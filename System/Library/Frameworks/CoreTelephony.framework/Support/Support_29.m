void sub_100FE3140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, __int16 a11, char a12, char a13, int a14, __int16 a15, char a16, char a17, int a18, const void *a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,const void *a33,__int16 a34,char a35,char a36,int a37,const void *a38,__int16 a39,char a40,char a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  std::__shared_weak_count *v47;
  uint64_t v48;

  if (a47 < 0) {
    operator delete(__p);
  }
  *(void *)(v48 - 144) = &a28;
  sub_10019E86C((void ***)(v48 - 144));
  if ((_BYTE)a11) {
    sub_100044D00(&a10);
  }
  if ((_BYTE)a20) {
    sub_100044D00(&a19);
  }
  if ((_BYTE)a34) {
    sub_100044D00(&a33);
  }
  if ((_BYTE)a39) {
    sub_100057D78(&a38);
  }
  sub_10004D2C8(v47);
  _Unwind_Resume(a1);
}

void sub_100FE329C(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    v19 = operator new(0x30uLL);
    v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7B3E0;
    *((_DWORD *)v19 + 6) = v21;
    v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE34CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE34E4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    v34 = ", ";
    __int16 v35 = 2080;
    v36 = v17;
    __int16 v37 = 2080;
    v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019B9CC(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE37D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE3848()
{
  return "getPreferredRoamingNetworks";
}

void sub_100FE3854(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B3E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE3874(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B3E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE38C8(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE38DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B430;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE38FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B430;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE3950(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE397C(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE39B4(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
LABEL_5:
    uint64_t v11 = (std::__shared_weak_count *)operator new(0x268uLL);
    v11->__shared_owners_ = 0;
    v11->__shared_weak_owners_ = 0;
    v11->__vftable = (std::__shared_weak_count_vtbl *)off_101A79BD0;
    v12 = v11 + 1;
    bzero(&v11[1], 0x250uLL);
    codec::fromJSONObject<entitlements::TransferAuthorizationResponse>((uint64_t)&v11[1], a3);
    v13 = *(os_log_t **)(a1 + 40);
    v14 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      *(void *)&buf[4] = v15;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&buf[24] = v16;
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransferAuthorization response: {", buf, 0x2Au);
      v13 = *(os_log_t **)(a1 + 40);
      v14 = *v13;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      v19 = sub_100FB56F4(a2);
      *(_DWORD *)buf = 136316162;
      *(void *)&buf[4] = v17;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&buf[24] = v18;
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      *(_WORD *)&buf[42] = 2082;
      *(void *)&buf[44] = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sstatus: %{public}s: ", buf, 0x34u);
      v13 = *(os_log_t **)(a1 + 40);
    }
    if (BYTE1(v11[1].__vftable))
    {
      v20 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!BYTE1(v11[1].__vftable)) {
          sub_10016C840();
        }
        uint64_t v23 = v22;
        uint64_t v24 = entitlements::asString();
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v21;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v23;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v24;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransferType: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[2].__shared_owners_))
    {
      int v25 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[2].__shared_owners_)) {
          sub_10016C840();
        }
        p_uint64_t shared_owners = &v11[1].__shared_owners_;
        if (SHIBYTE(v11[2].__vftable) < 0) {
          p_uint64_t shared_owners = (uint64_t *)*p_shared_owners;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v26;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v27;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = p_shared_owners;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTransferToken: %s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[3].__shared_weak_owners_))
    {
      CFTypeRef v29 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[3].__shared_weak_owners_)) {
          sub_10016C840();
        }
        p_shared_weak_owners = &v11[2].__shared_weak_owners_;
        if (SHIBYTE(v11[3].__shared_owners_) < 0) {
          p_shared_weak_owners = (uint64_t *)*p_shared_weak_owners;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v30;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v31;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = p_shared_weak_owners;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sExpirationTime: %s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[10].__shared_owners_))
    {
      __int16 v33 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v34;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v35;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTargetDevice: {", buf, 0x2Au);
        __int16 v33 = **(NSObject ***)(a1 + 40);
      }
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v36;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v37;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIccidStates: [", buf, 0x2Au);
      }
      if (!LOBYTE(v11[10].__shared_owners_)) {
        sub_10016C840();
      }
      v38 = v11[5].__vftable;
      for (uint64_t i = v11[5].__shared_owners_;
            v38 != (std::__shared_weak_count_vtbl *)i;
            v38 = (std::__shared_weak_count_vtbl *)((char *)v38 + 96))
      {
        long long v155 = 0u;
        long long v156 = 0u;
        memset(buf, 0, sizeof(buf));
        if (SHIBYTE(v38->__on_zero_shared) < 0)
        {
          sub_10004FC84(buf, v38->~__shared_weak_count, (unint64_t)v38->~__shared_weak_count_0);
        }
        else
        {
          long long v39 = *(_OWORD *)&v38->~__shared_weak_count;
          *(void *)&buf[16] = v38->__on_zero_shared;
          *(_OWORD *)buf = v39;
        }
        sub_1000593FC((uint64_t)&buf[24], (long long *)&v38->__get_deleter);
        sub_1000593FC((uint64_t)&buf[56], (long long *)&v38[1].__on_zero_shared);
        WORD4(v156) = v38[2].~__shared_weak_count_0;
        v40 = *(os_log_t **)(a1 + 40);
        v41 = *v40;
        if (os_log_type_enabled(*v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)v144 = 136315906;
          uint64_t v145 = v42;
          __int16 v146 = 2080;
          v147 = " ";
          __int16 v148 = 2080;
          uint64_t v149 = v43;
          __int16 v150 = 2080;
          v151 = ", ";
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s{", v144, 0x2Au);
          v40 = *(os_log_t **)(a1 + 40);
          v41 = *v40;
        }
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v44 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v45 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          v46 = buf;
          if ((buf[23] & 0x80u) != 0) {
            v46 = *(uint8_t **)buf;
          }
          *(_DWORD *)v144 = 136316162;
          uint64_t v145 = v44;
          __int16 v146 = 2080;
          v147 = " ";
          __int16 v148 = 2080;
          uint64_t v149 = v45;
          __int16 v150 = 2080;
          v151 = ", ";
          __int16 v152 = 2080;
          v153 = v46;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%siccid: %s", v144, 0x34u);
          v40 = *(os_log_t **)(a1 + 40);
        }
        if (buf[48])
        {
          v47 = *v40;
          if (os_log_type_enabled(*v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v48 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            if (!buf[48]) {
              sub_10016C840();
            }
            if ((buf[47] & 0x80u) == 0) {
              v50 = &buf[24];
            }
            else {
              v50 = *(uint8_t **)&buf[24];
            }
            *(_DWORD *)v144 = 136316162;
            uint64_t v145 = v48;
            __int16 v146 = 2080;
            v147 = " ";
            __int16 v148 = 2080;
            uint64_t v149 = v49;
            __int16 v150 = 2080;
            v151 = ", ";
            __int16 v152 = 2082;
            v153 = v50;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%simei: %{public}s", v144, 0x34u);
            v40 = *(os_log_t **)(a1 + 40);
          }
        }
        if ((_BYTE)v156)
        {
          v51 = *v40;
          if (os_log_type_enabled(*v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v52 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            if (!(_BYTE)v156) {
              sub_10016C840();
            }
            if (v155 >= 0) {
              v54 = &buf[56];
            }
            else {
              v54 = *(uint8_t **)&buf[56];
            }
            *(_DWORD *)v144 = 136316162;
            uint64_t v145 = v52;
            __int16 v146 = 2080;
            v147 = " ";
            __int16 v148 = 2080;
            uint64_t v149 = v53;
            __int16 v150 = 2080;
            v151 = ", ";
            __int16 v152 = 2082;
            v153 = v54;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%smeid: %{public}s", v144, 0x34u);
            v40 = *(os_log_t **)(a1 + 40);
          }
        }
        if (BYTE9(v156))
        {
          v55 = *v40;
          if (os_log_type_enabled(*v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v56 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v57 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            if (!BYTE9(v156)) {
              sub_10016C840();
            }
            *(_DWORD *)v144 = 136316162;
            uint64_t v145 = v56;
            __int16 v146 = 2080;
            v147 = " ";
            __int16 v148 = 2080;
            uint64_t v149 = v57;
            __int16 v150 = 2080;
            v151 = ", ";
            __int16 v152 = 1026;
            LODWORD(v153) = BYTE8(v156);
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sprofileRelease: %{public}d", v144, 0x30u);
            v40 = *(os_log_t **)(a1 + 40);
          }
        }
        v58 = *v40;
        if (os_log_type_enabled(*v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v59 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v60 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          *(_DWORD *)v144 = 136315906;
          uint64_t v145 = v59;
          __int16 v146 = 2080;
          v147 = " ";
          __int16 v148 = 2080;
          uint64_t v149 = v60;
          __int16 v150 = 2080;
          v151 = ", ";
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}", v144, 0x2Au);
        }
        if ((_BYTE)v156 && SHIBYTE(v155) < 0) {
          operator delete(*(void **)&buf[56]);
        }
        if (buf[48] && (char)buf[47] < 0) {
          operator delete(*(void **)&buf[24]);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
      }
      v61 = **(NSObject ***)(a1 + 40);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v62 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v63 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v62;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v63;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s]", buf, 0x2Au);
      }
      if (!LOBYTE(v11[10].__shared_owners_)) {
        sub_10016C840();
      }
      v13 = *(os_log_t **)(a1 + 40);
      v12 = v11 + 1;
      if (LOBYTE(v11[7].__vftable))
      {
        v64 = *v13;
        if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v65 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          if (!LOBYTE(v11[10].__shared_owners_) || !LOBYTE(v11[7].__vftable)) {
            sub_10016C840();
          }
          v67 = &v11[6].__vftable;
          if (SHIBYTE(v11[6].__shared_weak_owners_) < 0) {
            v67 = (void *)*v67;
          }
          *(_DWORD *)buf = 136316162;
          *(void *)&buf[4] = v65;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&buf[24] = v66;
          *(_WORD *)&buf[32] = 2080;
          *(void *)&buf[34] = ", ";
          *(_WORD *)&buf[42] = 2082;
          *(void *)&buf[44] = v67;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sDeviceType: %{public}s", buf, 0x34u);
          v13 = *(os_log_t **)(a1 + 40);
        }
      }
      v68 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v69 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[10].__shared_owners_)) {
          sub_10016C840();
        }
        v71 = &v11[4].__vftable;
        if (SHIBYTE(v11[4].__shared_weak_owners_) < 0) {
          v71 = (void *)*v71;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v69;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v70;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v71;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%seid: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v68 = *v13;
      }
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v72 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v73 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v72;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v73;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}", buf, 0x2Au);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[11].__shared_weak_owners_))
    {
      v74 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v75 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v76 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[11].__shared_weak_owners_)) {
          sub_10016C840();
        }
        v77 = &v11[10].__shared_weak_owners_;
        if (SHIBYTE(v11[11].__shared_owners_) < 0) {
          v77 = (uint64_t *)*v77;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v75;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v76;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = v77;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sCarrierTransferData: %s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[21].__vftable))
    {
      v78 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v79 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v80 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[21].__vftable)) {
          sub_10016C840();
        }
        v81 = &v11[20].__vftable;
        if (SHIBYTE(v11[20].__shared_weak_owners_) < 0) {
          v81 = (void *)*v81;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v79;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v80;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v81;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sWebServiceUrl: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[22].__shared_owners_))
    {
      v82 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v83 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v84 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[22].__shared_owners_)) {
          sub_10016C840();
        }
        v85 = &v11[21].__shared_owners_;
        if (SHIBYTE(v11[22].__vftable) < 0) {
          v85 = (uint64_t *)*v85;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v83;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v84;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2080;
        *(void *)&buf[44] = v85;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sWebServicePostData: %s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[23].__shared_weak_owners_))
    {
      v86 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v87 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v88 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[23].__shared_weak_owners_)) {
          sub_10016C840();
        }
        v89 = &v11[22].__shared_weak_owners_;
        if (SHIBYTE(v11[23].__shared_owners_) < 0) {
          v89 = (uint64_t *)*v89;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v87;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v88;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v89;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReasonCode: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[25].__vftable))
    {
      v90 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v91 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v92 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[25].__vftable)) {
          sub_10016C840();
        }
        v93 = &v11[24].__vftable;
        if (SHIBYTE(v11[24].__shared_weak_owners_) < 0) {
          v93 = (void *)*v93;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v91;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v92;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v93;
        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sReasonCodeUrl: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[16].__vftable))
    {
      v94 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v95 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v96 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v95;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v96;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sTermsAndConditions: {", buf, 0x2Au);
        v13 = *(os_log_t **)(a1 + 40);
        v94 = *v13;
      }
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v97 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v98 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[16].__vftable)) {
          sub_10016C840();
        }
        if (SHIBYTE(v11[12].__shared_weak_owners_) < 0) {
          uint64_t shared_owners = v11[12].__shared_owners_;
        }
        else {
          uint64_t shared_owners = HIBYTE(v11[12].__shared_weak_owners_);
        }
        v103 = "Present";
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v97;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        if (!shared_owners) {
          v103 = "Empty";
        }
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v98;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v103;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sMainText: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v94 = *v13;
      }
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v104 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v105 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[16].__vftable)) {
          sub_10016C840();
        }
        v106 = &v11[13].__vftable;
        if (SHIBYTE(v11[13].__shared_weak_owners_) < 0) {
          v106 = (void *)*v106;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v104;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v105;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v106;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sUserChoiceUrl: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v94 = *v13;
      }
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v107 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v108 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[16].__vftable)) {
          sub_10016C840();
        }
        v109 = &v11[14].__vftable;
        if (SHIBYTE(v11[14].__shared_weak_owners_) < 0) {
          v109 = (void *)*v109;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v107;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v108;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v109;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sAcceptPostData: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v94 = *v13;
      }
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v110 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v111 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[16].__vftable)) {
          sub_10016C840();
        }
        v112 = &v11[15].__vftable;
        if (SHIBYTE(v11[15].__shared_weak_owners_) < 0) {
          v112 = (void *)*v112;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v110;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v111;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v112;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sRejectPostData: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v94 = *v13;
      }
      if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v113 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v114 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v113;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v114;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}", buf, 0x2Au);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (LOBYTE(v11[19].__shared_weak_owners_))
    {
      v115 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v116 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v117 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v116;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v117;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sOtpContent: {", buf, 0x2Au);
        v13 = *(os_log_t **)(a1 + 40);
        v115 = *v13;
      }
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v118 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v119 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[19].__shared_weak_owners_)) {
          sub_10016C840();
        }
        v120 = &v11[16].__shared_owners_;
        if (SHIBYTE(v11[17].__vftable) < 0) {
          v120 = (uint64_t *)*v120;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v118;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v119;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v120;
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sLastFourNumbers: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v115 = *v13;
      }
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v121 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v122 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[19].__shared_weak_owners_)) {
          sub_10016C840();
        }
        v123 = &v11[17].__shared_owners_;
        if (SHIBYTE(v11[18].__vftable) < 0) {
          v123 = (uint64_t *)*v123;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v121;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v122;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v123;
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sOtpUrl: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v115 = *v13;
      }
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v124 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v125 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[19].__shared_weak_owners_)) {
          sub_10016C840();
        }
        v126 = &v11[18].__shared_owners_;
        if (SHIBYTE(v11[19].__vftable) < 0) {
          v126 = (uint64_t *)*v126;
        }
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v124;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v125;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v126;
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sOtpPostData: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v115 = *v13;
      }
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v127 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v128 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!LOBYTE(v11[19].__shared_weak_owners_)) {
          sub_10016C840();
        }
        uint64_t v129 = v128;
        uint64_t v130 = entitlements::asString();
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v127;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v129;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 2082;
        *(void *)&buf[44] = v130;
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sOtpState: %{public}s", buf, 0x34u);
        v13 = *(os_log_t **)(a1 + 40);
        v115 = *v13;
      }
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v131 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v132 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315906;
        *(void *)&buf[4] = v131;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v132;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}", buf, 0x2Au);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    if (BYTE1(v11[25].__shared_owners_))
    {
      v133 = *v13;
      if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v134 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
        uint64_t v135 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        if (!BYTE1(v11[25].__shared_owners_)) {
          sub_10016C840();
        }
        int shared_owners_low = LOBYTE(v11[25].__shared_owners_);
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = v134;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = v135;
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = ", ";
        *(_WORD *)&buf[42] = 1026;
        *(_DWORD *)&buf[44] = shared_owners_low;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sIsWebView: %{public}d", buf, 0x30u);
        v13 = *(os_log_t **)(a1 + 40);
      }
    }
    v137 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v138 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v139 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      *(void *)&buf[4] = v138;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&buf[24] = v139;
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%s}\n", buf, 0x2Au);
    }
    goto LABEL_177;
  }
  if (a2 == 6013)
  {
    v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      *(void *)&buf[4] = v9;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&buf[24] = v10;
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%stransfer authorization response redirecting to webservice", buf, 0x2Au);
    }
    goto LABEL_5;
  }
  v100 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v101 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v102 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)buf = 136315906;
    *(void *)&buf[4] = v101;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&buf[24] = v102;
    *(_WORD *)&buf[32] = 2080;
    *(void *)&buf[34] = ", ";
    _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
  }
  uint64_t v11 = 0;
  v12 = 0;
LABEL_177:
  v140 = operator new(0x30uLL);
  v141 = v140;
  v140[1] = 0;
  v140[2] = 0;
  void *v140 = off_101A7B508;
  v142 = (char *)(v140 + 3);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v140 + 6) = a2;
    v140[4] = v12;
    v140[5] = v11;
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    sub_10004D2C8(v11);
  }
  else
  {
    *((_DWORD *)v140 + 6) = a2;
    v140[4] = v12;
    v140[5] = 0;
  }
  *a4 = v142;
  a4[1] = v141;
}

void sub_100FE5A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
}

void sub_100FE5B44(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    v19 = operator new(0x30uLL);
    v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7B508;
    *((_DWORD *)v19 + 6) = v21;
    v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE5D74(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE5D8C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019BC88(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE6080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE60F0()
{
  return "transferAuthorization";
}

void sub_100FE60FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B508;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE611C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B508;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE6170(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE6184(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B558;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE61A4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B558;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE61F8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE6224(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE625C(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  int v4 = a2;
  uint64_t v5 = a1;
  if (a2 == 6000)
  {
    v8 = (std::__shared_weak_count *)operator new(0x30uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8[1].__vftable = 0;
    uint64_t v9 = &v8[1].__vftable;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A79CC0;
    v8[1].__shared_owners_ = 0;
    v8[1].__shared_weak_owners_ = 0;
    uint64_t v97 = v8;
    CFTypeRef cf = 0;
    uint64_t v117 = 0;
    Value = CFDictionaryGetValue(a3, *(const void **)(v5 + 48));
    sub_100FC3AEC(&cf, Value);
    uint64_t v95 = a4;
    if ((_BYTE)v117)
    {
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      CFTypeRef v111 = cf;
      if (cf)
      {
        CFRetain(cf);
        uint64_t v11 = (void *)v111;
      }
      else
      {
        uint64_t v11 = 0;
      }
      sub_100044D00(&v111);
      id v21 = [v11 countByEnumeratingWithState:&v112 objects:buf count:16];
      if (!v21) {
        goto LABEL_101;
      }
      uint64_t v99 = *(void *)v113;
      *(void *)&long long v22 = 136316162;
      long long v93 = v22;
      v94 = v9;
      uint64_t v96 = (PersonalityInfo ***)v5;
LABEL_13:
      uint64_t v100 = 0;
      id v98 = v21;
      while (1)
      {
        if (*(void *)v113 != v99) {
          objc_enumerationMutation(v11);
        }
        uint64_t v23 = *(void **)(*((void *)&v112 + 1) + 8 * v100);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v32 = **(NSObject ***)(v5 + 40);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
            uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
            *(_DWORD *)uint64_t v118 = 136315906;
            *(void *)&v118[4] = v33;
            *(_WORD *)&v118[12] = 2080;
            *(void *)&v118[14] = " ";
            *(_WORD *)&v118[22] = 2080;
            uint64_t v119 = (char *)v34;
            *(_WORD *)v120 = 2080;
            *(void *)&v120[2] = ", ";
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sArray item in response is of wrong format, expecting Dictionary", v118, 0x2Au);
          }
          goto LABEL_91;
        }
        id v24 = [v23 objectForKey:*(void *)(v5 + 56)];
        if (!v24)
        {
          uint64_t v16 = **(NSObject ***)(v5 + 40);
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_101;
          }
          uint64_t v80 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
          uint64_t v81 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
          *(_DWORD *)uint64_t v118 = 136315906;
          *(void *)&v118[4] = v80;
          *(_WORD *)&v118[12] = 2080;
          *(void *)&v118[14] = " ";
          *(_WORD *)&v118[22] = 2080;
          uint64_t v119 = (char *)v81;
          *(_WORD *)v120 = 2080;
          *(void *)&v120[2] = ", ";
          v19 = "#W %s%s%s%sno scope atatus in response";
LABEL_98:
          v20 = v118;
          goto LABEL_99;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v16 = **(NSObject ***)(v5 + 40);
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_101;
          }
          uint64_t v82 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
          uint64_t v83 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
          *(_DWORD *)uint64_t v118 = 136315906;
          *(void *)&v118[4] = v82;
          *(_WORD *)&v118[12] = 2080;
          *(void *)&v118[14] = " ";
          *(_WORD *)&v118[22] = 2080;
          uint64_t v119 = (char *)v83;
          *(_WORD *)v120 = 2080;
          *(void *)&v120[2] = ", ";
          v19 = "#W %s%s%s%sinvalid scope status format, expecting number";
          goto LABEL_98;
        }
        unsigned int v25 = [v24 intValue];
        unsigned int v26 = v25;
        if (v25 - 6000 >= 3 && v25 != 6005)
        {
          v89 = **(NSObject ***)(v5 + 40);
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v91 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
            uint64_t v92 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
            *(_DWORD *)uint64_t v118 = v93;
            *(void *)&v118[4] = v91;
            *(_WORD *)&v118[12] = 2080;
            *(void *)&v118[14] = " ";
            *(_WORD *)&v118[22] = 2080;
            uint64_t v119 = (char *)v92;
            *(_WORD *)v120 = 2080;
            *(void *)&v120[2] = ", ";
            __int16 v121 = 1024;
            LODWORD(v122) = v26;
            v19 = "#W %s%s%s%sunknown scope status: %d";
            v20 = v118;
            uint64_t v84 = v89;
            uint32_t v85 = 48;
            goto LABEL_100;
          }
          goto LABEL_101;
        }
        long long v109 = 0u;
        memset(v110, 0, sizeof(v110));
        LODWORD(v110[0]) = v25;
        *(_OWORD *)__p = 0u;
        CFTypeRef v28 = CFDictionaryGetValue((CFDictionaryRef)v23, *(const void **)(v5 + 64));
        sub_100FC2A7C(__p, v5, v28, *(void **)(v5 + 64));
        if (!BYTE8(v109)) {
          break;
        }
        if ((SBYTE7(v109) & 0x80u) == 0) {
          CFTypeRef v29 = __p;
        }
        else {
          CFTypeRef v29 = (void **)__p[0];
        }
        DWORD1(v110[0]) = ![+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v29, v93) isEqualToString:@"wifi-pseudonym"];
        if ((BYTE4(v110[0]) & 1) == 0)
        {
          CFTypeRef v106 = 0;
          uint64_t v107 = 0;
          __int16 v30 = CFDictionaryGetValue((CFDictionaryRef)v23, *(const void **)(v5 + 72));
          sub_100FC3AEC(&v106, v30);
          if ((_BYTE)v107)
          {
            long long v104 = 0u;
            long long v105 = 0u;
            long long v102 = 0u;
            long long v103 = 0u;
            CFTypeRef v101 = v106;
            if (v106)
            {
              CFRetain(v106);
              __int16 v31 = (void *)v101;
            }
            else
            {
              __int16 v31 = 0;
            }
            sub_100044D00(&v101);
            uint64_t v49 = (char *)[v31 countByEnumeratingWithState:&v102 objects:v124 count:16];
            if (v49)
            {
              uint64_t v50 = *(void *)v103;
              do
              {
                for (uint64_t i = 0; i != v49; ++i)
                {
                  if (*(void *)v103 != v50) {
                    objc_enumerationMutation(v31);
                  }
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    memset(v118, 0, sizeof(v118));
                    ctu::cf::assign();
                    uint64_t v52 = *(void *)v118;
                    v123[0] = *(void *)&v118[8];
                    *(void *)((char *)v123 + 7) = *(void *)&v118[15];
                    uint8_t v53 = v118[23];
                    uint64_t v54 = *(void *)&v110[1];
                    if (*(void *)&v110[1] >= *((void *)&v110[1] + 1))
                    {
                      unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v110[1] - *((void *)&v110[0] + 1)) >> 3);
                      unint64_t v58 = v57 + 1;
                      if (v57 + 1 > 0xAAAAAAAAAAAAAAALL) {
                        sub_1000D8578();
                      }
                      if (0x5555555555555556
                         * ((uint64_t)(*((void *)&v110[1] + 1) - *((void *)&v110[0] + 1)) >> 3) > v58)
                        unint64_t v58 = 0x5555555555555556
                            * ((uint64_t)(*((void *)&v110[1] + 1) - *((void *)&v110[0] + 1)) >> 3);
                      if (0xAAAAAAAAAAAAAAABLL
                         * ((uint64_t)(*((void *)&v110[1] + 1) - *((void *)&v110[0] + 1)) >> 3) >= 0x555555555555555)
                        unint64_t v59 = 0xAAAAAAAAAAAAAAALL;
                      else {
                        unint64_t v59 = v58;
                      }
                      *(void *)v120 = (char *)&v110[1] + 8;
                      if (v59) {
                        uint64_t v60 = (char *)sub_10004812C((uint64_t)&v110[1] + 8, v59);
                      }
                      else {
                        uint64_t v60 = 0;
                      }
                      v61 = &v60[24 * v57];
                      *(void *)uint64_t v118 = v60;
                      *(void *)&v118[8] = v61;
                      uint64_t v119 = &v60[24 * v59];
                      uint64_t v62 = v123[0];
                      *(void *)v61 = v52;
                      *((void *)v61 + 1) = v62;
                      *(void *)(v61 + 15) = *(void *)((char *)v123 + 7);
                      v61[23] = v53;
                      *(void *)&v118[16] = v61 + 24;
                      sub_100048204((uint64_t *)v110 + 1, v118);
                      uint64_t v56 = *(void *)&v110[1];
                      sub_100048174((uint64_t)v118);
                    }
                    else
                    {
                      uint64_t v55 = v123[0];
                      **(void **)&v110[1] = *(void *)v118;
                      *(void *)(v54 + 8) = v55;
                      *(void *)(v54 + 15) = *(void *)((char *)v123 + 7);
                      *(unsigned char *)(v54 + 23) = v53;
                      uint64_t v56 = v54 + 24;
                    }
                    *(void *)&v110[1] = v56;
                  }
                }
                uint64_t v49 = (char *)[v31 countByEnumeratingWithState:&v102 objects:v124 count:16];
              }
              while (v49);
            }
          }
          else
          {
            uint64_t v45 = **(NSObject ***)(v5 + 40);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v46 = PersonalityInfo::logPrefix(*v96[3]);
              uint64_t v47 = ((uint64_t (*)(PersonalityInfo ***))(*v96)[5])(v96);
              uint64_t v48 = __p;
              if (SBYTE7(v109) < 0) {
                uint64_t v48 = (void **)__p[0];
              }
              *(_DWORD *)uint64_t v118 = v93;
              *(void *)&v118[4] = v46;
              *(_WORD *)&v118[12] = 2080;
              *(void *)&v118[14] = " ";
              *(_WORD *)&v118[22] = 2080;
              uint64_t v119 = (char *)v47;
              *(_WORD *)v120 = 2080;
              *(void *)&v120[2] = ", ";
              __int16 v121 = 2080;
              uint64_t v122 = v48;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sNo Tokens provided for scope:%s", v118, 0x34u);
            }
          }
          uint64_t shared_owners = (void *)v97[1].__shared_owners_;
          unint64_t shared_weak_owners = v97[1].__shared_weak_owners_;
          if ((unint64_t)shared_owners >= shared_weak_owners)
          {
            uint64_t v9 = v94;
            uint64_t v66 = (void *)*v94;
            uint64_t v67 = ((uint64_t)shared_owners - *v94) >> 5;
            unint64_t v68 = v67 + 1;
            if ((unint64_t)(v67 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v69 = shared_weak_owners - (void)v66;
            if (v69 >> 4 > v68) {
              unint64_t v68 = v69 >> 4;
            }
            if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v70 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v70 = v68;
            }
            if (v70 >> 59) {
              sub_10006A7CC();
            }
            v71 = (char *)operator new(32 * v70);
            uint64_t v5 = (uint64_t)v96;
            uint64_t v72 = &v71[32 * v67];
            uint64_t v73 = *((void *)&v110[1] + 1);
            *(void *)uint64_t v72 = *(void *)&v110[0];
            v74 = &v71[32 * v70];
            *(_OWORD *)(v72 + 8) = *(_OWORD *)((char *)v110 + 8);
            *((void *)v72 + 3) = v73;
            memset((char *)v110 + 8, 0, 24);
            uint64_t v65 = v72 + 32;
            if (shared_owners == v66)
            {
              v97[1].__vftable = (std::__shared_weak_count_vtbl *)v72;
              v97[1].__shared_owners_ = (uint64_t)v65;
              v97[1].__shared_weak_owners_ = (uint64_t)v74;
            }
            else
            {
              uint64_t v75 = 0;
              do
              {
                uint64_t v76 = &v72[v75 * 8];
                v77 = &shared_owners[v75];
                *((void *)v76 - 4) = shared_owners[v75 - 4];
                *((void *)v76 - 3) = 0;
                *((void *)v76 - 2) = 0;
                *((void *)v76 - 1) = 0;
                *(_OWORD *)(v76 - 24) = *(_OWORD *)&shared_owners[v75 - 3];
                *((void *)v76 - 1) = shared_owners[v75 - 1];
                *(v77 - 3) = 0;
                *(v77 - 2) = 0;
                *(v77 - 1) = 0;
                v75 -= 4;
              }
              while (&shared_owners[v75] != v66);
              uint64_t shared_owners = &v97[1].~__shared_weak_count;
              v78 = (void *)v97[1].__shared_owners_;
              v97[1].__vftable = (std::__shared_weak_count_vtbl *)&v72[v75 * 8];
              v97[1].__shared_owners_ = (uint64_t)v65;
              v97[1].__shared_weak_owners_ = (uint64_t)v74;
              if (v78 != shared_owners)
              {
                do
                {
                  uint64_t v79 = v78 - 4;
                  *(void *)uint64_t v118 = v78 - 3;
                  sub_100047F64((void ***)v118);
                  v78 = v79;
                }
                while (v79 != shared_owners);
              }
            }
            if (shared_owners) {
              operator delete(shared_owners);
            }
          }
          else
          {
            *uint64_t shared_owners = *(void *)&v110[0];
            shared_owners[1] = 0;
            shared_owners[2] = 0;
            shared_owners[3] = 0;
            *(_OWORD *)(shared_owners + 1) = *(_OWORD *)((char *)v110 + 8);
            shared_owners[3] = *((void *)&v110[1] + 1);
            memset((char *)v110 + 8, 0, 24);
            uint64_t v65 = shared_owners + 4;
            uint64_t v9 = v94;
            uint64_t v5 = (uint64_t)v96;
          }
          v97[1].__shared_owners_ = (uint64_t)v65;
          if ((_BYTE)v107) {
            sub_100044D00(&v106);
          }
          goto LABEL_87;
        }
        v41 = **(NSObject ***)(v5 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
          uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
          uint64_t v44 = __p;
          if (SBYTE7(v109) < 0) {
            uint64_t v44 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v118 = v93;
          *(void *)&v118[4] = v42;
          *(_WORD *)&v118[12] = 2080;
          *(void *)&v118[14] = " ";
          *(_WORD *)&v118[22] = 2080;
          uint64_t v119 = (char *)v43;
          *(_WORD *)v120 = 2080;
          *(void *)&v120[2] = ", ";
          __int16 v121 = 2080;
          uint64_t v122 = v44;
          v38 = v41;
          long long v39 = "#W %s%s%s%sToken name '%s' is not valid one";
          uint32_t v40 = 52;
LABEL_40:
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v39, v118, v40);
        }
LABEL_87:
        if (BYTE8(v109) && SBYTE7(v109) < 0) {
          operator delete(__p[0]);
        }
        *(void *)uint64_t v118 = (char *)v110 + 8;
        sub_100047F64((void ***)v118);
LABEL_91:
        if ((id)++v100 == v98)
        {
          id v21 = [v11 countByEnumeratingWithState:&v112 objects:buf count:16];
          if (v21) {
            goto LABEL_13;
          }
          goto LABEL_101;
        }
      }
      __int16 v35 = **(NSObject ***)(v5 + 40);
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_87;
      }
      uint64_t v36 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
      *(_DWORD *)uint64_t v118 = 136315906;
      *(void *)&v118[4] = v36;
      *(_WORD *)&v118[12] = 2080;
      *(void *)&v118[14] = " ";
      *(_WORD *)&v118[22] = 2080;
      uint64_t v119 = (char *)v37;
      *(_WORD *)v120 = 2080;
      *(void *)&v120[2] = ", ";
      v38 = v35;
      long long v39 = "#W %s%s%s%sScope name is not given";
      uint32_t v40 = 42;
      goto LABEL_40;
    }
    uint64_t v16 = **(NSObject ***)(v5 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
      *(_DWORD *)buf = 136315906;
      uint64_t v126 = v17;
      __int16 v127 = 2080;
      uint64_t v128 = " ";
      __int16 v129 = 2080;
      uint64_t v130 = v18;
      __int16 v131 = 2080;
      uint64_t v132 = ", ";
      v19 = "#W %s%s%s%sResponse is of wrong format, expecting Array";
      v20 = buf;
LABEL_99:
      uint64_t v84 = v16;
      uint32_t v85 = 42;
LABEL_100:
      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, v19, v20, v85);
    }
LABEL_101:
    if ((_BYTE)v117) {
      sub_100044D00(&cf);
    }
    uint64_t v15 = v97;
    a4 = v95;
    int v4 = 6000;
  }
  else
  {
    v12 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
      *(_DWORD *)buf = 136315906;
      uint64_t v126 = v13;
      __int16 v127 = 2080;
      uint64_t v128 = " ";
      __int16 v129 = 2080;
      uint64_t v130 = v14;
      __int16 v131 = 2080;
      uint64_t v132 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    uint64_t v9 = 0;
    uint64_t v15 = 0;
  }
  v86 = operator new(0x30uLL);
  uint64_t v87 = v86;
  v86[1] = 0;
  v86[2] = 0;
  void *v86 = off_101A7B600;
  uint64_t v88 = (char *)(v86 + 3);
  if (v15)
  {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v86 + 6) = v4;
    v86[4] = v9;
    v86[5] = v15;
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    sub_10004D2C8(v15);
  }
  else
  {
    *((_DWORD *)v86 + 6) = v4;
    v86[4] = v9;
    v86[5] = 0;
  }
  *a4 = v88;
  a4[1] = v87;
}

void sub_100FE6F98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,const void *a53,__int16 a54)
{
  if ((_BYTE)a54) {
    sub_100044D00(&a53);
  }
  sub_10004D2C8(a17);
  _Unwind_Resume(a1);
}

void sub_100FE70C0(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    unsigned int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    v19 = operator new(0x30uLL);
    v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7B600;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE72F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE7308(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019BF44(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE75FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE766C()
{
  return "getAuthorizationTokens";
}

void sub_100FE7678(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B600;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE7698(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B600;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE76EC(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE7700(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B650;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE7720(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B650;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE7774(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE77A0(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE77D8(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, _OWORD *a4@<X8>)
{
  int v13 = a2;
  uint64_t v11 = 0;
  v12 = 0;
  if (a2 == 6000)
  {
    v6 = (std::__shared_weak_count *)operator new(0x20uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
    CFDictionaryRemoveValue(MutableCopy, @"status");
    sub_10004EFE4(&v14, (CFTypeRef *)&MutableCopy);
    *(void *)buf = v6[1].__vftable;
    v6[1].__vftable = v14;
    uint64_t v14 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v14);
    sub_10005717C((const void **)&MutableCopy);
    uint64_t v11 = v6 + 1;
    v12 = v6;
  }
  else
  {
    v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v17 = 2080;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      v20 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
  }
  sub_1003B1590(&v13, (uint64_t *)&v11, buf);
  *a4 = *(_OWORD *)buf;
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100FE79BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10005717C((const void **)va);
  sub_10004D2C8(v6);
  _Unwind_Resume(a1);
}

void sub_100FE79F4(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2080;
    int v25 = ", ";
    __int16 v26 = 2080;
    uint64_t v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    uint64_t v14 = *(std::__shared_weak_count **)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)buf = v15;
      *(void *)&buf[8] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v16 = *(std::__shared_weak_count **)(v13 + 16);
      *(void *)(v13 + 8) = v15;
      *(void *)(v13 + 16) = v14;
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_10004D2C8(v14);
      *a4 = v13;
      a4[1] = v12;
LABEL_17:
      sub_10004D2C8(v14);
      return;
    }
    *(void *)(v13 + 16) = 0;
    *a4 = v13;
    a4[1] = v12;
  }
  else
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = 0;
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    int v19 = v17;
    sub_100625330(&v19, (uint64_t *)buf, &v20);
    long long v18 = v20;
    long long v20 = 0uLL;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    uint64_t v14 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)a4 = v18;
    if (v14) {
      goto LABEL_17;
    }
  }
}

void sub_100FE7C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE7C54(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      long long v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      long long v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1006BA148(v22, a2, a4, buf, &v29, &v28);
        }
        if (!v25)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE7F48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE7FB8()
{
  return "getLinkCharacteristics";
}

void sub_100FE7FC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE7FE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B728;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE8038(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE8064(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE809C(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, _OWORD *a4@<X8>)
{
  int v13 = a2;
  uint64_t v11 = 0;
  v12 = 0;
  if (a2 == 6000)
  {
    v6 = (std::__shared_weak_count *)operator new(0x20uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019C4240;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
    CFDictionaryRemoveValue(MutableCopy, @"status");
    sub_10004EFE4(&v14, (CFTypeRef *)&MutableCopy);
    *(void *)buf = v6[1].__vftable;
    v6[1].__vftable = v14;
    uint64_t v14 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v14);
    sub_10005717C((const void **)&MutableCopy);
    uint64_t v11 = v6 + 1;
    v12 = v6;
  }
  else
  {
    v8 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v17 = 2080;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      long long v20 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
  }
  sub_1003B1590(&v13, (uint64_t *)&v11, buf);
  *a4 = *(_OWORD *)buf;
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100FE8280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10005717C((const void **)va);
  sub_10004D2C8(v6);
  _Unwind_Resume(a1);
}

void sub_100FE82B8(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)buf = 136316162;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v22 = 2080;
    uint64_t v23 = v10;
    __int16 v24 = 2080;
    int v25 = ", ";
    __int16 v26 = 2080;
    uint64_t v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", buf, 0x34u);
  }
  uint64_t v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    uint64_t v14 = *(std::__shared_weak_count **)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      *(void *)buf = v15;
      *(void *)&buf[8] = v14;
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v16 = *(std::__shared_weak_count **)(v13 + 16);
      *(void *)(v13 + 8) = v15;
      *(void *)(v13 + 16) = v14;
      if (v16) {
        sub_10004D2C8(v16);
      }
      sub_10004D2C8(v14);
      *a4 = v13;
      a4[1] = v12;
LABEL_17:
      sub_10004D2C8(v14);
      return;
    }
    *(void *)(v13 + 16) = 0;
    *a4 = v13;
    a4[1] = v12;
  }
  else
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = 0;
    if (*(unsigned char *)(a3 + 4)) {
      int v17 = *(_DWORD *)a3;
    }
    else {
      int v17 = 6005;
    }
    int v19 = v17;
    sub_100625330(&v19, (uint64_t *)buf, &v20);
    long long v18 = v20;
    long long v20 = 0uLL;
    if (v12)
    {
      sub_10004D2C8(v12);
      if (*((void *)&v20 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
      }
    }
    uint64_t v14 = *(std::__shared_weak_count **)&buf[8];
    *(_OWORD *)a4 = v18;
    if (v14) {
      goto LABEL_17;
    }
  }
}

void sub_100FE84F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE8518(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      long long v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      long long v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    uint64_t v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  int v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_1006BA2FC(v22, a2, a4, buf, &v29, &v28);
        }
        if (!v25)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE880C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE887C()
{
  return "setEnhancedSession";
}

void sub_100FE8888(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B800;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE88A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B800;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE88FC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE8928(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE8960(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  int v4 = a2;
  if (a2 != 6000)
  {
    v12 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      uint64_t v111 = v13;
      __int16 v112 = 2080;
      long long v113 = " ";
      __int16 v114 = 2080;
      uint64_t v115 = v14;
      __int16 v116 = 2080;
      uint64_t v117 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_106;
  }
  v8 = (char *)operator new(0x30uLL);
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *((void *)v8 + 3) = 0;
  uint64_t v9 = (uint64_t *)(v8 + 24);
  *(void *)v8 = off_101A79D10;
  *((void *)v8 + 4) = 0;
  *((void *)v8 + 5) = 0;
  CFTypeRef cf = 0;
  uint64_t v101 = 0;
  Value = CFDictionaryGetValue(a3, *(const void **)(a1 + 48));
  sub_100FC3AEC(&cf, Value);
  if (!(_BYTE)v101) {
    goto LABEL_106;
  }
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  CFTypeRef v95 = cf;
  if (cf)
  {
    CFRetain(cf);
    uint64_t v11 = (void *)v95;
  }
  else
  {
    uint64_t v11 = 0;
  }
  uint64_t v72 = a4;
  sub_100044D00(&v95);
  id v15 = [v11 countByEnumeratingWithState:&v96 objects:buf count:16];
  if (!v15) {
    goto LABEL_104;
  }
  uint64_t v76 = *(void *)v97;
  std::string::size_type v16 = (std::string::size_type)(v8 + 40);
  uint64_t v79 = v8;
  uint64_t v73 = v11;
  v74 = (uint64_t *)(v8 + 24);
  while (2)
  {
    v77 = 0;
    id v75 = v15;
    do
    {
      if (*(void *)v97 != v76) {
        objc_enumerationMutation(v11);
      }
      int v17 = *(void **)(*((void *)&v96 + 1) + 8 * (void)v77);
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v18 = [v17 objectForKey:*(void *)(a1 + 56)];
        if (v18)
        {
          id v19 = [v17 objectForKey:*(void *)(a1 + 64)];
          if (v19)
          {
            if ([v17 objectForKey:*(void *)(a1 + 72)])
            {
              v109[0] = 0;
              int64x2_t v108 = 0u;
              memset(__p, 0, sizeof(__p));
              *(_OWORD *)long long v93 = 0u;
              long long v94 = 0u;
              sub_100FC2A7C(v93, a1, v18, *(void **)(a1 + 56));
              if (BYTE8(v94))
              {
                if (SBYTE7(v94) < 0)
                {
                  sub_10004FC84(&__dst, v93[0], (unint64_t)v93[1]);
                }
                else
                {
                  long long __dst = *(_OWORD *)v93;
                  uint64_t v81 = (char *)v94;
                }
              }
              else
              {
                long long __dst = 0uLL;
                uint64_t v81 = 0;
              }
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
              *(_OWORD *)__p = __dst;
              __p[2] = v81;
              *(_OWORD *)uint64_t v91 = 0u;
              long long v92 = 0u;
              sub_100FC2A7C(v91, a1, v19, *(void **)(a1 + 64));
              if (BYTE8(v92))
              {
                if (SBYTE7(v92) < 0)
                {
                  sub_10004FC84(&__dst, v91[0], (unint64_t)v91[1]);
                }
                else
                {
                  long long __dst = *(_OWORD *)v91;
                  uint64_t v81 = (char *)v92;
                }
              }
              else
              {
                long long __dst = 0uLL;
                uint64_t v81 = 0;
              }
              if (SHIBYTE(__p[5]) < 0) {
                operator delete(__p[3]);
              }
              *(_OWORD *)&__p[3] = __dst;
              __p[5] = v81;
              CFTypeRef v89 = 0;
              uint64_t v90 = 0;
              long long v20 = CFDictionaryGetValue((CFDictionaryRef)v17, *(const void **)(a1 + 72));
              sub_100FC3AEC(&v89, v20);
              if ((_BYTE)v90)
              {
                long long v87 = 0u;
                long long v88 = 0u;
                long long v85 = 0u;
                long long v86 = 0u;
                CFTypeRef v84 = v89;
                if (v89)
                {
                  CFRetain(v89);
                  int v21 = (void *)v84;
                }
                else
                {
                  int v21 = 0;
                }
                sub_100044D00(&v84);
                id v22 = [v21 countByEnumeratingWithState:&v85 objects:v106 count:16];
                if (v22)
                {
                  uint64_t v23 = *(void *)v86;
                  id obj = v21;
                  do
                  {
                    for (uint64_t i = 0; i != v22; uint64_t i = (char *)i + 1)
                    {
                      if (*(void *)v86 != v23) {
                        objc_enumerationMutation(obj);
                      }
                      int v25 = *(void **)(*((void *)&v85 + 1) + 8 * i);
                      id v26 = [v25 objectForKey:*(void *)(a1 + 88)];
                      id v27 = [v25 objectForKey:*(void *)(a1 + 96)];
                      std::string::size_type v28 = v16;
                      id v29 = [v25 objectForKey:*(void *)(a1 + 104)];
                      id v30 = [v25 objectForKey:*(void *)(a1 + 80)];
                      uint64_t v31 = sub_100FC3664(a1, v26, *(void **)(a1 + 88));
                      uint64_t v32 = sub_100FC3664(a1, v27, *(void **)(a1 + 96));
                      LODWORD(v29) = sub_100FC2DC4(a1, v29, *(void **)(a1 + 104));
                      memset(__str, 0, sizeof(__str));
                      sub_100FC2A7C(__str, a1, v30, *(void **)(a1 + 80));
                      memset(&v82, 0, sizeof(v82));
                      *((void *)&__dst + 1) = v32;
                      uint64_t v81 = (char *)v31;
                      *(double *)&long long __dst = (double)(int)v29;
                      v8 = v79;
                      std::string::operator=(&v82, (const std::string *)__str);
                      uint64_t v33 = v108.i64[1];
                      if (v108.i64[1] >= v109[0])
                      {
                        unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((v108.i64[1] - v108.i64[0]) >> 4);
                        unint64_t v38 = v37 + 1;
                        if (v37 + 1 > 0x555555555555555) {
                          sub_10006A748();
                        }
                        if (0x5555555555555556 * ((v109[0] - v108.i64[0]) >> 4) > v38) {
                          unint64_t v38 = 0x5555555555555556 * ((v109[0] - v108.i64[0]) >> 4);
                        }
                        if (0xAAAAAAAAAAAAAAABLL * ((v109[0] - v108.i64[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                          unint64_t v39 = 0x555555555555555;
                        }
                        else {
                          unint64_t v39 = v38;
                        }
                        long long v105 = v109;
                        if (v39) {
                          uint32_t v40 = (char *)sub_10019F624((uint64_t)v109, v39);
                        }
                        else {
                          uint32_t v40 = 0;
                        }
                        uint64_t v42 = &v40[48 * v37];
                        long long v102 = v40;
                        v103.i64[0] = (uint64_t)v42;
                        v103.i64[1] = (uint64_t)v42;
                        long long v104 = &v40[48 * v39];
                        long long v43 = __dst;
                        *((void *)v42 + 2) = v81;
                        *(_OWORD *)uint64_t v42 = v43;
                        uint64_t v44 = v42 + 24;
                        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
                        {
                          sub_10004FC84(v44, v82.__r_.__value_.__l.__data_, v82.__r_.__value_.__l.__size_);
                          uint64_t v46 = (char *)v103.i64[1];
                          uint64_t v42 = (char *)v103.i64[0];
                        }
                        else
                        {
                          long long v45 = *(_OWORD *)&v82.__r_.__value_.__l.__data_;
                          *((void *)v42 + 5) = *((void *)&v82.__r_.__value_.__l + 2);
                          *(_OWORD *)uint64_t v44 = v45;
                          uint64_t v46 = v42;
                        }
                        uint64_t v47 = v108.i64[1];
                        uint64_t v48 = v108.i64[0];
                        if (v108.i64[1] == v108.i64[0])
                        {
                          int64x2_t v51 = vdupq_n_s64(v108.u64[1]);
                        }
                        else
                        {
                          do
                          {
                            long long v49 = *(_OWORD *)(v47 - 48);
                            *((void *)v42 - 4) = *(void *)(v47 - 32);
                            *((_OWORD *)v42 - 3) = v49;
                            long long v50 = *(_OWORD *)(v47 - 24);
                            *((void *)v42 - 1) = *(void *)(v47 - 8);
                            *(_OWORD *)(v42 - 24) = v50;
                            v42 -= 48;
                            *(void *)(v47 - 16) = 0;
                            *(void *)(v47 - 8) = 0;
                            *(void *)(v47 - 24) = 0;
                            v47 -= 48;
                          }
                          while (v47 != v48);
                          int64x2_t v51 = v108;
                        }
                        uint64_t v41 = (uint64_t)(v46 + 48);
                        v108.i64[0] = (uint64_t)v42;
                        v108.i64[1] = (uint64_t)(v46 + 48);
                        int64x2_t v103 = v51;
                        uint64_t v52 = (char *)v109[0];
                        v109[0] = v104;
                        long long v104 = v52;
                        long long v102 = (char *)v51.i64[0];
                        sub_100FC8928((uint64_t)&v102);
                      }
                      else
                      {
                        long long v34 = __dst;
                        *(void *)(v108.i64[1] + 16) = v81;
                        *(_OWORD *)uint64_t v33 = v34;
                        __int16 v35 = (unsigned char *)(v33 + 24);
                        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
                        {
                          sub_10004FC84(v35, v82.__r_.__value_.__l.__data_, v82.__r_.__value_.__l.__size_);
                        }
                        else
                        {
                          long long v36 = *(_OWORD *)&v82.__r_.__value_.__l.__data_;
                          *(void *)(v33 + 40) = *((void *)&v82.__r_.__value_.__l + 2);
                          *(_OWORD *)__int16 v35 = v36;
                        }
                        uint64_t v41 = v33 + 48;
                      }
                      v108.i64[1] = v41;
                      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v82.__r_.__value_.__l.__data_);
                      }
                      std::string::size_type v16 = v28;
                      if (__str[24] && (__str[23] & 0x80000000) != 0) {
                        operator delete(*(void **)__str);
                      }
                    }
                    id v22 = [obj countByEnumeratingWithState:&v85 objects:v106 count:16];
                  }
                  while (v22);
                }
              }
              unint64_t v54 = *((void *)v8 + 4);
              unint64_t v53 = *((void *)v8 + 5);
              if (v54 >= v53)
              {
                uint64_t v9 = v74;
                unint64_t v56 = 0x8E38E38E38E38E39 * ((uint64_t)(v54 - *v74) >> 3);
                unint64_t v57 = v56 + 1;
                if (v56 + 1 > 0x38E38E38E38E38ELL) {
                  sub_10006A748();
                }
                unint64_t v58 = 0x8E38E38E38E38E39 * ((uint64_t)(v53 - *v74) >> 3);
                if (2 * v58 > v57) {
                  unint64_t v57 = 2 * v58;
                }
                if (v58 >= 0x1C71C71C71C71C7) {
                  unint64_t v59 = 0x38E38E38E38E38ELL;
                }
                else {
                  unint64_t v59 = v57;
                }
                v82.__r_.__value_.__l.__size_ = v16;
                id v15 = v75;
                if (v59) {
                  uint64_t v60 = (char *)sub_10016ACDC(v16, v59);
                }
                else {
                  uint64_t v60 = 0;
                }
                *(void *)&long long __dst = v60;
                *((void *)&__dst + 1) = &v60[72 * v56];
                uint64_t v81 = (char *)*((void *)&__dst + 1);
                v82.__r_.__value_.__r.__words[0] = (std::string::size_type)&v60[72 * v59];
                sub_100FC898C(*((char **)&__dst + 1), (long long *)__p);
                v81 += 72;
                sub_100601AD8(v74, &__dst);
                unint64_t v55 = *((void *)v8 + 4);
                sub_100601B94((uint64_t)&__dst);
              }
              else
              {
                sub_100FC898C(*((char **)v8 + 4), (long long *)__p);
                uint64_t v9 = v74;
                unint64_t v55 = v54 + 72;
                *((void *)v8 + 4) = v54 + 72;
                id v15 = v75;
              }
              *((void *)v8 + 4) = v55;
              if ((_BYTE)v90) {
                sub_100044D00(&v89);
              }
              uint64_t v11 = v73;
              if (BYTE8(v92) && SBYTE7(v92) < 0) {
                operator delete(v91[0]);
              }
              if (BYTE8(v94) && SBYTE7(v94) < 0) {
                operator delete(v93[0]);
              }
              *(void *)&long long __dst = &v108;
              sub_10019F7C0((void ***)&__dst);
              if (SHIBYTE(__p[5]) < 0) {
                operator delete(__p[3]);
              }
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
              goto LABEL_94;
            }
            v61 = **(NSObject ***)(a1 + 40);
            if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_104;
            }
            uint64_t v67 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            unint64_t v68 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            LODWORD(__p[0]) = 136315906;
            *(void **)((char *)__p + 4) = v67;
            WORD2(__p[1]) = 2080;
            *(void **)((char *)&__p[1] + 6) = " ";
            HIWORD(__p[2]) = 2080;
            __p[3] = v68;
            LOWORD(__p[4]) = 2080;
            *(void **)((char *)&__p[4] + 2) = ", ";
            v64 = "#W %s%s%s%sno geofences in response";
          }
          else
          {
            v61 = **(NSObject ***)(a1 + 40);
            if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_104;
            }
            uint64_t v65 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v66 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            LODWORD(__p[0]) = 136315906;
            *(void **)((char *)__p + 4) = v65;
            WORD2(__p[1]) = 2080;
            *(void **)((char *)&__p[1] + 6) = " ";
            HIWORD(__p[2]) = 2080;
            __p[3] = v66;
            LOWORD(__p[4]) = 2080;
            *(void **)((char *)&__p[4] + 2) = ", ";
            v64 = "#W %s%s%s%sno version in response";
          }
        }
        else
        {
          v61 = **(NSObject ***)(a1 + 40);
          if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_104;
          }
          uint64_t v62 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
          uint64_t v63 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
          LODWORD(__p[0]) = 136315906;
          *(void **)((char *)__p + 4) = v62;
          WORD2(__p[1]) = 2080;
          *(void **)((char *)&__p[1] + 6) = " ";
          HIWORD(__p[2]) = 2080;
          __p[3] = v63;
          LOWORD(__p[4]) = 2080;
          *(void **)((char *)&__p[4] + 2) = ", ";
          v64 = "#W %s%s%s%sno profile name in response";
        }
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, v64, (uint8_t *)__p, 0x2Au);
        goto LABEL_104;
      }
LABEL_94:
      v77 = (char *)v77 + 1;
    }
    while (v77 != v15);
    id v15 = [v11 countByEnumeratingWithState:&v96 objects:buf count:16];
    if (v15) {
      continue;
    }
    break;
  }
LABEL_104:
  a4 = v72;
  int v4 = 6000;
  if ((_BYTE)v101) {
    sub_100044D00(&cf);
  }
LABEL_106:
  uint64_t v69 = operator new(0x30uLL);
  unint64_t v70 = v69;
  v69[1] = 0;
  v69[2] = 0;
  *uint64_t v69 = off_101A7B8A8;
  v71 = (char *)(v69 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    *((_DWORD *)v69 + 6) = v4;
    v69[4] = v9;
    v69[5] = v8;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v8 + 1, 1uLL, memory_order_relaxed);
    sub_10004D2C8((std::__shared_weak_count *)v8);
    sub_10004D2C8((std::__shared_weak_count *)v8);
  }
  else
  {
    *((_DWORD *)v69 + 6) = v4;
    v69[4] = v9;
    v69[5] = 0;
  }
  *a4 = v71;
  a4[1] = v70;
}

void sub_100FE94AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,const void *a62,__int16 a63)
{
  if ((_BYTE)a63) {
    sub_100044D00(&a62);
  }
  sub_10004D2C8(v63);
  _Unwind_Resume(a1);
}

void sub_100FE962C(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    id v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    id v19 = operator new(0x30uLL);
    long long v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7B8A8;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    long long v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::string::size_type v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FE985C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FE9874(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    unint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  id v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    long long v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019C200(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FE9B68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FE9BD8()
{
  return "retrieveGeofenceData";
}

void sub_100FE9BE4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B8A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE9C04(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B8A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FE9C58(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FE9C6C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B8F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FE9C8C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B8F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FE9CE0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FE9D0C(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FE9D44(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  int v4 = a2;
  if (a2 == 6000)
  {
    v8 = (std::__shared_weak_count *)operator new(0x30uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8[1].__vftable = 0;
    unint64_t v54 = &v8[1].__vftable;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A79D60;
    v8[1].__shared_owners_ = 0;
    v8[1].__shared_weak_owners_ = 0;
    CFTypeRef cf = 0;
    uint64_t v62 = 0;
    Value = CFDictionaryGetValue(a3, *(const void **)(a1 + 48));
    sub_100FC3AEC(&cf, Value);
    if (!(_BYTE)v62) {
      goto LABEL_57;
    }
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    CFTypeRef v56 = cf;
    uint64_t v52 = a4;
    if (cf)
    {
      CFRetain(cf);
      uint64_t i = (void *)v56;
    }
    else
    {
      uint64_t i = 0;
    }
    sub_100044D00(&v56);
    id v14 = [i countByEnumeratingWithState:&v57 objects:buf count:16];
    if (!v14) {
      goto LABEL_55;
    }
    uint64_t v15 = *(void *)v58;
    unint64_t v53 = i;
    while (1)
    {
      uint64_t v16 = 0;
      do
      {
        if (*(void *)v58 != v15) {
          objc_enumerationMutation(i);
        }
        int v17 = *(void **)(*((void *)&v57 + 1) + 8 * (void)v16);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v18 = [v17 objectForKey:*(void *)(a1 + 56)];
          if (!v18)
          {
            long long v43 = **(NSObject ***)(a1 + 40);
            if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_55;
            }
            uint64_t v44 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            long long v45 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            LODWORD(__p[0]) = 136315906;
            *(void **)((char *)__p + 4) = v44;
            WORD2(__p[1]) = 2080;
            *(void **)((char *)&__p[1] + 6) = " ";
            HIWORD(__p[2]) = 2080;
            __p[3] = v45;
            __int16 v65 = 2080;
            uint64_t v66 = ", ";
            uint64_t v46 = "#W %s%s%s%sno blind-pub-key name in response";
LABEL_54:
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)__p, 0x2Au);
            goto LABEL_55;
          }
          id v19 = [v17 objectForKey:*(void *)(a1 + 64)];
          if (!v19)
          {
            long long v43 = **(NSObject ***)(a1 + 40);
            if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_55;
            }
            uint64_t v47 = (void *)PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
            uint64_t v48 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            LODWORD(__p[0]) = 136315906;
            *(void **)((char *)__p + 4) = v47;
            WORD2(__p[1]) = 2080;
            *(void **)((char *)&__p[1] + 6) = " ";
            HIWORD(__p[2]) = 2080;
            __p[3] = v48;
            __int16 v65 = 2080;
            uint64_t v66 = ", ";
            uint64_t v46 = "#W %s%s%s%sno not-before name in response";
            goto LABEL_54;
          }
          memset(__p, 0, sizeof(__p));
          sub_100FC2A7C(__p, a1, v18, *(void **)(a1 + 56));
          if (LOBYTE(__p[3]))
          {
            if (SHIBYTE(__p[2]) < 0)
            {
              sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)__p;
              *(void **)&__dst[16] = __p[2];
            }
          }
          else
          {
            memset(__dst, 0, sizeof(__dst));
          }
          v63[0] = *(void *)&__dst[8];
          uint64_t v20 = *(void *)__dst;
          *(void *)((char *)v63 + 7) = *(void *)&__dst[15];
          char v21 = __dst[23];
          unint64_t v22 = sub_100FC37E8(a1, v19, *(void **)(a1 + 64));
          if (v23) {
            unint64_t v24 = v22;
          }
          else {
            unint64_t v24 = 0;
          }
          unint64_t shared_owners = v8[1].__shared_owners_;
          unint64_t shared_weak_owners = v8[1].__shared_weak_owners_;
          if (shared_owners >= shared_weak_owners)
          {
            uint64_t v29 = (uint64_t)(shared_owners - *v54) >> 5;
            unint64_t v30 = v29 + 1;
            if ((unint64_t)(v29 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v31 = shared_weak_owners - *v54;
            if (v31 >> 4 > v30) {
              unint64_t v30 = v31 >> 4;
            }
            if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v32 = v30;
            }
            __int16 v33 = (char *)sub_1000F5A68((uint64_t)&v8[1].__shared_weak_owners_, v32);
            long long v34 = &v33[32 * v29];
            long long v36 = &v33[32 * v35];
            uint64_t v37 = v63[0];
            *(void *)long long v34 = v20;
            *((void *)v34 + 1) = v37;
            *(void *)(v34 + 15) = *(void *)((char *)v63 + 7);
            v34[23] = v21;
            *((void *)v34 + 3) = v24;
            uint64_t v28 = (uint64_t)(v34 + 32);
            unint64_t v38 = v8[1].__vftable;
            unint64_t v39 = (std::__shared_weak_count_vtbl *)v8[1].__shared_owners_;
            if (v39 == v38)
            {
              v8[1].__vftable = (std::__shared_weak_count_vtbl *)v34;
              v8[1].__shared_owners_ = v28;
              v8[1].__shared_weak_owners_ = (uint64_t)v36;
              uint64_t i = v53;
              if (!v39) {
                goto LABEL_41;
              }
            }
            else
            {
              do
              {
                long long v40 = *(_OWORD *)&v39[-1].~__shared_weak_count_0;
                *((void *)v34 - 2) = v39[-1].__get_deleter;
                *((_OWORD *)v34 - 2) = v40;
                v39[-1].__on_zero_shared = 0;
                v39[-1].__get_deleter = 0;
                v39[-1].~__shared_weak_count_0 = 0;
                *((void *)v34 - 1) = v39[-1].__on_zero_shared_weak;
                v34 -= 32;
                unint64_t v39 = (std::__shared_weak_count_vtbl *)((char *)v39 - 32);
              }
              while (v39 != v38);
              unint64_t v39 = v8[1].__vftable;
              uint64_t v41 = (void **)v8[1].__shared_owners_;
              v8[1].__vftable = (std::__shared_weak_count_vtbl *)v34;
              v8[1].__shared_owners_ = v28;
              v8[1].__shared_weak_owners_ = (uint64_t)v36;
              for (uint64_t i = v53; v41 != (void **)v39; v41 -= 4)
              {
                if (*((char *)v41 - 9) < 0) {
                  operator delete(*(v41 - 4));
                }
              }
              if (!v39) {
                goto LABEL_41;
              }
            }
            operator delete(v39);
          }
          else
          {
            uint64_t v27 = v63[0];
            *(void *)unint64_t shared_owners = v20;
            *(void *)(shared_owners + 8) = v27;
            *(void *)(shared_owners + 15) = *(void *)((char *)v63 + 7);
            *(unsigned char *)(shared_owners + 23) = v21;
            *(void *)(shared_owners + 24) = v24;
            uint64_t v28 = shared_owners + 32;
            v8[1].__shared_owners_ = shared_owners + 32;
            uint64_t i = v53;
          }
LABEL_41:
          v8[1].__shared_owners_ = v28;
          if (LOBYTE(__p[3]) && SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v16 = (char *)v16 + 1;
      }
      while (v16 != v14);
      id v42 = [i countByEnumeratingWithState:&v57 objects:buf count:16];
      id v14 = v42;
      if (!v42)
      {
LABEL_55:
        a4 = v52;
        int v4 = 6000;
        if ((_BYTE)v62) {
          sub_100044D00(&cf);
        }
        goto LABEL_57;
      }
    }
  }
  uint64_t v11 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    *(_DWORD *)buf = 136315906;
    uint64_t v68 = v12;
    __int16 v69 = 2080;
    unint64_t v70 = " ";
    __int16 v71 = 2080;
    uint64_t v72 = v13;
    __int16 v73 = 2080;
    v74 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
  }
  unint64_t v54 = 0;
  v8 = 0;
LABEL_57:
  long long v49 = operator new(0x30uLL);
  long long v50 = v49;
  v49[1] = 0;
  v49[2] = 0;
  *long long v49 = off_101A7B9A0;
  int64x2_t v51 = (char *)(v49 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v49 + 6) = v4;
    v49[4] = v54;
    v49[5] = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
  else
  {
    *((_DWORD *)v49 + 6) = v4;
    v49[4] = v54;
    v49[5] = 0;
  }
  *a4 = v51;
  a4[1] = v50;
}

void sub_100FEA3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,const void *a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
  if ((_BYTE)a28) {
    sub_100044D00(&a27);
  }
  sub_10004D2C8(v39);
  _Unwind_Resume(a1);
}

void sub_100FEA464(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    uint64_t v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    id v19 = operator new(0x30uLL);
    uint64_t v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7B9A0;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  id v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    uint64_t v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FEA694(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FEA6AC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  id v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    long long v36 = v17;
    __int16 v37 = 2080;
    unint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  id v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    uint64_t v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019C4BC(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FEA9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FEAA10()
{
  return "getSigningKeys";
}

void sub_100FEAA1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B9A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FEAA3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B9A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FEAA90(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FEAAA4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B9F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FEAAC4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7B9F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FEAB18(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FEAB44(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FEAB7C(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  int v4 = a2;
  uint64_t v5 = a1;
  if (a2 != 6000)
  {
    uint64_t v13 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      *(_DWORD *)buf = 136315906;
      uint64_t v110 = v14;
      __int16 v111 = 2080;
      __int16 v112 = " ";
      __int16 v113 = 2080;
      uint64_t v114 = v15;
      __int16 v115 = 2080;
      __int16 v116 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", buf, 0x2Au);
    }
    v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_108;
  }
  v8 = (std::__shared_weak_count *)operator new(0x30uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = 0;
  uint64_t v9 = (int64x2_t *)&v8[1];
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A79DB0;
  v8[1].__shared_owners_ = 0;
  v8[1].__shared_weak_owners_ = 0;
  CFTypeRef cf = 0;
  uint64_t v101 = 0;
  Value = CFDictionaryGetValue(a3, *(const void **)(v5 + 48));
  sub_100FC3AEC(&cf, Value);
  if (!(_BYTE)v101) {
    goto LABEL_108;
  }
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  CFTypeRef v95 = cf;
  if (cf)
  {
    CFRetain(cf);
    uint64_t v11 = (void *)v95;
  }
  else
  {
    uint64_t v11 = 0;
  }
  sub_100044D00(&v95);
  id v16 = [v11 countByEnumeratingWithState:&v96 objects:buf count:16];
  if (!v16) {
    goto LABEL_106;
  }
  uint64_t v77 = *(void *)v97;
  v78 = v8;
  id v75 = v11;
  uint64_t v72 = a4;
  p_unint64_t shared_weak_owners = &v8[1].__shared_weak_owners_;
  uint64_t v74 = v5;
  while (2)
  {
    int v17 = 0;
    uint64_t v18 = v77;
    id v76 = v16;
    do
    {
      if (*(void *)v97 != v18) {
        objc_enumerationMutation(v11);
      }
      id v19 = *(void **)(*((void *)&v96 + 1) + 8 * (void)v17);
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v20 = [v19 objectForKey:*(void *)(v5 + 56)];
        if (v20)
        {
          id v21 = [v19 objectForKey:*(void *)(v5 + 80)];
          if (v21)
          {
            id v22 = [v19 objectForKey:*(void *)(v5 + 64)];
            if (v22)
            {
              id v23 = [v19 objectForKey:*(void *)(v5 + 72)];
              if (v23)
              {
                memset(v108, 0, sizeof(v108));
                memset(v107, 0, sizeof(v107));
                unint64_t v24 = sub_100FC2DC4(v5, v20, *(void **)(v5 + 56));
                int v25 = &_mh_execute_header;
                if (v24 > (unint64_t)&_mh_execute_header) {
                  LODWORD(v25) = v24;
                }
                *(_DWORD *)uint64_t v107 = v25;
                long long v93 = 0u;
                long long v94 = 0u;
                sub_100FC2A7C(&v93, v5, v21, *(void **)(v5 + 80));
                if (BYTE8(v94))
                {
                  if (SBYTE7(v94) < 0)
                  {
                    sub_10004FC84(__dst, (void *)v93, *((unint64_t *)&v93 + 1));
                  }
                  else
                  {
                    *(_OWORD *)long long __dst = v93;
                    __dst[2] = (void *)v94;
                  }
                }
                else
                {
                  memset(__dst, 0, sizeof(__dst));
                }
                if (SHIBYTE(v108[5]) < 0) {
                  operator delete((void *)v108[3]);
                }
                *(_OWORD *)&v108[3] = *(_OWORD *)__dst;
                v108[5] = (uint64_t)__dst[2];
                CFTypeRef v91 = 0;
                uint64_t v92 = 0;
                sub_100FC3AEC(&v91, v22);
                if ((_BYTE)v92)
                {
                  long long v89 = 0u;
                  long long v90 = 0u;
                  long long v87 = 0u;
                  long long v88 = 0u;
                  CFTypeRef v86 = v91;
                  if (v91)
                  {
                    CFRetain(v91);
                    CFTypeRef v26 = (void *)v86;
                  }
                  else
                  {
                    CFTypeRef v26 = 0;
                  }
                  sub_100044D00(&v86);
                  id v27 = [v26 countByEnumeratingWithState:&v87 objects:v106 count:16];
                  if (v27)
                  {
                    uint64_t v28 = *(void *)v88;
                    do
                    {
                      for (uint64_t i = 0; i != v27; uint64_t i = (char *)i + 1)
                      {
                        if (*(void *)v88 != v28) {
                          objc_enumerationMutation(v26);
                        }
                        __int16 v30 = *(void **)(*((void *)&v87 + 1) + 8 * i);
                        memset(__dst, 0, sizeof(__dst));
                        sub_100058DB0(__dst, (char *)[v30 UTF8String]);
                        __int16 v31 = *(_OWORD **)&v107[16];
                        if (*(void *)&v107[16] >= *(void *)&v107[24])
                        {
                          uint64_t v33 = sub_100048008((uint64_t *)&v107[8], (long long *)__dst);
                        }
                        else
                        {
                          if (SHIBYTE(__dst[2]) < 0)
                          {
                            sub_10004FC84(*(unsigned char **)&v107[16], __dst[0], (unint64_t)__dst[1]);
                          }
                          else
                          {
                            long long v32 = *(_OWORD *)__dst;
                            *(void **)(*(void *)&v107[16] + 16) = __dst[2];
                            *__int16 v31 = v32;
                          }
                          uint64_t v33 = (uint64_t)v31 + 24;
                        }
                        *(void *)&v107[16] = v33;
                        if (SHIBYTE(__dst[2]) < 0) {
                          operator delete(__dst[0]);
                        }
                      }
                      id v27 = [v26 countByEnumeratingWithState:&v87 objects:v106 count:16];
                    }
                    while (v27);
                  }
                }
                CFTypeRef v84 = 0;
                uint64_t v85 = 0;
                sub_100FC3AEC(&v84, v23);
                id v16 = v76;
                if ((_BYTE)v85)
                {
                  long long v82 = 0u;
                  long long v83 = 0u;
                  long long v80 = 0u;
                  long long v81 = 0u;
                  CFTypeRef v79 = v84;
                  if (v84)
                  {
                    CFRetain(v84);
                    long long v34 = (void *)v79;
                  }
                  else
                  {
                    long long v34 = 0;
                  }
                  sub_100044D00(&v79);
                  id v35 = [v34 countByEnumeratingWithState:&v80 objects:v105 count:16];
                  if (v35)
                  {
                    uint64_t v36 = *(void *)v81;
                    do
                    {
                      for (j = 0; j != v35; j = (char *)j + 1)
                      {
                        if (*(void *)v81 != v36) {
                          objc_enumerationMutation(v34);
                        }
                        unint64_t v38 = *(void **)(*((void *)&v80 + 1) + 8 * (void)j);
                        memset(__dst, 0, sizeof(__dst));
                        sub_100058DB0(__dst, (char *)[v38 UTF8String]);
                        unint64_t v39 = (_OWORD *)v108[1];
                        if (v108[1] >= (unint64_t)v108[2])
                        {
                          uint64_t v41 = sub_100048008(v108, (long long *)__dst);
                        }
                        else
                        {
                          if (SHIBYTE(__dst[2]) < 0)
                          {
                            sub_10004FC84((unsigned char *)v108[1], __dst[0], (unint64_t)__dst[1]);
                          }
                          else
                          {
                            long long v40 = *(_OWORD *)__dst;
                            *(void **)(v108[1] + 16) = __dst[2];
                            *unint64_t v39 = v40;
                          }
                          uint64_t v41 = (uint64_t)v39 + 24;
                        }
                        v108[1] = v41;
                        if (SHIBYTE(__dst[2]) < 0) {
                          operator delete(__dst[0]);
                        }
                      }
                      id v35 = [v34 countByEnumeratingWithState:&v80 objects:v105 count:16];
                    }
                    while (v35);
                  }
                }
                unint64_t shared_owners = v78[1].__shared_owners_;
                unint64_t shared_weak_owners = v78[1].__shared_weak_owners_;
                if (shared_owners >= shared_weak_owners)
                {
                  uint64_t v18 = v77;
                  unint64_t v45 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(shared_owners - v9->i64[0]) >> 4);
                  unint64_t v46 = v45 + 1;
                  if (v45 + 1 > 0x333333333333333) {
                    sub_10006A748();
                  }
                  unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(shared_weak_owners - v9->i64[0]) >> 4);
                  if (2 * v47 > v46) {
                    unint64_t v46 = 2 * v47;
                  }
                  if (v47 >= 0x199999999999999) {
                    unint64_t v48 = 0x333333333333333;
                  }
                  else {
                    unint64_t v48 = v46;
                  }
                  long long v104 = p_shared_weak_owners;
                  v8 = v78;
                  if (v48)
                  {
                    if (v48 > 0x333333333333333) {
                      sub_10006A7CC();
                    }
                    long long v49 = (char *)operator new(80 * v48);
                  }
                  else
                  {
                    long long v49 = 0;
                  }
                  __dst[0] = v49;
                  __dst[1] = &v49[80 * v45];
                  __dst[2] = __dst[1];
                  int64x2_t v103 = &v49[80 * v48];
                  sub_100FC8A70((uint64_t)__dst[1], (uint64_t)v107);
                  long long v50 = (std::__shared_weak_count_vtbl *)__dst[1];
                  uint64_t v44 = (char *)__dst[2] + 80;
                  __dst[2] = (char *)__dst[2] + 80;
                  uint64_t v52 = v78[1].__vftable;
                  unint64_t v51 = v78[1].__shared_owners_;
                  uint64_t v11 = v75;
                  if ((std::__shared_weak_count_vtbl *)v51 == v52)
                  {
                    int64x2_t v57 = vdupq_n_s64(v51);
                  }
                  else
                  {
                    unint64_t v53 = 0;
                    do
                    {
                      unint64_t v54 = (char *)&v50[v53 / 0x28];
                      unint64_t v55 = v51 + v53;
                      *((_DWORD *)v54 - 20) = *(_DWORD *)(v51 + v53 - 80);
                      *((void *)v54 - 8) = 0;
                      *((void *)v54 - 7) = 0;
                      *((void *)v54 - 9) = 0;
                      *(_OWORD *)(v54 - 72) = *(_OWORD *)(v51 + v53 - 72);
                      *((void *)v54 - 7) = *(void *)(v51 + v53 - 56);
                      *(void *)(v55 - 72) = 0;
                      *(void *)(v55 - 64) = 0;
                      *(void *)(v55 - 56) = 0;
                      *((void *)v54 - 6) = 0;
                      *((void *)v54 - 5) = 0;
                      *((void *)v54 - 4) = 0;
                      *((_OWORD *)v54 - 3) = *(_OWORD *)(v51 + v53 - 48);
                      *((void *)v54 - 4) = *(void *)(v51 + v53 - 32);
                      *(void *)(v55 - 48) = 0;
                      *(void *)(v55 - 40) = 0;
                      *(void *)(v55 - 32) = 0;
                      long long v56 = *(_OWORD *)(v51 + v53 - 24);
                      *((void *)v54 - 1) = *(void *)(v51 + v53 - 8);
                      *(_OWORD *)(v54 - 24) = v56;
                      *(void *)(v55 - 16) = 0;
                      *(void *)(v55 - 8) = 0;
                      *(void *)(v55 - 24) = 0;
                      v53 -= 80;
                    }
                    while ((std::__shared_weak_count_vtbl *)(v51 + v53) != v52);
                    int64x2_t v57 = *v9;
                    uint64_t v44 = (char *)__dst[2];
                    long long v50 = (std::__shared_weak_count_vtbl *)((char *)v50 + v53);
                  }
                  v78[1].__vftable = v50;
                  v78[1].__shared_owners_ = (uint64_t)v44;
                  *(int64x2_t *)&__dst[1] = v57;
                  long long v58 = (char *)v78[1].__shared_weak_owners_;
                  v78[1].__shared_weak_owners_ = (uint64_t)v103;
                  int64x2_t v103 = v58;
                  __dst[0] = (void *)v57.i64[0];
                  sub_100FC8BBC((uint64_t)__dst);
                }
                else
                {
                  sub_100FC8A70(v78[1].__shared_owners_, (uint64_t)v107);
                  uint64_t v11 = v75;
                  uint64_t v18 = v77;
                  uint64_t v44 = (char *)(shared_owners + 80);
                  v8 = v78;
                  v78[1].__shared_owners_ = (uint64_t)v44;
                }
                v8[1].__shared_owners_ = (uint64_t)v44;
                if ((_BYTE)v85) {
                  sub_100044D00(&v84);
                }
                uint64_t v5 = v74;
                if ((_BYTE)v92) {
                  sub_100044D00(&v91);
                }
                if (BYTE8(v94) && SBYTE7(v94) < 0) {
                  operator delete((void *)v93);
                }
                if (SHIBYTE(v108[5]) < 0) {
                  operator delete((void *)v108[3]);
                }
                __dst[0] = v108;
                sub_100047F64((void ***)__dst);
                __dst[0] = &v107[8];
                sub_100047F64((void ***)__dst);
                goto LABEL_94;
              }
              long long v59 = **(NSObject ***)(v5 + 40);
              v8 = v78;
              a4 = v72;
              int v4 = 6000;
              if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_106;
              }
              uint64_t v67 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
              uint64_t v68 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
              *(_DWORD *)uint64_t v107 = 136315906;
              *(void *)&v107[4] = v67;
              *(_WORD *)&v107[12] = 2080;
              *(void *)&v107[14] = " ";
              *(_WORD *)&v107[22] = 2080;
              *(void *)&v107[24] = v68;
              LOWORD(v108[0]) = 2080;
              *(uint64_t *)((char *)v108 + 2) = (uint64_t)", ";
              uint64_t v62 = "#W %s%s%s%sno scopes in response";
            }
            else
            {
              long long v59 = **(NSObject ***)(v5 + 40);
              v8 = v78;
              a4 = v72;
              int v4 = 6000;
              if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_106;
              }
              uint64_t v65 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
              uint64_t v66 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
              *(_DWORD *)uint64_t v107 = 136315906;
              *(void *)&v107[4] = v65;
              *(_WORD *)&v107[12] = 2080;
              *(void *)&v107[14] = " ";
              *(_WORD *)&v107[22] = 2080;
              *(void *)&v107[24] = v66;
              LOWORD(v108[0]) = 2080;
              *(uint64_t *)((char *)v108 + 2) = (uint64_t)", ";
              uint64_t v62 = "#W %s%s%s%sno blind-sigs in response";
            }
          }
          else
          {
            long long v59 = **(NSObject ***)(v5 + 40);
            v8 = v78;
            a4 = v72;
            int v4 = 6000;
            if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_106;
            }
            uint64_t v63 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
            uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
            *(_DWORD *)uint64_t v107 = 136315906;
            *(void *)&v107[4] = v63;
            *(_WORD *)&v107[12] = 2080;
            *(void *)&v107[14] = " ";
            *(_WORD *)&v107[22] = 2080;
            *(void *)&v107[24] = v64;
            LOWORD(v108[0]) = 2080;
            *(uint64_t *)((char *)v108 + 2) = (uint64_t)", ";
            uint64_t v62 = "#W %s%s%s%sno device-type in response";
          }
        }
        else
        {
          long long v59 = **(NSObject ***)(v5 + 40);
          v8 = v78;
          a4 = v72;
          int v4 = 6000;
          if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_106;
          }
          uint64_t v60 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v5 + 24));
          uint64_t v61 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
          *(_DWORD *)uint64_t v107 = 136315906;
          *(void *)&v107[4] = v60;
          *(_WORD *)&v107[12] = 2080;
          *(void *)&v107[14] = " ";
          *(_WORD *)&v107[22] = 2080;
          *(void *)&v107[24] = v61;
          LOWORD(v108[0]) = 2080;
          *(uint64_t *)((char *)v108 + 2) = (uint64_t)", ";
          uint64_t v62 = "#W %s%s%s%sno status in response";
        }
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, v62, v107, 0x2Au);
        v8 = v78;
        goto LABEL_106;
      }
LABEL_94:
      int v17 = (char *)v17 + 1;
    }
    while (v17 != v16);
    id v16 = [v11 countByEnumeratingWithState:&v96 objects:buf count:16];
    a4 = v72;
    int v4 = 6000;
    if (v16) {
      continue;
    }
    break;
  }
LABEL_106:
  if ((_BYTE)v101) {
    sub_100044D00(&cf);
  }
LABEL_108:
  __int16 v69 = operator new(0x30uLL);
  unint64_t v70 = v69;
  v69[1] = 0;
  v69[2] = 0;
  *__int16 v69 = off_101A7BA98;
  __int16 v71 = (char *)(v69 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v69 + 6) = v4;
    v69[4] = v9;
    v69[5] = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
  else
  {
    *((_DWORD *)v69 + 6) = v4;
    v69[4] = v9;
    v69[5] = 0;
  }
  *a4 = v71;
  a4[1] = v70;
}

void sub_100FEB710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,const void *a57,__int16 a58)
{
  if ((_BYTE)a58) {
    sub_100044D00(&a57);
  }
  sub_10004D2C8(a19);
  _Unwind_Resume(a1);
}

void sub_100FEB8A0(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    int v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  uint64_t v13 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    id v19 = operator new(0x30uLL);
    id v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7BA98;
    *((_DWORD *)v19 + 6) = v21;
    uint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    id v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  id v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FEBAD0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FEBAE8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    unint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  id v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    id v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019C778(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FEBDDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FEBE4C()
{
  return "getBlindSignatures";
}

void sub_100FEBE58(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7BA98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FEBE78(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7BA98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FEBECC(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100FEBEE0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7BAE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FEBF00(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7BAE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100FEBF54(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100FEBF80(void *a1)
{
  sub_100FC27D8(a1);

  operator delete();
}

void sub_100FEBFB8(uint64_t a1@<X0>, int a2@<W1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 6000)
  {
    v8 = (std::__shared_weak_count *)operator new(0x20uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8[1].__vftable = 0;
    uint64_t v9 = &v8[1].__vftable;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A79E00;
    Value = (void *)CFDictionaryGetValue(a3, *(const void **)(a1 + 48));
    unint64_t v11 = sub_100FC37E8(a1, Value, *(void **)(a1 + 48));
    if (v12) {
      unint64_t v13 = v11;
    }
    else {
      unint64_t v13 = 0;
    }
    *uint64_t v9 = v13;
  }
  else
  {
    uint64_t v14 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      int v20 = 136315906;
      uint64_t v21 = v15;
      __int16 v22 = 2080;
      uint64_t v23 = " ";
      __int16 v24 = 2080;
      uint64_t v25 = v16;
      __int16 v26 = 2080;
      uint64_t v27 = ", ";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#W %s%s%s%sskipping response parsing due to status", (uint8_t *)&v20, 0x2Au);
    }
    v8 = 0;
    uint64_t v9 = 0;
  }
  int v17 = operator new(0x30uLL);
  int v18 = v17;
  v17[1] = 0;
  v17[2] = 0;
  *int v17 = off_101A7BB90;
  id v19 = (char *)(v17 + 3);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v17 + 6) = a2;
    v17[4] = v9;
    v17[5] = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
  else
  {
    *((_DWORD *)v17 + 6) = a2;
    v17[4] = v9;
    v17[5] = 0;
  }
  *a4 = v19;
  a4[1] = v18;
}

void sub_100FEC1B8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FEC1D8(uint64_t a1@<X0>, char **a2@<X1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  v8 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    int v22 = 136316162;
    uint64_t v23 = v9;
    __int16 v24 = 2080;
    uint64_t v25 = " ";
    __int16 v26 = 2080;
    uint64_t v27 = v10;
    __int16 v28 = 2080;
    CFTypeRef v29 = ", ";
    __int16 v30 = 2080;
    uint64_t v31 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPrepare result for %s", (uint8_t *)&v22, 0x34u);
  }
  unint64_t v13 = *a2;
  char v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v13)
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(_DWORD *)a3;
    id v19 = operator new(0x30uLL);
    int v20 = (std::__shared_weak_count *)v19;
    if (v17) {
      int v21 = v18;
    }
    else {
      int v21 = 6005;
    }
    v19[1] = 0;
    v19[2] = 0;
    void *v19 = off_101A7BB90;
    *((_DWORD *)v19 + 6) = v21;
    unint64_t v13 = (char *)(v19 + 3);
    v19[4] = 0;
    v19[5] = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
    goto LABEL_16;
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v13 + 2);
  if (!v14)
  {
    *((void *)v13 + 2) = 0;
    int v20 = v12;
LABEL_16:
    *a4 = v13;
    a4[1] = v20;
    return;
  }
  uint64_t v15 = *((void *)v13 + 1);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v13 + 2);
  *((void *)v13 + 1) = v15;
  *((void *)v13 + 2) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v14);
  *a4 = v13;
  a4[1] = v12;
  sub_10004D2C8(v14);
}

void sub_100FEC408(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FEC420(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, const void **a6, const void **a7)
{
  uint64_t v14 = **(NSObject ***)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 24));
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((a4 - 1) > 2) {
      int v17 = "RequestCanceled";
    }
    else {
      int v17 = off_101A7BD60[(int)a4 - 1];
    }
    if (*(void *)a5) {
      int v18 = sub_100FB56F4(**(_DWORD **)a5);
    }
    else {
      int v18 = "??";
    }
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v31 = 2080;
    uint64_t v32 = v16;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v17;
    __int16 v37 = 2080;
    unint64_t v38 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s%s%sPosting result %s: %s", buf, 0x3Eu);
  }
  id v19 = (std::__shared_weak_count *)a3[1];
  if (v19)
  {
    int v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *a3;
      if (v22)
      {
        __int16 v24 = *(int **)a5;
        uint64_t v23 = *(std::__shared_weak_count **)(a5 + 8);
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058198(&cf, a6);
        sub_1000584C8(&v26, a7);
        int v25 = *(_DWORD *)(v22 + 8);
        if (v25 == 1)
        {
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
            sub_10004D2C8(v23);
          }
          else
          {
            *(void *)buf = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v29 = v26;
            if (v26) {
              CFRetain(v26);
            }
            sub_1000577C4(&v29);
            sub_100057D78((const void **)buf);
          }
        }
        else if (!v25)
        {
          *(void *)buf = v24;
          *(void *)&buf[8] = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeRef v29 = cf;
          if (cf) {
            CFRetain(cf);
          }
          CFTypeRef v28 = v26;
          if (v26) {
            CFRetain(v26);
          }
          sub_10019CA34(v22, a2, a4, buf, &v29, &v28);
        }
        sub_1000577C4(&v26);
        sub_100057D78(&cf);
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_10004D2C8(v21);
    }
  }
}

void sub_100FEC714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100FEC784()
{
  return "enableService";
}

void sub_100FEC790(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7BB90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100FEC7B0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7BB90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FEC804(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_100FEC818(ctu::OsLogLogger *a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = ctu::OsLogLogger::OsLogLogger(a1, "com.apple.telephony", "msg.mms.pdu");
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(unsigned char *)(result + 32) = *(unsigned char *)(a2 + 32);
  *(unsigned char *)(result + 33) = *(unsigned char *)(a2 + 33);
  *(unsigned char *)(result + 34) = *(unsigned char *)(a2 + 34);
  *(_DWORD *)(result + 36) = *(_DWORD *)(a2 + 36);
  uint64_t v6 = *(unsigned int *)(a2 + 20);
  unint64_t v7 = (*(_DWORD *)(a2 + 16) - v6);
  if (v7 >= a3) {
    LODWORD(v7) = a3;
  }
  *(void *)(result + 8) = *(void *)(a2 + 8) + v6;
  *(_DWORD *)(result + 16) = v7;
  *(_DWORD *)(result + 20) = 0;
  return result;
}

uint64_t sub_100FEC89C(uint64_t a1, std::string *a2)
{
  uint64_t result = sub_100FEC944(a1, a2, 0xFFFFFFFF);
  if (result)
  {
    if (*(unsigned char *)(a1 + 33)
      && ((int v5 = SHIBYTE(a2->__r_.__value_.__r.__words[2]), v5 >= 0)
        ? (unint64_t size = HIBYTE(a2->__r_.__value_.__r.__words[2]))
        : (unint64_t size = a2->__r_.__value_.__l.__size_),
          size))
    {
      uint64_t v7 = 0;
      if (v5 >= 0) {
        v8 = a2;
      }
      else {
        v8 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      unsigned int v9 = 1;
      while (1)
      {
        int v10 = v8->__r_.__value_.__s.__data_[v7];
        if (v10 < 0 || memchr("()<>@,;:\\\"/[]?={} \t", v10, 0x14uLL)) {
          break;
        }
        uint64_t v7 = v9;
        if (size <= v9++) {
          return 1;
        }
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_100FEC944(uint64_t a1, std::string *__dst, unsigned int a3)
{
  if (a3 == -1)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 20);
    uint64_t v6 = (*(_DWORD *)(a1 + 16) - v5);
    if (v6)
    {
      uint64_t v7 = 0;
      while (*(unsigned char *)(*(void *)(a1 + 8) + v5 + v7))
      {
        if (v6 == ++v7) {
          goto LABEL_16;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if (v7 == v6 || *(unsigned char *)(*(void *)(a1 + 8) + v5 + v7)) {
      goto LABEL_16;
    }
    unsigned int v4 = v7 + 1;
  }
  else
  {
    unsigned int v4 = a3;
    if (!a3)
    {
      if (SHIBYTE(__dst->__r_.__value_.__r.__words[2]) < 0)
      {
        *__dst->__r_.__value_.__l.__data_ = 0;
        __dst->__r_.__value_.__l.__size_ = 0;
      }
      else
      {
        __dst->__r_.__value_.__s.__data_[0] = 0;
        *((unsigned char *)&__dst->__r_.__value_.__s + 23) = 0;
      }
      return 1;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 20);
    LODWORD(v6) = *(_DWORD *)(a1 + 16) - v5;
  }
  if (v4 <= v6)
  {
    sub_10003ECB8(__dst, (const std::string::value_type *)(*(void *)(a1 + 8) + v5), v4 - 1);
    *(_DWORD *)(a1 + 20) += v4;
    return 1;
  }
LABEL_16:
  uint64_t result = 0;
  if (SHIBYTE(__dst->__r_.__value_.__r.__words[2]) < 0)
  {
    *__dst->__r_.__value_.__l.__data_ = 0;
    __dst->__r_.__value_.__l.__size_ = 0;
  }
  else
  {
    __dst->__r_.__value_.__s.__data_[0] = 0;
    *((unsigned char *)&__dst->__r_.__value_.__s + 23) = 0;
  }
  return result;
}

uint64_t sub_100FECA4C(uint64_t a1, std::string *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2 >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  int v3 = *(char *)(*(void *)(a1 + 8) + v2);
  if (*(unsigned char *)(a1 + 33))
  {
    if (v3 < 0) {
      return 0;
    }
  }
  if (v3 == 127) {
    *(_DWORD *)(a1 + 20) = v2 + 1;
  }
  return sub_100FEC944(a1, a2, 0xFFFFFFFF);
}

uint64_t sub_100FECA8C(uint64_t a1, int *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2 >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 20) = v2 + 1;
  unsigned int v4 = *(unsigned __int8 *)(v3 + v2);
  if (v4 > 0x1F) {
    return 0;
  }
  if (v4 == 31) {
    return sub_100FECACC(a1, a2);
  }
  *a2 = v4;
  return 1;
}

uint64_t sub_100FECACC(uint64_t a1, int *a2)
{
  int v2 = 0;
  *a2 = 0;
  int v3 = 5;
  while (1)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 16);
    uint64_t v4 = *(unsigned int *)(a1 + 20);
    if (v5 == v4) {
      return 0;
    }
    if (v4 >= v5) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v4 + 1;
    char v7 = *(unsigned char *)(v6 + v4);
    int v2 = v7 & 0x7F | (*a2 << 7);
    *a2 = v2;
    if ((v7 & 0x80) == 0) {
      return 1;
    }
    if (!--v3) {
      return 0;
    }
  }
  *a2 = v2 << 7;
  return 1;
}

uint64_t sub_100FECB30(uint64_t a1, int *a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2 >= v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = v2 + 1;
  *(_DWORD *)(a1 + 20) = v2 + 1;
  unsigned int v6 = *(unsigned __int8 *)(v4 + v2);
  if (v6 > 0x1E || v3 - v5 < v6) {
    return 0;
  }
  *a2 = 0;
  if (v6)
  {
    int v8 = 0;
    int v9 = 0;
    do
    {
      uint64_t v10 = *(unsigned int *)(a1 + 20);
      if (v10 < *(_DWORD *)(a1 + 16))
      {
        *(_DWORD *)(a1 + 20) = v10 + 1;
        int v9 = *(unsigned __int8 *)(v4 + v10);
        int v8 = *a2;
      }
      int v8 = v9 | (v8 << 8);
      *a2 = v8;
      --v6;
    }
    while (v6);
  }
  return 1;
}

uint64_t sub_100FECBAC(uint64_t a1, int *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2 >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if ((*(char *)(v3 + v2) & 0x80000000) == 0) {
    return sub_100FECB30(a1, a2);
  }
  *(_DWORD *)(a1 + 20) = v2 + 1;
  int v5 = *(char *)(v3 + v2);
  if ((v5 & 0x80000000) == 0) {
    return 0;
  }
  *a2 = v5 & 0x7F;
  return 1;
}

uint64_t sub_100FECBF4(uint64_t a1, std::string *__dst, unsigned int *a3, _DWORD *a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  if (v4 >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  if (*(unsigned char *)(*(void *)(a1 + 8) + v4) == 127)
  {
    *(_DWORD *)(a1 + 20) = v4 + 1;
    if (SHIBYTE(__dst->__r_.__value_.__r.__words[2]) < 0)
    {
      *__dst->__r_.__value_.__l.__data_ = 0;
      __dst->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      __dst->__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__dst->__r_.__value_.__s + 23) = 0;
    }
    uint64_t v13 = sub_100FEC944(a1, __dst, 0xFFFFFFFF);
    unsigned int v27 = 4;
    *a3 = 4;
    if (a4)
    {
      *a4 = 4;
      unsigned int v27 = *a3;
    }
    unsigned int v28 = *(_DWORD *)(a1 + 24);
    if (v27 != v28 && v28)
    {
      if (v27 == 3 && v28 == 106) {
        goto LABEL_48;
      }
      if (sub_100EBEA94((uint64_t)__dst, (uint64_t)__dst, v27, v28))
      {
LABEL_50:
        int v29 = *(_DWORD *)(a1 + 24);
        goto LABEL_51;
      }
    }
    os_log_t v16 = *(os_log_t *)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
      return v13;
    }
    __int16 v30 = sub_100F5EA6C(*a3);
    unsigned int v31 = *a3;
    uint64_t v32 = sub_100F5EA6C(*(_DWORD *)(a1 + 24));
    int v33 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)buf = 136315906;
    uint64_t v44 = v30;
    __int16 v45 = 1024;
    unsigned int v46 = v31;
    __int16 v47 = 2080;
    unint64_t v48 = v32;
    __int16 v49 = 1024;
    int v50 = v33;
    int v21 = "unable to convert from charset %s (%d) to %s (%d)";
    goto LABEL_54;
  }
  if (!*(unsigned char *)(*(void *)(a1 + 8) + v4))
  {
    if (SHIBYTE(__dst->__r_.__value_.__r.__words[2]) < 0)
    {
      *__dst->__r_.__value_.__l.__data_ = 0;
      __dst->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      __dst->__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__dst->__r_.__value_.__s + 23) = 0;
    }
    int v25 = *(_DWORD *)(a1 + 24);
    if (!v25) {
      int v25 = 106;
    }
    *a3 = v25;
    if (a4) {
      *a4 = v25;
    }
    unsigned int v26 = *(_DWORD *)(a1 + 20);
    if (v26 < *(_DWORD *)(a1 + 16)) {
      *(_DWORD *)(a1 + 20) = v26 + 1;
    }
    return 1;
  }
  unsigned int v42 = 0;
  if (!sub_100FECA8C(a1, (int *)&v42))
  {
    *(_DWORD *)(a1 + 20) = v4;
    *a3 = 106;
    if (a4) {
      *a4 = 106;
    }
    uint64_t v13 = sub_100FECA4C(a1, __dst);
    if (v13)
    {
      unsigned int v22 = *a3;
      unsigned int v23 = *(_DWORD *)(a1 + 24);
      if (*a3 != v23)
      {
        if (v23)
        {
          if (v22 == 3 && v23 == 106)
          {
            int v24 = 106;
LABEL_57:
            *a3 = v24;
            return 1;
          }
          if (sub_100EBEA94((uint64_t)__dst, (uint64_t)__dst, v22, v23))
          {
            int v24 = *(_DWORD *)(a1 + 24);
            goto LABEL_57;
          }
        }
      }
    }
    os_log_t v36 = *(os_log_t *)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
      return v13;
    }
    unint64_t v38 = sub_100F5EA6C(*a3);
    unsigned int v39 = *a3;
    long long v40 = sub_100F5EA6C(*(_DWORD *)(a1 + 24));
    int v41 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)buf = 136316162;
    uint64_t v44 = v38;
    __int16 v45 = 1024;
    unsigned int v46 = v39;
    __int16 v47 = 2080;
    unint64_t v48 = v40;
    __int16 v49 = 1024;
    int v50 = v41;
    __int16 v51 = 1024;
    int v52 = v13;
    int v21 = "unable to convert from charset %s (%d) to %s (%d) decodeWspSuccess = (%d)";
    long long v34 = v36;
    uint32_t v35 = 40;
LABEL_61:
    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, v21, buf, v35);
    return v13;
  }
  unsigned int v9 = v42;
  if (v42 < 2) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20);
  if (v10 < v42 || !sub_100FECBAC(a1, (int *)a3)) {
    return 0;
  }
  if (a4) {
    *a4 = *a3;
  }
  unsigned int v12 = *(_DWORD *)(a1 + 16);
  uint64_t v11 = *(unsigned int *)(a1 + 20);
  if (v11 < v12 && *(unsigned char *)(*(void *)(a1 + 8) + v11) == 127)
  {
    LODWORD(v11) = v11 + 1;
    *(_DWORD *)(a1 + 20) = v11;
  }
  uint64_t v13 = sub_100FEC944(a1, __dst, v9 + v12 - (v10 + v11));
  unsigned int v14 = *a3;
  unsigned int v15 = *(_DWORD *)(a1 + 24);
  if (*a3 != v15 && v15)
  {
    if (v14 != 3 || v15 != 106)
    {
      if (!sub_100EBEA94((uint64_t)__dst, (uint64_t)__dst, v14, v15)) {
        goto LABEL_22;
      }
      goto LABEL_50;
    }
LABEL_48:
    int v29 = 106;
LABEL_51:
    *a3 = v29;
    return v13;
  }
LABEL_22:
  os_log_t v16 = *(os_log_t *)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
  {
    int v17 = sub_100F5EA6C(*a3);
    unsigned int v18 = *a3;
    id v19 = sub_100F5EA6C(*(_DWORD *)(a1 + 24));
    int v20 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)buf = 136315906;
    uint64_t v44 = v17;
    __int16 v45 = 1024;
    unsigned int v46 = v18;
    __int16 v47 = 2080;
    unint64_t v48 = v19;
    __int16 v49 = 1024;
    int v50 = v20;
    int v21 = "unable to convert from charset %s (%d) to %s (%d)";
LABEL_54:
    long long v34 = v16;
    uint32_t v35 = 34;
    goto LABEL_61;
  }
  return v13;
}

std::string *sub_100FED034(std::string *result, unsigned int a2, unsigned int a3, std::string *a4)
{
  unsigned int v4 = a3 - a2;
  if (a3 > a2)
  {
    unsigned int v6 = result;
    __int16 v11 = 0;
    *(void *)__str = 0;
    uint64_t v7 = a3 - 1;
    uint64_t v8 = a2;
    do
    {
      snprintf(__str, 0xAuLL, "%.2hhx", *(unsigned __int8 *)(v6->__r_.__value_.__l.__size_ + v8));
      size_t v9 = strlen(__str);
      uint64_t result = std::string::append(a4, __str, v9);
      if (v7 != v8) {
        uint64_t result = std::string::append(a4, " ", 1uLL);
      }
      ++v8;
      --v4;
    }
    while (v4);
  }
  return result;
}

void sub_100FED128()
{
  memset(&v0, 0, sizeof(v0));
  operator new();
}

void sub_100FED55C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FED5B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  memset(&v25, 0, sizeof(v25));
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  if (v4 < v5)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    unsigned int v8 = v4 + 1;
    *(_DWORD *)(a1 + 20) = v4 + 1;
    unint64_t v9 = *(unsigned char *)(v7 + v4) & 0x7F;
    uint64_t v11 = a2 + 8;
    uint64_t v10 = *(void *)(a2 + 8);
    if (v9 < (*(void *)(v11 + 8) - v10) >> 3 && (uint64_t v12 = *(void *)(v10 + 8 * v9)) != 0)
    {
      sub_100FED034((std::string *)a1, v4, v8, &v25);
      unsigned int v13 = *(_DWORD *)(a1 + 20);
      uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(v12 + 32) + 96))(*(void *)(v12 + 32));
      uint64_t v3 = v14;
      if (v14)
      {
        int v15 = *(_DWORD *)(a1 + 20);
        if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 24))(v14, a1) & 1) == 0)
        {
          if ((*(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20)) >= 0x1E) {
            int v16 = 30;
          }
          else {
            int v16 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 20);
          }
          std::string::append(&v25, " ", 1uLL);
          sub_100FED034((std::string *)a1, *(_DWORD *)(a1 + 20) - 1, *(_DWORD *)(a1 + 20) + v16, &v25);
          int v17 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
          {
            uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
            int v24 = &v25;
            if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              int v24 = (std::string *)v25.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)buf = 136315650;
            *(void *)unsigned int v27 = v23;
            *(_WORD *)&v27[8] = 1024;
            *(_DWORD *)unsigned int v28 = v16;
            *(_WORD *)&v28[4] = 2080;
            v29[0] = v24;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "unable to decode encoded header '%s': next %d bytes: %s", buf, 0x1Cu);
          }
          (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
          uint64_t v3 = 0;
          *(_DWORD *)(a1 + 20) = v15;
        }
        std::string::append(&v25, ": ", 2uLL);
        sub_100FED034((std::string *)a1, v13, *(_DWORD *)(a1 + 20), &v25);
      }
    }
    else
    {
      if (v5 - v8 >= 0x1E) {
        int v18 = 30;
      }
      else {
        int v18 = v5 - v8;
      }
      sub_100FED034((std::string *)a1, v4, v18 + v8, &v25);
      id v19 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        int v21 = *(_DWORD *)(a1 + 20);
        unsigned int v22 = &v25;
        if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unsigned int v22 = (std::string *)v25.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)unsigned int v27 = v9;
        *(_WORD *)&v27[4] = 1024;
        *(_DWORD *)&v27[6] = v21;
        *(_WORD *)unsigned int v28 = 1024;
        *(_DWORD *)&v28[2] = v18;
        LOWORD(v29[0]) = 2080;
        *(void *)((char *)v29 + 2) = v22;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "unknown header encoding 0x%.2x at byte %u: next %d bytes %s", buf, 0x1Eu);
      }
      uint64_t v3 = 0;
    }
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  return v3;
}

void sub_100FED8CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FED8F8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if (v2 >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  if ((*(char *)(*(void *)(a1 + 8) + v2) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 34)) {
      sub_100FED128();
    }
    return 0;
  }
  return sub_100FED5B4(a1, a2);
}

uint64_t sub_100FED928(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 1;
  while (1)
  {
    if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
      return 1;
    }
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    uint64_t v6 = sub_100FED8F8(a1, v5);
    if (!v6) {
      break;
    }
    uint64_t v7 = v6;
    sub_100CC9AE4(a2, v6, 1);
    unsigned int v8 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 64))(v7);
    if (!strcmp(v8, "Content-Type")) {
      return v4;
    }
  }
  return 0;
}

void sub_100FEDA08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100CCA330(a2, "Content-Type");
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 24);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = v5 + 8;
  uint64_t v7 = sub_100CCA3B0(v5 + 8, "charset");
  unsigned int v8 = (unsigned int *)(v7 + 20);
  if (!v7) {
    unsigned int v8 = (unsigned int *)&unk_1015989E4;
  }
  unsigned int v9 = *v8;
  if (!*v8)
  {
    unsigned int v9 = *(_DWORD *)(a1 + 28);
    sub_10095B91C(v6, v9);
  }
  if (v9 != *(_DWORD *)(a1 + 24))
  {
    memset(&__p, 0, sizeof(__p));
    sub_10003ECB8(&__p, *(const std::string::value_type **)(a2 + 72), *(unsigned int *)(a2 + 96));
    unsigned int v10 = *(_DWORD *)(a1 + 24);
    if (v9 != v10 && v10 != 0)
    {
      if (v9 == 3 && v10 == 106 || sub_100EBEA94((uint64_t)&__p, (uint64_t)&__p, v9, v10)) {
        goto LABEL_21;
      }
      unsigned int v10 = *(_DWORD *)(a1 + 24);
    }
    if (!sub_100EBEA94((uint64_t)&__p, (uint64_t)&__p, v10, v10)
      && !sub_100EBEA94((uint64_t)&__p, (uint64_t)&__p, 3u, *(_DWORD *)(a1 + 24)))
    {
      uint64_t v12 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        unsigned int v13 = sub_100F5EA6C(v9);
        uint64_t v14 = sub_100F5EA6C(*(_DWORD *)(a1 + 24));
        int v15 = *(_DWORD *)(a1 + 24);
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v14;
        __int16 v29 = 1024;
        int v30 = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "unable to convert from charset %s (%d) to %s (%d)", buf, 0x22u);
      }
      goto LABEL_28;
    }
LABEL_21:
    unsigned int v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unsigned int v16 = __p.__r_.__value_.__r.__words[1];
    }
    sub_1003BF7D0((unint64_t *)a2, (char *)p_p, v16);
    sub_10095B91C(v6, *(_DWORD *)(a1 + 24));
    uint64_t v18 = sub_100CCA330(a2, "Content-Disposition");
    if (v18) {
      sub_10095B91C(v18 + 32, *(_DWORD *)(a1 + 24));
    }
LABEL_28:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v19 = sub_100CCA3B0(v6, "charset");
  int v20 = (_DWORD *)(v19 + 20);
  if (!v19) {
    int v20 = &unk_1015989E4;
  }
  if (*v20 == 106)
  {
    memset(buf, 0, 24);
    sub_10003ECB8((std::string *)buf, *(const std::string::value_type **)(a2 + 72), *(unsigned int *)(a2 + 96));
    int v21 = *(NSObject **)a1;
    BOOL v22 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR);
    if (v22)
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "About to decode the body private -> public", (uint8_t *)&__p, 2u);
    }
    uint64_t v23 = *(unsigned int *)(a1 + 36);
    Registry::get((uint64_t *)&v26, (Registry *)v22);
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v26;
    long long v26 = 0uLL;
    sub_10079694C(v23, (Registry **)&__p, (std::string *)buf, 1);
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
    if (*((void *)&v26 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v26 + 1));
    }
    unsigned int v24 = buf[23];
    if (buf[23] >= 0) {
      std::string v25 = buf;
    }
    else {
      std::string v25 = *(char **)buf;
    }
    if (buf[23] < 0) {
      unsigned int v24 = *(_DWORD *)&buf[8];
    }
    sub_1003BF7D0((unint64_t *)a2, v25, v24);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_100FEDD48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FEDDAC(NSObject **a1, int a2)
{
  std::string __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (sub_100FEDF58(a1, &__p))
  {
    uint64_t v4 = __p;
    if (v12 != __p)
    {
      unint64_t v5 = 0;
      uint64_t v6 = 0;
      unsigned int v7 = 1;
      while (1)
      {
        if (v6)
        {
          if ((int)sub_100FEE318(v6, v4[v5]) < 1)
          {
            uint64_t v4 = __p;
            uint64_t v8 = *((void *)__p + v5);
            if (v8)
            {
              (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
              uint64_t v4 = __p;
            }
            goto LABEL_8;
          }
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
          uint64_t v4 = __p;
        }
        uint64_t v6 = v4[v5];
LABEL_8:
        unint64_t v5 = v7++;
        if (v5 >= (v12 - (unsigned char *)v4) >> 3) {
          goto LABEL_15;
        }
      }
    }
  }
  unsigned int v9 = *a1;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    int v15 = a2;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "unable to decode multipart/alternative part %u", buf, 8u);
  }
  uint64_t v6 = 0;
LABEL_15:
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }
  return v6;
}

void sub_100FEDF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100FEDF58(uint64_t a1, uint64_t **a2)
{
  unsigned int v44 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (sub_100FECACC(a1, (int *)&v44))
  {
    memset(&__p, 0, sizeof(__p));
    sub_100FED034((std::string *)a1, v4, *(_DWORD *)(a1 + 20), &__p);
    unsigned int v5 = v44;
    if (v44)
    {
      BOOL v6 = 0;
      unsigned int v7 = 0;
      while (1)
      {
        uint64_t v8 = sub_100FEE3B0(a1, v7);
        uint64_t v9 = v8;
        if (!v8) {
          break;
        }
        uint64_t v11 = a2[1];
        unint64_t v10 = (unint64_t)a2[2];
        if ((unint64_t)v11 >= v10)
        {
          uint64_t v13 = v11 - *a2;
          if ((unint64_t)(v13 + 1) >> 61) {
            sub_10022E78C();
          }
          uint64_t v14 = v10 - (void)*a2;
          uint64_t v15 = v14 >> 2;
          if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
            uint64_t v15 = v13 + 1;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v15;
          }
          if (v16) {
            int v17 = (char *)sub_10004EF74((uint64_t)(a2 + 2), v16);
          }
          else {
            int v17 = 0;
          }
          uint64_t v18 = (uint64_t *)&v17[8 * v13];
          *uint64_t v18 = v9;
          uint64_t v12 = v18 + 1;
          int v20 = (char *)*a2;
          uint64_t v19 = (char *)a2[1];
          if (v19 != (char *)*a2)
          {
            do
            {
              uint64_t v21 = *((void *)v19 - 1);
              v19 -= 8;
              *--uint64_t v18 = v21;
            }
            while (v19 != v20);
            uint64_t v19 = (char *)*a2;
          }
          *a2 = v18;
          a2[1] = v12;
          a2[2] = (uint64_t *)&v17[8 * v16];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          *uint64_t v11 = v8;
          uint64_t v12 = v11 + 1;
        }
        a2[1] = v12;
        BOOL v6 = ++v7 >= v5;
        if (v7 == v5) {
          goto LABEL_22;
        }
      }
      long long v40 = (char *)*a2;
      int v41 = (char *)a2[1];
      if (*a2 != (uint64_t *)v41)
      {
        do
        {
          if (*(void *)v40) {
            (*(void (**)(void))(**(void **)v40 + 8))(*(void *)v40);
          }
          v40 += 8;
        }
        while (v40 != v41);
        long long v40 = (char *)*a2;
      }
      a2[1] = (uint64_t *)v40;
    }
    else
    {
LABEL_22:
      int v22 = *(_DWORD *)(a1 + 20);
      if (*(_DWORD *)(a1 + 16) != v22)
      {
        int v23 = 0;
        do
        {
          uint64_t v24 = sub_100FEE3B0(a1, v5);
          uint64_t v25 = v24;
          if (!v24)
          {
            *(_DWORD *)(a1 + 20) = v22;
            goto LABEL_55;
          }
          unsigned int v27 = a2[1];
          unint64_t v26 = (unint64_t)a2[2];
          if ((unint64_t)v27 >= v26)
          {
            uint64_t v29 = v27 - *a2;
            if ((unint64_t)(v29 + 1) >> 61) {
              sub_10022E78C();
            }
            uint64_t v30 = v26 - (void)*a2;
            uint64_t v31 = v30 >> 2;
            if (v30 >> 2 <= (unint64_t)(v29 + 1)) {
              uint64_t v31 = v29 + 1;
            }
            if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v32 = v31;
            }
            if (v32) {
              int v33 = (char *)sub_10004EF74((uint64_t)(a2 + 2), v32);
            }
            else {
              int v33 = 0;
            }
            long long v34 = (uint64_t *)&v33[8 * v29];
            uint64_t *v34 = v25;
            unsigned int v28 = v34 + 1;
            os_log_t v36 = (char *)*a2;
            uint32_t v35 = (char *)a2[1];
            if (v35 != (char *)*a2)
            {
              do
              {
                uint64_t v37 = *((void *)v35 - 1);
                v35 -= 8;
                *--long long v34 = v37;
              }
              while (v35 != v36);
              uint32_t v35 = (char *)*a2;
            }
            *a2 = v34;
            a2[1] = v28;
            a2[2] = (uint64_t *)&v33[8 * v32];
            if (v35) {
              operator delete(v35);
            }
          }
          else
          {
            *unsigned int v27 = v24;
            unsigned int v28 = v27 + 1;
          }
          a2[1] = v28;
          ++v23;
          int v22 = *(_DWORD *)(a1 + 20);
        }
        while (*(_DWORD *)(a1 + 16) != v22);
        if (v23)
        {
          unint64_t v38 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109376;
            int v46 = v23 + v5;
            __int16 v47 = 1024;
            unsigned int v48 = v5;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I found %u actual entries with nEntries = %u", buf, 0xEu);
          }
        }
      }
LABEL_55:
      BOOL v6 = 1;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    unsigned int v39 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "unable to decode nEntries for multipart message", (uint8_t *)&__p, 2u);
    }
    return 0;
  }
  return v6;
}

void sub_100FEE2EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FEE318(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_100CCA330(a1, "Content-Type");
  if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0) {
    int v5 = !sub_10035F95C(v4, "text", "plain");
  }
  else {
    int v5 = 100;
  }
  uint64_t v6 = sub_100CCA330(a2, "Content-Type");
  if (v6 && (uint64_t v7 = *(void *)(v6 + 24)) != 0) {
    int v8 = sub_10035F95C(v7, "text", "plain") - 1;
  }
  else {
    int v8 = -100;
  }
  return (v8 + v5);
}

uint64_t sub_100FEE3B0(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (*(_DWORD *)(a1 + 16) != v4)
  {
    unsigned int v26 = 0;
    if (sub_100FECACC(a1, (int *)&v26))
    {
      memset(&__p, 0, sizeof(__p));
      sub_100FED034((std::string *)a1, v4, *(_DWORD *)(a1 + 20), &__p);
      int v24 = 0;
      unsigned int v5 = *(_DWORD *)(a1 + 20);
      if (*(_DWORD *)(a1 + 16) == v5 || (sub_100FECACC(a1, &v24) & 1) == 0)
      {
        int v8 = *(NSObject **)a1;
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          goto LABEL_11;
        }
        *(_DWORD *)buf = 67109120;
        unsigned int v28 = a2;
        unint64_t v10 = "Couldn't decode dataLen for part %u";
      }
      else
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          *__p.__r_.__value_.__l.__data_ = 0;
          __p.__r_.__value_.__l.__size_ = 0;
        }
        else
        {
          __p.__r_.__value_.__s.__data_[0] = 0;
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
        }
        sub_100FED034((std::string *)a1, v5, *(_DWORD *)(a1 + 20), &__p);
        int v9 = *(_DWORD *)(a1 + 20);
        if (*(_DWORD *)(a1 + 16) != v9)
        {
          uint64_t v11 = sub_100CC980C();
          uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(v11 + 32) + 96))(*(void *)(v11 + 32));
          if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 24))(v12, a1))
          {
            int v14 = *(_DWORD *)(a1 + 16);
            int v13 = *(_DWORD *)(a1 + 20);
            unsigned int v15 = v9 - v13 + v26;
            unsigned int v26 = v15;
            int v16 = v14 - v13;
            if (v15 <= v14 - v13) {
              operator new();
            }
            int v17 = *(NSObject **)a1;
            if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109376;
              unsigned int v28 = v15;
              __int16 v29 = 1024;
              int v30 = v16;
              _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "HeadersLen %u > remaining %u", buf, 0xEu);
            }
            sub_100058DB0(v20, "");
            sub_100FEEBA4(a1, "bad_part_headersfLen", (uint64_t)v20);
            if ((v21 & 0x80000000) == 0) {
              goto LABEL_11;
            }
            uint64_t v18 = (void *)v20[0];
          }
          else
          {
            uint64_t v19 = *(NSObject **)a1;
            if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              unsigned int v28 = a2;
              _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Couldn't decode Content-Type for part %u", buf, 8u);
            }
            sub_100058DB0(v22, "");
            sub_100FEEBA4(a1, "bad_part_content_type", (uint64_t)v22);
            if ((v23 & 0x80000000) == 0) {
              goto LABEL_11;
            }
            uint64_t v18 = v22[0];
          }
          operator delete(v18);
LABEL_11:
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          return 0;
        }
        int v8 = *(NSObject **)a1;
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          goto LABEL_11;
        }
        *(_DWORD *)buf = 67109120;
        unsigned int v28 = a2;
        unint64_t v10 = "out of buffer before Content-Type for part %u";
      }
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v10, buf, 8u);
      goto LABEL_11;
    }
  }
  uint64_t v6 = *(NSObject **)a1;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v28 = a2;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Couldn't decode headersLen for part %u", buf, 8u);
  }
  return 0;
}

void sub_100FEEAE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FEEBA4(uint64_t a1, const char *a2, uint64_t a3)
{
  unsigned int v4 = *(const void **)(a1 + 8);
  size_t v5 = *(unsigned int *)(a1 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v7 = *(void *)(a3 + 16);
  }
  sub_100FF02BC(a2, v4, v5, (uint64_t)__p);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100FEEC28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FEEC44(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 20);
  if (v1 >= *(_DWORD *)(a1 + 16)) {
    return 0;
  }
  if (*(char *)(*(void *)(a1 + 8) + v1) < 0)
  {
    *(_DWORD *)(a1 + 20) = v1 + 1;
    operator new();
  }
  unsigned int v18 = 0;
  if (sub_100FECA8C(a1, (int *)&v18))
  {
    int v3 = *(_DWORD *)(a1 + 20);
    int v17 = 0;
    if (sub_100FECBAC(a1, &v17)) {
      operator new();
    }
    *(_DWORD *)(a1 + 20) = v3;
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v15 = 0;
    char v6 = sub_100FEC944(a1, (std::string *)__p, 0xFFFFFFFF);
    if (v6)
    {
      if ((SBYTE7(v15) & 0x80u) == 0) {
        uint64_t v7 = (char *)__p;
      }
      else {
        uint64_t v7 = (char *)__p[0];
      }
      uint64_t v5 = sub_10035FDE0(v7);
      if (v5)
      {
LABEL_19:
        if (SBYTE7(v15) < 0) {
          operator delete(__p[0]);
        }
        if (v6)
        {
          int v9 = *(_DWORD *)(a1 + 20);
          unsigned int v10 = v3 - v9 + v18;
          unsigned int v18 = v10;
          if (v5)
          {
            uint64_t v16 = 0;
            *(_OWORD *)std::string __p = 0u;
            long long v15 = 0u;
            sub_100FEC818((ctu::OsLogLogger *)__p, a1, v10);
            if ((sub_100FED928((uint64_t)__p, v5 + 8) & 1) == 0)
            {
              (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
              uint64_t v5 = 0;
            }
            ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)__p);
            unsigned int v10 = v18;
            int v9 = *(_DWORD *)(a1 + 20);
          }
          if (*(_DWORD *)(a1 + 16) - v9 < v10) {
            unsigned int v10 = *(_DWORD *)(a1 + 16) - v9;
          }
          *(_DWORD *)(a1 + 20) = v10 + v9;
          return v5;
        }
        return 0;
      }
      int v8 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        int v13 = __p;
        if (SBYTE7(v15) < 0) {
          int v13 = (void **)__p[0];
        }
        *(_DWORD *)buf = 136315138;
        int v20 = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%s is not a valid content type", buf, 0xCu);
      }
    }
    uint64_t v5 = 0;
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 20) = v1;
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v15 = 0;
  if (sub_100FEC944(a1, (std::string *)__p, 0xFFFFFFFF))
  {
    if ((SBYTE7(v15) & 0x80u) == 0) {
      unsigned int v4 = (char *)__p;
    }
    else {
      unsigned int v4 = (char *)__p[0];
    }
    uint64_t v5 = sub_10035FDE0(v4);
  }
  else
  {
    uint64_t v12 = *(NSObject **)a1;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "couldn't decode contentType", buf, 2u);
    }
    uint64_t v5 = 0;
  }
  if (SBYTE7(v15) < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_100FEEF4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_100FEEFA8()
{
}

void sub_100FEFB08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FEFBD8(uint64_t a1, void *a2, std::string *a3, std::string *a4, std::string *a5, std::string *a6)
{
  unsigned int v14 = 0;
  int v12 = sub_100FECBAC(a1, (int *)&v14);
  uint64_t result = 0;
  if (v12)
  {
    uint64_t result = sub_100FEC944(a1, a3, 0xFFFFFFFF);
    if (result)
    {
      uint64_t result = sub_100FEC944(a1, a4, 0xFFFFFFFF);
      if (result)
      {
        uint64_t result = sub_100FEC944(a1, a5, 0xFFFFFFFF);
        if (result) {
          uint64_t result = sub_100FEC944(a1, a6, 0xFFFFFFFF);
        }
      }
    }
  }
  *a2 = v14;
  return result;
}

uint64_t sub_100FEFC90(uint64_t a1, _DWORD *a2)
{
  *a2 = -1;
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 20);
  if (v4 - v3 <= 2)
  {
    uint64_t v5 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v4;
      char v6 = "unable to decode wap push: bodylen = %u";
LABEL_33:
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, buf, 8u);
      return 0;
    }
    return 0;
  }
  if (v4 > v3) {
    *(_DWORD *)(a1 + 20) = ++v3;
  }
  if (v3 >= v4)
  {
    int v9 = 0;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v3 + 1;
    int v9 = *(unsigned __int8 *)(v8 + v3++);
  }
  if (v3 >= v4)
  {
    unsigned int v11 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 8);
    *(_DWORD *)(a1 + 20) = v3 + 1;
    unsigned int v11 = *(unsigned __int8 *)(v10 + v3++);
  }
  if (v9 != 6)
  {
    uint64_t v5 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v9;
      char v6 = "unable to decode wap push: unknown PDU type %u";
      goto LABEL_33;
    }
    return 0;
  }
  if (v4 - v3 >= v11)
  {
    uint64_t v33 = 0;
    *(_OWORD *)buf = 0u;
    long long v32 = 0u;
    uint64_t v13 = sub_100FEC818((ctu::OsLogLogger *)buf, a1, v11);
    uint64_t v14 = sub_100FEEC44(v13);
    if (!v14)
    {
      unsigned int v18 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v27 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "unable to decode wap push: bad content type", v27, 2u);
      }
      goto LABEL_51;
    }
    *(void *)unsigned int v27 = 0;
    unint64_t v28 = 0;
    uint64_t v29 = 0;
    sub_100058DB0(v27, "application/vnd.wap.mms-message");
    std::string __p = 0;
    size_t v25 = 0;
    uint64_t v26 = 0;
    if (!sub_10035F71C(v14, (uint64_t)&__p))
    {
LABEL_46:
      int v22 = *(NSObject **)a1;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        p_p = &__p;
        if (v26 < 0) {
          p_p = __p;
        }
        *(_DWORD *)int v30 = 136315138;
        *(void *)&v30[4] = p_p;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Ignoring WAP push with content type [%s]", v30, 0xCu);
      }
      *a2 = 1;
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      if (SHIBYTE(v26) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v29) < 0) {
        operator delete(*(void **)v27);
      }
LABEL_51:
      ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)buf);
      return 0;
    }
    if (v29 >= 0) {
      unint64_t v15 = HIBYTE(v29);
    }
    else {
      unint64_t v15 = v28;
    }
    if (SHIBYTE(v26) < 0)
    {
      if (v15 != -1)
      {
        int v17 = __p;
        if (v25 >= v15) {
          size_t v16 = v15;
        }
        else {
          size_t v16 = v25;
        }
        goto LABEL_38;
      }
    }
    else if (v15 != -1)
    {
      if (HIBYTE(v26) >= v15) {
        size_t v16 = v15;
      }
      else {
        size_t v16 = HIBYTE(v26);
      }
      int v17 = &__p;
LABEL_38:
      if (v29 >= 0) {
        uint64_t v19 = v27;
      }
      else {
        uint64_t v19 = *(uint8_t **)v27;
      }
      if (!memcmp(v17, v19, v16) && v16 == v15)
      {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        int v20 = *(_DWORD *)(a1 + 20);
        unsigned int v21 = *(_DWORD *)(a1 + 16) - v20;
        if (v21 >= v11) {
          unsigned int v21 = v11;
        }
        *(_DWORD *)(a1 + 20) = v21 + v20;
        sub_100FEEFA8();
      }
      goto LABEL_46;
    }
    sub_1000C14D8();
  }
  uint64_t v5 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v11;
    char v6 = "unable to decode wap push: bad wspHeaderLen %u";
    goto LABEL_33;
  }
  return 0;
}

void sub_100FF0264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v21 - 96));
  _Unwind_Resume(a1);
}

uint64_t sub_100FF02BC(const char *a1, const void *a2, size_t a3, uint64_t a4)
{
  uint64_t result = sub_10121F67C();
  if (result)
  {
    uint64_t result = sub_10121F6B4();
    if (result)
    {
      uint64_t v44 = 0;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      *(_OWORD *)long long v32 = 0u;
      long long v33 = 0u;
      memset(v31, 0, sizeof(v31));
      sub_10004DE24((uint64_t)v31);
      std::string __p = 0;
      long long v30 = 0uLL;
      WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
      sub_100058DB0(&v28, WirelessUserDirectory);
      uint64_t v10 = std::string::append(&v28, "/Library/Logs/CrashReporter/", 0x1CuLL);
      unsigned int v11 = (void *)v10->__r_.__value_.__r.__words[0];
      v45[0] = v10->__r_.__value_.__l.__size_;
      *(void *)((char *)v45 + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
      unsigned int v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v30) < 0) {
        operator delete(__p);
      }
      std::string __p = v11;
      *(void *)&long long v30 = v45[0];
      *(void *)((char *)&v30 + 7) = *(void *)((char *)v45 + 7);
      HIBYTE(v30) = v12;
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v28.__r_.__value_.__l.__data_);
        unsigned int v12 = HIBYTE(v30);
        unsigned int v11 = __p;
      }
      uint64_t v13 = *(unsigned __int8 *)(a4 + 23);
      if ((v13 & 0x80u) != 0) {
        uint64_t v13 = *(void *)(a4 + 8);
      }
      if ((v12 & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (void **)v11;
      }
      if ((v12 & 0x80u) == 0) {
        uint64_t v15 = v12;
      }
      else {
        uint64_t v15 = v30;
      }
      if (v13)
      {
        size_t v16 = sub_10004B96C(v31, (uint64_t)p_p, v15);
        size_t v17 = strlen(a1);
        unsigned int v18 = sub_10004B96C(v16, (uint64_t)a1, v17);
        int v19 = *(char *)(a4 + 23);
        if (v19 >= 0) {
          uint64_t v20 = a4;
        }
        else {
          uint64_t v20 = *(void *)a4;
        }
        if (v19 >= 0) {
          uint64_t v21 = *(unsigned __int8 *)(a4 + 23);
        }
        else {
          uint64_t v21 = *(void *)(a4 + 8);
        }
        sub_10004B96C(v18, v20, v21);
        time(0);
      }
      else
      {
        int v22 = sub_10004B96C(v31, (uint64_t)p_p, v15);
        size_t v23 = strlen(a1);
        int v24 = sub_10004B96C(v22, (uint64_t)a1, v23);
        sub_10004B96C(v24, (uint64_t)"_error_", 7);
        time(0);
      }
      size_t v25 = (void *)std::ostream::operator<<();
      sub_10004B96C(v25, (uint64_t)".mms", 4);
      memset(&v28, 0, sizeof(v28));
      sub_10004BC98((uint64_t)v31 + 8, &v28);
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v26 = &v28;
      }
      else {
        uint64_t v26 = (std::string *)v28.__r_.__value_.__r.__words[0];
      }
      unsigned int v27 = fopen((const char *)v26, "w");
      if (v27)
      {
        fwrite(a2, 1uLL, a3, v27);
        fclose(v27);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v33) < 0) {
        operator delete(v32[1]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      return std::ios::~ios();
    }
  }
  return result;
}

void sub_100FF063C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void SuppServicesHandler::create()
{
}

void sub_100FF0784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9)
  {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
    if (!v9)
    {
LABEL_3:
      if (v10) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v9)
  {
    goto LABEL_3;
  }
  dispatch_release(v9);
  if (v10) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_100FF07F0(uint64_t a1, dispatch_object_t *a2)
{
  unsigned int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF08F0(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  uint64_t v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF0A14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t SuppServicesHandler::SuppServicesHandler(uint64_t a1, uint64_t a2, dispatch_object_t *a3, uint64_t *a4)
{
  uint64_t v8 = (void *)(a1 + 8);
  int v9 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v52, kCtLoggingSystemName, "set.supp");
  if (v9) {
    dispatch_retain(v9);
  }
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  unsigned int v11 = dispatch_queue_create_with_target_V2("SuppServicesHandler", initially_inactive, v9);
  dispatch_set_qos_class_floor(v11, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v11);
  void *v8 = 0;
  v8[1] = 0;
  *(void *)(a1 + 24) = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  if (v11) {
    dispatch_release(v11);
  }
  if (v9) {
    dispatch_release(v9);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v39, &v52);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v39);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v39);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v52);
  if (v9) {
    dispatch_release(v9);
  }
  v51[0] = off_101999E18;
  v51[1] = sub_100FF1658;
  v51[3] = v51;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v12) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v51);
  *(void *)a1 = off_101A7BD88;
  *(void *)(a1 + 56) = off_101A7BFF0;
  *(void *)(a1 + 64) = off_101A7C038;
  *(void *)(a1 + 72) = a1 + 72;
  *(void *)(a1 + 80) = a1 + 72;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = *(void *)a2;
  uint64_t v13 = *(void *)(a2 + 8);
  *(void *)(a1 + 104) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *a4;
  uint64_t v15 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  (*(void (**)(OsLogContext *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v14 + 56))(&v52, v14, &object);
  *(OsLogContext *)(a1 + 112) = v52;
  v52.var0 = 0;
  v52.var1.fRef = 0;
  if (object) {
    dispatch_release(object);
  }
  uint64_t v16 = *a4;
  *a4 = 0;
  *(void *)(a1 + 128) = v16;
  Registry::getCommandDriversFactory((uint64_t *)&v52, *(Registry **)a2);
  var0 = v52.var0;
  unsigned int v18 = *(NSObject **)(a1 + 24);
  dispatch_object_t v49 = v18;
  if (v18) {
    dispatch_retain(v18);
  }
  (*(void (**)(char *, dispatch_object_t *))(*(void *)var0 + 160))(var0, &v49);
  if (v49) {
    dispatch_release(v49);
  }
  if (v52.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v52.var1.fRef);
  }
  uint64_t v19 = *(void *)(a1 + 128);
  uint64_t v20 = *(NSObject **)(a1 + 24);
  dispatch_object_t v48 = v20;
  if (v20) {
    dispatch_retain(v20);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v19 + 16))(v19, &v48);
  if (v48) {
    dispatch_release(v48);
  }
  uint64_t v21 = *(void *)(a1 + 128);
  int v22 = *(NSObject **)(a1 + 24);
  dispatch_object_t v47 = v22;
  if (v22) {
    dispatch_retain(v22);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v21 + 24))(v21, &v47);
  if (v47) {
    dispatch_release(v47);
  }
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  size_t v23 = (uint64_t *)(a1 + 240);
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 232) = a1 + 240;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(void *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(void *)(a1 + 368) = 0;
  uint64_t v24 = *(void *)(a1 + 128);
  size_t v25 = *(NSObject **)(a1 + 24);
  dispatch_object_t v46 = v25;
  if (v25) {
    dispatch_retain(v25);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v24 + 32))(v24, &v46);
  if (v46) {
    dispatch_release(v46);
  }
  sub_100058DB0(&__p, "SuppServicesHandler");
  uint64_t v26 = *(NSObject **)(a1 + 24);
  dispatch_object_t v43 = v26;
  if (v26) {
    dispatch_retain(v26);
  }
  unsigned int v27 = *a3;
  dispatch_object_t v42 = v27;
  if (v27) {
    dispatch_retain(v27);
  }
  ctu::RestModule::RestModule();
  if (v42) {
    dispatch_release(v42);
  }
  if (v43) {
    dispatch_release(v43);
  }
  if (v45 < 0) {
    operator delete(__p);
  }
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(void *)(a1 + 464) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(void *)(a1 + 448) = a1 + 456;
  *(void *)(a1 + 480) = a1 + 488;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 520) = 0;
  *(void *)(a1 + 504) = a1 + 512;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 528) = a1 + 536;
  *(void *)(a1 + 568) = 0;
  *(void *)(a1 + 552) = a1 + 560;
  *(void *)(a1 + 560) = 0;
  sub_1000FE9CC((uint64_t *)(a1 + 576), (uint64_t)&rest::kDefaultBundles);
  *(void *)(a1 + 616) = 0;
  *(void *)(a1 + 608) = 0;
  *(void *)(a1 + 600) = a1 + 608;
  *(void *)(a1 + 624) = 0;
  *(void *)(a1 + 648) = 0;
  *(void *)(a1 + 640) = 0;
  *(void *)(a1 + 632) = a1 + 640;
  *(_DWORD *)(a1 + 656) = 0;
  *(void *)(a1 + 680) = 0;
  *(void *)(a1 + 672) = 0;
  *(void *)(a1 + 664) = a1 + 672;
  *(void *)(a1 + 704) = 0;
  *(void *)(a1 + 696) = 0;
  *(void *)(a1 + 688) = a1 + 696;
  subscriber::makeSimSlotRange();
  uint64_t v29 = v39;
  std::string v28 = v40;
  if (v39 != v40)
  {
    long long v30 = v41;
    while ((v30(*v29) & 1) == 0)
    {
      if (++v29 == v28)
      {
        uint64_t v29 = v28;
        break;
      }
    }
    long long v38 = v40;
    while (v29 != v38)
    {
      signed int v31 = *v29;
      uint64_t v32 = *v23;
      if (!*v23)
      {
LABEL_65:
        uint64_t v53 = 0;
        long long v35 = (char *)operator new(0xD8uLL);
        v52.var0 = v35;
        v52.var1.fRef = (os_log_s *)(a1 + 240);
        *((_DWORD *)v35 + 8) = v31;
        *((_DWORD *)v35 + 10) = v31;
        *((void *)v35 + 6) = 0;
        *((void *)v35 + 7) = 0;
        sub_100AB7CDC((void *)v35 + 8);
      }
      while (1)
      {
        while (1)
        {
          long long v33 = (uint64_t *)v32;
          signed int v34 = *(_DWORD *)(v32 + 32);
          if (v34 <= v31) {
            break;
          }
          uint64_t v32 = *v33;
          if (!*v33) {
            goto LABEL_65;
          }
        }
        if (v34 >= v31) {
          break;
        }
        uint64_t v32 = v33[1];
        if (!v32) {
          goto LABEL_65;
        }
      }
      long long v36 = v29 + 1;
      uint64_t v29 = v28;
      if (v36 != v28)
      {
        uint64_t v29 = v36;
        while ((v30(*v29) & 1) == 0)
        {
          if (++v29 == v28)
          {
            uint64_t v29 = v28;
            break;
          }
        }
      }
    }
  }
  return a1;
}

void sub_100FF12DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, dispatch_object_t object, dispatch_object_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,dispatch_object_t a27,dispatch_object_t a28,dispatch_object_t a29,dispatch_object_t a30,dispatch_object_t a31,char a32)
{
  sub_10008863C((void *)(v32 - 128));
  operator delete();
}

const char *sub_100FF1658(int a1)
{
  uint64_t v1 = "set.supp.?";
  if (a1 == 2) {
    uint64_t v1 = "set.supp.2";
  }
  if (a1 == 1) {
    return "set.supp.1";
  }
  else {
    return v1;
  }
}

void *sub_100FF1684(uint64_t a1)
{
  sub_10005D144(*(void **)(a1 + 40));

  return sub_100FFDB7C((void *)a1);
}

uint64_t sub_100FF16C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_100FFDC00(a1);
}

uint64_t sub_100FF1724(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_100FFDCC8(a1);
}

void sub_100FF1788(uint64_t a1)
{
  *(void *)a1 = off_101A7BD88;
  uint64_t v2 = (SuppServicesPreferencesDelegateInterface *)(a1 + 56);
  *(void *)(a1 + 56) = off_101A7BFF0;
  unsigned int v3 = (SuppServicesDriverEventHandlerInterface *)(a1 + 64);
  *(void *)(a1 + 64) = off_101A7C038;
  sub_1000346F8(a1 + 688, *(void **)(a1 + 696));
  sub_10005CD2C(a1 + 664, *(char **)(a1 + 672));
  sub_100087ED0(a1 + 632, *(void **)(a1 + 640));
  sub_10030AAD0(a1 + 600, *(void **)(a1 + 608));
  sub_100087F94(a1 + 576, *(void **)(a1 + 584));
  sub_10005CD2C(a1 + 552, *(char **)(a1 + 560));
  sub_10005CD2C(a1 + 528, *(char **)(a1 + 536));
  sub_1007035FC(a1 + 504, *(void **)(a1 + 512));
  sub_10005CD2C(a1 + 480, *(char **)(a1 + 488));
  sub_10005D144(*(void **)(a1 + 456));
  sub_100FFDB7C((void *)(a1 + 416));
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 408);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 392);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  sub_100FFDC00(a1 + 320);
  uint64_t v7 = *(void *)(a1 + 304);
  *(void *)(a1 + 304) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  sub_100FFDCC8(a1 + 256);
  sub_101001FFC(*(void **)(a1 + 240));
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 224);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  int v9 = *(std::__shared_weak_count **)(a1 + 208);
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v10 = *(std::__shared_weak_count **)(a1 + 192);
  if (v10) {
    sub_10004D2C8(v10);
  }
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 176);
  if (v11) {
    sub_10004D2C8(v11);
  }
  unsigned int v12 = *(std::__shared_weak_count **)(a1 + 160);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 144);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 120);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 104);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_100160A84((atomic_uint **)(a1 + 72));
  SuppServicesDriverEventHandlerInterface::~SuppServicesDriverEventHandlerInterface(v3);
  SuppServicesPreferencesDelegateInterface::~SuppServicesPreferencesDelegateInterface(v2);
  uint64_t v17 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SuppServicesInterface::~SuppServicesInterface((SuppServicesInterface *)a1);
}

void sub_100FF1A28(uint64_t a1)
{
}

void sub_100FF1A30(uint64_t a1)
{
}

void sub_100FF1A38(uint64_t a1)
{
  sub_100FF1788(a1);

  operator delete();
}

void sub_100FF1A70(uint64_t a1)
{
  sub_100FF1788(a1 - 56);

  operator delete();
}

void sub_100FF1AAC(uint64_t a1)
{
  sub_100FF1788(a1 - 64);

  operator delete();
}

void sub_100FF1AE8(uint64_t a1, _DWORD *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 96));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)size_t v23 = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v23);
  if (!v10)
  {
    uint64_t v12 = 0;
    goto LABEL_8;
  }
  uint64_t v12 = v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
LABEL_8:
    std::mutex::unlock(v5);
    unsigned int v11 = 0;
    char v13 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
LABEL_9:
  if (!*a2 || !v12) {
    goto LABEL_26;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 48))(v12))
  {
    sub_100FF3B10((void **)a1, *a2);
    goto LABEL_26;
  }
  uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)size_t v23 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Call waiting not supported. Clear Call Waiting Value", v23, 2u);
  }
  uint64_t v15 = *a2;
  for (uint64_t i = *(uint64_t **)(a1 + 240); i; uint64_t i = (uint64_t *)*i)
  {
    int v17 = *((_DWORD *)i + 8);
    if (v17 <= (int)v15)
    {
      if (v17 >= (int)v15)
      {
        uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v15);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)size_t v23 = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Clearing Call Waiting status", v23, 2u);
        }
        int v22 = sub_1000389F8(*(uint64_t **)(a1 + 240), v15) + 8;
        sub_10005D144((void *)*v22);
        *(v22 - 1) = (uint64_t)v22;
        *int v22 = 0;
        v22[1] = 0;
        sub_100FF3D90(a1, v15);
        goto LABEL_26;
      }
      ++i;
    }
  }
  unsigned int v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v15);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    uint64_t v19 = subscriber::asString();
    *(_DWORD *)size_t v23 = 136315138;
    *(void *)&v23[4] = v19;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", v23, 0xCu);
  }
LABEL_26:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100FF1DE8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF1E14(uint64_t a1, uint64_t a2)
{
  void (***v12)(uint8_t *__return_ptr, void, uint64_t);
  NSObject *v13;
  void **v14;
  void **v15;
  int v16;
  NSObject *v17;
  const char *v18;
  void **v19;
  void **v20;
  BOOL v21;
  NSObject *v22;
  uint8_t buf[8];
  std::__shared_weak_count *v24;
  uint8_t v25[4];
  const char *v26;

  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 96));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }
  uint64_t v12 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12)
    {
      int v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
      }
      goto LABEL_34;
    }
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_12;
  }
  std::mutex::unlock(v5);
  if (!v12)
  {
LABEL_9:
    char v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
    }
    return;
  }
LABEL_12:
  uint64_t v14 = *(void ***)(a1 + 480);
  if (v14 != (void **)(a1 + 488))
  {
    do
    {
      uint64_t v15 = sub_100046F68(a2, v14 + 4);
      uint64_t v16 = *((unsigned __int8 *)v14 + 56);
      if ((void **)(a2 + 8) == v15 || v16 != *((unsigned __int8 *)v15 + 56))
      {
        *(void *)buf = 0;
        uint64_t v24 = 0;
        (**v12)(buf, v12, (uint64_t)(v14 + 4));
        if (*(void *)buf && !*(unsigned char *)(*(void *)buf + 49))
        {
          int v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)buf + 52));
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v18 = "enabled";
            if (!v16) {
              unsigned int v18 = "disabled";
            }
            *(_DWORD *)size_t v25 = 136315138;
            uint64_t v26 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I VoLTE provisioning status: %s", v25, 0xCu);
          }
          sub_100FF450C(a1, *(unsigned int *)(*(void *)buf + 52));
        }
        if (v24) {
          sub_10004D2C8(v24);
        }
      }
      uint64_t v19 = (void **)v14[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          uint64_t v19 = (void **)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void **)v14[2];
          uint64_t v21 = *v20 == v14;
          uint64_t v14 = v20;
        }
        while (!v21);
      }
      uint64_t v14 = v20;
    }
    while (v20 != (void **)(a1 + 488));
  }
  if (v11)
  {
    sub_10004D2C8(v11);
LABEL_34:
    sub_10004D2C8(v11);
  }
}

void sub_100FF2130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF2178(uint64_t a1, uint64_t a2)
{
  void (***v12)(uint64_t *__return_ptr, void, uint64_t);
  NSObject *v13;
  void *v14;
  void **v15;
  NSObject *v16;
  uint8_t *v17;
  void *v18;
  void *v19;
  BOOL v20;
  NSObject *v21;
  uint8_t buf[8];
  char v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint8_t v26[4];
  uint8_t *v27;

  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 96));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }
  uint64_t v12 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12)
    {
      uint64_t v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
      }
      goto LABEL_37;
    }
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_12;
  }
  std::mutex::unlock(v5);
  if (!v12)
  {
LABEL_9:
    char v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
    }
    return;
  }
LABEL_12:
  uint64_t v14 = *(void **)(a1 + 504);
  if (v14 != (void *)(a1 + 512))
  {
    do
    {
      uint64_t v15 = sub_100046F68(a2, (void **)v14 + 4);
      if ((void **)(a2 + 8) == v15
        || *((_DWORD *)v14 + 14) != *((_DWORD *)v15 + 14)
        || *((unsigned __int8 *)v14 + 60) != *((unsigned __int8 *)v15 + 60)
        || (sub_1005A0BB8((unsigned __int8 *)v14 + 64, (unsigned __int8 *)v15 + 64) & 1) == 0)
      {
        uint64_t v24 = 0;
        size_t v25 = 0;
        (**v12)(&v24, v12, (uint64_t)(v14 + 4));
        if (v24 && !*(unsigned char *)(v24 + 49))
        {
          uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(v24 + 52));
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            asString();
            int v17 = buf;
            if (v23 < 0) {
              int v17 = *(uint8_t **)buf;
            }
            *(_DWORD *)uint64_t v26 = 136315138;
            unsigned int v27 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I VoWiFi provisioning status: %s", v26, 0xCu);
            if (v23 < 0) {
              operator delete(*(void **)buf);
            }
          }
          sub_100FF450C(a1, *(unsigned int *)(v24 + 52));
        }
        if (v25) {
          sub_10004D2C8(v25);
        }
      }
      unsigned int v18 = (void *)v14[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          unsigned int v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v14[2];
          uint64_t v20 = *v19 == (void)v14;
          uint64_t v14 = v19;
        }
        while (!v20);
      }
      uint64_t v14 = v19;
    }
    while (v19 != (void *)(a1 + 512));
  }
  if (v11)
  {
    sub_10004D2C8(v11);
LABEL_37:
    sub_10004D2C8(v11);
  }
}

void sub_100FF24D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (v16)
  {
    sub_10004D2C8(v16);
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF2520(uint64_t a1, uint64_t a2)
{
  void (***v12)(uint8_t *__return_ptr, void, uint64_t);
  NSObject *v13;
  void **v14;
  void **v15;
  void **v16;
  void **v17;
  BOOL v18;
  uint64_t *v19;
  int v20;
  uint64_t *v21;
  int v22;
  int v23;
  int v24;
  uint64_t *v25;
  int v26;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  uint8_t buf[8];
  std::__shared_weak_count *v31;
  uint8_t v32[4];
  const char *v33;

  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 96));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }
  uint64_t v12 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v10[3];
  unsigned int v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
    std::mutex::unlock(v5);
    if (v12)
    {
LABEL_12:
      uint64_t v14 = *(void ***)(a1 + 528);
      if (v14 == (void **)(a1 + 536)) {
        goto LABEL_41;
      }
      while (1)
      {
        uint64_t v15 = sub_100046F68(a2, v14 + 4);
        if ((void **)(a2 + 8) != v15
          && *((_DWORD *)v14 + 14) == *((_DWORD *)v15 + 14)
          && *((_DWORD *)v14 + 15) == *((_DWORD *)v15 + 15)
          && *((unsigned __int8 *)v14 + 64) == *((unsigned __int8 *)v15 + 64))
        {
          goto LABEL_21;
        }
        *(void *)buf = 0;
        signed int v31 = 0;
        (**v12)(buf, v12, (uint64_t)(v14 + 4));
        if (!*(void *)buf) {
          goto LABEL_19;
        }
        if (*(unsigned char *)(*(void *)buf + 49)) {
          goto LABEL_19;
        }
        uint64_t v19 = *(uint64_t **)(a1 + 240);
        if (!v19) {
          goto LABEL_19;
        }
        uint64_t v20 = *(_DWORD *)(*(void *)buf + 52);
        uint64_t v21 = *(uint64_t **)(a1 + 240);
        while (1)
        {
          int v22 = *((_DWORD *)v21 + 8);
          if (v20 >= v22) {
            break;
          }
LABEL_33:
          uint64_t v21 = (uint64_t *)*v21;
          if (!v21) {
            goto LABEL_19;
          }
        }
        if (v22 < v20) {
          break;
        }
        size_t v23 = *((_DWORD *)v14 + 14);
        uint64_t v24 = *((_DWORD *)v14 + 15);
        size_t v25 = sub_1000389F8(v19, v20);
        uint64_t v26 = (v23 | v24) & 1;
        if (*((unsigned __int8 *)v25 + 164) != v26)
        {
          unsigned int v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)buf + 52));
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            std::string v28 = "disabled";
            if (v26) {
              std::string v28 = "enabled";
            }
            *(_DWORD *)uint64_t v32 = 136315138;
            long long v33 = v28;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Feature is %s", v32, 0xCu);
          }
          *((unsigned char *)v25 + 164) = v26;
          sub_100FF450C(a1, *(unsigned int *)(*(void *)buf + 52));
        }
LABEL_19:
        if (v31) {
          sub_10004D2C8(v31);
        }
LABEL_21:
        uint64_t v16 = (void **)v14[1];
        if (v16)
        {
          do
          {
            int v17 = v16;
            uint64_t v16 = (void **)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            int v17 = (void **)v14[2];
            unsigned int v18 = *v17 == v14;
            uint64_t v14 = v17;
          }
          while (!v18);
        }
        uint64_t v14 = v17;
        if (v17 == (void **)(a1 + 536))
        {
LABEL_41:
          if (v11)
          {
            sub_10004D2C8(v11);
            goto LABEL_45;
          }
          return;
        }
      }
      ++v21;
      goto LABEL_33;
    }
LABEL_9:
    char v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
    }
    return;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  if (v12)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_12;
  }
  uint64_t v29 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
  }
LABEL_45:
  sub_10004D2C8(v11);
}

void sub_100FF28BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (v12)
  {
    sub_10004D2C8(v12);
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF2904(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  void (***v13)(uint8_t *__return_ptr, void, uint64_t);
  NSObject *v14;
  void *v15;
  void **v16;
  _DWORD *v17;
  void *v18;
  void *v19;
  BOOL v20;
  uint64_t *v21;
  int v22;
  uint64_t *v23;
  int v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  int v28;
  NSObject *v29;
  NSObject *log;
  uint8_t v31[16];
  uint8_t buf[8];
  std::__shared_weak_count *v33;

  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 96));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    std::mutex::unlock(v6);
    goto LABEL_9;
  }
  char v13 = (void (***)(uint8_t *__return_ptr, void, uint64_t))v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
    std::mutex::unlock(v6);
    if (v13)
    {
LABEL_12:
      uint64_t v15 = *(void **)(a1 + 552);
      if (v15 == (void *)(a1 + 560)) {
        goto LABEL_42;
      }
      while (1)
      {
        uint64_t v16 = sub_100046F68(a2, (void **)v15 + 4);
        int v17 = v15 + 7;
        if ((void **)(a2 + 8) != v16 && sub_10047161C((uint64_t)(v15 + 7), (uint64_t)(v16 + 7))) {
          goto LABEL_19;
        }
        *(void *)buf = 0;
        long long v33 = 0;
        (**v13)(buf, v13, (uint64_t)(v15 + 4));
        if (!*(void *)buf) {
          goto LABEL_17;
        }
        if (*(unsigned char *)(*(void *)buf + 49)) {
          goto LABEL_17;
        }
        uint64_t v21 = *(uint64_t **)(a1 + 240);
        if (!v21) {
          goto LABEL_17;
        }
        int v22 = *(_DWORD *)(*(void *)buf + 52);
        size_t v23 = *(uint64_t **)(a1 + 240);
        while (1)
        {
          uint64_t v24 = *((_DWORD *)v23 + 8);
          if (v22 >= v24) {
            break;
          }
LABEL_31:
          size_t v23 = (uint64_t *)*v23;
          if (!v23) {
            goto LABEL_17;
          }
        }
        if (v24 < v22) {
          break;
        }
        size_t v25 = sub_1000389F8(v21, v22);
        uint64_t v26 = sub_1000389F8(*(uint64_t **)(a1 + 240), *(_DWORD *)(*(void *)buf + 52));
        unsigned int v27 = v26;
        if (*v17 == 1 && !*((unsigned char *)v25 + 162))
        {
          log = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)buf + 52));
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)signed int v31 = 0;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I We are IMS Registered for the 1st time after restart/SIM insert", v31, 2u);
          }
          *((unsigned char *)v25 + 162) = 1;
          std::string v28 = *v17 == 1;
          if (*((unsigned __int8 *)v27 + 163) == v28)
          {
LABEL_41:
            sub_100FF450C(a1, *(unsigned int *)(*(void *)buf + 52));
            goto LABEL_17;
          }
LABEL_40:
          *((unsigned char *)v27 + 163) = v28;
          goto LABEL_41;
        }
        std::string v28 = *v17 == 1;
        if (*((unsigned __int8 *)v26 + 163) != v28) {
          goto LABEL_40;
        }
LABEL_17:
        if (v33) {
          sub_10004D2C8(v33);
        }
LABEL_19:
        unsigned int v18 = (void *)v15[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            unsigned int v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v19 = (void *)v15[2];
            uint64_t v20 = *v19 == (void)v15;
            uint64_t v15 = v19;
          }
          while (!v20);
        }
        uint64_t v15 = v19;
        if (v19 == (void *)(a1 + 560))
        {
LABEL_42:
          if (v12)
          {
            sub_10004D2C8(v12);
            goto LABEL_46;
          }
          return;
        }
      }
      ++v23;
      goto LABEL_31;
    }
LABEL_9:
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
    }
    return;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  if (v13)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_12;
  }
  uint64_t v29 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "PersonalityShop is not ready", buf, 2u);
  }
LABEL_46:
  sub_10004D2C8(v12);
}

void sub_100FF2C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (v14)
  {
    sub_10004D2C8(v14);
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF2CB8(uint64_t result, uint64_t a2)
{
  char v2 = *(void **)(result + 576);
  unsigned int v3 = (void *)(result + 584);
  if (v2 != (void *)(result + 584))
  {
    unsigned int v4 = (void **)result;
    uint64_t v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 8);
      if (*v5)
      {
        uint64_t v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < (int)v7;
          if (v9 >= (int)v7) {
            unsigned int v11 = (uint64_t *)v6;
          }
          else {
            unsigned int v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            uint64_t v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 8))
        {
          uint64_t result = rest::operator==();
          if (result) {
            goto LABEL_53;
          }
          uint64_t v7 = *((unsigned int *)v2 + 8);
        }
      }
      uint64_t result = (uint64_t)v4[30];
      if (result)
      {
        uint64_t v12 = v4[30];
        do
        {
          int v13 = *((_DWORD *)v12 + 8);
          if (v13 <= (int)v7)
          {
            if (v13 >= (int)v7)
            {
              uint64_t result = (uint64_t)sub_1000389F8((uint64_t *)result, v7);
              if (*(void *)(result + 128)) {
                BOOL v14 = *((unsigned char *)v2 + 40) == 2;
              }
              else {
                BOOL v14 = 0;
              }
              if (v14)
              {
                uint64_t result = (uint64_t)sub_1000389F8(v4[30], v7);
                uint64_t v15 = *((unsigned __int8 *)v2 + 71);
                uint64_t v16 = (v15 & 0x80u) == 0 ? *((unsigned __int8 *)v2 + 71) : v2[7];
                if (v16)
                {
                  uint64_t v17 = *(void *)(result + 128);
                  unsigned int v18 = (unsigned __int8 **)(v17 + 8);
                  uint64_t v19 = *(unsigned __int8 *)(v17 + 31);
                  int v20 = (char)v19;
                  if ((v19 & 0x80u) != 0) {
                    uint64_t v19 = *(void *)(v17 + 16);
                  }
                  if (v16 != v19) {
                    goto LABEL_45;
                  }
                  if (v20 >= 0) {
                    uint64_t v21 = (unsigned __int8 *)(v17 + 8);
                  }
                  else {
                    uint64_t v21 = *v18;
                  }
                  if ((v15 & 0x80) != 0)
                  {
                    uint64_t result = memcmp((const void *)v2[6], v21, v2[7]);
                    if (result) {
                      goto LABEL_45;
                    }
                  }
                  else if (*((unsigned char *)v2 + 71))
                  {
                    int v22 = (unsigned __int8 *)(v2 + 6);
                    while (*v22 == *v21)
                    {
                      ++v22;
                      ++v21;
                      if (!--v15) {
                        goto LABEL_53;
                      }
                    }
LABEL_45:
                    size_t v23 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v4[6] + 16))(v4[6], v7);
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                    {
                      if (*((char *)v2 + 71) >= 0) {
                        uint64_t v24 = v2 + 6;
                      }
                      else {
                        uint64_t v24 = (void *)v2[6];
                      }
                      if (*(char *)(v17 + 31) < 0) {
                        unsigned int v18 = (unsigned __int8 **)*v18;
                      }
                      *(_DWORD *)buf = 136315394;
                      std::string v28 = v24;
                      __int16 v29 = 2080;
                      long long v30 = v18;
                      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Operator bundle ID changing to %s, cached is %s. Resetting CLIR network setting", buf, 0x16u);
                    }
                    uint64_t result = (uint64_t)sub_100FF7360(v4, v7);
                  }
                }
              }
              break;
            }
            ++v12;
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
LABEL_53:
      size_t v25 = (void *)v2[1];
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          size_t v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (void *)v2[2];
          BOOL v14 = *v26 == (void)v2;
          char v2 = v26;
        }
        while (!v14);
      }
      char v2 = v26;
    }
    while (v26 != v3);
  }
  return result;
}

uint64_t sub_100FF2F64(uint64_t a1)
{
  char v2 = *(void **)(a1 + 232);
  unsigned int v3 = (void *)(a1 + 240);
  if (v2 != (void *)(a1 + 240))
  {
    do
    {
      unsigned int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 8));
      uint64_t v5 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v2 + 201)) {
          uint64_t v6 = "true";
        }
        else {
          uint64_t v6 = "false";
        }
        *(_DWORD *)buf = 136315138;
        unsigned int v27 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fValidGwSim: %s", buf, 0xCu);
        uint64_t v5 = *v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v2 + 200)) {
          uint64_t v7 = "true";
        }
        else {
          uint64_t v7 = "false";
        }
        *(_DWORD *)buf = 136315138;
        unsigned int v27 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fXcapAllowed: %s", buf, 0xCu);
        uint64_t v5 = *v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v2 + 204)) {
          uint64_t v8 = "true";
        }
        else {
          uint64_t v8 = "false";
        }
        *(_DWORD *)buf = 136315138;
        unsigned int v27 = v8;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fImsFeatureEnabled: %s", buf, 0xCu);
        uint64_t v5 = *v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v2 + 202)) {
          int v9 = "true";
        }
        else {
          int v9 = "false";
        }
        *(_DWORD *)buf = 136315138;
        unsigned int v27 = v9;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fImsRegisteredAtleastOnce: %s", buf, 0xCu);
        uint64_t v5 = *v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v2 + 205)) {
          BOOL v10 = "true";
        }
        else {
          BOOL v10 = "false";
        }
        *(_DWORD *)buf = 136315138;
        unsigned int v27 = v10;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fConnectionAvailabilityForUtService [Available:%s]", buf, 0xCu);
        uint64_t v5 = *v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v2 + 207)) {
          unsigned int v11 = "true";
        }
        else {
          unsigned int v11 = "false";
        }
        *(_DWORD *)buf = 136315138;
        unsigned int v27 = v11;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fConnectionAvailabilityForEmLocService [Available:%s]", buf, 0xCu);
      }
      uint64_t v12 = (uint64_t *)v2[13];
      if (v12)
      {
        int v13 = (int *)(v2 + 13);
        uint64_t v14 = v2[13];
        do
        {
          int v15 = *(_DWORD *)(v14 + 28);
          BOOL v16 = v15 < 1;
          if (v15 >= 1) {
            uint64_t v17 = (uint64_t *)v14;
          }
          else {
            uint64_t v17 = (uint64_t *)(v14 + 8);
          }
          if (!v16) {
            int v13 = (int *)v14;
          }
          uint64_t v14 = *v17;
        }
        while (*v17);
        if (v13 != (int *)(v2 + 13) && v13[7] <= 1)
        {
          unsigned int v18 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            while (1)
            {
              while (1)
              {
                int v19 = *((_DWORD *)v12 + 7);
                if (v19 < 2) {
                  break;
                }
                uint64_t v12 = (uint64_t *)*v12;
                if (!v12) {
                  goto LABEL_62;
                }
              }
              if (v19 == 1) {
                break;
              }
              uint64_t v12 = (uint64_t *)v12[1];
              if (!v12) {
LABEL_62:
              }
                sub_1000C14F0("map::at:  key not found");
            }
            if (*((unsigned char *)v12 + 32)) {
              int v20 = "true";
            }
            else {
              int v20 = "false";
            }
            *(_DWORD *)buf = 136315138;
            unsigned int v27 = v20;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I fCallWaiting[kCTCallClassVoice]: %s", buf, 0xCu);
          }
        }
      }
      uint64_t v21 = (void *)v2[1];
      if (v21)
      {
        do
        {
          int v22 = v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          int v22 = (void *)v2[2];
          BOOL v23 = *v22 == (void)v2;
          char v2 = v22;
        }
        while (!v23);
      }
      char v2 = v22;
    }
    while (v22 != v3);
  }
  uint64_t v24 = *(uint64_t (**)(void))(**(void **)(a1 + 384) + 48);

  return v24();
}

uint64_t sub_100FF3344(uint64_t result, uint64_t *a2)
{
  if (*((unsigned char *)a2 + 24))
  {
    uint64_t v3 = result;
    unsigned int v4 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = (uint64_t *)*a2;
      }
      int v6 = 136315138;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Device with ID '%s' is in proximity, will sync preferences", (uint8_t *)&v6, 0xCu);
    }
    return (*(uint64_t (**)(void))(**(void **)(v3 + 184) + 144))(*(void *)(v3 + 184));
  }
  return result;
}

void sub_100FF342C(void **a1)
{
  subscriber::makeSimSlotRange();
  uint64_t v3 = v12;
  char v2 = v13;
  if (v12 != v13)
  {
    unsigned int v4 = v14;
    while ((v14(*v3) & 1) == 0)
    {
      if (++v3 == v13)
      {
        uint64_t v3 = v13;
        break;
      }
    }
    uint64_t v5 = v13;
LABEL_7:
    while (v3 != v5)
    {
      uint64_t v6 = *v3;
      uint64_t v10 = 0;
      unsigned int v11 = 0;
      sub_100FF3570(a1, v6, &v10);
      if (v11) {
        sub_10004D2C8(v11);
      }
      uint64_t v8 = 0;
      int v9 = 0;
      sub_100FF3840(a1, v6, &v8);
      if (v9) {
        sub_10004D2C8(v9);
      }
      sub_100FF3B10(a1, v6);
      sub_100FF3D90((uint64_t)a1, v6);
      sub_100FF3FF4((uint64_t)a1, v6);
      uint64_t v7 = v3 + 1;
      uint64_t v3 = v2;
      if (v7 != v2)
      {
        uint64_t v3 = v7;
        while ((v4(*v3) & 1) == 0)
        {
          if (++v3 == v2)
          {
            uint64_t v3 = v2;
            goto LABEL_7;
          }
        }
      }
    }
  }
}

void sub_100FF3548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF3570(void **a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a1[30];
  if (!v5)
  {
LABEL_7:
    int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v19 = 136315138;
      *(void *)&v19[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", v19, 0xCu);
    }
    return;
  }
  uint64_t v7 = v5;
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)a2) {
      break;
    }
LABEL_6:
    uint64_t v7 = (uint64_t *)*v7;
    if (!v7) {
      goto LABEL_7;
    }
  }
  if (v8 < (int)a2)
  {
    ++v7;
    goto LABEL_6;
  }
  if (*a3) {
    goto LABEL_16;
  }
  (*(void (**)(unsigned char *__return_ptr))(*a1[23] + 40))(v19);
  long long v10 = *(_OWORD *)v19;
  *(_OWORD *)int v19 = 0uLL;
  unsigned int v11 = (std::__shared_weak_count *)a3[1];
  *(_OWORD *)a3 = v10;
  if (!v11)
  {
    if ((void)v10) {
      goto LABEL_15;
    }
    goto LABEL_22;
  }
  sub_10004D2C8(v11);
  if (*(void *)&v19[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v19[8]);
  }
  if (!*a3)
  {
LABEL_22:
    unsigned int v18 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N Could not restore CLIR user setting from persistent storage", v19, 2u);
    }
    return;
  }
LABEL_15:
  uint64_t v5 = a1[30];
LABEL_16:
  uint64_t v12 = sub_1000389F8(v5, a2);
  long long v13 = *(_OWORD *)a3;
  *a3 = 0;
  a3[1] = 0;
  uint64_t v14 = (std::__shared_weak_count *)v12[19];
  *((_OWORD *)v12 + 9) = v13;
  if (v14) {
    sub_10004D2C8(v14);
  }
  int v15 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000389F8(a1[30], a2);
    uint64_t v16 = asString();
    sub_1000389F8(a1[30], a2);
    uint64_t v17 = asString();
    *(_DWORD *)int v19 = 136315394;
    *(void *)&v19[4] = v16;
    *(_WORD *)&v19[12] = 2080;
    *(void *)&v19[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Restored the CLIR user setting from Persistent Storage with Service Status %s, Provisioned Status %s", v19, 0x16u);
  }
  sub_100FF70DC((uint64_t)a1, a2);
}

void sub_100FF3840(void **a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a1[30];
  if (!v5)
  {
LABEL_7:
    int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v19 = 136315138;
      *(void *)&v19[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", v19, 0xCu);
    }
    return;
  }
  uint64_t v7 = v5;
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)a2) {
      break;
    }
LABEL_6:
    uint64_t v7 = (uint64_t *)*v7;
    if (!v7) {
      goto LABEL_7;
    }
  }
  if (v8 < (int)a2)
  {
    ++v7;
    goto LABEL_6;
  }
  if (*a3) {
    goto LABEL_16;
  }
  (*(void (**)(unsigned char *__return_ptr))(*a1[23] + 64))(v19);
  long long v10 = *(_OWORD *)v19;
  *(_OWORD *)int v19 = 0uLL;
  unsigned int v11 = (std::__shared_weak_count *)a3[1];
  *(_OWORD *)a3 = v10;
  if (!v11)
  {
    if ((void)v10) {
      goto LABEL_15;
    }
    goto LABEL_22;
  }
  sub_10004D2C8(v11);
  if (*(void *)&v19[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v19[8]);
  }
  if (!*a3)
  {
LABEL_22:
    unsigned int v18 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N Could not restore CLIR network setting from persistent storage", v19, 2u);
    }
    return;
  }
LABEL_15:
  uint64_t v5 = a1[30];
LABEL_16:
  uint64_t v12 = sub_1000389F8(v5, a2);
  long long v13 = *(_OWORD *)a3;
  *a3 = 0;
  a3[1] = 0;
  uint64_t v14 = (std::__shared_weak_count *)v12[17];
  *((_OWORD *)v12 + 8) = v13;
  if (v14) {
    sub_10004D2C8(v14);
  }
  int v15 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000389F8(a1[30], a2);
    uint64_t v16 = asString();
    sub_1000389F8(a1[30], a2);
    uint64_t v17 = asString();
    *(_DWORD *)int v19 = 136315394;
    *(void *)&v19[4] = v16;
    *(_WORD *)&v19[12] = 2080;
    *(void *)&v19[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Restored the CLIR network setting from Persistent Storage with Service Status %s, Provisioned Status %s", v19, 0x16u);
  }
  sub_100FF70DC((uint64_t)a1, a2);
}

void sub_100FF3B10(void **a1, uint64_t a2)
{
  unsigned int v4 = a1[30];
  if (!v4)
  {
LABEL_7:
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v17 = 136315138;
      uint64_t v18 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v17, 0xCu);
    }
    return;
  }
  while (1)
  {
    int v5 = *((_DWORD *)v4 + 8);
    if (v5 <= (int)a2) {
      break;
    }
LABEL_6:
    unsigned int v4 = (void *)*v4;
    if (!v4) {
      goto LABEL_7;
    }
  }
  if (v5 < (int)a2)
  {
    ++v4;
    goto LABEL_6;
  }
  unsigned __int16 v7 = (*(uint64_t (**)(void *, uint64_t))(*a1[23] + 88))(a1[23], a2);
  if (v7 > 0xFFu)
  {
    char v12 = v7;
    long long v13 = sub_1000389F8(a1[30], a2) + 8;
    sub_10005D144((void *)*v13);
    *(v13 - 1) = (uint64_t)v13;
    uint64_t *v13 = 0;
    v13[1] = 0;
    uint64_t v14 = sub_1000389F8(a1[30], a2);
    int v17 = 1;
    *((unsigned char *)sub_1000BC5E4((uint64_t **)v14 + 7, 1, &v17) + 32) = v12;
    int v15 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = "ON";
      if (!v12) {
        uint64_t v16 = "OFF";
      }
      int v17 = 136315138;
      uint64_t v18 = (uint64_t)v16;
      int v9 = "#I Restored Call Waiting status %s from Persistent Storage";
      long long v10 = v15;
      uint32_t v11 = 12;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v17, v11);
    }
  }
  else
  {
    int v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      int v9 = "#I Could not restore Call Waiting status from Persistent Storage";
      long long v10 = v8;
      uint32_t v11 = 2;
      goto LABEL_17;
    }
  }
}

void sub_100FF3D90(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
  uint64_t v7 = v4[8];
  int v5 = v4 + 8;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  int v8 = v5;
  do
  {
    int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 < 1;
    if (v9 >= 1) {
      uint32_t v11 = (uint64_t *)v6;
    }
    else {
      uint32_t v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      int v8 = (uint64_t *)v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == v5 || *((int *)v8 + 7) >= 2) {
LABEL_11:
  }
    int v8 = v5;
  if (v8 == sub_1000389F8(*(uint64_t **)(a1 + 240), a2) + 8)
  {
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Call waiting status cleared", __p, 2u);
    }
    BOOL v13 = 1;
  }
  else
  {
    char v12 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
    *(_DWORD *)std::string __p = 1;
    BOOL v13 = *((unsigned char *)sub_1000BC5E4((uint64_t **)v12 + 7, 1, __p) + 32) != 0;
  }
  int v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = "OFF";
    if (v13) {
      uint64_t v16 = "ON";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Publishing Call Waiting status %s", __p, 0xCu);
  }
  uint64_t v17 = *(void *)(a1 + 200);
  PersonalityIdFromSlotId();
  (*(void (**)(uint64_t, unsigned char *, BOOL))(*(void *)v17 + 200))(v17, __p, v13);
  if (v19 < 0) {
    operator delete(*(void **)__p);
  }
}

void sub_100FF3FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF3FF4(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(uint64_t **)(a1 + 240);
  if (!v4)
  {
LABEL_7:
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v16 = 136315138;
      uint64_t v17 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v16, 0xCu);
    }
    return;
  }
  while (1)
  {
    int v5 = *((_DWORD *)v4 + 8);
    if (v5 <= (int)a2) {
      break;
    }
LABEL_6:
    unsigned int v4 = (uint64_t *)*v4;
    if (!v4) {
      goto LABEL_7;
    }
  }
  if (v5 < (int)a2)
  {
    ++v4;
    goto LABEL_6;
  }
  unsigned __int16 v7 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 184) + 112))(*(void *)(a1 + 184), a2);
  char v8 = v7;
  unsigned int v9 = v7;
  BOOL v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v9 > 0xFF)
  {
    if (v11)
    {
      int v15 = "ON";
      if (!v8) {
        int v15 = "OFF";
      }
      int v16 = 136315138;
      uint64_t v17 = (uint64_t)v15;
      char v12 = "#I Restored Auto Answer status to %s from Persistent Storage";
      BOOL v13 = v10;
      uint32_t v14 = 12;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, v14);
    }
  }
  else if (v11)
  {
    LOWORD(v16) = 0;
    char v12 = "#N Could not restore Auto Answer status from Persistent Storage";
    BOOL v13 = v10;
    uint32_t v14 = 2;
    goto LABEL_17;
  }
}

void sub_100FF41F0(uint64_t a1, _DWORD *a2)
{
  if (*a2 != *(_DWORD *)(a1 + 624))
  {
    subscriber::makeSimSlotRange();
    unsigned int v4 = *(unsigned int **)buf;
    if (*(unsigned int **)buf != v17)
    {
      while ((v18(*v4) & 1) == 0)
      {
        if (++v4 == v17)
        {
          unsigned int v4 = v17;
          break;
        }
      }
LABEL_6:
      while (v4 != v17)
      {
        int v5 = v4 + 1;
        sub_100FF450C(a1, *v4);
        unsigned int v4 = v17;
        if (v5 != v17)
        {
          unsigned int v4 = v5;
          while ((v18(*v4) & 1) == 0)
          {
            if (++v4 == v17)
            {
              unsigned int v4 = v17;
              goto LABEL_6;
            }
          }
        }
      }
    }
    if (*(_DWORD *)(a1 + 624) == 1)
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I In widget mode", buf, 2u);
      }
      unsigned __int16 v7 = dispatch_group_create();
      char v8 = v7;
      uint64_t v9 = *(void *)(a1 + 184);
      if (v9)
      {
        dispatch_group_t group = v7;
        if (v7)
        {
          dispatch_retain(v7);
          dispatch_group_enter(v8);
        }
        (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v9 + 32))(v9, &group);
        if (group)
        {
          dispatch_group_leave(group);
          if (group) {
            dispatch_release(group);
          }
        }
      }
      operator new();
    }
    if (*a2 == 1)
    {
      BOOL v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Not in widget mode", buf, 2u);
      }
      BOOL v11 = dispatch_group_create();
      char v12 = v11;
      uint64_t v13 = *(void *)(a1 + 184);
      if (v13)
      {
        dispatch_group_t object = v11;
        if (v11)
        {
          dispatch_retain(v11);
          dispatch_group_enter(v12);
        }
        (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v13 + 32))(v13, &object);
        if (object)
        {
          dispatch_group_leave(object);
          if (object) {
            dispatch_release(object);
          }
        }
      }
      operator new();
    }
  }
}

void sub_100FF44B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group, dispatch_group_t a10)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  if (v10) {
    dispatch_release(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF450C(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(uint64_t **)(a1 + 240);
  if (!v4)
  {
LABEL_8:
    unsigned __int16 v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
    return;
  }
  int v5 = v4;
  while (1)
  {
    int v6 = *((_DWORD *)v5 + 8);
    if (v6 <= (int)a2) {
      break;
    }
LABEL_7:
    int v5 = (uint64_t *)*v5;
    if (!v5) {
      goto LABEL_8;
    }
  }
  if (v6 < (int)a2)
  {
    ++v5;
    goto LABEL_7;
  }
  char v8 = sub_1000389F8(v4, a2);
  __int16 v111 = 0;
  __int16 v112 = 0;
  uint64_t v107 = 0;
  sub_100FF6114(buf, (Registry **)(a1 + 96), (NSObject **)(a1 + 40), a2, (uint64_t)"supported", &v111);
  sub_1000057AC(&v112, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000577C4(&v111);
  uint64_t v9 = sub_100062778((const void **)&v107);
  BOOL v11 = v112;
  if (v112)
  {
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, v112, v10);
    int v95 = buf[0] != 0;
  }
  else
  {
    int v95 = capabilities::ct::supportsXcapForUncertifiedCarriers((capabilities::ct *)v9);
  }
  uint64_t v110 = 0;
  CFBooleanRef v109 = kCFBooleanFalse;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100FF6114(buf, (Registry **)(a1 + 96), (NSObject **)(a1 + 40), a2, (uint64_t)"provisioningDependency", &v109);
  sub_1000057AC(&v110, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000577C4((const void **)&v109);
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v110, v12);
  int v94 = buf[0];
  uint64_t v107 = 0;
  int64x2_t v108 = 0;
  long long v96 = (Registry **)(a1 + 96);
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)buf[0], *(Registry **)(a1 + 96));
  uint32_t v14 = ServiceMap;
  if (v15 < 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v15;
  char v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
  long long v89 = v11;
  if (v19)
  {
    uint64_t v20 = v19[3];
    uint64_t v21 = (std::__shared_weak_count *)v19[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v14);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v22 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v14);
  uint64_t v21 = 0;
  char v22 = 1;
LABEL_23:
  (*(void (**)(void ***__return_ptr, uint64_t, uint64_t))(*(void *)v20 + 8))(&v107, v20, a2);
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (!v107) {
    goto LABEL_38;
  }
  BOOL v23 = sub_100046F68(a1 + 600, v107 + 3);
  if ((void **)(a1 + 608) == v23) {
    goto LABEL_38;
  }
  uint64_t v26 = (char *)v23[9];
  uint64_t v24 = v23 + 9;
  size_t v25 = v26;
  if (!v26) {
    goto LABEL_38;
  }
  unsigned int v27 = v24;
  do
  {
    int v28 = *((_DWORD *)v25 + 7);
    BOOL v29 = v28 < 7;
    if (v28 >= 7) {
      long long v30 = (void **)v25;
    }
    else {
      long long v30 = (void **)(v25 + 8);
    }
    if (!v29) {
      unsigned int v27 = (void **)v25;
    }
    size_t v25 = (char *)*v30;
  }
  while (*v30);
  if (v27 == v24 || *((int *)v27 + 7) > 7) {
LABEL_38:
  }
    BOOL v31 = 0;
  else {
    BOOL v31 = *((_DWORD *)v27 + 8) == 2;
  }
  PersonalityIdFromSlotId();
  uint64_t v32 = sub_100046F68(a1 + 480, &__p);
  if ((void **)(a1 + 488) == v32) {
    int v33 = 0;
  }
  else {
    int v33 = *((unsigned __int8 *)v32 + 56);
  }
  if (v106 < 0) {
    operator delete(__p);
  }
  if (v33) {
    int v34 = 1;
  }
  else {
    int v34 = v31;
  }
  int v93 = v34;
  CFBooleanRef v103 = kCFBooleanFalse;
  long long v104 = 0;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100FF6114(buf, v96, (NSObject **)(a1 + 40), a2, (uint64_t)"imsFeatureDependency", &v103);
  sub_1000057AC(&v104, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000577C4((const void **)&v103);
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v104, v35);
  int v92 = buf[0];
  CFBooleanRef v101 = kCFBooleanFalse;
  long long v102 = 0;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100FF6114(buf, v96, (NSObject **)(a1 + 40), a2, (uint64_t)"imsRegistrationDependency", &v101);
  sub_1000057AC(&v102, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000577C4((const void **)&v101);
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v102, v36);
  int v91 = buf[0];
  CFBooleanRef v99 = kCFBooleanFalse;
  uint64_t v100 = 0;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100FF6114(buf, v96, (NSObject **)(a1 + 40), a2, (uint64_t)"AllowedOnlyWhenIMSRegistered", &v99);
  sub_1000057AC(&v100, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000577C4((const void **)&v99);
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v100, v37);
  int v90 = buf[0];
  CFBooleanRef v97 = kCFBooleanFalse;
  long long v98 = 0;
  if (kCFBooleanFalse) {
    CFRetain(kCFBooleanFalse);
  }
  sub_100FF6114(buf, v96, (NSObject **)(a1 + 40), a2, (uint64_t)"SupportNASFallback", &v97);
  sub_1000057AC(&v98, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  sub_1000577C4((const void **)&v97);
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v98, v38);
  int v39 = buf[0];
  long long v41 = (std::mutex *)Registry::getServiceMap(v40, *v96);
  dispatch_object_t v42 = v41;
  if (v43 < 0)
  {
    uint64_t v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v45 = 5381;
    do
    {
      uint64_t v43 = v45;
      unsigned int v46 = *v44++;
      uint64_t v45 = (33 * v45) ^ v46;
    }
    while (v46);
  }
  std::mutex::lock(v41);
  *(void *)buf = v43;
  dispatch_object_t v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)buf);
  if (v47)
  {
    dispatch_object_t v48 = (GestaltUtilityInterface *)v47[3];
    dispatch_object_t v49 = (std::__shared_weak_count *)v47[4];
    if (v49)
    {
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v42);
      atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v49);
      char v50 = 0;
      goto LABEL_63;
    }
  }
  else
  {
    dispatch_object_t v48 = 0;
  }
  std::mutex::unlock(v42);
  dispatch_object_t v49 = 0;
  char v50 = 1;
LABEL_63:
  int isWatch = GestaltUtilityInterface::isWatch(v48);
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v49);
  }
  if (isWatch)
  {
    int v52 = *(_DWORD *)(a1 + 624);
    int isWatch = v52 != 1;
    BOOL v53 = v52 == 1;
  }
  else
  {
    BOOL v53 = 0;
  }
  uint64_t v55 = *(void *)(a1 + 136);
  unint64_t v54 = *(std::__shared_weak_count **)(a1 + 144);
  if (v54) {
    atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (isWatch) {
    goto LABEL_74;
  }
  char v56 = !v53;
  if (v39) {
    char v56 = 1;
  }
  if (v56)
  {
    int64x2_t v57 = v54;
  }
  else
  {
LABEL_74:
    uint64_t v55 = *(void *)(a1 + 168);
    int64x2_t v57 = *(std::__shared_weak_count **)(a1 + 176);
    if (v57) {
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v54) {
      sub_10004D2C8(v54);
    }
  }
  if (!capabilities::ct::supportsXcapForUncertifiedCarriers((capabilities::ct *)v54)) {
    goto LABEL_94;
  }
  uint64_t v58 = *(void *)(a1 + 696);
  if (!v58) {
    goto LABEL_94;
  }
  uint64_t v59 = a1 + 696;
  do
  {
    int v60 = *(_DWORD *)(v58 + 28);
    BOOL v61 = v60 < (int)a2;
    if (v60 >= (int)a2) {
      uint64_t v62 = (uint64_t *)v58;
    }
    else {
      uint64_t v62 = (uint64_t *)(v58 + 8);
    }
    if (!v61) {
      uint64_t v59 = v58;
    }
    uint64_t v58 = *v62;
  }
  while (*v62);
  if (v59 != a1 + 696
    && *(_DWORD *)(v59 + 28) <= (int)a2
    && ((int v63 = *(unsigned __int8 *)(v59 + 33), v64 = *(unsigned __int8 *)(v59 + 32), v63) ? (v65 = v64 == 0) : (v65 = 0),
        v65))
  {
    uint64_t v55 = *(void *)(a1 + 168);
    long long v88 = *(std::__shared_weak_count **)(a1 + 176);
    if (v88) {
      atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v66 = v39;
    if (v57) {
      sub_10004D2C8(v57);
    }
    int v67 = 0;
    int64x2_t v57 = v88;
  }
  else
  {
LABEL_94:
    int v66 = v39;
    int v67 = 1;
  }
  uint64_t v68 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
  {
    int v69 = *((unsigned __int8 *)v8 + 161);
    unint64_t v70 = "from CB";
    int v71 = *((unsigned __int8 *)v8 + 160);
    int v72 = *((unsigned __int8 *)v8 + 165);
    if (!v89) {
      unint64_t v70 = "from SW";
    }
    int v73 = *((unsigned __int8 *)v8 + 167);
    int v74 = *((unsigned __int8 *)v8 + 164);
    int v75 = *((unsigned __int8 *)v8 + 162);
    int v76 = *((unsigned __int8 *)v8 + 163);
    *(_DWORD *)buf = 67113218;
    *(_DWORD *)&uint8_t buf[4] = v95;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = v70;
    __int16 v114 = 1024;
    int v115 = v69;
    __int16 v116 = 1024;
    int v117 = v71;
    __int16 v118 = 1024;
    int v119 = v72;
    __int16 v120 = 1024;
    int v121 = v73;
    __int16 v122 = 1024;
    int v123 = v94;
    __int16 v124 = 1024;
    int v125 = v93;
    __int16 v126 = 1024;
    int v127 = v92;
    __int16 v128 = 1024;
    int v129 = v74;
    __int16 v130 = 1024;
    int v131 = v91;
    __int16 v132 = 1024;
    int v133 = v75;
    __int16 v134 = 1024;
    int v135 = v90;
    __int16 v136 = 1024;
    int v137 = v76;
    __int16 v138 = 1024;
    BOOL v139 = v53;
    __int16 v140 = 1024;
    int v141 = v66;
    __int16 v142 = 1024;
    int v143 = v67;
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I SSP/AP - Support[%d](%s) SIM[%d] Allowed[%d] UtConnection[%d] EmLocConnection[%d] ProvisioningDependency[%d] Provisioned[%d] FeatureDependency[%d] FeatureEnabled[%d] RegistrationDependency(AtLeastOnce)[%d] RegisteredAtLeastOnce[%d] AllowedOnlyWhenIMSRegistered[%d] IMSRegistered[%d] Tinker[%d] SupportsNASFallbackInTinker[%d] CsVoiceAvailable[%d]", buf, 0x6Cu);
  }
  if (((isWatch | v95 ^ 1) & 1) == 0
    && *((unsigned char *)v8 + 161)
    && *((unsigned char *)v8 + 160)
    && *((unsigned __int8 *)v8 + 165) | *((unsigned __int8 *)v8 + 167))
  {
    int v77 = v93;
    if (!v94) {
      int v77 = 1;
    }
    if (v92) {
      BOOL v78 = *((unsigned char *)v8 + 164) == 0;
    }
    else {
      BOOL v78 = 0;
    }
    int v79 = !v78;
    if (v91) {
      BOOL v80 = *((unsigned char *)v8 + 162) == 0;
    }
    else {
      BOOL v80 = 0;
    }
    int v81 = !v80;
    if (*((unsigned char *)v8 + 163)) {
      BOOL v82 = 1;
    }
    else {
      BOOL v82 = v90 == 0;
    }
    if (v82 && v81 && v79 && v77)
    {
      uint64_t v55 = *(void *)(a1 + 152);
      long long v83 = *(std::__shared_weak_count **)(a1 + 160);
      if (v83) {
        atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v57) {
        sub_10004D2C8(v57);
      }
      int64x2_t v57 = v83;
    }
  }
  if (v55 != v8[1])
  {
    if (v57) {
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CFTypeRef v84 = (std::__shared_weak_count *)v8[2];
    v8[1] = v55;
    v8[2] = (uint64_t)v57;
    if (v84) {
      sub_10004D2C8(v84);
    }
    uint64_t v85 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v86 = (*(uint64_t (**)(uint64_t))(*(void *)v8[1] + 48))(v8[1]);
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v86;
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I Active transport set to %s", buf, 0xCu);
    }
    uint64_t v87 = *(void *)(a1 + 200);
    PersonalityIdFromSlotId();
    (*(void (**)(uint64_t, unsigned char *, BOOL))(*(void *)v87 + 224))(v87, buf, v55 == *(void *)(a1 + 152));
    if (SHIBYTE(v115) < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (v57) {
    sub_10004D2C8(v57);
  }
  sub_100062778((const void **)&v98);
  sub_100062778((const void **)&v100);
  sub_100062778((const void **)&v102);
  sub_100062778((const void **)&v104);
  if (v108) {
    sub_10004D2C8(v108);
  }
  sub_100062778((const void **)&v110);
  sub_100062778((const void **)&v112);
}

void sub_100FF4F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, uint64_t a16, const void *a17, uint64_t a18, const void *a19, uint64_t a20,const void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,const void *a28,uint64_t a29,const void *a30)
{
  if (v30) {
    sub_10004D2C8(v30);
  }
  sub_100062778(&a15);
  sub_100062778(&a17);
  sub_100062778(&a19);
  sub_100062778(&a21);
  if (a26) {
    sub_10004D2C8((std::__shared_weak_count *)a26);
  }
  sub_100062778(&a28);
  sub_100062778(&a30);
  _Unwind_Resume(a1);
}

void sub_100FF5164(uint64_t a1, uint64_t a2)
{
  char v2 = *(void **)(a1 + 632);
  uint64_t v3 = (void *)(a1 + 640);
  if (v2 == (void *)(a1 + 640)) {
    return;
  }
  int v5 = (void *)(a2 + 8);
  do
  {
    uint64_t v6 = *v5;
    uint64_t v7 = *((unsigned int *)v2 + 8);
    if (*v5)
    {
      char v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          BOOL v11 = (uint64_t *)v6;
        }
        else {
          BOOL v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          char v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 8))
      {
        if (rest::operator==()) {
          goto LABEL_22;
        }
        uint64_t v7 = *((unsigned int *)v2 + 8);
      }
    }
    CFBooleanRef v12 = *(uint64_t **)(a1 + 240);
    if (!v12)
    {
LABEL_20:
      uint32_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = subscriber::asString();
        *(_DWORD *)buf = 136315138;
        uint64_t v21 = v19;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
      }
      goto LABEL_22;
    }
    while (1)
    {
      int v13 = *((_DWORD *)v12 + 8);
      if ((int)v7 >= v13) {
        break;
      }
LABEL_19:
      CFBooleanRef v12 = (uint64_t *)*v12;
      if (!v12) {
        goto LABEL_20;
      }
    }
    if (v13 < (int)v7)
    {
      ++v12;
      goto LABEL_19;
    }
    unsigned int v18 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Phone Number status has changed", buf, 2u);
    }
    if (*((unsigned char *)sub_1000389F8(*(uint64_t **)(a1 + 240), *((_DWORD *)v2 + 8)) + 162))
    {
      *((unsigned char *)sub_1000389F8(*(uint64_t **)(a1 + 240), *((_DWORD *)v2 + 8)) + 162) = 0;
      sub_100FF450C(a1, *((unsigned int *)v2 + 8));
    }
LABEL_22:
    uint64_t v15 = (void *)v2[1];
    if (v15)
    {
      do
      {
        int v16 = v15;
        uint64_t v15 = (void *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        int v16 = (void *)v2[2];
        BOOL v17 = *v16 == (void)v2;
        char v2 = v16;
      }
      while (!v17);
    }
    char v2 = v16;
  }
  while (v16 != v3);
}

void sub_100FF53C8(uint64_t a1, uint64_t a2)
{
  char v2 = *(void **)(a1 + 688);
  uint64_t v3 = (void *)(a1 + 696);
  if (v2 != (void *)(a1 + 696))
  {
    int v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      uint64_t v7 = *((unsigned int *)v2 + 7);
      if (!*v5) {
        goto LABEL_18;
      }
      char v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          BOOL v11 = (uint64_t *)v6;
        }
        else {
          BOOL v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          char v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5
        || (int)v7 < *((_DWORD *)v8 + 7)
        || (!*((unsigned char *)v2 + 33) || !*((unsigned char *)v8 + 33)
          ? (int v13 = *((unsigned __int8 *)v8 + 33) != 0, v12 = *((unsigned __int8 *)v2 + 33) != 0)
          : (v12 = *((unsigned __int8 *)v2 + 32), int v13 = *((unsigned __int8 *)v8 + 32)),
            v12 != v13))
      {
LABEL_18:
        uint32_t v14 = *(uint64_t **)(a1 + 240);
        if (!v14)
        {
LABEL_23:
          int v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            uint64_t v17 = subscriber::asString();
            *(_DWORD *)buf = 136315138;
            uint64_t v23 = v17;
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
          }
          goto LABEL_28;
        }
        while (1)
        {
          int v15 = *((_DWORD *)v14 + 8);
          if ((int)v7 >= v15)
          {
            if (v15 >= (int)v7)
            {
              unsigned int v18 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I CS Voice support status has changed", buf, 2u);
              }
              sub_100FF450C(a1, *((unsigned int *)v2 + 7));
              break;
            }
            ++v14;
          }
          uint32_t v14 = (uint64_t *)*v14;
          if (!v14) {
            goto LABEL_23;
          }
        }
      }
LABEL_28:
      uint64_t v19 = (void *)v2[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v2[2];
          BOOL v21 = *v20 == (void)v2;
          char v2 = v20;
        }
        while (!v21);
      }
      char v2 = v20;
    }
    while (v20 != v3);
  }
}

void sub_100FF561C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5710(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5808(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5900(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Radio disabled", v7, 2u);
  }
  uint64_t v3 = *(void **)(a1 + 232);
  if (v3 != (void *)(a1 + 240))
  {
    do
    {
      if (!*((unsigned char *)v3 + 200))
      {
        *((unsigned char *)v3 + 200) = 1;
        sub_100FF450C(a1, *((unsigned int *)v3 + 10));
      }
      unsigned int v4 = (void *)v3[1];
      if (v4)
      {
        do
        {
          int v5 = v4;
          unsigned int v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          int v5 = (void *)v3[2];
          BOOL v6 = *v5 == (void)v3;
          uint64_t v3 = v5;
        }
        while (!v6);
      }
      uint64_t v3 = v5;
    }
    while (v5 != (void *)(a1 + 240));
  }
}

void sub_100FF59D0(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5AD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5BE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100FF5BE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5CF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100FF5D00(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5DF0(uint64_t a1)
{
}

void sub_100FF5DFC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5EEC(uint64_t a1)
{
}

void sub_100FF5F00(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF5FF0(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_101004B48;
  v7[3] = &unk_101A7CD78;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  char v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_100FFDDF8;
    int v12 = &unk_101A7C228;
    int v13 = a3;
    uint32_t v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_100FFDD90;
    int v12 = &unk_101A7C208;
    int v13 = a3;
    uint32_t v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_100FF6114(void *a1, Registry **a2, NSObject **a3, uint64_t a4, uint64_t a5, void *a6)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a2);
  BOOL v11 = ServiceMap;
  if (v12 < 0)
  {
    int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string __p = v12;
  int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)__p);
  if (!v16)
  {
    uint64_t v18 = 0;
LABEL_9:
    std::mutex::unlock(v11);
    uint64_t v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_19;
    }
    goto LABEL_10;
  }
  uint64_t v18 = v16[3];
  uint64_t v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (!v18) {
    goto LABEL_19;
  }
LABEL_10:
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  PersonalityIdFromSlotId();
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *))(*(void *)v18 + 40))(&v22, v18, __p);
  if (v25 < 0) {
    operator delete(*(void **)__p);
  }
  if (!v22)
  {
    if (v23) {
      sub_10004D2C8(v23);
    }
LABEL_19:
    int v20 = 1;
    if (v19) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  (*(void (**)(uint64_t, const char *, uint64_t, void, void, uint64_t))(*(void *)v22 + 40))(v22, "XCAP", a5, *a6, 0, 1);
  if (v23) {
    sub_10004D2C8(v23);
  }
  int v20 = 0;
  if ((v19 & 1) == 0) {
LABEL_20:
  }
    sub_10004D2C8(v17);
LABEL_21:
  if (v20)
  {
    BOOL v21 = *a3;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = a5;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not get SystemDeterminationManagerInterface for %s XCAP value", __p, 0xCu);
    }
    *a1 = *a6;
    *a6 = 0;
  }
}

void sub_100FF636C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FF63C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100FF64B4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 240);
  if (v4)
  {
    uint64_t v5 = v4;
    do
    {
      int v6 = *((_DWORD *)v5 + 8);
      if (v6 <= (int)a2)
      {
        if (v6 >= (int)a2)
        {
          if (!sub_1000389F8(v4, a2)[1]) {
            return 0;
          }
          if (!sub_100FF6754(a1)
            || sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[1] == *(void *)(a1 + 152))
          {
            BOOL v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v12 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
              uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12[1] + 48))(v12[1]);
              int v15 = 136315138;
              uint64_t v16 = v13;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Issuing Get CLIR request to %s", (uint8_t *)&v15, 0xCu);
            }
            uint64_t v14 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
            return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14[1] + 120))(v14[1], a2);
          }
          else
          {
            int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
            uint64_t result = 0;
            if (v10)
            {
              LOWORD(v15) = 0;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring request to fetch CLIR value because it would trigger CSFB", (uint8_t *)&v15, 2u);
              return 0;
            }
          }
          return result;
        }
        ++v5;
      }
      uint64_t v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v15 = 136315138;
    uint64_t v16 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v15, 0xCu);
    return 0;
  }
  return result;
}

uint64_t sub_100FF6754(uint64_t a1)
{
  uint64_t v2 = a1 + 664;
  PersonalityIdFromSlotId();
  uint64_t v3 = sub_100046F68(v2, &__p);
  if ((void **)(a1 + 672) == v3)
  {
    uint64_t v5 = 0;
  }
  else
  {
    if (*((unsigned char *)v3 + 56)) {
      BOOL v4 = *((unsigned char *)v3 + 57) == 0;
    }
    else {
      BOOL v4 = 1;
    }
    uint64_t v5 = !v4;
  }
  if (v8 < 0) {
    operator delete(__p);
  }
  return v5;
}

void sub_100FF67D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FF67F0(uint64_t a1, unsigned int a2, int *a3, unsigned char *a4)
{
  unsigned int v11 = a2;
  v10[0] = a1;
  v10[1] = &v11;
  v10[2] = a3;
  v10[3] = a4;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FF6B60(a1, v11, a3, a4);
    }
    BOOL v8 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v8 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_101004EA0;
  v12[3] = &unk_101A7CE18;
  v12[4] = a1 + 8;
  v12[5] = v10;
  uint64_t v13 = v12;
  int v9 = *(NSObject **)(a1 + 24);
  char v19 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v8)
  {
    int v15 = sub_10005A778;
    uint64_t v16 = &unk_101A7CE38;
    char v17 = &v19;
    uint64_t v18 = &v13;
    dispatch_sync(v9, block);
  }
  else
  {
    int v15 = sub_10005B4DC;
    uint64_t v16 = &unk_101A7CE58;
    char v17 = &v19;
    uint64_t v18 = &v13;
    dispatch_async_and_wait(v9, block);
  }
  return v19 != 0;
}

uint64_t sub_100FF698C(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(uint64_t **)(a1 + 240);
  if (!v4)
  {
LABEL_7:
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136315138;
      uint64_t v13 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v12, 0xCu);
    }
    return 3;
  }
  uint64_t v5 = v4;
  while (1)
  {
    int v6 = *((_DWORD *)v5 + 8);
    if (v6 <= (int)a2) {
      break;
    }
LABEL_6:
    uint64_t v5 = (uint64_t *)*v5;
    if (!v5) {
      goto LABEL_7;
    }
  }
  if (v6 < (int)a2)
  {
    ++v5;
    goto LABEL_6;
  }
  if (!sub_1000389F8(v4, a2)[18]) {
    return 3;
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
    int v12 = 136315138;
    uint64_t v13 = asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I User CLIR setting is known: %s", (uint8_t *)&v12, 0xCu);
  }
  int v10 = *(unsigned __int8 *)(sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[18] + 1);
  if (v10 == 3) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = 3;
  }
  if (v10 == 2) {
    return 1;
  }
  else {
    return v11;
  }
}

uint64_t sub_100FF6B60(uint64_t a1, uint64_t a2, int *a3, unsigned char *a4)
{
  *a4 = 0;
  *a3 = 3;
  int v6 = *(uint64_t **)(a1 + 240);
  if (!v6)
  {
LABEL_7:
    unsigned int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v24 = 136315138;
      uint64_t v25 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v24, 0xCu);
    }
    return 0;
  }
  int v9 = v6;
  while (1)
  {
    int v10 = *((_DWORD *)v9 + 8);
    if (v10 <= (int)a2) {
      break;
    }
LABEL_6:
    int v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_7;
    }
  }
  if (v10 < (int)a2)
  {
    ++v9;
    goto LABEL_6;
  }
  if (!sub_1000389F8(v6, a2)[16])
  {
    char v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v12 = 0;
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      return v12;
    }
    LOWORD(v24) = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Network CLIR status is unknown, cannot determine value", (uint8_t *)&v24, 2u);
    return 0;
  }
  *a4 = 0;
  *a3 = 3;
  uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
    int v24 = 136315138;
    uint64_t v25 = asString();
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Network CLIR setting is known %s", (uint8_t *)&v24, 0xCu);
  }
  int v15 = *(unsigned __int8 *)(sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[16] + 1);
  int v16 = 1;
  switch(v15)
  {
    case 0:
      int v15 = 0;
      goto LABEL_16;
    case 1:
LABEL_16:
      *a4 = 2;
      uint64_t v12 = 1;
      int v16 = v15;
      goto LABEL_22;
    case 2:
      goto LABEL_21;
    case 3:
      int v16 = 0;
LABEL_21:
      uint64_t v12 = 1;
      *a4 = 1;
      int v18 = sub_100FF698C(a1, a2);
      if (v18 == 3) {
        goto LABEL_22;
      }
      int v21 = v18;
      uint64_t v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = asString();
        int v24 = 136315138;
        uint64_t v25 = v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Effective CLIR setting (user) is %s", (uint8_t *)&v24, 0xCu);
      }
      break;
    default:
      uint64_t v12 = 0;
      int v16 = 3;
LABEL_22:
      char v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = asString();
        int v24 = 136315138;
        uint64_t v25 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Effective CLIR setting (network) is %s", (uint8_t *)&v24, 0xCu);
      }
      int v21 = v16;
      break;
  }
  *a3 = v21;
  return v12;
}

void sub_100FF6F48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100FF704C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)a3 + 48))(a3);
  BOOL v4 = *(uint64_t (**)(void))(**(void **)(a1 + 384) + 40);

  return v4();
}

uint64_t sub_100FF70DC(uint64_t a1, uint64_t a2)
{
  int v21 = 0;
  LODWORD(v20) = 3;
  sub_100FF6B60(a1, a2, (int *)&v20, &v21);
  HIDWORD(v20) = sub_100FF698C(a1, a2);
  BOOL v4 = *(uint64_t **)(a1 + 456);
  if (!v4) {
    goto LABEL_14;
  }
  uint64_t v5 = *(uint64_t **)(a1 + 456);
  while (1)
  {
    int v6 = *((_DWORD *)v5 + 7);
    if (v6 <= (int)a2) {
      break;
    }
LABEL_6:
    uint64_t v5 = (uint64_t *)*v5;
    if (!v5) {
      goto LABEL_14;
    }
  }
  if (v6 < (int)a2)
  {
    ++v5;
    goto LABEL_6;
  }
  while (1)
  {
    while (1)
    {
      int v7 = *((_DWORD *)v4 + 7);
      if (v7 <= (int)a2) {
        break;
      }
      BOOL v4 = (uint64_t *)*v4;
      if (!v4) {
LABEL_29:
      }
        sub_1000C14F0("map::at:  key not found");
    }
    if (v7 >= (int)a2) {
      break;
    }
    BOOL v4 = (uint64_t *)v4[1];
    if (!v4) {
      goto LABEL_29;
    }
  }
  uint64_t result = rest::operator==();
  if ((result & 1) == 0)
  {
LABEL_14:
    int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asString();
      uint64_t v11 = asString();
      uint64_t v12 = asString();
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v11;
      __int16 v23 = 2080;
      uint64_t v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I CLIR info is changing to effective: %s, user: %s, modifiable: %s", buf, 0x20u);
    }
    uint64_t v13 = (uint64_t **)(a1 + 456);
    *(void *)buf = 1;
    *(void *)&uint8_t buf[8] = a1 + 416;
    uint64_t v14 = *(uint64_t **)(a1 + 456);
    int v15 = (uint64_t **)(a1 + 456);
    if (v14)
    {
      do
      {
        while (1)
        {
          int v15 = (uint64_t **)v14;
          int v16 = *((_DWORD *)v14 + 7);
          if (v16 <= (int)a2) {
            break;
          }
          uint64_t v14 = *v15;
          uint64_t v13 = v15;
          if (!*v15) {
            goto LABEL_24;
          }
        }
        if (v16 >= (int)a2)
        {
          char v19 = v15;
          goto LABEL_27;
        }
        uint64_t v14 = v15[1];
      }
      while (v14);
      uint64_t v13 = v15 + 1;
    }
LABEL_24:
    char v19 = operator new(0x30uLL);
    v19[7] = a2;
    v19[10] = 0;
    *((void *)v19 + 4) = 0x300000003;
    *(void *)char v19 = 0;
    *((void *)v19 + 1) = 0;
    *((void *)v19 + 2) = v15;
    void *v13 = (uint64_t *)v19;
    uint64_t v17 = **(void **)(a1 + 448);
    int v18 = (uint64_t *)v19;
    if (v17)
    {
      *(void *)(a1 + 448) = v17;
      int v18 = *v13;
    }
    sub_100046C90(*(uint64_t **)(a1 + 456), v18);
    ++*(void *)(a1 + 464);
LABEL_27:
    *((void *)v19 + 4) = v20;
    *((unsigned char *)v19 + 40) = v21;
    return sub_1010057F4((uint64_t)buf);
  }
  return result;
}

void sub_100FF7344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1010057F4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100FF7360(void **a1, uint64_t a2)
{
  uint64_t result = sub_1000389F8(a1[30], a2);
  if (result[16])
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000389F8(a1[30], a2);
      uint64_t v6 = asString();
      sub_1000389F8(a1[30], a2);
      *(_DWORD *)int v9 = 136315394;
      *(void *)&v9[4] = v6;
      *(_WORD *)&v9[12] = 2080;
      *(void *)&v9[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Clearing current CLIR network setting with Service Status %s, Provisioned Status %s", v9, 0x16u);
    }
    int v7 = sub_1000389F8(a1[30], a2);
    BOOL v8 = (std::__shared_weak_count *)v7[17];
    uint8_t v7[16] = 0;
    v7[17] = 0;
    if (v8) {
      sub_10004D2C8(v8);
    }
    (*(void (**)(void *, uint64_t))(*a1[23] + 80))(a1[23], a2);
    sub_100FF70DC((uint64_t)a1, a2);
    *(void *)int v9 = off_101A7CF08;
    *(void *)&v9[8] = a1;
    *(void *)&v9[16] = a2;
    uint64_t v10 = v9;
    sub_100FF704C((uint64_t)a1, a2, (uint64_t)v9);
    return sub_10003B34C(v9);
  }
  return result;
}

void sub_100FF751C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100FF7538(void **a1, uint64_t a2)
{
  BOOL v4 = sub_1000389F8(a1[30], a2);
  uint64_t v7 = v4[8];
  uint64_t v5 = v4 + 8;
  uint64_t v6 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  BOOL v8 = v5;
  do
  {
    int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 < 1;
    if (v9 >= 1) {
      uint64_t v11 = (uint64_t *)v6;
    }
    else {
      uint64_t v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      BOOL v8 = (uint64_t *)v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == v5 || *((int *)v8 + 7) >= 2) {
LABEL_11:
  }
    BOOL v8 = v5;
  if (v8 == sub_1000389F8(a1[30], a2) + 8)
  {
    int v16 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Could not persist Call Waiting status", (uint8_t *)&v17, 2u);
    }
  }
  else
  {
    uint64_t v12 = sub_1000389F8(a1[30], a2);
    int v17 = 1;
    int v13 = *((unsigned __int8 *)sub_1000BC5E4((uint64_t **)v12 + 7, 1, &v17) + 32);
    uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = "OFF";
      if (v13) {
        int v15 = "ON";
      }
      int v17 = 136315138;
      int v18 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Persisting Call Waiting status %s", (uint8_t *)&v17, 0xCu);
    }
    (*(void (**)(void *, uint64_t, BOOL))(*a1[23] + 96))(a1[23], a2, v13 != 0);
  }
}

uint64_t sub_100FF774C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  __int16 v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 88))(*(void *)(a1 + 184));
  if ((v4 & 0xFF00) != 0) {
    return v4 != 0;
  }
  else {
    return a3;
  }
}

uint64_t sub_100FF77A4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  __int16 v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 88))(*(void *)(a1 + 120));
  if ((v4 & 0xFF00) != 0) {
    return v4 != 0;
  }
  else {
    return a3;
  }
}

uint64_t sub_100FF77FC(uint64_t a1, int a2, int a3, int a4)
{
  int v10 = a3;
  int v11 = a2;
  int v9 = a4;
  v8[0] = a1;
  v8[1] = (uint64_t)&v11;
  v8[2] = (uint64_t)&v10;
  v8[3] = (uint64_t)&v9;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_10100596C(v8);
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_101005BB0;
  v12[3] = &unk_101A7CF78;
  v12[4] = a1 + 8;
  v12[5] = v8;
  int v13 = v12;
  uint64_t v7 = *(NSObject **)(a1 + 24);
  char v19 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    int v15 = sub_10005A778;
    int v16 = &unk_101A7CE38;
    int v17 = &v19;
    int v18 = &v13;
    dispatch_sync(v7, block);
  }
  else
  {
    int v15 = sub_10005B4DC;
    int v16 = &unk_101A7CE58;
    int v17 = &v19;
    int v18 = &v13;
    dispatch_async_and_wait(v7, block);
  }
  return v19 != 0;
}

void sub_100FF7988(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  int v12 = a4;
  int v13 = a5;
  int v14 = a6;
  int v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF7B18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v6 = *(uint64_t **)(a1 + 240);
  if (!v6)
  {
LABEL_7:
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v21 = 136315138;
      uint64_t v22 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v21, 0xCu);
    }
    return;
  }
  while (1)
  {
    int v9 = *((_DWORD *)v6 + 8);
    if (v9 <= (int)a2) {
      break;
    }
LABEL_6:
    BOOL v6 = (uint64_t *)*v6;
    if (!v6) {
      goto LABEL_7;
    }
  }
  if (v9 < (int)a2)
  {
    ++v6;
    goto LABEL_6;
  }
  int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13[1] + 48))(v13[1]);
    int v21 = 136315138;
    uint64_t v22 = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending fetch request to %s", (uint8_t *)&v21, 0xCu);
  }
  if (!sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[1]) {
    goto LABEL_20;
  }
  if (sub_100FF6754(a1) && sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[1] != *(void *)(a1 + 152))
  {
    int v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring request to fetch Call Barring value because it would trigger CSFB", (uint8_t *)&v21, 2u);
    }
    goto LABEL_20;
  }
  int v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17[1] + 48))(v17[1]);
    int v21 = 136315138;
    uint64_t v22 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Issuing Get Call Barring request to %s", (uint8_t *)&v21, 0xCu);
  }
  char v19 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v19[1] + 80))(v19[1], a2, a3, a4) & 1) == 0)
  {
LABEL_20:
    uint64_t v20 = operator new(0x20uLL);
    void *v20 = off_101A7CFA8;
    v20[1] = a1;
    *((_DWORD *)v20 + 4) = a2;
    *((_DWORD *)v20 + 5) = a4;
    *((_DWORD *)v20 + 6) = a3;
    __int16 v23 = v20;
    sub_100FF7EDC(a1, a2, (uint64_t)v20);
    sub_10003B34C(&v21);
  }
}

void sub_100FF7EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100FF7EDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)a3 + 48))(a3);
  __int16 v4 = *(uint64_t (**)(void))(**(void **)(a1 + 384) + 40);

  return v4();
}

uint64_t sub_100FF7F78(uint64_t a1, unsigned int a2, unsigned char *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v12 = a4;
  unsigned int v13 = a2;
  unsigned int v11 = a5;
  v10[0] = a1;
  v10[1] = &v13;
  v10[2] = a3;
  v10[3] = &v12;
  void v10[4] = &v11;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FF8118(a1, v13, a3, v12, v11);
    }
    BOOL v8 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v8 = 1;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_101005DA0;
  v14[3] = &unk_101A7D018;
  v14[4] = a1 + 8;
  v14[5] = v10;
  int v15 = v14;
  int v9 = *(NSObject **)(a1 + 24);
  char v21 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v8)
  {
    int v17 = sub_10005A778;
    uint64_t v18 = &unk_101A7CE38;
    char v19 = &v21;
    uint64_t v20 = &v15;
    dispatch_sync(v9, block);
  }
  else
  {
    int v17 = sub_10005B4DC;
    uint64_t v18 = &unk_101A7CE58;
    char v19 = &v21;
    uint64_t v20 = &v15;
    dispatch_async_and_wait(v9, block);
  }
  return v21 != 0;
}

uint64_t sub_100FF8118(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned int a4, unsigned int a5)
{
  for (uint64_t i = *(uint64_t **)(a1 + 240); i; uint64_t i = (uint64_t *)*i)
  {
    int v11 = *((_DWORD *)i + 8);
    if (v11 <= (int)a2)
    {
      if (v11 >= (int)a2)
      {
        uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = 67109376;
          LODWORD(v20[0]) = a4;
          WORD2(v20[0]) = 1024;
          *(_DWORD *)((char *)v20 + 6) = a5;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Retrieving from Call Barring model for type %d, class %d", (uint8_t *)&v19, 0xEu);
        }
        if (sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[5])
        {
          int v16 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
          return sub_100AB89AC(v16[5], a4, a5, a3);
        }
        int v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (v18)
        {
          LOWORD(v19) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Call barring model is not available", (uint8_t *)&v19, 2u);
          return 0;
        }
        return result;
      }
      ++i;
    }
  }
  unsigned int v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v19 = 136315138;
    v20[0] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v19, 0xCu);
    return 0;
  }
  return result;
}

void sub_100FF8360(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  int v13 = a5;
  int v14 = a6;
  int v15 = a7;
  int v11 = *(std::__shared_weak_count **)(a1 + 16);
  if (v11)
  {
    if (std::__shared_weak_count::lock(v11)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF84F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)unsigned int v12 = *(_OWORD *)a4;
    v12[2] = *(void **)(a4 + 16);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(v13, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)int v13 = *(_OWORD *)a5;
    v13[2] = *(void **)(a5 + 16);
  }
  if (*(char *)(a6 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a6, *(void *)(a6 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a6;
    __p[2] = *(void **)(a6 + 16);
  }
  int v15 = a7;
  int v11 = *(std::__shared_weak_count **)(a1 + 16);
  if (v11)
  {
    if (std::__shared_weak_count::lock(v11)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF8740(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (*(char *)(v22 + 63) < 0) {
    operator delete(*v23);
  }
  if (*(char *)(v22 + 39) < 0) {
    operator delete(*v24);
  }
  sub_10006A6AC(a1);
}

void sub_100FF87B4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100FF88A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 240);
  if (v5)
  {
    uint64_t v7 = v5;
    do
    {
      int v8 = *((_DWORD *)v7 + 8);
      if (v8 <= (int)a2)
      {
        if (v8 >= (int)a2)
        {
          if (!sub_1000389F8(v5, a2)[1]) {
            return 0;
          }
          if (!sub_100FF6754(a1)
            || sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[1] == *(void *)(a1 + 152))
          {
            int v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              int v14 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
              uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14[1] + 48))(v14[1]);
              int v17 = 136315138;
              uint64_t v18 = v15;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Issuing request to %s to fetch the Call Waiting values", (uint8_t *)&v17, 0xCu);
            }
            int v16 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
            return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16[1] + 104))(v16[1], a2, a3);
          }
          else
          {
            int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
            uint64_t result = 0;
            if (v12)
            {
              LOWORD(v17) = 0;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring request to fetch Call Waiting value because it would trigger CSFB", (uint8_t *)&v17, 2u);
              return 0;
            }
          }
          return result;
        }
        ++v7;
      }
      uint64_t v7 = (uint64_t *)*v7;
    }
    while (v7);
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v17 = 136315138;
    uint64_t v18 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v17, 0xCu);
    return 0;
  }
  return result;
}

void sub_100FF8B50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100FF8C5C(uint64_t a1, unsigned int a2, unsigned char *a3, int a4, int8x8_t a5)
{
  int v12 = a4;
  unsigned int v13 = a2;
  a5.i32[0] = a4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(a5);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.i32[0] != 1) {
    __TUAssertTrigger();
  }
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = a3;
  v11[3] = &v12;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FF8E10(a1, v13, a3, v12);
    }
    BOOL v9 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v9 = 1;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_101007344;
  v14[3] = &unk_101A7D238;
  v14[4] = a1 + 8;
  v14[5] = v11;
  uint64_t v15 = v14;
  int v10 = *(NSObject **)(a1 + 24);
  char v21 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v9)
  {
    int v17 = sub_10005A778;
    uint64_t v18 = &unk_101A7CE38;
    int v19 = &v21;
    uint64_t v20 = &v15;
    dispatch_sync(v10, block);
  }
  else
  {
    int v17 = sub_10005B4DC;
    uint64_t v18 = &unk_101A7CE58;
    int v19 = &v21;
    uint64_t v20 = &v15;
    dispatch_async_and_wait(v10, block);
  }
  return v21 != 0;
}

BOOL sub_100FF8E10(uint64_t a1, uint64_t a2, unsigned char *a3, int a4)
{
  BOOL v6 = *(uint64_t **)(a1 + 240);
  if (!v6)
  {
LABEL_8:
    int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v33 = 136315138;
    uint64_t v34 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v33, 0xCu);
    return 0;
  }
  BOOL v9 = v6;
  while (1)
  {
    int v10 = *((_DWORD *)v9 + 8);
    if (v10 <= (int)a2) {
      break;
    }
LABEL_7:
    BOOL v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_8;
    }
  }
  if (v10 < (int)a2)
  {
    ++v9;
    goto LABEL_7;
  }
  unsigned int v13 = sub_1000389F8(v6, a2);
  uint64_t v16 = v13[8];
  int v14 = v13 + 8;
  uint64_t v15 = v16;
  if (!v16) {
    goto LABEL_20;
  }
  int v17 = v14;
  do
  {
    int v18 = *(_DWORD *)(v15 + 28);
    BOOL v19 = v18 < a4;
    if (v18 >= a4) {
      uint64_t v20 = (uint64_t *)v15;
    }
    else {
      uint64_t v20 = (uint64_t *)(v15 + 8);
    }
    if (!v19) {
      int v17 = (uint64_t *)v15;
    }
    uint64_t v15 = *v20;
  }
  while (*v20);
  if (v17 == v14 || *((_DWORD *)v17 + 7) > a4) {
LABEL_20:
  }
    int v17 = v14;
  if (v17 == sub_1000389F8(*(uint64_t **)(a1 + 240), a2) + 8)
  {
    BOOL v31 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v32) {
      return result;
    }
    LOWORD(v33) = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Could not retrieve Call Waiting value", (uint8_t *)&v33, 2u);
    return 0;
  }
  char v21 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
  uint64_t v24 = v21[8];
  uint64_t v22 = v21 + 8;
  uint64_t v23 = v24;
  if (!v24) {
    goto LABEL_32;
  }
  uint64_t v25 = v22;
  do
  {
    int v26 = *(_DWORD *)(v23 + 28);
    BOOL v27 = v26 < a4;
    if (v26 >= a4) {
      int v28 = (uint64_t *)v23;
    }
    else {
      int v28 = (uint64_t *)(v23 + 8);
    }
    if (!v27) {
      uint64_t v25 = (uint64_t *)v23;
    }
    uint64_t v23 = *v28;
  }
  while (*v28);
  if (v25 == v22 || *((_DWORD *)v25 + 7) > a4) {
LABEL_32:
  }
    uint64_t v25 = v22;
  *a3 = *((unsigned char *)v25 + 32);
  BOOL v29 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    int v30 = *a3;
    int v33 = 67109120;
    LODWORD(v34) = v30;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Call Waiting value %d", (uint8_t *)&v33, 8u);
  }
  return 1;
}

void sub_100FF90D4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FF91D8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100FF92DC(uint64_t a1, unsigned int a2, int *a3, int a4)
{
  int v10 = a4;
  unsigned int v11 = a2;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = a3;
  v9[3] = &v10;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FF946C(a1, v11, a3, v10);
    }
    BOOL v7 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_101007D84;
  v12[3] = &unk_101A7D358;
  v12[4] = a1 + 8;
  v12[5] = v9;
  unsigned int v13 = v12;
  int v8 = *(NSObject **)(a1 + 24);
  char v19 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v7)
  {
    uint64_t v15 = sub_10005A778;
    uint64_t v16 = &unk_101A7CE38;
    int v17 = &v19;
    int v18 = &v13;
    dispatch_sync(v8, block);
  }
  else
  {
    uint64_t v15 = sub_10005B4DC;
    uint64_t v16 = &unk_101A7CE58;
    int v17 = &v19;
    int v18 = &v13;
    dispatch_async_and_wait(v8, block);
  }
  return v19 != 0;
}

BOOL sub_100FF946C(uint64_t a1, uint64_t a2, int *a3, int a4)
{
  BOOL v6 = *(uint64_t **)(a1 + 240);
  if (!v6)
  {
LABEL_7:
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v18 = 136315138;
    uint64_t v19 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v18, 0xCu);
    return 0;
  }
  int v8 = v6;
  while (1)
  {
    int v9 = *((_DWORD *)v8 + 8);
    if (v9 <= (int)a2) {
      break;
    }
LABEL_6:
    int v8 = (uint64_t *)*v8;
    if (!v8) {
      goto LABEL_7;
    }
  }
  if (v9 < (int)a2)
  {
    ++v8;
    goto LABEL_6;
  }
  if (!a4)
  {
    int v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v15) {
      return result;
    }
    LOWORD(v18) = 0;
    uint64_t v16 = "#I Not handling Connected Line Presentation APIs";
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v18, 2u);
    return 0;
  }
  if (!sub_1000389F8(v6, a2)[10])
  {
    int v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v17 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v17) {
      return result;
    }
    LOWORD(v18) = 0;
    uint64_t v16 = "#I CLIP Model is not valid";
    goto LABEL_18;
  }
  *a3 = *(unsigned __int8 *)(sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[10] + 1) == 1;
  int v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *a3;
    int v18 = 67109120;
    LODWORD(v19) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Returning CLIP value: %d", (uint8_t *)&v18, 8u);
  }
  return 1;
}

void sub_100FF9704(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100FF97F4(uint64_t a1, unsigned int a2, int *a3)
{
  unsigned int v9 = a2;
  v8[0] = a1;
  v8[1] = &v9;
  v8[2] = a3;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FF9980(a1, v9, a3);
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_101008238;
  v10[3] = &unk_101A7D3F8;
  void v10[4] = a1 + 8;
  void v10[5] = v8;
  unsigned int v11 = v10;
  BOOL v7 = *(NSObject **)(a1 + 24);
  char v17 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    int v13 = sub_10005A778;
    int v14 = &unk_101A7CE38;
    BOOL v15 = &v17;
    uint64_t v16 = &v11;
    dispatch_sync(v7, block);
  }
  else
  {
    int v13 = sub_10005B4DC;
    int v14 = &unk_101A7CE58;
    BOOL v15 = &v17;
    uint64_t v16 = &v11;
    dispatch_async_and_wait(v7, block);
  }
  return v17 != 0;
}

BOOL sub_100FF9980(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 240);
  if (!v5)
  {
LABEL_7:
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v15 = 136315138;
    uint64_t v16 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v15, 0xCu);
    return 0;
  }
  BOOL v7 = v5;
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)a2) {
      break;
    }
LABEL_6:
    BOOL v7 = (uint64_t *)*v7;
    if (!v7) {
      goto LABEL_7;
    }
  }
  if (v8 < (int)a2)
  {
    ++v7;
    goto LABEL_6;
  }
  if (!sub_1000389F8(v5, a2)[12])
  {
    int v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v14) {
      return result;
    }
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I COLR Model is not valid", (uint8_t *)&v15, 2u);
    return 0;
  }
  *a3 = *(unsigned __int8 *)sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[12] == 1;
  unsigned int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = *a3;
    int v15 = 67109120;
    LODWORD(v16) = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I COLR Model is available, filling %d", (uint8_t *)&v15, 8u);
  }
  return 1;
}

void sub_100FF9BB4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100FF9CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[1])
  {
    int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v16 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    LOWORD(v17) = 0;
    unsigned int v11 = "#I fetchCallForwarding failed, no command driver";
    goto LABEL_11;
  }
  if (sub_100FF6754(a1) && sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[1] != *(void *)(a1 + 152))
  {
    int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v9) {
      return result;
    }
    LOWORD(v17) = 0;
    unsigned int v11 = "#I VoLTE call is active, ignoring request to fetch Call Forwarding value because it would trigger CSFB";
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v17, 2u);
    return 0;
  }
  int v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13[1] + 48))(v13[1]);
    int v17 = 136315138;
    uint64_t v18 = v14;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Sent the Call Forward Fetch request to %s", (uint8_t *)&v17, 0xCu);
  }
  int v15 = sub_1000389F8(*(uint64_t **)(a1 + 240), a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15[1] + 56))(v15[1], a2, a3, a4);
}

void sub_100FF9F28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, int a6, int a7, int a8)
{
  sub_10009DB3C((uint64_t)&v14, a4);
  char v15 = a5;
  int v16 = a6;
  int v17 = a7;
  int v18 = a8;
  int v13 = *(std::__shared_weak_count **)(a1 + 16);
  if (v13)
  {
    if (std::__shared_weak_count::lock(v13)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100FFA0B8(uint64_t a1, unsigned int a2, BOOL *a3, uint64_t a4, unsigned char *a5, int a6, unsigned int a7)
{
  int v16 = a6;
  unsigned int v17 = a2;
  unsigned int v15 = a7;
  v14[0] = a1;
  v14[1] = &v17;
  v14[2] = a3;
  v14[3] = a4;
  v14[4] = a5;
  v14[5] = &v16;
  void v14[6] = &v15;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FFA274(a1, v17, a3, a4, a5, v16, v15);
    }
    BOOL v12 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v12 = 1;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = sub_101009560;
  v18[3] = &unk_101A7D518;
  v18[4] = a1 + 8;
  v18[5] = v14;
  uint64_t v19 = v18;
  int v13 = *(NSObject **)(a1 + 24);
  char v25 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v12)
  {
    char v21 = sub_10005A778;
    uint64_t v22 = &unk_101A7CE38;
    uint64_t v23 = &v25;
    uint64_t v24 = &v19;
    dispatch_sync(v13, block);
  }
  else
  {
    char v21 = sub_10005B4DC;
    uint64_t v22 = &unk_101A7CE58;
    uint64_t v23 = &v25;
    uint64_t v24 = &v19;
    dispatch_async_and_wait(v13, block);
  }
  return v25 != 0;
}

BOOL sub_100FFA274(uint64_t a1, uint64_t a2, BOOL *a3, uint64_t a4, unsigned char *a5, int a6, unsigned int a7)
{
  BOOL v9 = *(uint64_t **)(a1 + 240);
  if (v9)
  {
    unsigned int v15 = v9;
    do
    {
      int v16 = *((_DWORD *)v15 + 8);
      if (v16 <= (int)a2)
      {
        if (v16 >= (int)a2)
        {
          uint64_t v39 = 0;
          *(_OWORD *)CFBooleanRef v37 = 0u;
          long long v38 = 0u;
          uint64_t v20 = sub_1000389F8(v9, a2);
          BOOL v21 = sub_100AB8218(v20[3], a6, a7, (uint64_t)v37);
          BOOL v18 = v21;
          if (v21)
          {
            memset(&v36, 0, sizeof(v36));
            if (v38 >= 0) {
              uint64_t v22 = (std::string::value_type *)&v37[1];
            }
            else {
              uint64_t v22 = (std::string::value_type *)v37[1];
            }
            if (v38 >= 0) {
              std::string::size_type v23 = HIBYTE(v38);
            }
            else {
              std::string::size_type v23 = v38;
            }
            sub_10006E5EC(&v36, v22, &v22[v23], v23);
            CSIPhoneNumber::CSIPhoneNumber();
            *(void *)a4 = *(void *)buf;
            uint64_t v24 = (void **)(a4 + 8);
            if (*(char *)(a4 + 31) < 0) {
              operator delete(*v24);
            }
            *(_OWORD *)uint64_t v24 = *(_OWORD *)&buf[8];
            *(void *)(a4 + 24) = v41;
            HIBYTE(v41) = 0;
            uint8_t buf[8] = 0;
            char v25 = (void **)(a4 + 32);
            if (*(char *)(a4 + 55) < 0) {
              operator delete(*v25);
            }
            *(_OWORD *)char v25 = v42;
            *(void *)(a4 + 48) = v43;
            HIBYTE(v43) = 0;
            LOBYTE(v42) = 0;
            *(_DWORD *)(a4 + 56) = v44;
            *(unsigned char *)(a4 + 60) = v45;
            int v26 = (void **)(a4 + 64);
            if (*(char *)(a4 + 87) < 0) {
              operator delete(*v26);
            }
            *(_OWORD *)int v26 = __p;
            *(void *)(a4 + 80) = v47;
            HIBYTE(v47) = 0;
            LOBYTE(__p) = 0;
            BOOL v27 = (_OWORD *)(a4 + 88);
            if (*(char *)(a4 + 111) < 0)
            {
              operator delete(*(void **)(a4 + 88));
              int v29 = SHIBYTE(v47);
              *BOOL v27 = v48;
              *(void *)(a4 + 104) = v49;
              HIBYTE(v49) = 0;
              LOBYTE(v48) = 0;
              *(_OWORD *)(a4 + 112) = v50;
              *(unsigned char *)(a4 + 128) = v51;
              if (v29 < 0) {
                operator delete((void *)__p);
              }
            }
            else
            {
              *BOOL v27 = v48;
              *(void *)(a4 + 104) = v49;
              HIBYTE(v49) = 0;
              LOBYTE(v48) = 0;
              *(_OWORD *)(a4 + 112) = v50;
              *(unsigned char *)(a4 + 128) = v51;
            }
            if (SHIBYTE(v43) < 0) {
              operator delete((void *)v42);
            }
            if (SHIBYTE(v41) < 0) {
              operator delete(*(void **)&buf[8]);
            }
            *a5 = v39;
            *a3 = BYTE1(v37[0]) == 1;
            int v30 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              CSIPhoneNumber::getFullNumber((uint64_t *)v34, (CSIPhoneNumber *)a4);
              BOOL v31 = v35 >= 0 ? v34 : (void **)v34[0];
              int v32 = (char)*a5;
              BOOL v33 = *a3;
              *(_DWORD *)buf = 136315650;
              *(void *)&uint8_t buf[4] = v31;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v32;
              *(_WORD *)&unsigned char buf[18] = 1024;
              *(_DWORD *)&buf[20] = v33;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Call Forward return values: Number '%s', Time %d, Enabled %d", buf, 0x18u);
              if (v35 < 0) {
                operator delete(v34[0]);
              }
            }
            if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v36.__r_.__value_.__l.__data_);
            }
          }
          else
          {
            int v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = a6;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = a7;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Failed to retrieve call forward setting for reason %d, class %d", buf, 0xEu);
            }
          }
          if (SHIBYTE(v38) < 0) {
            operator delete(v37[1]);
          }
          return v18;
        }
        ++v15;
      }
      unsigned int v15 = (uint64_t *)*v15;
    }
    while (v15);
  }
  unsigned int v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  return 0;
}

void sub_100FFA6EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100FFA730(uint64_t a1, int a2)
{
  int v13 = a2;
  v12[0] = a1;
  v12[1] = &v13;
  if (!*(void *)(a1 + 32))
  {
    BOOL v9 = 1;
    goto LABEL_13;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v9 = *(void *)(a1 + 32) == 0;
LABEL_13:
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_101009584;
    v14[3] = &unk_101A7D538;
    v14[4] = a1 + 8;
    v14[5] = v12;
    unsigned int v15 = v14;
    int v10 = *(NSObject **)(a1 + 24);
    unsigned __int8 v16 = 0;
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    if (v9)
    {
      BOOL v18 = sub_10005A778;
      uint64_t v19 = &unk_101A7CE38;
      uint64_t v20 = &v16;
      BOOL v21 = &v15;
      dispatch_sync(v10, &buf);
    }
    else
    {
      BOOL v18 = sub_10005B4DC;
      uint64_t v19 = &unk_101A7CE58;
      uint64_t v20 = &v16;
      BOOL v21 = &v15;
      dispatch_async_and_wait(v10, &buf);
    }
    int v11 = v16;
    return v11 != 0;
  }
  uint64_t v3 = *(uint64_t **)(a1 + 240);
  if (v3)
  {
    __int16 v4 = *(uint64_t **)(a1 + 240);
    do
    {
      int v5 = *((_DWORD *)v4 + 8);
      if (v13 >= v5)
      {
        if (v5 >= v13)
        {
          int v11 = *(unsigned __int8 *)(sub_1000389F8(v3, v13)[3] + 48);
          return v11 != 0;
        }
        ++v4;
      }
      __int16 v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  BOOL v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v13);
  BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (result)
  {
    uint64_t v8 = subscriber::asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    return 0;
  }
  return result;
}

void sub_100FFA988(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100FFA994(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_10033571C((uint64_t)&v7, a3);
  __int16 v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFAAE0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100FFAAF8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100FFABEC(uint64_t a1, unsigned int a2, int *a3)
{
  unsigned int v9 = a2;
  v8[0] = a1;
  v8[1] = &v9;
  v8[2] = a3;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_100FFAD78(a1, v9, a3);
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_101009D1C;
  v10[3] = &unk_101A7D5D8;
  void v10[4] = a1 + 8;
  void v10[5] = v8;
  int v11 = v10;
  uint64_t v7 = *(NSObject **)(a1 + 24);
  char v17 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    int v13 = sub_10005A778;
    uint64_t v14 = &unk_101A7CE38;
    unsigned int v15 = &v17;
    unsigned __int8 v16 = &v11;
    dispatch_sync(v7, block);
  }
  else
  {
    int v13 = sub_10005B4DC;
    uint64_t v14 = &unk_101A7CE58;
    unsigned int v15 = &v17;
    unsigned __int8 v16 = &v11;
    dispatch_async_and_wait(v7, block);
  }
  return v17 != 0;
}

BOOL sub_100FFAD78(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 240);
  if (!v5)
  {
LABEL_7:
    unsigned int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v14 = 136315138;
    uint64_t v15 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v14, 0xCu);
    return 0;
  }
  uint64_t v7 = v5;
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)a2) {
      break;
    }
LABEL_6:
    uint64_t v7 = (uint64_t *)*v7;
    if (!v7) {
      goto LABEL_7;
    }
  }
  if (v8 < (int)a2)
  {
    ++v7;
    goto LABEL_6;
  }
  if (!sub_1000389F8(v5, a2)[14])
  {
    BOOL v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v13) {
      return result;
    }
    LOWORD(v14) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I CNAP values are unknown", (uint8_t *)&v14, 2u);
    return 0;
  }
  if (*(unsigned char *)(sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[14] + 1) == 1) {
    int v11 = *(unsigned __int8 *)sub_1000389F8(*(uint64_t **)(a1 + 240), a2)[14] == 1;
  }
  else {
    int v11 = 2;
  }
  *a3 = v11;
  return 1;
}

uint64_t sub_100FFAF58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 384) + 24))();
}

void sub_100FFAF80(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFB078(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFB168(uint64_t a1, unsigned int *a2)
{
  if (a2[1] != 31) {
    return;
  }
  __int16 v4 = *(uint64_t **)(a1 + 240);
  uint64_t v5 = *a2;
  if (!v4)
  {
LABEL_7:
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v41 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
    return;
  }
  while (1)
  {
    int v6 = *((_DWORD *)v4 + 8);
    if ((int)v5 >= v6) {
      break;
    }
LABEL_6:
    __int16 v4 = (uint64_t *)*v4;
    if (!v4) {
      goto LABEL_7;
    }
  }
  if (v6 < (int)v5)
  {
    ++v4;
    goto LABEL_6;
  }
  uint64_t v8 = *((void *)a2 + 1);
  uint64_t v9 = *((void *)a2 + 2);
  if (v8 == v9)
  {
    uint64_t v22 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v41 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Received SIM file %s data from SimFS with no data, ignoring", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v39 = 0;
    CFBooleanRef v38 = kCFBooleanFalse;
    if (kCFBooleanFalse) {
      CFRetain(kCFBooleanFalse);
    }
    sub_100FF6114(buf, (Registry **)(a1 + 96), (NSObject **)(a1 + 40), v5, (uint64_t)"supported", &v38);
    sub_1000057AC(&v39, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    sub_1000577C4((const void **)&v38);
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, v39, v10);
    int v11 = buf[0];
    CFBooleanRef v36 = kCFBooleanFalse;
    CFBooleanRef v37 = 0;
    uint64_t v12 = *a2;
    if (kCFBooleanFalse) {
      CFRetain(kCFBooleanFalse);
    }
    sub_100FF6114(buf, (Registry **)(a1 + 96), (NSObject **)(a1 + 40), v12, (uint64_t)"IgnoreSimFileCFIS", &v36);
    sub_1000057AC(&v37, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    sub_1000577C4((const void **)&v36);
    buf[0] = 0;
    ctu::cf::assign((ctu::cf *)buf, v37, v13);
    int v14 = buf[0];
    uint64_t v15 = sub_1000389F8(*(uint64_t **)(a1 + 240), *a2);
    if (v14) {
      BOOL v16 = v11 == 0;
    }
    else {
      BOOL v16 = 1;
    }
    if (!v16 || v15[1] == *(void *)(a1 + 152))
    {
      std::string::size_type v23 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)uint64_t v41 = v24;
        uint64_t v19 = "#I Ignoring SIM file %s as Call Forwarding is provisioned over XCAP";
        uint64_t v20 = v23;
        uint32_t v21 = 12;
LABEL_28:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
      }
    }
    else
    {
      unint64_t v17 = v9 - v8;
      if (((v9 - v8) & 0xF) != 0)
      {
        BOOL v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          uint64_t v19 = "#N Data size is not aligning to 16 byte record";
          uint64_t v20 = v18;
          uint32_t v21 = 2;
          goto LABEL_28;
        }
      }
      else if (v17 >= 0x10)
      {
        uint64_t v25 = 0;
        unint64_t v26 = v17 >> 4;
        BOOL v27 = (unsigned __int8 *)(*((void *)a2 + 1) + 1);
        while (1)
        {
          int v29 = *v27;
          v27 += 16;
          int v28 = v29;
          if (v29 != 255) {
            break;
          }
          if (v26 == ++v25) {
            goto LABEL_29;
          }
        }
        int v30 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *a2);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109632;
          *(_DWORD *)uint64_t v41 = v28 & 1;
          *(_WORD *)&v41[4] = 1024;
          *(_DWORD *)&v41[6] = v28;
          __int16 v42 = 2048;
          uint64_t v43 = v25;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Read the CFU status for voice from SIM: %d with second byte: %x in record %lu", buf, 0x18u);
        }
        BOOL v31 = sub_1000389F8(*(uint64_t **)(a1 + 240), *a2);
        sub_100AB8128(v31[3], v28 & 1);
        int v32 = *(std::__shared_weak_count **)(a1 + 224);
        if (v32)
        {
          BOOL v33 = std::__shared_weak_count::lock(v32);
          if (v33)
          {
            uint64_t v34 = v33;
            uint64_t v35 = *(void *)(a1 + 216);
            if (v35) {
              (*(void (**)(uint64_t, void))(*(void *)v35 + 328))(v35, *a2);
            }
            sub_10004D2C8(v34);
          }
        }
      }
    }
LABEL_29:
    sub_100062778((const void **)&v37);
    sub_100062778((const void **)&v39);
  }
}

void sub_100FFB660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  __int16 v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  sub_10004D2C8(v2);
  sub_100062778((const void **)va);
  sub_100062778((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100FFB6FC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFB7EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFB8DC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFB9D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __int16 v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFBAFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t *sub_100FFBB04(uint64_t *result)
{
  uint64_t v1 = result[5];
  if (!v1) {
    return result;
  }
  uint64_t v2 = (uint64_t)result;
  __int16 v4 = result + 4;
  uint64_t v3 = result[4];
  result[5] = v1 - 1;
  result[4] = v3 + 1;
  sub_1010089C4((uint64_t)result, 1);
  if (*(void *)(v2 + 40))
  {
    BOOL result = *(uint64_t **)(v2 + 48);
    if (!result) {
      return result;
    }
    unint64_t v5 = *(void *)(*(void *)(v2 + 8) + 8 * (*(void *)(v2 + 32) / 0x155uLL))
       + 12 * (*(void *)(v2 + 32) % 0x155uLL);
    BOOL result = (uint64_t *)(*(uint64_t (**)(uint64_t *, void, void))(*result + 16))(result, *(void *)v5, *(unsigned int *)(v5 + 8));
    if (*(void *)(v2 + 40)) {
      return result;
    }
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  uint64_t v7 = *(void ***)(v2 + 8);
  uint64_t v6 = *(void *)(v2 + 16);
  *(void *)(v2 + 40) = 0;
  unint64_t v8 = v6 - (void)v7;
  if ((unint64_t)(v6 - (void)v7) >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v6 = *(void *)(v2 + 16);
      uint64_t v7 = (void **)(*(void *)(v2 + 8) + 8);
      *(void *)(v2 + 8) = v7;
      unint64_t v8 = v6 - (void)v7;
    }
    while ((unint64_t)(v6 - (void)v7) > 0x10);
  }
  unint64_t v9 = v8 >> 3;
  if (v9 == 1)
  {
    uint64_t v10 = 170;
    goto LABEL_11;
  }
  if (v9 == 2)
  {
    uint64_t v10 = 341;
LABEL_11:
    *__int16 v4 = v10;
  }
  if (*(void *)(v2 + 40))
  {
    sub_1010089C4(v2, 0);
    uint64_t v12 = *(void *)(v2 + 8);
    uint64_t v11 = *(void *)(v2 + 16);
    if (v11 == v12) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = 341 * ((v11 - v12) >> 3) - 1;
    }
    if ((unint64_t)(v13 - (*(void *)(v2 + 40) + *(void *)(v2 + 32))) >= 0x155)
    {
      operator delete(*(void **)(v11 - 8));
      *(void *)(v2 + 16) -= 8;
    }
  }
  else
  {
    while ((void **)v6 != v7)
    {
      operator delete(*(void **)(v6 - 8));
      uint64_t v7 = *(void ***)(v2 + 8);
      uint64_t v6 = *(void *)(v2 + 16) - 8;
      *(void *)(v2 + 16) = v6;
    }
    *__int16 v4 = 0;
  }
  sub_101008A20((void **)v2);
  uint64_t v15 = *(void *)(v2 + 8);
  uint64_t v14 = *(void *)(v2 + 16);
  if (v14 != v15) {
    *(void *)(v2 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  sub_101008A20((void **)v2);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *__int16 v4 = 0;
  v4[1] = 0;
  long long v18 = 0uLL;
  return (uint64_t *)sub_100FFDCC8((uint64_t)&v16);
}

void sub_100FFBD04(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFBE1C(uint64_t a1)
{
}

void sub_100FFBE24(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFBF40(uint64_t a1)
{
}

void sub_100FFBF48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC068(uint64_t a1)
{
}

void sub_100FFC070(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC17C(uint64_t a1)
{
}

void sub_100FFC184(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC29C(uint64_t a1)
{
}

void sub_100FFC2A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC3C0(uint64_t a1)
{
}

void sub_100FFC3C8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC4E8(uint64_t a1)
{
}

void sub_100FFC4F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC5E4(uint64_t a1)
{
}

void sub_100FFC5EC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC6F0(uint64_t a1)
{
}

void sub_100FFC6F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC80C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_100FFC814(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFC920(uint64_t a1)
{
}

void sub_100FFC928(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFCA34(uint64_t a1)
{
}

uint64_t *sub_100FFCA3C(uint64_t *result)
{
  uint64_t v1 = result[5];
  if (!v1) {
    return result;
  }
  uint64_t v2 = (uint64_t)result;
  uint64_t v4 = result + 4;
  uint64_t v3 = result[4];
  result[5] = v1 - 1;
  result[4] = v3 + 1;
  sub_10100E9EC((uint64_t)result, 1);
  if (*(void *)(v2 + 40))
  {
    BOOL result = *(uint64_t **)(v2 + 48);
    if (!result) {
      return result;
    }
    unint64_t v5 = (void *)(*(void *)(*(void *)(v2 + 8) + ((*(void *)(v2 + 32) >> 5) & 0x7FFFFFFFFFFFFF8))
                  + 16 * *(void *)(v2 + 32));
    BOOL result = (uint64_t *)(*(uint64_t (**)(uint64_t *, void, void))(*result + 16))(result, *v5, v5[1]);
    if (*(void *)(v2 + 40)) {
      return result;
    }
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  uint64_t v7 = *(void ***)(v2 + 8);
  uint64_t v6 = *(void *)(v2 + 16);
  *(void *)(v2 + 40) = 0;
  unint64_t v8 = v6 - (void)v7;
  if ((unint64_t)(v6 - (void)v7) >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v6 = *(void *)(v2 + 16);
      uint64_t v7 = (void **)(*(void *)(v2 + 8) + 8);
      *(void *)(v2 + 8) = v7;
      unint64_t v8 = v6 - (void)v7;
    }
    while ((unint64_t)(v6 - (void)v7) > 0x10);
  }
  unint64_t v9 = v8 >> 3;
  if (v9 == 1)
  {
    uint64_t v10 = 128;
    goto LABEL_11;
  }
  if (v9 == 2)
  {
    uint64_t v10 = 256;
LABEL_11:
    *uint64_t v4 = v10;
  }
  if (*(void *)(v2 + 40))
  {
    sub_10100E9EC(v2, 0);
    uint64_t v12 = *(void *)(v2 + 8);
    uint64_t v11 = *(void *)(v2 + 16);
    if (v11 == v12) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = 32 * (v11 - v12) - 1;
    }
    if ((unint64_t)(v13 - (*(void *)(v2 + 40) + *(void *)(v2 + 32))) >= 0x100)
    {
      operator delete(*(void **)(v11 - 8));
      *(void *)(v2 + 16) -= 8;
    }
  }
  else
  {
    while ((void **)v6 != v7)
    {
      operator delete(*(void **)(v6 - 8));
      uint64_t v7 = *(void ***)(v2 + 8);
      uint64_t v6 = *(void *)(v2 + 16) - 8;
      *(void *)(v2 + 16) = v6;
    }
    *uint64_t v4 = 0;
  }
  sub_10100EA48((void **)v2);
  uint64_t v15 = *(void *)(v2 + 8);
  uint64_t v14 = *(void *)(v2 + 16);
  if (v14 != v15) {
    *(void *)(v2 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  sub_10100EA48((void **)v2);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *uint64_t v4 = 0;
  v4[1] = 0;
  long long v18 = 0uLL;
  return (uint64_t *)sub_100FFDC00((uint64_t)&v16);
}

void sub_100FFCC0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFCD24(uint64_t a1)
{
}

void sub_100FFCD2C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFCE3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100FFCE44(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFCF48(uint64_t a1)
{
}

void sub_100FFCF50(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Network saved CLIR values successfully", v2, 2u);
  }
}

void sub_100FFCFD8(uint64_t a1)
{
}

void sub_100FFCFE0(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    uint64_t v3 = CSIErrorString();
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Network unable to save CLIR info, error=%s", (uint8_t *)&v2, 0xCu);
  }
}

void sub_100FFD0AC(uint64_t a1)
{
}

void sub_100FFD0B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFD1C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100FFD1CC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFD2D0(uint64_t a1)
{
}

void *sub_100FFD2D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Saved CLIP values successfully", (uint8_t *)v8, 2u);
  }
  v8[0] = off_101A7E1D8;
  v8[1] = a1;
  v8[2] = a2 | (unint64_t)(a3 << 32);
  void v8[3] = v8;
  sub_100FF704C(a1, a2, (uint64_t)v8);
  return sub_10003B34C(v8);
}

void sub_100FFD3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100FFD3F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100FFD2D8(a1 - 64, a2, a3);
}

void *sub_100FFD400(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v6) = 136315138;
    *(void *)((char *)&v6 + 4) = CSIErrorString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Unable to fetch CLIP info, error=%s", (uint8_t *)&v6, 0xCu);
  }
  *(void *)&long long v6 = off_101A7E258;
  *((void *)&v6 + 1) = a1;
  uint64_t v7 = a2;
  unint64_t v8 = &v6;
  sub_100FF7EDC(a1, a2, (uint64_t)&v6);
  return sub_10003B34C(&v6);
}

void sub_100FFD520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100FFD534(uint64_t a1, uint64_t a2)
{
  return sub_100FFD400(a1 - 64, a2);
}

void sub_100FFD53C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFD64C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100FFD654(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFD748(uint64_t a1)
{
}

void sub_100FFD750(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFD860(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100FFD868(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFD95C(uint64_t a1)
{
}

void sub_100FFD964(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFDA80(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100FFDB74()
{
  return 1;
}

void *sub_100FFDB7C(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100FFDC00(uint64_t a1)
{
  int v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 256;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100FFDCC8(uint64_t a1)
{
  int v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 170;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 341;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100FFDD90(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  unint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_100FFDDF8(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  unint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_100FFDE60(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100FFDF2C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100FFE004);
  __cxa_rethrow();
}

void sub_100FFDF54(_Unwind_Exception *a1)
{
}

void sub_100FFDF6C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100FFDFA4(uint64_t a1)
{
}

uint64_t sub_100FFDFC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100FFE004(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100FFE030(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *v1;
  long long v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 400));
  uint64_t v4 = *(void *)(v2 + 184);
  long long v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  uint64_t v6 = *(void *)(v2 + 136);
  uint64_t v7 = v1[1];
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(v7);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 32))(v6, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  for (uint64_t i = *(void *)(v2 + 80); i != v2 + 72; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 72));
  sub_100088C88((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100FFE1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group, dispatch_group_t a13)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100FFE208(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *v1;
  long long v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_100058DB0(__p, "/cc/events/subscriber_sim_file_event");
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = off_101A7C2B8;
  v4[1] = v2;
  v4[2] = sub_100FFB168;
  v4[3] = 0;
  uint64_t v19 = v4;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  uint64_t v13 = sub_100FFF77C;
  uint64_t v14 = &unk_101A7C328;
  uint64_t v15 = v2 + 8;
  long long v16 = sub_100FF5900;
  uint64_t v17 = 0;
  aBlock = _Block_copy(__p);
  long long v5 = *(std::__shared_weak_count **)(v2 + 16);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      sub_1001644F8(&v11, &aBlock, *(dispatch_object_t *)(v2 + 24));
      sub_100164540(buf, &v11);
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100FFF334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, dispatch_group_t group, uint64_t a14, uint64_t a15, dispatch_group_t object, dispatch_group_t a17, dispatch_group_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100FFF5DC()
{
}

__n128 sub_100FFF5F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7C2B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100FFF644(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C2B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100FFF67C(void *a1)
{
  uint64_t v5 = 0x2800000000;
  long long __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void sub_100FFF714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FFF730(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FFF770()
{
}

uint64_t sub_100FFF77C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100FFF7C8(void *a1)
{
  *a1 = off_101A7C358;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100FFF814(void *a1)
{
  *a1 = off_101A7C358;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100FFF880(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100FFF930(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100FFF948(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100FFF968()
{
}

void *sub_100FFF9D4(void *a1)
{
  *a1 = off_101A7C3A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100FFFA20(void *a1)
{
  *a1 = off_101A7C3A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100FFFA8C()
{
}

void sub_100FFFAFC()
{
}

__n128 sub_100FFFB10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7C3E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100FFFB64(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C3E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100FFFB9C(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  rest::read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100FFFC20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FFFC60()
{
}

void sub_100FFFC70()
{
}

__n128 sub_100FFFC84(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7C468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100FFFCD0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100FFFD00(uint64_t a1, xpc_object_t *a2)
{
  void (***v14)(uint64_t *__return_ptr, void, uint64_t);
  char v15;
  uint64_t *v16;
  BOOL v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t v20;

  sub_10031A644(*(void *)(a1 + 8), a2);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(uint64_t **)(v4 + 600);
  if (v5 != (uint64_t *)(v4 + 608))
  {
    while (1)
    {
      long long v18 = 0;
      uint64_t v19 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v4 + 96));
      uint64_t v7 = ServiceMap;
      if ((v8 & 0x8000000000000000) != 0)
      {
        uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          unint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      uint64_t v20 = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v20);
      if (!v12) {
        break;
      }
      uint64_t v14 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (!v13) {
        goto LABEL_9;
      }
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      uint64_t v15 = 0;
LABEL_10:
      (**v14)(&v18, v14, (uint64_t)(v5 + 4));
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      if (v18 && !*(unsigned char *)(v18 + 49)) {
        sub_100FF450C(v4, *(unsigned int *)(v18 + 52));
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
      long long v16 = (uint64_t *)v5[1];
      if (v16)
      {
        do
        {
          uint64_t v3 = v16;
          long long v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v3 = (uint64_t *)v5[2];
          uint64_t v17 = *v3 == (void)v5;
          uint64_t v5 = v3;
        }
        while (!v17);
      }
      uint64_t v5 = v3;
      if (v3 == (uint64_t *)(v4 + 608)) {
        return;
      }
    }
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    uint64_t v15 = 1;
    goto LABEL_10;
  }
}

void sub_100FFFE9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100FFFEC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100FFFF08()
{
}

void sub_100FFFF18()
{
}

__n128 sub_100FFFF2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7C4E8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100FFFF80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C4E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100FFFFB8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008B2E4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  unint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087ED0((uint64_t)&v9, v10);
}

void sub_101000078(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101000090(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010000D0()
{
}

void sub_1010000E0()
{
}

__n128 sub_1010000F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7C568;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101000148(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101000180(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100F541BC((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  unint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_101000240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101000258(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101000298()
{
}

void sub_1010002A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7C5E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1010002C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7C5E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101000318(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_101000340(SuppServicesDriverEventHandlerInterface *this)
{
  *(void *)this = off_101A7C638;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SuppServicesDriverEventHandlerInterface::~SuppServicesDriverEventHandlerInterface(this);
}

void sub_10100039C(SuppServicesDriverEventHandlerInterface *this)
{
  *(void *)this = off_101A7C638;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  SuppServicesDriverEventHandlerInterface::~SuppServicesDriverEventHandlerInterface(this);

  operator delete();
}

void sub_10100040C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    unsigned int v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13)
      {
        uint64_t v14 = (std::__shared_weak_count *)a3[1];
        uint64_t v15 = *a3;
        long long v16 = v14;
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v13 + 344))(v13, a2, &v15, a4, a5);
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_1010004D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1010004F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v7);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15 + 352))(v15, a2, a3, a4, a5, a6);
      }
      sub_10004D2C8(v14);
    }
  }
}

void sub_1010005CC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1010005E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v7);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15 + 360))(v15, a2, a3, a4, a5, a6);
      }
      sub_10004D2C8(v14);
    }
  }
}

void sub_1010006B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1010006C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      long long v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 368))(v17, a2, a3, a4, a5, a6, a7);
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_1010007A4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1010007B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    unsigned int v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 376))(v13, a2, a3, a4, a5);
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_101000878(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10100088C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v7);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15 + 384))(v15, a2, a3, a4, a5, a6);
      }
      sub_10004D2C8(v14);
    }
  }
}

void sub_101000960(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000974(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v7);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15 + 392))(v15, a2, a3, a4, a5, a6);
      }
      sub_10004D2C8(v14);
    }
  }
}

void sub_101000A48(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000A5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v8);
    if (v15)
    {
      long long v16 = v15;
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 400))(v17, a2, a3, a4, a5, a6, a7);
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_101000B38(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000B4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 408))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101000BF0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000C04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 416))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101000CBC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000CD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        uint64_t v12 = (std::__shared_weak_count *)a4[1];
        uint64_t v13 = *a4;
        uint64_t v14 = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v11 + 424))(v11, a2, a3, &v13);
        if (v14) {
          sub_10004D2C8(v14);
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101000D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_101000DB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 432))(v13, a2, a3, a4, a5);
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_101000E74(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000E88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 440))(v13, a2, a3, a4, a5);
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_101000F48(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101000F5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v7);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v15 + 448))(v15, a2, a3, a4, a5, a6);
      }
      sub_10004D2C8(v14);
    }
  }
}

void sub_101001030(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101001044(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4) {
    return 0;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return 0;
  }
  unint64_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 8);
  if (v9) {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 456))(v9, a2, a3);
  }
  else {
    uint64_t v10 = 0;
  }
  sub_10004D2C8(v8);
  return v10;
}

void sub_1010010E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1010010F8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = (std::__shared_weak_count *)a3[1];
        uint64_t v11 = *a3;
        uint64_t v12 = v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v9 + 464))(v9, a2, &v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010011AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1010011CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 472))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101001284(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101001298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 480))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10100133C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101001350(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 488))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010013F4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101001408(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = (std::__shared_weak_count *)a3[1];
        uint64_t v11 = *a3;
        uint64_t v12 = v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v9 + 496))(v9, a2, &v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010014BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1010014DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 504))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101001594(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1010015A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 512))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10100164C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101001660(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 520))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101001704(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101001718(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = (std::__shared_weak_count *)a3[1];
        uint64_t v11 = *a3;
        uint64_t v12 = v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v9 + 528))(v9, a2, &v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010017CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1010017EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 536))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101001890(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1010018A4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = (std::__shared_weak_count *)a3[1];
        uint64_t v11 = *a3;
        uint64_t v12 = v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v9 + 544))(v9, a2, &v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101001958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_101001978(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 552))(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101001A1C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101001A30(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101001A60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_101001AB0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_101001BF8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101001C28(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_101001C78(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = subscriber::asString();
          uint64_t v12 = sub_1000389F8(*(uint64_t **)(v9 + 240), a2);
          uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12[1] + 48))(v12[1]);
          int v15 = 136315394;
          uint64_t v16 = v11;
          __int16 v17 = 2080;
          uint64_t v18 = v13;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Issuing request of %s to %s to save the Call Waiting values", (uint8_t *)&v15, 0x16u);
        }
        uint64_t v14 = sub_1000389F8(*(uint64_t **)(v9 + 240), a2);
        (*(void (**)(uint64_t, uint64_t, BOOL, unint64_t, unint64_t))(*(void *)v14[1] + 112))(v14[1], a2, (a2 & 0xFF00000000) != 0, a3, HIDWORD(a3));
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101001E10(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101001E24(uint64_t **a1)
{
  unint64_t v8 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  sub_100FF342C((void **)v1);
  subscriber::makeSimSlotRange();
  uint64_t v4 = *(unsigned int **)buf;
  uint64_t v3 = v10;
  if (*(unsigned int **)buf != v10)
  {
    uint64_t v5 = v11;
    do
    {
      if (v5(*v4)) {
        goto LABEL_8;
      }
      ++v4;
    }
    while (v4 != v3);
    uint64_t v4 = v3;
LABEL_8:
    uint64_t v6 = v10;
LABEL_9:
    while (v4 != v6)
    {
      sub_100FF450C(v1, *v4);
      uint64_t v7 = v4 + 1;
      uint64_t v4 = v3;
      if (v7 != v3)
      {
        uint64_t v4 = v7;
        do
        {
          if (v5(*v4)) {
            goto LABEL_9;
          }
          ++v4;
        }
        while (v4 != v3);
        uint64_t v4 = v3;
      }
    }
  }
  (*(void (**)(void))(**(void **)(v1 + 184) + 24))(*(void *)(v1 + 184));
  (*(void (**)(void))(**(void **)(v1 + 136) + 16))(*(void *)(v1 + 136));
  operator delete();
}

void sub_101001FA0()
{
}

void sub_101001FDC()
{
}

uint64_t sub_101001FF0(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_101001FFC(void *a1)
{
  if (a1)
  {
    sub_101001FFC(*a1);
    sub_101001FFC(a1[1]);
    sub_101002050((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

uint64_t sub_101002050(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 152);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 120);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 104);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_10005D144(*(void **)(a1 + 64));
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 48);
  if (v7) {
    sub_10004D2C8(v7);
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9) {
    sub_10004D2C8(v9);
  }
  return a1;
}

void sub_1010020DC(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_101002050((uint64_t)v1 + 40);
    }
    operator delete(v1);
  }
}

void sub_101002138()
{
}

void *sub_10100214C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A7C828;
  result[1] = v3;
  return result;
}

uint64_t sub_101002194(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A7C828;
  a2[1] = v2;
  return result;
}

void sub_1010021C0(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      int v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          int v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/clir_infos");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_101002488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_101002540(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002580()
{
}

void sub_101002590()
{
}

__n128 sub_1010025A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7C8B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1010025F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C8B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101002630(void *a1, xpc_object_t *a2)
{
  int v12 = 0;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    int v12 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int v12 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  xpc_object_t v8 = (uint64_t (*)(void *, int *))a1[2];
  uint64_t v9 = a1[3];
  xpc_object_t v10 = (void *)(a1[1] + (v9 >> 1));
  if (v9) {
    xpc_object_t v8 = *(uint64_t (**)(void *, int *))(*v10 + v8);
  }
  return v8(v10, &v12);
}

uint64_t sub_101002718(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002758()
{
}

void sub_101002768()
{
}

__n128 sub_10100277C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7C938;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1010027D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C938;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101002808(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  xpc_object_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *xpc_object_t v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100A59380((uint64_t)v3, a2, "PersonalityID", "State");
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_1010028D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1010028F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002930()
{
}

void sub_101002940()
{
}

__n128 sub_101002954(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7C9B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1010029A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7C9B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010029E0(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *xpc_object_t v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100A5892C((uint64_t)v3, a2, "PersonalityID", "State");
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1007035FC((uint64_t)&v9, v10);
}

void sub_101002AB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101002AC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002B08()
{
}

void sub_101002B18()
{
}

__n128 sub_101002B2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7CA38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101002B80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CA38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101002BB8(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  xpc_object_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *xpc_object_t v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100169118((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_101002C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_101002C90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002CD0()
{
}

void sub_101002CE0()
{
}

__n128 sub_101002CF4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7CAB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101002D48(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CAB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101002D80(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  xpc_object_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *xpc_object_t v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_101002E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_101002E58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002E98()
{
}

void sub_101002EA8()
{
}

void *sub_101002EBC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A7CB38;
  result[1] = v3;
  return result;
}

uint64_t sub_101002F04(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A7CB38;
  a2[1] = v2;
  return result;
}

void sub_101002F30(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_101002F38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101002F78()
{
}

void sub_101002F88()
{
}

__n128 sub_101002F9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7CBB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101002FF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CBB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101003028(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *xpc_object_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_1010030E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101003100(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101003140()
{
}

void sub_101003150()
{
}

__n128 sub_101003164(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7CC38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1010031B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CC38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010031F0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101003238(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101003278()
{
}

void sub_101003288()
{
}

__n128 sub_10100329C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7CCB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1010032F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CCB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101003328(void *a1)
{
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  xpc_object_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1010033BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010033D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101003418()
{
}

void sub_101003424(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(*a1 + 128);
  uint64_t v3 = *(NSObject **)(*a1 + 24);
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4)
  {
    uint64_t v5 = *(void *)(v1 + 8);
    long long v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
      xpc_object_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = v5 + 56;
        if (!v5) {
          uint64_t v10 = 0;
        }
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = v10;
        int v15 = v8;
        std::__shared_weak_count::__release_weak(v7);
        sub_10004D2C8(v9);
      }
      else
      {
        uint64_t v14 = 0;
        int v15 = 0;
        std::__shared_weak_count::__release_weak(v7);
      }
      (*(void (**)(dispatch_group_t *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *))(*(void *)v2 + 48))(group, v2, &object, &v14);
      long long v11 = *(_OWORD *)group;
      group[0] = 0;
      group[1] = 0;
      int v12 = *(std::__shared_weak_count **)(v1 + 192);
      *(_OWORD *)(v1 + 184) = v11;
      if (v12)
      {
        sub_10004D2C8(v12);
        if (group[1]) {
          sub_10004D2C8((std::__shared_weak_count *)group[1]);
        }
      }
      if (v15) {
        std::__shared_weak_count::__release_weak(v15);
      }
      if (object) {
        dispatch_release(object);
      }
      uint64_t v13 = *(void *)(v1 + 184);
      group[0] = 0;
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v13 + 16))(v13, group);
      if (group[0])
      {
        dispatch_group_leave(group[0]);
        if (group[0]) {
          dispatch_release(group[0]);
        }
      }
      (*(void (**)(void))(**(void **)(v1 + 184) + 24))(*(void *)(v1 + 184));
      sub_100FF342C((void **)v1);
      operator delete();
    }
  }
  sub_100088B9C();
}

void sub_1010035F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  operator delete();
}

void sub_101003658(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(*a1 + 128);
  uint64_t v3 = *(NSObject **)(*a1 + 24);
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4)
  {
    uint64_t v5 = *(void *)(v1 + 8);
    long long v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
      xpc_object_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = v5 + 56;
        if (!v5) {
          uint64_t v10 = 0;
        }
        atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = v10;
        int v15 = v8;
        std::__shared_weak_count::__release_weak(v7);
        sub_10004D2C8(v9);
      }
      else
      {
        uint64_t v14 = 0;
        int v15 = 0;
        std::__shared_weak_count::__release_weak(v7);
      }
      (*(void (**)(dispatch_group_t *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *))(*(void *)v2 + 40))(group, v2, &object, &v14);
      long long v11 = *(_OWORD *)group;
      group[0] = 0;
      group[1] = 0;
      int v12 = *(std::__shared_weak_count **)(v1 + 192);
      *(_OWORD *)(v1 + 184) = v11;
      if (v12)
      {
        sub_10004D2C8(v12);
        if (group[1]) {
          sub_10004D2C8((std::__shared_weak_count *)group[1]);
        }
      }
      if (v15) {
        std::__shared_weak_count::__release_weak(v15);
      }
      if (object) {
        dispatch_release(object);
      }
      uint64_t v13 = *(void *)(v1 + 184);
      group[0] = 0;
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v13 + 16))(v13, group);
      if (group[0])
      {
        dispatch_group_leave(group[0]);
        if (group[0]) {
          dispatch_release(group[0]);
        }
      }
      (*(void (**)(void))(**(void **)(v1 + 184) + 24))(*(void *)(v1 + 184));
      sub_100FF342C((void **)v1);
      operator delete();
    }
  }
  sub_100088B9C();
}

void sub_101003824(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  operator delete();
}

void sub_10100388C(uint64_t **a1)
{
  uint64_t v9 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    uint64_t v5 = *(uint64_t **)(v2 + 240);
    while (1)
    {
      int v6 = *((_DWORD *)v5 + 8);
      if ((int)v4 >= v6)
      {
        if (v6 >= (int)v4)
        {
          int v8 = *((_DWORD *)v1 + 3);
          *((unsigned char *)sub_1000389F8(v3, v4) + 161) = v8 == 2;
          *((unsigned char *)sub_1000389F8(*(uint64_t **)(v2 + 240), *((_DWORD *)v1 + 2)) + 160) = 1;
          sub_100FF450C(v2, *((unsigned int *)v1 + 2));
          goto LABEL_12;
        }
        ++v5;
      }
      uint64_t v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v1 + 2);
LABEL_9:
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v11 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_12:
  operator delete();
}

void sub_1010039F8()
{
}

void sub_101003A24(uint64_t **a1)
{
  uint64_t v11 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    uint64_t v5 = *(uint64_t **)(v2 + 240);
    while (1)
    {
      int v6 = *((_DWORD *)v5 + 8);
      if ((int)v4 >= v6)
      {
        if (v6 >= (int)v4)
        {
          int v8 = sub_1000389F8(v3, v4);
          if (*((unsigned __int8 *)v8 + 165) != *((unsigned __int8 *)v1 + 12))
          {
            uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              if (*((unsigned char *)v1 + 12)) {
                uint64_t v10 = "true";
              }
              else {
                uint64_t v10 = "false";
              }
              *(_DWORD *)long long buf = 136315138;
              uint64_t v13 = (uint64_t)v10;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I UT Connection: [Available:%s]", buf, 0xCu);
            }
            *(_WORD *)((char *)v8 + 165) = *((_WORD *)v1 + 6);
            sub_100FF450C(v2, *((unsigned int *)v1 + 2));
          }
          goto LABEL_11;
        }
        ++v5;
      }
      uint64_t v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v1 + 2);
LABEL_9:
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v13 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_11:
  operator delete();
}

void sub_101003C1C()
{
}

void sub_101003C48(uint64_t **a1)
{
  uint64_t v10 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    uint64_t v5 = *(uint64_t **)(v2 + 240);
    while (1)
    {
      int v6 = *((_DWORD *)v5 + 8);
      if ((int)v4 >= v6)
      {
        if (v6 >= (int)v4)
        {
          if (*((unsigned __int8 *)sub_1000389F8(v3, v4) + 167) != *((unsigned __int8 *)v1 + 12))
          {
            int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              if (*((unsigned char *)v1 + 12)) {
                uint64_t v9 = "true";
              }
              else {
                uint64_t v9 = "false";
              }
              *(_DWORD *)long long buf = 136315138;
              uint64_t v12 = (uint64_t)v9;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I EmLoc Connection: [Available:%s]", buf, 0xCu);
            }
            *(_WORD *)((char *)sub_1000389F8(*(uint64_t **)(v2 + 240), *((_DWORD *)v1 + 2)) + 167) = *((_WORD *)v1 + 6);
            sub_100FF450C(v2, *((unsigned int *)v1 + 2));
          }
          goto LABEL_11;
        }
        ++v5;
      }
      uint64_t v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v1 + 2);
LABEL_9:
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v12 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_11:
  operator delete();
}

void sub_101003E48()
{
}

uint64_t *sub_101003E74(uint64_t **a1)
{
  uint64_t v1 = *a1;
  unint64_t v54 = a1;
  uint64_t v55 = v1;
  uint64_t v2 = *v1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v1, *(Registry **)(*v1 + 96));
  uint64_t v4 = ServiceMap;
  uint64_t v6 = v5;
  if (v5 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    uint64_t v14 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "CSIPersistentPropertiesInterface is not set!", buf, 2u);
    }
    goto LABEL_29;
  }
LABEL_11:
  (*(void (**)(uint64_t))(*(void *)v12 + 112))(v12);
  uint64_t v56 = 0;
  sub_100058DB0(buf, "SettingsModel::fCLIRStatus");
  char v16 = (*(uint64_t (**)(uint64_t, uint8_t *, uint64_t *))(*(void *)v12 + 24))(v12, buf, &v56);
  char v17 = v16;
  int v15 = (uint64_t *)v59;
  if ((v15 & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((v17 & 1) == 0) {
      goto LABEL_29;
    }
  }
  else if ((v16 & 1) == 0)
  {
    goto LABEL_29;
  }
  xpc_object_t v18 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "SettingsModel::fCLIRStatus";
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Migrating %s property", buf, 0xCu);
  }
  int v19 = v56;
  uint64_t v20 = operator new(0x20uLL);
  v20[1] = 0;
  void v20[2] = 0;
  void *v20 = off_101A7CD38;
  *((unsigned char *)v20 + 24) = BYTE2(v19);
  *((unsigned char *)v20 + 25) = v19;
  *(void *)long long buf = v20 + 3;
  *(void *)&uint8_t buf[8] = v20;
  char v21 = (*(uint64_t (**)(void, uint64_t, uint8_t *))(**(void **)(v2 + 184) + 48))(*(void *)(v2 + 184), 1, buf);
  if (v21)
  {
    long long v57 = *(_OWORD *)buf;
    if (*(void *)&buf[8]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    }
    sub_100FF3570((void **)v2, 1, &v57);
    if (*((void *)&v57 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v57 + 1));
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v21)
  {
    sub_100058DB0(buf, "SettingsModel::fCLIRStatus");
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v12 + 96))(v12, buf);
    int v15 = (uint64_t *)v59;
    if ((v15 & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    xpc_object_t v22 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "SettingsModel::fCLIRStatus";
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Failed to migrate %s property", buf, 0xCu);
    }
  }
LABEL_29:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  xpc_object_t v23 = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(v2 + 96));
  xpc_object_t v24 = v23;
  uint64_t v25 = v5;
  if (v5 < 0)
  {
    xpc_object_t v26 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v23);
  *(void *)long long buf = v25;
  int v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
  if (v29)
  {
    uint64_t v31 = v29[3];
    int v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v32 = 0;
      if (!v31) {
        goto LABEL_37;
      }
      goto LABEL_41;
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  std::mutex::unlock(v24);
  int v30 = 0;
  char v32 = 1;
  if (!v31)
  {
LABEL_37:
    BOOL v33 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "CSIPersistentPropertiesInterface is not set!", buf, 2u);
    }
    goto LABEL_52;
  }
LABEL_41:
  (*(void (**)(uint64_t))(*(void *)v31 + 112))(v31);
  LOBYTE(v57) = 0;
  sub_100058DB0(buf, "SettingsModel::fCallWaitingStatus");
  char v35 = (*(uint64_t (**)(uint64_t, uint8_t *, long long *))(*(void *)v31 + 32))(v31, buf, &v57);
  char v36 = v35;
  uint64_t v34 = (uint64_t *)v59;
  if ((v34 & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if ((v36 & 1) == 0) {
      goto LABEL_52;
    }
  }
  else if ((v35 & 1) == 0)
  {
    goto LABEL_52;
  }
  CFBooleanRef v37 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "SettingsModel::fCallWaitingStatus";
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Migrating %s property", buf, 0xCu);
  }
  if ((*(unsigned int (**)(void, uint64_t, void))(**(void **)(v2 + 184) + 96))(*(void *)(v2 + 184), 1, v57))
  {
    sub_100FF3B10((void **)v2, 1);
    sub_100058DB0(buf, "SettingsModel::fCallWaitingStatus");
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v31 + 96))(v31, buf);
    uint64_t v34 = (uint64_t *)v59;
    if ((v34 & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    CFBooleanRef v38 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "SettingsModel::fCallWaitingStatus";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#N Failed to migrate %s property", buf, 0xCu);
    }
  }
LABEL_52:
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  uint64_t v39 = (std::mutex *)Registry::getServiceMap(v34, *(Registry **)(v2 + 96));
  long long v40 = v39;
  if (v5 < 0)
  {
    uint64_t v41 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v42 = 5381;
    do
    {
      uint64_t v5 = v42;
      unsigned int v43 = *v41++;
      uint64_t v42 = (33 * v42) ^ v43;
    }
    while (v43);
  }
  std::mutex::lock(v39);
  *(void *)long long buf = v5;
  int v44 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
  if (v44)
  {
    uint64_t v46 = v44[3];
    char v45 = (std::__shared_weak_count *)v44[4];
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v40);
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v45);
      char v47 = 0;
      if (!v46) {
        goto LABEL_60;
      }
      goto LABEL_64;
    }
  }
  else
  {
    uint64_t v46 = 0;
  }
  std::mutex::unlock(v40);
  char v45 = 0;
  char v47 = 1;
  if (!v46)
  {
LABEL_60:
    long long v48 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "CSIPersistentPropertiesInterface is not set!", buf, 2u);
    }
    goto LABEL_75;
  }
LABEL_64:
  (*(void (**)(uint64_t))(*(void *)v46 + 112))(v46);
  LOBYTE(v57) = 0;
  sub_100058DB0(buf, "SettingsModel::fAutoAnswer");
  char v49 = (*(uint64_t (**)(uint64_t, uint8_t *, long long *))(*(void *)v46 + 32))(v46, buf, &v57);
  char v50 = v49;
  if (v59 < 0)
  {
    operator delete(*(void **)buf);
    if ((v50 & 1) == 0) {
      goto LABEL_75;
    }
  }
  else if ((v49 & 1) == 0)
  {
    goto LABEL_75;
  }
  char v51 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "SettingsModel::fAutoAnswer";
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Migrating %s property", buf, 0xCu);
  }
  if ((*(unsigned int (**)(void, uint64_t, void))(**(void **)(v2 + 184) + 120))(*(void *)(v2 + 184), 1, v57))
  {
    sub_100FF3FF4(v2, 1);
    sub_100058DB0(buf, "SettingsModel::fAutoAnswer");
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v46 + 96))(v46, buf);
    if (v59 < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    int v52 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "SettingsModel::fAutoAnswer";
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#N Failed to migrate %s property", buf, 0xCu);
    }
  }
LABEL_75:
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  sub_100088C88((uint64_t *)&v55);
  return sub_100046B58((uint64_t *)&v54);
}

void sub_10100472C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_101004810(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7CD38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101004830(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7CD38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t *sub_10100488C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  uint64_t v9 = v5;
  uint64_t v10 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100FF3570(v2, v3, &v9);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10013A778(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1010048FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101004924(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  uint64_t v9 = v5;
  uint64_t v10 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100FF3840(v2, v3, &v9);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10013A778(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_101004994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1010049BC(void ****a1)
{
  uint64_t v1 = a1;
  sub_100FF3B10(**a1, *((unsigned int *)*a1 + 2));
  operator delete();
}

void sub_101004A14()
{
}

void sub_101004A40(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100FF3FF4(**a1, *((unsigned int *)*a1 + 2));
  operator delete();
}

void sub_101004A98()
{
}

void sub_101004AC4(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100FF450C(**a1, *((unsigned int *)*a1 + 2));
  operator delete();
}

void sub_101004B1C()
{
}

void sub_101004B48(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(unsigned int **)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  uint64_t v5 = v3[2];
  uint64_t v6 = *(uint64_t **)(*(void *)v3 + 240);
  if (v6)
  {
    uint64_t v7 = *(uint64_t **)(*(void *)v3 + 240);
    do
    {
      int v8 = *((_DWORD *)v7 + 8);
      if (v8 <= (int)v5)
      {
        if (v8 >= (int)v5)
        {
          uint64_t v10 = sub_1000389F8(v6, v5);
          uint64_t v11 = v10[2];
          *a2 = v10[1];
          a2[1] = v11;
          if (v11) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          }
          return;
        }
        ++v7;
      }
      uint64_t v7 = (uint64_t *)*v7;
    }
    while (v7);
  }
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v5);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    int v12 = 136315138;
    uint64_t v13 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v12, 0xCu);
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_101004C80(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if ((sub_100FF64B4(v2, *((unsigned int *)*a1 + 2)) & 1) == 0)
  {
    uint64_t v3 = *((unsigned int *)v1 + 2);
    v5[0] = off_101A7CDA8;
    v5[1] = v2;
    v5[2] = v3;
    v5[3] = v5;
    sub_100FF7EDC(v2, v3, (uint64_t)v5);
    sub_10003B34C(v5);
  }
  operator delete();
}

void sub_101004D4C(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101004D8C()
{
}

__n128 sub_101004DA0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7CDA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101004DEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CDA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101004E1C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 168))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), 2);
}

uint64_t sub_101004E54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101004E94()
{
}

uint64_t sub_101004EA0(uint64_t a1)
{
  return sub_100FF6B60(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(int **)(*(void *)(a1 + 40) + 16), *(unsigned char **)(*(void *)(a1 + 40) + 24));
}

void sub_101004EB4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 3);
    uint64_t v6 = *(uint64_t **)(v2 + 240);
    do
    {
      int v7 = *((_DWORD *)v6 + 8);
      if (v7 <= (int)v3)
      {
        if (v7 >= (int)v3)
        {
          if (sub_1000389F8(v4, v3)[1])
          {
            uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v10 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
              uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10[1] + 48))(v10[1]);
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v11;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Issuing set CLIR request to %s", buf, 0xCu);
            }
            int v12 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[1] + 160))(v12[1], v3, v5);
          }
          uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v5;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Saving CLIR value %d internally", buf, 8u);
          }
          uint64_t v14 = *(uint64_t **)(v2 + 240);
          if (!v14)
          {
LABEL_21:
            char v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              uint64_t v18 = subscriber::asString();
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v18;
              _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
            }
            goto LABEL_47;
          }
          int v15 = *(uint64_t **)(v2 + 240);
          while (1)
          {
            int v16 = *((_DWORD *)v15 + 8);
            if (v16 <= (int)v3)
            {
              if (v16 >= (int)v3)
              {
                if (!sub_1000389F8(v14, v3)[18])
                {
                  int v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
                  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I CLIR Model was not initialized, initializing it", buf, 2u);
                  }
                  sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
                  operator new();
                }
                switch((int)v5)
                {
                  case 0:
                    uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
                    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Presentation Allowed", buf, 2u);
                    }
                    char v21 = 3;
                    goto LABEL_39;
                  case 1:
                    xpc_object_t v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
                    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      char v21 = 2;
                      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Presentation Restricted", buf, 2u);
                    }
                    else
                    {
                      char v21 = 2;
                    }
                    goto LABEL_39;
                  case 2:
                    xpc_object_t v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Presentation Permanent", buf, 2u);
                    }
                    char v21 = 1;
                    goto LABEL_39;
                  case 3:
                    xpc_object_t v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
                    char v21 = 0;
                    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Presentation Not Provisioned", buf, 2u);
                      char v21 = 0;
                    }
LABEL_39:
                    *(unsigned char *)(sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[18] + 1) = v21;
                    break;
                  default:
                    break;
                }
                uint64_t v25 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[18];
                xpc_object_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
                BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
                if (v25)
                {
                  if (v27)
                  {
                    sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
                    uint64_t v28 = asString();
                    sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
                    uint64_t v29 = asString();
                    *(_DWORD *)long long buf = 136315394;
                    *(void *)&uint8_t buf[4] = v28;
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = v29;
                    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Persisting CLIR user setting with Service Status %s, Provisioned Status %s", buf, 0x16u);
                  }
                  uint64_t v30 = *(void *)(v2 + 184);
                  uint64_t v31 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
                  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v30 + 48))(v30, v3, v31 + 18);
                }
                else if (v27)
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I CLIR Model is invalid", buf, 2u);
                }
                sub_100FF70DC(v2, v3);
LABEL_47:
                *(void *)long long buf = off_101A7CE88;
                *(void *)&uint8_t buf[8] = v2;
                *(void *)&uint8_t buf[16] = v3;
                BOOL v33 = buf;
                (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 112) + 184))(*(void *)(v2 + 112), v3, 0);
                (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 0);
                sub_10003B34C(buf);
LABEL_48:
                operator delete();
              }
              ++v15;
            }
            int v15 = (uint64_t *)*v15;
            if (!v15) {
              goto LABEL_21;
            }
          }
        }
        ++v6;
      }
      uint64_t v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  goto LABEL_48;
}

void sub_101005690(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_1010056E0()
{
}

__n128 sub_1010056F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7CE88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101005740(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CE88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101005770(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 184))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), 0);
}

uint64_t sub_1010057A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010057E8()
{
}

uint64_t sub_1010057F4(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_10100585C()
{
}

__n128 sub_101005870(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7CF08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010058BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CF08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010058EC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 192))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_101005920(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101005960()
{
}

uint64_t sub_10100596C(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = (unsigned int *)a1[1];
  uint64_t v4 = *(uint64_t **)(*a1 + 240);
  uint64_t v5 = *v2;
  if (!v4)
  {
LABEL_7:
    int v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v16 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
    return 0;
  }
  uint64_t v6 = v4;
  while (1)
  {
    int v7 = *((_DWORD *)v6 + 8);
    if ((int)v5 >= v7) {
      break;
    }
LABEL_6:
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      goto LABEL_7;
    }
  }
  if (v7 < (int)v5)
  {
    ++v6;
    goto LABEL_6;
  }
  char v14 = 0;
  if (!sub_1000389F8(v4, v5)[5])
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)a1[1]);
    uint64_t v9 = 0;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return v9;
    }
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Call barring values are not available", buf, 2u);
    return 0;
  }
  uint64_t v11 = sub_1000389F8(*(uint64_t **)(v3 + 240), *(_DWORD *)a1[1]);
  uint64_t v9 = sub_100AB89AC(v11[5], *(_DWORD *)a1[2], *(_DWORD *)a1[3], &v14);
  int v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)a1[1]);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v16) = v9;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Call Barring value availability %d", buf, 8u);
  }
  return v9;
}

uint64_t sub_101005BB0(uint64_t a1)
{
  return sub_10100596C(*(uint64_t **)(a1 + 40));
}

uint64_t *sub_101005BB8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100FF7B18(*(void *)v1, *(unsigned int *)(v1 + 8), *(unsigned int *)(v1 + 40), *(unsigned int *)(v1 + 44));
  sub_101005C20(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_101005C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_101005C20(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_101005C7C()
{
}

__n128 sub_101005C90(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7CFA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101005CE4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7CFA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101005D1C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 112))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24));
}

uint64_t sub_101005D54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101005D94()
{
}

uint64_t sub_101005DA0(uint64_t a1)
{
  return sub_100FF8118(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(unsigned char **)(*(void *)(a1 + 40) + 16), **(_DWORD **)(*(void *)(a1 + 40) + 24), **(_DWORD **)(*(void *)(a1 + 40) + 32));
}

uint64_t *sub_101005DC0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v4 = *(uint64_t **)(*(void *)v1 + 240);
  if (!v4)
  {
LABEL_7:
    int v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v23 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
    goto LABEL_9;
  }
  int v5 = *(unsigned __int8 *)(v1 + 12);
  uint64_t v6 = v1 + 16;
  uint64_t v7 = *(unsigned int *)(v1 + 40);
  uint64_t v8 = *(unsigned int *)(v1 + 44);
  uint64_t v9 = *(uint64_t **)(*(void *)v1 + 240);
  uint64_t v10 = *(unsigned int *)(v1 + 48);
  while (1)
  {
    int v11 = *((_DWORD *)v9 + 8);
    if (v11 <= (int)v3) {
      break;
    }
LABEL_6:
    uint64_t v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_7;
    }
  }
  if (v11 < (int)v3)
  {
    ++v9;
    goto LABEL_6;
  }
  if (!sub_1000389F8(v4, v3)[1]) {
    goto LABEL_18;
  }
  if (sub_100FF6754(v2) && sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[1] != *(void *)(v2 + 152))
  {
    char v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring the request to save Call Barring value because it would trigger CSFB", buf, 2u);
    }
    goto LABEL_18;
  }
  int v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16[1] + 48))(v16[1]);
    *(_DWORD *)long long buf = 136315138;
    uint64_t v23 = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Issuing Set Call Barring request to %s", buf, 0xCu);
  }
  uint64_t v18 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, BOOL, uint64_t))(*(void *)v18[1] + 88))(v18[1], v3, v7, v8, v6, v5 != 0, v10) & 1) == 0)
  {
LABEL_18:
    int v19 = operator new(0x20uLL);
    void *v19 = off_101A7D048;
    v19[1] = v2;
    *((_DWORD *)v19 + 4) = v3;
    *((_DWORD *)v19 + 5) = v8;
    *((_DWORD *)v19 + 6) = v7;
    xpc_object_t v24 = v19;
    (*(void (**)(void, uint64_t, uint64_t, void, uint64_t))(**(void **)(v2 + 112) + 120))(*(void *)(v2 + 112), v3, v8, 0, v7);
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 1);
    sub_10003B34C(buf);
  }
LABEL_9:
  sub_101006174(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_101006148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_101006174(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_1010061D0()
{
}

__n128 sub_1010061E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D048;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101006238(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D048;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101006270(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                           + 120))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), 0, *(unsigned int *)(a1 + 24));
}

uint64_t sub_1010062AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010062EC()
{
}

uint64_t *sub_1010062F8(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v17 = a1;
  uint64_t v18 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = v1[2];
  uint64_t v4 = *(uint64_t **)(*(void *)v1 + 240);
  if (!v4)
  {
LABEL_7:
    int v11 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_9;
  }
  uint64_t v5 = v1[3];
  uint64_t v6 = v1 + 4;
  uint64_t v7 = v1 + 10;
  uint64_t v8 = v1 + 16;
  uint64_t v9 = *(uint64_t **)(*(void *)v1 + 240);
  while (1)
  {
    int v10 = *((_DWORD *)v9 + 8);
    if (v10 <= (int)v3) {
      break;
    }
LABEL_6:
    uint64_t v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_7;
    }
  }
  if (v10 < (int)v3)
  {
    ++v9;
    goto LABEL_6;
  }
  if (!sub_1000389F8(v4, v3)[1]) {
    goto LABEL_14;
  }
  uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    char v14 = sub_1000389F8(v2[30], v3);
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14[1] + 48))(v14[1]);
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Issuing Set Call Barring request to %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v16 = sub_1000389F8(v2[30], v3);
  if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned int *, unsigned int *, unsigned int *))(*(void *)v16[1] + 96))(v16[1], v3, v5, v6, v7, v8) & 1) == 0)
  {
LABEL_14:
    *(void *)&long long buf = off_101A7D0C8;
    *((void *)&buf + 1) = v2;
    uint64_t v20 = v3 | (v5 << 32);
    p_long long buf = &buf;
    sub_1010066E4((uint64_t)&buf);
    (*(void (**)(void *, uint64_t, uint64_t))(*v2[48] + 40))(v2[48], v3, 1);
    sub_10003B34C(&buf);
  }
LABEL_9:
  sub_1010065D8((uint64_t *)&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_1010065AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_1010065D8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 87) < 0) {
      operator delete(*(void **)(v1 + 64));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

void sub_101006654()
{
}

__n128 sub_101006668(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D0C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010066B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D0C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010066E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 112);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int *)(a1 + 20);
  if (v4 > 8) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = asc_1015AD426[v4];
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 152))(v2, v3, v5);
}

uint64_t sub_101006738(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101006778()
{
}

void sub_101006784(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if ((sub_100FF88A8(v2, *((unsigned int *)*a1 + 2), *((unsigned int *)*a1 + 3)) & 1) == 0)
  {
    uint64_t v3 = v1[1];
    v5[0] = off_101A7D148;
    v5[1] = v2;
    v5[2] = v3;
    v5[3] = v5;
    sub_100FF7EDC(v2, v3, (uint64_t)v5);
    sub_10003B34C(v5);
  }
  operator delete();
}

void sub_101006850(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101006890()
{
}

__n128 sub_1010068A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D148;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010068F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D148;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101006920(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 56))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

uint64_t sub_101006954(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101006994()
{
}

void sub_1010069A0(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = *(uint64_t **)(v2 + 240);
  if (!v4)
  {
LABEL_7:
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_9;
  }
  int v5 = *((unsigned __int8 *)v1 + 12);
  uint64_t v6 = *(uint64_t **)(v2 + 240);
  uint64_t v7 = *((unsigned int *)v1 + 4);
  uint64_t v8 = *((unsigned int *)v1 + 5);
  while (1)
  {
    int v9 = *((_DWORD *)v6 + 8);
    if (v9 <= (int)v3)
    {
      if (v9 >= (int)v3)
      {
        if (sub_1000389F8(v4, v3)[1])
        {
          if (sub_100FF6754(v2) && sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[1] != *(void *)(v2 + 152))
          {
            uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              char v14 = "#I VoLTE call is active, ignoring the request to save Call Waiting value because it would trigger CSFB";
              goto LABEL_34;
            }
            goto LABEL_9;
          }
          unint64_t v15 = v3 | ((unint64_t)(v5 != 0) << 32);
          unint64_t v16 = v7 | (v8 << 32);
          unint64_t v17 = *(void *)(v2 + 360);
          if (v17 > 1)
          {
            uint64_t v41 = (unint64_t *)(*(void *)(*(void *)(v2 + 328)
                                                 + (((v17 + *(void *)(v2 + 352) - 1) >> 5) & 0x7FFFFFFFFFFFFF8))
                                     + 16 * (v17 + *(unsigned char *)(v2 + 352) - 1));
            unint64_t *v41 = v15;
            v41[1] = v16;
            uint64_t v42 = *(void *)(v2 + 360);
          }
          else
          {
            unint64_t v133 = v15;
            uint64_t v18 = (char **)(v2 + 328);
            int v19 = *(char **)(v2 + 336);
            uint64_t v20 = *(char **)(v2 + 328);
            uint64_t v21 = v19 - v20;
            if (v19 == v20) {
              uint64_t v22 = 0;
            }
            else {
              uint64_t v22 = 32 * (v19 - v20) - 1;
            }
            unint64_t v23 = *(void *)(v2 + 352);
            unint64_t v24 = v23 + v17;
            if (v22 == v24)
            {
              if (v23 < 0x100)
              {
                unint64_t v132 = v16;
                uint64_t v43 = v21 >> 3;
                int v44 = *(char **)(v2 + 344);
                char v45 = *(char **)(v2 + 320);
                if (v21 >> 3 >= (unint64_t)((v44 - v45) >> 3))
                {
                  if (v44 == v45) {
                    unint64_t v48 = 1;
                  }
                  else {
                    unint64_t v48 = (v44 - v45) >> 2;
                  }
                  char v49 = (char *)sub_100048350(v48);
                  uint64_t v51 = v50;
                  int v52 = operator new(0x1000uLL);
                  BOOL v53 = &v49[8 * v43];
                  uint64_t v54 = v51;
                  uint64_t v55 = &v49[8 * v51];
                  if (v43 == v54)
                  {
                    uint64_t v56 = 8 * v43;
                    if (v21 < 1)
                    {
                      int v72 = v52;
                      uint64_t v73 = v56 >> 2;
                      if (v19 == v20) {
                        unint64_t v74 = 1;
                      }
                      else {
                        unint64_t v74 = v73;
                      }
                      int v75 = (char *)sub_100048350(v74);
                      BOOL v53 = &v75[8 * (v74 >> 2)];
                      uint64_t v55 = &v75[8 * v76];
                      if (v49) {
                        operator delete(v49);
                      }
                      char v49 = v75;
                      int v52 = v72;
                    }
                    else
                    {
                      uint64_t v57 = v56 >> 3;
                      if (v57 >= -1) {
                        unint64_t v58 = v57 + 1;
                      }
                      else {
                        unint64_t v58 = v57 + 2;
                      }
                      v53 -= 8 * (v58 >> 1);
                    }
                  }
                  *(void *)BOOL v53 = v52;
                  int v77 = v53 + 8;
                  BOOL v78 = *(char **)(v2 + 328);
                  int v79 = *(char **)(v2 + 336);
                  while (v79 != v78)
                  {
                    if (v53 == v49)
                    {
                      if (v77 >= v55)
                      {
                        if (v55 == v49) {
                          unint64_t v84 = 1;
                        }
                        else {
                          unint64_t v84 = (v55 - v49) >> 2;
                        }
                        uint64_t v85 = (char *)sub_100048350(v84);
                        uint64_t v87 = v85;
                        BOOL v53 = &v85[(2 * v84 + 6) & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v88 = v77 - v49;
                        BOOL v59 = v77 == v49;
                        int v77 = v53;
                        if (!v59)
                        {
                          int v77 = &v53[v88 & 0xFFFFFFFFFFFFFFF8];
                          uint64_t v89 = 8 * (v88 >> 3);
                          int v90 = v53;
                          int v91 = (uint64_t *)v49;
                          do
                          {
                            uint64_t v92 = *v91++;
                            *(void *)int v90 = v92;
                            v90 += 8;
                            v89 -= 8;
                          }
                          while (v89);
                        }
                        uint64_t v55 = &v85[8 * v86];
                        if (v49) {
                          operator delete(v49);
                        }
                        char v49 = v87;
                      }
                      else
                      {
                        uint64_t v80 = (v55 - v77) >> 3;
                        if (v80 >= -1) {
                          uint64_t v81 = v80 + 1;
                        }
                        else {
                          uint64_t v81 = v80 + 2;
                        }
                        uint64_t v82 = v81 >> 1;
                        BOOL v53 = &v49[8 * (v81 >> 1)];
                        long long v83 = v49;
                        if (v77 != v49)
                        {
                          memmove(v53, v49, v77 - v49);
                          long long v83 = v77;
                        }
                        int v77 = &v83[8 * v82];
                      }
                    }
                    uint64_t v93 = *((void *)v79 - 1);
                    v79 -= 8;
                    *((void *)v53 - 1) = v93;
                    v53 -= 8;
                    BOOL v78 = *v18;
                  }
                  int v94 = *(void **)(v2 + 320);
                  *(void *)(v2 + 320) = v49;
                  *(void *)(v2 + 328) = v53;
                  *(void *)(v2 + 336) = v77;
                  *(void *)(v2 + 344) = v55;
                  unint64_t v16 = v132;
                  unint64_t v40 = v133;
                  if (v94) {
                    operator delete(v94);
                  }
                }
                else
                {
                  uint64_t v46 = operator new(0x1000uLL);
                  char v47 = v46;
                  if (v44 == v19)
                  {
                    if (v20 == v45)
                    {
                      if (v19 == v20) {
                        unint64_t v95 = 1;
                      }
                      else {
                        unint64_t v95 = (v44 - v20) >> 2;
                      }
                      long long v96 = (char *)sub_100048350(v95);
                      uint64_t v20 = &v96[(2 * v95 + 6) & 0xFFFFFFFFFFFFFFF8];
                      long long v98 = *(uint64_t **)(v2 + 328);
                      CFBooleanRef v99 = v20;
                      uint64_t v100 = *(void *)(v2 + 336) - (void)v98;
                      unint64_t v16 = v132;
                      if (v100)
                      {
                        CFBooleanRef v99 = &v20[v100 & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v101 = 8 * (v100 >> 3);
                        long long v102 = v20;
                        do
                        {
                          uint64_t v103 = *v98++;
                          *(void *)long long v102 = v103;
                          v102 += 8;
                          v101 -= 8;
                        }
                        while (v101);
                      }
                      long long v104 = *(void **)(v2 + 320);
                      *(void *)(v2 + 320) = v96;
                      *(void *)(v2 + 328) = v20;
                      *(void *)(v2 + 336) = v99;
                      *(void *)(v2 + 344) = &v96[8 * v97];
                      if (v104)
                      {
                        operator delete(v104);
                        uint64_t v20 = *v18;
                      }
                    }
                    else
                    {
                      unint64_t v16 = v132;
                    }
                    *((void *)v20 - 1) = v47;
                    long long v105 = *(char **)(v2 + 328);
                    char v106 = *(char **)(v2 + 336);
                    *(void *)(v2 + 328) = v105 - 8;
                    uint64_t v107 = *((void *)v105 - 1);
                    *(void *)(v2 + 328) = v105;
                    if (v106 == *(char **)(v2 + 344))
                    {
                      unint64_t v108 = *(void *)(v2 + 320);
                      uint64_t v109 = (uint64_t)&v105[-v108];
                      if ((unint64_t)v105 <= v108)
                      {
                        uint64_t v117 = (uint64_t)&v106[-v108];
                        BOOL v59 = v117 == 0;
                        uint64_t v118 = v117 >> 2;
                        if (v59) {
                          unint64_t v119 = 1;
                        }
                        else {
                          unint64_t v119 = v118;
                        }
                        __int16 v120 = (char *)sub_100048350(v119);
                        __int16 v122 = &v120[8 * (v119 >> 2)];
                        int v123 = *(uint64_t **)(v2 + 328);
                        char v106 = v122;
                        uint64_t v124 = *(void *)(v2 + 336) - (void)v123;
                        unint64_t v16 = v132;
                        if (v124)
                        {
                          char v106 = &v122[v124 & 0xFFFFFFFFFFFFFFF8];
                          uint64_t v125 = 8 * (v124 >> 3);
                          __int16 v126 = &v120[8 * (v119 >> 2)];
                          do
                          {
                            uint64_t v127 = *v123++;
                            *(void *)__int16 v126 = v127;
                            v126 += 8;
                            v125 -= 8;
                          }
                          while (v125);
                        }
                        __int16 v128 = *(void **)(v2 + 320);
                        *(void *)(v2 + 320) = v120;
                        *(void *)(v2 + 328) = v122;
                        *(void *)(v2 + 336) = v106;
                        *(void *)(v2 + 344) = &v120[8 * v121];
                        if (v128)
                        {
                          operator delete(v128);
                          char v106 = *(char **)(v2 + 336);
                        }
                      }
                      else
                      {
                        uint64_t v110 = v109 >> 3;
                        BOOL v32 = v109 >> 3 < -1;
                        uint64_t v111 = (v109 >> 3) + 2;
                        if (v32) {
                          uint64_t v112 = v111;
                        }
                        else {
                          uint64_t v112 = v110 + 1;
                        }
                        uint64_t v113 = -(v112 >> 1);
                        uint64_t v114 = v112 >> 1;
                        int v115 = &v105[-8 * v114];
                        int64_t v116 = v106 - v105;
                        if (v106 != v105)
                        {
                          memmove(&v105[-8 * v114], v105, v106 - v105);
                          long long v105 = *v18;
                        }
                        char v106 = &v115[v116];
                        *(void *)(v2 + 328) = &v105[8 * v113];
                        *(void *)(v2 + 336) = &v115[v116];
                        unint64_t v16 = v132;
                      }
                    }
                    *(void *)char v106 = v107;
                    *(void *)(v2 + 336) += 8;
                    unint64_t v40 = v133;
                  }
                  else
                  {
                    *(void *)int v19 = v46;
                    *(void *)(v2 + 336) += 8;
                    unint64_t v16 = v132;
                    unint64_t v40 = v133;
                  }
                }
              }
              else
              {
                *(void *)(v2 + 352) = v23 - 256;
                uint64_t v27 = *(void *)v20;
                uint64_t v25 = v20 + 8;
                uint64_t v26 = v27;
                *(void *)(v2 + 328) = v25;
                if (v19 != *(char **)(v2 + 344)) {
                  goto LABEL_30;
                }
                unint64_t v28 = v16;
                unint64_t v29 = *(void *)(v2 + 320);
                uint64_t v30 = (uint64_t)&v25[-v29];
                if ((unint64_t)v25 <= v29)
                {
                  uint64_t v60 = (uint64_t)&v19[-v29];
                  BOOL v59 = v60 == 0;
                  uint64_t v61 = v60 >> 2;
                  if (v59) {
                    unint64_t v62 = 1;
                  }
                  else {
                    unint64_t v62 = v61;
                  }
                  int v63 = (char *)sub_100048350(v62);
                  BOOL v65 = &v63[8 * (v62 >> 2)];
                  int v66 = *(uint64_t **)(v2 + 328);
                  int v19 = v65;
                  uint64_t v67 = *(void *)(v2 + 336) - (void)v66;
                  unint64_t v40 = v133;
                  if (v67)
                  {
                    int v19 = &v65[v67 & 0xFFFFFFFFFFFFFFF8];
                    uint64_t v68 = 8 * (v67 >> 3);
                    int v69 = v65;
                    do
                    {
                      uint64_t v70 = *v66++;
                      *(void *)int v69 = v70;
                      v69 += 8;
                      v68 -= 8;
                    }
                    while (v68);
                  }
                  int v71 = *(void **)(v2 + 320);
                  *(void *)(v2 + 320) = v63;
                  *(void *)(v2 + 328) = v65;
                  *(void *)(v2 + 336) = v19;
                  *(void *)(v2 + 344) = &v63[8 * v64];
                  if (v71)
                  {
                    operator delete(v71);
                    int v19 = *(char **)(v2 + 336);
                  }
                }
                else
                {
                  uint64_t v31 = v30 >> 3;
                  BOOL v32 = v30 >> 3 < -1;
                  uint64_t v33 = (v30 >> 3) + 2;
                  if (v32) {
                    uint64_t v34 = v33;
                  }
                  else {
                    uint64_t v34 = v31 + 1;
                  }
                  uint64_t v35 = -(v34 >> 1);
                  uint64_t v36 = v34 >> 1;
                  CFBooleanRef v37 = &v25[-8 * v36];
                  int64_t v38 = v19 - v25;
                  if (v19 != v25)
                  {
                    memmove(&v25[-8 * v36], v25, v19 - v25);
                    int v19 = *v18;
                  }
                  uint64_t v39 = &v19[8 * v35];
                  int v19 = &v37[v38];
                  *(void *)(v2 + 328) = v39;
                  *(void *)(v2 + 336) = &v37[v38];
                  unint64_t v16 = v28;
LABEL_30:
                  unint64_t v40 = v133;
                }
                *(void *)int v19 = v26;
                *(void *)(v2 + 336) += 8;
              }
              uint64_t v20 = *(char **)(v2 + 328);
              unint64_t v24 = *(void *)(v2 + 360) + *(void *)(v2 + 352);
            }
            else
            {
              unint64_t v40 = v15;
            }
            int v129 = (unint64_t *)(*(void *)&v20[(v24 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v24);
            *int v129 = v40;
            v129[1] = v16;
            uint64_t v42 = *(void *)(v2 + 360) + 1;
            *(void *)(v2 + 360) = v42;
          }
          if (v42 == 1)
          {
            uint64_t v130 = *(void *)(v2 + 368);
            if (v130)
            {
              int v131 = (void *)(*(void *)(*(void *)(v2 + 328) + ((*(void *)(v2 + 352) >> 5) & 0x7FFFFFFFFFFFFF8))
                              + 16 * *(void *)(v2 + 352));
              (*(void (**)(uint64_t, void, void))(*(void *)v130 + 16))(v130, *v131, v131[1]);
            }
          }
        }
        else
        {
          uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            char v14 = "#I Save call waiting failed, no command driver";
LABEL_34:
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&buf, 2u);
          }
LABEL_9:
          uint64_t v11 = *((unsigned int *)v1 + 2);
          unint64_t v12 = v11 | ((unint64_t)*((unsigned int *)v1 + 4) << 32);
          *(void *)&long long buf = off_101A7D1C8;
          *((void *)&buf + 1) = v2;
          unint64_t v135 = v12;
          p_long long buf = &buf;
          sub_100FF7EDC(v2, v11, (uint64_t)&buf);
          sub_10003B34C(&buf);
        }
        operator delete();
      }
      ++v6;
    }
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      goto LABEL_7;
    }
  }
}

void sub_1010071C8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16)
{
  operator delete(v17);
  if (v16) {
    operator delete(v16);
  }
  operator delete();
}

void sub_101007230()
{
}

__n128 sub_101007244(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D1C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101007290(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D1C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010072C0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 64))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), 0);
}

uint64_t sub_1010072F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101007338()
{
}

BOOL sub_101007344(uint64_t a1)
{
  return sub_100FF8E10(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(unsigned char **)(*(void *)(a1 + 40) + 16), **(_DWORD **)(*(void *)(a1 + 40) + 24));
}

void sub_10100735C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *(uint64_t **)(v1 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)*a1 + 3);
    do
    {
      int v5 = *((_DWORD *)v3 + 8);
      if (v5 <= (int)v2)
      {
        if (v5 >= (int)v2)
        {
          uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
          BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
          if (v4)
          {
            if (v8)
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Handling Calling Line Presentation APIs", (uint8_t *)&buf, 2u);
            }
            if (!sub_1000389F8(*(uint64_t **)(v1 + 240), v2)[1]) {
              goto LABEL_24;
            }
            if (sub_100FF6754(v1)
              && sub_1000389F8(*(uint64_t **)(v1 + 240), v2)[1] != *(void *)(v1 + 152))
            {
              uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
              if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                int v9 = "#I VoLTE call is active, ignoring request to fetch CLIP value because it would trigger CSFB";
                goto LABEL_20;
              }
              goto LABEL_24;
            }
            int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v11 = sub_1000389F8(*(uint64_t **)(v1 + 240), v2);
              uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11[1] + 48))(v11[1]);
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v12;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Issuing request to %s to fetch the CLIP Fetch", (uint8_t *)&buf, 0xCu);
            }
            uint64_t v13 = sub_1000389F8(*(uint64_t **)(v1 + 240), v2);
            if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13[1] + 128))(v13[1], v2) & 1) == 0) {
              goto LABEL_24;
            }
          }
          else
          {
            if (v8)
            {
              LOWORD(buf) = 0;
              int v9 = "#I Not handling Connected Line Presentation APIs";
LABEL_20:
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&buf, 2u);
            }
LABEL_24:
            *(void *)&long long buf = off_101A7D268;
            *((void *)&buf + 1) = v1;
            uint64_t v15 = v2 | (v4 << 32);
            p_long long buf = &buf;
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 112) + 208))(*(void *)(v1 + 112), v2, v4);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, 1);
            sub_10003B34C(&buf);
          }
LABEL_9:
          operator delete();
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_101007744(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101007784()
{
}

__n128 sub_101007798(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D268;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010077E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D268;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101007814(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 208))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

uint64_t sub_101007848(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101007888()
{
}

void sub_101007894(uint64_t **a1)
{
  uint64_t v1 = (unsigned int *)*a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = *(uint64_t **)(v2 + 240);
  if (!v4)
  {
LABEL_8:
    BOOL v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_10;
  }
  unsigned int v6 = v1[3];
  uint64_t v5 = v1[4];
  while (1)
  {
    int v7 = *((_DWORD *)v4 + 8);
    if (v7 <= (int)v3)
    {
      if (v7 >= (int)v3)
      {
        int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
        if (v6)
        {
          if (v11)
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Handling Calling Line Presentation APIs", (uint8_t *)&buf, 2u);
          }
          if (!sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[1]) {
            goto LABEL_10;
          }
          if (sub_100FF6754(v2) && sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[1] != *(void *)(v2 + 152))
          {
            uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              uint64_t v13 = "#I VoLTE call is active, ignoring request to save CLIP value because it would trigger CSFB";
              char v14 = v12;
              goto LABEL_22;
            }
            goto LABEL_10;
          }
          uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            unint64_t v16 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
            uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16[1] + 48))(v16[1]);
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v17;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Issuing request to %s to save CLIP", (uint8_t *)&buf, 0xCu);
          }
          uint64_t v18 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
          if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[1] + 152))(v18[1], v3, v5) & 1) == 0) {
            goto LABEL_10;
          }
        }
        else
        {
          if (v11)
          {
            LOWORD(buf) = 0;
            uint64_t v13 = "#I Not handling Connected Line Presentation APIs";
            char v14 = v10;
LABEL_22:
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&buf, 2u);
          }
LABEL_10:
          uint64_t v9 = v1[2];
          *(void *)&long long buf = off_101A7D2E8;
          *((void *)&buf + 1) = v2;
          uint64_t v20 = v9;
          p_long long buf = &buf;
          sub_100FF7EDC(v2, v9, (uint64_t)&buf);
          sub_10003B34C(&buf);
        }
        operator delete();
      }
      ++v4;
    }
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      goto LABEL_8;
    }
  }
}

void sub_101007C34(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101007C74()
{
}

__n128 sub_101007C88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D2E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101007CD4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D2E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101007D04(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 248))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_101007D38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101007D78()
{
}

BOOL sub_101007D84(uint64_t a1)
{
  return sub_100FF946C(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(int **)(*(void *)(a1 + 40) + 16), **(_DWORD **)(*(void *)(a1 + 40) + 24));
}

void sub_101007D9C(uint64_t **a1)
{
  uint64_t v12 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *(uint64_t **)(v1 + 240);
  if (v3)
  {
    uint64_t v4 = *(uint64_t **)(v1 + 240);
    do
    {
      int v5 = *((_DWORD *)v4 + 8);
      if (v5 <= (int)v2)
      {
        if (v5 >= (int)v2)
        {
          if (!sub_1000389F8(v3, v2)[1]) {
            goto LABEL_18;
          }
          if (sub_100FF6754(v1) && sub_1000389F8(*(uint64_t **)(v1 + 240), v2)[1] != *(void *)(v1 + 152))
          {
            int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring request to fetch COLR value because it would trigger CSFB", (uint8_t *)&buf, 2u);
            }
            goto LABEL_18;
          }
          BOOL v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v9 = sub_1000389F8(*(uint64_t **)(v1 + 240), v2);
            uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9[1] + 48))(v9[1]);
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v10;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Issuing request to %s to fetch the COLR Fetch", (uint8_t *)&buf, 0xCu);
          }
          BOOL v11 = sub_1000389F8(*(uint64_t **)(v1 + 240), v2);
          if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11[1] + 136))(v11[1], v2) & 1) == 0)
          {
LABEL_18:
            *(void *)&long long buf = off_101A7D388;
            *((void *)&buf + 1) = v1;
            uint64_t v14 = v2;
            p_long long buf = &buf;
            (*(void (**)(void, uint64_t))(**(void **)(v1 + 112) + 216))(*(void *)(v1 + 112), v2);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, 1);
            sub_10003B34C(&buf);
          }
LABEL_9:
          operator delete();
        }
        ++v4;
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  unsigned int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_1010080E8(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101008128()
{
}

__n128 sub_10100813C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D388;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101008188(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D388;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010081B8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 216))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_1010081EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100822C()
{
}

BOOL sub_101008238(uint64_t a1)
{
  return sub_100FF9980(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(int **)(*(void *)(a1 + 40) + 16));
}

void sub_10100824C(uint64_t **a1)
{
  uint64_t v2 = **a1;
  uint64_t v1 = (*a1)[1];
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    int v119 = *((_DWORD *)*a1 + 4);
    do
    {
      int v4 = *((_DWORD *)v3 + 8);
      if (v4 <= (int)v1)
      {
        if (v4 >= (int)v1)
        {
          unint64_t v6 = *(void *)(v2 + 296);
          if (v6 <= 5)
          {
            uint64_t v118 = (char **)(v2 + 264);
            int v7 = *(char **)(v2 + 272);
            BOOL v8 = *(char **)(v2 + 264);
            unint64_t v9 = (v7 - v8) >> 3;
            if (v7 == v8) {
              uint64_t v10 = 0;
            }
            else {
              uint64_t v10 = 341 * v9 - 1;
            }
            unint64_t v11 = *(void *)(v2 + 288);
            unint64_t v12 = v11 + v6;
            if (v10 == v12)
            {
              if (v11 >= 0x155)
              {
                *(void *)(v2 + 288) = v11 - 341;
                uint64_t v15 = *(void *)v8;
                uint64_t v13 = v8 + 8;
                uint64_t v14 = v15;
                *(void *)(v2 + 264) = v13;
                if (v7 == *(char **)(v2 + 280))
                {
                  unint64_t v16 = *(void *)(v2 + 256);
                  uint64_t v17 = (uint64_t)&v13[-v16];
                  if ((unint64_t)v13 <= v16)
                  {
                    uint64_t v43 = (uint64_t)&v7[-v16];
                    BOOL v42 = v43 == 0;
                    uint64_t v44 = v43 >> 2;
                    if (v42) {
                      unint64_t v45 = 1;
                    }
                    else {
                      unint64_t v45 = v44;
                    }
                    uint64_t v46 = (char *)sub_100048350(v45);
                    unint64_t v48 = &v46[8 * (v45 >> 2)];
                    char v49 = *(uint64_t **)(v2 + 264);
                    int v7 = v48;
                    uint64_t v50 = *(void *)(v2 + 272) - (void)v49;
                    if (v50)
                    {
                      int v7 = &v48[v50 & 0xFFFFFFFFFFFFFFF8];
                      uint64_t v51 = 8 * (v50 >> 3);
                      int v52 = &v46[8 * (v45 >> 2)];
                      do
                      {
                        uint64_t v53 = *v49++;
                        *(void *)int v52 = v53;
                        v52 += 8;
                        v51 -= 8;
                      }
                      while (v51);
                    }
                    uint64_t v54 = *(void **)(v2 + 256);
                    *(void *)(v2 + 256) = v46;
                    *(void *)(v2 + 264) = v48;
                    *(void *)(v2 + 272) = v7;
                    *(void *)(v2 + 280) = &v46[8 * v47];
                    if (v54)
                    {
                      operator delete(v54);
                      int v7 = *(char **)(v2 + 272);
                    }
                  }
                  else
                  {
                    uint64_t v18 = v17 >> 3;
                    BOOL v19 = v17 >> 3 < -1;
                    uint64_t v20 = (v17 >> 3) + 2;
                    if (v19) {
                      uint64_t v21 = v20;
                    }
                    else {
                      uint64_t v21 = v18 + 1;
                    }
                    uint64_t v22 = -(v21 >> 1);
                    uint64_t v23 = v21 >> 1;
                    unint64_t v24 = &v13[-8 * v23];
                    int64_t v25 = v7 - v13;
                    if (v7 != v13)
                    {
                      memmove(&v13[-8 * v23], v13, v7 - v13);
                      int v7 = *v118;
                    }
                    uint64_t v26 = &v7[8 * v22];
                    int v7 = &v24[v25];
                    *(void *)(v2 + 264) = v26;
                    *(void *)(v2 + 272) = &v24[v25];
                  }
                }
                *(void *)int v7 = v14;
                goto LABEL_45;
              }
              uint64_t v27 = *(char **)(v2 + 280);
              unint64_t v28 = *(char **)(v2 + 256);
              if (v9 >= (v27 - v28) >> 3)
              {
                if (v27 == v28) {
                  unint64_t v31 = 1;
                }
                else {
                  unint64_t v31 = (v27 - v28) >> 2;
                }
                BOOL v32 = (char *)sub_100048350(v31);
                uint64_t v34 = v33;
                uint64_t v35 = operator new(0xFFCuLL);
                uint64_t v36 = &v32[8 * v9];
                uint64_t v37 = v34;
                int64_t v38 = &v32[8 * v34];
                if (v9 == v37)
                {
                  uint64_t v39 = 8 * v9;
                  if (v7 - v8 < 1)
                  {
                    long long v83 = v35;
                    uint64_t v84 = v39 >> 2;
                    if (v7 == v8) {
                      unint64_t v85 = 1;
                    }
                    else {
                      unint64_t v85 = v84;
                    }
                    uint64_t v86 = (char *)sub_100048350(v85);
                    uint64_t v36 = &v86[8 * (v85 >> 2)];
                    int64_t v38 = &v86[8 * v87];
                    if (v32) {
                      operator delete(v32);
                    }
                    BOOL v32 = v86;
                    uint64_t v35 = v83;
                  }
                  else
                  {
                    uint64_t v40 = v39 >> 3;
                    if (v40 >= -1) {
                      unint64_t v41 = v40 + 1;
                    }
                    else {
                      unint64_t v41 = v40 + 2;
                    }
                    v36 -= 8 * (v41 >> 1);
                  }
                }
                *(void *)uint64_t v36 = v35;
                uint64_t v88 = v36 + 8;
                uint64_t v89 = *(void *)(v2 + 272);
                for (uint64_t i = (void *)(v2 + 264); v89 != *i; v36 -= 8)
                {
                  if (v36 == v32)
                  {
                    if (v88 >= v38)
                    {
                      if (v38 == v32) {
                        unint64_t v95 = 1;
                      }
                      else {
                        unint64_t v95 = (v38 - v32) >> 2;
                      }
                      long long v96 = (char *)sub_100048350(v95);
                      long long v98 = v96;
                      uint64_t v36 = &v96[(2 * v95 + 6) & 0xFFFFFFFFFFFFFFF8];
                      uint64_t v99 = v88 - v32;
                      BOOL v42 = v88 == v32;
                      uint64_t v88 = v36;
                      if (!v42)
                      {
                        uint64_t v88 = &v36[v99 & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v100 = 8 * (v99 >> 3);
                        uint64_t v101 = v36;
                        long long v102 = (uint64_t *)v32;
                        do
                        {
                          uint64_t v103 = *v102++;
                          *(void *)uint64_t v101 = v103;
                          v101 += 8;
                          v100 -= 8;
                        }
                        while (v100);
                      }
                      int64_t v38 = &v96[8 * v97];
                      if (v32) {
                        operator delete(v32);
                      }
                      BOOL v32 = v98;
                    }
                    else
                    {
                      uint64_t v91 = (v38 - v88) >> 3;
                      if (v91 >= -1) {
                        uint64_t v92 = v91 + 1;
                      }
                      else {
                        uint64_t v92 = v91 + 2;
                      }
                      uint64_t v93 = v92 >> 1;
                      uint64_t v36 = &v32[8 * (v92 >> 1)];
                      int v94 = v32;
                      if (v88 != v32)
                      {
                        memmove(v36, v32, v88 - v32);
                        int v94 = v88;
                      }
                      uint64_t v88 = &v94[8 * v93];
                    }
                    uint64_t i = (void *)(v2 + 264);
                  }
                  uint64_t v104 = *(void *)(v89 - 8);
                  v89 -= 8;
                  *((void *)v36 - 1) = v104;
                }
                long long v105 = *(void **)(v2 + 256);
                *(void *)(v2 + 256) = v32;
                *(void *)(v2 + 264) = v36;
                *(void *)(v2 + 272) = v88;
                *(void *)(v2 + 280) = v38;
                if (v105) {
                  operator delete(v105);
                }
              }
              else
              {
                unint64_t v29 = operator new(0xFFCuLL);
                uint64_t v30 = v29;
                if (v27 == v7)
                {
                  if (v8 == v28)
                  {
                    if (v7 == v8) {
                      unint64_t v61 = 1;
                    }
                    else {
                      unint64_t v61 = (v27 - v8) >> 2;
                    }
                    unint64_t v62 = (char *)sub_100048350(v61);
                    BOOL v8 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
                    uint64_t v64 = *(uint64_t **)(v2 + 264);
                    BOOL v65 = v8;
                    uint64_t v66 = *(void *)(v2 + 272) - (void)v64;
                    if (v66)
                    {
                      BOOL v65 = &v8[v66 & 0xFFFFFFFFFFFFFFF8];
                      uint64_t v67 = 8 * (v66 >> 3);
                      uint64_t v68 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
                      do
                      {
                        uint64_t v69 = *v64++;
                        *(void *)uint64_t v68 = v69;
                        v68 += 8;
                        v67 -= 8;
                      }
                      while (v67);
                    }
                    uint64_t v70 = *(void **)(v2 + 256);
                    *(void *)(v2 + 256) = v62;
                    *(void *)(v2 + 264) = v8;
                    *(void *)(v2 + 272) = v65;
                    *(void *)(v2 + 280) = &v62[8 * v63];
                    if (v70)
                    {
                      operator delete(v70);
                      BOOL v8 = *v118;
                    }
                  }
                  *((void *)v8 - 1) = v30;
                  int v71 = *(char **)(v2 + 264);
                  int v72 = *(char **)(v2 + 272);
                  *(void *)(v2 + 264) = v71 - 8;
                  uint64_t v73 = *((void *)v71 - 1);
                  *(void *)(v2 + 264) = v71;
                  if (v72 == *(char **)(v2 + 280))
                  {
                    unint64_t v74 = *(void *)(v2 + 256);
                    uint64_t v75 = (uint64_t)&v71[-v74];
                    if ((unint64_t)v71 <= v74)
                    {
                      uint64_t v106 = (uint64_t)&v72[-v74];
                      BOOL v42 = v106 == 0;
                      uint64_t v107 = v106 >> 2;
                      if (v42) {
                        unint64_t v108 = 1;
                      }
                      else {
                        unint64_t v108 = v107;
                      }
                      uint64_t v109 = (char *)sub_100048350(v108);
                      uint64_t v111 = &v109[8 * (v108 >> 2)];
                      uint64_t v112 = *(uint64_t **)(v2 + 264);
                      int v72 = v111;
                      uint64_t v113 = *(void *)(v2 + 272) - (void)v112;
                      if (v113)
                      {
                        int v72 = &v111[v113 & 0xFFFFFFFFFFFFFFF8];
                        uint64_t v114 = 8 * (v113 >> 3);
                        int v115 = &v109[8 * (v108 >> 2)];
                        do
                        {
                          uint64_t v116 = *v112++;
                          *(void *)int v115 = v116;
                          v115 += 8;
                          v114 -= 8;
                        }
                        while (v114);
                      }
                      uint64_t v117 = *(void **)(v2 + 256);
                      *(void *)(v2 + 256) = v109;
                      *(void *)(v2 + 264) = v111;
                      *(void *)(v2 + 272) = v72;
                      *(void *)(v2 + 280) = &v109[8 * v110];
                      if (v117)
                      {
                        operator delete(v117);
                        int v72 = *(char **)(v2 + 272);
                      }
                    }
                    else
                    {
                      uint64_t v76 = v75 >> 3;
                      BOOL v19 = v75 >> 3 < -1;
                      uint64_t v77 = (v75 >> 3) + 2;
                      if (v19) {
                        uint64_t v78 = v77;
                      }
                      else {
                        uint64_t v78 = v76 + 1;
                      }
                      uint64_t v79 = -(v78 >> 1);
                      uint64_t v80 = v78 >> 1;
                      uint64_t v81 = &v71[-8 * v80];
                      int64_t v82 = v72 - v71;
                      if (v72 != v71)
                      {
                        memmove(&v71[-8 * v80], v71, v72 - v71);
                        int v71 = *v118;
                      }
                      int v72 = &v81[v82];
                      *(void *)(v2 + 264) = &v71[8 * v79];
                      *(void *)(v2 + 272) = &v81[v82];
                    }
                  }
                  *(void *)int v72 = v73;
                }
                else
                {
                  *(void *)int v7 = v29;
                }
LABEL_45:
                *(void *)(v2 + 272) += 8;
              }
              BOOL v8 = *(char **)(v2 + 264);
              unint64_t v12 = *(void *)(v2 + 296) + *(void *)(v2 + 288);
            }
            unint64_t v55 = *(void *)&v8[8 * (v12 / 0x155)] + 12 * (v12 % 0x155);
            *(void *)unint64_t v55 = v1;
            *(_DWORD *)(v55 + 8) = v119;
            uint64_t v56 = *(void *)(v2 + 296);
            *(void *)(v2 + 296) = v56 + 1;
            if (!v56)
            {
              uint64_t v57 = *(void *)(v2 + 304);
              if (v57)
              {
                unint64_t v58 = *(void *)(*(void *)(v2 + 264) + 8 * (*(void *)(v2 + 288) / 0x155uLL))
                    + 12 * (*(void *)(v2 + 288) % 0x155uLL);
                (*(void (**)(uint64_t, void, void))(*(void *)v57 + 16))(v57, *(void *)v58, *(unsigned int *)(v58 + 8));
              }
            }
          }
          BOOL v59 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v60 = *(void *)(v2 + 296);
            *(_DWORD *)long long buf = 134217984;
            uint64_t v121 = v60;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I Processed call forward fetch request, queue size is now %zu", buf, 0xCu);
          }
LABEL_9:
          operator delete();
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  int v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v121 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_101008970(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  operator delete(v13);
  if (v12) {
    operator delete(v12);
  }
  operator delete();
}

void sub_1010089C4(uint64_t a1, char a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 < 0x155) {
    a2 = 1;
  }
  if (v3 > 0x2A9 || (a2 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 341;
  }
}

void sub_101008A20(void **a1)
{
  uint64_t v2 = a1[2];
  unint64_t v3 = a1[1];
  uint64_t v4 = (unsigned char *)a1[3] - (unsigned char *)*a1;
  unint64_t v5 = (v2 - v3) >> 3;
  if (v5 >= v4 >> 3) {
    return;
  }
  if (v2 == v3)
  {
    unint64_t v9 = 0;
    unint64_t v6 = 0;
    goto LABEL_8;
  }
  unint64_t v6 = (char *)sub_100048350(v5);
  int v7 = a1[1];
  uint64_t v2 = a1[2];
  unint64_t v9 = &v6[8 * v8];
  uint64_t v10 = v2 - v7;
  if (v2 == v7)
  {
LABEL_8:
    uint64_t v13 = v2;
    goto LABEL_9;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 8 * (v10 >> 3);
  do
  {
    *(void *)&v6[v11] = *(void *)&v7[v11];
    v11 += 8;
  }
  while (v12 != v11);
  uint64_t v2 = a1[1];
  uint64_t v13 = a1[2];
LABEL_9:
  int64_t v14 = v13 - v2;
  uint64_t v15 = *a1;
  *a1 = v6;
  a1[1] = v6;
  a1[2] = &v6[v14];
  a1[3] = v9;
  if (v15)
  {
    operator delete(v15);
  }
}

void sub_101008AF0(uint64_t **a1)
{
  int v7 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *((unsigned int *)*a1 + 3);
  uint64_t v4 = *((unsigned int *)*a1 + 4);
  unint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109376;
    HIDWORD(buf) = v3;
    __int16 v9 = 1024;
    int v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Call Forward Fetch is going ahead for Request - Reason %d, Call Class 0x%04X", (uint8_t *)&buf, 0xEu);
  }
  if ((sub_100FF9CBC(v1, v2, v3, v4) & 1) == 0)
  {
    unint64_t v6 = operator new(0x20uLL);
    void *v6 = off_101A7D428;
    v6[1] = v1;
    *((_DWORD *)v6 + 4) = v2;
    *((_DWORD *)v6 + 5) = v3;
    *((_DWORD *)v6 + 6) = v4;
    uint64_t v11 = v6;
    sub_100FF7EDC(v1, v2, (uint64_t)v6);
    sub_10003B34C(&buf);
    sub_100FFBB04((uint64_t *)(v1 + 256));
  }
  operator delete();
}

void sub_101008C70(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101008CB0()
{
}

__n128 sub_101008CC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D428;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101008D18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D428;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101008D50(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24));
}

uint64_t sub_101008D88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101008DC8()
{
}

uint64_t *sub_101008DD4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v33 = a1;
  uint64_t v34 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(uint64_t **)(*(void *)v1 + 240);
  if (!v3)
  {
    uint64_t v4 = *(unsigned int *)(v1 + 8);
LABEL_9:
    int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      buf.var0 = 136315138;
      *(void *)&buf.var1 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_11;
  }
  uint64_t v4 = *(unsigned int *)(v1 + 8);
  unint64_t v5 = *(uint64_t **)(*(void *)v1 + 240);
  while (1)
  {
    int v6 = *((_DWORD *)v5 + 8);
    if ((int)v4 >= v6) {
      break;
    }
LABEL_6:
    unint64_t v5 = (uint64_t *)*v5;
    if (!v5) {
      goto LABEL_9;
    }
  }
  if (v6 < (int)v4)
  {
    ++v5;
    goto LABEL_6;
  }
  int v9 = *(unsigned __int8 *)(v1 + 152);
  unsigned int v10 = *(_DWORD *)(v1 + 156);
  BOOL v11 = v10 > 5;
  int v12 = (1 << v10) & 0x34;
  BOOL v13 = v11 || v12 == 0;
  if (!v13 && *(unsigned char *)(v1 + 12) && !*(unsigned char *)(v1 + 152))
  {
    if (sub_1000389F8(v3, v4)[1] == *(void *)(v2 + 152))
    {
      int v9 = 0;
    }
    else
    {
      int64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = *(_DWORD *)(v1 + 156);
        buf.var0 = 67109120;
        buf.var1 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I The call forward reason is '%d', but no reply time provided, assuming 20 seconds", (uint8_t *)&buf, 8u);
      }
      int v9 = 20;
    }
  }
  uint64_t v16 = *(unsigned int *)(v1 + 8);
  int v17 = *(unsigned __int8 *)(v1 + 12);
  sub_10009DB3C((uint64_t)&buf, v1 + 16);
  uint64_t v18 = *(unsigned int *)(v1 + 156);
  uint64_t v19 = *(unsigned int *)(v1 + 160);
  uint64_t v20 = *(unsigned int *)(v1 + 164);
  if (sub_1000389F8(*(uint64_t **)(v2 + 240), v16)[1])
  {
    if (!sub_100FF6754(v2) || sub_1000389F8(*(uint64_t **)(v2 + 240), v16)[1] == *(void *)(v2 + 152))
    {
      unint64_t v24 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v16);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        int64_t v25 = sub_1000389F8(*(uint64_t **)(v2 + 240), v16);
        uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25[1] + 48))(v25[1]);
        CSIPhoneNumber::getFullNumber((uint64_t *)__p, &buf);
        uint64_t v27 = __p;
        if (v36 < 0) {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)uint64_t v43 = 136316674;
        uint64_t v44 = v26;
        __int16 v45 = 1024;
        int v46 = v17;
        __int16 v47 = 2080;
        *(void *)unint64_t v48 = v27;
        *(_WORD *)&v48[8] = 1024;
        *(_DWORD *)&v48[10] = v18;
        __int16 v49 = 1024;
        int v50 = v19;
        __int16 v51 = 1024;
        int v52 = v9;
        __int16 v53 = 1024;
        int v54 = v20;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Sent the request to save Call Forward to %s with enabled %d, number %s, reason %d, class %d, Reply Timer %d, MMI Procedure %d", v43, 0x34u);
        if (v36 < 0) {
          operator delete(__p[0]);
        }
      }
      unint64_t v28 = sub_1000389F8(*(uint64_t **)(v2 + 240), v16);
      if ((5 * ((205 * v9) >> 10)) >= 0x1Eu) {
        uint64_t v29 = 30;
      }
      else {
        uint64_t v29 = (5 * ((205 * v9) >> 10));
      }
      char v22 = (*(uint64_t (**)(uint64_t, uint64_t, BOOL, CSIPhoneNumber *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v28[1] + 64))(v28[1], v16, v17 != 0, &buf, v18, v19, v29, v20);
    }
    else
    {
      uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v16);
      char v22 = 0;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v43 = 0;
        uint64_t v23 = "#I VoLTE call is active, ignoring the request to save Call Forward value because it would trigger CSFB";
        goto LABEL_39;
      }
    }
  }
  else
  {
    uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v16);
    char v22 = 0;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v43 = 0;
      uint64_t v23 = "#I SetCallForwarding failed, no command driver";
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v23, v43, 2u);
      char v22 = 0;
    }
  }
  if (v42 < 0) {
    operator delete(v41);
  }
  if (v40 < 0) {
    operator delete(v39);
  }
  if (v38 < 0) {
    operator delete(*(void **)&buf.var2.__r_.var0);
  }
  if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
  }
  if ((v22 & 1) == 0)
  {
    uint64_t v30 = *(unsigned int *)(v1 + 8);
    uint64_t v31 = *(void *)(v1 + 156);
    BOOL v32 = operator new(0x20uLL);
    *BOOL v32 = off_101A7D4A8;
    v32[1] = v2;
    *((_DWORD *)v32 + 4) = v30;
    *(void *)((char *)v32 + 20) = v31;
    *(void *)&v48[4] = v32;
    sub_100FF704C(v2, v30, (uint64_t)v32);
    sub_10003B34C(v43);
  }
LABEL_11:
  sub_1010093AC(&v34);
  return sub_100046B58((uint64_t *)&v33);
}

void sub_101009338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  sub_10003B34C((void *)(v40 - 176));
  sub_1010093AC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1010093AC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

void sub_101009438()
{
}

__n128 sub_10100944C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D4A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1010094A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D4A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010094D8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                           + 24))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), 0);
}

uint64_t sub_101009514(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101009554()
{
}

BOOL sub_101009560(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  return sub_100FFA274(*(void *)v1, **(unsigned int **)(v1 + 8), *(BOOL **)(v1 + 16), *(void *)(v1 + 24), *(unsigned char **)(v1 + 32), **(_DWORD **)(v1 + 40), **(_DWORD **)(v1 + 48));
}

BOOL sub_101009584(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = (uint64_t *)*((void *)*v1 + 30);
  uint64_t v3 = *v1[1];
  if (v2)
  {
    uint64_t v4 = (uint64_t *)*((void *)*v1 + 30);
    do
    {
      int v5 = *((_DWORD *)v4 + 8);
      if ((int)v3 >= v5)
      {
        if (v5 >= (int)v3) {
          return *(unsigned char *)(sub_1000389F8(v2, v3)[3] + 48) != 0;
        }
        ++v4;
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**((void **)*v1 + 6) + 16))(*((void *)*v1 + 6), v3);
  BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v8 = 136315138;
    uint64_t v9 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v8, 0xCu);
    return 0;
  }
  return result;
}

uint64_t *sub_1010096A4(unsigned int **a1)
{
  uint64_t v1 = *a1;
  unsigned int v10 = a1;
  BOOL v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(uint64_t **)(*(void *)v1 + 240);
  if (v3)
  {
    uint64_t v4 = v1[2];
    int v5 = *(uint64_t **)(*(void *)v1 + 240);
    do
    {
      int v6 = *((_DWORD *)v5 + 8);
      if ((int)v4 >= v6)
      {
        if (v6 >= (int)v4) {
          goto LABEL_12;
        }
        ++v5;
      }
      int v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v4 = v1[2];
  }
  int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)CSIPhoneNumber buf = 136315138;
    uint64_t v13 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  sub_100335978((uint64_t)(v1 + 4), 256);
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  LODWORD(v4) = v1[2];
LABEL_12:
  int v8 = sub_1000389F8(v3, v4);
  sub_100335978((uint64_t)(v1 + 4), *(unsigned __int8 *)(v8[3] + 48) | 0x100);
  sub_100AB000C((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_1010097FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_101009818(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *(uint64_t **)(v1 + 240);
  if (v3)
  {
    uint64_t v4 = *(uint64_t **)(v1 + 240);
    do
    {
      int v5 = *((_DWORD *)v4 + 8);
      if (v5 <= (int)v2)
      {
        if (v5 >= (int)v2)
        {
          if (sub_1000389F8(v3, v2)[1])
          {
            if (sub_100FF6754(v1)
              && sub_1000389F8(*(uint64_t **)(v1 + 240), v2)[1] != *(void *)(v1 + 152))
            {
              int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
              if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                int v8 = "#I VoLTE call is active, ignoring request to fetch Calling Name Presentation because it would trigger CSFB";
                goto LABEL_21;
              }
              goto LABEL_22;
            }
            uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v10 = sub_1000389F8(*(uint64_t **)(v1 + 240), v2);
              uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10[1] + 48))(v10[1]);
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v11;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Sent the Calling Name Presentation Fetch request to %s", (uint8_t *)&buf, 0xCu);
            }
            int v12 = sub_1000389F8(*(uint64_t **)(v1 + 240), v2);
            if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12[1] + 144))(v12[1], v2) & 1) == 0) {
              goto LABEL_22;
            }
          }
          else
          {
            int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              int v8 = "#I fetch CNAP failed, no command driver";
LABEL_21:
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&buf, 2u);
            }
LABEL_22:
            *(void *)&long long buf = off_101A7D568;
            *((void *)&buf + 1) = v1;
            uint64_t v14 = v2;
            p_long long buf = &buf;
            (*(void (**)(void, uint64_t))(**(void **)(v1 + 112) + 256))(*(void *)(v1 + 112), v2);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, 1);
            sub_10003B34C(&buf);
          }
LABEL_9:
          operator delete();
        }
        ++v4;
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_101009BC4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101009C04()
{
}

__n128 sub_101009C18(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101009C64(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101009C94(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 256))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_101009CD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101009D10()
{
}

BOOL sub_101009D1C(uint64_t a1)
{
  return sub_100FFAD78(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8), *(int **)(*(void *)(a1 + 40) + 16));
}

void sub_101009D30(void ****a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = v2[30];
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    int v5 = v2[30];
    while (1)
    {
      int v6 = *((_DWORD *)v5 + 8);
      if ((int)v4 >= v6)
      {
        if (v6 >= (int)v4)
        {
          if (sub_1000389F8(v3, v4)[1])
          {
            if (!sub_100FF6754((uint64_t)v2)
              || (void *)sub_1000389F8(v2[30], *((_DWORD *)v1 + 2))[1] == v2[19])
            {
              (*(void (**)(void *, void, void))(*v2[17] + 168))(v2[17], *((unsigned int *)v1 + 2), *((unsigned __int8 *)v1 + 12));
              (*(void (**)(void *, void, void))(*v2[19] + 168))(v2[19], *((unsigned int *)v1 + 2), *((unsigned __int8 *)v1 + 12));
              uint64_t v9 = *((unsigned int *)v1 + 2);
              int v10 = *((unsigned __int8 *)v1 + 12);
              uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v9);
              if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
              {
                int v12 = "OFF";
                if (v10) {
                  int v12 = "ON";
                }
                *(_DWORD *)long long buf = 136315138;
                uint64_t v14 = (uint64_t)v12;
                _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Persisting Auto Answer status %s", buf, 0xCu);
              }
              (*(void (**)(void *, uint64_t, BOOL))(*v2[23] + 120))(v2[23], v9, v10 != 0);
            }
            else
            {
              int v8 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
              if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring request to enable Auto Answer Mode", buf, 2u);
              }
            }
          }
          goto LABEL_11;
        }
        ++v5;
      }
      int v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v1 + 2);
LABEL_9:
  int v7 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v14 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_11:
  operator delete();
}

void sub_10100A040()
{
}

void sub_10100A06C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    while (1)
    {
      int v5 = *((_DWORD *)v3 + 8);
      if ((int)v4 >= v5)
      {
        if (v5 >= (int)v4)
        {
          int v7 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48));
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I New SIM Info available, restoring the Call Forward Settings", (uint8_t *)&buf, 2u);
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(v2 + 96));
          int v10 = ServiceMap;
          if ((v11 & 0x8000000000000000) != 0)
          {
            int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v13 = 5381;
            do
            {
              std::string::size_type v11 = v13;
              unsigned int v14 = *v12++;
              uint64_t v13 = (33 * v13) ^ v14;
            }
            while (v14);
          }
          std::mutex::lock(ServiceMap);
          buf.__r_.__value_.__r.__words[0] = v11;
          int v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&buf);
          if (v15)
          {
            uint64_t v17 = v15[3];
            uint64_t v16 = (std::__shared_weak_count *)v15[4];
            if (v16)
            {
              atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v10);
              atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v16);
              char v18 = 0;
              if (!v17)
              {
LABEL_20:
                uint64_t v19 = *(NSObject **)(v2 + 40);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Subscriber sim controller not found.", (uint8_t *)&buf, 2u);
                }
                goto LABEL_38;
              }
LABEL_24:
              memset(&buf, 0, sizeof(buf));
              (*(void (**)(uint64_t, void, void, std::string *))(*(void *)v17 + 200))(v17, *((unsigned int *)v1 + 2), 0, &buf);
              uint64_t v20 = sub_1000389F8(*(uint64_t **)(v2 + 240), *((_DWORD *)v1 + 2));
              sub_100AB8B90(v20[3]);
              std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type size = buf.__r_.__value_.__l.__size_;
              }
              if (size)
              {
                char v22 = sub_1000389F8(*(uint64_t **)(v2 + 240), *((_DWORD *)v1 + 2));
                if (sub_100AB8D70(v22[3], &buf))
                {
                  uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
                  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)unint64_t v28 = 0;
                    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I ICCID has changed, resetting CLIR network info if available", v28, 2u);
                  }
                  sub_100FF7360((void **)v2, *((unsigned int *)v1 + 2));
                }
              }
              unint64_t v24 = *(std::__shared_weak_count **)(v2 + 224);
              if (v24)
              {
                int64_t v25 = std::__shared_weak_count::lock(v24);
                if (v25)
                {
                  uint64_t v26 = v25;
                  uint64_t v27 = *(void *)(v2 + 216);
                  if (v27) {
                    (*(void (**)(uint64_t, void))(*(void *)v27 + 328))(v27, *((unsigned int *)v1 + 2));
                  }
                  sub_10004D2C8(v26);
                }
              }
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
LABEL_38:
              if ((v18 & 1) == 0) {
                sub_10004D2C8(v16);
              }
LABEL_11:
              operator delete();
            }
          }
          else
          {
            uint64_t v17 = 0;
          }
          std::mutex::unlock(v10);
          uint64_t v16 = 0;
          char v18 = 1;
          if (!v17) {
            goto LABEL_20;
          }
          goto LABEL_24;
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
      if (!v3) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v1 + 2);
LABEL_9:
  int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_11;
}

void sub_10100A45C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_10004D2C8(v19);
  if (a18 < 0) {
    operator delete(__p);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  operator delete();
}

void sub_10100A4D0(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)v1 + 2);
    int v5 = *(uint64_t **)(v2 + 240);
    while (1)
    {
      int v6 = *((_DWORD *)v5 + 8);
      if ((int)v4 >= v6)
      {
        if (v6 >= (int)v4)
        {
          uint64_t v8 = *(void *)(v2 + 112);
          uint64_t v9 = sub_1000389F8(v3, *((_DWORD *)v1 + 2));
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v8 + 48))(v8, v4, *(unsigned __int8 *)(v9[3] + 48));
          goto LABEL_12;
        }
        ++v5;
      }
      int v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v4 = *((unsigned int *)v1 + 2);
LABEL_9:
  int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v4);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v11 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_12:
  operator delete();
}

void sub_10100A64C()
{
}

void sub_10100A678(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 384) + 40))(*(void *)(**(void **)a1 + 384), *(unsigned int *)(*(void *)a1 + 8), 0);
  operator delete();
}

void sub_10100A6F8()
{
}

void sub_10100A724(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 384) + 40))(*(void *)(**(void **)a1 + 384), *(unsigned int *)(*(void *)a1 + 8), *(unsigned int *)(*(void *)a1 + 12));
  operator delete();
}

void sub_10100A7A0()
{
}

uint64_t *sub_10100A7CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v4 = *(void **)(v1 + 16);
  int v5 = *(std::__shared_weak_count **)(v1 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v6 = *(uint64_t **)(v2 + 240);
  if (!v6)
  {
LABEL_9:
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)long long __p = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
    goto LABEL_36;
  }
  int v7 = *(_DWORD *)(v1 + 32);
  int v8 = *(_DWORD *)(v1 + 36);
  while (1)
  {
    int v9 = *((_DWORD *)v6 + 8);
    if (v9 <= (int)v3) {
      break;
    }
LABEL_8:
    int v6 = (uint64_t *)*v6;
    if (!v6) {
      goto LABEL_9;
    }
  }
  if (v9 < (int)v3)
  {
    ++v6;
    goto LABEL_8;
  }
  uint64_t v26 = v5;
  int v11 = 0;
  if (*v4 != v4[1])
  {
    uint64_t v12 = *v4 + 8;
    do
    {
      uint64_t v13 = v12 - 8;
      unsigned int v14 = (os_log_t *)sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[3];
      uint8_t v15 = *(unsigned char *)(v12 - 6);
      *(_WORD *)std::string buf = *(_WORD *)(v12 - 8);
      buf[2] = v15;
      if (*(char *)(v12 + 23) < 0)
      {
        sub_10004FC84(&__p[4], *(void **)v12, *(void *)(v12 + 8));
      }
      else
      {
        long long v16 = *(_OWORD *)v12;
        uint64_t v41 = *(void *)(v12 + 16);
        *(_OWORD *)&__p[4] = v16;
      }
      char v42 = *(unsigned char *)(v12 + 24);
      sub_100AB7E9C(v14, v7, (uint64_t)buf);
      if (SHIBYTE(v41) < 0) {
        operator delete(*(void **)&__p[4]);
      }
      int v11 = *(unsigned __int8 *)(v12 - 6) | v11;
      v12 += 40;
    }
    while (v13 + 40 != v4[1]);
  }
  uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v33 = 67109120;
    int v34 = v11;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Classes covered are %d", v33, 8u);
  }
  if (!v8)
  {
    char v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v33 = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", v33, 2u);
    }
    int v8 = 255;
  }
  for (uint64_t i = 0; i != 8; ++i)
  {
    int v20 = 1 << i;
    uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v29 = 67109376;
      *(_DWORD *)&v29[4] = 1 << i;
      LOWORD(v30) = 1024;
      *(_DWORD *)((char *)&v30 + 2) = v8;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Checking for service class %d and call class in the request: %d", v29, 0xEu);
    }
    if ((v20 & v8) != 0 && (v20 & v11) == 0)
    {
      char v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v29 = 67109120;
        *(_DWORD *)&v29[4] = 1 << i;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Baseband response does not contain information on class %d, assuming inactive", v29, 8u);
      }
      uint64_t v23 = (os_log_t *)sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[3];
      *(_WORD *)uint64_t v33 = 0;
      v33[2] = 1 << i;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v35 = 0;
      char v38 = 0;
      sub_100AB7E9C(v23, v7, (uint64_t)v33);
      if (SHIBYTE(v37) < 0) {
        operator delete(v35);
      }
    }
  }
  int v5 = v26;
  unint64_t v24 = operator new(0x20uLL);
  *unint64_t v24 = off_101A7D608;
  v24[1] = v2;
  *((_DWORD *)v24 + 4) = v8;
  *((_DWORD *)v24 + 5) = v3;
  *((_DWORD *)v24 + 6) = v7;
  BOOL v32 = (uint8_t *)v24;
  sub_10100AE28((uint64_t)v24);
  (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 0);
  sub_10003B34C(v29);
  *(void *)uint64_t v29 = off_101A7D688;
  uint64_t v30 = v2;
  uint64_t v31 = v3;
  BOOL v32 = v29;
  sub_10100B12C((uint64_t)v29);
  (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 0);
  sub_10003B34C(v29);
  sub_100FFBB04((uint64_t *)(v2 + 256));
LABEL_36:
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10013AAC4(&v28);
  return sub_100046B58((uint64_t *)&v27);
}

void sub_10100AD0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10013AAC4(&a16);
  sub_100046B58(&a15);
  _Unwind_Resume(a1);
}

void sub_10100AD88()
{
}

__n128 sub_10100AD9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100ADF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10100AE28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = 1;
  do
  {
    if ((v4 & v3) != 0)
    {
      uint64_t v26 = 0;
      long long v24 = 0u;
      long long v25 = 0u;
      *(_OWORD *)char v22 = 0u;
      *(_OWORD *)uint64_t v23 = 0u;
      long long v21 = 0u;
      memset(&v20, 0, sizeof(v20));
      CSIPhoneNumber::CSIPhoneNumber(&v20);
      __int16 v19 = 0;
      if (sub_100FFA274(v2, *(unsigned int *)(a1 + 20), (BOOL *)&v19 + 1, (uint64_t)&v20, &v19, *(_DWORD *)(a1 + 24), v4))
      {
        uint64_t v5 = *(void *)(v2 + 112);
        uint64_t v6 = *(unsigned int *)(a1 + 20);
        uint64_t v7 = *(unsigned int *)(a1 + 24);
        int v8 = HIBYTE(v19);
        uint64_t v9 = (char)v19;
        sub_10009DB3C((uint64_t)&v10, (uint64_t)&v20);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, BOOL, uint64_t, uint64_t *))(*(void *)v5 + 32))(v5, v6, v7, v4, v8 != 0, v9, &v10);
        if (v18 < 0) {
          operator delete(__p);
        }
        if (v16 < 0) {
          operator delete(v15);
        }
        if (v14 < 0) {
          operator delete(v13);
        }
        if (v12 < 0) {
          operator delete(v11);
        }
      }
      if (SHIBYTE(v24) < 0) {
        operator delete(v23[1]);
      }
      if (SHIBYTE(v23[0]) < 0) {
        operator delete(v22[0]);
      }
      if (SBYTE7(v21) < 0) {
        operator delete(*(void **)&v20.var2.__r_.var0);
      }
      if (*((char *)&v20.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(v20.var2.__r_.__value_.var0.var1.__data_);
      }
    }
    uint64_t v4 = (2 * v4);
  }
  while (v4 && (int)v4 < 129);
}

void sub_10100AFB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,void *a59,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a64 < 0) {
    operator delete(a59);
  }
  if (a58 < 0) {
    operator delete(a53);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10100B04C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100B08C()
{
}

void sub_10100B09C()
{
}

__n128 sub_10100B0B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100B0FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100B12C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 112);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(unsigned __int8 *)(sub_1000389F8(*(uint64_t **)(v1 + 240), v3)[3] + 48);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 48);

  return v5(v2, v3, v4);
}

uint64_t sub_10100B1A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100B1E0()
{
}

void sub_10100B1EC(uint64_t **a1)
{
  uint8_t v15 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *((unsigned int *)*a1 + 3);
  uint64_t v5 = *((unsigned int *)*a1 + 4);
  uint64_t v4 = *((unsigned int *)*a1 + 5);
  int v6 = *((unsigned __int8 *)*a1 + 24);
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = CSIErrorString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Unable to fetch call forwarding info, error=%s", (uint8_t *)&buf, 0xCu);
  }
  int v8 = *(uint64_t **)(v1 + 240);
  if (v8)
  {
    uint64_t v9 = *(uint64_t **)(v1 + 240);
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      if (v10 <= (int)v2)
      {
        if (v10 >= (int)v2)
        {
          if (v6 != 1
            || (v4 - 21) > 1
            || (*((unsigned char *)sub_1000389F8(v8, v2) + 160) = 0,
                sub_100FF450C(v1, v2),
                (sub_100FF9CBC(v1, v2, v3, v5) & 1) == 0))
          {
            if (!v5)
            {
              char v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", (uint8_t *)&buf, 2u);
              }
              uint64_t v5 = 255;
            }
            uint64_t v13 = operator new(0x20uLL);
            void *v13 = off_101A7D708;
            v13[1] = v1;
            *((_DWORD *)v13 + 4) = v2;
            *((_DWORD *)v13 + 5) = v3;
            *((_DWORD *)v13 + 6) = v5;
            p_long long buf = (long long *)v13;
            (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v1 + 112) + 16))(*(void *)(v1 + 112), v2, v3, v5);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, v4);
            sub_10003B34C(&buf);
            *(void *)&long long buf = off_101A7D788;
            *((void *)&buf + 1) = v1;
            uint64_t v17 = v2;
            p_long long buf = &buf;
            sub_10100B76C((uint64_t)&buf);
            (*(void (**)(void, uint64_t, void))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, 0);
            sub_10003B34C(&buf);
            sub_100FFBB04((uint64_t *)(v1 + 256));
          }
LABEL_11:
          operator delete();
        }
        ++v9;
      }
      uint64_t v9 = (uint64_t *)*v9;
    }
    while (v9);
  }
  int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    uint64_t v14 = subscriber::asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v14;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_11;
}

void sub_10100B570(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100B5B4()
{
}

__n128 sub_10100B5C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D708;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100B61C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D708;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100B654(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 16))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24));
}

uint64_t sub_10100B68C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100B6CC()
{
}

void sub_10100B6DC()
{
}

__n128 sub_10100B6F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D788;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100B73C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D788;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100B76C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 112);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(unsigned __int8 *)(sub_1000389F8(*(uint64_t **)(v1 + 240), v3)[3] + 48);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 48);

  return v5(v2, v3, v4);
}

uint64_t sub_10100B7E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100B820()
{
}

void sub_10100B82C(void **a1)
{
  char v16 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = v2[30];
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 3);
    uint64_t v6 = *((unsigned int *)v1 + 4);
    int v7 = *((unsigned __int8 *)v1 + 20);
    uint64_t v8 = *((unsigned int *)v1 + 6);
    do
    {
      int v9 = *((_DWORD *)v4 + 8);
      if (v9 <= (int)v3)
      {
        if (v9 >= (int)v3)
        {
          if (!v6)
          {
            int v11 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", (uint8_t *)&buf, 2u);
            }
            uint64_t v6 = 255;
          }
          char v12 = operator new(0x20uLL);
          void *v12 = off_101A7D808;
          v12[1] = v2;
          *((_DWORD *)v12 + 4) = v3;
          *((_DWORD *)v12 + 5) = v5;
          *((_DWORD *)v12 + 6) = v6;
          *((_DWORD *)v12 + 7) = v8;
          p_long long buf = (long long *)v12;
          (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*v2[14] + 40))(v2[14], v3, v5, v6, v8);
          (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
          sub_10003B34C(&buf);
          if (v5 & 0xFFFFFFFB) == 0 && (v6)
          {
            uint64_t v13 = sub_1000389F8(v2[30], v3);
            sub_100AB8128(v13[3], v7 != 0);
            uint64_t v14 = sub_1000389F8(v2[30], v3);
            sub_100AB83B4(v14[3], 0, 1u);
            uint8_t v15 = sub_1000389F8(v2[30], v3);
            sub_100AB83B4(v15[3], 4, 1u);
            *(void *)&long long buf = off_101A7D888;
            *((void *)&buf + 1) = v2;
            unint64_t v18 = v3 | ((unint64_t)(v7 != 0) << 32);
            p_long long buf = &buf;
            (*(void (**)(void *, uint64_t))(*v2[14] + 48))(v2[14], v3);
            (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
            sub_10003B34C(&buf);
          }
LABEL_9:
          operator delete();
        }
        ++v4;
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
  }
  int v10 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_10100BB7C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100BBC0()
{
}

__n128 sub_10100BBD4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D808;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100BC28(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D808;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100BC60(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                           + 40))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
}

uint64_t sub_10100BC98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100BCD8()
{
}

void sub_10100BCE8()
{
}

__n128 sub_10100BCFC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7D888;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100BD48(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D888;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100BD78(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 48))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned __int8 *)(a1 + 20));
}

uint64_t sub_10100BDB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100BDF0()
{
}

void sub_10100BDFC(uint64_t **a1)
{
  char v16 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *((unsigned int *)*a1 + 3);
  uint64_t v5 = *((unsigned int *)*a1 + 4);
  uint64_t v4 = *((unsigned int *)*a1 + 5);
  uint64_t v6 = *((unsigned int *)*a1 + 6);
  int v7 = *((unsigned __int8 *)*a1 + 28);
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v18 = CSIErrorString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Unable to set call forwarding info, error=%s", buf, 0xCu);
  }
  int v9 = *(uint64_t **)(v1 + 240);
  if (v9)
  {
    int v10 = *(uint64_t **)(v1 + 240);
    do
    {
      int v11 = *((_DWORD *)v10 + 8);
      if (v11 <= (int)v2)
      {
        if (v11 >= (int)v2)
        {
          if (v7 == 1 && (v6 - 21) <= 1)
          {
            *((unsigned char *)sub_1000389F8(v9, v2) + 160) = 0;
            sub_100FF450C(v1, v2);
          }
          if (!v5)
          {
            uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", buf, 2u);
            }
            uint64_t v5 = 255;
          }
          uint8_t v15 = operator new(0x20uLL);
          *uint8_t v15 = off_101A7D908;
          v15[1] = v1;
          *((_DWORD *)v15 + 4) = v2;
          *((_DWORD *)v15 + 5) = v3;
          *((_DWORD *)v15 + 6) = v5;
          *((_DWORD *)v15 + 7) = v4;
          __int16 v19 = v15;
          (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(v1 + 112) + 24))(*(void *)(v1 + 112), v2, v3, v5, v4);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, v6);
          sub_10003B34C(buf);
LABEL_19:
          operator delete();
        }
        ++v10;
      }
      int v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  char v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    uint64_t v13 = subscriber::asString();
    *(_DWORD *)long long buf = 136315138;
    uint64_t v18 = v13;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  goto LABEL_19;
}

void sub_10100C108(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100C148()
{
}

__n128 sub_10100C15C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D908;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100C1B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D908;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100C1E8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                           + 24))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
}

uint64_t sub_10100C220(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100C260()
{
}

void sub_10100C26C(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = v2[30];
  if (v4)
  {
    unsigned int v5 = *((_DWORD *)v1 + 3);
    int v6 = *((_DWORD *)v1 + 4);
    int v7 = *((unsigned __int8 *)v1 + 20);
    do
    {
      int v8 = *((_DWORD *)v4 + 8);
      if (v8 <= (int)v3)
      {
        if (v8 >= (int)v3)
        {
          if (!v6)
          {
            int v10 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", buf, 2u);
            }
            int v6 = 255;
          }
          if (!sub_1000389F8(v2[30], v3)[5]) {
            sub_100AB8660(buf);
          }
          for (int i = 0; i != 8; ++i)
          {
            if (((1 << i) & v6) != 0)
            {
              uint64_t v12 = sub_1000389F8(v2[30], v3)[5];
              sub_100AB8804(v12, v5, (1 << i), ((1 << i) & v7) != 0);
            }
          }
          uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Fetch complete notification", buf, 2u);
          }
          uint64_t v14 = operator new(0x20uLL);
          void *v14 = off_101A7D988;
          v14[1] = v2;
          *((_DWORD *)v14 + 4) = v6;
          *((_DWORD *)v14 + 5) = v3;
          *((_DWORD *)v14 + 6) = v5;
          char v16 = v14;
          sub_10100C690((uint64_t)v14);
          (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
          sub_10003B34C(buf);
LABEL_21:
          operator delete();
        }
        ++v4;
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  goto LABEL_21;
}

void sub_10100C598(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

void sub_10100C5F0()
{
}

__n128 sub_10100C604(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7D988;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100C658(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7D988;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10100C690(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Fetch complete notification", v6, 2u);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  uint64_t v5 = 1;
  do
  {
    if ((v5 & v4) != 0)
    {
      unsigned __int8 v7 = 0;
      if (sub_100FF8118(v2, *(unsigned int *)(a1 + 20), &v7, *(_DWORD *)(a1 + 24), v5)) {
        (*(void (**)(void, void, uint64_t, void, void))(**(void **)(v2 + 112) + 128))(*(void *)(v2 + 112), *(unsigned int *)(a1 + 20), v5, *(unsigned int *)(a1 + 24), v7);
      }
    }
    uint64_t v5 = (2 * v5);
  }
  while (v5 && (int)v5 < 129);
}

uint64_t sub_10100C770(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100C7B0()
{
}

void sub_10100C7BC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  int v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 3);
    uint64_t v6 = *((unsigned int *)v1 + 4);
    uint64_t v7 = *((unsigned int *)v1 + 5);
    int v8 = *((unsigned __int8 *)v1 + 24);
    do
    {
      int v9 = *((_DWORD *)v4 + 8);
      if (v9 <= (int)v3)
      {
        if (v9 >= (int)v3)
        {
          int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Fetch Error notification", buf, 2u);
          }
          uint64_t v17 = 0;
          CFBooleanRef v16 = kCFBooleanTrue;
          if (kCFBooleanTrue) {
            CFRetain(kCFBooleanTrue);
          }
          sub_100FF6114(buf, (Registry **)(v2 + 96), (NSObject **)(v2 + 40), v3, (uint64_t)"CallBarringNASFallbackSupported", &v16);
          sub_1000057AC(&v17, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          sub_1000577C4((const void **)&v16);
          buf[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, v17, v13);
          if (buf[0] && v8 == 1 && (v7 - 21) <= 1)
          {
            *((unsigned char *)sub_1000389F8(*(uint64_t **)(v2 + 240), v3) + 160) = 0;
            sub_100FF450C(v2, v3);
            sub_100058DB0(buf, "");
            sub_100FF7B18(v2, v3, v5, v6);
            if (v19 < 0) {
              operator delete(*(void **)buf);
            }
          }
          else
          {
            if (!v6)
            {
              uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", buf, 2u);
              }
              uint64_t v6 = 255;
            }
            uint8_t v15 = operator new(0x20uLL);
            *uint8_t v15 = off_101A7DA08;
            v15[1] = v2;
            *((_DWORD *)v15 + 4) = v3;
            *((_DWORD *)v15 + 5) = v6;
            *((_DWORD *)v15 + 6) = v5;
            CSIPhoneNumber v20 = v15;
            (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 112) + 112))(*(void *)(v2 + 112), v3, v6, v5);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, v7);
            sub_10003B34C(buf);
          }
          sub_100062778((const void **)&v17);
          goto LABEL_25;
        }
        ++v4;
      }
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_25:
  operator delete();
}

void sub_10100CB58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
}

void sub_10100CBFC()
{
}

__n128 sub_10100CC10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7DA08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100CC64(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DA08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100CC9C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 112))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24));
}

uint64_t sub_10100CCD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100CD14()
{
}

void sub_10100CD20(unsigned int **a1)
{
  uint64_t v14 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)*a1;
  uint64_t v3 = (*a1)[2];
  int v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    uint64_t v5 = v1[3];
    uint64_t v6 = v1[4];
    uint64_t v7 = v1[6];
    do
    {
      int v8 = *((_DWORD *)v4 + 8);
      if (v8 <= (int)v3)
      {
        if (v8 >= (int)v3)
        {
          int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Info set complete notification", buf, 2u);
          }
          if (!v6)
          {
            uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", buf, 2u);
            }
            uint64_t v6 = 255;
          }
          CFBooleanRef v13 = operator new(0x20uLL);
          void *v13 = off_101A7DA88;
          v13[1] = v2;
          *((_DWORD *)v13 + 4) = v3;
          *((_DWORD *)v13 + 5) = v6;
          *((_DWORD *)v13 + 6) = v7;
          *((_DWORD *)v13 + 7) = v5;
          uint64_t v17 = v13;
          (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 112) + 136))(*(void *)(v2 + 112), v3, v6, v7, v5);
          (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 0);
          sub_10003B34C(buf);
          goto LABEL_17;
        }
        ++v4;
      }
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v16 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_17:
  operator delete();
}

void sub_10100CFDC(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100D01C()
{
}

__n128 sub_10100D030(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7DA88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100D084(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DA88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100D0BC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                           + 136))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
}

uint64_t sub_10100D0F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100D134()
{
}

void sub_10100D140(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  int v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 3);
    uint64_t v6 = *((unsigned int *)v1 + 4);
    uint64_t v8 = *((unsigned int *)v1 + 5);
    uint64_t v7 = *((unsigned int *)v1 + 6);
    int v9 = *((unsigned __int8 *)v1 + 28);
    do
    {
      int v10 = *((_DWORD *)v4 + 8);
      if (v10 <= (int)v3)
      {
        if (v10 >= (int)v3)
        {
          uint64_t v17 = 0;
          CFBooleanRef v16 = kCFBooleanFalse;
          if (kCFBooleanFalse) {
            CFRetain(kCFBooleanFalse);
          }
          sub_100FF6114(buf, (Registry **)(v2 + 96), (NSObject **)(v2 + 40), v3, (uint64_t)"CallBarringNASFallbackSupported", &v16);
          sub_1000057AC(&v17, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          sub_1000577C4((const void **)&v16);
          buf[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, v17, v12);
          if (buf[0] && v9 == 1 && (v7 - 21) <= 1)
          {
            *((unsigned char *)sub_1000389F8(*(uint64_t **)(v2 + 240), v3) + 160) = 0;
            sub_100FF450C(v2, v3);
          }
          if (!v6)
          {
            CFBooleanRef v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Call class was not provided, interpreting it as ALL", buf, 2u);
            }
            uint64_t v6 = 255;
          }
          uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Info set error notification", buf, 2u);
          }
          uint8_t v15 = operator new(0x20uLL);
          *uint8_t v15 = off_101A7DB08;
          v15[1] = v2;
          *((_DWORD *)v15 + 4) = v3;
          *((_DWORD *)v15 + 5) = v6;
          *((_DWORD *)v15 + 6) = v8;
          *((_DWORD *)v15 + 7) = v5;
          CSIPhoneNumber v20 = v15;
          (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 112) + 120))(*(void *)(v2 + 112), v3, v6, v8, v5);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, v7);
          sub_10003B34C(buf);
          sub_100062778((const void **)&v17);
LABEL_22:
          operator delete();
        }
        ++v4;
      }
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v19 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  goto LABEL_22;
}

void sub_10100D4A8(uint64_t a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100062778((const void **)va);
  operator delete();
}

void sub_10100D534()
{
}

__n128 sub_10100D548(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7DB08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100D59C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DB08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100D5D4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                           + 120))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28));
}

uint64_t sub_10100D60C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100D64C()
{
}

void sub_10100D658(uint64_t **a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = **a1;
  uint64_t v1 = (*a1)[1];
  for (int i = *(uint64_t **)(v2 + 240); i; int i = (uint64_t *)*i)
  {
    int v4 = *((_DWORD *)i + 8);
    if (v4 <= (int)v1)
    {
      if (v4 >= (int)v1)
      {
        uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Password Registration event", (uint8_t *)&buf, 2u);
        }
        *(void *)&long long buf = off_101A7DB88;
        *((void *)&buf + 1) = v2;
        uint64_t v10 = v1;
        p_long long buf = &buf;
        sub_10100D91C((uint64_t)&buf);
        (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v1, 0);
        sub_10003B34C(&buf);
        goto LABEL_12;
      }
      ++i;
    }
  }
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
LABEL_12:
  operator delete();
}

void sub_10100D84C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100D88C()
{
}

__n128 sub_10100D8A0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DB88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100D8EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DB88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100D91C(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 112);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int *)(a1 + 20);
  if (v4 > 8) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = asc_1015AD426[v4];
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 144))(v2, v3, v5);
}

uint64_t sub_10100D970(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100D9B0()
{
}

void sub_10100D9BC(uint64_t **a1)
{
  int v9 = a1;
  uint64_t v2 = **a1;
  uint64_t v1 = (*a1)[1];
  uint64_t v3 = *(uint64_t **)(v2 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)*a1 + 4);
    do
    {
      int v5 = *((_DWORD *)v3 + 8);
      if (v5 <= (int)v1)
      {
        if (v5 >= (int)v1)
        {
          uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Sending out Call Barring Password Registration failure event", (uint8_t *)&buf, 2u);
          }
          *(void *)&long long buf = off_101A7DC08;
          *((void *)&buf + 1) = v2;
          uint64_t v11 = v1;
          p_long long buf = &buf;
          sub_10100DC8C((uint64_t)&buf);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v1, v4);
          sub_10003B34C(&buf);
          goto LABEL_13;
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
LABEL_13:
  operator delete();
}

void sub_10100DBBC(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100DBFC()
{
}

__n128 sub_10100DC10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DC08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100DC5C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DC08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100DC8C(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 112);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int *)(a1 + 20);
  if (v4 > 8) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = asc_1015AD426[v4];
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 152))(v2, v3, v5);
}

uint64_t sub_10100DCE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100DD20()
{
}

uint64_t *sub_10100DD2C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v17 = a1;
  uint64_t v18 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v4 = *(unsigned int *)(v1 + 12);
  uint64_t v6 = *(unsigned __int8 **)(v1 + 16);
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = v2[30];
  if (!v7)
  {
LABEL_8:
    int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_19;
  }
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)v3) {
      break;
    }
LABEL_7:
    uint64_t v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_8;
    }
  }
  if (v8 < (int)v3)
  {
    ++v7;
    goto LABEL_7;
  }
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Call waiting values retrieved successfully", (uint8_t *)&buf, 2u);
  }
  uint64_t v11 = sub_1000389F8(v2[30], v3) + 8;
  sub_10005D144((void *)*v11);
  int v12 = 0;
  *(v11 - 1) = (uint64_t)v11;
  *uint64_t v11 = 0;
  v11[1] = 0;
  if (v4) {
    int v13 = v4;
  }
  else {
    int v13 = 255;
  }
  do
  {
    if (((1 << v12) & v13) != 0)
    {
      int v14 = *v6;
      uint8_t v15 = sub_1000389F8(v2[30], v3);
      LODWORD(buf) = 1 << v12;
      *((unsigned char *)sub_1000BC5E4((uint64_t **)v15 + 7, 1 << v12, &buf) + 32) = ((1 << v12) & v14) != 0;
    }
    ++v12;
  }
  while (v12 != 8);
  sub_100FF7538(v2, v3);
  sub_100FF3D90((uint64_t)v2, v3);
  *(void *)&long long buf = off_101A7DC88;
  *((void *)&buf + 1) = v2;
  uint64_t v20 = v4 | (v3 << 32);
  p_long long buf = &buf;
  sub_10100E0BC((uint64_t)&buf);
  (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
  sub_10003B34C(&buf);
LABEL_19:
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1009076B4(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_10100DFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  sub_10003B34C(&a11);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_1009076B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10100E02C()
{
}

__n128 sub_10100E040(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DC88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100E08C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DC88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100E0BC(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 8);
  if (*(_DWORD *)(result + 16)) {
    int v3 = *(_DWORD *)(result + 16);
  }
  else {
    int v3 = 255;
  }
  uint64_t v4 = 1;
  do
  {
    if ((v4 & v3) != 0)
    {
      unsigned __int8 v5 = 0;
      __n128 result = sub_100FF8E10(v2, *(unsigned int *)(v1 + 20), &v5, v4);
      if (result) {
        __n128 result = (*(uint64_t (**)(void, void, uint64_t, void))(**(void **)(v2 + 112) + 72))(*(void *)(v2 + 112), *(unsigned int *)(v1 + 20), v4, v5);
      }
    }
    uint64_t v4 = (2 * v4);
  }
  while (v4 && (int)v4 < 129);
  return result;
}

uint64_t sub_10100E16C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100E1AC()
{
}

void sub_10100E1B8(void ****a1)
{
  int v12 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = v2[30];
  if (v4)
  {
    uint64_t v6 = *((unsigned int *)v1 + 3);
    uint64_t v5 = *((unsigned int *)v1 + 4);
    int v7 = *((unsigned __int8 *)v1 + 20);
    do
    {
      int v8 = *((_DWORD *)v4 + 8);
      if (v8 <= (int)v3)
      {
        if (v8 >= (int)v3)
        {
          uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = CSIErrorString();
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Unable to fetch call waiting info, error=%s", (uint8_t *)&buf, 0xCu);
          }
          if (v7 != 1
            || (v5 - 21) > 1
            || (*((unsigned char *)sub_1000389F8(v2[30], v3) + 160) = 0,
                sub_100FF450C((uint64_t)v2, v3),
                (sub_100FF88A8((uint64_t)v2, v3, v6) & 1) == 0))
          {
            *(void *)&long long buf = off_101A7DD08;
            *((void *)&buf + 1) = v2;
            uint64_t v14 = v3 | (v6 << 32);
            p_long long buf = &buf;
            if (v6) {
              uint64_t v11 = v6;
            }
            else {
              uint64_t v11 = 255;
            }
            (*(void (**)(void *, uint64_t, uint64_t))(*v2[14] + 56))(v2[14], v3, v11);
            (*(void (**)(void *, uint64_t, uint64_t))(*v2[48] + 40))(v2[48], v3, v5);
            sub_10003B34C(&buf);
          }
LABEL_9:
          operator delete();
        }
        ++v4;
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_10100E45C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100E49C()
{
}

__n128 sub_10100E4B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DD08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100E4FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DD08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100E52C(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 20);
  if (v1) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 255;
  }
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 56))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), v2);
}

uint64_t sub_10100E56C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100E5AC()
{
}

void sub_10100E5B8(uint64_t **a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    unsigned int v6 = *((_DWORD *)v1 + 3);
    uint64_t v5 = *((unsigned int *)v1 + 4);
    char v7 = *((unsigned char *)v1 + 20);
    do
    {
      int v8 = *((_DWORD *)v4 + 8);
      if (v8 <= (int)v3)
      {
        if (v8 >= (int)v3)
        {
          uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Saved call waiting values successfully", buf, 2u);
          }
          int v12 = 0;
          if (v6) {
            uint64_t v13 = v6;
          }
          else {
            uint64_t v13 = 255;
          }
          do
          {
            if (((1 << v12) & v13) != 0)
            {
              uint64_t v14 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
              *(_DWORD *)long long buf = 1 << v12;
              *((unsigned char *)sub_1000BC5E4((uint64_t **)v14 + 7, 1 << v12, buf) + 32) = v7;
            }
            ++v12;
          }
          while (v12 != 8);
          sub_100FF7538((void **)v2, v3);
          sub_100FF3D90(v2, v3);
          uint8_t v15 = operator new(0x20uLL);
          *uint8_t v15 = off_101A7DD88;
          v15[1] = v2;
          *((_DWORD *)v15 + 4) = v3;
          *((_DWORD *)v15 + 5) = v6;
          *((_DWORD *)v15 + 6) = v5;
          uint64_t v18 = v15;
          (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 112) + 80))(*(void *)(v2 + 112), v3, v13, v5);
          (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 0);
          sub_10003B34C(buf);
          sub_100FFCA3C((uint64_t *)(v2 + 320));
          goto LABEL_19;
        }
        ++v4;
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v17 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_19:
  operator delete();
}

void sub_10100E878(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100E8BC()
{
}

__n128 sub_10100E8D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7DD88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100E924(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DD88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100E95C(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 20);
  if (v1) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 255;
  }
  return (*(uint64_t (**)(void, void, uint64_t, void))(**(void **)(*(void *)(a1 + 8) + 112) + 80))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), v2, *(unsigned int *)(a1 + 24));
}

uint64_t sub_10100E9A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100E9E0()
{
}

void sub_10100E9EC(uint64_t a1, char a2)
{
  unint64_t v3 = *(void *)(a1 + 32);
  if (v3 < 0x100) {
    a2 = 1;
  }
  if (v3 > 0x1FF || (a2 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 256;
  }
}

void sub_10100EA48(void **a1)
{
  uint64_t v2 = a1[2];
  unint64_t v3 = a1[1];
  uint64_t v4 = (unsigned char *)a1[3] - (unsigned char *)*a1;
  unint64_t v5 = (v2 - v3) >> 3;
  if (v5 >= v4 >> 3) {
    return;
  }
  if (v2 == v3)
  {
    int v9 = 0;
    unsigned int v6 = 0;
    goto LABEL_8;
  }
  unsigned int v6 = (char *)sub_100048350(v5);
  char v7 = a1[1];
  uint64_t v2 = a1[2];
  int v9 = &v6[8 * v8];
  uint64_t v10 = v2 - v7;
  if (v2 == v7)
  {
LABEL_8:
    uint64_t v13 = v2;
    goto LABEL_9;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 8 * (v10 >> 3);
  do
  {
    *(void *)&v6[v11] = *(void *)&v7[v11];
    v11 += 8;
  }
  while (v12 != v11);
  uint64_t v2 = a1[1];
  uint64_t v13 = a1[2];
LABEL_9:
  int64_t v14 = v13 - v2;
  uint8_t v15 = *a1;
  *a1 = v6;
  a1[1] = v6;
  a1[2] = &v6[v14];
  a1[3] = v9;
  if (v15)
  {
    operator delete(v15);
  }
}

void sub_10100EB18(uint64_t **a1)
{
  uint64_t v17 = a1;
  unsigned int v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    unsigned int v6 = *((_DWORD *)v1 + 3);
    uint64_t v5 = *((unsigned int *)v1 + 4);
    uint64_t v7 = *((unsigned int *)v1 + 5);
    int v8 = *((unsigned __int8 *)v1 + 24);
    do
    {
      int v9 = *((_DWORD *)v4 + 8);
      if (v9 <= (int)v3)
      {
        if (v9 >= (int)v3)
        {
          uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
            uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13[1] + 48))(v13[1]);
            *(_DWORD *)long long buf = 136315394;
            uint64_t v19 = v14;
            __int16 v20 = 2080;
            uint64_t v21 = CSIErrorString();
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Unable to save call waiting info to %s, error=%s", buf, 0x16u);
          }
          if (v8 == 1 && (v7 - 21) <= 1)
          {
            *((unsigned char *)sub_1000389F8(*(uint64_t **)(v2 + 240), v3) + 160) = 0;
            sub_100FF450C(v2, v3);
          }
          uint8_t v15 = operator new(0x20uLL);
          *uint8_t v15 = off_101A7DE08;
          v15[1] = v2;
          *((_DWORD *)v15 + 4) = v3;
          *((_DWORD *)v15 + 5) = v6;
          *((_DWORD *)v15 + 6) = v5;
          char v22 = v15;
          if (v6) {
            uint64_t v16 = v6;
          }
          else {
            uint64_t v16 = 255;
          }
          (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 112) + 64))(*(void *)(v2 + 112), v3, v16, v5);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, v7);
          sub_10003B34C(buf);
          sub_100FFCA3C((uint64_t *)(v2 + 320));
          goto LABEL_19;
        }
        ++v4;
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v19 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
LABEL_19:
  operator delete();
}

void sub_10100EE04(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100EE44()
{
}

__n128 sub_10100EE58(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7DE08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10100EEAC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DE08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100EEE4(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 20);
  if (v1) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 255;
  }
  return (*(uint64_t (**)(void, void, uint64_t, void))(**(void **)(*(void *)(a1 + 8) + 112) + 64))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), v2, *(unsigned int *)(a1 + 24));
}

uint64_t sub_10100EF28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100EF68()
{
}

uint64_t *sub_10100EF74(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v34 = a1;
  uint64_t v35 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v6 = *(uint64_t **)(v2 + 240);
  if (!v6)
  {
LABEL_9:
    int v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
    goto LABEL_44;
  }
  uint64_t v7 = *(uint64_t **)(v2 + 240);
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)v3) {
      break;
    }
LABEL_8:
    uint64_t v7 = (uint64_t *)*v7;
    if (!v7) {
      goto LABEL_9;
    }
  }
  if (v8 < (int)v3)
  {
    ++v7;
    goto LABEL_8;
  }
  if (v5)
  {
    uint64_t v10 = operator new(0x38uLL);
    v10[1] = 0;
    v10[2] = 0;
    *uint64_t v10 = off_101A7DF08;
    *((_WORD *)v10 + 12) = *(_WORD *)v5;
    void v10[5] = 0;
    void v10[6] = 0;
    void v10[4] = 0;
    uint64_t v11 = sub_1000389F8(v6, v3);
    uint64_t v12 = (std::__shared_weak_count *)v11[17];
    v11[16] = (uint64_t)(v10 + 3);
    v11[17] = (uint64_t)v10;
    if (v12) {
      sub_10004D2C8(v12);
    }
    *(_WORD *)long long buf = 255;
    *(_OWORD *)&uint8_t buf[8] = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    uint64_t v13 = *(void *)(v2 + 584);
    if (!v13) {
      goto LABEL_24;
    }
    uint64_t v14 = v2 + 584;
    do
    {
      int v15 = *(_DWORD *)(v13 + 32);
      BOOL v16 = v15 < (int)v3;
      if (v15 >= (int)v3) {
        uint64_t v17 = (uint64_t *)v13;
      }
      else {
        uint64_t v17 = (uint64_t *)(v13 + 8);
      }
      if (!v16) {
        uint64_t v14 = v13;
      }
      uint64_t v13 = *v17;
    }
    while (*v17);
    if (v14 != v2 + 584 && *(_DWORD *)(v14 + 32) <= (int)v3)
    {
      if (*(char *)(v14 + 71) < 0)
      {
        sub_10004FC84(&__dst, *(void **)(v14 + 48), *(void *)(v14 + 56));
      }
      else
      {
        long long __dst = *(_OWORD *)(v14 + 48);
        uint64_t v37 = *(void *)(v14 + 64);
      }
    }
    else
    {
LABEL_24:
      long long __dst = 0uLL;
      uint64_t v37 = 0;
    }
    uint64_t v18 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[16];
    uint64_t v19 = v18 + 8;
    if (*(char *)(v18 + 31) < 0) {
      operator delete(*(void **)v19);
    }
    long long v20 = __dst;
    *(void *)(v19 + 16) = v37;
    *(_OWORD *)uint64_t v19 = v20;
    uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = asString();
      uint64_t v23 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[16];
      long long v24 = (void *)(v23 + 8);
      if (*(char *)(v23 + 31) < 0) {
        long long v24 = (void *)*v24;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v24;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I CLIR network value received %s, for operator %s", buf, 0x16u);
    }
    uint64_t v25 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[16];
    uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
    if (v25)
    {
      if (v27)
      {
        sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
        uint64_t v28 = asString();
        sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
        uint64_t v29 = asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v28;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v29;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Persisting CLIR network setting with Service Status %s, Provisioned Status %s", buf, 0x16u);
      }
      uint64_t v30 = *(void *)(v2 + 184);
      uint64_t v31 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v30 + 72))(v30, v3, v31 + 16);
    }
    else if (v27)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#N Cannot persist CLIR network status because it's unavailable", buf, 2u);
    }
    sub_100FF70DC(v2, v3);
    if (*(unsigned __int8 *)(v5 + 1) > 3u)
    {
      *(void *)long long buf = off_101A7DFD8;
      *(void *)&uint8_t buf[8] = v2;
      *(void *)&uint8_t buf[16] = v3;
      *(void *)&long long v39 = buf;
      (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 112) + 168))(*(void *)(v2 + 112), v3, 0);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 1);
    }
    else
    {
      *(void *)long long buf = off_101A7DF58;
      *(void *)&uint8_t buf[8] = v2;
      *(void *)&uint8_t buf[16] = v3;
      *(void *)&long long v39 = buf;
      sub_10100F874((uint64_t)buf);
      (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 0);
    }
  }
  else
  {
    BOOL v32 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I handleCmdDriverCLIRInfo_sync: info parameter is invalid", buf, 2u);
    }
    *(void *)long long buf = off_101A7DE88;
    *(void *)&uint8_t buf[8] = v2;
    *(void *)&uint8_t buf[16] = v3;
    *(void *)&long long v39 = buf;
    (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 112) + 168))(*(void *)(v2 + 112), v3, 0);
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 384) + 40))(*(void *)(v2 + 384), v3, 1);
  }
  sub_10003B34C(buf);
LABEL_44:
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10013A778(&v35);
  return sub_100046B58((uint64_t *)&v34);
}

void sub_10100F5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  sub_100087784((uint64_t)&a18);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10100F640()
{
}

__n128 sub_10100F654(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DE88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100F6A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DE88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100F6D0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 168))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), 0);
}

uint64_t sub_10100F708(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100F748()
{
}

void sub_10100F754(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7DF08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10100F774(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7DF08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10100F7C8(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void sub_10100F7E4()
{
}

__n128 sub_10100F7F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DF58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100F844(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DF58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100F874(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  char v5 = 0;
  int v4 = 0;
  uint64_t result = sub_100FF6B60(v1, *(unsigned int *)(a1 + 16), &v4, &v5);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v1 + 112) + 160);
    return v3();
  }
  return result;
}

uint64_t sub_10100F910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100F950()
{
}

void sub_10100F960()
{
}

__n128 sub_10100F974(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7DFD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100F9C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7DFD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100F9F0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 168))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), 0);
}

uint64_t sub_10100FA28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100FA68()
{
}

void sub_10100FA74(void ****a1)
{
  uint64_t v10 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  int v4 = v2[30];
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 3);
    int v6 = *((unsigned __int8 *)v1 + 16);
    do
    {
      int v7 = *((_DWORD *)v4 + 8);
      if (v7 <= (int)v3)
      {
        if (v7 >= (int)v3)
        {
          int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = CSIErrorString();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Unable to fetch CLIR info, error=%s", (uint8_t *)&buf, 0xCu);
          }
          if (v6 != 1
            || (v5 - 21) > 1
            || (*((unsigned char *)sub_1000389F8(v2[30], v3) + 160) = 0,
                sub_100FF450C((uint64_t)v2, v3),
                (sub_100FF64B4((uint64_t)v2, v3) & 1) == 0))
          {
            *(void *)&long long buf = off_101A7E058;
            *((void *)&buf + 1) = v2;
            uint64_t v12 = v3;
            p_long long buf = &buf;
            (*(void (**)(void *, uint64_t, uint64_t))(*v2[14] + 168))(v2[14], v3, 2);
            (*(void (**)(void *, uint64_t, uint64_t))(*v2[48] + 40))(v2[48], v3, v5);
            sub_10003B34C(&buf);
          }
LABEL_9:
          operator delete();
        }
        ++v4;
      }
      int v4 = (void *)*v4;
    }
    while (v4);
  }
  int v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_10100FD00(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_10100FD40()
{
}

__n128 sub_10100FD54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10100FDA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10100FDD0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 168))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), 2);
}

uint64_t sub_10100FE08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10100FE48()
{
}

uint64_t *sub_10100FE54(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  int v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v6 = v2[30];
  if (!v6)
  {
LABEL_8:
    int v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_17;
  }
  while (1)
  {
    int v7 = *((_DWORD *)v6 + 8);
    if (v7 <= (int)v3) {
      break;
    }
LABEL_7:
    int v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (v7 < (int)v3)
  {
    ++v6;
    goto LABEL_7;
  }
  int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = sub_1000389F8(v2[30], v3);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10[1] + 48))(v10[1]);
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Received CLIP Information from %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v12 = sub_1000389F8(v2[30], v3);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (std::__shared_weak_count *)v12[11];
  v12[10] = v5;
  v12[11] = (uint64_t)v4;
  if (v13) {
    sub_10004D2C8(v13);
  }
  *(void *)&long long buf = off_101A7E0D8;
  *((void *)&buf + 1) = v2;
  uint64_t v18 = v3;
  p_long long buf = &buf;
  sub_1010101A4((uint64_t)&buf);
  (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
  sub_10003B34C(&buf);
LABEL_17:
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10013A778(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_1010100D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  sub_10003B34C(&a11);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_101010114()
{
}

__n128 sub_101010128(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E0D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101010174(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E0D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010101A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v4 = 0;
  uint64_t result = sub_100FF946C(v1, *(unsigned int *)(a1 + 16), &v4, 1);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v1 + 112) + 232);
    return v3();
  }
  return result;
}

uint64_t sub_101010238(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101010278()
{
}

void sub_101010284(void ****a1)
{
  uint64_t v12 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  int v4 = v2[30];
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 3);
    int v6 = v2[30];
    do
    {
      int v7 = *((_DWORD *)v6 + 8);
      if (v7 <= (int)v3)
      {
        if (v7 >= (int)v3)
        {
          if (*((unsigned char *)v1 + 16) == 1 && (v5 - 21) <= 1)
          {
            *((unsigned char *)sub_1000389F8(v4, v3) + 160) = 0;
            sub_100FF450C((uint64_t)v2, v3);
          }
          int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = sub_1000389F8(v2[30], v3);
            uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10[1] + 48))(v10[1]);
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Unable to retrieve CLIP info from %s", (uint8_t *)&buf, 0xCu);
          }
          *(void *)&long long buf = off_101A7E158;
          *((void *)&buf + 1) = v2;
          uint64_t v14 = v3;
          p_long long buf = &buf;
          (*(void (**)(void *, uint64_t, uint64_t))(*v2[14] + 208))(v2[14], v3, 1);
          (*(void (**)(void *, uint64_t, uint64_t))(*v2[48] + 40))(v2[48], v3, v5);
          sub_10003B34C(&buf);
LABEL_15:
          operator delete();
        }
        ++v6;
      }
      int v6 = (void *)*v6;
    }
    while (v6);
  }
  int v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_15;
}

void sub_101010528(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101010568()
{
}

__n128 sub_10101057C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010105C8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010105F8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112) + 208))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), 1);
}

uint64_t sub_101010630(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101010670()
{
}

void sub_101010680()
{
}

__n128 sub_101010694(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E1D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010106E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E1D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101010710(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 240))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

uint64_t sub_101010744(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101010784()
{
}

void sub_101010794()
{
}

__n128 sub_1010107A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010107F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101010824(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 248))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_101010858(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101010898()
{
}

uint64_t *sub_1010108A4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  int v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v6 = v2[30];
  if (!v6)
  {
LABEL_9:
    int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_23;
  }
  int v7 = v2[30];
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)v3) {
      break;
    }
LABEL_8:
    int v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_9;
    }
  }
  if (v8 < (int)v3)
  {
    ++v7;
    goto LABEL_8;
  }
  if (v5)
  {
    uint64_t v10 = sub_1000389F8(v6, v3);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = (std::__shared_weak_count *)v10[13];
    v10[12] = v5;
    v10[13] = (uint64_t)v4;
    if (v11) {
      sub_10004D2C8(v11);
    }
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received COLR status, sending kConnectedLineIdRestrictionValueAvailableNotification", (uint8_t *)&buf, 2u);
    }
    *(void *)&long long buf = off_101A7E2D8;
    *((void *)&buf + 1) = v2;
    uint64_t v18 = v3;
    p_long long buf = &buf;
    sub_101010CA0((uint64_t)&buf);
    (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
  }
  else
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I COLR is invalid, sending kConnectedLineIdRestrictionFetchError", (uint8_t *)&buf, 2u);
    }
    *(void *)&long long buf = off_101A7E358;
    *((void *)&buf + 1) = v2;
    uint64_t v18 = v3;
    p_long long buf = &buf;
    (*(void (**)(void *, uint64_t))(*v2[14] + 216))(v2[14], v3);
    (*(void (**)(void *, uint64_t, uint64_t))(*v2[48] + 40))(v2[48], v3, 1);
  }
  sub_10003B34C(&buf);
LABEL_23:
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10013A778(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_101010BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  sub_10003B34C(&a11);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_101010C10()
{
}

__n128 sub_101010C24(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E2D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101010C70(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E2D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101010CA0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v4 = 0;
  uint64_t result = sub_100FF9980(v1, *(unsigned int *)(a1 + 16), &v4);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v1 + 112) + 200);
    return v3();
  }
  return result;
}

uint64_t sub_101010D30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101010D70()
{
}

void sub_101010D80()
{
}

__n128 sub_101010D94(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101010DE0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101010E10(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 216))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_101010E44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101010E84()
{
}

void sub_101010E90(uint64_t **a1)
{
  int v8 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *(uint64_t **)(v1 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)*a1 + 3);
    do
    {
      int v5 = *((_DWORD *)v3 + 8);
      if (v5 <= (int)v2)
      {
        if (v5 >= (int)v2)
        {
          int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Failed to receive COLR status, sending kConnectedLineIdRestrictionFetchError", (uint8_t *)&buf, 2u);
          }
          *(void *)&long long buf = off_101A7E3D8;
          *((void *)&buf + 1) = v1;
          uint64_t v10 = v2;
          p_long long buf = &buf;
          (*(void (**)(void, uint64_t))(**(void **)(v1 + 112) + 216))(*(void *)(v1 + 112), v2);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, v4);
          sub_10003B34C(&buf);
LABEL_12:
          operator delete();
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_12;
}

void sub_1010110BC(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_1010110FC()
{
}

__n128 sub_101011110(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E3D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10101115C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E3D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10101118C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 216))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_1010111C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101011200()
{
}

uint64_t *sub_10101120C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v6 = v2[30];
  if (!v6)
  {
LABEL_9:
    int v9 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_23;
  }
  int v7 = v2[30];
  while (1)
  {
    int v8 = *((_DWORD *)v7 + 8);
    if (v8 <= (int)v3) {
      break;
    }
LABEL_8:
    int v7 = (void *)*v7;
    if (!v7) {
      goto LABEL_9;
    }
  }
  if (v8 < (int)v3)
  {
    ++v7;
    goto LABEL_8;
  }
  if (v5)
  {
    uint64_t v10 = sub_1000389F8(v6, v3);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = (std::__shared_weak_count *)v10[15];
    v10[14] = v5;
    v10[15] = (uint64_t)v4;
    if (v11) {
      sub_10004D2C8(v11);
    }
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received CNAP status, sending kConnectedLineIdRestrictionValueAvailableNotification", (uint8_t *)&buf, 2u);
    }
    *(void *)&long long buf = off_101A7E458;
    *((void *)&buf + 1) = v2;
    uint64_t v18 = v3;
    p_long long buf = &buf;
    sub_101011610((uint64_t)&buf);
    (*(void (**)(void *, uint64_t, void))(*v2[48] + 40))(v2[48], v3, 0);
  }
  else
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v3);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I CNAP is invalid, sending kCallingNamePresentationValueFetchError", (uint8_t *)&buf, 2u);
    }
    *(void *)&long long buf = off_101A7E4D8;
    *((void *)&buf + 1) = v2;
    uint64_t v18 = v3;
    p_long long buf = &buf;
    (*(void (**)(void *, uint64_t))(*v2[14] + 256))(v2[14], v3);
    (*(void (**)(void *, uint64_t, uint64_t))(*v2[48] + 40))(v2[48], v3, 1);
  }
  sub_10003B34C(&buf);
LABEL_23:
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10013A778(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_101011540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  sub_10003B34C(&a11);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_101011580()
{
}

__n128 sub_101011594(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010115E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101011610(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v4 = 2;
  sub_100FFAD78(v1, *(unsigned int *)(a1 + 16), &v4);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 112) + 264);

  return v2();
}

uint64_t sub_1010116A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010116E4()
{
}

void sub_1010116F4()
{
}

__n128 sub_101011708(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E4D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101011754(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E4D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101011784(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 256))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_1010117C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101011800()
{
}

void sub_10101180C(uint64_t **a1)
{
  int v8 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *(uint64_t **)(v1 + 240);
  if (v3)
  {
    uint64_t v4 = *((unsigned int *)*a1 + 3);
    do
    {
      int v5 = *((_DWORD *)v3 + 8);
      if (v5 <= (int)v2)
      {
        if (v5 >= (int)v2)
        {
          int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Failed to receive CNAP status, sending kCallingNamePresentationValueFetchError", (uint8_t *)&buf, 2u);
          }
          *(void *)&long long buf = off_101A7E558;
          *((void *)&buf + 1) = v1;
          uint64_t v10 = v2;
          p_long long buf = &buf;
          (*(void (**)(void, uint64_t))(**(void **)(v1 + 112) + 256))(*(void *)(v1 + 112), v2);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 384) + 40))(*(void *)(v1 + 384), v2, v4);
          sub_10003B34C(&buf);
LABEL_12:
          operator delete();
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  int v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&buf, 0xCu);
  }
  goto LABEL_12;
}

void sub_101011A40(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  operator delete();
}

void sub_101011A80()
{
}

__n128 sub_101011A94(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7E558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101011AE0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101011B10(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 112) + 256))(*(void *)(*(void *)(a1 + 8) + 112), *(unsigned int *)(a1 + 16));
}

uint64_t sub_101011B4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101011B8C()
{
}

void sub_101011B98(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *((unsigned int *)*a1 + 2);
  uint64_t v4 = *(uint64_t **)(v2 + 240);
  if (v4)
  {
    int v5 = *((unsigned __int8 *)v1 + 12);
    uint64_t v6 = *((unsigned int *)v1 + 4);
    uint64_t v7 = *((unsigned int *)v1 + 5);
    int v8 = *(uint64_t **)(v2 + 240);
    uint64_t v9 = *((unsigned int *)v1 + 6);
    do
    {
      int v10 = *((_DWORD *)v8 + 8);
      if (v10 <= (int)v3)
      {
        if (v10 >= (int)v3)
        {
          if (sub_1000389F8(v4, v3)[1])
          {
            if (!sub_100FF6754(v2)
              || sub_1000389F8(*(uint64_t **)(v2 + 240), v3)[1] == *(void *)(v2 + 152))
            {
              uint64_t v13 = sub_1000389F8(*(uint64_t **)(v2 + 240), v3);
              (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t, uint64_t, uint64_t))(*(void *)v13[1] + 72))(v13[1], v3, v5 != 0, v6, v7, v9);
            }
            else
            {
              uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I VoLTE call is active, ignoring request to activate Call Forwarding because it would trigger CSFB", buf, 2u);
              }
            }
          }
LABEL_9:
          operator delete();
        }
        ++v8;
      }
      int v8 = (uint64_t *)*v8;
    }
    while (v8);
  }
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v15 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
  }
  goto LABEL_9;
}

void sub_101011DDC()
{
}

void sub_101011E08(void ****a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Migrating Supplementary services preferences from slot %s -> %s", buf, 0x16u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(unsigned char *__return_ptr))(*v2[23] + 40))(buf);
  uint64_t v4 = *v2[23];
  if (*(void *)buf) {
    (*(void (**)(void))(v4 + 48))();
  }
  else {
    (*(void (**)(void))(v4 + 56))();
  }
  uint64_t v5 = *((unsigned int *)v1 + 3);
  uint64_t v14 = *(void *)buf;
  uint64_t v15 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
  }
  sub_100FF3570(v2, v5, &v14);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*v2[23] + 64))(&v12);
  uint64_t v6 = *v2[23];
  if (v12) {
    (*(void (**)(void))(v6 + 72))();
  }
  else {
    (*(void (**)(void))(v6 + 80))();
  }
  uint64_t v7 = *((unsigned int *)v1 + 3);
  uint64_t v10 = v12;
  uint64_t v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100FF3840(v2, v7, &v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
  unsigned __int16 v8 = (*(uint64_t (**)(void *, void))(*v2[23] + 88))(v2[23], *((unsigned int *)v1 + 2));
  if (v8 >= 0x100u) {
    (*(void (**)(void *, void, BOOL))(*v2[23] + 96))(v2[23], *((unsigned int *)v1 + 3), v8 != 0);
  }
  else {
    (*(void (**)(void *, void))(*v2[23] + 104))(v2[23], *((unsigned int *)v1 + 3));
  }
  sub_100FF3B10(v2, *((unsigned int *)v1 + 3));
  unsigned __int16 v9 = (*(uint64_t (**)(void *, void))(*v2[23] + 112))(v2[23], *((unsigned int *)v1 + 2));
  if (v9 >= 0x100u) {
    (*(void (**)(void *, void, BOOL))(*v2[23] + 120))(v2[23], *((unsigned int *)v1 + 3), v9 != 0);
  }
  else {
    (*(void (**)(void *, void))(*v2[23] + 128))(v2[23], *((unsigned int *)v1 + 3));
  }
  sub_100FF3FF4((uint64_t)v2, *((unsigned int *)v1 + 3));
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  operator delete();
}

void sub_101012220(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  operator delete();
}

unsigned char *sub_1010122A4@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *a1;
  if (v4 > 7) {
    int v5 = 0;
  }
  else {
    int v5 = dword_1015AD438[v4];
  }
  *(_DWORD *)a2 = v5;
  if (*((char *)a1 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a2 + 8), *((void **)a1 + 1), *((void *)a1 + 2));
  }
  else
  {
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 2);
    *(void *)(a2 + 24) = *((void *)a1 + 3);
  }
  __n128 result = (unsigned char *)(a2 + 32);
  if (*((char *)a1 + 55) < 0) {
    return sub_10004FC84(result, *((void **)a1 + 4), *((void *)a1 + 5));
  }
  *(_OWORD *)__n128 result = *((_OWORD *)a1 + 2);
  *(void *)(a2 + 48) = *((void *)a1 + 6);
  return result;
}

void sub_101012350(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10101236C@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  uint64_t v48 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  memset(v35, 0, sizeof(v35));
  long long v34 = 0u;
  sub_10004BD84((uint64_t)&v34);
  sub_100058DB0(__p, "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
  sub_1010E716C((uint64_t)&v34, (uint64_t)__p);
  if (SBYTE7(v19[0]) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "<imdn xmlns=\"urn:ietf:params:xml:ns:imdn\">");
  sub_1010E716C((uint64_t)&v34, (uint64_t)__p);
  if (SBYTE7(v19[0]) < 0) {
    operator delete(__p[0]);
  }
  std::operator+<char>();
  uint64_t v4 = std::string::append(&v33, "</message-id>", 0xDuLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  *(void *)&v19[0] = *((void *)&v4->__r_.__value_.__l + 2);
  *(_OWORD *)long long __p = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  sub_1010E716C((uint64_t)&v34, (uint64_t)__p);
  if (SBYTE7(v19[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  std::operator+<char>();
  uint64_t v6 = std::string::append(&v33, "</datetime>", 0xBuLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  *(void *)&v19[0] = *((void *)&v6->__r_.__value_.__l + 2);
  *(_OWORD *)long long __p = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  sub_1010E716C((uint64_t)&v34, (uint64_t)__p);
  if (SBYTE7(v19[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (*a1 == 2)
  {
    sub_100058DB0(__p, " <display-notification>\n  <status>\n\t<displayed/>\n </status>\n </display-notification>");
    sub_1010E716C((uint64_t)&v34, (uint64_t)__p);
  }
  else
  {
    if (*a1) {
      goto LABEL_19;
    }
    sub_100058DB0(__p, " <delivery-notification>\n  <status>\n    <delivered/>\n </status>\n </delivery-notification>");
    sub_1010E716C((uint64_t)&v34, (uint64_t)__p);
  }
  if (SBYTE7(v19[0]) < 0) {
    operator delete(__p[0]);
  }
LABEL_19:
  sub_10004B96C(v35, (uint64_t)"</imdn>", 7);
  memset(&v33, 0, sizeof(v33));
  sub_10004BC98((uint64_t)&v35[1], &v33);
  uint64_t v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)long long v20 = 0u;
  long long v21 = 0u;
  memset(v19, 0, sizeof(v19));
  *(_OWORD *)long long __p = 0u;
  sub_10004BD84((uint64_t)__p);
  sub_1000BE8E8((uint64_t)__p, "Content-Type", off_101A8C268);
  sub_1000BE8E8((uint64_t)__p, "Content-Disposition", &off_101A7E5C8);
  std::string::size_type size = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v33.__r_.__value_.__l.__size_;
  }
  v16[0] = (void *)size;
  sub_1008DD444((uint64_t)__p, "Content-Length", v16);
  sub_10004B96C(v19, (uint64_t)"\r\n", 2);
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned __int16 v9 = &v33;
  }
  else {
    unsigned __int16 v9 = (std::string *)v33.__r_.__value_.__r.__words[0];
  }
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v10 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v10 = v33.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v19, (uint64_t)v9, v10);
  sub_10004BC98((uint64_t)v19 + 8, v16);
  sub_100CC8650(a2, (uint64_t)v16);
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  *(void **)((char *)__p
  xpc_object_t v14 = v12;
  *(void *)&v19[0] = v12;
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  *(void *)&long long v34 = v11;
  *(void *)((char *)&v35[-2] + *(v11 - 3)) = v13;
  v35[0] = v14;
  if (SHIBYTE(v37) < 0) {
    operator delete(*((void **)&v36 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10101287C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,char a60)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a60);
  _Unwind_Resume(a1);
}

void sub_101012938(int *a1@<X0>, uint64_t a2@<X8>)
{
  int v3 = *a1;
  if (*a1)
  {
    long long v43 = 0;
    long long v44 = 0;
    unint64_t v45 = 0;
    if (v3)
    {
      sub_100058DB0(__p, "positive-delivery");
      long long v5 = v44;
      if ((unint64_t)v44 >= v45)
      {
        unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44 - (char *)v43) >> 3);
        unint64_t v8 = v7 + 1;
        if (v7 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3) > v8) {
          unint64_t v8 = 0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v45 - (void)v43) >> 3) >= 0x555555555555555) {
          unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v9 = v8;
        }
        uint64_t v48 = &v45;
        if (v9) {
          std::string::size_type v10 = (char *)sub_10004812C((uint64_t)&v45, v9);
        }
        else {
          std::string::size_type v10 = 0;
        }
        std::string::size_type v11 = (std::string::size_type)&v10[24 * v7];
        v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
        v46.__r_.__value_.__l.__size_ = v11;
        long long v47 = &v10[24 * v9];
        long long v12 = *(_OWORD *)__p;
        *(void *)(v11 + 16) = v42;
        *(_OWORD *)std::string::size_type v11 = v12;
        __p[1] = 0;
        std::string::size_type v42 = 0;
        __p[0] = 0;
        v46.__r_.__value_.__r.__words[2] = v11 + 24;
        sub_100048204((uint64_t *)&v43, &v46);
        xpc_object_t v13 = v44;
        sub_100048174((uint64_t)&v46);
        long long v44 = v13;
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v6 = *(_OWORD *)__p;
        v44->__r_.__value_.__r.__words[2] = v42;
        *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
        long long v44 = v5 + 1;
      }
      int v3 = *a1;
    }
    if ((v3 & 2) != 0)
    {
      sub_100058DB0(__p, "display");
      xpc_object_t v14 = v44;
      if ((unint64_t)v44 >= v45)
      {
        unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44 - (char *)v43) >> 3);
        unint64_t v17 = v16 + 1;
        if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3) > v17) {
          unint64_t v17 = 0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v45 - (void)v43) >> 3) >= 0x555555555555555) {
          unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v18 = v17;
        }
        uint64_t v48 = &v45;
        if (v18) {
          uint64_t v19 = (char *)sub_10004812C((uint64_t)&v45, v18);
        }
        else {
          uint64_t v19 = 0;
        }
        std::string::size_type v20 = (std::string::size_type)&v19[24 * v16];
        v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
        v46.__r_.__value_.__l.__size_ = v20;
        long long v47 = &v19[24 * v18];
        long long v21 = *(_OWORD *)__p;
        *(void *)(v20 + 16) = v42;
        *(_OWORD *)std::string::size_type v20 = v21;
        __p[1] = 0;
        std::string::size_type v42 = 0;
        __p[0] = 0;
        v46.__r_.__value_.__r.__words[2] = v20 + 24;
        sub_100048204((uint64_t *)&v43, &v46);
        long long v22 = v44;
        sub_100048174((uint64_t)&v46);
        long long v44 = v22;
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v15 = *(_OWORD *)__p;
        v44->__r_.__value_.__r.__words[2] = v42;
        *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v15;
        long long v44 = v14 + 1;
      }
      int v3 = *a1;
    }
    if ((v3 & 4) != 0)
    {
      sub_100058DB0(__p, "negative-delivery");
      long long v23 = v44;
      if ((unint64_t)v44 >= v45)
      {
        unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44 - (char *)v43) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3) > v26) {
          unint64_t v26 = 0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v45 - (void)v43) >> 3) >= 0x555555555555555) {
          unint64_t v27 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v27 = v26;
        }
        uint64_t v48 = &v45;
        if (v27) {
          long long v28 = (char *)sub_10004812C((uint64_t)&v45, v27);
        }
        else {
          long long v28 = 0;
        }
        std::string::size_type v29 = (std::string::size_type)&v28[24 * v25];
        v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
        v46.__r_.__value_.__l.__size_ = v29;
        long long v47 = &v28[24 * v27];
        long long v30 = *(_OWORD *)__p;
        *(void *)(v29 + 16) = v42;
        *(_OWORD *)std::string::size_type v29 = v30;
        __p[1] = 0;
        std::string::size_type v42 = 0;
        __p[0] = 0;
        v46.__r_.__value_.__r.__words[2] = v29 + 24;
        sub_100048204((uint64_t *)&v43, &v46);
        long long v31 = v44;
        sub_100048174((uint64_t)&v46);
        long long v44 = v31;
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v24 = *(_OWORD *)__p;
        v44->__r_.__value_.__r.__words[2] = v42;
        *(_OWORD *)&v23->__r_.__value_.__l.__data_ = v24;
        long long v44 = v23 + 1;
      }
      int v3 = *a1;
    }
    if ((v3 & 8) != 0)
    {
      sub_100058DB0(__p, "interworking");
      uint64_t v32 = v44;
      if ((unint64_t)v44 >= v45)
      {
        unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44 - (char *)v43) >> 3);
        unint64_t v35 = v34 + 1;
        if (v34 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3) > v35) {
          unint64_t v35 = 0x5555555555555556 * ((uint64_t)(v45 - (void)v43) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v45 - (void)v43) >> 3) >= 0x555555555555555) {
          unint64_t v36 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v36 = v35;
        }
        uint64_t v48 = &v45;
        if (v36) {
          long long v37 = (char *)sub_10004812C((uint64_t)&v45, v36);
        }
        else {
          long long v37 = 0;
        }
        std::string::size_type v38 = (std::string::size_type)&v37[24 * v34];
        v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
        v46.__r_.__value_.__l.__size_ = v38;
        long long v47 = &v37[24 * v36];
        long long v39 = *(_OWORD *)__p;
        *(void *)(v38 + 16) = v42;
        *(_OWORD *)std::string::size_type v38 = v39;
        __p[1] = 0;
        std::string::size_type v42 = 0;
        __p[0] = 0;
        v46.__r_.__value_.__r.__words[2] = v38 + 24;
        sub_100048204((uint64_t *)&v43, &v46);
        long long v40 = v44;
        sub_100048174((uint64_t)&v46);
        long long v44 = v40;
        if (SHIBYTE(v42) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v33 = *(_OWORD *)__p;
        v44->__r_.__value_.__r.__words[2] = v42;
        *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v33;
        long long v44 = v32 + 1;
      }
    }
    sub_100062B40(v43, v44, ",", 1uLL, &v46);
    sub_100CC8650((void *)a2, (uint64_t)&v46);
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    v46.__r_.__value_.__r.__words[0] = (std::string::size_type)&v43;
    sub_100047F64((void ***)&v46);
  }
  else
  {
    *(_DWORD *)(a2 + 32) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
}

void sub_101012E3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  long long __p = &a16;
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_101012EBC(void *a1)
{
  long long v11 = 0u;
  long long v12 = 0u;
  sub_100058DB0(v7, "imdn.Disposition-Notification");
  if (SHIBYTE(v8) < 0)
  {
    sub_10004FC84(__p, v7[0], (unint64_t)v7[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v7;
    uint64_t v10 = v8;
  }
  sub_1010E7200(a1, (uint64_t)__p, (uint64_t)&v11);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[0]);
  }
  if (!BYTE8(v12)) {
    return 0xFFFFFFFFLL;
  }
  sub_100058DB0(__p, "positive-delivery");
  BOOL v2 = sub_1010E6188((uint64_t)&v11, (long long *)__p);
  BOOL v3 = v2;
  if (SHIBYTE(v10) < 0)
  {
    operator delete(__p[0]);
    if (v3) {
      goto LABEL_11;
    }
LABEL_14:
    if (!BYTE8(v12)) {
      sub_10016C840();
    }
    sub_100058DB0(__p, "display");
    BOOL v5 = sub_1010E6188((uint64_t)&v11, (long long *)__p);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
    if (v5) {
      uint64_t v4 = 2;
    }
    else {
      uint64_t v4 = 0xFFFFFFFFLL;
    }
    goto LABEL_20;
  }
  if (!v2) {
    goto LABEL_14;
  }
LABEL_11:
  uint64_t v4 = 0;
LABEL_20:
  if (BYTE8(v12) && SBYTE7(v12) < 0) {
    operator delete((void *)v11);
  }
  return v4;
}

void sub_10101300C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v21 - 24))
  {
    if (*(char *)(v21 - 25) < 0) {
      operator delete(*(void **)(v21 - 48));
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_101013080(void *a1@<X0>, uint64_t a2@<X8>)
{
  long long v10 = 0u;
  long long v11 = 0u;
  sub_100058DB0(v6, "imdn.Message-ID");
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(__p, v6[0], (unint64_t)v6[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v6;
    uint64_t v9 = v7;
  }
  sub_1010E7200(a1, (uint64_t)__p, (uint64_t)&v10);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  if (BYTE8(v11))
  {
    if (SBYTE7(v11) < 0)
    {
      sub_10004FC84((unsigned char *)a2, (void *)v10, *((unint64_t *)&v10 + 1));
      int v4 = BYTE8(v11);
      int v5 = SBYTE7(v11);
      *(unsigned char *)(a2 + 24) = 1;
      if (v4)
      {
        if (v5 < 0) {
          operator delete((void *)v10);
        }
      }
    }
    else
    {
      *(_OWORD *)a2 = v10;
      *(void *)(a2 + 16) = v11;
      *(unsigned char *)(a2 + 24) = 1;
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
}

void sub_101013180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(unsigned char *)(v21 - 24))
  {
    if (*(char *)(v21 - 25) < 0) {
      operator delete(*(void **)(v21 - 48));
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010131D0(uint64_t **a1, long long *a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  xpc_object_t v13 = a2;
  uint64_t v8 = sub_101013500(a1, (void **)a2, (uint64_t)&unk_10144E20E, &v13);
  *(_OWORD *)long long __p = *(_OWORD *)a5;
  uint64_t v12 = *(void *)(a5 + 16);
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  *(void *)a5 = 0;
  uint64_t v9 = sub_101013280((unint64_t *)v8 + 7, a3, a4, (__n128 *)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v9;
}

void sub_101013264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101013280(unint64_t *a1, unint64_t a2, unint64_t a3, __n128 *a4)
{
  unint64_t v12 = a2;
  if (a2 - 1 < a3)
  {
    if (a1[3] && *a1 != a3)
    {
      *a1 = 0;
      uint64_t v7 = a1 + 2;
      sub_10026CF54((uint64_t)(a1 + 1), (void *)a1[2]);
      a1[1] = (unint64_t)v7;
      a1[3] = 0;
      *uint64_t v7 = 0;
    }
    *a1 = a3;
    xpc_object_t v13 = &v12;
    uint64_t v8 = sub_100372E78((uint64_t **)a1 + 1, &v12, (uint64_t)&unk_10144E20E, (uint64_t **)&v13);
    sub_10005C9A4((uint64_t)(v8 + 5), a4);
    uint64_t v9 = (uint64_t *)*a1;
    if (!*a1)
    {
      int v10 = 1;
      return v9 | v10;
    }
    int v10 = 1;
    if ((uint64_t *)a1[3] != v9) {
      goto LABEL_13;
    }
    goto LABEL_10;
  }
  if (!*a1)
  {
    int v10 = 0;
LABEL_13:
    LODWORD(v9) = 0;
    return v9 | v10;
  }
  int v10 = 0;
  LODWORD(v9) = 0;
  if (a1[3] == *a1) {
LABEL_10:
  }
    LODWORD(v9) = 256;
  return v9 | v10;
}

void sub_101013390(uint64_t **a1@<X0>, void **a2@<X1>, unint64_t *a3@<X8>)
{
  int v5 = sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v5
    && (v6 = (uint64_t *)v5, uint64_t v9 = v5[7], v7 = (unint64_t **)(v5 + 7), (v8 = v9) != 0)
    && (void *)v6[10] == v8)
  {
    uint64_t v10 = (uint64_t)(v7 - 3);
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    sub_101013438(v7, a3);
    sub_10006C514(a1, v6);
    sub_10026CF00(v10);
    operator delete(v6);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

unint64_t **sub_101013438@<X0>(unint64_t **result@<X0>, unint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  BOOL v2 = (unint64_t **)result[1];
  BOOL v3 = result + 2;
  if (v2 != result + 2)
  {
    do
    {
      int v5 = v2[5];
      long long v6 = v2[6];
      uint64_t v10 = a2;
      while (v5 != v6)
      {
        __n128 result = sub_100240714(&v10, v5);
        int v5 = (unint64_t *)((char *)v5 + 1);
      }
      uint64_t v7 = v2[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = (unint64_t **)v7;
          uint64_t v7 = (unint64_t *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (unint64_t **)v2[2];
          BOOL v9 = *v8 == (unint64_t *)v2;
          BOOL v2 = v8;
        }
        while (!v9);
      }
      BOOL v2 = v8;
    }
    while (v8 != v3);
  }
  return result;
}

void sub_1010134E4(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_101013500(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  long long v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_1010135B8((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_101013660((uint64_t)v10, 0);
  }
  return v7;
}

double sub_1010135B8@<D0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  long long v6 = (char *)operator new(0x58uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t v7 = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t v7 = v9;
  }
  double result = 0.0;
  *(_OWORD *)(v6 + 72) = 0u;
  uint64_t v11 = v6 + 72;
  *((_OWORD *)v11 - 1) = 0u;
  *((void *)v11 - 1) = v11;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_101013648(_Unwind_Exception *a1)
{
  sub_101013660(v1, 0);
  _Unwind_Resume(a1);
}

void sub_101013660(uint64_t a1, uint64_t a2)
{
  BOOL v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10026CF00((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void PhonebookHandler::create()
{
}

void sub_1010137B0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t PhonebookHandler::PhonebookHandler(uint64_t a1, uint64_t a2, dispatch_object_t *a3, uint64_t *a4)
{
  *(void *)a1 = off_101A7E5E0;
  uint64_t v8 = (void *)(a1 + 8);
  long long v9 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v47, kCtLoggingSystemName, "pb");
  if (v9)
  {
    dispatch_retain(v9);
    uint64_t v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v9);
    dispatch_retain(v9);
    uint64_t v11 = dispatch_queue_create_with_target_V2("PhonebookHandler", v10, v9);
  }
  else
  {
    unint64_t v12 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    uint64_t v11 = dispatch_queue_create("PhonebookHandler", v12);
  }
  xpc_object_t v13 = v11;
  void *v8 = 0;
  v8[1] = 0;
  *(void *)(a1 + 24) = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v9)
  {
    dispatch_release(v9);
    dispatch_release(v9);
    dispatch_release(v9);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v45, &v47);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v45);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v45);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v47);
  if (v9) {
    dispatch_release(v9);
  }
  v46[0] = off_101999E18;
  v46[1] = sub_101013FEC;
  v46[3] = v46;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v14) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v46);
  *(void *)a1 = off_101A7E5E0;
  *(void *)(a1 + 56) = *(void *)a2;
  uint64_t v15 = *(void *)(a2 + 8);
  *(void *)(a1 + 64) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v16 = *a4;
  unint64_t v17 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  (*(void (**)(OsLogContext *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v16 + 24))(&v47, v16, &object);
  *(OsLogContext *)(a1 + 72) = v47;
  v47.var0 = 0;
  v47.var1.fRef = 0;
  if (object) {
    dispatch_release(object);
  }
  Registry::getCommandDriversFactory((uint64_t *)&v47, *(Registry **)a2);
  var0 = v47.var0;
  uint64_t v19 = *(NSObject **)(a1 + 24);
  dispatch_object_t v43 = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  (*(void (**)(char *, dispatch_object_t *))(*(void *)var0 + 56))(var0, &v43);
  if (v43) {
    dispatch_release(v43);
  }
  std::string::size_type v20 = a3;
  if (v47.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v47.var1.fRef);
  }
  *(void *)(a1 + 128) = 0;
  uint64_t v21 = (uint64_t **)(a1 + 128);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = a1 + 128;
  v47.var0 = 0;
  v47.var1.fRef = 0;
  uint64_t v48 = 0;
  (*(void (**)(OsLogContext *__return_ptr))(*(void *)*a4 + 16))(&v47);
  long long v22 = v47.var0;
  if ((OSSharedRef<os_log_s> *)v47.var0 != &v47.var1)
  {
    do
    {
      long long v23 = *v21;
      long long v24 = (uint64_t **)(a1 + 128);
      unint64_t v25 = (uint64_t **)(a1 + 128);
      if (*v21)
      {
        int v26 = *((_DWORD *)v22 + 8);
        do
        {
          while (1)
          {
            unint64_t v25 = (uint64_t **)v23;
            int v27 = *((_DWORD *)v23 + 8);
            if (v27 <= v26) {
              break;
            }
            long long v23 = *v25;
            long long v24 = v25;
            if (!*v25) {
              goto LABEL_42;
            }
          }
          if (v27 >= v26)
          {
            long long v30 = (char *)v25;
            goto LABEL_45;
          }
          long long v23 = v25[1];
        }
        while (v23);
        long long v24 = v25 + 1;
      }
LABEL_42:
      long long v30 = (char *)operator new(0x58uLL);
      *((_DWORD *)v30 + 8) = *((_DWORD *)v22 + 8);
      *(_OWORD *)(v30 + 40) = 0u;
      *(_OWORD *)(v30 + 56) = 0u;
      *(_OWORD *)(v30 + 72) = 0u;
      *(void *)long long v30 = 0;
      *((void *)v30 + 1) = 0;
      *((void *)v30 + 2) = v25;
      *long long v24 = (uint64_t *)v30;
      uint64_t v28 = **(void **)(a1 + 120);
      std::string::size_type v29 = (uint64_t *)v30;
      if (v28)
      {
        *(void *)(a1 + 120) = v28;
        std::string::size_type v29 = *v24;
      }
      sub_100046C90(*(uint64_t **)(a1 + 128), v29);
      ++*(void *)(a1 + 136);
LABEL_45:
      uint64_t v32 = *((void *)v22 + 5);
      uint64_t v31 = *((void *)v22 + 6);
      if (v31) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
      }
      long long v33 = (std::__shared_weak_count *)*((void *)v30 + 10);
      *((void *)v30 + 9) = v32;
      *((void *)v30 + 10) = v31;
      if (v33) {
        sub_10004D2C8(v33);
      }
      unint64_t v34 = (OsLogContext *)*((void *)v22 + 1);
      if (v34)
      {
        do
        {
          unint64_t v35 = v34;
          unint64_t v34 = (OsLogContext *)v34->var0;
        }
        while (v34);
      }
      else
      {
        do
        {
          unint64_t v35 = (OsLogContext *)*((void *)v22 + 2);
          BOOL v36 = v35->var0 == v22;
          long long v22 = (char *)v35;
        }
        while (!v36);
      }
      long long v22 = (char *)v35;
    }
    while (v35 != (OsLogContext *)&v47.var1);
  }
  sub_10005D0E4((uint64_t)&v47, (void *)v47.var1.fRef);
  sub_10035D650((uint64_t *)(a1 + 144), (uint64_t)&rest::kDefaultRegistrationStatuses);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  *(void *)(a1 + 184) = 0;
  sub_100058DB0(&__p, "PhonebookHandler");
  long long v37 = *(NSObject **)(a1 + 24);
  long long v40 = v37;
  if (v37) {
    dispatch_retain(v37);
  }
  long long v39 = *v20;
  if (*v20) {
    dispatch_retain(*v20);
  }
  ctu::RestModule::RestModule();
  if (v39) {
    dispatch_release(v39);
  }
  if (v40) {
    dispatch_release(v40);
  }
  if (v42 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  return a1;
}

void sub_101013E14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, dispatch_object_t a19, dispatch_object_t a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
}

const char *sub_101013FEC(int a1)
{
  uint64_t v1 = "pb.?";
  if (a1 == 2) {
    uint64_t v1 = "pb.2";
  }
  if (a1 == 1) {
    return "pb.1";
  }
  else {
    return v1;
  }
}

void sub_101014018(uint64_t a1)
{
  *(void *)a1 = off_101A7E5E0;
  sub_100087F94(a1 + 224, *(void **)(a1 + 232));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 216);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 200);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000346F8(a1 + 168, *(void **)(a1 + 176));
  sub_1000346F8(a1 + 144, *(void **)(a1 + 152));
  sub_101017820(*(char **)(a1 + 128));
  int v4 = *(std::__shared_weak_count **)(a1 + 112);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5) {
    sub_10004D2C8(v5);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 80);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 64);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  PhonebookInterface::~PhonebookInterface((PhonebookInterface *)a1);
}

void sub_101014120(uint64_t a1)
{
  sub_101014018(a1);

  operator delete();
}

void sub_101014158(uint64_t a1, dispatch_object_t *a2)
{
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101014258(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  (*(void (**)(uint64_t *__return_ptr))(***(void ***)a1 + 8))(&v17);
  if (v17 && isReal())
  {
    uint64_t v16 = 0;
    BOOL v5 = a2 == 2;
    *(void *)long long buf = CFPreferencesCopyValue(*(CFStringRef *)(*(void *)(a1 + 8) + 8 * v5), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_100225AE0(&v16, (CFTypeRef *)buf);
    if (v16) {
      long long v6 = sub_1000810B8;
    }
    else {
      long long v6 = 0;
    }
    if (v6)
    {
      uint64_t v15 = 0;
      *(void *)long long buf = CFPreferencesCopyValue(*(CFStringRef *)(*(void *)(a1 + 16) + 8 * v5), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_100225AE0(&v15, (CFTypeRef *)buf);
      xpc_object_t v14 = 0;
      *(void *)long long buf = CFPreferencesCopyValue(*(CFStringRef *)(*(void *)(a1 + 24) + 8 * v5), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_100225AE0(&v14, (CFTypeRef *)buf);
      if (v15) {
        uint64_t v7 = sub_1000810B8;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v7 || (v14 ? (uint64_t v8 = sub_1000810B8) : (uint64_t v8 = 0), v8))
      {
        (*(void (**)(void, uint64_t, const __CFString *))(***(void ***)(a1 + 32) + 16))(**(void **)(a1 + 32), v17 + 24, @"PNRPhoneNumber");
        (*(void (**)(void, uint64_t, const __CFString *, const void *, const __CFString *, void, uint64_t, void))(***(void ***)(a1 + 32) + 16))(**(void **)(a1 + 32), v17 + 24, @"CopiedSIMPhoneNumber", v14, @"phonebook", 0, 1, 0);
        long long v9 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = subscriber::asString();
          uint64_t v11 = (const char *)(v17 + 24);
          uint64_t v12 = *(unsigned __int8 *)(v17 + 47);
          int v13 = (char)v12;
          if ((v12 & 0x80u) != 0) {
            uint64_t v12 = *(void *)(v17 + 32);
          }
          if (v13 < 0) {
            uint64_t v11 = *(const char **)(v17 + 24);
          }
          if (!v12) {
            uint64_t v11 = "<invalid>";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v10;
          __int16 v20 = 2080;
          uint64_t v21 = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I migrated phonebook storage for slot: %s, persona: %s", buf, 0x16u);
        }
      }
      CFPreferencesSetValue(*(CFStringRef *)(*(void *)(a1 + 16) + 8 * v5), 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      CFPreferencesSetValue(*(CFStringRef *)(*(void *)(a1 + 48) + 8 * v5), 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      CFPreferencesSetValue(*(CFStringRef *)(*(void *)(a1 + 8) + 8 * v5), 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      CFPreferencesSetValue(*(CFStringRef *)(*(void *)(a1 + 24) + 8 * v5), 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_1000558F4(&v14);
      sub_1000558F4(&v15);
    }
    sub_1000558F4(&v16);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
}

void sub_1010145F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, const void *a11, const void *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void sub_101014648(uint64_t a1, uint64_t a2, dispatch_object_t *a3)
{
  BOOL v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10101476C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10101484C(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  uint64_t v1 = v45;
  uint64_t v2 = v46;
  if (v45 != v46)
  {
    int v3 = v47;
    while ((v47(*v1) & 1) == 0)
    {
      if (++v1 == v46)
      {
        uint64_t v1 = v46;
        break;
      }
    }
    char v42 = v46;
    if (v1 != v46)
    {
      uint64_t v4 = a1 + 120;
      BOOL v5 = (uint64_t *)(a1 + 176);
      uint64_t v6 = (uint64_t *)(a1 + 152);
      do
      {
        uint64_t v7 = *v1;
        uint64_t v43 = 0;
        long long v44 = 0;
        sub_100039CB8(&v43, v4, v7);
        uint64_t v8 = v43;
        if (v43)
        {
          long long v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
          uint64_t v10 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            sub_100039C68(v4, v7);
            uint64_t v11 = asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I PhoneBook state: %s", buf, 0xCu);
          }
          (*(void (**)(uint64_t))(*(void *)v8 + 264))(v8);
          uint64_t v12 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = sub_100039C68(v4, v7);
            xpc_object_t v14 = (const char *)(v13 + 1);
            if (!v13) {
              xpc_object_t v14 = (const char *)&kInvalidPersonalityId;
            }
            uint64_t v15 = *((unsigned __int8 *)v14 + 23);
            BOOL v16 = (v15 & 0x80u) != 0;
            if ((v15 & 0x80u) != 0) {
              uint64_t v15 = *((void *)v14 + 1);
            }
            if (v16) {
              xpc_object_t v14 = *(const char **)v14;
            }
            if (!v15) {
              xpc_object_t v14 = "<invalid>";
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v14;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I associated persona: %s", buf, 0xCu);
            uint64_t v12 = *v9;
          }
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = (CSIPhoneNumber *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 192))(v8);
            CSIPhoneNumber::getFullNumber((uint64_t *)buf, v17);
            unint64_t v18 = buf;
            if (v49 < 0) {
              unint64_t v18 = *(unsigned char **)buf;
            }
            *(_DWORD *)int v50 = 136315138;
            __int16 v51 = v18;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I copied SIM phone number: %s", v50, 0xCu);
            if (v49 < 0) {
              operator delete(*(void **)buf);
            }
            uint64_t v12 = *v9;
          }
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v19 = (CSIPhoneNumber *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 160))(v8);
            CSIPhoneNumber::getFullNumber((uint64_t *)buf, v19);
            __int16 v20 = buf;
            if (v49 < 0) {
              __int16 v20 = *(unsigned char **)buf;
            }
            *(_DWORD *)int v50 = 136315138;
            __int16 v51 = v20;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I cached phone number: %s", v50, 0xCu);
            if (v49 < 0) {
              operator delete(*(void **)buf);
            }
            uint64_t v12 = *v9;
          }
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = (CSIPhoneNumber *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 176))(v8);
            CSIPhoneNumber::getFullNumber((uint64_t *)buf, v21);
            long long v22 = buf;
            if (v49 < 0) {
              long long v22 = *(unsigned char **)buf;
            }
            *(_DWORD *)int v50 = 136315138;
            __int16 v51 = v22;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I PNR phone number: %s", v50, 0xCu);
            if (v49 < 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v23 = *v5;
          if (*v5)
          {
            uint64_t v24 = a1 + 176;
            do
            {
              int v25 = *(_DWORD *)(v23 + 28);
              BOOL v26 = v25 < (int)v7;
              if (v25 >= (int)v7) {
                int v27 = (uint64_t *)v23;
              }
              else {
                int v27 = (uint64_t *)(v23 + 8);
              }
              if (!v26) {
                uint64_t v24 = v23;
              }
              uint64_t v23 = *v27;
            }
            while (*v27);
            if ((uint64_t *)v24 != v5 && (int)v7 >= *(_DWORD *)(v24 + 28))
            {
              uint64_t v28 = *v9;
              if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
              {
                std::string::size_type v29 = "false";
                if (*(unsigned char *)(v24 + 32)) {
                  std::string::size_type v29 = "true";
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v29;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I fSmsOnline: %s", buf, 0xCu);
              }
            }
          }
          long long v30 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v31 = sub_100039C68(v4, v7);
            if (v31)
            {
              uint64_t v32 = "false";
              if (*((unsigned char *)v31 + 4)) {
                uint64_t v32 = "true";
              }
            }
            else
            {
              uint64_t v32 = "false";
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v32;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I fPhoneNumberRegistrationState: %s", buf, 0xCu);
          }
          uint64_t v33 = *v6;
          if (*v6)
          {
            uint64_t v34 = a1 + 152;
            do
            {
              int v35 = *(_DWORD *)(v33 + 28);
              BOOL v36 = v35 < (int)v7;
              if (v35 >= (int)v7) {
                long long v37 = (uint64_t *)v33;
              }
              else {
                long long v37 = (uint64_t *)(v33 + 8);
              }
              if (!v36) {
                uint64_t v34 = v33;
              }
              uint64_t v33 = *v37;
            }
            while (*v37);
            if ((uint64_t *)v34 != v6 && (int)v7 >= *(_DWORD *)(v34 + 28))
            {
              std::string::size_type v38 = *v9;
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v39 = asString();
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v39;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I fRegStatus: %s", buf, 0xCu);
              }
            }
          }
        }
        if (v44) {
          sub_10004D2C8(v44);
        }
        long long v40 = v1 + 1;
        uint64_t v1 = v2;
        if (v40 != v2)
        {
          uint64_t v1 = v40;
          while ((v3(*v1) & 1) == 0)
          {
            if (++v1 == v2)
            {
              uint64_t v1 = v2;
              break;
            }
          }
        }
      }
      while (v1 != v42);
    }
  }
}

void sub_101014E44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_101014E80(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1;
  int v9 = a2;
  int v10 = a3;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  sub_1000DFC90((uint64_t)&v12, a5);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101015028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void sub_101015064(void **a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (a4 == 2
    && (!(*(unsigned int (**)(void))(*(void *)*a3 + 208))() || (*(unsigned int (**)(void))(*(void *)*a3 + 216))()))
  {
    int v10 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Selected phone book type is kOwnPhoneNumbers, and MSISDN does not exist/write locked. Sending kPhoneBookSelected", (uint8_t *)&v15, 2u);
    }
    (*(void (**)(void, uint64_t))(*(void *)*a3 + 40))(*a3, 2);
    (*(void (**)(void))(*a1[9] + 280))();
LABEL_16:
    sub_1000607A8(a5, 1);
    return;
  }
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 136315138;
    uint64_t v16 = asString();
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Select Phone Book called for %s", (uint8_t *)&v15, 0xCu);
  }
  uint64_t v12 = sub_100039C68((uint64_t)(a1 + 15), a2);
  if (v12 && *(int *)v12 > 1)
  {
    (*(void (**)(void, uint64_t))(*(void *)*a3 + 40))(*a3, a4);
    (*(void (**)(void))(*(void *)*a3 + 16))();
    xpc_object_t v14 = sub_100039C68((uint64_t)(a1 + 15), a2);
    if (v14) {
      *(_DWORD *)xpc_object_t v14 = 3;
    }
    (*(void (**)(void *, uint64_t, uint64_t))(*a1[11] + 64))(a1[11], a2, a4);
    goto LABEL_16;
  }
  sub_1000607A8(a5, 0);
  int v13 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I The Phone Book is not ready", (uint8_t *)&v15, 2u);
  }
}

void sub_1010153CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  sub_10009DB3C((uint64_t)&v10, a4);
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a5;
    __p[2] = *(void **)(a5 + 16);
  }
  sub_1000DFC90((uint64_t)&v12, a6);
  int v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1010155DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a2)
  {
    if (*(char *)(v36 + 127) < 0) {
      operator delete(*(void **)(v36 + 104));
    }
    if (*(char *)(v36 + 103) < 0) {
      operator delete(*(void **)(v36 + 80));
    }
    if (*(char *)(v36 + 71) < 0) {
      operator delete(*(void **)(v36 + 48));
    }
    if (*(char *)(v36 + 47) < 0) {
      operator delete(*(void **)(v36 + 24));
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101015674(uint64_t a1, uint64_t a2, unsigned int a3, CSIPhoneNumber *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  uint64_t v12 = a1 + 120;
  sub_100039CB8(&v68, a1 + 120, a2);
  if (v68)
  {
    (*(void (**)(uint64_t))(*(void *)v68 + 176))(v68);
    char v13 = CSIPhoneNumber::operator==();
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v67 = 0;
    xpc_object_t v14 = sub_100039C68(v12, a2);
    int v15 = (char *)(v14 + 1);
    if (!v14) {
      int v15 = (char *)&kInvalidPersonalityId;
    }
    if (v15[23] < 0)
    {
      sub_10004FC84(__dst, *(void **)v15, *((void *)v15 + 1));
    }
    else
    {
      long long v16 = *(_OWORD *)v15;
      uint64_t v67 = *((void *)v15 + 2);
      *(_OWORD *)long long __dst = v16;
    }
    unsigned int v58 = a3;
    if ((isReal() & 1) == 0)
    {
      std::string::size_type v29 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.var0) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "writeEntry_sync - persona is undefined yet", (uint8_t *)&buf, 2u);
      }
LABEL_41:
      uint64_t v44 = v68;
      if (v13) {
        CSIPhoneNumber::CSIPhoneNumber(&buf);
      }
      else {
        sub_10009DB3C((uint64_t)&buf, (uint64_t)a4);
      }
      (*(void (**)(uint64_t, CSIPhoneNumber *))(*(void *)v44 + 152))(v44, &buf);
      if (v64 < 0) {
        operator delete(__p);
      }
      if (v62 < 0) {
        operator delete(v61);
      }
      if (v60 < 0) {
        operator delete(*(void **)&buf.var2.__r_.var0);
      }
      if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 48))(v44) == 2
        && (!(*(unsigned int (**)(uint64_t))(*(void *)v44 + 208))(v44)
         || (*(unsigned int (**)(uint64_t))(*(void *)v44 + 216))(v44)))
      {
        unint64_t v45 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, a4);
          std::string v46 = buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0 ? &buf : *(CSIPhoneNumber **)&buf.var0;
          *(_DWORD *)int v72 = 136315138;
          *(void *)&v72[4] = v46;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Selected phone book type is kOwnPhoneNumbers, and MSISDN does not exist/write locked. Writing '%s' to preferences file", v72, 0xCu);
          if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
            operator delete(*(void **)&buf.var0);
          }
        }
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 296))(*(void *)(a1 + 72), a2);
      }
      else
      {
        OsLogContext v47 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, a4);
          uint64_t v48 = buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0 ? &buf : *(CSIPhoneNumber **)&buf.var0;
          *(_DWORD *)int v72 = 136315138;
          *(void *)&v72[4] = v48;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Write Entry called with number '%s'", v72, 0xCu);
          if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
            operator delete(*(void **)&buf.var0);
          }
        }
        char v49 = sub_100039C68(v12, a2);
        if (!v49 || *(int *)v49 <= 3)
        {
          sub_1000607A8(a6, 0);
          int v50 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.var0) = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Phone book is not Available", (uint8_t *)&buf, 2u);
          }
          goto LABEL_81;
        }
        __int16 v51 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Sending out the write entry to the Command Driver", (uint8_t *)&buf, 2u);
        }
        uint64_t v52 = *(void *)(a1 + 88);
        uint64_t v53 = (*(uint64_t (**)(uint64_t))(*(void *)v44 + 48))(v44);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, CSIPhoneNumber *, uint64_t))(*(void *)v52 + 56))(v52, a2, v53, v58, a4, a5);
      }
      int v54 = *(std::__shared_weak_count **)(a1 + 112);
      if (v54)
      {
        unint64_t v55 = std::__shared_weak_count::lock(v54);
        if (v55)
        {
          uint64_t v56 = v55;
          uint64_t v57 = *(void *)(a1 + 104);
          if (v57) {
            (*(void (**)(uint64_t, uint64_t, void, const char *))(*(void *)v57 + 304))(v57, a2, 0, "writeEntry_sync");
          }
          sub_10004D2C8(v56);
        }
      }
      sub_1000607A8(a6, 1);
LABEL_81:
      if (SHIBYTE(v67) < 0) {
        operator delete(__dst[0]);
      }
      goto LABEL_83;
    }
    if (v13)
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 56));
      __int16 v20 = ServiceMap;
      if (v21 < 0)
      {
        long long v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v23 = 5381;
        do
        {
          uint64_t v21 = v23;
          unsigned int v24 = *v22++;
          uint64_t v23 = (33 * v23) ^ v24;
        }
        while (v24);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&buf.var0 = v21;
      int v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&buf);
      if (v25)
      {
        uint64_t v26 = v25[3];
        int v27 = (std::__shared_weak_count *)v25[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v20);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v28 = 0;
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v26 = 0;
      }
      std::mutex::unlock(v20);
      int v27 = 0;
      char v28 = 1;
LABEL_34:
      (*(void (**)(uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v26 + 32))(v26, __dst, @"CachedPhoneNumber", @"phonebook", 0, 1);
      if ((v28 & 1) == 0) {
        sub_10004D2C8(v27);
      }
      goto LABEL_41;
    }
    BOOL v65 = 0;
    CSIPhoneNumber::getFullNumber((uint64_t *)&buf.var0, a4);
    if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
      p_CSIPhoneNumber buf = (const __CFString **)&buf;
    }
    else {
      p_CSIPhoneNumber buf = *(const __CFString ***)&buf.var0;
    }
    uint64_t v70 = 0;
    int v71 = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&v71, p_buf, (const char *)0x8000100, kCFAllocatorDefault, v30))
    {
      uint64_t v32 = v70;
      uint64_t v70 = v71;
      *(void *)int v72 = v32;
      sub_1000558F4((const void **)v72);
    }
    BOOL v65 = v70;
    uint64_t v70 = 0;
    sub_1000558F4(&v70);
    uint64_t v33 = (uint64_t *)buf.var2.__r_.__value_.var0.var0.__data_[15];
    if ((v33 & 0x80000000) != 0) {
      operator delete(*(void **)&buf.var0);
    }
    uint64_t v34 = (std::mutex *)Registry::getServiceMap(v33, *(Registry **)(a1 + 56));
    int v35 = v34;
    if (v36 < 0)
    {
      long long v37 = (unsigned __int8 *)(v36 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v38 = 5381;
      do
      {
        uint64_t v36 = v38;
        unsigned int v39 = *v37++;
        uint64_t v38 = (33 * v38) ^ v39;
      }
      while (v39);
    }
    std::mutex::lock(v34);
    *(void *)&buf.var0 = v36;
    long long v40 = sub_10004D37C(&v35[1].__m_.__sig, (unint64_t *)&buf);
    if (v40)
    {
      uint64_t v41 = v40[3];
      char v42 = (std::__shared_weak_count *)v40[4];
      if (v42)
      {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v35);
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v42);
        char v43 = 0;
LABEL_38:
        (*(void (**)(uint64_t, void **, const __CFString *, const void *, const __CFString *, void, uint64_t, void))(*(void *)v41 + 16))(v41, __dst, @"CachedPhoneNumber", v65, @"phonebook", 0, 1, 0);
        if ((v43 & 1) == 0) {
          sub_10004D2C8(v42);
        }
        sub_1000558F4(&v65);
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    std::mutex::unlock(v35);
    char v42 = 0;
    char v43 = 1;
    goto LABEL_38;
  }
  sub_1000607A8(a6, 0);
  uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.var0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "writeEntry_sync - No phonebook model", (uint8_t *)&buf, 2u);
  }
LABEL_83:
  if (v69) {
    sub_10004D2C8(v69);
  }
}

void sub_101015F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  sub_10004D2C8(v37);
  if (a37 < 0) {
    operator delete(__p);
  }
  long long v40 = *(std::__shared_weak_count **)(v38 - 152);
  if (v40) {
    sub_10004D2C8(v40);
  }
  _Unwind_Resume(a1);
}

void sub_101016080(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1000DFC90((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1010161CC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1010161E4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100AACA58((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016330(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_101016348(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  int v8 = a3;
  sub_100AACD94((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016488(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1010164A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)int v7 = *(_OWORD *)a3;
    v7[2] = *(void **)(a3 + 16);
  }
  sub_10009DB3C((uint64_t)&v8, a4);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016670(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 + 39) < 0) {
    operator delete(*v17);
  }
  sub_10006A6AC(a1);
}

void sub_1010166B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10009DB3C((uint64_t)&v6, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010168A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10009DB3C((uint64_t)&v5, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_101016A00(uint64_t a1, int a2, uint64_t a3)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = (uint64_t)&v8;
  v7[2] = a3;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_10101B6C4(v7);
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10101B9C0;
  v9[3] = &unk_101A7EBF0;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  uint64_t v10 = v9;
  uint64_t v6 = *(NSObject **)(a1 + 24);
  char v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    uint64_t v12 = sub_10005A7B4;
    char v13 = &unk_101A7EB30;
    xpc_object_t v14 = &v16;
    int v15 = &v10;
    dispatch_sync(v6, block);
  }
  else
  {
    uint64_t v12 = sub_10005B518;
    char v13 = &unk_101A7EB50;
    xpc_object_t v14 = &v16;
    int v15 = &v10;
    dispatch_async_and_wait(v6, block);
  }
  return v16 != 0;
}

void sub_101016B80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016C94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a5 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016DAC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016E9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a5 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101016FB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1010170C8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  char v9 = *(unsigned char *)(a2 + 24);
  uint64_t v6 = a3[1];
  uint64_t v10 = *a3;
  uint64_t v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101017274(void *a1, uint64_t a2)
{
  if ((operator==() & 1) == 0)
  {
    uint64_t v4 = (void *)a1[18];
    if (v4 != a1 + 19)
    {
      BOOL v5 = (uint64_t *)(a2 + 8);
      while (1)
      {
        uint64_t v6 = *(void *)((char *)v4 + 28);
        uint64_t v16 = v6;
        uint64_t v7 = *v5;
        if (!*v5) {
          goto LABEL_16;
        }
        uint64_t v8 = a2 + 8;
        do
        {
          int v9 = *(_DWORD *)(v7 + 28);
          BOOL v10 = v9 < (int)v6;
          if (v9 >= (int)v6) {
            uint64_t v11 = (uint64_t *)v7;
          }
          else {
            uint64_t v11 = (uint64_t *)(v7 + 8);
          }
          if (!v10) {
            uint64_t v8 = v7;
          }
          uint64_t v7 = *v11;
        }
        while (*v11);
        if ((uint64_t *)v8 == v5 || *(_DWORD *)(v8 + 28) > (int)v6) {
          goto LABEL_16;
        }
        uint64_t v12 = sub_10012EF5C(a2, (int *)&v16);
        if (*(_DWORD *)v12 != HIDWORD(v16)) {
          break;
        }
LABEL_17:
        char v13 = (void *)v4[1];
        if (v13)
        {
          do
          {
            xpc_object_t v14 = v13;
            char v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            xpc_object_t v14 = (void *)v4[2];
            BOOL v15 = *v14 == (void)v4;
            uint64_t v4 = v14;
          }
          while (!v15);
        }
        uint64_t v4 = v14;
        if (v14 == a1 + 19) {
          return;
        }
      }
      uint64_t v6 = v16;
LABEL_16:
      sub_101017378(a1, v6);
      goto LABEL_17;
    }
  }
}

void sub_101017378(void *a1, uint64_t a2)
{
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  long long v9 = 0u;
  memset(&__p, 0, sizeof(__p));
  char v6 = 0;
  unsigned __int8 v4 = 0;
  sub_1000372B8((uint64_t)a1, a2, &__p, (uint64_t)&v10, (uint64_t)v8, &v6, &v5, &v4);
  sub_10101754C(a1, a2, v4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SBYTE7(v9) < 0) {
    operator delete(v8[0]);
  }
  if (SBYTE7(v11) < 0) {
    operator delete((void *)v10);
  }
}

void sub_10101741C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v21 - 25) < 0) {
    operator delete(*(void **)(v21 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_101017458(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)a1[21];
  int v3 = a1 + 22;
  if (v2 != a1 + 22)
  {
    char v6 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v7 = *(void *)((char *)v2 + 28);
      uint64_t v17 = v7;
      uint64_t v8 = *v6;
      if (!*v6) {
        goto LABEL_15;
      }
      long long v9 = v6;
      do
      {
        int v10 = *(_DWORD *)(v8 + 28);
        BOOL v11 = v10 < (int)v7;
        if (v10 >= (int)v7) {
          uint64_t v12 = (uint64_t *)v8;
        }
        else {
          uint64_t v12 = (uint64_t *)(v8 + 8);
        }
        if (!v11) {
          long long v9 = (void *)v8;
        }
        uint64_t v8 = *v12;
      }
      while (*v12);
      if (v9 == v6 || *((_DWORD *)v9 + 7) > (int)v7) {
        goto LABEL_15;
      }
      char v13 = sub_10012EF5C(a2, (int *)&v17);
      if (*(unsigned __int8 *)v13 != BYTE4(v17)) {
        break;
      }
LABEL_16:
      xpc_object_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          BOOL v15 = v14;
          xpc_object_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          BOOL v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          uint64_t v2 = v15;
        }
        while (!v16);
      }
      uint64_t v2 = v15;
      if (v15 == v3) {
        return;
      }
    }
    uint64_t v7 = v17;
LABEL_15:
    sub_101017378(a1, v7);
    goto LABEL_16;
  }
}

uint64_t *sub_10101754C(void *a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1[19];
  if (!v5) {
    goto LABEL_11;
  }
  char v6 = a1 + 19;
  do
  {
    int v7 = *(_DWORD *)(v5 + 28);
    BOOL v8 = v7 < (int)a2;
    if (v7 >= (int)a2) {
      long long v9 = (uint64_t *)v5;
    }
    else {
      long long v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      char v6 = (void *)v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 19 && *((_DWORD *)v6 + 7) <= (int)a2) {
    unsigned int v10 = *((_DWORD *)v6 + 8) - 4;
  }
  else {
LABEL_11:
  }
    unsigned int v10 = -4;
  uint64_t v11 = a1[22];
  if (!v11) {
    goto LABEL_22;
  }
  uint64_t v12 = a1 + 22;
  do
  {
    int v13 = *(_DWORD *)(v11 + 28);
    BOOL v14 = v13 < (int)a2;
    if (v13 >= (int)a2) {
      BOOL v15 = (uint64_t *)v11;
    }
    else {
      BOOL v15 = (uint64_t *)(v11 + 8);
    }
    if (!v14) {
      uint64_t v12 = (void *)v11;
    }
    uint64_t v11 = *v15;
  }
  while (*v15);
  if (v12 != a1 + 22 && *((_DWORD *)v12 + 7) <= (int)a2)
  {
    BOOL v16 = *((unsigned __int8 *)v12 + 32) != 0;
    if (a3)
    {
LABEL_23:
      BOOL v17 = v10 < 2 && v16;
      uint64_t v18 = (uint64_t)(a1 + 15);
      double result = sub_100039C68((uint64_t)(a1 + 15), a2);
      if (result)
      {
        if (v17 == (*((unsigned char *)result + 4) != 0)) {
          return result;
        }
      }
      else
      {
        if (!v17) {
          return result;
        }
        LOBYTE(v17) = 1;
      }
      goto LABEL_36;
    }
  }
  else
  {
LABEL_22:
    BOOL v16 = 0;
    if (a3) {
      goto LABEL_23;
    }
  }
  uint64_t v18 = (uint64_t)(a1 + 15);
  double result = sub_100039C68((uint64_t)(a1 + 15), a2);
  if (!result || !*((unsigned char *)result + 4)) {
    return result;
  }
  LOBYTE(v17) = 0;
LABEL_36:
  __int16 v20 = sub_100039C68(v18, a2);
  if (v20) {
    *((unsigned char *)v20 + 4) = v17;
  }
  uint64_t v21 = a1[9];
  long long v22 = sub_100039C68(v18, a2);
  if (v22) {
    BOOL v23 = *((unsigned char *)v22 + 4) != 0;
  }
  else {
    BOOL v23 = 0;
  }
  unsigned int v24 = *(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(void *)v21 + 320);

  return (uint64_t *)v24(v21, a2, v23);
}

uint64_t sub_10101770C(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband refresh start received", v9, 2u);
  }
  uint64_t v5 = sub_100039C68(a1 + 120, a2);
  if (v5)
  {
    char v6 = v5;
    uint64_t v7 = v5[4];
    if (v7) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 256))(v7, 1);
    }
    *((unsigned char *)v6 + 5) = 0;
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 88) + 80))(*(void *)(a1 + 88), a2);
}

void sub_101017820(char *a1)
{
  if (a1)
  {
    sub_101017820(*(void *)a1);
    sub_101017820(*((void *)a1 + 1));
    uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 10);
    if (v2) {
      sub_10004D2C8(v2);
    }
    if (a1[71] < 0) {
      operator delete(*((void **)a1 + 6));
    }
    operator delete(a1);
  }
}

void sub_101017888(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101017954(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_101017A2C);
  __cxa_rethrow();
}

void sub_10101797C(_Unwind_Exception *a1)
{
}

void sub_101017994(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1010179CC(uint64_t a1)
{
}

uint64_t sub_1010179E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101017A2C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_101017A5C()
{
}

uint64_t sub_101017A70(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_101017A7C(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  BOOL v8 = v1;
  uint64_t v2 = *v1;
  int v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 88);
  uint64_t v5 = v1[1];
  *(void *)CSIPhoneNumber buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 192));
  sub_100088C88((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_101017B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
}

uint64_t *sub_101017BA8(void **a1)
{
  uint64_t v1 = *a1;
  int v54 = a1;
  unint64_t v55 = v1;
  uint64_t v2 = *v1;
  int v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  long long v69 = *(_OWORD *)off_101A7E678;
  long long v70 = *(_OWORD *)off_101A7E668;
  long long v67 = *(_OWORD *)off_101A7E698;
  long long v68 = *(_OWORD *)off_101A7E688;
  uint64_t v58 = 0;
  BOOL v59 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)off_101A7E698, *(Registry **)(v2 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CSIPhoneNumber buf = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v58 = v12;
  BOOL v59 = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  BOOL v14 = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(v2 + 56));
  BOOL v15 = v14;
  if (v16 < 0)
  {
    BOOL v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(v14);
  *(void *)CSIPhoneNumber buf = v16;
  __int16 v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (v20)
  {
    uint64_t v22 = v20[3];
    uint64_t v21 = (std::__shared_weak_count *)v20[4];
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v21 = 0;
  }
  std::mutex::unlock(v15);
  uint64_t v56 = v22;
  uint64_t v57 = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v21);
  }
  *(void *)CSIPhoneNumber buf = &v58;
  unint64_t v61 = (std::__shared_weak_count *)&v68;
  char v62 = (std::__shared_weak_count *)&v70;
  uint64_t v63 = (uint8_t *)&v67;
  char v64 = &v56;
  uint64_t v65 = v2;
  uint64_t v66 = &v69;
  sub_101014258((uint64_t)buf, 1);
  sub_101014258((uint64_t)buf, 2);
  if (v57) {
    sub_10004D2C8(v57);
  }
  if (v59) {
    sub_10004D2C8(v59);
  }
  sub_100058DB0(&v70, "/cc/props/registration_status");
  BOOL v23 = (uint8_t *)operator new(0x28uLL);
  *(void *)BOOL v23 = off_101A7E830;
  *((void *)v23 + 1) = v2 + 144;
  *((void *)v23 + 2) = v2;
  *((void *)v23 + 3) = sub_101017274;
  *((void *)v23 + 4) = 0;
  uint64_t v63 = v23;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v71 < 0) {
    operator delete((void *)v70);
  }
  sub_100058DB0(&v70, "/cc/props/sms_online");
  unsigned int v24 = (uint8_t *)operator new(0x28uLL);
  *(void *)unsigned int v24 = off_101A7E8B0;
  *((void *)v24 + 1) = v2 + 168;
  *((void *)v24 + 2) = v2;
  *((void *)v24 + 3) = sub_101017458;
  *((void *)v24 + 4) = 0;
  uint64_t v63 = v24;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v71 < 0) {
    operator delete((void *)v70);
  }
  int v25 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v25 || (uint64_t v26 = *(std::__shared_weak_count **)(v2 + 8), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
LABEL_64:
  }
    sub_100088B9C();
  char v28 = v27;
  atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  sub_100058DB0(&v70, "/cc/events/subscriber_sim_file_attributes_event");
  *(void *)CSIPhoneNumber buf = off_101A7E930;
  unint64_t v61 = v26;
  char v62 = v28;
  uint64_t v63 = buf;
  ctu::RestModule::observeEvent();
  std::string::size_type v29 = (capabilities::ct *)sub_10003F600(buf);
  if (v71 < 0) {
    operator delete((void *)v70);
  }
  if (capabilities::ct::supportsNVRAMUpdateWithoutBasebandReboot(v29))
  {
    sub_100058DB0(&v70, "/cc/events/baseband_refresh_start");
    CFAllocatorRef v30 = (uint8_t *)operator new(0x20uLL);
    *(void *)CFAllocatorRef v30 = off_101A7ED20;
    *((void *)v30 + 1) = v2;
    *((void *)v30 + 2) = sub_10101770C;
    *((void *)v30 + 3) = 0;
    uint64_t v63 = v30;
    ctu::RestModule::observeEvent();
    sub_10003F600(buf);
    if (v71 < 0) {
      operator delete((void *)v70);
    }
  }
  uint64_t v32 = v1[2];
  uint64_t v31 = v1[3];
  if (v31) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(v2 + 112);
  *(void *)(v2 + 104) = v32;
  *(void *)(v2 + 112) = v31;
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v69, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (*((void *)&v69 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v69 + 1));
  }
  sub_100058DB0(&v70, "/cc/events/dump_state");
  uint64_t v34 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v34 = off_101A7EAA0;
  *((void *)v34 + 1) = v2;
  *((void *)v34 + 2) = sub_10101484C;
  *((void *)v34 + 3) = 0;
  uint64_t v63 = v34;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  int v35 = (uint64_t *)v71;
  if ((v35 & 0x80000000) != 0) {
    operator delete((void *)v70);
  }
  uint64_t v36 = (std::mutex *)Registry::getServiceMap(v35, *(Registry **)(v2 + 56));
  long long v37 = v36;
  if (v38 < 0)
  {
    unsigned int v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      uint64_t v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(v36);
  *(void *)CSIPhoneNumber buf = v38;
  char v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)buf);
  if (v42)
  {
    uint64_t v44 = v42[3];
    char v43 = (std::__shared_weak_count *)v42[4];
    if (v43)
    {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v37);
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v43);
      goto LABEL_52;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v37);
  char v43 = 0;
LABEL_52:
  unint64_t v45 = *(std::__shared_weak_count **)(v2 + 216);
  *(void *)(v2 + 208) = v44;
  *(void *)(v2 + 216) = v43;
  if (v45) {
    sub_10004D2C8(v45);
  }
  sub_1008F2AF8(v2 + 224);
  std::string v46 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v46) {
    goto LABEL_64;
  }
  uint64_t v47 = *(void *)(v2 + 8);
  uint64_t v48 = std::__shared_weak_count::lock(v46);
  if (!v48) {
    goto LABEL_64;
  }
  char v49 = v48;
  int v50 = (std::__shared_weak_count *)operator new(0x30uLL);
  v50->__shared_owners_ = 0;
  v50->__shared_weak_owners_ = 0;
  v50->__vftable = (std::__shared_weak_count_vtbl *)off_101A7E9B0;
  atomic_fetch_add_explicit(&v49->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  v50[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A7EA00;
  v50[1].__shared_owners_ = v47;
  v50[1].__shared_weak_owners_ = (uint64_t)v49;
  atomic_fetch_add_explicit(&v49->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  std::__shared_weak_count::__release_weak(v49);
  sub_10004D2C8(v49);
  uint64_t v51 = *(void *)(v2 + 88);
  uint64_t v52 = v1[1];
  *(void *)&long long v70 = v52;
  if (v52)
  {
    dispatch_retain(v52);
    dispatch_group_enter(v52);
  }
  *(void *)CSIPhoneNumber buf = v50 + 1;
  unint64_t v61 = v50;
  atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, long long *, uint8_t *))(*(void *)v51 + 16))(v51, &v70, buf);
  if (v61) {
    sub_10004D2C8(v61);
  }
  if ((void)v70)
  {
    dispatch_group_leave((dispatch_group_t)v70);
    if ((void)v70) {
      dispatch_release((dispatch_object_t)v70);
    }
  }
  sub_10004D2C8(v50);
  sub_10040F180((uint64_t *)&v55);
  return sub_100046B58((uint64_t *)&v54);
}

void sub_1010182B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  sub_10003F600(&a15);
  if (*(char *)(v15 - 89) < 0) {
    operator delete(*(void **)(v15 - 112));
  }
  sub_10040F180(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1010183BC()
{
}

__n128 sub_1010183D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7E830;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101018424(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E830;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10101845C(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v11 = (void **)*v3;
  uint64_t v12 = v5;
  int v13 = (void *)v3[2];
  if (v13)
  {
    v5[2] = &v12;
    *int v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v11 = &v12;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  unsigned int v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    void v12[2] = v10;
    uint64_t v11 = &v12;
    uint64_t v12 = 0;
    int v13 = 0;
  }
  else
  {
    unsigned int v9 = v10;
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10[0]);
  sub_1000346F8((uint64_t)&v11, v12);
}

void sub_101018558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_101018584(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010185C4()
{
}

void sub_1010185D4()
{
}

__n128 sub_1010185E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7E8B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10101863C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7E8B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101018674(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v11 = (void **)*v3;
  uint64_t v12 = v5;
  int v13 = (void *)v3[2];
  if (v13)
  {
    v5[2] = &v12;
    *int v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v11 = &v12;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  unsigned int v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    void v12[2] = v10;
    uint64_t v11 = &v12;
    uint64_t v12 = 0;
    int v13 = 0;
  }
  else
  {
    unsigned int v9 = v10;
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10[0]);
  sub_1000346F8((uint64_t)&v11, v12);
}

void sub_101018770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_10101879C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010187DC()
{
}

void *sub_1010187E8(void *a1)
{
  *a1 = off_101A7E930;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101018834(void *a1)
{
  *a1 = off_101A7E930;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1010188A0(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A7E930;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1010188FC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A7E930;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101018934(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101018944(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101018984()
{
}

void sub_101018A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_101018A78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101018AB8()
{
}

void sub_101018AC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7E9B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101018AE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7E9B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101018B38(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_101018B60(PhonebookDriverEventHandlerInterface *this)
{
  *(void *)this = off_101A7EA00;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  PhonebookDriverEventHandlerInterface::~PhonebookDriverEventHandlerInterface(this);
}

void sub_101018BBC(PhonebookDriverEventHandlerInterface *this)
{
  *(void *)this = off_101A7EA00;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  PhonebookDriverEventHandlerInterface::~PhonebookDriverEventHandlerInterface(this);

  operator delete();
}

void sub_101018C2C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_101018D78(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_101018EC0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_101018FF8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *a3;
        uint64_t v11 = a3[1];
        if (v11)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          sub_101016B80(v9, a2, v10, v11);
        }
        sub_101016B80(v9, a2, v10, 0);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010190A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        uint64_t v12 = *a4;
        uint64_t v13 = a4[1];
        if (v13)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
          sub_101016C94(v11, a2, a3, v12, v13);
        }
        sub_101016C94(v11, a2, a3, v12, 0);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101019160(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        uint64_t v12 = *a4;
        uint64_t v13 = a4[1];
        if (v13)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
          sub_101016E9C(v11, a2, a3, v12, v13);
        }
        sub_101016E9C(v11, a2, a3, v12, 0);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101019220(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_101019370(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_1010194C0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_10101960C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_10101975C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *a3;
        uint64_t v11 = a3[1];
        if (v11)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
          sub_101016FB4(v9, a2, v10, v11);
        }
        sub_101016FB4(v9, a2, v10, 0);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101019804(uint64_t a1, uint64_t a2, uint64_t a3, long long **a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        __int16 v20 = 0;
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        sub_1000302C0((char *)&v20, *a4, a4[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3));
        uint64_t v12 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v11 + 48) + 16))(*(void *)(v11 + 48), a2);
        uint64_t v13 = *v12;
        if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = v20;
          BOOL v14 = v21;
          uint64_t v16 = asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL
                                                                                 * (((char *)v14 - (char *)v15) >> 3);
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v16;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Got %zu %s emergency numbers", (uint8_t *)&buf, 0x16u);
          uint64_t v13 = *v12;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = asString();
          sub_100062B40(v20, v21, ", ", 2uLL, &buf);
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string buf = &buf;
          }
          else {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)unsigned int v24 = 136315394;
          *(void *)&v24[4] = v17;
          __int16 v25 = 2080;
          uint64_t v26 = p_buf;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Emergency numbers for %s: %s", v24, 0x16u);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        uint64_t v19 = *(void *)(v11 + 208);
        memset(&buf, 0, sizeof(buf));
        sub_1000302C0((char *)&buf, (long long *)v20, (long long *)v21, 0xAAAAAAAAAAAAAAABLL * (((char *)v21 - (char *)v20) >> 3));
        (*(void (**)(uint64_t, uint64_t, std::string *, uint64_t))(*(void *)v19 + 40))(v19, a3, &buf, a2);
        *(void *)unsigned int v24 = &buf;
        sub_100047F64((void ***)v24);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v20;
        sub_100047F64((void ***)&buf);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_101019A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  sub_100047F64(&a17);
  a17 = (void **)&a10;
  sub_100047F64(&a17);
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_101019AC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136315138;
          uint64_t v12 = asString();
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N No %s emergency numbers provided. Clearing old emergency numbers.", (uint8_t *)&v11, 0xCu);
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v9 + 208) + 48))(*(void *)(v9 + 208), a3, a2);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101019C40(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101019C54(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 88) + 24))(*(void *)(v1 + 88));
  operator delete();
}

void sub_101019D10()
{
}

void sub_101019D40()
{
}

__n128 sub_101019D54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7EAA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101019DA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7EAA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101019DE0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101019E28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101019E68()
{
}

uint64_t *sub_101019E74(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_100039CB8(&v12, (uint64_t)(v2 + 15), *(_DWORD *)(v1 + 8));
  uint64_t v3 = v12;
  if (v12)
  {
    (*(void (**)(uint64_t, void))(*(void *)v12 + 24))(v12, *(unsigned int *)(v1 + 12));
    uint64_t v4 = *(unsigned int *)(v1 + 8);
    uint64_t v5 = v13;
    *(void *)std::string buf = v3;
    int v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_101015064(v2, v4, buf, *(unsigned int *)(v1 + 12), v1 + 40);
    if (v5)
    {
      sub_10004D2C8(v5);
LABEL_9:
      sub_10004D2C8(v5);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
    }
    sub_1000607A8(v1 + 40, 0);
    uint64_t v5 = v13;
    if (v13) {
      goto LABEL_9;
    }
  }
  sub_100AAC038(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_101019FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100AAC038(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10101A014(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_101015674(*(void *)v1, *(unsigned int *)(v1 + 8), *(_DWORD *)(v1 + 12), (CSIPhoneNumber *)(v1 + 16), v1 + 152, v1 + 176);
  sub_100AAC58C(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_10101A068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10101A084(int **a1)
{
  uint64_t v1 = *a1;
  BOOL v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received Fetch call", buf, 2u);
  }
  uint64_t v4 = sub_100039C68(v2 + 120, v1[2]);
  if (v4 && *(int *)v4 > 3)
  {
    *(void *)std::string buf = 0;
    uint64_t v18 = 0;
    sub_100039CB8(buf, v2 + 120, v1[2]);
    uint64_t v6 = *(void *)buf;
    if (*(void *)buf)
    {
      uint64_t v7 = *(void *)(v2 + 88);
      uint64_t v8 = v1[2];
      uint64_t v9 = (*(uint64_t (**)(void))(**(void **)buf + 48))(*(void *)buf);
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 64))(v6);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v7 + 48))(v7, v8, v9, 1, *(unsigned __int16 *)(v10 + 6));
      int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Fetch request sent out the Command Driver", v16, 2u);
      }
      sub_1000607A8((uint64_t)(v1 + 4), 1);
    }
    else
    {
      sub_1000607A8((uint64_t)(v1 + 4), 0);
      uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v16 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "No phonebook model", v16, 2u);
      }
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
  }
  else
  {
    sub_1000607A8((uint64_t)(v1 + 4), 0);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Phone book is not available state", buf, 2u);
    }
  }
  sub_10041FB18((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10101A380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10041FB18(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10101A3B8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_100039CB8(&v9, v2 + 120, *(_DWORD *)(v1 + 8));
  if (v9)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 96))(v9);
    uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      uint64_t v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Count: %zd", buf, 0xCu);
    }
    sub_100AACD38(v1 + 16, 1, v3);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
    }
    sub_100AACD38(v1 + 16, 0, 0);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100AACCE8(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_10101A580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100AACCE8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10101A5BC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v34 = 0;
  int v35 = 0;
  sub_100039CB8(&v34, v2 + 120, *(_DWORD *)(v1 + 8));
  uint64_t v3 = v34;
  if (v34)
  {
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
    long long v11 = 0u;
    sub_1002AE1CC((uint64_t)v10);
    int v4 = (*(uint64_t (**)(uint64_t, void, uint8_t *))(*(void *)v3 + 80))(v3, *(unsigned int *)(v1 + 12), v10);
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      int v37 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Found the entry: %d", buf, 8u);
    }
    sub_100AAD098(v1 + 16, v4);
  }
  else
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No phonebook model", v10, 2u);
    }
    sub_1002AE1CC((uint64_t)v10);
    sub_100AAD098(v1 + 16, 0);
  }
  sub_100039D40((uint64_t)v10);
  if (v35) {
    sub_10004D2C8(v35);
  }
  sub_100AAD048(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10101A7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  sub_100039D40((uint64_t)&a11);
  long long v13 = *(std::__shared_weak_count **)(v11 - 56);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100AAD048(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

BOOL sub_10101A82C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  return sub_1000372B8(*(void *)v1, **(unsigned int **)(v1 + 8), *(std::string **)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 32), *(unsigned char **)(v1 + 40), *(unsigned char **)(v1 + 48), *(unsigned char **)(v1 + 56));
}

uint64_t *sub_10101A848(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)v1 + 120;
  int v4 = sub_100039C68(v3, *(_DWORD *)(v1 + 8));
  if (v4 && *(int *)v4 > 1)
  {
    uint64_t v15 = 0;
    long long v16 = 0;
    sub_100039CB8(&v15, v3, *(_DWORD *)(v1 + 8));
    uint64_t v6 = v15;
    if (v15)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 208))(v15)
        && !(*(unsigned int (**)(uint64_t))(*(void *)v6 + 216))(v6))
      {
        uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Set phone number called, and MSISDN is writable", buf, 2u);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, 2);
        long long v12 = sub_100039C68(v3, *(_DWORD *)(v1 + 8));
        if (v12) {
          *(_DWORD *)long long v12 = 4;
        }
      }
      else
      {
        uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Set phone number called, and MSISDN does not exist/write locked", buf, 2u);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40))(v6, 2);
      }
      uint64_t v8 = *(unsigned int *)(v1 + 8);
      *(void *)std::string buf = off_101A7EB80;
      uint64_t v18 = v2;
      uint64_t v19 = v8;
      long long v20 = buf;
      sub_101015674(v2, v8, 1u, (CSIPhoneNumber *)(v1 + 40), v1 + 16, (uint64_t)buf);
      sub_100060644(buf);
    }
    else
    {
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
      }
    }
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Phone book is not ready to write", buf, 2u);
    }
  }
  sub_100AAD3E0(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_10101ABCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100AAD3E0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10101AC1C()
{
}

__n128 sub_10101AC30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7EB80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10101AC7C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7EB80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10101ACAC(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(result + 8) + 72) + 304))(*(void *)(*(void *)(result + 8) + 72), *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t sub_10101ACF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10101AD34()
{
}

uint64_t *sub_10101AD40(uint64_t *a1)
{
  uint64_t v1 = *a1;
  std::string v46 = a1;
  uint64_t v47 = v1;
  uint64_t v2 = *(void *)v1;
  v51[0] = 0;
  v51[1] = 0;
  uint64_t v52 = 0;
  CSIPhoneNumber::getFullNumber((uint64_t *)v51, (CSIPhoneNumber *)(v1 + 24));
  int v3 = SHIBYTE(v52);
  if (v52 >= 0) {
    int v4 = (void *)HIBYTE(v52);
  }
  else {
    int v4 = v51[1];
  }
  uint64_t v5 = *(NSObject **)(v2 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (v6)
    {
      uint64_t v26 = *(void *)(v1 + 8);
      long long v29 = *(const char **)(v26 + 24);
      long long v27 = (const char *)(v26 + 24);
      long long v28 = v29;
      uint64_t v30 = *((unsigned __int8 *)v27 + 23);
      int v31 = (char)v30;
      if ((v30 & 0x80u) != 0) {
        uint64_t v30 = *((void *)v27 + 1);
      }
      if (v31 < 0) {
        long long v27 = v28;
      }
      if (!v30) {
        long long v27 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Reset PNR phone number for persona %s", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(v2 + 56));
    long long v33 = ServiceMap;
    if (v34 < 0)
    {
      int v35 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v36 = 5381;
      do
      {
        uint64_t v34 = v36;
        unsigned int v37 = *v35++;
        uint64_t v36 = (33 * v36) ^ v37;
      }
      while (v37);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v34;
    uint64_t v38 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
    if (v38)
    {
      uint64_t v39 = v38[3];
      long long v23 = (std::__shared_weak_count *)v38[4];
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v33);
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
        char v40 = 0;
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v39 = 0;
    }
    std::mutex::unlock(v33);
    long long v23 = 0;
    char v40 = 1;
LABEL_69:
    (*(void (**)(uint64_t, uint64_t, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v39 + 32))(v39, *(void *)(v1 + 8) + 24, @"PNRPhoneNumber", @"phonebook", 0, 1);
    if (v40) {
      goto LABEL_56;
    }
LABEL_55:
    sub_10004D2C8(v23);
    goto LABEL_56;
  }
  if (v6)
  {
    uint64_t v8 = (void **)v51[0];
    uint64_t v9 = *(void *)(v1 + 8);
    uint64_t v12 = *(void *)(v9 + 24);
    uint64_t v10 = v9 + 24;
    uint64_t v11 = v12;
    if (v3 >= 0) {
      uint64_t v8 = v51;
    }
    uint64_t v13 = *(unsigned __int8 *)(v10 + 23);
    int v14 = (char)v13;
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(v10 + 8);
    }
    if (v14 < 0) {
      uint64_t v10 = v11;
    }
    if (v13) {
      uint64_t v15 = (const char *)v10;
    }
    else {
      uint64_t v15 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v15;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Store PNR phone number %s for persona %s", buf, 0x16u);
  }
  long long v16 = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(v2 + 56));
  long long v17 = v16;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)std::string buf = v18;
  long long v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
  if (v22)
  {
    uint64_t v24 = v22[3];
    long long v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  long long v23 = 0;
  char v25 = 1;
LABEL_38:
  uint64_t v41 = *(void *)(v1 + 8);
  if (SHIBYTE(v52) < 0)
  {
    sub_10004FC84(__dst, v51[0], (unint64_t)v51[1]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v51;
    uint64_t v49 = v52;
  }
  if (SHIBYTE(v49) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v55 = v49;
  }
  uint64_t v53 = 0;
  if (SHIBYTE(v55) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    *(void *)&uint8_t buf[16] = v55;
  }
  uint64_t v56 = 0;
  if (ctu::cf::convert_copy())
  {
    char v42 = v53;
    uint64_t v53 = v56;
    uint64_t v57 = v42;
    sub_1000558F4(&v57);
  }
  uint64_t v43 = v41 + 24;
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  int v50 = v53;
  uint64_t v53 = 0;
  sub_1000558F4(&v53);
  if (SHIBYTE(v55) < 0) {
    operator delete(__p[0]);
  }
  (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, const __CFString *, void, uint64_t, void, uint64_t *, uint64_t))(*(void *)v24 + 16))(v24, v43, @"PNRPhoneNumber", v50, @"phonebook", 0, 1, 0, v46, v47);
  sub_1000558F4(&v50);
  if ((SHIBYTE(v49) & 0x80000000) == 0)
  {
    if (v25) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  operator delete(__dst[0]);
  if ((v25 & 1) == 0) {
    goto LABEL_55;
  }
LABEL_56:
  __p[0] = 0;
  __p[1] = 0;
  sub_100039CB8(__p, v2 + 120, *(_DWORD *)(*(void *)(v1 + 8) + 52));
  if (__p[0]) {
    (*(void (**)(void *, uint64_t))(*(void *)__p[0] + 168))(__p[0], v1 + 24);
  }
  uint64_t v44 = *(unsigned int *)(*(void *)(v1 + 8) + 52);
  sub_100058DB0(buf, "My Number");
  (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)v2 + 88))(v2, v44, buf, v1 + 24);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
  sub_100AAD500(&v47);
  return sub_100046B58((uint64_t *)&v46);
}

void sub_10101B2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_1000558F4(&a24);
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_100AAD500(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10101B3A0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(v1 + 8));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(v1 + 16));
    int v4 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Request to set the Voice mail box number with %s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v5 = sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
  if (v5 && *(int *)v5 > 1)
  {
    *(_OWORD *)std::string buf = 0uLL;
    sub_100039CB8(buf, v2 + 120, *(_DWORD *)(v1 + 8));
    if (*(void *)buf)
    {
      uint64_t v7 = *(void *)(v2 + 88);
      uint64_t v8 = *(unsigned int *)(v1 + 8);
      int v9 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 248))(*(void *)buf, 4);
      sub_100058DB0(__p, "");
      if (v9) {
        uint64_t v10 = 4;
      }
      else {
        uint64_t v10 = 5;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void **))(*(void *)v7 + 56))(v7, v8, v10, 1, v1 + 16, __p);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No phonebook model", (uint8_t *)__p, 2u);
      }
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    BOOL v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Phone book is not ready to write", (uint8_t *)__p, 2u);
    }
  }
  sub_1006E15A8(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_10101B674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_1006E15A8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10101B6C4(uint64_t *a1)
{
  uint64_t v16 = 0;
  long long v17 = 0;
  uint64_t v2 = *a1;
  sub_100039CB8(&v16, *a1 + 120, *(_DWORD *)a1[1]);
  if (!v16)
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)a1[1]);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No phonebook model", (uint8_t *)__p, 2u);
    }
LABEL_16:
    uint64_t v9 = 0;
    goto LABEL_17;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 232))(v16);
  uint64_t v4 = a1[2];
  *(void *)uint64_t v4 = *(void *)v3;
  std::string::operator=((std::string *)(v4 + 8), (const std::string *)(v3 + 8));
  std::string::operator=((std::string *)(v4 + 32), (const std::string *)(v3 + 32));
  int v5 = *(_DWORD *)(v3 + 56);
  *(unsigned char *)(v4 + 60) = *(unsigned char *)(v3 + 60);
  *(_DWORD *)(v4 + 56) = v5;
  std::string::operator=((std::string *)(v4 + 64), (const std::string *)(v3 + 64));
  std::string::operator=((std::string *)(v4 + 88), (const std::string *)(v3 + 88));
  long long v6 = *(_OWORD *)(v3 + 112);
  *(unsigned char *)(v4 + 128) = *(unsigned char *)(v3 + 128);
  *(_OWORD *)(v4 + 112) = v6;
  CSIPhoneNumber::getBaseNumber((uint64_t *)__p, (CSIPhoneNumber *)a1[2]);
  if ((v15 & 0x80000000) == 0)
  {
    if (v15) {
      goto LABEL_4;
    }
    goto LABEL_14;
  }
  uint64_t v11 = __p[1];
  operator delete(__p[0]);
  if (!v11)
  {
LABEL_14:
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)a1[1]);
    uint64_t v9 = 0;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Voice mail box number is empty", (uint8_t *)__p, 2u);
    goto LABEL_16;
  }
LABEL_4:
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)a1[1]);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)a1[2]);
    uint64_t v8 = v15 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Voice mail box number is %s", buf, 0xCu);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v9 = 1;
LABEL_17:
  if (v17) {
    sub_10004D2C8(v17);
  }
  return v9;
}

void sub_10101B98C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10101B9C0(uint64_t a1)
{
  return sub_10101B6C4(*(uint64_t **)(a1 + 40));
}

void sub_10101B9C8(uint64_t **a1)
{
  uint64_t v33 = **a1;
  if (*((unsigned char *)*a1 + 12))
  {
    subscriber::makeSimSlotRange();
    uint64_t v2 = v37;
    uint64_t v1 = v38;
    if (v37 != v38)
    {
      uint64_t v3 = v39;
      do
      {
        if (v39(*v2)) {
          goto LABEL_7;
        }
        ++v2;
      }
      while (v2 != v38);
      uint64_t v2 = v38;
LABEL_7:
      uint64_t v4 = v38;
      if (v2 != v38)
      {
        long long v32 = v38;
        do
        {
          uint64_t v5 = *v2;
          long long v6 = sub_100039C68(v33 + 120, *v2);
          if (v6)
          {
            uint64_t v7 = 1;
            *(_DWORD *)long long v6 = 1;
          }
          ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v7, *(Registry **)(v33 + 56));
          uint64_t v9 = ServiceMap;
          if (v10 < 0)
          {
            uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v12 = 5381;
            do
            {
              uint64_t v10 = v12;
              unsigned int v13 = *v11++;
              uint64_t v12 = (33 * v12) ^ v13;
            }
            while (v13);
          }
          std::mutex::lock(ServiceMap);
          *(void *)std::string buf = v10;
          uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
          if (v14)
          {
            uint64_t v16 = v14[3];
            char v15 = (std::__shared_weak_count *)v14[4];
            if (v15)
            {
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v9);
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v4 = v32;
              sub_10004D2C8(v15);
              char v17 = 0;
              if (!v16) {
                goto LABEL_17;
              }
              goto LABEL_21;
            }
          }
          else
          {
            uint64_t v16 = 0;
          }
          std::mutex::unlock(v9);
          char v15 = 0;
          char v17 = 1;
          if (!v16)
          {
LABEL_17:
            uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v33 + 48) + 16))(*(void *)(v33 + 48), v5);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Subscriber Service is not up yet. Will try again later", buf, 2u);
            }
            goto LABEL_22;
          }
LABEL_21:
          int v34 = 4;
          sub_100602B08((uint64_t)buf, &v34, 1);
          (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v16 + 168))(v16, v5, buf);
          sub_1000346F8((uint64_t)buf, v36);
LABEL_22:
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          uint64_t v19 = v2 + 1;
          uint64_t v2 = v1;
          if (v19 != v1)
          {
            uint64_t v2 = v19;
            do
            {
              if (v3(*v2)) {
                goto LABEL_29;
              }
              ++v2;
            }
            while (v2 != v1);
            uint64_t v2 = v1;
          }
LABEL_29:
          ;
        }
        while (v2 != v4);
      }
    }
  }
  else
  {
    subscriber::makeSimSlotRange();
    unsigned int v21 = v37;
    uint64_t v20 = v38;
    if (v37 != v38)
    {
      long long v22 = v39;
      do
      {
        if (v39(*v21)) {
          goto LABEL_36;
        }
        ++v21;
      }
      while (v21 != v38);
      unsigned int v21 = v38;
LABEL_36:
      long long v23 = v38;
      if (v21 != v38)
      {
        uint64_t v24 = v33 + 120;
        do
        {
          int v25 = *v21;
          uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v33 + 48) + 16))(*(void *)(v33 + 48), *v21);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Phone book driver has gone down, clearing off the phone book model", buf, 2u);
          }
          long long v27 = sub_100039C68(v24, v25);
          if (v27) {
            *(_DWORD *)long long v27 = 0;
          }
          long long v28 = sub_100039C68(v24, v25);
          long long v29 = v28;
          if (v28)
          {
            uint64_t v30 = v28[4];
            if (v30) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 256))(v30, 1);
            }
            *((unsigned char *)v29 + 5) = 0;
          }
          char v31 = v21 + 1;
          unsigned int v21 = v20;
          if (v31 != v20)
          {
            unsigned int v21 = v31;
            do
            {
              if (v22(*v21)) {
                goto LABEL_51;
              }
              ++v21;
            }
            while (v21 != v20);
            unsigned int v21 = v20;
          }
LABEL_51:
          ;
        }
        while (v21 != v23);
      }
    }
  }
  operator delete();
}

void sub_10101BDE8()
{
}

void sub_10101BE64(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  switch(*((_DWORD *)*a1 + 2))
  {
    case 1:
      uint64_t v3 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v4 = *((_DWORD *)v1 + 3);
      *(_DWORD *)std::string buf = 67109120;
      int v10 = v4;
      uint64_t v5 = "#N Error in Get Capabilities: %d";
      break;
    case 2:
      uint64_t v3 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v8 = *((_DWORD *)v1 + 3);
      *(_DWORD *)std::string buf = 67109120;
      int v10 = v8;
      uint64_t v5 = "#N Error in PB State : %d";
      break;
    case 3:
      uint64_t v3 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v6 = *((_DWORD *)v1 + 3);
      *(_DWORD *)std::string buf = 67109120;
      int v10 = v6;
      uint64_t v5 = "#N Error in Fetch: %d";
      break;
    case 4:
      uint64_t v3 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v7 = *((_DWORD *)v1 + 3);
      *(_DWORD *)std::string buf = 67109120;
      int v10 = v7;
      uint64_t v5 = "#N Error in Write Entry: %d";
      break;
    default:
      goto LABEL_12;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, buf, 8u);
LABEL_11:
  (*(void (**)(void, void))(**(void **)(v2 + 72) + 304))(*(void *)(v2 + 72), *((unsigned int *)v1 + 4));
LABEL_12:
  operator delete();
}

void sub_10101C04C()
{
}

void sub_10101C088(uint64_t **a1)
{
  uint64_t v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = sub_100039C68(v2 + 120, *((_DWORD *)*a1 + 2));
  if (v3) {
    *(_DWORD *)uint64_t v3 = 2;
  }
  int v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Phone book Command Driver ready", buf, 2u);
  }
  operator delete();
}

void sub_10101C158()
{
}

uint64_t *sub_10101C184(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_100039CB8(&v17, v2 + 120, *(_DWORD *)(v1 + 8));
  uint64_t v3 = v17;
  if (v17)
  {
    int v4 = sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
    if (!v4 || *(int *)v4 <= 2)
    {
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
      uint64_t v6 = asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v20 = v6;
      int v7 = "#N Got capabilities, not in kPBStatePhoneBookSelected state (%s)";
      int v8 = v5;
      uint32_t v9 = 12;
      goto LABEL_14;
    }
    (*(void (**)(uint64_t, void))(*(void *)v3 + 56))(v3, *(void *)(v1 + 16));
    uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Got Phone book capabilities", buf, 2u);
    }
    uint64_t v12 = sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
    if (v12) {
      *(_DWORD *)uint64_t v12 = 4;
    }
    (*(void (**)(void, void))(**(void **)(v2 + 72) + 280))(*(void *)(v2 + 72), *(unsigned int *)(v1 + 8));
    unsigned int v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      int v7 = "#I Notified the clients that Phone Book has been selected";
      int v8 = v13;
      uint32_t v9 = 2;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
    }
  }
  else
  {
    int v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
    }
  }
LABEL_15:
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10013A778(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_10101C480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10101C4C4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  sub_100039CB8(&v16, v2 + 120, *(_DWORD *)(v1 + 8));
  uint64_t v3 = v16;
  if (v16)
  {
    int v4 = sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
    if (!v4 || *(int *)v4 <= 3)
    {
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_13;
      }
      sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
      uint64_t v6 = asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v19 = v6;
      int v7 = "#N Fetch partially complete, not in kPhoneBookAvailable state (%s)";
      int v8 = v5;
      uint32_t v9 = 12;
      goto LABEL_6;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48))(v3) == *(_DWORD *)(v1 + 12))
    {
      (*(void (**)(uint64_t, void))(*(void *)v3 + 72))(v3, *(void *)(v1 + 16));
    }
    else
    {
      uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        int v7 = "#I Fetch partial received for currently not set phone book";
        int v8 = v11;
        uint32_t v9 = 2;
LABEL_6:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
      }
    }
LABEL_13:
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Got partial fetch acknowledgement", buf, 2u);
    }
    goto LABEL_15;
  }
  int v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
  }
LABEL_15:
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_1009076B4(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10101C7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_1009076B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10101C7F4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  memset(&v28, 0, sizeof(v28));
  *(_OWORD *)uint64_t v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  long long v25 = 0u;
  char v23 = 0;
  unsigned __int8 v21 = 0;
  if (!sub_1000372B8(v2, *((unsigned int *)v1 + 2), &v28, (uint64_t)v26, (uint64_t)v24, &v23, &v22, &v21))
  {
LABEL_60:
    if (SBYTE7(v25) < 0) {
      operator delete(v24[0]);
    }
    if (SBYTE7(v27) < 0) {
      operator delete(v26[0]);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
    operator delete();
  }
  uint64_t v3 = *((unsigned int *)v1 + 2);
  int v4 = sub_100039C68(v2 + 120, *((_DWORD *)v1 + 2));
  if (!v4) {
    __assert_rtn("checkForPhoneNumberChanged_sync", "PhonebookHandler.cpp", 778, "descr");
  }
  uint64_t v38 = 0;
  CFStringRef v5 = off_101A7E6A8[v3 == 2];
  *(void *)&v29.var0 = CFPreferencesCopyValue(v5, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100225AE0(&v38, (CFTypeRef *)&v29);
  unsigned int v37 = 0;
  CSIPhoneNumber::CSIPhoneNumber();
  CSIPhoneNumber::getBaseNumber((uint64_t *)&v35, &v29);
  if (SHIBYTE(v36) < 0)
  {
    sub_10004FC84(buf, (void *)v35, *((unint64_t *)&v35 + 1));
  }
  else
  {
    *(_OWORD *)std::string buf = v35;
    *(void *)&uint8_t buf[16] = v36;
  }
  uint64_t v39 = 0;
  if ((buf[23] & 0x80000000) != 0)
  {
    sub_10004FC84(&__dst, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    long long __dst = *(_OWORD *)buf;
    unint64_t size = *(void *)&buf[16];
  }
  char v42 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v6 = v39;
    uint64_t v39 = v42;
    uint64_t v43 = v6;
    sub_1000558F4(&v43);
  }
  if (SHIBYTE(size) < 0) {
    operator delete((void *)__dst);
  }
  unsigned int v37 = v39;
  uint64_t v39 = 0;
  sub_1000558F4(&v39);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete((void *)v35);
  }
  if (v34 < 0) {
    operator delete(__p);
  }
  if (v32 < 0) {
    operator delete(v31);
  }
  if (v30 < 0) {
    operator delete(*(void **)&v29.var2.__r_.var0);
  }
  if (*((char *)&v29.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(v29.var2.__r_.__value_.var0.var1.__data_);
  }
  int v7 = v37;
  if (v38) {
    int v8 = sub_1000810B8;
  }
  else {
    int v8 = 0;
  }
  if (v8)
  {
    if (v37 ? sub_1000810B8 : 0)
    {
      if (CFEqual(v38, v37)) {
        goto LABEL_45;
      }
      int v7 = v37;
    }
  }
  CFPreferencesSetValue(v5, v7, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1003F2A04();
  (*(void (**)(void, uint64_t))(**(void **)(v2 + 72) + 328))(*(void *)(v2 + 72), v3);
  int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    memset(&v29, 0, 24);
    ctu::cf::assign();
    unint64_t size = v29.var2.__r_.__value_.var0.var1.__size_;
    long long __dst = *(_OWORD *)&v29.var0;
    int v11 = v29.var2.__r_.__value_.var0.var0.__data_[15];
    uint64_t v12 = *(long long **)&v29.var0;
    asString();
    p_dst = &__dst;
    if (v11 < 0) {
      p_dst = v12;
    }
    if (v29.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
      uint64_t v14 = &v29;
    }
    else {
      uint64_t v14 = *(CSIPhoneNumber **)&v29.var0;
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = p_dst;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sent out Phone Number Changed notification, old: %s, new: %s", buf, 0x16u);
    if (v29.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
      operator delete(*(void **)&v29.var0);
    }
    if (SHIBYTE(size) < 0) {
      operator delete((void *)__dst);
    }
  }
LABEL_45:
  if (!*((unsigned char *)v4 + 5))
  {
    *((unsigned char *)v4 + 5) = 1;
    uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v29.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I sending out 'Phone Number Available'", (uint8_t *)&v29, 2u);
    }
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 72) + 312))(*(void *)(v2 + 72), v3);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v2 + 112);
  if (v16)
  {
    uint64_t v17 = std::__shared_weak_count::lock(v16);
    if (v17)
    {
      uint64_t v18 = *(void *)(v2 + 104);
      if (v18)
      {
        uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v29.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Updating phone_numbers rest property", (uint8_t *)&v29, 2u);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t *, void **, void **, uint64_t))(*(void *)v18 + 432))(v18, v3, v4 + 1, v26, v24, 1);
        goto LABEL_58;
      }
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v29.var0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not get SettingsInterface to update phone numbers REST property", (uint8_t *)&v29, 2u);
    if (!v17) {
      goto LABEL_59;
    }
  }
  else if (!v17)
  {
LABEL_59:
    sub_1000558F4(&v37);
    sub_1000558F4(&v38);
    sub_10101754C((void *)v2, *((unsigned int *)v1 + 2), v21);
    goto LABEL_60;
  }
LABEL_58:
  sub_10004D2C8(v17);
  goto LABEL_59;
}

void sub_10101CE78(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  sub_10004D2C8(v37);
  sub_1000558F4((const void **)(v38 - 184));
  sub_1000558F4((const void **)(v38 - 176));
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  operator delete();
}

uint64_t *sub_10101CFA4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v35 = a1;
  uint64_t v36 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  sub_100039CB8(&v37, v2 + 120, *(_DWORD *)(v1 + 8));
  uint64_t v3 = v37;
  if (!v37)
  {
    int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.var0) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No phonebook model", (uint8_t *)&buf, 2u);
    }
    goto LABEL_42;
  }
  int v4 = *(_DWORD *)(v1 + 12);
  if ((v4 - 4) < 2)
  {
    uint64_t v5 = *(unsigned int *)(v1 + 8);
    uint64_t v6 = *(void *)(v2 + 48);
    int v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 16);
    if (*(void *)(*(void *)(v1 + 16) + 8) - **(void **)(v1 + 16) != 384)
    {
      uint64_t v20 = *(NSObject **)v7(v6, v5);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = asString();
        buf.var0 = 136315138;
        *(void *)&buf.var1 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Received 0 records for %s", (uint8_t *)&buf, 0xCu);
      }
      CSIPhoneNumber::CSIPhoneNumber(&buf);
      (*(void (**)(uint64_t, CSIPhoneNumber *))(*(void *)v3 + 224))(v3, &buf);
      if (v44 < 0) {
        operator delete(__p);
      }
      if (v42 < 0) {
        operator delete(v41);
      }
      if (v40 < 0) {
        operator delete(*(void **)&buf.var2.__r_.var0);
      }
      if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
      }
      goto LABEL_33;
    }
    int v8 = *(NSObject **)v7(v6, v5);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = asString();
      buf.var0 = 136315138;
      *(void *)&buf.var1 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Received PB entry for %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v10 = **(void **)(v1 + 16);
    if (*(void *)(*(void *)(v1 + 16) + 8) != v10)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 224))(v3, v10 + 32);
      goto LABEL_33;
    }
LABEL_45:
    sub_10015B728();
  }
  if (v4 == 2)
  {
    uint64_t v12 = *(uint64_t **)(v1 + 16);
    uint64_t v14 = *v12;
    uint64_t v13 = v12[1];
    uint64_t v15 = *(unsigned int *)(v1 + 8);
    uint64_t v16 = *(void *)(v2 + 48);
    uint64_t v17 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v16 + 16);
    if (v13 == v14)
    {
      char v22 = *(NSObject **)v17(v16, v15);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Received 0 records for Own Phone Numbers", (uint8_t *)&buf, 2u);
      }
    }
    else
    {
      uint64_t v18 = *(NSObject **)v17(v16, v15);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(*(void *)(v1 + 16) + 8) - **(void **)(v1 + 16)) >> 7);
        buf.var0 = 134217984;
        *(void *)&buf.var1 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Received PB entry for Own Phone Numbers, %lu", (uint8_t *)&buf, 0xCu);
      }
      if (*(void *)(*(void *)(v1 + 16) + 8) == **(void **)(v1 + 16)) {
        goto LABEL_45;
      }
      (*(void (**)(uint64_t))(*(void *)v3 + 104))(v3);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 136))(v3, 1);
    char v23 = *(std::__shared_weak_count **)(v2 + 112);
    if (v23)
    {
      uint64_t v24 = std::__shared_weak_count::lock(v23);
      if (v24)
      {
        long long v25 = v24;
        uint64_t v26 = *(void *)(v2 + 104);
        if (v26) {
          (*(void (**)(uint64_t, void, void, const char *))(*(void *)v26 + 304))(v26, *(unsigned int *)(v1 + 8), 0, "phonebookFetchComplete");
        }
        sub_10004D2C8(v25);
      }
    }
  }
LABEL_33:
  long long v27 = sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
  if (!v27 || *(int *)v27 <= 3)
  {
    std::string v28 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    sub_100039C68(v2 + 120, *(_DWORD *)(v1 + 8));
    uint64_t v29 = asString();
    buf.var0 = 136315138;
    *(void *)&buf.var1 = v29;
    char v30 = "#N Fetch complete, not in kPhoneBookAvailable state (%s)";
    char v31 = v28;
    uint32_t v32 = 12;
    goto LABEL_37;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48))(v3) == *(_DWORD *)(v1 + 12))
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 72))(v3, *(void *)(v1 + 16));
    (*(void (**)(void, void))(**(void **)(v2 + 72) + 288))(*(void *)(v2 + 72), *(unsigned int *)(v1 + 8));
  }
  else
  {
    uint64_t v33 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.var0) = 0;
      char v30 = "#I Fetch complete received for currently not set phone book";
      char v31 = v33;
      uint32_t v32 = 2;
LABEL_37:
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, (uint8_t *)&buf, v32);
    }
  }
LABEL_42:
  if (v38) {
    sub_10004D2C8(v38);
  }
  sub_1009076B4(&v36);
  return sub_100046B58((uint64_t *)&v35);
}

void sub_10101D5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_10004D2C8(v38);
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_1009076B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10101D68C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CSIPhoneNumber buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received phone book entry update", buf, 2u);
  }
  *(void *)CSIPhoneNumber buf = 0;
  uint64_t v10 = 0;
  sub_100039CB8(buf, v2 + 120, *((_DWORD *)v1 + 2));
  if (*(void *)buf)
  {
    uint64_t v4 = *((unsigned int *)v1 + 3);
    if (v4 <= 5 && ((1 << v4) & 0x34) != 0) {
      goto LABEL_8;
    }
    if (v4 == (*(unsigned int (**)(void))(**(void **)buf + 48))())
    {
      uint64_t v4 = *((unsigned int *)v1 + 3);
LABEL_8:
      (*(void (**)(void, void, uint64_t, void, void))(**(void **)(v2 + 88) + 48))(*(void *)(v2 + 88), *((unsigned int *)v1 + 2), v4, *((unsigned int *)v1 + 4), *((unsigned int *)v1 + 4));
      goto LABEL_11;
    }
    int v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received an entry update for non-selected phone book", v8, 2u);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No phonebook model", v8, 2u);
    }
  }
LABEL_11:
  if (v10) {
    sub_10004D2C8(v10);
  }
  operator delete();
}

void sub_10101D8DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  operator delete();
}

void sub_10101D924(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Received phone book entry delete", (uint8_t *)&buf, 2u);
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_100039CB8(&v17, v2 + 120, *((_DWORD *)v1 + 2));
  uint64_t v4 = v17;
  if (v17)
  {
    uint64_t v5 = v17;
    int v6 = *((_DWORD *)v1 + 3);
    if ((v6 - 4) >= 2)
    {
      if (v6 == 2)
      {
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received an entry delete for Own Phone Number", (uint8_t *)&buf, 2u);
        }
        sub_1002AE1CC((uint64_t)&buf);
        (*(void (**)(uint64_t, CSIPhoneNumber *))(*(void *)v4 + 104))(v4, &buf);
        sub_100039D40((uint64_t)&buf);
        int v11 = *(std::__shared_weak_count **)(v2 + 112);
        if (v11)
        {
          uint64_t v12 = std::__shared_weak_count::lock(v11);
          if (v12)
          {
            uint64_t v13 = v12;
            uint64_t v14 = *(void *)(v2 + 104);
            if (v14) {
              (*(void (**)(uint64_t, void, void, const char *))(*(void *)v14 + 304))(v14, *((unsigned int *)v1 + 2), 0, "phonebookEntryDelete");
            }
            sub_10004D2C8(v13);
          }
        }
      }
    }
    else
    {
      int v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = asString();
        buf.var0 = 136315138;
        *(void *)&buf.var1 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received an entry delete for (%s) Voice Mail Number", (uint8_t *)&buf, 0xCu);
      }
      CSIPhoneNumber::CSIPhoneNumber(&buf);
      (*(void (**)(uint64_t, CSIPhoneNumber *))(*(void *)v4 + 224))(v4, &buf);
      if (v24 < 0) {
        operator delete(__p);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
      if (v20 < 0) {
        operator delete(*(void **)&buf.var2.__r_.var0);
      }
      if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
      }
    }
    int v15 = *((_DWORD *)v1 + 3);
    if (v15 == (*(unsigned int (**)(uint64_t))(*(void *)v5 + 48))(v5))
    {
      (*(void (**)(uint64_t, void))(*(void *)v5 + 88))(v5, *((unsigned int *)v1 + 4));
    }
    else
    {
      uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.var0) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Received an entry delete for non-selected phone book", (uint8_t *)&buf, 2u);
      }
    }
  }
  else
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.var0) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No phonebook model", (uint8_t *)&buf, 2u);
    }
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  operator delete();
}

void sub_10101DD8C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_10004D2C8(v38);
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

void sub_10101DE50(uint64_t **a1)
{
  uint64_t v13 = 0;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v14 = 0;
  uint64_t v3 = v2 + 120;
  sub_100039CB8(&v13, v2 + 120, *((_DWORD *)v1 + 2));
  if (v13)
  {
    uint64_t v4 = sub_100039C68(v2 + 120, *((_DWORD *)v1 + 2));
    if (v4 && *(int *)v4 > 3)
    {
      (*(void (**)(void, void))(**(void **)(v2 + 72) + 296))(*(void *)(v2 + 72), *((unsigned int *)v1 + 2));
      int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      int v12 = *((unsigned __int16 *)v1 + 6);
      *(_DWORD *)CSIPhoneNumber buf = 67109120;
      LODWORD(v16) = v12;
      int v7 = "#I Write Entry complete for record: %d";
      uint64_t v8 = v11;
      uint32_t v9 = 8;
    }
    else
    {
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      sub_100039C68(v3, *((_DWORD *)v1 + 2));
      uint64_t v6 = asString();
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      uint64_t v16 = v6;
      int v7 = "#N Write complete, not in kPhoneBookAvailable state (%s)";
      uint64_t v8 = v5;
      uint32_t v9 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
    }
  }
LABEL_11:
  if (v14) {
    sub_10004D2C8(v14);
  }
  operator delete();
}

void sub_10101E0C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

void sub_10101E110(void ****a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)*a1 + 2));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asString();
    uint64_t v5 = "true";
    if (!*((unsigned char *)v1 + 16)) {
      uint64_t v5 = "false";
    }
    *(_DWORD *)CSIPhoneNumber buf = 136315394;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Phone Book State received with type (%s) and result (%s)", buf, 0x16u);
  }
  int v6 = *((_DWORD *)v1 + 3);
  if (v6 == 2)
  {
    if (*((unsigned char *)v1 + 16))
    {
      (*(void (**)(void *, void, uint64_t, uint64_t, uint64_t))(*v2[11] + 48))(v2[11], *((unsigned int *)v1 + 2), 2, 1, 1);
      int v7 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CSIPhoneNumber buf = 0;
        uint64_t v8 = "#I PB State is ready for Own Phone Numbers, sent out read request for record 1";
        uint32_t v9 = v7;
        uint32_t v10 = 2;
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
      }
    }
  }
  else if ((v6 & 0xFFFFFFFE) == 4)
  {
    if (*((unsigned char *)v1 + 16))
    {
      (*(void (**)(void *, void))(*v2[11] + 48))(v2[11], *((unsigned int *)v1 + 2));
      int v11 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        *(_DWORD *)CSIPhoneNumber buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        uint64_t v8 = "#I PB State is ready for %s, sent out read request for record 1";
        uint32_t v9 = v11;
        uint32_t v10 = 12;
        goto LABEL_13;
      }
    }
  }
  uint64_t v41 = 0;
  char v42 = 0;
  uint64_t v13 = (uint64_t)(v2 + 15);
  sub_100039CB8(&v41, (uint64_t)(v2 + 15), *((_DWORD *)v1 + 2));
  uint64_t v14 = v41;
  if (v41)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)v41 + 48))(v41) != *((_DWORD *)v1 + 3)) {
      goto LABEL_44;
    }
    int v15 = sub_100039C68((uint64_t)(v2 + 15), *((_DWORD *)v1 + 2));
    if (!v15 || *(int *)v15 <= 2)
    {
      uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_44;
      }
      sub_100039C68(v13, *((_DWORD *)v1 + 2));
      uint64_t v17 = asString();
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      uint64_t v18 = "#N Phone state received, not in kPBStatePhoneBookSelected state (%s)";
      unint64_t v19 = v16;
      uint32_t v20 = 12;
LABEL_43:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
      goto LABEL_44;
    }
    if (*((unsigned char *)v1 + 16))
    {
      char v22 = sub_100039C68((uint64_t)(v2 + 15), *((_DWORD *)v1 + 2));
      if (v22 && *(int *)v22 > 3)
      {
        uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_44;
        }
        *(_WORD *)CSIPhoneNumber buf = 0;
        uint64_t v18 = "#I Capabilities are already available";
      }
      else
      {
        char v23 = v2[11];
        uint64_t v24 = *((unsigned int *)v1 + 2);
        uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 48))(v14);
        (*(void (**)(void *, uint64_t, uint64_t))(*v23 + 40))(v23, v24, v25);
        uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_44;
        }
        *(_WORD *)CSIPhoneNumber buf = 0;
        uint64_t v18 = "#I Phone book ready - getting capabilities";
      }
      unint64_t v19 = v26;
      uint32_t v20 = 2;
      goto LABEL_43;
    }
    int v27 = *((_DWORD *)v1 + 3);
    if (!v27)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v14 + 32))(v14))
      {
        char v34 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I SIM Phone book is not available, retrying on Application Phone Book", buf, 2u);
        }
        uint64_t v35 = *((unsigned int *)v1 + 2);
        char v30 = v42;
        uint64_t v39 = v14;
        char v40 = v42;
        if (v42) {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100058DB0(__p, "");
        uint64_t v36 = *((unsigned int *)v1 + 2);
        *(void *)CSIPhoneNumber buf = off_101A7EC20;
        *(void *)&uint8_t buf[8] = v2;
        *(void *)&uint8_t buf[16] = v36;
        char v44 = buf;
        sub_101015064(v2, v35, &v39, 3, (uint64_t)buf);
        goto LABEL_52;
      }
      int v27 = *((_DWORD *)v1 + 3);
    }
    if (v27 == 3 && (*(unsigned int (**)(uint64_t))(*(void *)v14 + 32))(v14) == 3)
    {
      std::string v28 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CSIPhoneNumber buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Application Phone book is not available, retrying on SIM Phone Book", buf, 2u);
      }
      uint64_t v29 = *((unsigned int *)v1 + 2);
      char v30 = v42;
      uint64_t v39 = v14;
      char v40 = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100058DB0(__p, "");
      uint64_t v31 = *((unsigned int *)v1 + 2);
      *(void *)CSIPhoneNumber buf = off_101A7ECA0;
      *(void *)&uint8_t buf[8] = v2;
      *(void *)&uint8_t buf[16] = v31;
      char v44 = buf;
      sub_101015064(v2, v29, &v39, 0, (uint64_t)buf);
LABEL_52:
      sub_100060644(buf);
      if (v38 < 0) {
        operator delete(__p[0]);
      }
      if (v30) {
        sub_10004D2C8(v30);
      }
      goto LABEL_44;
    }
    uint32_t v32 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = asString();
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N %s Phone book unavailable", buf, 0xCu);
    }
    (*(void (**)(void *, void))(*v2[9] + 304))(v2[9], *((unsigned int *)v1 + 2));
  }
  else
  {
    uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *((unsigned int *)v1 + 2));
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
    }
  }
LABEL_44:
  if (v42) {
    sub_10004D2C8(v42);
  }
  operator delete();
}

void sub_10101E968(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20)
{
  sub_100060644(&a20);
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  operator delete();
}

void sub_10101EA0C()
{
}

__n128 sub_10101EA20(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7EC20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10101EA6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7EC20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10101EA9C(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(result + 8) + 72) + 304))(*(void *)(*(void *)(result + 8) + 72), *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t sub_10101EAE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10101EB24()
{
}

void sub_10101EB34()
{
}

__n128 sub_10101EB48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A7ECA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10101EB94(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7ECA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10101EBC4(uint64_t result, unsigned char *a2)
{
  if (!*a2) {
    return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(result + 8) + 72) + 304))(*(void *)(*(void *)(result + 8) + 72), *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t sub_10101EC0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10101EC4C()
{
}

uint64_t *sub_10101EC58(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint32_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(v1 + 16))
  {
    *(void *)CSIPhoneNumber buf = 0;
    uint64_t v24 = 0;
    sub_100039CB8(buf, v2 + 120, *(_DWORD *)(v1 + 8));
    uint64_t v3 = *(void *)buf;
    if (*(void *)buf)
    {
      uint64_t v4 = *(void **)(v1 + 16);
      int v7 = (void *)*v4;
      uint64_t v5 = v4 + 1;
      int v6 = v7;
      if (v7 != v5)
      {
        while (*((_DWORD *)v6 + 7) != 2)
        {
          uint64_t v8 = (void *)v6[1];
          if (v8)
          {
            do
            {
              uint32_t v9 = v8;
              uint64_t v8 = (void *)*v8;
            }
            while (v8);
          }
          else
          {
            do
            {
              uint32_t v9 = (void *)v6[2];
              BOOL v10 = *v9 == (void)v6;
              int v6 = v9;
            }
            while (!v10);
          }
          int v6 = v9;
          if (v9 == v5) {
            goto LABEL_20;
          }
        }
      }
      if (v6 == v5)
      {
LABEL_20:
        uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v22 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MSISDN file is not present, assuming read attempted", v22, 2u);
        }
        (*(void (**)(uint64_t, void))(*(void *)v3 + 200))(v3, 0);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 136))(v3, 1);
        int v15 = *(std::__shared_weak_count **)(v2 + 112);
        if (v15)
        {
          uint64_t v16 = std::__shared_weak_count::lock(v15);
          if (v16)
          {
            uint64_t v17 = v16;
            uint64_t v18 = *(void *)(v2 + 104);
            if (v18) {
              (*(void (**)(uint64_t, void, void, const char *))(*(void *)v18 + 304))(v18, *(unsigned int *)(v1 + 8), 0, "phonebooksPresent");
            }
            sub_10004D2C8(v17);
          }
        }
      }
      else
      {
        uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)char v22 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MSISDN file is present", v22, 2u);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 200))(v3, 1);
      }
      (*(void (**)(uint64_t, void))(*(void *)v3 + 240))(v3, *(void *)(v1 + 16));
    }
    else
    {
      uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)char v22 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "No phonebook model", v22, 2u);
      }
    }
    if (v24) {
      sub_10004D2C8(v24);
    }
  }
  else
  {
    int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CSIPhoneNumber buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Invalid object received for phone books present", buf, 2u);
    }
  }
  sub_10013A778(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_10101EFFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  sub_10004D2C8(v14);
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10013A778(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10101F048(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v95 = a1;
  uint64_t v96 = v1;
  if (*(unsigned char *)(*(void *)(v1 + 40) + 49)) {
    goto LABEL_180;
  }
  uint64_t v2 = *(void *)v1;
  if (!isReal()) {
    goto LABEL_180;
  }
  unsigned int v3 = *(unsigned __int8 *)(v1 + 32);
  if (v3 >= 2)
  {
    if (v3 == 2 || v3 == 6)
    {
      uint64_t v5 = *(unsigned int *)(*(void *)(v1 + 40) + 52);
      v103[0] = 0;
      v103[1] = 0;
      sub_100039CB8(v103, v2 + 120, v5);
      if (v103[0])
      {
        memset(buf, 0, sizeof(buf));
        int v6 = sub_100039C68(v2 + 120, v5);
        int v7 = (char *)(v6 + 1);
        if (!v6) {
          int v7 = (char *)&kInvalidPersonalityId;
        }
        if (v7[23] < 0)
        {
          sub_10004FC84(buf, *(void **)v7, *((void *)v7 + 1));
        }
        else
        {
          long long v8 = *(_OWORD *)v7;
          *(void *)&uint8_t buf[16] = *((void *)v7 + 2);
          *(_OWORD *)CSIPhoneNumber buf = v8;
        }
        memset(&v115, 0, sizeof(v115));
        BOOL v32 = sub_10001D294(buf, (unsigned __int8 *)&v115);
        if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v115.__r_.__value_.__l.__data_);
        }
        if (!v32)
        {
          uint64_t v33 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v5);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v34 = buf[23];
            if ((buf[23] & 0x80u) != 0) {
              uint64_t v34 = *(void *)&buf[8];
            }
            uint64_t v35 = buf;
            if ((buf[23] & 0x80u) != 0) {
              uint64_t v35 = *(uint8_t **)buf;
            }
            if (v34) {
              uint64_t v36 = (const char *)v35;
            }
            else {
              uint64_t v36 = "<invalid>";
            }
            LODWORD(v115.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v115.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I SIM %s is gone from slot, clearing off the Phone Number, Voice Mail Number", (uint8_t *)&v115, 0xCu);
          }
          memset(&v115, 0, sizeof(v115));
          uint64_t v37 = sub_100039C68(v2 + 120, v5);
          if (v37)
          {
            std::string::operator=((std::string *)(v37 + 1), &v115);
            if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v115.__r_.__value_.__l.__data_);
            }
          }
          char v38 = sub_100039C68(v2 + 120, v5);
          uint64_t v39 = v38;
          if (v38)
          {
            uint64_t v40 = v38[4];
            if (v40) {
              (*(void (**)(uint64_t, void))(*(void *)v40 + 256))(v40, 0);
            }
            *((unsigned char *)v39 + 5) = 0;
          }
          (*(void (**)(void, uint64_t))(**(void **)(v2 + 88) + 80))(*(void *)(v2 + 88), v5);
          uint64_t v41 = *(std::__shared_weak_count **)(v2 + 112);
          if (v41)
          {
            char v42 = std::__shared_weak_count::lock(v41);
            if (v42)
            {
              uint64_t v43 = v42;
              uint64_t v44 = *(void *)(v2 + 104);
              if (v44) {
                (*(void (**)(uint64_t, uint64_t, void, const char *))(*(void *)v44 + 304))(v44, v5, 0, "handleSimGone_sync");
              }
              sub_10004D2C8(v43);
            }
          }
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
      }
      else
      {
        char v22 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v5);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "No phonebook model", buf, 2u);
        }
      }
      if (v103[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v103[1]);
      }
    }
    goto LABEL_180;
  }
  uint64_t v9 = *(void *)(v1 + 40);
  uint64_t v10 = *(unsigned int *)(v9 + 52);
  if (!v3)
  {
    int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v9 + 52));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(unsigned __int8 *)(v9 + 47);
      BOOL v13 = (v12 & 0x80u) != 0;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(v9 + 32);
      }
      if (v13) {
        uint64_t v14 = *(const char **)(v9 + 24);
      }
      else {
        uint64_t v14 = (const char *)(v9 + 24);
      }
      if (v12) {
        int v15 = v14;
      }
      else {
        int v15 = "<invalid>";
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v15;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I SIM %s is announced on the slot", buf, 0xCu);
    }
    uint64_t v16 = sub_100039C68(v2 + 120, v10);
    uint64_t v17 = v16;
    if (v16)
    {
      uint64_t v18 = v16[4];
      if (v18) {
        (*(void (**)(uint64_t, void))(*(void *)v18 + 256))(v18, 0);
      }
      *((unsigned char *)v17 + 5) = 0;
    }
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 88) + 80))(*(void *)(v2 + 88), v10);
  }
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v98 = 0;
  unint64_t v19 = sub_100039C68(v2 + 120, v10);
  uint32_t v20 = (char *)(v19 + 1);
  if (!v19) {
    uint32_t v20 = (char *)&kInvalidPersonalityId;
  }
  if (v20[23] < 0)
  {
    sub_10004FC84(__dst, *(void **)v20, *((void *)v20 + 1));
  }
  else
  {
    long long v21 = *(_OWORD *)v20;
    uint64_t v98 = *((void *)v20 + 2);
    *(_OWORD *)long long __dst = v21;
  }
  if (!sub_10001D294((unsigned __int8 *)__dst, (unsigned __int8 *)(v9 + 24)))
  {
    char v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v10);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = *(unsigned __int8 *)(v9 + 47);
      BOOL v25 = (v24 & 0x80u) != 0;
      if ((v24 & 0x80u) != 0) {
        uint64_t v24 = *(void *)(v9 + 32);
      }
      if (v25) {
        uint64_t v26 = *(const char **)(v9 + 24);
      }
      else {
        uint64_t v26 = (const char *)(v9 + 24);
      }
      if (v24) {
        int v27 = v26;
      }
      else {
        int v27 = "<invalid>";
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I SIM %s is added on the slot", buf, 0xCu);
    }
    std::string v28 = sub_100039C68(v2 + 120, v10);
    if (v28)
    {
      std::string::operator=((std::string *)(v28 + 1), (const std::string *)(v9 + 24));
      uint64_t v105 = 0;
      uint64_t v106 = 0;
      sub_100039CB8(&v105, v2 + 120, v10);
      uint64_t v94 = v105;
      if (!v105)
      {
        unint64_t v45 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v10);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CSIPhoneNumber buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "retrieveNetworkAndCopiedPhoneNumber_sync, No phonebook model", buf, 2u);
        }
        goto LABEL_158;
      }
      v103[0] = 0;
      v103[1] = 0;
      uint64_t v104 = 0;
      uint64_t v29 = sub_100039C68(v2 + 120, v10);
      char v30 = (char *)(v29 + 1);
      if (!v29) {
        char v30 = (char *)&kInvalidPersonalityId;
      }
      if (v30[23] < 0)
      {
        sub_10004FC84(v103, *(void **)v30, *((void *)v30 + 1));
      }
      else
      {
        long long v31 = *(_OWORD *)v30;
        uint64_t v104 = *((void *)v30 + 2);
        *(_OWORD *)uint64_t v103 = v31;
      }
      if ((isReal() & 1) == 0) {
        __assert_rtn("retrieveNetworkAndCopiedPhoneNumber_sync", "PhonebookHandler.cpp", 1023, "isReal(persona)");
      }
      long long v102 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v46, *(Registry **)(v2 + 56));
      uint64_t v48 = ServiceMap;
      uint64_t v50 = v49;
      if (v49 < 0)
      {
        uint64_t v51 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v52 = 5381;
        do
        {
          uint64_t v50 = v52;
          unsigned int v53 = *v51++;
          uint64_t v52 = (33 * v52) ^ v53;
        }
        while (v53);
      }
      std::mutex::lock(ServiceMap);
      *(void *)CSIPhoneNumber buf = v50;
      int v54 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)buf);
      if (v54)
      {
        uint64_t v56 = v54[3];
        uint64_t v55 = (std::__shared_weak_count *)v54[4];
        if (v55)
        {
          atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v48);
          atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v55);
          char v57 = 0;
          goto LABEL_95;
        }
      }
      else
      {
        uint64_t v56 = 0;
      }
      std::mutex::unlock(v48);
      uint64_t v55 = 0;
      char v57 = 1;
LABEL_95:
      (*(void (**)(const void **__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v56 + 24))(&v102, v56, v103, @"CachedPhoneNumber", @"phonebook", 0, 1);
      if ((v57 & 1) == 0) {
        sub_10004D2C8(v55);
      }
      uint64_t v101 = 0;
      BOOL v59 = (std::mutex *)Registry::getServiceMap(v58, *(Registry **)(v2 + 56));
      char v60 = v59;
      uint64_t v61 = v49;
      if (v49 < 0)
      {
        char v62 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v63 = 5381;
        do
        {
          uint64_t v61 = v63;
          unsigned int v64 = *v62++;
          uint64_t v63 = (33 * v63) ^ v64;
        }
        while (v64);
      }
      std::mutex::lock(v59);
      *(void *)CSIPhoneNumber buf = v61;
      uint64_t v65 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)buf);
      if (v65)
      {
        uint64_t v67 = v65[3];
        uint64_t v66 = (std::__shared_weak_count *)v65[4];
        if (v66)
        {
          atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v60);
          atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v66);
          char v68 = 0;
          goto LABEL_105;
        }
      }
      else
      {
        uint64_t v67 = 0;
      }
      std::mutex::unlock(v60);
      uint64_t v66 = 0;
      char v68 = 1;
LABEL_105:
      (*(void (**)(const void **__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v67 + 24))(&v101, v67, v103, @"CopiedSIMPhoneNumber", @"phonebook", 0, 1);
      if ((v68 & 1) == 0) {
        sub_10004D2C8(v66);
      }
      uint64_t v100 = 0;
      long long v70 = (std::mutex *)Registry::getServiceMap(v69, *(Registry **)(v2 + 56));
      char v71 = v70;
      if (v49 < 0)
      {
        int v72 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v73 = 5381;
        do
        {
          uint64_t v49 = v73;
          unsigned int v74 = *v72++;
          uint64_t v73 = (33 * v73) ^ v74;
        }
        while (v74);
      }
      std::mutex::lock(v70);
      *(void *)CSIPhoneNumber buf = v49;
      uint64_t v75 = sub_10004D37C(&v71[1].__m_.__sig, (unint64_t *)buf);
      if (v75)
      {
        uint64_t v77 = v75[3];
        uint64_t v76 = (std::__shared_weak_count *)v75[4];
        if (v76)
        {
          atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v71);
          atomic_fetch_add_explicit(&v76->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v76);
          char v78 = 0;
LABEL_115:
          (*(void (**)(void **__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v77 + 24))(&v100, v77, v103, @"PNRPhoneNumber", @"phonebook", 0, 1);
          if ((v78 & 1) == 0) {
            sub_10004D2C8(v76);
          }
          memset(&v115, 0, sizeof(v115));
          ctu::cf::assign();
          std::string v99 = v115;
          CSIPhoneNumber::CSIPhoneNumber();
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v94 + 152))(v94, buf);
          if (v114 < 0) {
            operator delete(__p);
          }
          if (v112 < 0) {
            operator delete(v111);
          }
          if (v110 < 0) {
            operator delete(v109[0]);
          }
          if (SHIBYTE(v108) < 0) {
            operator delete(*(void **)&buf[8]);
          }
          if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v99.__r_.__value_.__l.__data_);
          }
          uint64_t v79 = v105;
          memset(&v115, 0, sizeof(v115));
          ctu::cf::assign();
          std::string v99 = v115;
          CSIPhoneNumber::CSIPhoneNumber();
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v79 + 184))(v79, buf);
          if (v114 < 0) {
            operator delete(__p);
          }
          if (v112 < 0) {
            operator delete(v111);
          }
          if (v110 < 0) {
            operator delete(v109[0]);
          }
          if (SHIBYTE(v108) < 0) {
            operator delete(*(void **)&buf[8]);
          }
          if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v99.__r_.__value_.__l.__data_);
          }
          memset(&v115, 0, sizeof(v115));
          ctu::cf::assign();
          std::string v99 = v115;
          CSIPhoneNumber::CSIPhoneNumber();
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v79 + 168))(v79, buf);
          if (v114 < 0) {
            operator delete(__p);
          }
          if (v112 < 0) {
            operator delete(v111);
          }
          if (v110 < 0) {
            operator delete(v109[0]);
          }
          if (SHIBYTE(v108) < 0) {
            operator delete(*(void **)&buf[8]);
          }
          if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v99.__r_.__value_.__l.__data_);
          }
          uint64_t v80 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v10);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v81 = (void *)HIBYTE(v104);
            if (v104 < 0) {
              uint64_t v81 = v103[1];
            }
            int64_t v82 = v103;
            if (v104 < 0) {
              int64_t v82 = (void **)v103[0];
            }
            if (v81) {
              long long v83 = (const char *)v82;
            }
            else {
              long long v83 = "<invalid>";
            }
            *(_DWORD *)CSIPhoneNumber buf = 136315906;
            *(void *)&uint8_t buf[4] = v83;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v102;
            *(_WORD *)&unsigned char buf[22] = 2112;
            unint64_t v108 = v101;
            LOWORD(v109[0]) = 2112;
            *(void **)((char *)v109 + 2) = v100;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I for personality %s restored phone numbers: cached:'%@' / simcopy:'%@' / pnr:'%@'", buf, 0x2Au);
          }
          sub_1000577C4((const void **)&v100);
          sub_1000577C4(&v101);
          sub_1000577C4(&v102);
          if (SHIBYTE(v104) < 0) {
            operator delete(v103[0]);
          }
LABEL_158:
          if (v106) {
            sub_10004D2C8(v106);
          }
          if (v94)
          {
            uint64_t v84 = *(std::__shared_weak_count **)(v2 + 112);
            if (v84)
            {
              unint64_t v85 = std::__shared_weak_count::lock(v84);
              if (v85)
              {
                uint64_t v86 = v85;
                uint64_t v87 = *(void *)(v2 + 104);
                if (v87) {
                  (*(void (**)(uint64_t, uint64_t, void, const char *))(*(void *)v87 + 304))(v87, v10, 0, "handleSimAdded_sync");
                }
                sub_10004D2C8(v86);
              }
            }
          }
          goto LABEL_166;
        }
      }
      else
      {
        uint64_t v77 = 0;
      }
      std::mutex::unlock(v71);
      uint64_t v76 = 0;
      char v78 = 1;
      goto LABEL_115;
    }
  }
LABEL_166:
  if (v3 == 1)
  {
    uint64_t v88 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v10);
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v89 = *(unsigned __int8 *)(v9 + 47);
      BOOL v90 = (v89 & 0x80u) != 0;
      if ((v89 & 0x80u) != 0) {
        uint64_t v89 = *(void *)(v9 + 32);
      }
      if (v90) {
        uint64_t v91 = *(const char **)(v9 + 24);
      }
      else {
        uint64_t v91 = (const char *)(v9 + 24);
      }
      if (v89) {
        uint64_t v92 = v91;
      }
      else {
        uint64_t v92 = "<invalid>";
      }
      *(_DWORD *)CSIPhoneNumber buf = 136315138;
      *(void *)&uint8_t buf[4] = v92;
      _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I SIM ready: %s", buf, 0xCu);
    }
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 88) + 72))(*(void *)(v2 + 88), v10);
  }
  if (SHIBYTE(v98) < 0) {
    operator delete(__dst[0]);
  }
LABEL_180:
  sub_101020014(&v96);
  return sub_100046B58((uint64_t *)&v95);
}

void sub_10101FE60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  sub_10004D2C8(v49);
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_101020014(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_101020014(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
    if (v2) {
      sub_10004D2C8(v2);
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void sub_10102007C()
{
}

__n128 sub_101020090(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A7ED20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1010200E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7ED20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10102011C(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  int v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_101020200(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101020240()
{
}

void sub_10102024C(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == 1)
  {
    sub_100058DB0(a2, "");
  }
  else
  {
    *((unsigned char *)&v9.__r_.__value_.__s + 23) = 1;
    LOWORD(v9.__r_.__value_.__l.__data_) = 46;
    int v3 = subscriber::simSlotAsInstance();
    std::to_string(&__p, v3 + 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    int v6 = std::string::append(&v9, (const std::string::value_type *)p_p, size);
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    a2[2] = *((void *)&v6->__r_.__value_.__l + 2);
    *(_OWORD *)a2 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v9.__r_.__value_.__l.__data_);
    }
  }
}

void sub_101020324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void *sub_101020358(void *a1, void *a2, int a3, BOOL a4, BOOL a5, uint64_t a6)
{
  sub_100058DB0(__p, "RCSMessageProvisionRegistration");
  AnalyticsEvent::AnalyticsEvent(a1, (long long *)__p, a2);
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  *a1 = &off_101A7EDA0;
  if (a3 && a3 != 3)
  {
    if (*(unsigned char *)(a6 + 8))
    {
      xpc_object_t v12 = *(xpc_object_t *)a6;
      if (v12) {
        xpc_retain(v12);
      }
      else {
        xpc_object_t v12 = xpc_null_create();
      }
      int v15 = (void *)a1[4];
      a1[4] = v12;
      xpc_release(v15);
    }
    else
    {
      xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
      if (v13 || (xpc_object_t v13 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v13);
          xpc_object_t v14 = v13;
        }
        else
        {
          xpc_object_t v14 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t v13 = 0;
      }
      xpc_release(v13);
      xpc_object_t v16 = xpc_null_create();
      uint64_t v17 = (void *)a1[4];
      a1[4] = v14;
      xpc_release(v17);
      xpc_release(v16);
    }
    unsigned int v18 = analytics::simSlotAsSubsId();
    xpc_object_t v26 = xpc_int64_create(v18);
    if (!v26) {
      xpc_object_t v26 = xpc_null_create();
    }
    uint64_t v24 = a1 + 4;
    BOOL v25 = "subs_id";
    sub_100035E70((uint64_t)&v24, &v26, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v26);
    xpc_object_t v26 = 0;
    xpc_object_t v22 = xpc_BOOL_create(a4);
    if (!v22) {
      xpc_object_t v22 = xpc_null_create();
    }
    uint64_t v24 = a1 + 4;
    BOOL v25 = "is_provisioned";
    sub_100035E70((uint64_t)&v24, &v22, &v23);
    xpc_release(v23);
    xpc_object_t v23 = 0;
    xpc_release(v22);
    xpc_object_t v22 = 0;
    xpc_object_t v20 = xpc_BOOL_create(a5);
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    uint64_t v24 = a1 + 4;
    BOOL v25 = "is_registered";
    sub_100035E70((uint64_t)&v24, &v20, &v21);
    xpc_release(v21);
    xpc_object_t v21 = 0;
    xpc_release(v20);
  }
  return a1;
}

void sub_1010205FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  AnalyticsEvent::~AnalyticsEvent(v23);
  _Unwind_Resume(a1);
}

void sub_10102062C(void **a1)
{
  AnalyticsEvent::~AnalyticsEvent(a1);

  operator delete();
}

void sub_101020664()
{
}

void sub_101020734(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101020768(uint64_t a1, uint64_t a2, const char *a3, NSObject **a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, a3);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v8 = *a4;
  *(void *)(a1 + 24) = *a4;
  if (v8) {
    dispatch_retain(v8);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v13, &v15);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v13);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  v14[0] = off_101999E18;
  v14[1] = sub_101020B60;
  v14[3] = v14;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v9) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v14);
  *(void *)a1 = &off_101A7EDD8;
  uint64_t v10 = *(Registry **)a2;
  *(void *)(a1 + 56) = *(void *)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  *(void *)(a1 + 64) = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    uint64_t v10 = *(Registry **)(a1 + 56);
  }
  *(void *)(a1 + 72) = a3;
  Registry::getNotificationSenderFactory((uint64_t *)&v15, v10);
  (*(void (**)(char *))(*(void *)v15.var0 + 80))(v15.var0);
  if (v15.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v15.var1.fRef);
  }
  Registry::getNotificationSenderFactory((uint64_t *)&v15, *(Registry **)(a1 + 56));
  (*(void (**)(char *))(*(void *)v15.var0 + 120))(v15.var0);
  if (v15.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v15.var1.fRef);
  }
  return a1;
}

void sub_101020A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_101020B60(int a1)
{
  if ((a1 - 1) > 2) {
    return "set.not.?";
  }
  else {
    return off_101A7F090[a1 - 1];
  }
}

SettingsNotificationHandlerInterface *sub_101020B88(SettingsNotificationHandlerInterface *this)
{
  *(void *)this = &off_101A7EDD8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  SettingsNotificationHandlerInterface::~SettingsNotificationHandlerInterface(this);
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((SettingsNotificationHandlerInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_101020C3C(SettingsNotificationHandlerInterface *a1)
{
  sub_101020B88(a1);

  operator delete();
}

uint64_t sub_101020C74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sending Call Forwarding Setting Fetch Error", (uint8_t *)v14, 2u);
  }
  if (a2 == 1)
  {
    std::string v9 = (const void *)kCTSettingTypeCallForwarding;
    uint64_t v10 = 1;
    do
    {
      if ((v10 & a4) != 0)
      {
        v14[0] = 0;
        v14[1] = 0;
        OsLogContext v15 = 0;
        uint64_t v11 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_101024498(v14, v11, 54, v9, (std::string *)v10);
        sub_1010245B4(v14, a3);
        sub_1010218B8((uint64_t)v14, v12);
        sub_10005717C(&v15);
      }
      uint64_t v10 = (2 * v10);
    }
    while (v10 && (int)v10 < 129);
  }
  return (***(uint64_t (****)(void, uint64_t, uint64_t, uint64_t))(a1 + 80))(*(void *)(a1 + 80), a2, a3, a4);
}

void sub_101020DF8(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101020E0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sending Call Forwarding Setting Save Error", (uint8_t *)v16, 2u);
  }
  if (a2 == 1)
  {
    uint64_t v11 = (const void *)kCTSettingTypeCallForwarding;
    uint64_t v12 = 1;
    do
    {
      if ((v12 & a4) != 0)
      {
        v16[0] = 0;
        v16[1] = 0;
        uint64_t v17 = 0;
        uint64_t v13 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_1010246BC(v16, v13, 56, v11, (std::string *)v12, a5);
        sub_1010245B4(v16, a3);
        sub_1010218B8((uint64_t)v16, v14);
        sub_10005717C(&v17);
      }
      uint64_t v12 = (2 * v12);
    }
    while (v12 && (int)v12 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 8))(*(void *)(a1 + 80), a2, a3, a4, a5);
}

void sub_101020F9C(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

void sub_101020FB0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, CSIPhoneNumber *a7)
{
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Sending Call Forwarding Setting Value Available Notification", (uint8_t *)&buf, 2u);
  }
  unsigned int v26 = a2;
  if (a2 == 1)
  {
    char v30 = (const void *)kCTSettingTypeCallForwarding;
    uint64_t v12 = (const void *)kCTSettingEnabled;
    uint64_t v13 = &kCFBooleanFalse;
    xpc_object_t v14 = (const void *)kCTSettingCallForwardingNumber;
    std::string v28 = (const void *)kCTSettingCallForwardingNoReplyTime;
    if (a5) {
      uint64_t v13 = &kCFBooleanTrue;
    }
    CFBooleanRef v15 = *v13;
    uint64_t v16 = 1;
    do
    {
      if ((v16 & a4) != 0)
      {
        v44[0] = 0;
        v44[1] = 0;
        unint64_t v45 = 0;
        uint64_t v17 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        unsigned int v18 = sub_101024498(v44, v17, 53, v30, (std::string *)v16);
        sub_1010245B4(v18, a3);
        sub_101021768(v44, v12, v15);
        CSIPhoneNumber::getFullNumber((uint64_t *)&__p, a7);
        if (SHIBYTE(v42) < 0)
        {
          sub_10004FC84(&__dst, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          long long __dst = __p;
          uint64_t v48 = v42;
        }
        std::string v46 = 0;
        if (SHIBYTE(v48) < 0)
        {
          sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          long long buf = __dst;
          uint64_t v50 = v48;
        }
        uint64_t v51 = 0;
        if (ctu::cf::convert_copy())
        {
          unint64_t v19 = v46;
          std::string v46 = v51;
          v52[0] = v19;
          sub_1000558F4(v52);
        }
        if (SHIBYTE(v50) < 0) {
          operator delete((void *)buf);
        }
        xpc_object_t v20 = v46;
        uint64_t v43 = v46;
        std::string v46 = 0;
        sub_1000558F4(&v46);
        if (SHIBYTE(v48) < 0) {
          operator delete((void *)__dst);
        }
        v52[0] = v20;
        if (v20) {
          CFRetain(v20);
        }
        sub_1010225D4(v44, v14, v52);
        sub_1000577C4(v52);
        sub_1000558F4(&v43);
        if (SHIBYTE(v42) < 0) {
          operator delete((void *)__p);
        }
        if (a3 == 2)
        {
          *(void *)&long long __dst = 0;
          LODWORD(buf) = a6;
          CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &buf);
          if (v22)
          {
            uint64_t v23 = __dst;
            *(void *)&long long __dst = v22;
            *(void *)&long long buf = v23;
            sub_1000570E8((const void **)&buf);
          }
          uint64_t v24 = (const void *)__dst;
          uint64_t v51 = (const void *)__dst;
          *(void *)&long long __dst = 0;
          sub_1000570E8((const void **)&__dst);
          *(void *)&long long buf = v24;
          if (v24) {
            CFRetain(v24);
          }
          sub_1010225D4(v44, v28, (const void **)&buf);
          sub_1000577C4((const void **)&buf);
          sub_1000570E8(&v51);
        }
        sub_1010218B8((uint64_t)v44, v21);
        sub_10005717C(&v45);
      }
      uint64_t v16 = (2 * v16);
    }
    while (v16 && (int)v16 < 129);
  }
  uint64_t v25 = *(void *)(a1 + 80);
  sub_10009DB3C((uint64_t)v32, (uint64_t)a7);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t, void, void, unsigned char *))(*(void *)v25 + 16))(v25, v26, a3, a4, a5, a6, v32);
  if (v40 < 0) {
    operator delete(v39);
  }
  if (v38 < 0) {
    operator delete(v37);
  }
  if (v36 < 0) {
    operator delete(v35);
  }
  if (v34 < 0) {
    operator delete(v33);
  }
}

void sub_10102139C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39)
{
}

uint64_t sub_101021458(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v16[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Sending Call Forwarding Setting Value Saved Notification", (uint8_t *)v16, 2u);
  }
  if (a2 == 1)
  {
    uint64_t v11 = (const void *)kCTSettingTypeCallForwarding;
    uint64_t v12 = 1;
    do
    {
      if ((v12 & a4) != 0)
      {
        v16[0] = 0;
        v16[1] = 0;
        uint64_t v17 = 0;
        uint64_t v13 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_1010246BC(v16, v13, 55, v11, (std::string *)v12, a5);
        sub_1010245B4(v16, a3);
        sub_1010218B8((uint64_t)v16, v14);
        sub_10005717C(&v17);
      }
      uint64_t v12 = (2 * v12);
    }
    while (v12 && (int)v12 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80), a2, a3, a4, a5);
}

void sub_1010215E8(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010215FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending Unconditional Call Forwarding Notification", (uint8_t *)v10, 2u);
  }
  if (a2 == 1)
  {
    v10[1] = (NSObject **)20;
    v10[0] = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
    uint64_t v11 = 0;
    long long v7 = (const void **)&kCFBooleanFalse;
    if (a3) {
      long long v7 = (const void **)&kCFBooleanTrue;
    }
    sub_101021768(v10, kCTIndicatorsUnconditionalCallForwarding, *v7);
    sub_1010218B8((uint64_t)v10, v8);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80), a2, a3);
}

void sub_101021754(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

void sub_101021768(NSObject ***a1, const void *a2, const void *a3)
{
  if (a3)
  {
    sub_101024214((const void **)theDict, (uint64_t)a1);
    CFDictionarySetValue(theDict[0], a2, a3);
    sub_10005717C((const void **)theDict);
  }
  else
  {
    uint64_t v5 = **a1;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      HIDWORD(theDict[1]) = 0;
      uint64_t v9 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = 0u;
      uint64_t v7 = 0;
      LODWORD(theDict[0]) = 136315138;
      *(CFMutableDictionaryRef *)((char *)theDict + 4) = (CFMutableDictionaryRef)__p;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Cannot add a NULL object to the CF dictionary for key: %s", (uint8_t *)theDict, 0xCu);
      if (SHIBYTE(v7) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_101021884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010218B8(uint64_t a1, const void *a2)
{
  ctu::cf_to_xpc((uint64_t *)&object, *(ctu **)(a1 + 16), a2);
  xpc_object_t v3 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  xpc_release(object);
  int v4 = *(_DWORD *)(a1 + 8);
  xpc_object_t object = v3;
  if (v3)
  {
    xpc_retain(v3);
    xpc_object_t v5 = v3;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t object = v5;
  }
  xpc_object_t v6 = xpc_null_create();
  xpc_object_t v7 = v6;
  sub_1000452AC(v4, &object, &v7);
  xpc_release(v6);
  xpc_release(v5);
  xpc_release(v3);
}

void sub_101021998(_Unwind_Exception *a1)
{
  xpc_release(v3);
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010219D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    xpc_object_t v6 = (const void *)kCTSettingTypeCallWaiting;
    uint64_t v7 = 1;
    do
    {
      if ((v7 & a3) != 0)
      {
        v11[0] = 0;
        v11[1] = 0;
        uint64_t v12 = 0;
        uint64_t v8 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_101024498(v11, v8, 54, v6, (std::string *)v7);
        sub_1010218B8((uint64_t)v11, v9);
        sub_10005717C(&v12);
      }
      uint64_t v7 = (2 * v7);
    }
    while (v7 && (int)v7 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), a2, a3);
}

void sub_101021ADC(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101021AF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1)
  {
    uint64_t v8 = (const void *)kCTSettingTypeCallWaiting;
    uint64_t v9 = 1;
    do
    {
      if ((v9 & a3) != 0)
      {
        v13[0] = 0;
        v13[1] = 0;
        xpc_object_t v14 = 0;
        uint64_t v10 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_1010246BC(v13, v10, 56, v8, (std::string *)v9, a4);
        sub_1010218B8((uint64_t)v13, v11);
        sub_10005717C(&v14);
      }
      uint64_t v9 = (2 * v9);
    }
    while (v9 && (int)v9 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), a2, a3, a4);
}

void sub_101021C08(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101021C1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1)
  {
    uint64_t v8 = (const void *)kCTSettingTypeCallWaiting;
    uint64_t v9 = (const void *)kCTSettingEnabled;
    uint64_t v10 = &kCFBooleanTrue;
    if (!a4) {
      uint64_t v10 = &kCFBooleanFalse;
    }
    CFBooleanRef v11 = *v10;
    uint64_t v12 = 1;
    do
    {
      if ((v12 & a3) != 0)
      {
        v16[0] = 0;
        v16[1] = 0;
        uint64_t v17 = 0;
        uint64_t v13 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_101024498(v16, v13, 53, v8, (std::string *)v12);
        sub_101021768(v16, v9, v11);
        sub_1010218B8((uint64_t)v16, v14);
        sub_10005717C(&v17);
      }
      uint64_t v12 = (2 * v12);
    }
    while (v12 && (int)v12 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 56))(*(void *)(a1 + 80), a2, a3, a4);
}

void sub_101021D70(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101021D84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1)
  {
    uint64_t v8 = (const void *)kCTSettingTypeCallWaiting;
    uint64_t v9 = 1;
    do
    {
      if ((v9 & a3) != 0)
      {
        v13[0] = 0;
        v13[1] = 0;
        xpc_object_t v14 = 0;
        uint64_t v10 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_1010246BC(v13, v10, 55, v8, (std::string *)v9, a4);
        sub_1010218B8((uint64_t)v13, v11);
        sub_10005717C(&v14);
      }
      uint64_t v9 = (2 * v9);
    }
    while (v9 && (int)v9 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 64))(*(void *)(a1 + 80), a2, a3, a4);
}

void sub_101021E9C(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101021EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1)
  {
    uint64_t v8 = (const void *)kCTSettingTypeCallBarring;
    uint64_t v9 = 1;
    do
    {
      if ((v9 & a3) != 0)
      {
        v13[0] = 0;
        v13[1] = 0;
        xpc_object_t v14 = 0;
        uint64_t v10 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_101024498(v13, v10, 54, v8, (std::string *)v9);
        sub_10102483C(v13, a4);
        sub_1010218B8((uint64_t)v13, v11);
        sub_10005717C(&v14);
      }
      uint64_t v9 = (2 * v9);
    }
    while (v9 && (int)v9 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 72))(*(void *)(a1 + 80), a2, a3, a4);
}

void sub_101021FD0(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101021FE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 == 1)
  {
    uint64_t v10 = (const void *)kCTSettingTypeCallBarring;
    uint64_t v11 = 1;
    do
    {
      if ((v11 & a3) != 0)
      {
        v15[0] = 0;
        v15[1] = 0;
        uint64_t v16 = 0;
        uint64_t v12 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_1010246BC(v15, v12, 56, v10, (std::string *)v11, a4);
        sub_10102483C(v15, a5);
        sub_1010218B8((uint64_t)v15, v13);
        sub_10005717C(&v16);
      }
      uint64_t v11 = (2 * v11);
    }
    while (v11 && (int)v11 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 80))(*(void *)(a1 + 80), a2, a3, a4, a5);
}

void sub_101022110(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101022124(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 == 1)
  {
    uint64_t v10 = (const void *)kCTSettingTypeCallBarring;
    uint64_t v11 = (const void *)kCTSettingEnabled;
    uint64_t v12 = &kCFBooleanTrue;
    if (!a5) {
      uint64_t v12 = &kCFBooleanFalse;
    }
    CFBooleanRef v13 = *v12;
    uint64_t v14 = 1;
    do
    {
      if ((v14 & a3) != 0)
      {
        v18[0] = 0;
        v18[1] = 0;
        unint64_t v19 = 0;
        CFBooleanRef v15 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_101024498(v18, v15, 53, v10, (std::string *)v14);
        sub_10102483C(v18, a4);
        sub_101021768(v18, v11, v13);
        sub_1010218B8((uint64_t)v18, v16);
        sub_10005717C(&v19);
      }
      uint64_t v14 = (2 * v14);
    }
    while (v14 && (int)v14 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 88))(*(void *)(a1 + 80), a2, a3, a4, a5);
}

void sub_10102228C(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010222A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 == 1)
  {
    uint64_t v10 = (const void *)kCTSettingTypeCallBarring;
    uint64_t v11 = 1;
    do
    {
      if ((v11 & a3) != 0)
      {
        v15[0] = 0;
        v15[1] = 0;
        uint64_t v16 = 0;
        uint64_t v12 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
        sub_1010246BC(v15, v12, 55, v10, (std::string *)v11, a4);
        sub_10102483C(v15, a5);
        sub_1010218B8((uint64_t)v15, v13);
        sub_10005717C(&v16);
      }
      uint64_t v11 = (2 * v11);
    }
    while (v11 && (int)v11 < 129);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 96))(*(void *)(a1 + 80), a2, a3, a4, a5);
}

void sub_1010223CC(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010223E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v14[0] = 0;
    v14[1] = 0;
    CFBooleanRef v15 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v14, v6, 55, kCTSettingTypeSupplementaryServicePassword);
    CFNumberRef v16 = 0;
    unint64_t valuePtr = a3;
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    if (v7)
    {
      unint64_t v8 = (unint64_t)v16;
      CFNumberRef v16 = v7;
      unint64_t valuePtr = v8;
      sub_1000570E8((const void **)&valuePtr);
    }
    CFNumberRef v9 = v16;
    CFNumberRef v13 = v16;
    CFNumberRef v16 = 0;
    sub_1000570E8((const void **)&v16);
    CFNumberRef v12 = v9;
    if (v9) {
      CFRetain(v9);
    }
    sub_1010225D4(v14, kCTSettingSupplementaryServiceType, (const void **)&v12);
    sub_1000577C4((const void **)&v12);
    sub_1010218B8((uint64_t)v14, v10);
    sub_1000570E8((const void **)&v13);
    sub_10005717C(&v15);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 104))(*(void *)(a1 + 80), a2, a3);
}

void sub_10102253C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1000570E8((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_101022578(uint64_t a1, uint64_t a2, int a3, const void *a4)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  sub_101021768((NSObject ***)a1, kCTSettingType, a4);
  return a1;
}

void sub_1010225C0(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

void sub_1010225D4(NSObject ***a1, const void *a2, const void **a3)
{
  if (*a3) {
    int v4 = sub_100080934;
  }
  else {
    int v4 = 0;
  }
  if (v4)
  {
    sub_101024214((const void **)theDict, (uint64_t)a1);
    CFDictionarySetValue(theDict[0], a2, *a3);
    sub_10005717C((const void **)theDict);
  }
  else
  {
    uint64_t v6 = **a1;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      HIDWORD(theDict[1]) = 0;
      uint64_t v10 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long __p = 0u;
      uint64_t v8 = 0;
      LODWORD(theDict[0]) = 136315138;
      *(CFMutableDictionaryRef *)((char *)theDict + 4) = (CFMutableDictionaryRef)__p;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Cannot add a invalid object to the CF dictionary for key: %s", (uint8_t *)theDict, 0xCu);
      if (SHIBYTE(v8) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10102270C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101022740(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v14[0] = 0;
    v14[1] = 0;
    CFBooleanRef v15 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v14, v6, 56, kCTSettingTypeSupplementaryServicePassword);
    CFNumberRef v16 = 0;
    unint64_t valuePtr = a3;
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    if (v7)
    {
      unint64_t v8 = (unint64_t)v16;
      CFNumberRef v16 = v7;
      unint64_t valuePtr = v8;
      sub_1000570E8((const void **)&valuePtr);
    }
    CFNumberRef v9 = v16;
    CFNumberRef v13 = v16;
    CFNumberRef v16 = 0;
    sub_1000570E8((const void **)&v16);
    CFNumberRef v12 = v9;
    if (v9) {
      CFRetain(v9);
    }
    sub_1010225D4(v14, kCTSettingSupplementaryServiceType, (const void **)&v12);
    sub_1000577C4((const void **)&v12);
    sub_1010218B8((uint64_t)v14, v10);
    sub_1000570E8((const void **)&v13);
    sub_10005717C(&v15);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 112))(*(void *)(a1 + 80), a2, a3);
}

void sub_10102289C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1000570E8((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010228D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1)
  {
    v14[0] = 0;
    v14[1] = 0;
    CFBooleanRef v15 = 0;
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v14, v8, 53, kCTSettingTypeCallingLineIdRestriction);
    CFNumberRef v9 = (const void **)&kCTSettingCallingLineIdRestrictionDisabled;
    uint64_t v10 = (const void **)&kCTSettingCallingLineIdRestrictionEnabled;
    if (a3 != 1) {
      uint64_t v10 = (const void **)&kCTSettingCallingLineIdRestrictionUnknown;
    }
    if (a3) {
      CFNumberRef v9 = v10;
    }
    sub_101021768(v14, kCTSettingCallingLineIdRestriction, *v9);
    if (a4)
    {
      CFNumberRef v12 = (const void **)&kCTSettingCallingLineIdRestrictionModifiable;
      if (a4 != 1) {
        CFNumberRef v12 = (const void **)&kCTSettingCallingLineIdRestrictionNotModifiable;
      }
      sub_101021768(v14, kCTSettingCallingLineIdRestrictionModification, *v12);
    }
    sub_1010218B8((uint64_t)v14, v11);
    sub_10005717C(&v15);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 120))(*(void *)(a1 + 80), a2, a3, a4);
}

void sub_101022A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101022A48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v10[0] = 0;
    v10[1] = 0;
    uint64_t v11 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v10, v6, 54, kCTSettingTypeCallingLineIdRestriction);
    if (a3)
    {
      uint64_t v8 = (const void **)&kCTSettingCallingLineIdRestrictionModifiable;
      if (a3 != 1) {
        uint64_t v8 = (const void **)&kCTSettingCallingLineIdRestrictionNotModifiable;
      }
      sub_101021768(v10, kCTSettingCallingLineIdRestrictionModification, *v8);
    }
    sub_1010218B8((uint64_t)v10, v7);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 128))(*(void *)(a1 + 80), a2, a3);
}

void sub_101022B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101022B68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v9[0] = 0;
    v9[1] = 0;
    uint64_t v10 = 0;
    uint64_t v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022C50(v9, v6, 56, kCTSettingTypeCallingLineIdRestriction, a3);
    sub_1010218B8((uint64_t)v9, v7);
    sub_10005717C(&v10);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 136))(*(void *)(a1 + 80), a2, a3);
}

void sub_101022C3C(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

NSObject ***sub_101022C50(NSObject ***a1, NSObject **a2, int a3, const void *a4, unsigned int a5)
{
  sub_101022578((uint64_t)a1, (uint64_t)a2, a3, a4);
  uint64_t v8 = *a2;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (a5 > 5) {
      CFNumberRef v9 = "MMI Procedure unknown";
    }
    else {
      CFNumberRef v9 = off_101A7F130[a5];
    }
    int v13 = 136315138;
    uint64_t v14 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding MMI Procedure %s", (uint8_t *)&v13, 0xCu);
  }
  switch(a5)
  {
    case 1u:
      uint64_t v10 = (const void **)&kCTSettingMMIProcedureActivation;
      goto LABEL_13;
    case 2u:
      uint64_t v10 = (const void **)&kCTSettingMMIProcedureDeactivation;
      goto LABEL_13;
    case 3u:
      uint64_t v10 = (const void **)&kCTSettingMMIProcedureInterrogation;
      goto LABEL_13;
    case 4u:
      uint64_t v10 = (const void **)&kCTSettingMMIProcedureRegistration;
      goto LABEL_13;
    case 5u:
      uint64_t v10 = (const void **)&kCTSettingMMIProcedureErasure;
LABEL_13:
      uint64_t v11 = *v10;
      break;
    default:
      uint64_t v11 = 0;
      break;
  }
  sub_101021768(a1, kCTSettingMMIProcedure, v11);
  return a1;
}

void sub_101022DA8(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_101022DD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v9[0] = 0;
    v9[1] = 0;
    uint64_t v10 = 0;
    uint64_t v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022C50(v9, v6, 55, kCTSettingTypeCallingLineIdRestriction, a3);
    sub_1010218B8((uint64_t)v9, v7);
    sub_10005717C(&v10);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 144))(*(void *)(a1 + 80), a2, a3);
}

void sub_101022EA4(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_101022EB8(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v7[0] = 0;
    v7[1] = 0;
    uint64_t v8 = 0;
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v7, v4, 57, kCTSettingTypeCallingLineIdRestriction);
    sub_1010218B8((uint64_t)v7, v5);
    sub_10005717C(&v8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 152))(*(void *)(a1 + 80), a2);
}

void sub_101022F80(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_101022F94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v11[0] = 0;
    v11[1] = 0;
    CFNumberRef v12 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v11, v6, 53, kCTSettingTypeConnectedLineIdRestriction);
    uint64_t v7 = (const void **)&kCTSettingConnectedLineIdRestrictionNotAvailable;
    uint64_t v8 = (const void **)&kCTSettingConnectedLineIdRestrictionAvailable;
    if (a3 != 1) {
      uint64_t v8 = (const void **)&kCTSettingConnectedLineIdRestrictionUnknown;
    }
    if (a3) {
      uint64_t v7 = v8;
    }
    sub_101021768(v11, kCTSettingConnectedLineIdRestriction, *v7);
    sub_1010218B8((uint64_t)v11, v9);
    sub_10005717C(&v12);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 160))(*(void *)(a1 + 80), a2, a3);
}

void sub_1010230B0(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010230C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v10[0] = 0;
    v10[1] = 0;
    uint64_t v11 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v7 = (const void **)&kCTSettingTypeConnectedLinePresentation;
    if (a3) {
      uint64_t v7 = (const void **)&kCTSettingTypeCallingLinePresentation;
    }
    sub_101022578((uint64_t)v10, v6, 54, *v7);
    sub_1010218B8((uint64_t)v10, v8);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 168))(*(void *)(a1 + 80), a2, a3);
}

void sub_1010231A4(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010231B8(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v7[0] = 0;
    v7[1] = 0;
    uint64_t v8 = 0;
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v7, v4, 54, kCTSettingTypeConnectedLineIdRestriction);
    sub_1010218B8((uint64_t)v7, v5);
    sub_10005717C(&v8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 176))(*(void *)(a1 + 80), a2);
}

void sub_101023280(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_101023294(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v10[0] = 0;
    v10[1] = 0;
    uint64_t v11 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v10, v6, 53, kCTSettingTypeConnectedLinePresentation);
    if (a3 > 2) {
      uint64_t v7 = (const void **)&kCTSettingConnectedLinePresentationUnknown;
    }
    else {
      uint64_t v7 = (const void **)*(&off_101A7F0A8 + (int)a3);
    }
    sub_101021768(v10, kCTSettingConnectedLinePresentation, *v7);
    sub_1010218B8((uint64_t)v10, v8);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 184))(*(void *)(a1 + 80), a2, a3);
}

void sub_1010233A8(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010233BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v10[0] = 0;
    v10[1] = 0;
    uint64_t v11 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v10, v6, 53, kCTSettingTypeCallingLinePresentation);
    if (a3 > 2) {
      uint64_t v7 = (const void **)&kCTSettingCallingLinePresentationUnknown;
    }
    else {
      uint64_t v7 = (const void **)*(&off_101A7F0C0 + (int)a3);
    }
    sub_101021768(v10, kCTSettingCallingLinePresentation, *v7);
    sub_1010218B8((uint64_t)v10, v8);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 192))(*(void *)(a1 + 80), a2, a3);
}

void sub_1010234D0(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010234E4(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v7[0] = 0;
    v7[1] = 0;
    uint64_t v8 = 0;
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v7, v4, 56, kCTSettingTypeCallingLinePresentation);
    sub_1010218B8((uint64_t)v7, v5);
    sub_10005717C(&v8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 208))(*(void *)(a1 + 80), a2);
}

void sub_1010235AC(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010235C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v10[0] = 0;
    v10[1] = 0;
    uint64_t v11 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v10, v6, 55, kCTSettingTypeCallingLinePresentation);
    if (a3 > 2) {
      uint64_t v7 = (const void **)&kCTSettingCallingLinePresentationUnknown;
    }
    else {
      uint64_t v7 = (const void **)*(&off_101A7F0C0 + (int)a3);
    }
    sub_101021768(v10, kCTSettingCallingLinePresentation, *v7);
    sub_1010218B8((uint64_t)v10, v8);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 200))(*(void *)(a1 + 80), a2, a3);
}

void sub_1010236D4(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010236E8(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v7[0] = 0;
    v7[1] = 0;
    uint64_t v8 = 0;
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v7, v4, 54, kCTSettingTypeCallingNamePresentation);
    sub_1010218B8((uint64_t)v7, v5);
    sub_10005717C(&v8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 216))(*(void *)(a1 + 80), a2);
}

void sub_1010237B0(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_1010237C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 1)
  {
    v11[0] = 0;
    v11[1] = 0;
    CFNumberRef v12 = 0;
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    sub_101022578((uint64_t)v11, v6, 53, kCTSettingTypeCallingNamePresentation);
    if (a3 == 2)
    {
      uint64_t v8 = (const void **)&kCTSettingCallingNamePresentationUnknown;
    }
    else if (a3 == 1)
    {
      uint64_t v8 = (const void **)&kCTSettingCallingNamePresentationEnabled;
    }
    else
    {
      uint64_t v7 = 0;
      if (a3)
      {
LABEL_9:
        sub_101021768(v11, kCTSettingCallingNamePresentation, v7);
        sub_1010218B8((uint64_t)v11, v9);
        sub_10005717C(&v12);
        return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 224))(*(void *)(a1 + 80), a2, a3);
      }
      uint64_t v8 = (const void **)&kCTSettingCallingNamePresentationDisabled;
    }
    uint64_t v7 = *v8;
    goto LABEL_9;
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 224))(*(void *)(a1 + 80), a2, a3);
}

void sub_1010238F0(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

uint64_t sub_101023904(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v6[1] = 37;
    v6[0] = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v7 = 0;
    sub_1010218B8((uint64_t)v6, v4);
    sub_10005717C(&v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 240))(*(void *)(a1 + 80), a2);
}

void sub_1010239BC(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010239D0(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v6[1] = 38;
    v6[0] = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v7 = 0;
    sub_1010218B8((uint64_t)v6, v4);
    sub_10005717C(&v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 248))(*(void *)(a1 + 80), a2);
}

void sub_101023A88(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101023A9C(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v6[1] = 39;
    v6[0] = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v7 = 0;
    sub_1010218B8((uint64_t)v6, v4);
    sub_10005717C(&v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 256))(*(void *)(a1 + 80), a2);
}

void sub_101023B5C(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101023B70(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v6[1] = 40;
    v6[0] = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v7 = 0;
    sub_1010218B8((uint64_t)v6, v4);
    sub_10005717C(&v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 264))(*(void *)(a1 + 80), a2);
}

void sub_101023C30(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101023C44(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending sendPhoneNumberAvailable", (uint8_t *)v7, 2u);
  }
  if (a2 == 1)
  {
    v7[1] = 128;
    v7[0] = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
    uint64_t v8 = 0;
    sub_1010218B8((uint64_t)v7, v5);
    sub_10005717C(&v8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 272))(*(void *)(a1 + 80), a2);
}

void sub_101023D6C(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101023D80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending sendPhoneNumberRegistrationState", (uint8_t *)v10, 2u);
  }
  if (a2 == 1)
  {
    v10[1] = (NSObject **)127;
    v10[0] = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
    uint64_t v11 = 0;
    uint64_t v7 = (const void **)&kCFBooleanFalse;
    if (a3) {
      uint64_t v7 = (const void **)&kCFBooleanTrue;
    }
    sub_101021768(v10, kCTPhoneNumberRegistrationStateRegisteredKey, *v7);
    sub_1010218B8((uint64_t)v10, v8);
    sub_10005717C(&v11);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96), a2, a3);
}

void sub_101023ED8(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101023EEC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending sendPhoneNumberChanged", (uint8_t *)v7, 2u);
  }
  if (a2 == 1)
  {
    v7[1] = 83;
    v7[0] = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), 1);
    uint64_t v8 = 0;
    sub_1010218B8((uint64_t)v7, v5);
    sub_10005717C(&v8);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 280))(*(void *)(a1 + 80), a2);
}

void sub_101024014(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101024028(uint64_t a1, uint64_t a2)
{
  if (a2 == 1)
  {
    v6[1] = 117;
    v6[0] = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    uint64_t v7 = 0;
    sub_1010218B8((uint64_t)v6, v4);
    sub_10005717C(&v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 80) + 232))(*(void *)(a1 + 80), a2);
}

void sub_1010240E0(_Unwind_Exception *a1)
{
  sub_10005717C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1010240F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 288))();
}

uint64_t sub_101024124(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 296))();
}

void sub_101024154(uint64_t a1)
{
}

void sub_1010241F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_101024214(const void **a1, uint64_t a2)
{
  xpc_object_t v3 = (const void **)(a2 + 16);
  if (*(void *)(a2 + 16)) {
    uint64_t v4 = sub_1000C06D0;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v6 = *v3;
    *xpc_object_t v3 = Mutable;
    uint64_t v8 = v6;
    sub_10005717C(&v8);
  }
  return sub_100057240(a1, v3);
}

void sub_1010242A4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101024370(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_101024448);
  __cxa_rethrow();
}

void sub_101024398(_Unwind_Exception *a1)
{
}

void sub_1010243B0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1010243E8(uint64_t a1)
{
}

uint64_t sub_101024404(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101024448(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_101024478()
{
}

uint64_t sub_10102448C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

NSObject ***sub_101024498(NSObject ***a1, NSObject **a2, int a3, const void *a4, std::string *a5)
{
  sub_101022578((uint64_t)a1, (uint64_t)a2, a3, a4);
  uint64_t v8 = *a2;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    sub_10058F068(a5, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v14 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Adding call class %s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v10 = (const void *)sub_10058F184((int)a5);
  sub_101021768(a1, kCTSettingCallClass, v10);
  return a1;
}

void sub_10102459C(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

void sub_1010245B4(NSObject ***a1, unsigned int a2)
{
  uint64_t v4 = **a1;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 5) {
      xpc_object_t v5 = "Call Forwarding Reason unknown";
    }
    else {
      xpc_object_t v5 = off_101A7F0D8[a2];
    }
    int v7 = 136315138;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Adding Call Forwarding Reason %s", (uint8_t *)&v7, 0xCu);
  }
  if (a2 - 1 > 4) {
    uint64_t v6 = (const void **)&kCTSettingCallForwardingReasonUnconditional;
  }
  else {
    uint64_t v6 = (const void **)*(&off_101A7F108 + (int)(a2 - 1));
  }
  sub_101021768(a1, kCTSettingCallForwardingReason, *v6);
}

NSObject ***sub_1010246BC(NSObject ***a1, NSObject **a2, int a3, const void *a4, std::string *a5, unsigned int a6)
{
  sub_101024498(a1, a2, a3, a4, a5);
  CFNumberRef v9 = *a2;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (a6 > 5) {
      uint64_t v10 = "MMI Procedure unknown";
    }
    else {
      uint64_t v10 = off_101A7F130[a6];
    }
    int v14 = 136315138;
    CFBooleanRef v15 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Adding MMI Procedure %s", (uint8_t *)&v14, 0xCu);
  }
  switch(a6)
  {
    case 1u:
      uint64_t v11 = (const void **)&kCTSettingMMIProcedureActivation;
      goto LABEL_13;
    case 2u:
      uint64_t v11 = (const void **)&kCTSettingMMIProcedureDeactivation;
      goto LABEL_13;
    case 3u:
      uint64_t v11 = (const void **)&kCTSettingMMIProcedureInterrogation;
      goto LABEL_13;
    case 4u:
      uint64_t v11 = (const void **)&kCTSettingMMIProcedureRegistration;
      goto LABEL_13;
    case 5u:
      uint64_t v11 = (const void **)&kCTSettingMMIProcedureErasure;
LABEL_13:
      CFNumberRef v12 = *v11;
      break;
    default:
      CFNumberRef v12 = 0;
      break;
  }
  sub_101021768(a1, kCTSettingMMIProcedure, v12);
  return a1;
}

void sub_101024814(_Unwind_Exception *a1)
{
  sub_10005717C((const void **)(v1 + 16));
  _Unwind_Resume(a1);
}

void sub_10102483C(NSObject ***a1, unsigned int a2)
{
  uint64_t v4 = **a1;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 8) {
      xpc_object_t v5 = "Call Forwarding Reason unknown";
    }
    else {
      xpc_object_t v5 = off_101A7F160[a2];
    }
    int v7 = 136315138;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Adding Call Barring Type %s", (uint8_t *)&v7, 0xCu);
  }
  if (a2 - 1 > 7) {
    uint64_t v6 = (const void **)&kCTSettingCallBarringFacilityAllOutgoing;
  }
  else {
    uint64_t v6 = (const void **)*(&off_101A7F1A8 + (int)(a2 - 1));
  }
  sub_101021768(a1, kCTSettingCallBarringFacility, *v6);
}

void sub_101024944(uint64_t a1, NSObject **a2, NSObject **a3)
{
  if (objc_opt_class())
  {
    if (!*a2)
    {
      global_queue = dispatch_get_global_queue(0, 0);
      int v7 = global_queue;
      if (global_queue)
      {
        dispatch_retain(global_queue);
        uint64_t v8 = *a2;
        *a2 = v7;
        if (v8) {
          dispatch_release(v8);
        }
      }
      else
      {
        *a2 = 0;
      }
    }
    operator new();
  }
  xpc_object_t v5 = *a3;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFNumberRef v9 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No SystemHealthManager!", v9, 2u);
  }
}

void sub_101024A80(uint64_t *a1)
{
  int v2 = objc_opt_new();
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472;
  uint64_t v6 = sub_101024B68;
  int v7 = &unk_101A7F1E8;
  uint64_t v3 = *a1;
  uint64_t v8 = a1[1];
  objc_msgSend(v2, "postComponentStatusEventFor:status:withReply:", 6, _NSConcreteStackBlock, 3221225472, sub_101024B68, &unk_101A7F1E8, v8, v3);

  operator delete();
}

void sub_101024B34()
{
  operator delete();
}

void sub_101024B68(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(os_log_t **)(a1 + 32);
  if (v6)
  {
    os_log_t v7 = *v6;
    BOOL v8 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v8)
      {
        uint64_t v9 = *(void *)(a1 + 40);
        uint64_t v10 = "Fail";
        int v16 = 134218498;
        if (a2) {
          uint64_t v10 = "Sucess";
        }
        uint64_t v17 = v9;
        __int16 v18 = 2080;
        unint64_t v19 = v10;
        __int16 v20 = 2112;
        id v21 = v5;
        uint64_t v11 = "#I SystemHealth post component status[%lld]: %s Error: %@";
        CFNumberRef v12 = v7;
        uint32_t v13 = 32;
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v16, v13);
      }
    }
    else if (v8)
    {
      int v14 = "Fail";
      uint64_t v15 = *(void *)(a1 + 40);
      if (a2) {
        int v14 = "Sucess";
      }
      int v16 = 134218242;
      uint64_t v17 = v15;
      __int16 v18 = 2080;
      unint64_t v19 = v14;
      uint64_t v11 = "#I SystemHealth post component status[%lld]: %s";
      CFNumberRef v12 = v7;
      uint32_t v13 = 22;
      goto LABEL_11;
    }
  }
}

ctu::OsLogLogger **sub_101024CC0(ctu::OsLogLogger **a1)
{
  return a1;
}

void sub_101024DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, uint64_t a14)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101024F3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_101024F4C(uint64_t a1)
{
}

void sub_101024F54(void *a1)
{
  int v2 = [WeaLocationModule alloc];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  uint64_t v9 = a1[5];
  uint64_t v10 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a1[7];
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  id v5 = [(WeaLocationModule *)v2 initWithDelegate:&v9 withQueue:&object];
  uint64_t v6 = *(void *)(a1[4] + 8);
  os_log_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  if (object) {
    dispatch_release(object);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_101024FF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_101025014(void *a1, void *a2)
{
  uint64_t v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  a1[7] = v3;
  if (v3) {
    dispatch_retain(v3);
  }
}

void sub_101025044(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1010251E8()
{
}

void sub_101025558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10102578C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_101025984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_101025BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_101025DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_101026014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10102622C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10102633C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101026488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101026680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void **a23)
{
  a23 = (void **)&a20;
  sub_100047F64(&a23);
  _Unwind_Resume(a1);
}

void sub_10102679C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_101026918(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7F250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101026938(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7F250;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101026994()
{
  __cxa_atexit((void (*)(void *))sub_101024CC0, &qword_101B13080, (void *)&_mh_execute_header);
}

uint64_t sub_1010269F0(uint64_t a1)
{
  *(void *)a1 = off_101A7F2A0;
  if (*(unsigned char *)(a1 + 48))
  {
    *(unsigned char *)(a1 + 48) = 0;
    notify_cancel(*(_DWORD *)(a1 + 56));
    *(_DWORD *)(a1 + 56) = -1;
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_101026A68(uint64_t a1)
{
  sub_1010269F0(a1);

  operator delete();
}

uint64_t sub_101026AA0(uint64_t a1)
{
  *(void *)a1 = off_101A7F2C0;
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    [v2 invalidate];
  }
  uint64_t v6 = (void **)(a1 + 232);
  sub_100047F64(&v6);
  sub_10016D140((void *)(a1 + 200));
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  sub_101029D00((void *)(a1 + 96));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_101026B78(uint64_t a1)
{
  sub_101026AA0(a1);

  operator delete();
}

void *sub_101026BB0(void *a1)
{
  *a1 = off_101A7F2E0;
  sub_101026C00((uint64_t)a1);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101026C00(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24))
  {
    *(unsigned char *)(a1 + 24) = 0;
    uint64_t v3 = *(void **)(a1 + 8);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_101029D84;
    v9[3] = &unk_1019A1BF8;
    void v9[4] = v3;
    uint64_t v4 = (std::__shared_weak_count *)v3[2];
    if (!v4 || (uint64_t v5 = v3[1], (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      sub_100088B9C();
    }
    os_log_t v7 = v6;
    BOOL v8 = v3[3];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768;
    void block[2] = sub_100058F08;
    block[3] = &unk_101A7F5D8;
    block[5] = v5;
    uint64_t v11 = v7;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    block[4] = v9;
    dispatch_async(v8, block);
    if (v11) {
      sub_10004D2C8(v11);
    }
    sub_10004D2C8(v7);
  }
}

void sub_101026D48(void *a1)
{
  sub_101026BB0(a1);

  operator delete();
}

void sub_101026E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  if (*(void *)(v6 - 24)) {
    dispatch_release(*(dispatch_object_t *)(v6 - 24));
  }
  _Unwind_Resume(a1);
}

void sub_101026F2C(_Unwind_Exception *a1)
{
}

void sub_101027284(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(NSObject **)(v1 - 112);
  if (v3) {
    dispatch_release(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010272A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (void *)(v2 + 32);
  uint64_t v4 = *(void **)(v2 + 24);
  if (v4 == (void *)(v2 + 32))
  {
    LOBYTE(v5) = 0;
  }
  else
  {
    int v5 = 0;
    while (1)
    {
      uint64_t v6 = *(void **)(a1 + 32);
      if (v6)
      {
        [v6 getLogContext];
        os_log_t v7 = *(NSObject **)&buf[8];
      }
      else
      {
        os_log_t v7 = 0;
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v8 = v4 + 4;
        if (*((char *)v4 + 55) < 0) {
          BOOL v8 = (void *)*v8;
        }
        uint64_t v9 = *((unsigned int *)v4 + 14);
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = v8;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "connectedServices[%{public}s]: %lu", buf, 0x16u);
      }
      int v10 = *((_DWORD *)v4 + 14);
      if ((v10 & 0x1000) != 0) {
        break;
      }
      uint64_t v11 = (void *)v4[1];
      if (v11)
      {
        do
        {
          CFNumberRef v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          CFNumberRef v12 = (void *)v4[2];
          BOOL v13 = *v12 == (void)v4;
          uint64_t v4 = v12;
        }
        while (!v13);
      }
      v5 |= (unsigned __int16)(v10 & 0x1000) >> 12;
      uint64_t v4 = v12;
      if (v12 == v3) {
        goto LABEL_20;
      }
    }
    LOBYTE(v5) = 1;
  }
LABEL_20:
  pthread_mutex_lock(&stru_101B0B848);
  *(unsigned char *)(*(void *)(a1 + 32) + 8) = v5 & 1;
  pthread_mutex_unlock(&stru_101B0B848);
  int v14 = *(void **)(a1 + 32);
  if (v14)
  {
    [v14 getLogContext];
    uint64_t v15 = *(NSObject **)&buf[8];
  }
  else
  {
    uint64_t v15 = 0;
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5 & 1;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "_tetheringConnected: %d", buf, 8u);
  }
}

void sub_1010274C4(uint64_t a1, void *a2)
{
  if (a2 && [a2 identifier])
  {
    [a2 identifier];
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v10 = 0;
    unsigned int v4 = [a2 connectedServices];
    int v5 = *(void **)(a1 + 32);
    if (v5)
    {
      [v5 getLogContext];
      uint64_t v6 = *(NSObject **)&buf[8];
    }
    else
    {
      uint64_t v6 = 0;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t v7 = __p;
      if (v10 < 0) {
        os_log_t v7 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "found[%{public}s]: %lu", buf, 0x16u);
    }
    BOOL v8 = (uint64_t **)(*(void *)(a1 + 32) + 24);
    *(void *)long long buf = __p;
    *((_DWORD *)sub_100492E9C(v8, __p, (uint64_t)&unk_10144E20E, (long long **)buf) + 14) = v4;
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_101027650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101027684(uint64_t a1, void *a2)
{
  if (a2 && [a2 identifier])
  {
    [a2 identifier];
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v21 = 0;
    unsigned int v4 = [a2 connectedServices];
    int v5 = *(void **)(a1 + 32);
    if (v5)
    {
      [v5 getLogContext];
      uint64_t v6 = *(NSObject **)&buf[8];
    }
    else
    {
      uint64_t v6 = 0;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t v7 = __p;
      if (v21 < 0) {
        os_log_t v7 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "lost[%{public}s]: %lu", buf, 0x16u);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = (void *)(v8 + 24);
    uint64_t v10 = (void *)(v8 + 32);
    uint64_t v11 = *(void **)(v8 + 32);
    if (v11)
    {
      CFNumberRef v12 = (void *)(v8 + 32);
      do
      {
        char v13 = sub_100046FE8(v11 + 4, __p);
        if (v13 >= 0) {
          int v14 = v11;
        }
        else {
          int v14 = v11 + 1;
        }
        if (v13 >= 0) {
          CFNumberRef v12 = v11;
        }
        uint64_t v11 = (void *)*v14;
      }
      while (*v14);
      if (v12 != v10 && (sub_100046FE8(__p, (void **)v12 + 4) & 0x80) == 0)
      {
        uint64_t v15 = (void *)v12[1];
        if (v15)
        {
          do
          {
            int v16 = v15;
            uint64_t v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          uint64_t v17 = v12;
          do
          {
            int v16 = (void *)v17[2];
            BOOL v18 = *v16 == (void)v17;
            uint64_t v17 = v16;
          }
          while (!v18);
        }
        if ((void *)*v9 == v12) {
          *uint64_t v9 = v16;
        }
        unint64_t v19 = (uint64_t *)v9[1];
        --v9[2];
        sub_10005EE6C(v19, v12);
        if (*((char *)v12 + 55) < 0) {
          operator delete((void *)v12[4]);
        }
        operator delete(v12);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1010278B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010278E8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    [v1 getLogContext];
    uint64_t v2 = v4;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    unsigned int v4 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v3) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "invalidated", (uint8_t *)&v3, 2u);
  }
}

void sub_10102796C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3)
  {
    [v3 getLogContext];
    unsigned int v4 = *((void *)&v5 + 1);
  }
  else
  {
    unsigned int v4 = 0;
    long long v5 = 0uLL;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v5) = 138543362;
    *(void *)((char *)&v5 + 4) = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "activateWithCompletion error: %{public}@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_101027AF0()
{
}

void sub_101027B04(uint64_t a1)
{
  *(void *)a1 = off_101A7F328;
  os_log_t v7 = (void **)(a1 + 136);
  sub_10008A88C(&v7);
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100B0D31C((void *)a1);
}

void sub_101027BE8(uint64_t a1)
{
  sub_101027B04(a1);

  operator delete();
}

uint64_t sub_101027C20(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 128);
}

void sub_101027C28(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 128))
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (!*(unsigned char *)(v3 + 48))
    {
      handler = _NSConcreteStackBlock;
      uint64_t v35 = 3221225472;
      char v36 = sub_10102A4AC;
      uint64_t v37 = &unk_101A5C2E0;
      char v38 = (void ***)v3;
      uint64_t v4 = (_DWORD *)(v3 + 56);
      if (notify_register_dispatch(kSBSLockStateNotifyKey, (int *)(v3 + 56), *(dispatch_queue_t *)(v3 + 24), &handler))
      {
        long long v5 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v27) = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N ScreenLockObserver: failed to register for lock state notification", (uint8_t *)&v27, 2u);
        }
        *uint64_t v4 = -1;
      }
      else
      {
        int v6 = *(_DWORD *)(v3 + 56);
        int v27 = 0;
        notify_get_state(v6, (uint64_t *)&v27);
        byte_101B13088 = v27 != 0;
        *(unsigned char *)(v3 + 48) = 1;
      }
    }
    uint64_t v7 = *(void *)(a1 + 96);
    if (!*(unsigned char *)(v7 + 24))
    {
      uint64_t v9 = *(void **)(v7 + 8);
      int v27 = _NSConcreteStackBlock;
      uint64_t v28 = 3221225472;
      char v29 = sub_10102A5C0;
      char v30 = &unk_1019A1BF8;
      long long v31 = v9;
      uint64_t v10 = (std::__shared_weak_count *)v9[2];
      if (!v10 || (uint64_t v11 = v9[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
        sub_100088B9C();
      }
      char v13 = v12;
      int v14 = v9[3];
      handler = _NSConcreteStackBlock;
      uint64_t v35 = 3321888768;
      char v36 = sub_100058F08;
      uint64_t v37 = &unk_101A7F5D8;
      uint64_t v39 = v11;
      char v40 = v13;
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      char v38 = &v27;
      dispatch_async(v14, &handler);
      if (v40) {
        sub_10004D2C8(v40);
      }
      sub_10004D2C8(v13);
      *(unsigned char *)(v7 + 24) = 1;
    }
    uint64_t v15 = *(uint64_t **)(a1 + 104);
    if (!*((unsigned char *)v15 + 41))
    {
      int v16 = (std::__shared_weak_count *)v15[1];
      if (!v16 || (uint64_t v17 = *v15, (v18 = std::__shared_weak_count::lock(v16)) == 0)) {
        sub_100088B9C();
      }
      unint64_t v19 = v18;
      p_unint64_t shared_weak_owners = &v18->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      int v27 = _NSConcreteStackBlock;
      uint64_t v28 = 3321888768;
      char v29 = sub_10102A718;
      char v30 = &unk_101A7F868;
      long long v31 = v15;
      uint64_t v32 = v17;
      uint64_t v33 = v19;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      *((unsigned char *)v15 + 41) = 1;
      v15[6] = tcp_connection_fallback_watcher_create();
      uint64_t v21 = (std::__shared_weak_count *)v15[1];
      if (!v21 || (uint64_t v22 = *v15, (v23 = std::__shared_weak_count::lock(v21)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v24 = v23;
      uint64_t v25 = v15[2];
      handler = _NSConcreteStackBlock;
      uint64_t v35 = 3321888768;
      char v36 = sub_10102A854;
      uint64_t v37 = &unk_101A7F8A0;
      uint64_t v39 = v22;
      char v40 = v24;
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      char v38 = &v27;
      dispatch_async(v25, &handler);
      if (v40) {
        sub_10004D2C8(v40);
      }
      sub_10004D2C8(v24);
      if (v33) {
        std::__shared_weak_count::__release_weak(v33);
      }
      std::__shared_weak_count::__release_weak(v19);
    }
    *(unsigned char *)(a1 + 128) = 1;
    int v27 = _NSConcreteStackBlock;
    uint64_t v28 = 3221225472;
    char v29 = sub_101028320;
    char v30 = &unk_1019A1BF8;
    long long v31 = (void *)a1;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    sub_10003E168(&v41, (void *)(a1 + 8));
    unsigned int v26 = *(NSObject **)(a1 + 24);
    handler = _NSConcreteStackBlock;
    uint64_t v35 = 3321888768;
    char v36 = sub_10102AB14;
    uint64_t v37 = &unk_101A7F8D8;
    uint64_t v39 = v41;
    char v40 = v42;
    if (v42) {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v38 = &v27;
    dispatch_async(v26, &handler);
    if (v40) {
      sub_10004D2C8(v40);
    }
    if (v42) {
      sub_10004D2C8(v42);
    }
  }
}

void sub_10102809C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  std::__shared_weak_count::__release_weak(v15);
  _Unwind_Resume(a1);
}

void sub_1010280C8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v1 || (uint64_t v2 = std::__shared_weak_count::lock(v1)) == 0) {
    sub_100088B9C();
  }
  uint64_t v3 = v2;
  p_unint64_t shared_weak_owners = &v2->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v2);
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  SBSRegisterDisplayIdentifiersChangedBlock();
  std::__shared_weak_count::__release_weak(v3);
  std::__shared_weak_count::__release_weak(v3);
}

void sub_101028198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v16);
  _Unwind_Resume(a1);
}

void sub_1010281B8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1010282C4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1010282E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

id sub_1010282F0()
{
  std::string v0 = +[BluetoothController sharedInstance];

  return [(BluetoothController *)v0 startWatchingForDevices];
}

void sub_101028320(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  Registry::createRestModuleOneTimeUseConnection(&v2, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10035B5E0(v1 + 136);
}

void sub_10102837C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101028394(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)(a1 + 32) + 64));
}

void sub_1010283A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 128))
  {
    SBSRegisterDisplayIdentifiersChangedBlock();
    uint64_t v3 = *(void *)(a1 + 80);
    if (*(unsigned char *)(v3 + 48))
    {
      *(unsigned char *)(v3 + 48) = 0;
      notify_cancel(*(_DWORD *)(v3 + 56));
      *(_DWORD *)(v3 + 56) = -1;
    }
    sub_101026C00(*(void *)(a1 + 96));
    uint64_t v4 = *(void *)(a1 + 104);
    if (*(unsigned char *)(v4 + 41))
    {
      *(unsigned char *)(v4 + 41) = 0;
      if (*(void *)(v4 + 48)) {
        tcp_connection_fallback_watcher_destroy();
      }
      *(void *)(v4 + 48) = 0;
    }
    [+[BluetoothController sharedInstance] stopWatchingForDevices];
    *(unsigned char *)(a1 + 128) = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    void v6[2] = sub_101028394;
    v6[3] = &unk_1019A1BF8;
    v6[4] = a1;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    sub_10003E168(&v9, (void *)(a1 + 8));
    long long v5 = *(NSObject **)(a1 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768;
    void block[2] = sub_10102AB14;
    block[3] = &unk_101A7F8D8;
    block[5] = v9;
    uint64_t v8 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v6;
    dispatch_async(v5, block);
    if (v8) {
      sub_10004D2C8(v8);
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

void sub_101028530(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if (*(unsigned char *)(v3 + 24))
  {
    uint64_t v4 = *(void *)(v3 + 8);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    long long v5 = *(void **)(v4 + 72);
    if (v5)
    {
      id v6 = [v5 currentLayout];
      if (v6)
      {
        id v7 = [v6 elements];
        uint64_t v8 = v7;
        if (v7)
        {
          long long v25 = 0u;
          long long v26 = 0u;
          long long v23 = 0u;
          long long v24 = 0u;
          id v9 = [v7 countByEnumeratingWithState:&v23 objects:v31 count:16];
          if (v9)
          {
            uint64_t v10 = *(void *)v24;
            do
            {
              for (int i = 0; i != v9; int i = (char *)i + 1)
              {
                if (*(void *)v24 != v10) {
                  objc_enumerationMutation(v8);
                }
                CFNumberRef v12 = *(void **)(*((void *)&v23 + 1) + 8 * i);
                if ([v12 bundleIdentifier])
                {
                  __p[0] = 0;
                  __p[1] = 0;
                  uint64_t v22 = 0;
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  *(_OWORD *)std::string __p = *(_OWORD *)buf;
                  uint64_t v22 = *(void *)&buf[16];
                  char v13 = *(NSObject **)(v4 + 40);
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                  {
                    if (v22 >= 0) {
                      int v14 = __p;
                    }
                    else {
                      int v14 = (void **)__p[0];
                    }
                    unsigned int v15 = [v12 isUIApplicationElement];
                    unsigned int v16 = [v12 hasKeyboardFocus];
                    *(_DWORD *)long long buf = 136315906;
                    *(void *)&uint8_t buf[4] = "displayApps";
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = v14;
                    *(_WORD *)&unsigned char buf[22] = 1024;
                    unsigned int v28 = v15;
                    __int16 v29 = 1024;
                    unsigned int v30 = v16;
                    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: app %s (UIApplicationElement %d hasKeyboardFocus %d)", buf, 0x22u);
                  }
                  if ([v12 isUIApplicationElement])
                  {
                    unint64_t v17 = a2[1];
                    if (v17 >= a2[2])
                    {
                      uint64_t v19 = sub_100048008(a2, (long long *)__p);
                    }
                    else
                    {
                      if (SHIBYTE(v22) < 0)
                      {
                        sub_10004FC84((unsigned char *)a2[1], __p[0], (unint64_t)__p[1]);
                      }
                      else
                      {
                        long long v18 = *(_OWORD *)__p;
                        *(void *)(v17 + 16) = v22;
                        *(_OWORD *)unint64_t v17 = v18;
                      }
                      uint64_t v19 = v17 + 24;
                      a2[1] = v17 + 24;
                    }
                    a2[1] = v19;
                  }
                  if (SHIBYTE(v22) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
              id v9 = [v8 countByEnumeratingWithState:&v23 objects:v31 count:16];
            }
            while (v9);
          }
        }
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_1010287B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101028828(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 104);
  pthread_mutex_lock(&stru_101B0B8C8);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 40);
  pthread_mutex_unlock(&stru_101B0B8C8);
  return v2;
}

BOOL sub_101028868(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 132);
  if (v1 < 0)
  {
    Boolean keyExistsAndHasValidFormat = 0;
    int AppBooleanValue = CFPreferencesGetAppBooleanValue(@"ShowRATIndicator", kCarrier1BundleId, &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat) {
      BOOL v4 = AppBooleanValue == 0;
    }
    else {
      BOOL v4 = 0;
    }
    int v1 = v4;
    *(_DWORD *)(a1 + 132) = v1;
  }
  return v1 != 0;
}

BOOL sub_1010288D4()
{
  BOOL v1 = [+[BluetoothController sharedInstance] tetheringConnected];
  return v1;
}

uint64_t sub_101028918(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (*(unsigned char *)(v2 + 24)) {
    return sub_1000554DC(*(void *)(v2 + 8), a2, 0);
  }
  else {
    return 0;
  }
}

uint64_t sub_101028938()
{
  return byte_101B13088;
}

uint64_t sub_101028944(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 96) + 8);
  pthread_mutex_lock(&stru_101B0B888);
  uint64_t v2 = *(unsigned int *)(v1 + 64);
  pthread_mutex_unlock(&stru_101B0B888);
  return v2;
}

uint64_t sub_101028988(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 96) + 8);
  pthread_mutex_lock(&stru_101B0B888);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 68);
  pthread_mutex_unlock(&stru_101B0B888);
  return v2;
}

uint64_t sub_1010289CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x2020000000;
  int v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_10102A890;
  v5[3] = &unk_1019A1080;
  void v5[4] = &v6;
  v5[5] = v1;
  uint64_t v10 = v5;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  void block[2] = sub_10102A8A4;
  block[3] = &unk_10199E470;
  block[4] = v1 + 8;
  block[5] = &v10;
  uint64_t v2 = *(NSObject **)(v1 + 24);
  if (*(void *)(v1 + 32)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t sub_101028ACC(uint64_t a1, uint64_t *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)(*(void *)(a1 + 96) + 8), *(Registry **)(*(void *)(*(void *)(a1 + 96) + 8) + 48));
  BOOL v4 = ServiceMap;
  long long v5 = "23ApplicationStateMonitor";
  if (((unint64_t)"23ApplicationStateMonitor" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"23ApplicationStateMonitor" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      long long v5 = (const char *)v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  int v14 = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v14);
  if (v9)
  {
    uint64_t v10 = v9[3];
    uint64_t v11 = (std::__shared_weak_count *)v9[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v12 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v11 = 0;
  char v12 = 1;
  if (!v10)
  {
LABEL_7:
    if (v12) {
      return (v10 != 0) & a2;
    }
    goto LABEL_12;
  }
LABEL_11:
  LOBYTE(a2) = sub_100D72BF4(v10, a2);
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v11);
  return (v10 != 0) & a2;
}

void sub_101028BD4(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101028BF0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  BOOL v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  block = (void **)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&block);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    uint64_t v13 = 8;
    if (v12) {
      return v13;
    }
    goto LABEL_15;
  }
LABEL_11:
  int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 776))(v11);
  uint64_t v17 = a1;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10102AB50;
  v18[3] = &unk_1019A11A8;
  v18[4] = a1 + 8;
  v18[5] = &v16;
  uint64_t v19 = v18;
  int v14 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned int v26 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472;
    uint64_t v22 = sub_10102ABDC;
    long long v23 = &unk_10199E470;
    long long v24 = &v26;
    long long v25 = &v19;
    dispatch_async_and_wait(v14, &block);
  }
  else
  {
    unsigned int v26 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472;
    uint64_t v22 = sub_10102ABA0;
    long long v23 = &unk_10199E470;
    long long v24 = &v26;
    long long v25 = &v19;
    dispatch_sync(v14, &block);
  }
  uint64_t v13 = v26;
  if ((v12 & 1) == 0) {
LABEL_15:
  }
    sub_10004D2C8(v10);
  return v13;
}

void sub_101028E20(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101028E3C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    uint64_t v12 = 0;
    if (v11) {
      return v12;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 64))(v10);
  if ((v11 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v9);
  return v12;
}

void sub_101028F54(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101028F70(capabilities::ct *a1)
{
  return capabilities::ct::supportsVoiceCall(a1) ^ 1;
}

uint64_t sub_101028F8C()
{
  return _MGGetBoolAnswer(@"wi-fi");
}

uint64_t sub_101028F98()
{
  return _MGGetBoolAnswer(@"wapi");
}

uint64_t sub_101028FA4(uint64_t a1, char a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  pthread_mutex_lock(&stru_101B0B908);
  *(unsigned char *)(v3 + 8) = a2;

  return pthread_mutex_unlock(&stru_101B0B908);
}

uint64_t sub_101028FF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  pthread_mutex_lock(&stru_101B0B908);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 8);
  pthread_mutex_unlock(&stru_101B0B908);
  return v2;
}

void sub_101029038(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101029940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
}

void sub_101029C2C()
{
  __cxa_end_catch();
  uint64_t v1 = (std::__shared_weak_count *)v0[9];
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_100B0D31C(v0);
  operator delete();
}

void sub_101029C3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  operator delete();
}

void sub_101029CBC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x101029C94);
}

void sub_101029CEC()
{
}

void sub_101029CF4()
{
}

void *sub_101029D00(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_101029D84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v1 + 72);
  if (v3)
  {
    [v3 invalidate];

    *(void *)(v1 + 72) = 0;
  }
}

void sub_101029DDC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101029E14(uint64_t a1)
{
}

uint64_t sub_101029E30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101029E74(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_101029EA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101029EDC(uint64_t a1)
{
}

uint64_t sub_101029EF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101029F3C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_101029F68(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  Registry::createRestModuleOneTimeUseConnection(&v6, *(Registry **)(v1 + 48));
  ctu::RestModule::connect();
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v2 = (uint64_t (***)())(v1 + 96);
  uint64_t v9 = off_101A7F6D8;
  uint64_t v10 = v1 + 80;
  uint64_t v11 = &v9;
  if (&v9 != (uint64_t (***)())(v1 + 96))
  {
    uint64_t v3 = *(uint64_t (****)())(v1 + 120);
    if (v3 == v2)
    {
      v8[1] = v1 + 80;
      v8[2] = 0;
      v8[0] = off_101A7F6D8;
      uint64_t v11 = 0;
      ((void (*)(uint64_t, uint64_t (***)()))(*v2)[3])(v1 + 96, &v9);
      (*(void (**)(void))(**(void **)(v1 + 120) + 32))(*(void *)(v1 + 120));
      *(void *)(v1 + 120) = 0;
      uint64_t v11 = &v9;
      (*(void (**)(void *, uint64_t))(v8[0] + 24))(v8, v1 + 96);
      (*(void (**)(void *))(v8[0] + 32))(v8);
    }
    else
    {
      *(void *)(v1 + 96) = off_101A7F6D8;
      *(void *)(v1 + 104) = v1 + 80;
      uint64_t v11 = v3;
    }
    *(void *)(v1 + 120) = v2;
  }
  sub_101029D00(&v9);
  uint64_t v4 = *(void *)(v1 + 120);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v1 + 128);
  }
  uint64_t v9 = off_101A7F768;
  uint64_t v10 = v1 + 80;
  uint64_t v11 = &v9;
  sub_1009C3620(&v9, (void *)(v1 + 200));
  sub_10016D140(&v9);
  uint64_t result = *(void *)(v1 + 224);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v1 + 232);
  }
  return result;
}

void sub_10102A1D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102A20C()
{
}

void *sub_10102A220(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A7F6D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10102A268(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A7F6D8;
  a2[1] = v2;
  return result;
}

uint64_t sub_10102A294(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10102A2D4()
{
}

void sub_10102A2E4()
{
}

void *sub_10102A2F8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A7F768;
  result[1] = v3;
  return result;
}

uint64_t sub_10102A340(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A7F768;
  a2[1] = v2;
  return result;
}

uint64_t sub_10102A36C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10102A3AC()
{
}

void sub_10102A3BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10102A3F4(uint64_t a1)
{
}

uint64_t sub_10102A410(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_10102A454(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(result + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_10102A4AC(uint64_t a1, int token)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = byte_101B13088;
  uint64_t v9 = 0;
  notify_get_state(token, &v9);
  uint64_t v5 = v9;
  byte_101B13088 = v9 != 0;
  if (v4 != (v9 != 0)) {
    ++*(_DWORD *)(v3 + 52);
  }
  uint64_t v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asStringBool(v5 != 0);
    uint64_t v8 = *(unsigned int *)(v3 + 52);
    LODWORD(v9) = 67109634;
    HIDWORD(v9) = token;
    __int16 v10 = 2080;
    uint64_t v11 = v7;
    __int16 v12 = 2048;
    uint64_t v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ScreenLockObserver: token=%d, state = %s, sequence = %lu", (uint8_t *)&v9, 0x1Cu);
  }
}

void sub_10102A5C0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v1 + 72);
  if (v3)
  {
    [v3 invalidate];

    *(void *)(v1 + 72) = 0;
  }
  int v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v4 || (uint64_t v5 = *(void *)(v1 + 8), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  p_unint64_t shared_weak_owners = &v6->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3321888768;
  v9[2] = sub_100029D50;
  v9[3] = &unk_101A7F838;
  void v9[4] = v5;
  __int16 v10 = v7;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  *(void *)(v1 + 72) = [objc_alloc((Class)FBSDisplayLayoutMonitor) initWithDisplayType:0 qualityOfService:21 handler:v9];
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  std::__shared_weak_count::__release_weak(v7);
}

void sub_10102A6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  std::__shared_weak_count::__release_weak(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_10102A6EC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10102A708(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10102A718(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5] && *(unsigned char *)(v3 + 41))
      {
        int v6 = tcp_fallback_watcher_fallback_inuse();
        uint64_t v7 = *(NSObject **)(v3 + 32);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8[0] = 67109120;
          v8[1] = v6;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I cellular fallback is %d", (uint8_t *)v8, 8u);
        }
        pthread_mutex_lock(&stru_101B0B8C8);
        *(unsigned char *)(v3 + 40) = v6;
        pthread_mutex_unlock(&stru_101B0B8C8);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10102A814(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10102A828(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10102A844(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_10102A854(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10102A864(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10102A880(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_10102A890(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 52);
  return result;
}

void *sub_10102A8A4(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void sub_10102A8B8(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v12 = a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(**(void **)a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)__p);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10) {
    goto LABEL_13;
  }
LABEL_10:
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v10 + 152))(&v13, v10);
  xpc_object_t v19 = 0;
  sub_1000DE980((uint64_t)&v13, &v19);
  sub_100058DB0(__p, "/cc/props/user_visible_apps_changed");
  xpc_object_t object = v19;
  xpc_object_t v19 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  xpc_object_t object = 0;
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v19);
  sub_10005CD2C((uint64_t)&v13, v14);
LABEL_13:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  operator delete();
}

void sub_10102AA7C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, char *a15, uint64_t a16, xpc_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24)
{
  xpc_release(object);
  xpc_object_t object = 0;
  if (a23 < 0) {
    operator delete(__p);
  }
  xpc_release(a24);
  sub_10005CD2C((uint64_t)&a12, a15);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  operator delete();
}

uint64_t sub_10102AB14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10102AB24(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10102AB40(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_10102AB50(uint64_t a1)
{
  uint64_t v1 = *(int **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 1);
  uint64_t v3 = *(_DWORD **)(v2 + 136);
  uint64_t v4 = *(_DWORD **)(v2 + 144);
  if (v3 != v4)
  {
    int v5 = *v1;
    do
    {
      if (*v3 == v5) {
        break;
      }
      v3 += 42;
    }
    while (v3 != v4);
  }
  return subscriber::toSimStatus();
}

uint64_t sub_10102ABA0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10102ABDC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_10102AC1C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10102AC54(uint64_t a1)
{
}

uint64_t sub_10102AC70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10102ACB4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 200))();
  }
  return result;
}

void sub_10102ACE0(ServiceManager::Service *this)
{
  *(void *)this = off_101A7F978;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10102AD3C(ServiceManager::Service *this)
{
  *(void *)this = off_101A7F978;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10102ADAC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CSIAppInfo");
}

unsigned char *sub_10102ADBC@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10102ADF8(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  sub_100B0D3D8(v2, &group);
}

void sub_10102AE60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10102AE84()
{
  return 0;
}

uint64_t sub_10102AE8C()
{
  return 1;
}

uint64_t sub_10102AE94()
{
  return 0;
}

void sub_10102AEA0(uint64_t a1)
{
}

void sub_10102AEA8(uint64_t a1, int a2, ServiceStage *a3)
{
}

const char *sub_10102AEB0(int a1)
{
  if ((a1 - 1) > 2) {
    return "lazuli.cap.ctr.?";
  }
  else {
    return off_101A7FE68[a1 - 1];
  }
}

uint64_t sub_10102AED8(uint64_t a1)
{
  *(void *)a1 = off_101A7F9F8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 240);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 216);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10005CD2C(a1 + 184, *(char **)(a1 + 192));
  sub_1001F7124(a1 + 160, *(void **)(a1 + 168));
  sub_1000346F8(a1 + 136, *(void **)(a1 + 144));
  sub_10005CD2C(a1 + 112, *(char **)(a1 + 120));
  uint64_t v9 = (void **)(a1 + 88);
  sub_10005CBF0(&v9);
  int v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 64);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  LazuliLifetimeInterface::~LazuliLifetimeInterface((LazuliLifetimeInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10102B010(uint64_t a1)
{
  sub_10102AED8(a1);

  operator delete();
}

void sub_10102B048(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Powering on", buf, 2u);
  }
  if ((ctu::RestModule::isConnected((ctu::RestModule *)(a1 + 72)) & 1) == 0)
  {
    Registry::createRestModuleOneTimeUseConnection(&v4, *(Registry **)(a1 + 56));
    ctu::RestModule::connect();
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  sub_100058DB0(__p, "/cc/props/lazuli_client_state");
  *(void *)long long buf = off_101A7FC58;
  uint64_t v9 = a1 + 112;
  uint64_t v10 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_capabilities_information");
  uint64_t v3 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v3 = off_101A7FCD8;
  *((void *)v3 + 1) = a1 + 136;
  *((void *)v3 + 2) = a1;
  *((void *)v3 + 3) = sub_10102B2A4;
  *((void *)v3 + 4) = 0;
  uint64_t v10 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/lazuli_registration_state");
  *(void *)long long buf = off_101A7FD58;
  uint64_t v9 = a1 + 184;
  uint64_t v10 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  sub_1001F3CD8(a1 + 160);
}

void sub_10102B254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102B2A4(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 152))
  {
    uint64_t v4 = a2 + 1;
    int v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v6 = *(void **)(a1 + 136);
    char v7 = v6;
    while (*((_DWORD *)v5 + 8) == *((_DWORD *)v7 + 8) && sub_1007AD264((uint64_t)(v5 + 5), (uint64_t)(v7 + 5)))
    {
      uint64_t v8 = (void *)v5[1];
      uint64_t v9 = v5;
      if (v8)
      {
        do
        {
          int v5 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v5 = (void *)v9[2];
          BOOL v10 = *v5 == (void)v9;
          uint64_t v9 = v5;
        }
        while (!v10);
      }
      char v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          char v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          char v7 = v12;
        }
        while (!v10);
      }
      char v7 = v12;
      if (v5 == v4) {
        return;
      }
    }
  }
  else
  {
    uint64_t v6 = *(void **)(a1 + 136);
  }
  if (v6 != (void *)(a1 + 144))
  {
    uint64_t v13 = a2 + 1;
    do
    {
      uint64_t v14 = *v13;
      uint64_t v15 = *((unsigned int *)v6 + 8);
      if (!*v13) {
        goto LABEL_32;
      }
      int v16 = a2 + 1;
      do
      {
        int v17 = *(_DWORD *)(v14 + 32);
        BOOL v18 = v17 < (int)v15;
        if (v17 >= (int)v15) {
          xpc_object_t v19 = (uint64_t *)v14;
        }
        else {
          xpc_object_t v19 = (uint64_t *)(v14 + 8);
        }
        if (!v18) {
          int v16 = (uint64_t *)v14;
        }
        uint64_t v14 = *v19;
      }
      while (*v19);
      if (v16 == v13 || (int)v15 < *((_DWORD *)v16 + 8) || !sub_1007AD264((uint64_t)(v16 + 5), (uint64_t)(v6 + 5)))
      {
LABEL_32:
        __int16 v20 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v15);
        uint64_t v21 = v20;
        uint64_t v22 = *(void *)(a1 + 168);
        if (!v22) {
          goto LABEL_42;
        }
        int v23 = *((_DWORD *)v6 + 8);
        uint64_t v24 = a1 + 168;
        do
        {
          int v25 = *(_DWORD *)(v22 + 32);
          BOOL v26 = v25 < v23;
          if (v25 >= v23) {
            int v27 = (uint64_t *)v22;
          }
          else {
            int v27 = (uint64_t *)(v22 + 8);
          }
          if (!v26) {
            uint64_t v24 = v22;
          }
          uint64_t v22 = *v27;
        }
        while (*v27);
        if (v24 != a1 + 168 && v23 >= *(_DWORD *)(v24 + 32))
        {
          uint64_t v43 = 0;
          uint64_t v44 = 0;
          long long v31 = *(std::__shared_weak_count **)(a1 + 64);
          uint64_t v41 = *(void *)(a1 + 56);
          uint64_t v42 = v31;
          if (v31) {
            atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_100058DB0(__p, "Capabilities");
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          int v45 = v23;
          sub_100B8C1D0(&v45, &v41, v24 + 40, (uint64_t)__p, (uint64_t *)buf, &v43);
          if (SBYTE7(v39) < 0) {
            operator delete(__p[0]);
          }
          if (v42) {
            sub_10004D2C8(v42);
          }
          uint64_t v40 = 0;
          *(_OWORD *)std::string __p = 0u;
          long long v39 = 0u;
          sub_10102B974((uint64_t)__p, a1, *((unsigned int *)v6 + 8));
          if (LOBYTE(__p[1]))
          {
            uint64_t v32 = *v21;
            if (os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = "kForLazuliCapable";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void **)&buf[14] = __p[0];
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Refreshing cache for [%s] timeout: %zu", buf, 0x16u);
            }
            uint64_t v36 = v43;
            uint64_t v37 = v44;
            if (v44) {
              atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (!LOBYTE(__p[1])) {
              sub_10016C840();
            }
            *(_DWORD *)long long buf = 0;
            sub_100178684(v21, &v36, (uint64_t *)__p, buf);
            if (v37) {
              sub_10004D2C8(v37);
            }
          }
          if (BYTE8(v39))
          {
            uint64_t v33 = *v21;
            if (os_log_type_enabled(*v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = "kForLazuliNotCapable";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v39;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Refreshing cache for [%s] timeout: %zu", buf, 0x16u);
            }
            uint64_t v34 = v43;
            uint64_t v35 = v44;
            if (v44) {
              atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (!BYTE8(v39)) {
              sub_10016C840();
            }
            *(_DWORD *)long long buf = 1;
            sub_100178684(v21, &v34, (uint64_t *)&v39, buf);
            if (v35) {
              sub_10004D2C8(v35);
            }
          }
          if (v44) {
            sub_10004D2C8(v44);
          }
        }
        else
        {
LABEL_42:
          unsigned int v28 = *v20;
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Missing provisioning initializer", (uint8_t *)__p, 2u);
          }
        }
      }
      __int16 v29 = (void *)v6[1];
      if (v29)
      {
        do
        {
          unsigned int v30 = v29;
          __int16 v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          unsigned int v30 = (void *)v6[2];
          BOOL v10 = *v30 == (void)v6;
          uint64_t v6 = v30;
        }
        while (!v10);
      }
      uint64_t v6 = v30;
    }
    while (v30 != (void *)(a1 + 144));
  }
}

void sub_10102B72C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102B7A4(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Tearing down", v2, 2u);
  }
}

uint64_t sub_10102B82C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Tear down complete", v4, 2u);
  }
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 72));
}

void sub_10102B898(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dump: Capabilities search info", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ======", v5, 2u);
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I ======", v4, 2u);
  }
}

void sub_10102B974(uint64_t a1, uint64_t a2, uint64_t a3)
{
  DefaultLazuliDiscoverCapabilitiesInformation = GetDefaultLazuliDiscoverCapabilitiesInformation();
  long long v7 = DefaultLazuliDiscoverCapabilitiesInformation[1];
  long long v18 = *DefaultLazuliDiscoverCapabilitiesInformation;
  long long v19 = v7;
  uint64_t v20 = *((void *)DefaultLazuliDiscoverCapabilitiesInformation + 4);
  uint64_t v8 = *(void *)(a2 + 144);
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v9 = a2 + 144;
  do
  {
    int v10 = *(_DWORD *)(v8 + 32);
    BOOL v11 = v10 < (int)a3;
    if (v10 >= (int)a3) {
      uint64_t v12 = (uint64_t *)v8;
    }
    else {
      uint64_t v12 = (uint64_t *)(v8 + 8);
    }
    if (!v11) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = *v12;
  }
  while (*v12);
  if (v9 != a2 + 144 && *(_DWORD *)(v9 + 32) <= (int)a3)
  {
    long long v16 = *(_OWORD *)(v9 + 56);
    *(_OWORD *)a1 = *(_OWORD *)(v9 + 40);
    *(_OWORD *)(a1 + 16) = v16;
    uint64_t v15 = *(void *)(v9 + 72);
  }
  else
  {
LABEL_11:
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v17[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No discovery information found", (uint8_t *)v17, 2u);
    }
    long long v14 = v19;
    *(_OWORD *)a1 = v18;
    *(_OWORD *)(a1 + 16) = v14;
    uint64_t v15 = v20;
  }
  *(void *)(a1 + 32) = v15;
}

void sub_10102BA8C(unsigned char *a1, uint64_t a2, uint64_t a3, long long *a4)
{
  long long __dst = 0uLL;
  uint64_t v33 = 0;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long __dst = *a4;
    uint64_t v33 = *((void *)a4 + 2);
  }
  uint64_t v30 = 0;
  long long v31 = 0;
  if (SHIBYTE(v33) < 0)
  {
    sub_10004FC84(v19, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)long long v19 = __dst;
    uint64_t v20 = v33;
  }
  char v25 = 0;
  char v26 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  std::string __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v21 = 0;
  char v24 = 0;
  sub_10102BE08(&v30, a2, a3, (uint64_t)v19);
  if (SHIBYTE(v29) < 0) {
    operator delete(__p);
  }
  if (v26)
  {
    v8[0] = &v25;
    sub_100047F64((void ***)v8);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v21);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
  uint64_t v7 = v30;
  if (v30)
  {
    if (SHIBYTE(v33) < 0)
    {
      sub_10004FC84(v8, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v8 = __dst;
      uint64_t v9 = v33;
    }
    char v14 = 0;
    char v15 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    long long v16 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    int v10 = 0;
    char v13 = 0;
    sub_10016F5BC(v7, (uint64_t)v8);
  }
  *a1 = 0;
  a1[112] = 0;
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_10102BDA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  operator delete(v25);
  uint64_t v28 = *(std::__shared_weak_count **)(v26 - 104);
  if (v28) {
    sub_10004D2C8(v28);
  }
  if (*(char *)(v26 - 73) < 0) {
    operator delete(*(void **)(v26 - 96));
  }
  _Unwind_Resume(a1);
}

void sub_10102BE08(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  sub_10102C10C(&v27, a2, a3);
  uint64_t v8 = v27;
  if (!v27)
  {
    char v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_WORD *)long long buf = 0;
    char v15 = "Failed to instantiate chat services";
    long long v16 = buf;
    goto LABEL_26;
  }
  uint64_t v26 = 0;
  *(_OWORD *)long long buf = 0u;
  long long v25 = 0u;
  sub_10102B974((uint64_t)buf, a2, a3);
  uint64_t v9 = *(void *)(a2 + 168);
  if (v9)
  {
    uint64_t v10 = a2 + 168;
    do
    {
      int v11 = *(_DWORD *)(v9 + 32);
      BOOL v12 = v11 < (int)a3;
      if (v11 >= (int)a3) {
        char v13 = (uint64_t *)v9;
      }
      else {
        char v13 = (uint64_t *)(v9 + 8);
      }
      if (!v12) {
        uint64_t v10 = v9;
      }
      uint64_t v9 = *v13;
    }
    while (*v13);
    if (v10 != a2 + 168 && *(_DWORD *)(v10 + 32) <= (int)a3)
    {
      uint64_t v17 = *(std::__shared_weak_count **)(a2 + 16);
      if (v17)
      {
        uint64_t v23 = *(void *)(a2 + 8);
        uint64_t v18 = std::__shared_weak_count::lock(v17);
        if (v18)
        {
          long long v19 = v18;
          atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          uint64_t v20 = *(void *)(a2 + 56);
          uint64_t v21 = *(void *)(a2 + 64);
          uint64_t v22 = operator new(0x148uLL);
          v22[1] = 0;
          v22[2] = 0;
          *uint64_t v22 = off_101A7FDD8;
          v33[0] = v20;
          v33[1] = v21;
          if (v21) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v31 = v23;
          uint64_t v32 = v19;
          uint64_t v29 = v8;
          uint64_t v30 = v28;
          if (v28) {
            atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10016EFEC((uint64_t)(v22 + 3), a3, v33, (NSObject **)(a2 + 24), a4);
        }
      }
      sub_100088B9C();
    }
  }
  char v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v33[0]) = 0;
    char v15 = "Missing provisioning initializer";
    long long v16 = (uint8_t *)v33;
LABEL_26:
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v15, v16, 2u);
  }
LABEL_15:
  *a1 = 0;
  a1[1] = 0;
  if (v28) {
    sub_10004D2C8(v28);
  }
}

void sub_10102C0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (v20) {
    sub_10004D2C8(v20);
  }
  std::__shared_weak_count::__release_weak(v19);
  uint64_t v23 = *(std::__shared_weak_count **)(v21 - 88);
  if (v23) {
    sub_10004D2C8(v23);
  }
  std::__shared_weak_count::~__shared_weak_count(v18);
  operator delete(v24);
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

void sub_10102C10C(void *a1, uint64_t a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v35 = 0;
  uint64_t v6 = (Registry **)(a2 + 56);
  PersonalityIdFromSlotId();
  uint64_t v7 = sub_100046F68(a2 + 112, __p);
  if ((void **)(a2 + 120) == v7)
  {
    long long v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
LABEL_15:
      *a1 = 0;
      a1[1] = 0;
      goto LABEL_42;
    }
    uint64_t v20 = subscriber::asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    uint64_t v21 = "IMS client not present for: %s";
LABEL_46:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v21, buf, 0xCu);
    goto LABEL_15;
  }
  if (!*((unsigned char *)v7 + 56))
  {
    long long v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    uint64_t v27 = subscriber::asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v27;
    uint64_t v21 = "IMS client not ready for: %s";
    goto LABEL_46;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*((unsigned __int8 *)v7 + 56), *v6);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  char v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_17:
    std::mutex::unlock(v9);
    char v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_9;
    }
LABEL_18:
    *(_OWORD *)long long buf = 0uLL;
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v16 + 32))(buf, v16, __p);
    uint64_t v22 = *(void *)buf;
    if (*(void *)buf)
    {
      *(void *)uint64_t v32 = 0;
      uint64_t v33 = 0;
      uint64_t v23 = *(std::__shared_weak_count **)(a2 + 64);
      uint64_t v30 = *(void *)(a2 + 56);
      uint64_t v31 = v23;
      if (v23) {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v28 = v22;
      uint64_t v29 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      *(_DWORD *)uint64_t v36 = a3;
      *(void *)uint64_t v32 = 0;
      uint64_t v33 = 0;
      sub_101074A08((unsigned int *)v36, &v30, (NSObject **)(a2 + 24), &v28, v32);
      if (v29) {
        sub_10004D2C8(v29);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
      if (*(void *)v32)
      {
        char v24 = v33;
        *a1 = *(void *)v32;
        a1[1] = v24;
        if (v24) {
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v36 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to get Sip stack reference", v36, 2u);
        }
        *a1 = 0;
        a1[1] = 0;
      }
      if (v33) {
        sub_10004D2C8(v33);
      }
    }
    else
    {
      long long v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v32 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to get Lazuli client", v32, 2u);
      }
      *a1 = 0;
      a1[1] = 0;
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    goto LABEL_40;
  }
  uint64_t v16 = v14[3];
  char v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (v16) {
    goto LABEL_18;
  }
LABEL_9:
  uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to get SD interface while discovering capabilities", buf, 2u);
  }
  *a1 = 0;
  a1[1] = 0;
LABEL_40:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
LABEL_42:
  if (SHIBYTE(v35) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10102C5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a25) {
    sub_10004D2C8(a25);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102C64C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6 = (NSObject **)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 56);
  uint64_t v7 = *(void *)(a2 + 64);
  uint64_t v9 = operator new(0x148uLL);
  v9[1] = 0;
  v9[2] = 0;
  *uint64_t v9 = off_101A7FDD8;
  v10[0] = v8;
  v10[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10016FF30((uint64_t)(v9 + 3), a3, v10, v6, a4);
}

void sub_10102C778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v12);
  _Unwind_Resume(a1);
}

void sub_10102C79C(uint64_t a1, int a2, uint64_t a3)
{
  memset(v5, 0, sizeof(v5));
  uint64_t v3 = *(void *)(a1 + 64);
  v4[0] = *(void *)(a1 + 56);
  v4[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10016FF30((uint64_t)v5, a2, v4, (NSObject **)(a1 + 24), a3);
}

void sub_10102CB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

void sub_10102CB90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,std::__shared_weak_count *a48)
{
  if (a48) {
    sub_10004D2C8(a48);
  }
  JUMPOUT(0x10102CB88);
}

uint64_t sub_10102CBA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v7 = a3;
    }
    else {
      uint64_t v7 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 141558275;
    uint64_t v19 = 1752392040;
    __int16 v20 = 2081;
    uint64_t v21 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I === discover-capabilities for: [%{private, mask.hash}s] ===", buf, 0x16u);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  PersonalityIdFromSlotId();
  uint64_t v8 = sub_100046F68(a1 + 184, __p);
  if ((void **)(a1 + 192) == v8)
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v10 = a3;
    }
    else {
      uint64_t v10 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 141558275;
    uint64_t v19 = 1752392040;
    __int16 v20 = 2081;
    uint64_t v21 = v10;
    int v11 = "#I IMS not available while searching for: [%{private, mask.hash}s]";
    goto LABEL_19;
  }
  if (*((_DWORD *)v8 + 14) == 1)
  {
    *(void *)uint64_t v16 = 0;
    uint64_t v17 = 0;
    sub_10102C64C((uint64_t)v16, a1, a2, a3);
  }
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v12 = a3;
    }
    else {
      uint64_t v12 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 141558275;
    uint64_t v19 = 1752392040;
    __int16 v20 = 2081;
    uint64_t v21 = v12;
    int v11 = "#I IMS not registered while searching for: [%{private, mask.hash}s]";
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v11, buf, 0x16u);
  }
LABEL_20:
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_10102D380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *aBlock, dispatch_object_t object, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a32) {
    sub_10004D2C8(a32);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10102D488(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 56));
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = (uint64_t)(*(void *)(v2 + 96) - *(void *)(v2 + 88)) >> 4;
          int v9 = 134217984;
          uint64_t v10 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Discovery timer expired. Clearing a total of [%zu] models", (uint8_t *)&v9, 0xCu);
        }
        sub_10019E028((uint64_t *)(v2 + 88));
      }
      sub_10004D2C8(v5);
    }
  }
  uint64_t result = *(void *)(v2 + 224);
  *(void *)(v2 + 224) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_10102D5C4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10102D5D8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10102D5F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

unint64_t sub_10102D604(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  if (*a4 == -1) {
    goto LABEL_38;
  }
  uint64_t v37 = 0;
  memset(v36, 0, sizeof(v36));
  sub_10102B974((uint64_t)v36, a1, a2);
  int v10 = v37;
  int v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (v10)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = Lazuli::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Discovery via options not supported: %s", buf, 0xCu);
    }
    uint64_t v12 = &_mh_execute_header;
    uint64_t v13 = 7;
    return v13 | (unint64_t)v12 & (unint64_t)&_mh_execute_header;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = *(void *)a3;
    }
    uint64_t v15 = Lazuli::asString();
    *(_DWORD *)long long buf = 141558531;
    *(void *)&uint8_t buf[4] = 1752392040;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v14;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v39 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Fetch remote capabilities for: [%{private, mask.hash}s] : %s", buf, 0x20u);
  }
  int v16 = *a4;
  if ((*a4 | 2) == 2)
  {
    uint64_t v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    memset(v44, 0, sizeof(v44));
    sub_10102E428(a1, a2, a3, v44);
    if ((_BYTE)v56)
    {
      uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Capabilities found in cache", buf, 2u);
      }
      uint64_t v18 = *(unsigned __int8 *)(a5 + 23);
      char v19 = v18;
      if ((v18 & 0x80u) != 0) {
        uint64_t v18 = *(void *)(a5 + 8);
      }
      if (v18)
      {
        *(_DWORD *)long long buf = a2;
        uint8_t buf[8] = 0;
        char v41 = 0;
        if ((_BYTE)v56)
        {
          sub_1001793CC((uint64_t)&buf[8], (uint64_t)v44);
          char v41 = 1;
          char v19 = *(unsigned char *)(a5 + 23);
        }
        if (v19 < 0)
        {
          sub_10004FC84(v42, *(void **)a5, *(void *)(a5 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v42 = *(_OWORD *)a5;
          v42[2] = *(void **)(a5 + 16);
        }
        sub_1001789C8((char *)v43, (long long *)a3);
        v43[14] = (void *)a1;
        uint64_t v29 = *(std::__shared_weak_count **)(a1 + 16);
        if (v29 && std::__shared_weak_count::lock(v29)) {
          operator new();
        }
        sub_100088B9C();
      }
      sub_1001794B8((uint64_t)v44);
      goto LABEL_49;
    }
    sub_1001794B8((uint64_t)v44);
    int v16 = *a4;
  }
  if ((v16 - 1) >= 2)
  {
    if (!v16)
    {
      uint64_t v21 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a3 + 23) >= 0) {
          uint64_t v22 = a3;
        }
        else {
          uint64_t v22 = *(void *)a3;
        }
        *(_DWORD *)long long buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&unsigned char buf[12] = 2081;
        *(void *)&buf[14] = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Nothing found in cache for destination: [%{private, mask.hash}s]", buf, 0x16u);
      }
      if (*(char *)(a5 + 23) < 0)
      {
        unint64_t v32 = *(void *)(a5 + 8);
        if (v32)
        {
          *(_DWORD *)long long buf = a2;
          sub_10004FC84(&buf[8], *(void **)a5, v32);
          goto LABEL_61;
        }
      }
      else if (*(unsigned char *)(a5 + 23))
      {
        *(_DWORD *)long long buf = a2;
        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)a5;
        uint64_t v39 = *(void *)(a5 + 16);
LABEL_61:
        sub_1001789C8((char *)v40, (long long *)a3);
        v40[14] = (void *)a1;
        uint64_t v33 = *(std::__shared_weak_count **)(a1 + 16);
        if (v33 && std::__shared_weak_count::lock(v33)) {
          operator new();
        }
        sub_100088B9C();
      }
LABEL_49:
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      return v13 | (unint64_t)v12 & (unint64_t)&_mh_execute_header;
    }
    uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = Lazuli::asString();
      *(_DWORD *)long long buf = 141558275;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&unsigned char buf[12] = 2081;
      *(void *)&buf[14] = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Unhandled type for discovery: [%{private, mask.hash}s]", buf, 0x16u);
    }
LABEL_38:
    uint64_t v12 = &_mh_execute_header;
    uint64_t v13 = 4;
    return v13 | (unint64_t)v12 & (unint64_t)&_mh_execute_header;
  }
  memset(buf, 0, sizeof(buf));
  PersonalityIdFromSlotId();
  __int16 v20 = sub_100046F68(a1 + 184, (void **)buf);
  if ((void **)(a1 + 192) == v20)
  {
    long long v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_56;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v26 = a3;
    }
    else {
      uint64_t v26 = *(void *)a3;
    }
    *(_DWORD *)uint64_t v44 = 141558275;
    *(void *)&v44[4] = 1752392040;
    *(_WORD *)&v44[12] = 2081;
    *(void *)&v44[14] = v26;
    uint64_t v27 = "#I IMS not available while searching for: [%{private, mask.hash}s]";
  }
  else
  {
    if (*((_DWORD *)v20 + 14) == 1)
    {
      *(void *)uint64_t v34 = 0;
      uint64_t v35 = 0;
      sub_10102C64C((uint64_t)v34, a1, a2, a3);
    }
    long long v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_56;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v30 = a3;
    }
    else {
      uint64_t v30 = *(void *)a3;
    }
    *(_DWORD *)uint64_t v44 = 141558275;
    *(void *)&v44[4] = 1752392040;
    *(_WORD *)&v44[12] = 2081;
    *(void *)&v44[14] = v30;
    uint64_t v27 = "#I IMS not registered while searching for: [%{private, mask.hash}s]";
  }
  _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v27, v44, 0x16u);
LABEL_56:
  uint64_t v12 = &_mh_execute_header;
  uint64_t v13 = 1;
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  return v13 | (unint64_t)v12 & (unint64_t)&_mh_execute_header;
}

void sub_10102E288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (STACK[0x248]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x248]);
  }
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10102E428(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I === read-cached-capabilities: [%{private, mask.hash}s] ===", buf, 0x16u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_10102BE08(buf, a1, a2, a3);
  if (*(void *)buf)
  {
    sub_100177E14(*(uint64_t *)buf, a4);
  }
  else
  {
    int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v11 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Bailing out of read cached capabilities", v11, 2u);
    }
    *a4 = 0;
    a4[208] = 0;
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_10102E5D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10102E5FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 56));
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = (uint64_t)(*(void *)(v2 + 96) - *(void *)(v2 + 88)) >> 4;
          int v9 = 134217984;
          uint64_t v10 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Discovery timer expired. Clearing total searches: %zu", (uint8_t *)&v9, 0xCu);
        }
        sub_10019E028((uint64_t *)(v2 + 88));
      }
      sub_10004D2C8(v5);
    }
  }
  uint64_t result = *(void *)(v2 + 224);
  *(void *)(v2 + 224) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_10102E738(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10102E74C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v7 = a3;
    }
    else {
      uint64_t v7 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I === chatbot-found: [%{private, mask.hash}s] ===", buf, 0x16u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_10102BE08(buf, a1, a2, a3);
  if (*(void *)buf)
  {
    sub_100176D58(*(uint64_t *)buf, 1);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Bailing out of chatbot found", v9, 2u);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_10102E8E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102E90C(uint64_t a1, uint64_t a2, void **a3, void **a4)
{
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      int v9 = a3;
    }
    else {
      int v9 = *a3;
    }
    if (*((char *)a4 + 23) >= 0) {
      uint64_t v10 = a4;
    }
    else {
      uint64_t v10 = *a4;
    }
    *(_DWORD *)long long buf = 141558787;
    *(void *)&uint8_t buf[4] = 1752392040;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v9;
    *(_WORD *)&unsigned char buf[22] = 2160;
    v44[0] = (void *)1752392040;
    LOWORD(v44[1]) = 2081;
    *(void **)((char *)&v44[1] + 2) = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I === chatbot-identity-updated: [%{private, mask.hash}s] ==> [%{private, mask.hash}s] ===", buf, 0x2Au);
  }
  uint64_t v40 = 0;
  char v41 = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(buf, *a3, (unint64_t)a3[1]);
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)a3;
    *(void *)&uint8_t buf[16] = a3[2];
  }
  LOBYTE(v46) = 0;
  char v48 = 0;
  uint64_t v50 = 0;
  long long __p = 0uLL;
  memset(v44, 0, sizeof(v44));
  char v45 = 0;
  sub_10102BE08(&v40, a1, a2, (uint64_t)buf);
  if (SHIBYTE(v50) < 0) {
    operator delete((void *)__p);
  }
  if (v48)
  {
    uint64_t v42 = (void **)&v46;
    sub_100047F64(&v42);
  }
  if (SHIBYTE(v44[2]) < 0) {
    operator delete(v44[0]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v11 = v40;
  if (v40)
  {
    sub_10017759C(v40, (const char *)a4);
    sub_100176D58(v11, 1);
    uint64_t v12 = *(void *)(a1 + 208);
    if (*((char *)a3 + 23) < 0)
    {
      sub_10004FC84(buf, *a3, (unint64_t)a3[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)a3;
      *(void *)&uint8_t buf[16] = a3[2];
    }
    LOBYTE(v46) = 0;
    char v48 = 0;
    uint64_t v50 = 0;
    long long __p = 0uLL;
    memset(v44, 0, sizeof(v44));
    char v45 = 0;
    if (*((char *)a4 + 23) < 0)
    {
      sub_10004FC84(&v51, *a4, (unint64_t)a4[1]);
      char v14 = v45;
      BOOL v15 = v48 == 0;
    }
    else
    {
      char v14 = 0;
      long long v51 = *(_OWORD *)a4;
      long long v52 = a4[2];
      BOOL v15 = 1;
    }
    char v57 = 0;
    char v58 = 0;
    char v56 = 0;
    char v62 = 1;
    long long v17 = *(_OWORD *)buf;
    uint64_t v18 = *(void *)&buf[16];
    memset(buf, 0, sizeof(buf));
    long long v19 = *(_OWORD *)v44;
    __int16 v20 = v44[2];
    memset(v44, 0, sizeof(v44));
    char v21 = v14;
    LOBYTE(v22) = 0;
    char v24 = 0;
    if (!v15)
    {
      long long v22 = v46;
      uint64_t v23 = v47;
      uint64_t v47 = 0;
      long long v46 = 0uLL;
      char v24 = 1;
    }
    long long v25 = __p;
    uint64_t v26 = v50;
    uint64_t v50 = 0;
    long long __p = 0uLL;
    long long v27 = v51;
    uint64_t v16 = (uint64_t)v52;
    long long v51 = 0uLL;
    long long v52 = 0;
    uint64_t v28 = v16;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    uint64_t v53 = 0;
    char v32 = 0;
    char v33 = 0;
    char v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    char v38 = 1;
    char v39 = 1;
    (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v12 + 96))(v12, a2, &v17);
    if (v39) {
      sub_1001FA16C((uint64_t)&v17);
    }
    sub_1001FA16C((uint64_t)buf);
  }
  else
  {
    uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Bailing out of chatbot identity updated", buf, 2u);
    }
  }
  if (v41) {
    sub_10004D2C8(v41);
  }
}

void sub_10102ED40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::__shared_weak_count *a41,uint64_t a42,char a43)
{
  if (a41) {
    sub_10004D2C8(a41);
  }
  _Unwind_Resume(a1);
}

void sub_10102EDA8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = *(void *)a3;
    }
    *(_DWORD *)long long buf = 141558275;
    uint64_t v18 = 1752392040;
    __int16 v19 = 2081;
    uint64_t v20 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I === get-normalized-destination for: [%{private, mask.hash}s] ===", buf, 0x16u);
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  sub_10102BE08(&v15, a1, a2, a3);
  uint64_t v10 = v15;
  uint64_t v11 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
  if (v15)
  {
    uint64_t v12 = *(NSObject **)v11();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v13 = a3;
      }
      else {
        uint64_t v13 = *(void *)a3;
      }
      *(_DWORD *)long long buf = 141558275;
      uint64_t v18 = 1752392040;
      __int16 v19 = 2081;
      uint64_t v20 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Handling destination with updated capabilities: [%{private, mask.hash}s]", buf, 0x16u);
    }
    a3 = v10 + 72;
  }
  else
  {
    char v14 = *(NSObject **)v11();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Bailing out of read normalizing destination", buf, 2u);
    }
  }
  sub_1001789C8(a4, (long long *)a3);
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_10102EFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10102EFFC(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  sub_10102B974((uint64_t)v21, a1, a2);
  if (v22)
  {
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = Lazuli::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Ignoring capabilities response. Discovery not supported: %s", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v20 = 0;
    memset(v19, 0, sizeof(v19));
    uint64_t v9 = *a3;
    xpc_object_t v18 = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t v18 = xpc_null_create();
    }
    long long v17 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    memset(&__str, 0, sizeof(__str));
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    uint64_t v16 = (void *)ims::lazuli::kRemoteUri;
    __dst.__r_.__value_.__l.__size_ = ims::lazuli::kRemoteUri;
    sub_100048BAC((uint64_t)&__dst, &object);
    memset(__p, 0, 24);
    xpc::dyn_cast_or_default();
    sub_100CC85C0(&__str, (uint64_t)buf);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    xpc_release((xpc_object_t)object);
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    memset(buf, 0, sizeof(buf));
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = __str;
    }
    sub_100CC85C0(__p, (uint64_t)&__dst);
    sub_10102BA8C(buf, a1, a2, (long long *)__p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if ((_BYTE)v39)
    {
      long long object = 0uLL;
      uint64_t v24 = 0;
      if ((char)buf[23] < 0)
      {
        sub_10004FC84(&object, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        long long object = *(_OWORD *)buf;
        uint64_t v24 = *(void *)&buf[16];
      }
      uint64_t v10 = HIBYTE(v24);
      if (v24 < 0) {
        uint64_t v10 = *((void *)&object + 1);
      }
      if (v10)
      {
        sub_100CC85C0(__p, (uint64_t)&object);
        sub_100CC84D0();
      }
      uint64_t v11 = *v17;
      if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT))
      {
        sub_100120074(&v18, &__dst);
        uint64_t v12 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__dst
            : (std::string *)__dst.__r_.__value_.__r.__words[0];
        LODWORD(__p[0]) = 141558787;
        *(void **)((char *)__p + 4) = (void *)1752392040;
        WORD2(__p[1]) = 2081;
        *(void **)((char *)&__p[1] + 6) = v16;
        HIWORD(__p[2]) = 2160;
        __p[3] = (void *)1752392040;
        LOWORD(v28) = 2081;
        *(void *)((char *)&v28 + 2) = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Unable to extract URI: Invalid key [%{private, mask.hash}s] from [%{private, mask.hash}s]", (uint8_t *)__p, 0x2Au);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }
      LOBYTE(v19[0]) = 0;
      LOBYTE(v20) = 0;
      if (SHIBYTE(v24) < 0) {
        operator delete((void *)object);
      }
    }
    else
    {
      LOBYTE(v19[0]) = 0;
      LOBYTE(v20) = 0;
    }
    sub_100179564((uint64_t)buf);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    xpc_release(v18);
    xpc_object_t v18 = 0;
    if ((_BYTE)v20)
    {
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v28 = 0u;
      memset(__p, 0, sizeof(__p));
      sub_1001789C8((char *)__p, v19);
      uint64_t v13 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        char v14 = __p;
        if (SHIBYTE(__p[2]) < 0) {
          char v14 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 141558275;
        *(void *)&uint8_t buf[4] = 1752392040;
        *(_WORD *)&unsigned char buf[12] = 2081;
        *(void *)&buf[14] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Capabilities response from: [%{private, mask.hash}s]", buf, 0x16u);
      }
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = 0uLL;
      sub_10102C64C((uint64_t)&__str, a1, a2, (uint64_t)__p);
    }
    uint64_t v15 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Unhandled capabilities response", buf, 2u);
    }
    sub_100179564((uint64_t)v19);
  }
}

void sub_101030A18(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_101030FC8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v40 = 0;
  char v41 = 0;
  sub_10102C10C(&v40, a1, a2);
  if (v40)
  {
    uint64_t v39 = 0;
    memset(v38, 0, sizeof(v38));
    sub_10102B974((uint64_t)v38, a1, a2);
    uint64_t v7 = *(void *)(a1 + 168);
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v8 = a1 + 168;
    do
    {
      int v9 = *(_DWORD *)(v7 + 32);
      BOOL v10 = v9 < (int)a2;
      if (v9 >= (int)a2) {
        uint64_t v11 = (uint64_t *)v7;
      }
      else {
        uint64_t v11 = (uint64_t *)(v7 + 8);
      }
      if (!v10) {
        uint64_t v8 = v7;
      }
      uint64_t v7 = *v11;
    }
    while (*v11);
    if (v8 == a1 + 168 || *(_DWORD *)(v8 + 32) > (int)a2)
    {
LABEL_12:
      uint64_t v12 = *v6;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Missing provisioning initializer", buf, 2u);
      }
    }
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    *(_OWORD *)long long buf = 0u;
    uint64_t v13 = *(void *)(a1 + 64);
    v18[0] = *(void *)(a1 + 56);
    v18[1] = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    char v14 = *(std::__shared_weak_count **)(a1 + 16);
    if (v14)
    {
      uint64_t v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        uint64_t v16 = (NSObject **)(a1 + 24);
        atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        if (v41) {
          atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_10016EFEC((uint64_t)buf, a2, v18, v16, a3);
      }
    }
    sub_100088B9C();
  }
  long long v17 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to instantiate chat services during delete chat", buf, 2u);
  }
  if (v41) {
    sub_10004D2C8(v41);
  }
}

void sub_101031238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, char a17)
{
  sub_10103182C((uint64_t)&a17);
  __int16 v19 = *(std::__shared_weak_count **)(v17 - 72);
  if (v19) {
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(a1);
}

void sub_101031294(void *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  __p[3] = a1;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1010313F4(void *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  __p[3] = a1;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101031554(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v5 = *(std::__shared_weak_count **)(a1 + 64);
  uint64_t v8 = *(void *)(a1 + 56);
  int v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(__p, "Capabilities");
  v13[0] = 0;
  v13[1] = 0;
  int v12 = a2;
  sub_100B8C1D0(&v12, &v8, a3, (uint64_t)__p, v13, &v10);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100B8A7C8(v10);
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_101031604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_101031644(void *a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  __p[3] = a1;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

__n128 sub_101031794(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v3 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)(a1 + 24) = v3;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  char v4 = *((unsigned char *)a2 + 48);
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 48) = v4;
  *(unsigned char *)(a1 + 80) = 0;
  if (*((unsigned char *)a2 + 80))
  {
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(_OWORD *)(a1 + 56) = *(long long *)((char *)a2 + 56);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *((void *)a2 + 7) = 0;
    *((void *)a2 + 8) = 0;
    *((void *)a2 + 9) = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  __n128 result = *(__n128 *)((char *)a2 + 88);
  *(void *)(a1 + 104) = *((void *)a2 + 13);
  *(__n128 *)(a1 + 88) = result;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 11) = 0;
  *(unsigned char *)(a1 + 112) = 1;
  return result;
}

void *sub_10103182C(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 296);
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 280);
  if (v3) {
    sub_10004D2C8(v3);
  }
  char v4 = *(std::__shared_weak_count **)(a1 + 264);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v10 = (void **)(a1 + 216);
  sub_100047F64(&v10);
  int v5 = *(std::__shared_weak_count **)(a1 + 208);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 192);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(unsigned char *)(a1 + 152))
  {
    uint64_t v10 = (void **)(a1 + 128);
    sub_100047F64(&v10);
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  char v7 = *(std::__shared_weak_count **)(a1 + 64);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  return sub_100087E88((void *)a1);
}

void sub_101031938()
{
}

uint64_t sub_10103194C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_101031958(dispatch_object_t *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x110uLL);
  sub_1010319E4(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;

  sub_1000B3BC8((uint64_t)a4, v8 + 4, (uint64_t)(v8 + 3));
}

void sub_1010319D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1010319E4(void *a1, dispatch_object_t *a2, uint64_t *a3, uint64_t *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A7FC08;
  sub_101031ADC((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_101031A2C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_101031A40(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FC08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101031A60(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FC08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101031AB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

uint64_t sub_101031ADC(uint64_t a1, dispatch_object_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = (std::__shared_weak_count *)a3[1];
  uint64_t v14 = *a3;
  uint64_t v15 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *a4;
  char v7 = (std::__shared_weak_count *)a4[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, "lazuli.cap.ctr");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int v9 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v9) {
    dispatch_retain(v9);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  *(void *)a1 = &off_1019EC970;
  v20[0] = off_101999E18;
  v20[1] = sub_10102AEB0;
  v20[3] = v20;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v10) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v20);
  *(void *)a1 = off_101A7F9F8;
  *(void *)(a1 + 56) = v14;
  *(void *)(a1 + 64) = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "lazuli.cap.ctr");
  uint64_t v16 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  ctu::RestModule::RestModule();
  if (v16) {
    dispatch_release(v16);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 112) = a1 + 120;
  *(_OWORD *)(a1 + 88) = 0u;
  DefaultLazuliCapabilitiesInformationMap = GetDefaultLazuliCapabilitiesInformationMap();
  sub_1004ECB58((uint64_t *)(a1 + 136), (uint64_t)DefaultLazuliCapabilitiesInformationMap);
  DefaultLazuliProvisioningInitializerMap = GetDefaultLazuliProvisioningInitializerMap();
  sub_1001FDE4C((uint64_t *)(a1 + 160), (uint64_t)DefaultLazuliProvisioningInitializerMap);
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 184) = a1 + 192;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = v8;
  *(void *)(a1 + 216) = v7;
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
    sub_10004D2C8(v7);
  }
  else
  {
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  return a1;
}

void sub_101031E4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
}

void sub_101031FDC()
{
}

void *sub_101031FF0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A7FC58;
  result[1] = v3;
  return result;
}

uint64_t sub_101032038(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A7FC58;
  a2[1] = v2;
  return result;
}

void sub_101032064(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10103206C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010320AC()
{
}

void sub_1010320BC()
{
}

__n128 sub_1010320D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A7FCD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101032124(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A7FCD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10103215C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  int v5 = (uint64_t **)(v3 + 8);
  char v4 = *(void **)(v3 + 8);
  long long v23 = *(uint64_t **)v3;
  long long v24 = v4;
  if (*(void *)(v3 + 16))
  {
    void v4[2] = &v24;
    *(void *)uint64_t v3 = v5;
    *int v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    long long v23 = (uint64_t *)&v24;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_1000346F8(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v29, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v28, object, count);
    xpc_release(object[0]);
    for (int i = v30; ; int i = ++v30)
    {
      if (i == v28[1] && v29 == v28[0])
      {
        xpc_release(v29);
        xpc_release(v29);
        goto LABEL_48;
      }
      xpc_object_t v27 = 0;
      object[0] = &v29;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v27);
      if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_46:
      xpc_release(v27);
    }
    memset(object, 0, 48);
    LODWORD(object[5]) = -1;
    xpc_object_t v9 = v27;
    if (v27)
    {
      xpc_retain(v27);
      xpc_object_t v34 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v34 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
      goto LABEL_30;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v34 = v10;
LABEL_30:
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
    {
      long long v31 = &v34;
      long long v32 = "first";
      sub_100048BAC((uint64_t)&v31, v33);
      xpc_type_t type = xpc_get_type(*(xpc_object_t *)v33);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        v35[0] = (int)object[0];
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v35, v33, v12);
        LODWORD(object[0]) = v35[0];
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        LODWORD(object[0]) = xpc::dyn_cast_or_default((xpc *)v33, 0, (uint64_t)v12);
      }
      xpc_release(*(xpc_object_t *)v33);
      long long v31 = &v34;
      long long v32 = "second";
      sub_100048BAC((uint64_t)&v31, v33);
      read_rest_value((uint64_t)&object[1], (void **)v33);
      xpc_release(*(xpc_object_t *)v33);
      xpc_object_t v10 = v34;
    }
    xpc_release(v10);
    xpc_release(v9);
    int v13 = (int)object[0];
    uint64_t v14 = *v5;
    uint64_t v15 = (uint64_t **)(v3 + 8);
    uint64_t v16 = (uint64_t **)(v3 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v16 = (uint64_t **)v14;
          int v17 = *((_DWORD *)v14 + 8);
          if (v17 <= SLODWORD(object[0])) {
            break;
          }
          uint64_t v14 = *v16;
          uint64_t v15 = v16;
          if (!*v16) {
            goto LABEL_45;
          }
        }
        if (v17 >= SLODWORD(object[0])) {
          break;
        }
        uint64_t v14 = v16[1];
        if (!v14)
        {
          uint64_t v15 = v16 + 1;
          goto LABEL_45;
        }
      }
    }
    else
    {
LABEL_45:
      char v18 = (char *)operator new(0x50uLL);
      *((_DWORD *)v18 + 8) = v13;
      long long v19 = *(_OWORD *)&object[3];
      *(_OWORD *)(v18 + 40) = *(_OWORD *)&object[1];
      *(_OWORD *)(v18 + 56) = v19;
      *((xpc_object_t *)v18 + 9) = object[5];
      sub_100046C38((uint64_t **)v3, (uint64_t)v16, v15, (uint64_t *)v18);
    }
    goto LABEL_46;
  }
LABEL_48:
  xpc_release(v6);
  long long v20 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v21 = a1[4];
  long long v22 = (void *)(a1[2] + (v21 >> 1));
  if (v21) {
    long long v20 = *(void (**)(void *, uint64_t **))(*v22 + v20);
  }
  v20(v22, &v23);
  sub_1000346F8((uint64_t)&v23, v24);
}

void sub_1010325A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,xpc_object_t a21,uint64_t a22,xpc_object_t a23)
{
  xpc_release(object);
  long long object = 0;
  xpc_release(a23);
  xpc_release(v23);
  sub_1000346F8((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_101032694(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010326D4()
{
}

void sub_1010326E4()
{
}

void *sub_1010326F8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A7FD58;
  result[1] = v3;
  return result;
}

uint64_t sub_101032740(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A7FD58;
  a2[1] = v2;
  return result;
}

void sub_10103276C(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_101032774(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010327B4()
{
}

void sub_1010327C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FDD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1010327E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FDD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_101032834(uint64_t a1)
{
  return sub_10103182C(a1 + 24);
}

uint64_t *sub_101032840(unsigned int **a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v6 = a1;
  char v7 = v1;
  uint64_t v2 = *(void *)(*((void *)v1 + 45) + 208);
  uint64_t v3 = *v1;
  sub_1001789C8(__dst, (long long *)(v1 + 62));
  __dst[112] = 1;
  if (!*((unsigned char *)v1 + 216)) {
    sub_10016C840();
  }
  sub_1001793CC((uint64_t)v19, (uint64_t)(v1 + 2));
  v19[208] = 1;
  LOBYTE(v8) = 1;
  BYTE4(v8) = 0;
  char v9 = 0;
  if (*((char *)v1 + 247) < 0)
  {
    sub_10004FC84(&v10, *((void **)v1 + 28), *((void *)v1 + 29));
  }
  else
  {
    long long v10 = *((_OWORD *)v1 + 14);
    uint64_t v11 = *((void *)v1 + 30);
  }
  LOBYTE(v12) = 0;
  BYTE4(v12) = 0;
  uint64_t v13 = v8;
  char v14 = v9;
  uint64_t v4 = v11;
  *(_OWORD *)long long __p = v10;
  uint64_t v11 = 0;
  long long v10 = 0uLL;
  uint64_t v16 = v4;
  uint64_t v17 = v12;
  char v18 = 1;
  (*(void (**)(uint64_t, uint64_t, char *, unsigned char *, uint64_t *))(*(void *)v2 + 48))(v2, v3, __dst, v19, &v13);
  if (v18 && SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10);
  }
  sub_1001794B8((uint64_t)v19);
  sub_100179564((uint64_t)__dst);
  sub_101032A28((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1010329BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30,int a31,__int16 a32,char a33,char a34)
{
  sub_1001794B8((uint64_t)&a32);
  sub_100179564(v34 - 168);
  sub_101032A28(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101032A28(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 359) < 0) {
      operator delete(*(void **)(v1 + 336));
    }
    if (*(unsigned char *)(v1 + 328))
    {
      uint64_t v2 = (void **)(v1 + 304);
      sub_100047F64(&v2);
    }
    if (*(char *)(v1 + 295) < 0) {
      operator delete(*(void **)(v1 + 272));
    }
    if (*(char *)(v1 + 271) < 0) {
      operator delete(*(void **)(v1 + 248));
    }
    if (*(char *)(v1 + 247) < 0) {
      operator delete(*(void **)(v1 + 224));
    }
    sub_1001794B8(v1 + 8);
    operator delete();
  }
  return result;
}

uint64_t *sub_101032AD8(unsigned int **a1)
{
  uint64_t v1 = *a1;
  char v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)(*((void *)v1 + 18) + 208);
  uint64_t v3 = *v1;
  sub_1001789C8(__dst, (long long *)v1 + 2);
  __dst[112] = 1;
  v20[0] = 0;
  v20[208] = 0;
  LOBYTE(v9) = 1;
  BYTE4(v9) = 0;
  char v10 = 0;
  if (*((char *)v1 + 31) < 0)
  {
    sub_10004FC84(&v11, *((void **)v1 + 1), *((void *)v1 + 2));
  }
  else
  {
    long long v4 = *(_OWORD *)(v1 + 2);
    uint64_t v12 = *((void *)v1 + 3);
    long long v11 = v4;
  }
  LOBYTE(v13) = 0;
  BYTE4(v13) = 0;
  uint64_t v14 = v9;
  char v15 = v10;
  uint64_t v5 = v12;
  *(_OWORD *)long long __p = v11;
  uint64_t v12 = 0;
  long long v11 = 0uLL;
  uint64_t v17 = v5;
  uint64_t v18 = v13;
  char v19 = 1;
  (*(void (**)(uint64_t, uint64_t, char *, unsigned char *, uint64_t *))(*(void *)v2 + 48))(v2, v3, __dst, v20, &v14);
  if (v19 && SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)v11);
  }
  sub_1001794B8((uint64_t)v20);
  sub_100179564((uint64_t)__dst);
  sub_101032C9C((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_101032C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30,int a31,__int16 a32,char a33,char a34)
{
  sub_1001794B8((uint64_t)&a32);
  sub_100179564(v34 - 168);
  sub_101032C9C(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101032C9C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 143) < 0) {
      operator delete(*(void **)(v1 + 120));
    }
    if (*(unsigned char *)(v1 + 112))
    {
      uint64_t v2 = (void **)(v1 + 88);
      sub_100047F64(&v2);
    }
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_101032D44(unsigned int **a1)
{
  uint64_t v1 = *a1;
  long long v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *((void *)v1 + 4);
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = v1 + 2;
    if (*((char *)v1 + 31) < 0) {
      long long v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I === discover-on-404 for: [%{private, mask.hash}s] ===", buf, 0x16u);
  }
  long long v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v16 = 0u;
  memset(buf, 0, sizeof(buf));
  uint64_t v5 = (long long *)(v1 + 2);
  if (*((char *)v1 + 31) < 0)
  {
    sub_10004FC84(buf, *((void **)v1 + 1), *((void *)v1 + 2));
  }
  else
  {
    long long v6 = *v5;
    *(void *)&uint8_t buf[16] = *((void *)v1 + 3);
    *(_OWORD *)long long buf = v6;
  }
  BYTE8(v17[0]) = 0;
  LOBYTE(v18) = 0;
  long long v19 = 0uLL;
  *((void *)&v18 + 1) = 0;
  long long v16 = 0uLL;
  *(void *)&uint8_t buf[24] = 0;
  LOBYTE(v17[0]) = 0;
  sub_101030FC8(v2, *v1, (uint64_t)buf);
  uint64_t v7 = *v1;
  int v13 = 1;
  memset(__p, 0, 24);
  unint64_t v8 = sub_10102D604(v2, v7, (uint64_t)buf, &v13, (uint64_t)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (HIDWORD(v8))
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v1 + 31) < 0) {
        uint64_t v5 = *(long long **)v5;
      }
      LODWORD(__p[0]) = 141558275;
      *(void **)((char *)__p + 4) = (void *)1752392040;
      WORD2(__p[1]) = 2081;
      *(void **)((char *)&__p[1] + 6) = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Discovery failure for: [%{private, mask.hash}s]", (uint8_t *)__p, 0x16u);
    }
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(*((void **)&v18 + 1));
  }
  if ((_BYTE)v18)
  {
    __p[0] = (char *)v17 + 8;
    sub_100047F64((void ***)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  sub_101033070((uint64_t *)&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_101032FEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a36) {
    sub_100047F64((void ***)&a13);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_101033070(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101033070(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1010330C8(unsigned int **a1)
{
  uint64_t v1 = *a1;
  long long v19 = a1;
  long long v20 = v1;
  uint64_t v2 = *((void *)v1 + 4);
  (*(void (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  memset(v24, 0, sizeof(v24));
  uint64_t v3 = *v1;
  long long v4 = (long long *)(v1 + 2);
  if (*((char *)v1 + 31) < 0)
  {
    sub_10004FC84(buf, *((void **)v1 + 1), *((void *)v1 + 2));
  }
  else
  {
    long long v5 = *v4;
    *(void *)&uint8_t buf[16] = *((void *)v1 + 3);
    *(_OWORD *)long long buf = v5;
  }
  BYTE8(v33[0]) = 0;
  LOBYTE(v34) = 0;
  long long v35 = 0uLL;
  *((void *)&v34 + 1) = 0;
  long long v32 = 0uLL;
  *(void *)&uint8_t buf[24] = 0;
  LOBYTE(v33[0]) = 0;
  sub_10102E428(v2, v3, (uint64_t)buf, v24);
  if (SHIBYTE(v35) < 0) {
    operator delete(*((void **)&v34 + 1));
  }
  if ((_BYTE)v34)
  {
    long long __p = (char *)v33 + 8;
    sub_100047F64((void ***)&__p);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  long long v6 = *(uint64_t (**)(void))(**(void **)(v2 + 48) + 16);
  if ((_BYTE)v29 && BYTE8(v25))
  {
    uint64_t v7 = *(NSObject **)v6();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v8 = v1 + 2;
      if (*((char *)v1 + 31) < 0) {
        unint64_t v8 = *(unsigned int **)v4;
      }
      *(_DWORD *)long long buf = 141558275;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&unsigned char buf[12] = 2081;
      *(void *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cache alredy present for: [%{private, mask.hash}s]. Skipping discovery", buf, 0x16u);
    }
    long long __p = 0;
    long long v22 = 0;
    uint64_t v9 = *v1;
    if (*((char *)v1 + 31) < 0)
    {
      sub_10004FC84(buf, *((void **)v1 + 1), *((void *)v1 + 2));
    }
    else
    {
      long long v10 = *v4;
      *(void *)&uint8_t buf[16] = *((void *)v1 + 3);
      *(_OWORD *)long long buf = v10;
    }
    BYTE8(v33[0]) = 0;
    LOBYTE(v34) = 0;
    long long v35 = 0uLL;
    *((void *)&v34 + 1) = 0;
    long long v32 = 0uLL;
    *(void *)&uint8_t buf[24] = 0;
    LOBYTE(v33[0]) = 0;
    sub_10102BE08(&__p, v2, v9, (uint64_t)buf);
    if (SHIBYTE(v35) < 0) {
      operator delete(*((void **)&v34 + 1));
    }
    if ((_BYTE)v34)
    {
      long long v30 = (void **)v33 + 1;
      sub_100047F64(&v30);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    if (__p)
    {
      *(_DWORD *)long long buf = 0;
      sub_1001772FC((uint64_t)__p, (int *)buf);
    }
    else
    {
      uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Bailing out of discovery on message reception", buf, 2u);
      }
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
  }
  else
  {
    long long v11 = *(NSObject **)v6();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v1 + 2;
      if (*((char *)v1 + 31) < 0) {
        uint64_t v12 = *(unsigned int **)v4;
      }
      *(_DWORD *)long long buf = 141558275;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&unsigned char buf[12] = 2081;
      *(void *)&buf[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Starting discovery upon message received for: [%{private, mask.hash}s]", buf, 0x16u);
    }
    long long v34 = 0u;
    long long v35 = 0u;
    memset(v33, 0, sizeof(v33));
    long long v32 = 0u;
    memset(buf, 0, sizeof(buf));
    if (*((char *)v1 + 31) < 0)
    {
      sub_10004FC84(buf, *((void **)v1 + 1), *((void *)v1 + 2));
    }
    else
    {
      long long v13 = *v4;
      *(void *)&uint8_t buf[16] = *((void *)v1 + 3);
      *(_OWORD *)long long buf = v13;
    }
    BYTE8(v33[0]) = 0;
    LOBYTE(v34) = 0;
    long long v35 = 0uLL;
    *((void *)&v34 + 1) = 0;
    long long v32 = 0uLL;
    *(void *)&uint8_t buf[24] = 0;
    LOBYTE(v33[0]) = 0;
    uint64_t v14 = *v1;
    LODWORD(v30) = 1;
    long long __p = 0;
    long long v22 = 0;
    uint64_t v23 = 0;
    unint64_t v15 = sub_10102D604(v2, v14, (uint64_t)buf, (int *)&v30, (uint64_t)&__p);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p);
    }
    if (HIDWORD(v15))
    {
      long long v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Fetch failed", (uint8_t *)&__p, 2u);
      }
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(*((void **)&v34 + 1));
    }
    if ((_BYTE)v34)
    {
      long long __p = (char *)v33 + 8;
      sub_100047F64((void ***)&__p);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1001794B8((uint64_t)v24);
  sub_101033070((uint64_t *)&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1010335FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_1001794B8((uint64_t)&a18);
  sub_101033070(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_101033724(unsigned int **a1)
{
  uint64_t v1 = *a1;
  long long v4 = a1;
  long long v5 = v1;
  uint64_t v2 = *((void *)v1 + 4);
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  memset(&__p, 0, sizeof(__p));
  memset(__s, 0, sizeof(__s));
  sub_100CC85C0(__s, (uint64_t)(v1 + 2));
  if (!sub_100CC801C(__s)) {
    sub_100CC8260();
  }
  if (sub_100CC801C(__s)) {
    sub_100CC7BC4();
  }
  std::string::operator=(&__p, (const std::string *)(v1 + 2));
  char v8 = 0;
  sub_100563D68((Registry **)(v2 + 56), v3, (unsigned __int8 *)&__p, &v8, (uint64_t)&v6);
  sub_100CC85C0(&__dst, (uint64_t)&v6);
  sub_100CC7D60();
}

void sub_101033DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  sub_101033070(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_101033F5C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FE28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101033F7C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FE28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101033FD8(void *a1@<X8>)
{
  if (qword_101B130A8 != -1) {
    dispatch_once(&qword_101B130A8, &stru_101A7FF48);
  }
  if (byte_101B130A0)
  {
    uint64_t v2 = operator new(0x40uLL);
    v2[1] = 0;
    v2[2] = 0;
    *uint64_t v2 = off_101A7FF78;
    v2[4] = 0;
    v2[5] = 0;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "localauth");
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v2 + 6), (const ctu::OsLogLogger *)v4);
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
    v2[3] = off_101A7FE90;
    operator new();
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_1010341A4()
{
}

id sub_101034220(uint64_t a1, int a2)
{
  OsLogContext v3 = **(void ***)(a1 + 32);
  if (a2) {
    uint64_t v4 = 2;
  }
  else {
    uint64_t v4 = 1;
  }
  id v12 = 0;
  id v5 = [v3 canEvaluatePolicy:v4 error:&v12];
  id v6 = v12;
  if (v6)
  {
    uint64_t v7 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      id v9 = [v6 description];
      id v10 = [v9 UTF8String];
      *(_DWORD *)long long buf = 136315394;
      uint64_t v14 = v8;
      __int16 v15 = 2080;
      id v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Cannot evaluate policy %s: error %s", buf, 0x16u);
    }
  }

  return v5;
}

void sub_101034340(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101034364(uint64_t a1, uint64_t *a2)
{
  id v4 = objc_alloc_init((Class)NSMutableDictionary);
  id v5 = v4;
  if (a2[5]) {
    id v6 = sub_1000810B8;
  }
  else {
    id v6 = 0;
  }
  if (v6) {
    objc_msgSend(v4, "setObject:forKey:");
  }
  if (a2[6]) {
    uint64_t v7 = sub_1000810B8;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7) {
    objc_msgSend(v5, "setObject:forKey:");
  }
  if (*((unsigned char *)a2 + 56)) {
    [v5 setObject:&off_101AE6538 forKey:&off_101AE6550];
  }
  if (a2[8]) {
    uint64_t v8 = sub_1000810B8;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8) {
    objc_msgSend(v5, "setObject:forKey:");
  }
  if (a2[9]) {
    id v9 = sub_1000810B8;
  }
  else {
    id v9 = 0;
  }
  if (v9) {
    objc_msgSend(v5, "setObject:forKey:");
  }

  int v10 = *((unsigned __int8 *)a2 + 8);
  uint64_t v11 = *a2;
  if (*a2 && (uint64_t v12 = *(void *)(v11 + 8)) != 0 && *(void *)(v11 + 40))
  {
    long long v13 = (std::__shared_weak_count *)operator new(0x48uLL);
    v13->__shared_weak_owners_ = 0;
    v13->__shared_owners_ = 0;
    v13->__vftable = (std::__shared_weak_count_vtbl *)off_101A80010;
    LOBYTE(v13[1].__vftable) = *(unsigned char *)v11;
    uint64_t v14 = v13 + 1;
    v13[1].__shared_owners_ = v12;
    *(void *)(v11 + 8) = 0;
    sub_100F5C5F0((uint64_t)&v13[1].__shared_weak_owners_, v11 + 16);
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
  }
  else
  {
    uint64_t v14 = 0;
    long long v13 = 0;
  }
  __int16 v15 = **(void ***)(a1 + 32);
  if (v10) {
    uint64_t v16 = 2;
  }
  else {
    uint64_t v16 = 1;
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3321888768;
  _OWORD v17[2] = sub_101034614;
  v17[3] = &unk_101A7FEB0;
  char v19 = v10;
  v17[4] = a1;
  v17[5] = v14;
  long long v18 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v15 evaluatePolicy:v16 options:v5 reply:v17];
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_1010345C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1010345F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  JUMPOUT(0x1010345E8);
}

void sub_101034614(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = *(NSObject **)(*(void *)(a1 + 32) + 24);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = asString();
      id v11 = [v6 description];
      int v12 = 136315394;
      uint64_t v13 = v10;
      __int16 v14 = 2080;
      id v15 = [v11 UTF8String];
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Policy %s evaluation failed: %s", (uint8_t *)&v12, 0x16u);
    }
    id v8 = [v6 code];
    if ((unint64_t)v8 <= 0xFFFFFFFFFFFFFFF5) {
      char v9 = 1;
    }
    else {
      char v9 = 1 - (_BYTE)v8;
    }
  }
  else
  {
    char v9 = 0;
  }

  **(unsigned char **)(a1 + 40) = v9;
}

void sub_10103474C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101034780(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10103479C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1010347AC(uint64_t a1)
{
  *(void *)a1 = off_101A7FE90;
  sub_1003B1ED8((id **)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  LocalAuthenticationInterface::~LocalAuthenticationInterface((LocalAuthenticationInterface *)a1);
}

void sub_101034814(uint64_t a1)
{
  *(void *)a1 = off_101A7FE90;
  sub_1003B1ED8((id **)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  LocalAuthenticationInterface::~LocalAuthenticationInterface((LocalAuthenticationInterface *)a1);

  operator delete();
}

void sub_101034890(id a1)
{
  uint64_t v1 = NSClassFromString(@"LAContext");
  byte_101B130A0 = v1 != 0;
}

void sub_1010348D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FF78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1010348F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A7FF78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101034948(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_101034970(uint64_t a1)
{
  *(void *)a1 = off_101A7FE90;
  sub_1003B1ED8((id **)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  LocalAuthenticationInterface::~LocalAuthenticationInterface((LocalAuthenticationInterface *)a1);
}

void sub_1010349D8(uint64_t a1)
{
  *(void *)a1 = off_101A7FE90;
  sub_1003B1ED8((id **)(a1 + 32));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  LocalAuthenticationInterface::~LocalAuthenticationInterface((LocalAuthenticationInterface *)a1);

  operator delete();
}

void sub_101034A54(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A80010;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101034A74(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A80010;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101034AC8(uint64_t a1)
{
  return sub_100F5C42C(a1 + 24);
}

void *sub_101034AD4(void *a1, void *a2)
{
  id v4 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "sbs");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *a1 = off_101A80070;
  a1[2] = *a2;
  uint64_t v5 = a2[1];
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[4] = 0;
  a1[5] = 0;
  sub_101034C14((uint64_t)a1);
  return a1;
}

void sub_101034BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  id v15 = (std::__shared_weak_count *)*((void *)v12 + 5);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v12 + 3);
  if (v16) {
    sub_10004D2C8(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  SBServicesInterface::~SBServicesInterface(v12);
  _Unwind_Resume(a1);
}

void sub_101034C14(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    OsLogContext v3 = *(std::__shared_weak_count **)(a1 + 24);
    uint64_t v7 = v2;
    id v8 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v2)
    {
      sub_10054A608(&v7, &v9);
      long long v4 = v9;
    }
    else
    {
      long long v4 = 0uLL;
    }
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
    *(_OWORD *)(a1 + 32) = v4;
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
    DistributedCenter = CFNotificationCenterGetDistributedCenter();
    CFNotificationCenterAddObserver(DistributedCenter, *(const void **)(a1 + 32), (CFNotificationCallback)sub_101037ABC, @"com.apple.LaunchServices.applicationRegistered", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
    CFNotificationCenterAddObserver(DistributedCenter, *(const void **)(a1 + 32), (CFNotificationCallback)sub_101037ABC, @"com.apple.LaunchServices.applicationUnregistered", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
}

void sub_101034CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101034D0C(uint64_t a1, NSObject **a2, uint64_t *a3)
{
  if (*((char *)a3 + 23) >= 0) {
    id v6 = a3;
  }
  else {
    id v6 = (uint64_t *)*a3;
  }
  uint64_t v7 = +[NSString stringWithUTF8String:v6];
  id v8 = +[NSURL URLWithString:v7];

  long long v9 = *a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  void block[2] = sub_101034E18;
  block[3] = &unk_101999238;
  id v12 = v8;
  id v10 = v8;
  dispatch_async(v9, block);
}

void sub_101034E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101034E18(uint64_t a1)
{
  id v2 = +[LSApplicationWorkspace defaultWorkspace];
  [v2 openSensitiveURL:*(void *)(a1 + 32) withOptions:0];
}

void sub_101034E74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_101034E88(uint64_t a1, uint64_t *a2, unsigned char *a3, NSObject **a4, uint64_t a5)
{
  if (*((char *)a2 + 23) >= 0) {
    id v10 = a2;
  }
  else {
    id v10 = (uint64_t *)*a2;
  }
  id v11 = +[NSString stringWithUTF8String:v10];
  id v12 = +[NSURL URLWithString:v11];

  uint64_t v24 = FBSOpenApplicationOptionKeyActivateSuspended;
  uint64_t v13 = &__kCFBooleanTrue;
  if (!*a3) {
    uint64_t v13 = &__kCFBooleanFalse;
  }
  long long v25 = v13;
  __int16 v14 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
  id v15 = (std::__shared_weak_count *)operator new(0x38uLL);
  v15->__shared_weak_owners_ = 0;
  v15->__shared_owners_ = 0;
  v15->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3388;
  sub_100023950((uint64_t)&v15[1], a5);
  uint64_t v16 = *a4;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  void block[2] = sub_1010350BC;
  block[3] = &unk_101A80120;
  id v17 = v12;
  id v20 = v17;
  id v18 = v14;
  id v21 = v18;
  long long v22 = v15 + 1;
  uint64_t v23 = v15;
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  dispatch_async(v16, block);
  if (v23) {
    sub_10004D2C8(v23);
  }

  sub_10004D2C8(v15);
}

void sub_10103508C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1010350BC(void *a1)
{
  id v2 = +[LSApplicationWorkspace defaultWorkspace];
  char v3 = [v2 openSensitiveURL:a1[4] withOptions:a1[5]];

  uint64_t v4 = a1[6];

  return sub_1000607A8(v4, v3);
}

void sub_101035120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101035130(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10103514C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

const void **sub_10103515C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(const void **__return_ptr))(*(void *)a1 + 40))(&v4);
  long long v5 = 0uLL;
  uint64_t v6 = 0;
  ctu::cf::assign();
  *(_OWORD *)a2 = v5;
  *(void *)(a2 + 16) = v6;
  return sub_1000558F4(&v4);
}

void sub_1010351D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

void sub_1010351FC(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = (uint64_t *)*a2;
  }
  id v8 = +[NSString stringWithUTF8String:v7];
  long long v9 = +[LSBundleRecord bundleRecordWithBundleIdentifier:v8 allowPlaceholder:1 error:0];
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 16));
  id v12 = ServiceMap;
  if (v13 < 0)
  {
    __int16 v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v13;
  id v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)__p);
  if (!v17)
  {
    std::mutex::unlock(v12);
    goto LABEL_12;
  }
  uint64_t v19 = v17[3];
  id v18 = (std::__shared_weak_count *)v17[4];
  if (v18)
  {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v12);
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v18);
    if (!v19)
    {
      uint64_t v20 = 0;
LABEL_22:
      sub_10004D2C8(v18);
      goto LABEL_23;
    }
    goto LABEL_14;
  }
  std::mutex::unlock(v12);
  if (!v19)
  {
LABEL_12:
    uint64_t v20 = 0;
    goto LABEL_23;
  }
LABEL_14:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v26 = 0;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v19 + 64))(__p, v19);
  if (v26 >= 0) {
    id v21 = __p;
  }
  else {
    id v21 = (void **)__p[0];
  }
  long long v22 = +[NSString stringWithUTF8String:v21];
  long long v27 = v22;
  uint64_t v23 = +[NSArray arrayWithObjects:&v27 count:1];
  uint64_t v20 = [v9 localizedNameWithPreferredLocalizations:v23];

  if (!v20)
  {
    uint64_t v24 = +[NSLocale preferredLanguages];
    uint64_t v20 = [v9 localizedNameWithPreferredLocalizations:v24];
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (v18) {
    goto LABEL_22;
  }
LABEL_23:
  *a3 = v20;
}

void sub_10103545C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }

  _Unwind_Resume(a1);
}

void sub_1010354E0(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    long long v5 = a1;
  }
  else {
    long long v5 = (uint64_t *)*a1;
  }
  uint64_t v6 = +[NSString stringWithUTF8String:v5];
  id v7 = [objc_alloc((Class)LSApplicationRecord) initWithBundleIdentifier:v6 allowPlaceholder:1 error:0];
  id v8 = v7;
  if (!v7) {
    goto LABEL_8;
  }
  long long v9 = objc_msgSend(v7, "counterpartIdentifiers", 0, 0, 0, 0, 0, 0, 0, 0);
  if (![v9 countByEnumeratingWithState:&v12 objects:v15 count:16])
  {

LABEL_8:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    goto LABEL_9;
  }
  uint64_t v13 = 0;
  long long v14 = 0uLL;
  ctu::cf::assign();
  uint64_t v10 = v14;
  uint64_t v11 = *(void *)((char *)&v14 + 7);
  *(void *)a2 = v13;
  *(void *)(a2 + 8) = v10;
  *(void *)(a2 + 15) = v11;
  *(unsigned char *)(a2 + 23) = HIBYTE(v14);
  *(unsigned char *)(a2 + 24) = 1;

LABEL_9:
}

void sub_101035624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10103566C(uint64_t a1, uint64_t *a2, const char *a3)
{
  id v5 = objc_alloc((Class)NSString);
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    id v7 = a2;
  }
  else {
    id v7 = (uint64_t *)*a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v8 = a2[1];
  }
  id v26 = [v5 initWithBytesNoCopy:v7 length:v8 encoding:4 freeWhenDone:0];
  id v9 = [objc_alloc((Class)NSString) initWithBytesNoCopy:a3 length:strlen(a3) encoding:4 freeWhenDone:0];
  id v10 = +[LSBundleRecord bundleRecordWithBundleIdentifier:v26 allowPlaceholder:1 error:0];
  id v11 = v9;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v12 = [v10 extensionPointRecord];
    uint64_t v13 = [v12 name];

    unsigned __int8 v14 = [v11 isEqualToString:v13];
    if (v14)
    {
      uint64_t v15 = 1;
      goto LABEL_25;
    }
  }
  else
  {
  }
  id v16 = v10;
  id v17 = v11;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id v18 = [v16 applicationExtensionRecords];
    id v19 = [v18 countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v19)
    {
      uint64_t v20 = *(void *)v28;
      while (2)
      {
        id v21 = 0;
        do
        {
          if (*(void *)v28 != v20) {
            objc_enumerationMutation(v18);
          }
          uint64_t v22 = [*(id *)(*((void *)&v27 + 1) + 8 * (void)v21) extensionPointRecord];
          uint64_t v23 = [(id)v22 name];

          LOBYTE(v22) = [v23 isEqualToString:v17];
          if (v22)
          {
            uint64_t v15 = 1;
            goto LABEL_23;
          }
          id v21 = (char *)v21 + 1;
        }
        while (v19 != v21);
        id v19 = [v18 countByEnumeratingWithState:&v27 objects:v31 count:16];
        if (v19) {
          continue;
        }
        break;
      }
    }
    uint64_t v15 = 0;
LABEL_23:
  }
  else
  {
    uint64_t v15 = 0;
  }

LABEL_25:
  return v15;
}

void sub_101035910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1010359C8(uint64_t *a1@<X1>, void *a2@<X8>)
{
  id v4 = objc_alloc((Class)NSUUID);
  if (*((char *)a1 + 23) >= 0) {
    id v5 = a1;
  }
  else {
    id v5 = (uint64_t *)*a1;
  }
  int v6 = +[NSString stringWithUTF8String:v5];
  id v7 = [v4 initWithUUIDString:v6];

  v10[0] = 0;
  v10[1] = 0;
  [v7 getUUIDBytes:v10];
  uint64_t v8 = (void *)NEHelperCacheCopySigningIdentifierMapping();
  if (!v8) {
    uint64_t v8 = xpc_null_create();
  }
  if (xpc_get_type(v8) != (xpc_type_t)&_xpc_type_null
    && xpc_get_type(v8) == (xpc_type_t)&_xpc_type_string
    && (string_ptr = (char *)xpc_string_get_string_ptr(v8)) != 0)
  {
    sub_100058DB0(a2, string_ptr);
  }
  else
  {
    sub_100058DB0(a2, "unknown");
  }
  xpc_release(v8);
}

void sub_101035B00(_Unwind_Exception *a1)
{
  xpc_release(v2);

  _Unwind_Resume(a1);
}

void **sub_101035B54(void **a1)
{
  char v3 = a1;
  sub_100A29080(&v3);
  return a1;
}

id sub_101035B8C(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    id v4 = a2;
  }
  else {
    id v4 = (uint64_t *)*a2;
  }
  id v5 = +[NSString stringWithUTF8String:v4];
  int v6 = +[LSBundleRecord bundleRecordWithBundleIdentifier:v5 allowPlaceholder:0 error:0];
  id v7 = [v6 UIBackgroundModes];
  uint64_t v8 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      id v9 = a2;
    }
    else {
      id v9 = (uint64_t *)*a2;
    }
    int v16 = 136315394;
    id v17 = v9;
    __int16 v18 = 2112;
    id v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I UIBackgroundModes: %s: %@", (uint8_t *)&v16, 0x16u);
  }
  if (!v7 || (uint64_t v10 = qword_101B130B8, qword_101B130B0 == qword_101B130B8))
  {
    id v13 = 0;
  }
  else
  {
    uint64_t v11 = qword_101B130B0 + 8;
    do
    {
      id v12 = [v7 containsObject:*(void *)(v11 - 8)];
      id v13 = v12;
      if (v11 == v10) {
        int v14 = 1;
      }
      else {
        int v14 = (int)v12;
      }
      v11 += 8;
    }
    while (v14 != 1);
  }

  return v13;
}

void sub_101035D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101035D30(uint64_t *a1@<X8>)
{
  uint64_t v5 = 0;
  int v6 = &v5;
  uint64_t v7 = 0x4812000000;
  uint64_t v8 = sub_101035F10;
  id v9 = sub_101035F4C;
  uint64_t v10 = "";
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v11 = v12;
  uint64_t v2 = (void *)NEHelperCacheCopyAppUUIDMapping();
  if (v2 || (uint64_t v2 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v2);
      xpc_object_t v3 = v2;
    }
    else
    {
      xpc_object_t v3 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    uint64_t v2 = 0;
  }
  xpc_release(v2);
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    void v4[2] = sub_101035F5C;
    v4[3] = &unk_101A2DE40;
    v4[4] = &v5;
    xpc_array_apply(v3, v4);
  }
  sub_1000C6BDC(a1, (uint64_t)(v6 + 6));
  xpc_release(v3);
  _Block_object_dispose(&v5, 8);
  sub_10005CD2C((uint64_t)&v11, v12[0]);
}

void sub_101035ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char *a21)
{
  _Block_object_dispose(&a14, 8);
  sub_10005CD2C(v21, a21);
  _Unwind_Resume(a1);
}

void *sub_101035F10(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  id v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void sub_101035F4C(uint64_t a1)
{
}

uint64_t sub_101035F5C(int a1, int a2, xpc_object_t object)
{
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_uuid)
  {
    CFUUIDBytes v11 = *(CFUUIDBytes *)xpc_uuid_get_bytes(object);
    CFUUIDRef v8 = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, v11);
    CFStringRef v7 = CFUUIDCreateString(kCFAllocatorDefault, v8);
    long long v9 = 0uLL;
    uint64_t v10 = 0;
    ctu::cf::assign();
    uint64_t v6 = 0;
    *(_OWORD *)std::string __p = 0uLL;
    sub_1000558F4((const void **)&v7);
    sub_10012577C((const void **)&v8);
  }
  return 1;
}

void sub_101036050(_Unwind_Exception *a1, void *a2, uint64_t a3, int a4, __int16 a5, char a6, char a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  CFUUIDRef v8 = va_arg(va1, const void *);
  if (a7 < 0) {
    operator delete(a2);
  }
  sub_1000558F4((const void **)va);
  sub_10012577C((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_10103609C(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t v2 = +[FBSApplicationDataStore applicationsWithAvailableStores];
  uint64_t v3 = (char *)[v2 countByEnumeratingWithState:&v8 objects:v14 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v9;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v9 != v4) {
          objc_enumerationMutation(v2);
        }
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v7 = 0;
        long long v12 = 0uLL;
        uint64_t v13 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = v12;
        uint64_t v7 = v13;
        sub_100046BAC((uint64_t **)a1, __p, (uint64_t)__p);
        if (SHIBYTE(v7) < 0) {
          operator delete(__p[0]);
        }
        ++v5;
      }
      while (v3 != v5);
      uint64_t v3 = (char *)[v2 countByEnumeratingWithState:&v8 objects:v14 count:16];
    }
    while (v3);
  }
}

void sub_1010361E8(_Unwind_Exception *a1)
{
  sub_10005CD2C(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10103624C(uint64_t a1@<X8>)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_100058DB0(&__p, "Process User Visible Apps");
  Registry::createXpcJetsamAssertion();
  if (v18 < 0) {
    operator delete(__p);
  }
  uint64_t v3 = (void *)SBSCopyDisplayIdentifiers();
  int v16 = v3;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v12 objects:v21 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v13;
    do
    {
      for (int i = 0; i != v5; int i = (char *)i + 1)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v4);
        }
        long long v8 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        id v10 = [[CTAppProperties alloc] init:v8];
        if (([v10 isInstalledApp] & 1) != 0
          || [v10 isInternalApp])
        {
          long long v11 = (char *)[v8 UTF8String];
          sub_100495908((uint64_t **)a1, &v11);
        }
      }
      id v5 = [v4 countByEnumeratingWithState:&v12 objects:v21 count:16];
    }
    while (v5);
  }

  sub_100DE52BC(&v16);
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_10103641C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,std::__shared_weak_count *a27)
{
  sub_10005CD2C(v27, *(char **)(v27 + 8));
  sub_100DE52BC(&a19);
  if (a27) {
    sub_10004D2C8(a27);
  }
  _Unwind_Resume(a1);
}

void sub_101036490(uint64_t a1@<X0>, _OWORD *a2@<X1>, void *a3@<X8>)
{
  long long v5 = a2[1];
  v15[0] = *a2;
  v15[1] = v5;
  id v14 = 0;
  uint64_t v6 = +[LSBundleRecord bundleRecordForAuditToken:v15 error:&v14];
  id v7 = v14;
  long long v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9
    || ([v6 bundleIdentifier],
        id v10 = objc_claimAutoreleasedReturnValue(),
        BOOL v11 = v10 == 0,
        v10,
        v11))
  {
    long long v13 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v17 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to get name %@", buf, 0xCu);
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    id v12 = [v6 bundleIdentifier];
    sub_100058DB0(a3, (char *)[v12 UTF8String]);
  }
}

void sub_1010365DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101036600(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  id v7 = +[RBSProcessIdentifier identifierWithPid:a2];
  id v16 = 0;
  long long v8 = +[RBSProcessHandle handleForIdentifier:v7 error:&v16];
  id v9 = v16;

  if (v9
    || !v8
    || ([v8 bundle],
        id v10 = objc_claimAutoreleasedReturnValue(),
        [v10 identifier],
        BOOL v11 = objc_claimAutoreleasedReturnValue(),
        BOOL v12 = v11 == 0,
        v11,
        v10,
        v12))
  {
    long long v15 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v18 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get name %@", buf, 0xCu);
    }
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    long long v13 = [v8 bundle];
    id v14 = [v13 identifier];
    sub_100058DB0(a3, (char *)[v14 UTF8String]);
  }
}

void sub_10103679C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1010367E4(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  std::string __p = 0;
  uint64_t v84 = 0;
  unint64_t v85 = 0;
  id v5 = objc_alloc((Class)LSApplicationRecord);
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = (uint64_t *)*a2;
  }
  id v7 = +[NSString stringWithUTF8String:v6];
  id v8 = [v5 initWithBundleIdentifier:v7 allowPlaceholder:0 error:0];

  id v9 = *(NSObject **)(a1 + 8);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    char v68 = v8;
    if (v10)
    {
      if (*((char *)a2 + 23) >= 0) {
        BOOL v11 = a2;
      }
      else {
        BOOL v11 = (uint64_t *)*a2;
      }
      BOOL v12 = [v8 iTunesMetadata];
      long long v13 = [v8 infoDictionary];
      *(_DWORD *)long long buf = 136315906;
      BOOL v90 = v11;
      __int16 v91 = 2112;
      id v92 = v8;
      __int16 v93 = 2112;
      id v94 = v12;
      __int16 v95 = 2112;
      uint64_t v96 = v13;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I bundleId %s: appRecord: %@, metadata: %@, infodict: %@", buf, 0x2Au);
    }
    unsigned int v64 = [v8 infoDictionary];
    [v64 objectForKey:@"UIBackgroundModes" ofClass:objc_opt_class()];
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    id obj = (id)objc_claimAutoreleasedReturnValue();
    id v14 = [obj countByEnumeratingWithState:&v79 objects:v88 count:16];
    if (v14)
    {
      uint64_t v15 = *(void *)v80;
      do
      {
        for (int i = 0; i != v14; int i = (char *)i + 1)
        {
          if (*(void *)v80 != v15) {
            objc_enumerationMutation(obj);
          }
          id v17 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            id v18 = *(void **)(*((void *)&v79 + 1) + 8 * i);
            if (*((char *)a2 + 23) >= 0) {
              uint64_t v19 = a2;
            }
            else {
              uint64_t v19 = (uint64_t *)*a2;
            }
            *(_DWORD *)long long buf = 136315394;
            BOOL v90 = v19;
            __int16 v91 = 2112;
            id v92 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I UIBackgroundModes: bundleId %s: appRecord: key=%@", buf, 0x16u);
          }
        }
        id v14 = [obj countByEnumeratingWithState:&v79 objects:v88 count:16];
      }
      while (v14);
    }

    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    uint64_t v20 = [v8 appTags];
    id v21 = [v20 countByEnumeratingWithState:&v75 objects:v87 count:16];
    if (v21)
    {
      uint64_t v22 = *(void *)v76;
      do
      {
        for (j = 0; j != v21; j = (char *)j + 1)
        {
          if (*(void *)v76 != v22) {
            objc_enumerationMutation(v20);
          }
          uint64_t v24 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            long long v25 = *(void **)(*((void *)&v75 + 1) + 8 * (void)j);
            if (*((char *)a2 + 23) >= 0) {
              id v26 = a2;
            }
            else {
              id v26 = (uint64_t *)*a2;
            }
            *(_DWORD *)long long buf = 136315394;
            BOOL v90 = v26;
            __int16 v91 = 2112;
            id v92 = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I appTags: bundleId %s: appRecord: value=%@", buf, 0x16u);
          }
        }
        id v21 = [v20 countByEnumeratingWithState:&v75 objects:v87 count:16];
      }
      while (v21);
    }

    uint64_t v27 = [v68 iTunesMetadata];
    uint64_t v66 = [v27 sourceApp];

    if (v66)
    {
      long long v28 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          long long v29 = a2;
        }
        else {
          long long v29 = (uint64_t *)*a2;
        }
        *(_DWORD *)long long buf = 136315394;
        BOOL v90 = v29;
        __int16 v91 = 2112;
        id v92 = v66;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I sourceApp: bundleId %s: appRecord: value=%@", buf, 0x16u);
      }
    }
    long long v30 = [v68 iTunesMetadata];
    uint64_t v67 = [v30 itemName];

    if (v67)
    {
      long long v31 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          long long v32 = a2;
        }
        else {
          long long v32 = (uint64_t *)*a2;
        }
        *(_DWORD *)long long buf = 136315394;
        BOOL v90 = v32;
        __int16 v91 = 2112;
        id v92 = v67;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I itemName: bundleId %s: appRecord: value=%@", buf, 0x16u);
      }
    }
    long long v33 = [v68 iTunesMetadata];
    long long v69 = [v33 storeCohort];

    if (v69)
    {
      long long v34 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) >= 0) {
          long long v35 = a2;
        }
        else {
          long long v35 = (uint64_t *)*a2;
        }
        *(_DWORD *)long long buf = 136315394;
        BOOL v90 = v35;
        __int16 v91 = 2112;
        id v92 = v69;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I storeCohort: bundleId %s: appRecord: value=%@", buf, 0x16u);
      }
    }
    long long v36 = [v68 iTunesMetadata];
    uint64_t v63 = [v36 genre];

    long long v37 = [v68 iTunesMetadata];
    id v62 = [v37 genreIdentifier];

    long long v38 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v39 = a2;
      }
      else {
        uint64_t v39 = (uint64_t *)*a2;
      }
      uint64_t v40 = [v68 iTunesMetadata];
      char v41 = [v40 subgenres];
      *(_DWORD *)long long buf = 136315906;
      BOOL v90 = v39;
      __int16 v91 = 2112;
      id v92 = v63;
      __int16 v93 = 2048;
      id v94 = v62;
      __int16 v95 = 2112;
      uint64_t v96 = v41;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I genre: bundleId %s: appRecord: genre=%@, genreId=%llu, subgenres: %@", buf, 0x2Au);
    }
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    uint64_t v42 = [v68 iTunesMetadata];
    uint64_t v43 = [v42 subgenres];

    id v44 = [v43 countByEnumeratingWithState:&v71 objects:v86 count:16];
    if (v44)
    {
      uint64_t v45 = *(void *)v72;
      do
      {
        for (k = 0; k != v44; k = (char *)k + 1)
        {
          if (*(void *)v72 != v45) {
            objc_enumerationMutation(v43);
          }
          uint64_t v47 = [*(id *)(*((void *)&v71 + 1) + 8 * (void)k) objectForKeyedSubscript:@"genreId"];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            signed int v48 = [v47 intValue];
            if (v48)
            {
              uint64_t v49 = v48;
              uint64_t v50 = v84;
              if ((unint64_t)v84 >= v85)
              {
                long long v52 = __p;
                uint64_t v53 = ((char *)v84 - (unsigned char *)__p) >> 3;
                unint64_t v54 = v53 + 1;
                if ((unint64_t)(v53 + 1) >> 61) {
                  sub_10010562C();
                }
                uint64_t v55 = v85 - (void)__p;
                if ((uint64_t)(v85 - (void)__p) >> 2 > v54) {
                  unint64_t v54 = v55 >> 2;
                }
                if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v56 = v54;
                }
                if (v56)
                {
                  char v57 = (char *)sub_10004EF74((uint64_t)&v85, v56);
                  long long v52 = __p;
                  uint64_t v50 = v84;
                }
                else
                {
                  char v57 = 0;
                }
                char v58 = &v57[8 * v53];
                *(void *)char v58 = v49;
                long long v51 = v58 + 8;
                while (v50 != v52)
                {
                  uint64_t v59 = *--v50;
                  *((void *)v58 - 1) = v59;
                  v58 -= 8;
                }
                std::string __p = v58;
                uint64_t v84 = v51;
                unint64_t v85 = (unint64_t)&v57[8 * v56];
                if (v52) {
                  operator delete(v52);
                }
              }
              else
              {
                *uint64_t v84 = v48;
                long long v51 = v50 + 1;
              }
              uint64_t v84 = v51;
            }
          }
        }
        id v44 = [v43 countByEnumeratingWithState:&v71 objects:v86 count:16];
      }
      while (v44);
    }

    id v8 = v68;
    id v60 = v62;
  }
  else
  {
    if (v10)
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v61 = a2;
      }
      else {
        uint64_t v61 = (uint64_t *)*a2;
      }
      *(_DWORD *)long long buf = 136315138;
      BOOL v90 = v61;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I bundleId %s: appRecord: NULL", buf, 0xCu);
    }
    id v60 = 0;
  }
  *a3 = v60;
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  sub_10010556C(a3 + 1, __p, (uint64_t)v84, ((char *)v84 - (unsigned char *)__p) >> 3);

  if (__p)
  {
    uint64_t v84 = __p;
    operator delete(__p);
  }
}

void sub_1010370A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_101037210(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    id v5 = a1;
  }
  else {
    id v5 = (uint64_t *)*a1;
  }
  uint64_t v6 = +[NSString stringWithUTF8String:v5];
  id v7 = +[LSBundleRecord bundleRecordWithBundleIdentifier:v6 allowPlaceholder:1 error:0];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v8 = [v7 containingBundleRecord];
    id v9 = v8;
    if (v8)
    {
      BOOL v10 = [v8 bundleIdentifier];
      BOOL v11 = v10;
      if (v10 && (BOOL v12 = (char *)[v10 UTF8String]) != 0)
      {
        sub_100058DB0(&v13, v12);
        *(_OWORD *)a2 = v13;
        *(void *)(a2 + 16) = v14;
        *(unsigned char *)(a2 + 24) = 1;
      }
      else
      {
        *(unsigned char *)a2 = 0;
        *(unsigned char *)(a2 + 24) = 0;
      }
    }
    else
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
}

void sub_101037358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101037394(uint64_t a1@<X0>, _OWORD *a2@<X1>, void *a3@<X8>)
{
  long long v7 = a2[1];
  v15[0] = *a2;
  v15[1] = v7;
  id v8 = +[LSBundleRecord bundleRecordForAuditToken:v15 error:0];
  id v9 = v8;
  if (v8)
  {
    BOOL v10 = [v8 SDKVersion];
    BOOL v11 = v10;
    if (v10)
    {
      sub_100058DB0(a3, (char *)[v10 UTF8String]);
    }
    else
    {
      long long v13 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v14 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Missing SDK version", v14, 2u);
      }
      sub_100058DB0(a3, "");
    }
  }
  else
  {
    BOOL v12 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v14 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "No bundle record", v14, 2u);
    }
    sub_100058DB0(a3, "");
  }
}

void sub_1010374E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101037508(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = (uint64_t *)*a2;
  }
  long long v7 = +[NSString stringWithUTF8String:v6];
  id v16 = 0;
  id v8 = [objc_alloc((Class)LSApplicationRecord) initWithBundleIdentifier:v7 allowPlaceholder:1 error:&v16];
  id v9 = v16;
  BOOL v10 = v9;
  if (v8)
  {
    BOOL v11 = [v8 applicationState];
    unsigned int v12 = [v11 isValid];
    if (v12
      && ([v8 applicationState],
          uint64_t v2 = objc_claimAutoreleasedReturnValue(),
          ([v2 isInstalled] & 1) != 0))
    {
      uint64_t v13 = 1;
    }
    else
    {
      uint64_t v13 = (uint64_t)[v8 isPlaceholder];
      if (!v12)
      {
LABEL_10:

        goto LABEL_15;
      }
    }

    goto LABEL_10;
  }
  if ([v9 code] != (id)-10814)
  {
    uint64_t v14 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412546;
      id v18 = v7;
      __int16 v19 = 2112;
      uint64_t v20 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "isInstalledApp (%@) returned error %@", buf, 0x16u);
    }
  }
  uint64_t v13 = 0;
LABEL_15:

  return v13;
}

void sub_1010376B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101037704(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  id v4 = objc_alloc((Class)NSString);
  int v5 = *((char *)a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = (uint64_t *)*a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    uint64_t v7 = a1[1];
  }
  id v8 = objc_msgSend(v4, "initWithBytesNoCopy:length:encoding:freeWhenDone:", v6, v7, 4, 0, context);
  id v9 = [objc_alloc((Class)LSApplicationRecord) initWithBundleIdentifier:v8 allowPlaceholder:0 error:0];
  BOOL v10 = v9;
  if (v9)
  {
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    BOOL v11 = [v9 applicationExtensionRecords];
    id v12 = [v11 countByEnumeratingWithState:&v25 objects:v29 count:16];
    if (v12)
    {
      uint64_t v13 = *(void *)v26;
      do
      {
        for (int i = 0; i != v12; int i = (char *)i + 1)
        {
          if (*(void *)v26 != v13) {
            objc_enumerationMutation(v11);
          }
          uint64_t v15 = *(void **)(*((void *)&v25 + 1) + 8 * i);
          id v16 = [v15 extensionPointRecord];
          id v17 = [v16 name];
          BOOL v18 = v17 == 0;

          if (!v18)
          {
            __int16 v19 = [v15 extensionPointRecord];
            id v20 = [v19 name];
            sub_100058DB0(__p, (char *)[v20 UTF8String]);
            sub_1000EA6A0((uint64_t **)a2, __p, (uint64_t)__p);
            if (v24 < 0) {
              operator delete(__p[0]);
            }
          }
        }
        id v12 = [v11 countByEnumeratingWithState:&v25 objects:v29 count:16];
      }
      while (v12);
    }
  }
}

void sub_10103790C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10005CD2C(v15, *(char **)(v15 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_101037998(uint64_t a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    id v4 = a2;
  }
  else {
    id v4 = (uint64_t *)*a2;
  }
  int v5 = +[NSString stringWithUTF8String:v4];
  id v6 = [objc_alloc((Class)LSApplicationRecord) initWithBundleIdentifier:v5 allowPlaceholder:1 error:0];
  uint64_t v7 = v6;
  if (v6)
  {
    id v8 = [v6 applicationState];
    if ([v8 isValid])
    {
      id v9 = [v7 applicationState];
      if ([v9 isAlwaysAvailable]) {
        uint64_t v10 = 1;
      }
      else {
        uint64_t v10 = [v7 isDeletable] ^ 1;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

void sub_101037A88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_101037ABC(int a1, unint64_t a2, CFTypeRef cf1, uint64_t a4, const __CFDictionary *a5)
{
  if (cf1
    && a2
    && a5
    && (CFEqual(cf1, @"com.apple.LaunchServices.applicationRegistered")
     || CFEqual(cf1, @"com.apple.LaunchServices.applicationUnregistered")))
  {
    sub_10054A558(a2, (uint64_t *)&v25);
    if (v26)
    {
      id v8 = std::__shared_weak_count::lock(v26);
      if (v8) {
        id v9 = v25;
      }
      else {
        id v9 = 0;
      }
      if (v26) {
        std::__shared_weak_count::__release_weak(v26);
      }
      if (!v9) {
        goto LABEL_41;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9);
      BOOL v11 = ServiceMap;
      if (v12 < 0)
      {
        uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      long long v25 = (Registry *)v12;
      id v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v25);
      if (!v16)
      {
        std::mutex::unlock(v11);
        goto LABEL_41;
      }
      uint64_t v18 = v16[3];
      id v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        if (!v18)
        {
LABEL_40:
          sub_10004D2C8(v17);
LABEL_41:
          if (v8) {
            sub_10004D2C8(v8);
          }
          return;
        }
      }
      else
      {
        std::mutex::unlock(v11);
        if (!v18) {
          goto LABEL_41;
        }
      }
      Value = CFDictionaryGetValue(a5, @"bundleIDs");
      id v20 = Value;
      if (Value && (CFTypeID v21 = CFGetTypeID(Value), v21 == CFArrayGetTypeID()))
      {
        long long v31 = v20;
        CFRetain(v20);
      }
      else
      {
        id v20 = 0;
        long long v31 = 0;
      }
      if (v20) {
        uint64_t v22 = sub_100083F10;
      }
      else {
        uint64_t v22 = 0;
      }
      if (v22)
      {
        uint64_t v23 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
        char v24 = dispatch_queue_create("SBServicesAppRegCb", v23);
        long long v25 = v9;
        long long v26 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v27 = v18;
        long long v28 = v17;
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        long long v29 = v20;
        if (v20) {
          CFRetain(v20);
        }
        long long v30 = v24;
        if (v24) {
          dispatch_retain(v24);
        }
        operator new();
      }
      sub_100044D00(&v31);
      if (!v17) {
        goto LABEL_41;
      }
      goto LABEL_40;
    }
  }
}

void sub_101037DE4(_Unwind_Exception *exception_object)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101037E14(void *a1)
{
  *a1 = off_101A80070;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  SBServicesInterface::~SBServicesInterface((SBServicesInterface *)a1);
}

void sub_101037E84(void *a1)
{
  *a1 = off_101A80070;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  SBServicesInterface::~SBServicesInterface((SBServicesInterface *)a1);

  operator delete();
}

uint64_t *sub_101037F08(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (v2) {
      dispatch_release(v2);
    }
    sub_100044D00((const void **)(v1 + 32));
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
    if (v3) {
      sub_10004D2C8(v3);
    }
    id v4 = *(std::__shared_weak_count **)(v1 + 8);
    if (v4) {
      sub_10004D2C8(v4);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_101037F7C(uint64_t a1)
{
  uint64_t v21 = a1;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  uint64_t v33 = 0;
  v34[0] = 0;
  v34[1] = 0;
  sub_100058DB0(&v40, "com.apple.MobileSMS");
  sub_100058DB0(v42, "com.apple.findmy");
  sub_1000EA30C((uint64_t)&v33, (void **)&v40, 2);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v42[i + 2]) < 0) {
      operator delete((void *)v42[i]);
    }
  }
  long long v31 = 0;
  uint64_t v32 = 0;
  long long v30 = &v31;
  if (Count >= 1)
  {
    for (CFIndex j = 0; j != Count; ++j)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v29 = 0;
      CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), j);
      long long v40 = 0uLL;
      uint64_t v41 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v40;
      uint64_t v29 = v41;
      if (v34 != (char **)sub_100046F68((uint64_t)&v33, __p))
      {
        char v5 = (*(uint64_t (**)(void, void **))(**(void **)(a1 + 16) + 128))(*(void *)(a1 + 16), __p);
        *(void *)&long long v40 = __p;
        *((unsigned char *)sub_1000ED870((uint64_t **)&v30, __p, (uint64_t)&unk_10144E20E, (long long **)&v40) + 56) = v5;
      }
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
    }
    if (v32)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      sub_100058DB0(__p, "SBServicesAppRegCb");
      id v6 = *(NSObject **)(a1 + 40);
      dispatch_object_t v25 = v6;
      if (v6) {
        dispatch_retain(v6);
      }
      dispatch_object_t object = 0;
      ctu::RestModule::RestModule();
      if (v25) {
        dispatch_release(v25);
      }
      if (SHIBYTE(v29) < 0) {
        operator delete(__p[0]);
      }
      Registry::createRestModuleOneTimeUseConnection(&v22, *(Registry **)a1);
      ctu::RestModule::connect();
      if (v23) {
        sub_10004D2C8(v23);
      }
      xpc_object_t v7 = xpc_array_create(0, 0);
      if (v7 || (xpc_object_t v7 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v7);
          xpc_object_t v8 = v7;
        }
        else
        {
          xpc_object_t v8 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
      }
      xpc_release(v7);
      id v9 = (uint64_t *)v30;
      if (v30 != &v31)
      {
        do
        {
          xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v11 = v10;
          if (v10)
          {
            xpc_object_t v39 = v10;
          }
          else
          {
            xpc_object_t v11 = xpc_null_create();
            xpc_object_t v39 = v11;
            if (!v11)
            {
              xpc_object_t v12 = xpc_null_create();
              xpc_object_t v11 = 0;
              goto LABEL_35;
            }
          }
          if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_object_t v12 = xpc_null_create();
LABEL_35:
            xpc_object_t v39 = v12;
            goto LABEL_36;
          }
          xpc_retain(v11);
LABEL_36:
          xpc_release(v11);
          if (*((char *)v9 + 55) >= 0) {
            uint64_t v13 = (const char *)(v9 + 4);
          }
          else {
            uint64_t v13 = (const char *)v9[4];
          }
          xpc_object_t v37 = xpc_string_create(v13);
          if (!v37) {
            xpc_object_t v37 = xpc_null_create();
          }
          *(void *)&long long v40 = &v39;
          *((void *)&v40 + 1) = "first";
          sub_100035E70((uint64_t)&v40, &v37, &v38);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          xpc_release(v37);
          xpc_object_t v37 = 0;
          xpc_object_t v35 = xpc_BOOL_create(*((unsigned char *)v9 + 56));
          if (!v35) {
            xpc_object_t v35 = xpc_null_create();
          }
          *(void *)&long long v40 = &v39;
          *((void *)&v40 + 1) = "second";
          sub_100035E70((uint64_t)&v40, &v35, &v36);
          xpc_release(v36);
          xpc_object_t v36 = 0;
          xpc_release(v35);
          xpc_object_t v35 = 0;
          xpc_object_t v14 = v39;
          if (v39) {
            xpc_retain(v39);
          }
          else {
            xpc_object_t v14 = xpc_null_create();
          }
          xpc_release(v39);
          xpc_array_append_value(v8, v14);
          xpc_release(v14);
          unsigned int v15 = (char *)v9[1];
          if (v15)
          {
            do
            {
              id v16 = (char **)v15;
              unsigned int v15 = *(char **)v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              id v16 = (char **)v9[2];
              BOOL v17 = *v16 == (char *)v9;
              id v9 = (uint64_t *)v16;
            }
            while (!v17);
          }
          id v9 = (uint64_t *)v16;
        }
        while (v16 != &v31);
      }
      if (v8)
      {
        xpc_retain(v8);
        xpc_object_t v18 = v8;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
      }
      xpc_release(v8);
      sub_100058DB0(&v40, "/cc/events/installed_apps_changed");
      xpc_object_t v39 = v18;
      xpc_object_t v19 = xpc_null_create();
      ctu::RestModule::sendEvent();
      xpc_release(v39);
      xpc_object_t v39 = 0;
      if (SHIBYTE(v41) < 0) {
        operator delete((void *)v40);
      }
      xpc_release(v19);
      if (v27) {
        sub_10004D2C8(v27);
      }
    }
  }
  sub_10005CD2C((uint64_t)&v30, v31);
  sub_10005CD2C((uint64_t)&v33, v34[0]);
  return sub_101037F08(&v21);
}

void sub_10103847C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, dispatch_object_t object, dispatch_object_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103863C()
{
  v4[0] = @"voip";
  v4[1] = @"network-authentication";
  void v4[2] = @"fetch";
  v4[3] = @"remote-notification";
  qword_101B130B8 = 0;
  qword_101B130C0 = 0;
  qword_101B130B0 = 0;
  uint64_t v1 = (char *)operator new(0x20uLL);
  uint64_t v2 = 0;
  qword_101B130B0 = (uint64_t)v1;
  qword_101B130B8 = (uint64_t)v1;
  qword_101B130C0 = (uint64_t)(v1 + 32);
  do
  {
    *(void *)&v1[v2 * 8] = (id)v4[v2];
    ++v2;
  }
  while (v2 != 4);
  qword_101B130B8 = (uint64_t)(v1 + 32);
  for (uint64_t i = 3; i != -1; --i)

  __cxa_atexit((void (*)(void *))sub_101035B54, &qword_101B130B0, (void *)&_mh_execute_header);
}

void sub_101038764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  a11 = 0;
  sub_100A29080(&a10);
  for (uint64_t i = 24; i != -8; i -= 8)

  _Unwind_Resume(a1);
}

void stewie::ConnectionAssistantTargetDataSource::create(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, os_log_t *a4@<X4>, void *a5@<X8>)
{
  if (!*a1)
  {
    id v6 = *a4;
    if (!os_log_type_enabled(*a4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v11 = 0;
    xpc_object_t v7 = "targetInstantAtLocationCacheFactory is required";
    xpc_object_t v8 = (uint8_t *)&v11;
LABEL_11:
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v7, v8, 2u);
    goto LABEL_12;
  }
  if (!*a2)
  {
    id v6 = *a4;
    if (!os_log_type_enabled(*a4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v10 = 0;
    xpc_object_t v7 = "serviceAtLocationFactory is required";
    xpc_object_t v8 = (uint8_t *)&v10;
    goto LABEL_11;
  }
  if (*(void *)(a3 + 16)) {
    operator new();
  }
  id v6 = *a4;
  if (os_log_type_enabled(*a4, OS_LOG_TYPE_ERROR))
  {
    __int16 v9 = 0;
    xpc_object_t v7 = "anchorStorage is required";
    xpc_object_t v8 = (uint8_t *)&v9;
    goto LABEL_11;
  }
LABEL_12:
  *a5 = 0;
}

void sub_101038948()
{
}

void stewie::ConnectionAssistantTargetDataSource::~ConnectionAssistantTargetDataSource(stewie::ConnectionAssistantTargetDataSource *this)
{
  if (*((unsigned char *)this + 304))
  {
    uint64_t v2 = (void *)*((void *)this + 35);
    if (v2)
    {
      *((void *)this + 36) = v2;
      operator delete(v2);
    }
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v3) {
    sub_10004D2C8(v3);
  }
  id v4 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v4) {
    sub_10004D2C8(v4);
  }
  char v5 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v5) {
    sub_10004D2C8(v5);
  }
  id v6 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v6) {
    sub_10004D2C8(v6);
  }
  xpc_object_t v7 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v7) {
    sub_10004D2C8(v7);
  }
  xpc_object_t v8 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v8) {
    sub_10004D2C8(v8);
  }
  __int16 v9 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v9) {
    sub_10004D2C8(v9);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

void sub_101038A0C(void *a1, uint64_t a2, long long *a3, int a4)
{
  uint64_t v42 = 0;
  long long v39 = *a3;
  uint64_t v40 = *((void *)a3 + 2);
  uint64_t v41 = *(void *)(a2 + 40);
  LODWORD(v42) = a4;
  uint64_t v38 = 0;
  long long v35 = *a3;
  uint64_t v36 = *((void *)a3 + 2);
  xpc_object_t v7 = (void *)(a2 + 112);
  uint64_t v6 = *(void *)(a2 + 112);
  uint64_t v37 = *(void *)(a2 + 48);
  LODWORD(v38) = a4;
  if (v6)
  {
    if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)v6 + 16))(v6, &v35))
    {
      uint64_t v8 = *(void *)(a2 + 128);
      if (v8)
      {
        if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)v8 + 16))(v8, &v39))
        {
          uint64_t v9 = *(void *)(a2 + 136);
          *a1 = *(void *)(a2 + 128);
          a1[1] = v9;
          if (v9) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
          }
          return;
        }
      }
    }
  }
  __int16 v10 = *(NSObject **)a2;
  if (os_log_type_enabled(*(os_log_t *)a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Resetting ServiceAtLocation", buf, 2u);
  }
  sub_101038E44((uint64_t)v7);
  uint64_t v11 = *(void *)(a2 + 56);
  xpc_object_t v12 = *(std::__shared_weak_count **)(a2 + 16);
  uint64_t v32 = *(void *)(a2 + 8);
  uint64_t v33 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a2 + 96);
  uint64_t v30 = *(void *)(a2 + 88);
  long long v31 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v11 + 16))(buf);
  long long v14 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  unsigned int v15 = *(std::__shared_weak_count **)(a2 + 120);
  *(_OWORD *)(a2 + 112) = v14;
  if (v15)
  {
    sub_10004D2C8(v15);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (*v7)
  {
    memset(buf, 0, sizeof(buf));
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a2 + 8) + 16))(buf);
    if (*(void *)buf)
    {
      uint64_t v16 = *(void *)(a2 + 24);
      long long v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
      }
      BOOL v17 = *(std::__shared_weak_count **)(a2 + 120);
      uint64_t v27 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v18 = *(std::__shared_weak_count **)(a2 + 80);
      uint64_t v26 = v18;
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint8_t *__return_ptr))(*(void *)v16 + 16))(v29);
      long long v19 = *(_OWORD *)v29;
      memset(v29, 0, sizeof(v29));
      id v20 = *(std::__shared_weak_count **)(a2 + 136);
      *(_OWORD *)(a2 + 128) = v19;
      if (v20)
      {
        sub_10004D2C8(v20);
        if (*(void *)&v29[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v29[8]);
        }
      }
      if (v26) {
        sub_10004D2C8(v26);
      }
      if (v27) {
        sub_10004D2C8(v27);
      }
      if (v28) {
        sub_10004D2C8(v28);
      }
      uint64_t v21 = *(void *)(a2 + 128);
      if (v21)
      {
        uint64_t v22 = *(void *)(a2 + 136);
        *a1 = v21;
        a1[1] = v22;
        if (v22) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
        }
        goto LABEL_47;
      }
      char v24 = *(NSObject **)a2;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
LABEL_46:
        *a1 = 0;
        a1[1] = 0;
LABEL_47:
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        return;
      }
      *(_WORD *)uint64_t v29 = 0;
      dispatch_object_t v25 = "Failed to create ServiceAtLocation";
    }
    else
    {
      char v24 = *(NSObject **)a2;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        goto LABEL_46;
      }
      *(_WORD *)uint64_t v29 = 0;
      dispatch_object_t v25 = "Failed to create targetInstantAtLocationCache";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v25, v29, 2u);
    goto LABEL_46;
  }
  uint64_t v23 = *(NSObject **)a2;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Failed to create anchorage for location", buf, 2u);
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_101038DEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_101038E44(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (v3) {
    sub_10004D2C8(v3);
  }
  *(void *)(a1 + 32) = 0;
  if (*(unsigned char *)(a1 + 72)) {
    *(unsigned char *)(a1 + 72) = 0;
  }
  *(void *)(a1 + 80) = 0;
  if (*(unsigned char *)(a1 + 128)) {
    *(unsigned char *)(a1 + 128) = 0;
  }
  *(void *)(a1 + 136) = 0;
  if (*(unsigned char *)(a1 + 192))
  {
    id v4 = *(void **)(a1 + 168);
    if (v4)
    {
      *(void *)(a1 + 176) = v4;
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 192) = 0;
  }
}

void stewie::ConnectionAssistantTargetDataSource::updateGPSData(uint64_t a1, long long *a2, int a3, unint64_t *a4)
{
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  sub_101038A0C(&v60, a1, a2, a3);
  uint64_t v6 = v60;
  if (v60)
  {
    unint64_t v7 = *(void *)(a1 + 144);
    unint64_t v8 = *a4;
    if (v7 <= *a4 && v8 < v7 + 1000000000)
    {
LABEL_53:
      unint64_t v41 = *(void *)(a1 + 192);
      if (v41 <= v8 + 100000000 && v41 + 600000000000 > v8)
      {
        if (!*(unsigned char *)(a1 + 240)) {
          goto LABEL_78;
        }
        if (!*(void *)(a1 + 200)) {
          goto LABEL_78;
        }
        if (!*(void *)(a1 + 208)) {
          goto LABEL_78;
        }
        unint64_t v43 = *(void *)(a1 + 224);
        if (!v43) {
          goto LABEL_78;
        }
        unint64_t v44 = *(void *)(a1 + 232);
        if (v44 >= v8 || v43 >= v8 || !v44) {
          goto LABEL_78;
        }
        uint64_t v45 = *(NSObject **)a1;
        if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Service window: forcing update", buf, 2u);
          unint64_t v8 = *a4;
        }
      }
      *(void *)(a1 + 192) = v8;
      uint64_t v62 = *a4 + 7200000000000;
      if (*(unsigned char *)(a1 + 240))
      {
        *(_OWORD *)char v68 = *(_OWORD *)(a1 + 200);
        v68[16] = *(unsigned char *)(a1 + 216);
        long long v69 = *(_OWORD *)(a1 + 224);
      }
      else
      {
        memset(v68, 0, 17);
        long long v69 = 0uLL;
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t, unint64_t *, uint64_t *, unsigned char *))(*(void *)v6 + 40))(buf, v6, a4, &v62, v68);
      unint64_t v46 = *(void *)buf;
      unint64_t v47 = *(void *)&buf[8];
      *(void *)(a1 + 200) = *(void *)buf;
      *(void *)(a1 + 208) = v47;
      int v48 = buf[16];
      *(unsigned char *)(a1 + 216) = buf[16];
      uint64_t v49 = v64;
      unint64_t v50 = *(void *)v65;
      *(void *)(a1 + 224) = v64;
      *(void *)(a1 + 232) = v50;
      *(unsigned char *)(a1 + 240) = 1;
      os_log_t v51 = *(os_log_t *)a1;
      BOOL v52 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
      if (v46 && v47)
      {
        if (v52)
        {
          uint64_t v53 = "in";
          if (!v48) {
            uint64_t v53 = "out";
          }
          *(_DWORD *)long long buf = 134219010;
          *(void *)&uint8_t buf[4] = v46 / 0x3B9ACA00;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v47 / 0x3B9ACA00;
          *(_WORD *)&unsigned char buf[22] = 2080;
          unsigned int v64 = v53;
          *(_WORD *)uint64_t v65 = 2048;
          *(void *)&v65[2] = v50 / 0x3B9ACA00;
          __int16 v66 = 2048;
          unint64_t v67 = (unint64_t)v49 / 0x3B9ACA00;
          unint64_t v54 = "#I Service window: [%llu, %llu] starts %s, aos: %llu, los: %llu";
          uint64_t v55 = v51;
          uint32_t v56 = 52;
          goto LABEL_77;
        }
      }
      else if (v52)
      {
        *(_WORD *)long long buf = 0;
        unint64_t v54 = "#I Service window: invalid";
        uint64_t v55 = v51;
        uint32_t v56 = 2;
LABEL_77:
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, v54, buf, v56);
      }
LABEL_78:
      if (*(unsigned char *)(a1 + 304))
      {
        if (*(void *)(a1 + 256))
        {
          if (*(void *)(a1 + 264))
          {
            unint64_t v57 = *(void *)(a1 + 272);
            if (v57)
            {
              if (v57 < *a4)
              {
                char v58 = *(NSObject **)a1;
                if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
                  || (*(_WORD *)long long buf = 0,
                      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Service plot expired, resetting", buf, 2u), *(unsigned char *)(a1 + 304)))
                {
                  uint64_t v59 = *(void **)(a1 + 280);
                  if (v59)
                  {
                    *(void *)(a1 + 288) = v59;
                    operator delete(v59);
                  }
                  *(unsigned char *)(a1 + 304) = 0;
                }
              }
            }
          }
        }
      }
      goto LABEL_88;
    }
    *(void *)(a1 + 144) = v8;
    memset(buf, 0, sizeof(buf));
    if (!*(unsigned char *)(a1 + 108)) {
      goto LABEL_45;
    }
    if (!*(_DWORD *)(a1 + 104))
    {
      os_log_t v18 = *(os_log_t *)a1;
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_45;
      }
      *(_DWORD *)char v68 = 67109120;
      *(_DWORD *)&v68[4] = 0;
      long long v19 = "#I Current LLC target is %d, optimal target is null";
      id v20 = v18;
      goto LABEL_24;
    }
    uint64_t v10 = (*(uint64_t (**)(uint64_t, unint64_t *, void, uint8_t *))(*(void *)v6 + 32))(v6, a4, *(void *)(a1 + 104), buf);
    unsigned int v11 = v10;
    int v12 = *(unsigned __int8 *)(a1 + 108);
    if (BYTE4(v10)) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      if ((BYTE4(v10) != 0) == (v12 != 0))
      {
        if (!BYTE4(v10)) {
          goto LABEL_45;
        }
        goto LABEL_39;
      }
      long long v14 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        if (!v12) {
          goto LABEL_95;
        }
        int v15 = *(_DWORD *)(a1 + 104);
LABEL_27:
        *(_DWORD *)char v68 = 67109120;
        *(_DWORD *)&v68[4] = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Current LLC target %d is not in service", v68, 8u);
      }
    }
    else
    {
      int v15 = *(_DWORD *)(a1 + 104);
      if (v15 == v10) {
        goto LABEL_39;
      }
      long long v14 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
    }
    if (!*(unsigned char *)(a1 + 108)) {
      goto LABEL_95;
    }
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    uint64_t v21 = (stewie::TargetInstant *)(*(void *(**)(unsigned char *__return_ptr, uint64_t, unint64_t *, void))(*(void *)v6 + 24))(v68, v6, a4, v11);
    *(_OWORD *)long long buf = *(_OWORD *)v68;
    *(void *)&uint8_t buf[16] = *(void *)&v68[16];
    uint64_t v22 = (double *)stewie::TargetInstant::invalidInstance(v21);
    if (*(double *)buf == *v22 && *(double *)&buf[8] == v22[1])
    {
      double v23 = *(double *)&buf[16];
      double v24 = v22[2];
      dispatch_object_t v25 = *(NSObject **)a1;
      BOOL v26 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
      if (v23 == v24)
      {
        if (v26)
        {
          if (*(unsigned char *)(a1 + 108))
          {
            int v27 = *(_DWORD *)(a1 + 104);
            *(_DWORD *)char v68 = 67109120;
            *(_DWORD *)&v68[4] = v27;
            long long v19 = "#I Failed to get instant for LLC target %d, resetting optimal target";
            id v20 = v25;
LABEL_24:
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, v68, 8u);
            goto LABEL_45;
          }
LABEL_95:
          sub_10016C840();
        }
LABEL_45:
        if (*(unsigned char *)(a1 + 184))
        {
          uint64_t v37 = *(NSObject **)a1;
          if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
            || (unint64_t v38 = *a4 / 0x3B9ACA00,
                *(_DWORD *)char v68 = 134217984,
                *(void *)&v68[4] = v38,
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Optimal target id: null at %llu", v68, 0xCu), *(unsigned char *)(a1 + 184)))
          {
            *(unsigned char *)(a1 + 184) = 0;
          }
        }
        if (!*(unsigned char *)(a1 + 108)) {
          goto LABEL_52;
        }
        int v39 = *(_DWORD *)(a1 + 104);
        if (!v39) {
          goto LABEL_52;
        }
        os_log_t v40 = *(os_log_t *)a1;
        if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
          goto LABEL_52;
        }
        *(_DWORD *)char v68 = 67109120;
        *(_DWORD *)&v68[4] = v39;
        long long v34 = "LLC target: %d does not match optimal target: null";
        long long v35 = v40;
        uint32_t v36 = 8;
LABEL_94:
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, v68, v36);
LABEL_52:
        unint64_t v8 = *a4;
        goto LABEL_53;
      }
      if (!v26)
      {
LABEL_39:
        uint64_t v29 = *(void *)&buf[16];
        *(_DWORD *)(a1 + 152) = v11;
        *(_OWORD *)(a1 + 160) = *(_OWORD *)buf;
        *(void *)(a1 + 176) = v29;
        *(unsigned char *)(a1 + 184) = 1;
        uint64_t v30 = *(NSObject **)a1;
        if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v31 = *a4 / 0x3B9ACA00;
          *(_DWORD *)char v68 = 67109376;
          *(_DWORD *)&v68[4] = v11;
          *(_WORD *)&v68[8] = 2048;
          *(void *)&v68[10] = v31;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Optimal target id: %d at %llu", v68, 0x12u);
        }
        if (!*(unsigned char *)(a1 + 108)) {
          goto LABEL_52;
        }
        int v32 = *(_DWORD *)(a1 + 104);
        if (v32 == v11) {
          goto LABEL_52;
        }
        os_log_t v33 = *(os_log_t *)a1;
        if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
          goto LABEL_52;
        }
        *(_DWORD *)char v68 = 67109376;
        *(_DWORD *)&v68[4] = v32;
        *(_WORD *)&v68[8] = 1024;
        *(_DWORD *)&v68[10] = v11;
        long long v34 = "LLC target: %d does not match optimal target: %d";
        long long v35 = v33;
        uint32_t v36 = 14;
        goto LABEL_94;
      }
    }
    else
    {
      dispatch_object_t v25 = *(NSObject **)a1;
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_39;
      }
    }
    if (!*(unsigned char *)(a1 + 108)) {
      goto LABEL_95;
    }
    int v28 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)char v68 = 67109376;
    *(_DWORD *)&v68[4] = v28;
    *(_WORD *)&v68[8] = 2048;
    *(double *)&v68[10] = *(double *)&buf[8] * 180.0 / 3.14159265;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Tracking current LLC target %d, service: %.2f", v68, 0x12u);
    goto LABEL_39;
  }
  uint64_t v16 = a1 + 112;
  if (*(void *)(a1 + 112))
  {
    BOOL v17 = *(NSObject **)a1;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I updateGPSData: service not available, resetting cache", buf, 2u);
    }
  }
  sub_101038E44(v16);
LABEL_88:
  if (v61) {
    sub_10004D2C8(v61);
  }
}

void sub_1010396CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void stewie::ConnectionAssistantTargetDataSource::updateProvisioningData(uint64_t a1, uint64_t *a2)
{
  id v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    int v11 = 134218240;
    uint64_t v12 = v5;
    __int16 v13 = 2048;
    uint64_t v14 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Updating target data source with threshold: %f, anchor threshold: %f", (uint8_t *)&v11, 0x16u);
  }
  if (a2[2])
  {
    *(_OWORD *)(a1 + 40) = *(_OWORD *)a2;
    long long v7 = *((_OWORD *)a2 + 1);
    a2[2] = 0;
    a2[3] = 0;
    unint64_t v8 = *(std::__shared_weak_count **)(a1 + 64);
    *(_OWORD *)(a1 + 56) = v7;
    if (v8) {
      sub_10004D2C8(v8);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 120);
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)a1;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v11) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "anchorStorage is required", (uint8_t *)&v11, 2u);
    }
  }
}

void stewie::ConnectionAssistantTargetDataSource::updateServiceSchedules(uint64_t a1, long long *a2)
{
  id v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Updating service schedules", v12, 2u);
  }
  long long v5 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 80);
  *(_OWORD *)(a1 + 72) = v5;
  if (v6) {
    sub_10004D2C8(v6);
  }
  long long v7 = a2[1];
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v7;
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (*(unsigned char *)(a1 + 304))
  {
    int v11 = *(void **)(a1 + 280);
    if (v11)
    {
      *(void *)(a1 + 288) = v11;
      operator delete(v11);
    }
    *(unsigned char *)(a1 + 304) = 0;
  }
}

uint64_t stewie::ConnectionAssistantTargetDataSource::updateLLCTarget(uint64_t a1, uint64_t a2, long long *a3, int a4, void *a5)
{
  uint64_t v10 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v11 = *a5 / 0x3B9ACA00uLL;
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    *(_WORD *)&uint8_t buf[8] = 2048;
    *(void *)&buf[10] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I LLC target id: %d at %llu", buf, 0x12u);
  }
  if (*(unsigned char *)(a1 + 108)) {
    uint64_t v12 = *(_DWORD *)(a1 + 104) != a2;
  }
  else {
    uint64_t v12 = 1;
  }
  *(_DWORD *)(a1 + 104) = a2;
  *(unsigned char *)(a1 + 108) = 1;
  if (a2)
  {
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    sub_101038A0C(&v29, a1, a3, a4);
    uint64_t v13 = v29;
    if (!v29)
    {
      dispatch_object_t v25 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Optimal target id: null, service not available", buf, 2u);
      }
      if (*(unsigned char *)(a1 + 184)) {
        *(unsigned char *)(a1 + 184) = 0;
      }
      goto LABEL_48;
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v14 = (*(uint64_t (**)(uint64_t, void *, unint64_t, uint8_t *))(*(void *)v29 + 32))(v29, a5, a2 | (unint64_t)&_mh_execute_header, buf);
    if ((v14 & 0xFF00000000) != 0 && v14 == a2) {
      goto LABEL_35;
    }
    uint64_t v16 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unint64_t v31 = 67109120;
      *(_DWORD *)&_OWORD v31[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I LLC target %d is not in service", v31, 8u);
    }
    BOOL v17 = (stewie::TargetInstant *)(*(void *(**)(unsigned char *__return_ptr, uint64_t, void *, uint64_t))(*(void *)v13 + 24))(v31, v13, a5, a2);
    *(_OWORD *)long long buf = *(_OWORD *)v31;
    *(void *)&uint8_t buf[16] = *(void *)&v31[16];
    os_log_t v18 = (double *)stewie::TargetInstant::invalidInstance(v17);
    if (*(double *)buf == *v18 && (double v19 = *(double *)&buf[8], *(double *)&buf[8] == v18[1]))
    {
      double v20 = *(double *)&buf[16];
      double v21 = v18[2];
      uint64_t v22 = *(NSObject **)a1;
      BOOL v23 = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT);
      if (v20 == v21)
      {
        if (v23)
        {
          *(_DWORD *)unint64_t v31 = 67109120;
          *(_DWORD *)&_OWORD v31[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Failed to get instant for LLC target %d, ignoring the update, resetting the target", v31, 8u);
        }
        if (*(unsigned char *)(a1 + 108)) {
          uint64_t v12 = 1;
        }
        else {
          uint64_t v12 = v12;
        }
        if (*(unsigned char *)(a1 + 108)) {
          *(unsigned char *)(a1 + 108) = 0;
        }
        goto LABEL_48;
      }
      if (!v23)
      {
LABEL_35:
        if (v12)
        {
          long long v26 = *(_OWORD *)buf;
          uint64_t v12 = 1;
          uint64_t v27 = *(void *)&buf[16];
          if (!*(unsigned char *)(a1 + 184)) {
            goto LABEL_47;
          }
        }
        else
        {
          if (!*(unsigned char *)(a1 + 184))
          {
            long long v26 = *(_OWORD *)buf;
            uint64_t v12 = 1;
            uint64_t v27 = *(void *)&buf[16];
            goto LABEL_47;
          }
          uint64_t v12 = *(_DWORD *)(a1 + 152) != a2
             || *(double *)(a1 + 160) != *(double *)buf
             || *(double *)(a1 + 168) != *(double *)&buf[8]
             || *(double *)(a1 + 176) != *(double *)&buf[16];
          long long v26 = *(_OWORD *)buf;
          uint64_t v27 = *(void *)&buf[16];
        }
        *(unsigned char *)(a1 + 184) = 0;
LABEL_47:
        *(_DWORD *)(a1 + 152) = a2;
        *(_OWORD *)(a1 + 160) = v26;
        *(void *)(a1 + 176) = v27;
        *(unsigned char *)(a1 + 184) = 1;
LABEL_48:
        if (v30) {
          sub_10004D2C8(v30);
        }
        return v12;
      }
    }
    else
    {
      uint64_t v22 = *(NSObject **)a1;
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
      double v19 = *(double *)&buf[8];
    }
    *(_DWORD *)unint64_t v31 = 67109376;
    *(_DWORD *)&_OWORD v31[4] = a2;
    *(_WORD *)&v31[8] = 2048;
    *(double *)&v31[10] = v19 * 180.0 / 3.14159265;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Tracking LLC target %d, service: %.2f", v31, 0x12u);
    goto LABEL_35;
  }
  double v24 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Optimal target id: null, LLC target %d", buf, 8u);
  }
  if (*(unsigned char *)(a1 + 184)) {
    *(unsigned char *)(a1 + 184) = 0;
  }
  return v12;
}

void sub_101039D74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void stewie::ConnectionAssistantTargetDataSource::updateCachedServicePlot(uint64_t a1, long long *a2, int a3, unint64_t *a4)
{
  uint64_t v23 = 0;
  double v24 = 0;
  sub_101038A0C(&v23, a1, a2, a3);
  uint64_t v6 = v23;
  if (v23)
  {
    unint64_t v7 = *a4;
    unint64_t v8 = *(void *)(a1 + 248);
    if (v8 > *a4 + 100000000 || v8 + 600000000000 <= v7)
    {
      *(void *)(a1 + 248) = v7;
      uint64_t v28 = *a4 + 3600000000000;
      if (*(unsigned char *)(a1 + 304))
      {
        long long v25 = *(_OWORD *)(a1 + 256);
        uint64_t v10 = *(void *)(a1 + 280);
        v26[0] = *(void **)(a1 + 272);
        v26[1] = 0;
        long long v27 = 0uLL;
        sub_10135C3D4((char *)&v26[1], v10, *(void *)(a1 + 288), 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 288) - v10) >> 3));
      }
      else
      {
        *(_OWORD *)long long v26 = 0u;
        long long v27 = 0u;
        long long v25 = 0u;
      }
      (*(void (**)(unsigned char *__return_ptr, uint64_t, unint64_t *, uint64_t *, long long *))(*(void *)v6 + 48))(buf, v6, a4, &v28, &v25);
      if (*(unsigned char *)(a1 + 304))
      {
        uint64_t v13 = *(void **)(a1 + 280);
        if (v13)
        {
          *(void *)(a1 + 288) = v13;
          operator delete(v13);
        }
        *(unsigned char *)(a1 + 304) = 0;
      }
      *(_OWORD *)(a1 + 256) = *(_OWORD *)buf;
      uint64_t v14 = __p;
      *(void *)(a1 + 272) = *(void *)&buf[16];
      *(void *)(a1 + 280) = 0;
      *(void *)(a1 + 288) = 0;
      *(void *)(a1 + 296) = 0;
      sub_10135C3D4((char *)(a1 + 280), (uint64_t)v14, (uint64_t)v31, 0xCCCCCCCCCCCCCCCDLL * ((v31 - v14) >> 3));
      *(unsigned char *)(a1 + 304) = 1;
      if (__p)
      {
        unint64_t v31 = __p;
        operator delete(__p);
      }
      if (v26[1])
      {
        *(void **)&long long v27 = v26[1];
        operator delete(v26[1]);
      }
      if (!*(void *)(a1 + 256) || (unint64_t v15 = *(void *)(a1 + 264)) == 0 || (v16 = *(void *)(a1 + 272)) == 0)
      {
        uint64_t v22 = *(NSObject **)a1;
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_32;
        }
        *(_WORD *)long long buf = 0;
        double v19 = "#I Service plot: invalid";
        double v20 = v22;
        uint32_t v21 = 2;
        goto LABEL_31;
      }
      if (!*(unsigned char *)(a1 + 304)) {
        sub_10016C840();
      }
      BOOL v17 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = (uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 3;
        *(_DWORD *)long long buf = 134218496;
        *(void *)&uint8_t buf[4] = v15 / 0x3B9ACA00;
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v16 / 0x3B9ACA00;
        *(_WORD *)&unsigned char buf[22] = 2048;
        std::string __p = (void *)(0xCCCCCCCCCCCCCCCDLL * v18);
        double v19 = "#I Service plot: [%llu, %llu] %zu readings";
        double v20 = v17;
        uint32_t v21 = 32;
LABEL_31:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
      }
    }
  }
  else
  {
    unint64_t v11 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Service plot: null, service not available", buf, 2u);
    }
    if (*(unsigned char *)(a1 + 304))
    {
      uint64_t v12 = *(void **)(a1 + 280);
      if (v12)
      {
        *(void *)(a1 + 288) = v12;
        operator delete(v12);
      }
      *(unsigned char *)(a1 + 304) = 0;
    }
  }
LABEL_32:
  if (v24) {
    sub_10004D2C8(v24);
  }
}

void sub_10103A0CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void stewie::ConnectionAssistantTargetDataSource::handleDumpState(stewie::ConnectionAssistantTargetDataSource *this)
{
  uint64_t v2 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] *********************************************", (uint8_t *)&buf, 2u);
    uint64_t v2 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * ConnectionAssistantTargetDataSource state *", (uint8_t *)&buf, 2u);
    uint64_t v2 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] *********************************************", (uint8_t *)&buf, 2u);
    uint64_t v2 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    double v3 = *((double *)this + 5) * 180.0 / 3.14159265;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Service threshold: %.2f", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    double v4 = *((double *)this + 6) * 180.0 / 3.14159265;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Anchor service threshold: %.2f", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  else
  {
    uint64_t v6 = *(NSObject **)this;
    if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [d] AnchorStorage not set", (uint8_t *)&buf, 2u);
    }
  }
  uint64_t v7 = *((void *)this + 11);
  unint64_t v8 = *(NSObject **)this;
  BOOL v9 = os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT);
  if (!v7)
  {
    if (!v9) {
      goto LABEL_23;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v10 = "#I [d] (AnchorServiceSchedule) anchorServiceSchedule not set";
    goto LABEL_22;
  }
  if (v9)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [d] (AnchorServiceSchedule) anchorServiceSchedule {", (uint8_t *)&buf, 2u);
    uint64_t v7 = *((void *)this + 11);
  }
  (*(void (**)(uint64_t, stewie::ConnectionAssistantTargetDataSource *))(*(void *)v7 + 24))(v7, this);
  unint64_t v8 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v10 = "#I [d] (AnchorServiceSchedule) }";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&buf, 2u);
  }
LABEL_23:
  uint64_t v11 = *((void *)this + 9);
  uint64_t v12 = *(NSObject **)this;
  BOOL v13 = os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (!v13) {
      goto LABEL_31;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v14 = "#I [d] (TargetServiceSchedule) targetServiceSchedule not set";
    goto LABEL_30;
  }
  if (v13)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [d] (TargetServiceSchedule) targetServiceSchedule {", (uint8_t *)&buf, 2u);
    uint64_t v11 = *((void *)this + 9);
  }
  (*(void (**)(uint64_t, stewie::ConnectionAssistantTargetDataSource *))(*(void *)v11 + 24))(v11, this);
  uint64_t v12 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v14 = "#I [d] (TargetServiceSchedule) }";
LABEL_30:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&buf, 2u);
  }
LABEL_31:
  unint64_t v15 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BFCEE8((uint64_t)this + 104, &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v63.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v63.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] LLC targetID: %{public}s", (uint8_t *)&v63, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    unint64_t v15 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v17 = *((void *)this + 18);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] Optimal target updated at GPS time: %llu", (uint8_t *)&buf, 0xCu);
    unint64_t v15 = *(NSObject **)this;
  }
  int v18 = *((unsigned __int8 *)this + 184);
  BOOL v19 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (!v18)
  {
    if (!v19) {
      goto LABEL_55;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v23 = "#I [d] (OptimalTarget) OptimalTarget not set";
    double v24 = v15;
    uint32_t v25 = 2;
    goto LABEL_54;
  }
  if (v19)
  {
    std::to_string(&buf, *((_DWORD *)this + 38));
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      double v20 = &buf;
    }
    else {
      double v20 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v63.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v63.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] (OptimalTarget) targetID: %{public}s", (uint8_t *)&v63, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    unint64_t v15 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    double v21 = *((double *)this + 20) * 180.0 / 3.14159265;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v21;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] (OptimalTarget) heading: %.2f", (uint8_t *)&buf, 0xCu);
    unint64_t v15 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    double v22 = *((double *)this + 21) * 180.0 / 3.14159265;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v22;
    uint64_t v23 = "#I [d] (OptimalTarget) service: %.2f";
    double v24 = v15;
    uint32_t v25 = 12;
LABEL_54:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&buf, v25);
  }
LABEL_55:
  long long v26 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v27 = *((void *)this + 24);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I [d] Service window updated at GPS time: %llu", (uint8_t *)&buf, 0xCu);
  }
  if (!*((unsigned char *)this + 240))
  {
    uint64_t v29 = *(NSObject **)this;
    if (!os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_97;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    long long v35 = "#I [d] (ServiceWindow) ServiceWindow not set";
    goto LABEL_82;
  }
  if (!*((void *)this + 25))
  {
    uint64_t v29 = *(NSObject **)this;
    if (!os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_97;
    }
    goto LABEL_81;
  }
  uint64_t v28 = *((void *)this + 26);
  uint64_t v29 = *(NSObject **)this;
  BOOL v30 = os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT);
  if (!v28)
  {
    if (!v30) {
      goto LABEL_97;
    }
LABEL_81:
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    long long v35 = "#I [d] (ServiceWindow) ServiceWindow is not valid";
LABEL_82:
    uint32_t v36 = v29;
    uint32_t v37 = 2;
LABEL_96:
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, (uint8_t *)&buf, v37);
    goto LABEL_97;
  }
  if (v30)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) ServiceWindow is valid, all times are GPS times", (uint8_t *)&buf, 2u);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v31 = *((void *)this + 25);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v31;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) startTime: %llu", (uint8_t *)&buf, 0xCu);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v32 = *((void *)this + 26);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v32;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) endTime: %llu", (uint8_t *)&buf, 0xCu);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t v33 = "false";
    if (*((unsigned char *)this + 216)) {
      os_log_t v33 = "true";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) inServiceAtStart: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 216))
    {
      long long v34 = "false";
      if (!*((void *)this + 28) && !*((void *)this + 29)) {
        long long v34 = "true";
      }
    }
    else
    {
      long long v34 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) alwaysInService: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 216))
    {
      unint64_t v38 = "false";
    }
    else
    {
      unint64_t v38 = "false";
      if (!*((void *)this + 28) && !*((void *)this + 29)) {
        unint64_t v38 = "true";
      }
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) alwaysNotInService: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v39 = *((void *)this + 29);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v39;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceWindow) AOS: %llu", (uint8_t *)&buf, 0xCu);
    uint64_t v29 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v40 = *((void *)this + 28);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v40;
    long long v35 = "#I [d] (ServiceWindow) LOS: %llu";
    uint32_t v36 = v29;
    uint32_t v37 = 12;
    goto LABEL_96;
  }
LABEL_97:
  unint64_t v41 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v42 = *((void *)this + 31);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v42;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I [d] Service plot updated at GPS time: %llu", (uint8_t *)&buf, 0xCu);
  }
  if (!*((unsigned char *)this + 304))
  {
    unint64_t v43 = *(NSObject **)this;
    if (!os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_130;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    char v58 = "#I [d] (ServicePlot) ServicePlot not set";
    goto LABEL_128;
  }
  if (!*((void *)this + 32))
  {
    unint64_t v43 = *(NSObject **)this;
LABEL_126:
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_130;
    }
LABEL_127:
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    char v58 = "#I [d] (ServicePlot) ServicePlot is not valid";
LABEL_128:
    uint64_t v59 = v43;
    uint32_t v60 = 2;
    goto LABEL_129;
  }
  unint64_t v43 = *(NSObject **)this;
  if (!*((void *)this + 33)) {
    goto LABEL_126;
  }
  uint64_t v44 = *((void *)this + 34);
  BOOL v45 = os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT);
  if (!v44)
  {
    if (!v45) {
      goto LABEL_130;
    }
    goto LABEL_127;
  }
  if (v45)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] (ServicePlot) ServicePlot is valid, all times are GPS times", (uint8_t *)&buf, 2u);
    unint64_t v43 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v46 = *((void *)this + 32);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v46;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] (ServicePlot) version: %llu", (uint8_t *)&buf, 0xCu);
    unint64_t v43 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v47 = *((void *)this + 33);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v47;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] (ServicePlot) startTime: %llu", (uint8_t *)&buf, 0xCu);
    unint64_t v43 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v48 = *((void *)this + 34);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v48;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] (ServicePlot) endTime: %llu", (uint8_t *)&buf, 0xCu);
    unint64_t v43 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] (ServicePlot) readings [", (uint8_t *)&buf, 2u);
  }
  uint64_t v49 = *((void *)this + 35);
  for (uint64_t i = *((void *)this + 36); v49 != i; v49 += 40)
  {
    os_log_t v51 = *(NSObject **)this;
    if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v52 = *(void *)v49;
      std::to_string(&v63, *(_DWORD *)(v49 + 8));
      uint64_t v53 = (v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v63
          : (std::string *)v63.__r_.__value_.__r.__words[0];
      double v54 = *(double *)(v49 + 16) * 180.0 / 3.14159265;
      double v55 = *(double *)(v49 + 24) * 180.0;
      LODWORD(buf.__r_.__value_.__l.__data_) = 134218755;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v52;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v53;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2049;
      double v65 = v54;
      __int16 v66 = 2049;
      double v67 = v55 / 3.14159265;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I [d] (ServicePlot) readings - at: %llu, targetID: %{public}s, heading: %{private}.2f, service: %{private}.2f", (uint8_t *)&buf, 0x2Au);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v63.__r_.__value_.__l.__data_);
      }
    }
  }
  os_log_t v56 = *(os_log_t *)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v57 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)this + 36) - *((void *)this + 35)) >> 3);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v57;
    char v58 = "#I [d] (ServicePlot) readings ] %zu readings";
    uint64_t v59 = v56;
    uint32_t v60 = 12;
LABEL_129:
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, v58, (uint8_t *)&buf, v60);
  }
LABEL_130:
  uint64_t v61 = *((void *)this + 16);
  if (v61)
  {
    (*(void (**)(uint64_t))(*(void *)v61 + 56))(v61);
  }
  else
  {
    uint64_t v62 = *(NSObject **)this;
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I [d] (ServiceAtLocation) ServiceAtLocation not set", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_10103AEDC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10103AFE0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    dispatch_release(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

uint64_t sub_10103B04C(uint64_t a1, void *a2, uint64_t *a3, NSObject **a4)
{
  unint64_t v8 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v25, kCtLoggingSystemName, "set.mmi");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v28, &v25);
  ctu::OsLogLogger::OsLogLogger(v8, (const ctu::OsLogLogger *)v28);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v28);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v25);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A801B8;
  *(void *)(a1 + 32) = *a2;
  uint64_t v9 = a2[1];
  *(void *)(a1 + 40) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 56) = 0;
  uint64_t v10 = (uint64_t **)(a1 + 56);
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  uint64_t v11 = *a3;
  uint64_t v12 = *a4;
  dispatch_object_t object = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v11 + 16))(v11, &object);
  if (object) {
    dispatch_release(object);
  }
  subscriber::makeSimSlotRange();
  var0 = v25.var0;
  fRef = v25.var1.fRef;
  if (v25.var0 != (char *)v25.var1.fRef)
  {
    unint64_t v15 = v26;
    while ((v15(*(unsigned int *)var0) & 1) == 0)
    {
      var0 += 4;
      if (var0 == (char *)fRef)
      {
        var0 = (char *)fRef;
        break;
      }
    }
    unint64_t v16 = v25.var1.fRef;
LABEL_13:
    while (var0 != (char *)v16)
    {
      int v17 = *(_DWORD *)var0;
      int v18 = *v10;
      BOOL v19 = (uint64_t **)(a1 + 56);
      double v20 = (uint64_t **)(a1 + 56);
      if (*v10)
      {
        while (1)
        {
          while (1)
          {
            double v20 = (uint64_t **)v18;
            int v21 = *((_DWORD *)v18 + 7);
            if (v21 <= v17) {
              break;
            }
            int v18 = *v20;
            BOOL v19 = v20;
            if (!*v20) {
              goto LABEL_21;
            }
          }
          if (v21 >= v17) {
            break;
          }
          int v18 = v20[1];
          if (!v18)
          {
            BOOL v19 = v20 + 1;
            goto LABEL_21;
          }
        }
      }
      else
      {
LABEL_21:
        double v22 = operator new(0x28uLL);
        v22[7] = v17;
        *((unsigned char *)v22 + 32) = 0;
        sub_100046C38((uint64_t **)(a1 + 48), (uint64_t)v20, v19, (uint64_t *)v22);
      }
      uint64_t v23 = var0 + 4;
      var0 = (char *)fRef;
      if (v23 != (char *)fRef)
      {
        var0 = v23;
        while ((v15(*(unsigned int *)var0) & 1) == 0)
        {
          var0 += 4;
          if (var0 == (char *)fRef)
          {
            var0 = (char *)fRef;
            goto LABEL_13;
          }
        }
      }
    }
  }
  return a1;
}

void sub_10103B2A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, char a10, uint64_t a11, uint64_t a12, dispatch_object_t object, char a14)
{
  int v17 = *(std::__shared_weak_count **)(v14 + 96);
  if (v17) {
    sub_10004D2C8(v17);
  }
  int v18 = *(std::__shared_weak_count **)(v14 + 80);
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  sub_1000346F8(v15, *(void **)(v14 + 56));
  BOOL v19 = *(std::__shared_weak_count **)(v14 + 40);
  if (v19) {
    sub_10004D2C8(v19);
  }
  double v20 = *(std::__shared_weak_count **)(v14 + 24);
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  ctu::OsLogLogger::~OsLogLogger(a9);
  MMIInterface::~MMIInterface((MMIInterface *)v14);
  _Unwind_Resume(a1);
}

void sub_10103B348(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  double v4 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v3;
  *(void *)(a1 + 80) = v2;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t sub_10103B374(void *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v6 = (std::__shared_weak_count *)a1[10];
  if (!v6) {
    return 1;
  }
  uint64_t v11 = std::__shared_weak_count::lock(v6);
  if (!v11) {
    return 1;
  }
  uint64_t v12 = v11;
  uint64_t v13 = a1[9];
  if (v13)
  {
    uint64_t v14 = a1[1];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 3);
      *(_DWORD *)std::string buf = 134218240;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = a5;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MMI Arguments list size %ld, MMI Procedure %d", buf, 0x12u);
    }
    uint64_t v16 = *a4;
    switch(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 3))
    {
      case 0uLL:
        switch((int)a5)
        {
          case 1:
            int v17 = a1[1];
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_94;
            }
            *(_WORD *)std::string buf = 0;
            int v18 = "#I Activation Call Forwarding";
            BOOL v19 = v17;
            uint32_t v20 = 2;
            goto LABEL_93;
          case 2:
            std::string::size_type v32 = a1[1];
            BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
            uint64_t v34 = 0;
            if (!v33) {
              goto LABEL_95;
            }
            *(_WORD *)std::string buf = 0;
            goto LABEL_54;
          case 3:
            long long v35 = a1[1];
            if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_58;
            }
            *(_WORD *)std::string buf = 0;
            goto LABEL_57;
          case 5:
            uint32_t v37 = a1[1];
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Erase of Call Forwarding", buf, 2u);
            }
            CSIPhoneNumber::CSIPhoneNumber(&v67);
            (*(void (**)(uint64_t, uint64_t, void, CSIPhoneNumber *, void, uint64_t, void, uint64_t))(*(void *)v13 + 232))(v13, a2, 0, &v67, 0, a3, 0, 5);
            unint64_t v38 = &v67;
            goto LABEL_89;
          default:
            uint32_t v36 = a1[1];
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_67;
            }
            *(_WORD *)std::string buf = 0;
            goto LABEL_66;
        }
      case 1uLL:
        switch((int)a5)
        {
          case 1:
          case 4:
            if (*(char *)(v16 + 23) < 0) {
              uint64_t v22 = *(void *)(v16 + 8);
            }
            else {
              uint64_t v22 = *(unsigned __int8 *)(v16 + 23);
            }
            os_log_t v51 = a1[1];
            BOOL v52 = os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
            if (v22)
            {
              if (v52)
              {
                *(_DWORD *)std::string buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = a5;
                _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Registering Call Forwarding with MMI Procedure %d", buf, 8u);
              }
              uint64_t v75 = 0;
              long long v73 = 0u;
              long long v74 = 0u;
              long long v71 = 0u;
              long long v72 = 0u;
              long long v69 = 0u;
              long long v70 = 0u;
              memset(buf, 0, sizeof(buf));
              CSIPhoneNumber::CSIPhoneNumber();
              sub_10009DB3C((uint64_t)v66, (uint64_t)buf);
              (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, void, uint64_t, void, uint64_t))(*(void *)v13 + 232))(v13, a2, 1, v66, 0, a3, 0, a5);
              uint64_t v53 = v66;
              goto LABEL_88;
            }
            if (v52)
            {
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = a5;
              int v18 = "#I Activation Call Forwarding with MMI Procedure %d";
              BOOL v19 = v51;
              uint32_t v20 = 8;
LABEL_93:
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
            }
LABEL_94:
            uint64_t v34 = 1;
LABEL_95:
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v13 + 224))(v13, a2, v34, a3, 0, a5);
            uint64_t v21 = 0;
            break;
          case 2:
            std::string::size_type v32 = a1[1];
            BOOL v45 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
            uint64_t v34 = 0;
            if (v45)
            {
              *(_WORD *)std::string buf = 0;
LABEL_54:
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Deactivation Call Forwarding", buf, 2u);
              uint64_t v34 = 0;
            }
            goto LABEL_95;
          case 3:
            long long v35 = a1[1];
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
LABEL_57:
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Interrogation of Call Forwarding", buf, 2u);
            }
LABEL_58:
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)v13 + 216))(v13, a2, a3, 0, 0);
            uint64_t v21 = 0;
            goto LABEL_96;
          case 5:
            std::string::size_type v39 = a1[1];
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Erase of Call Forwarding", buf, 2u);
            }
            CSIPhoneNumber::CSIPhoneNumber(&v65);
            (*(void (**)(uint64_t, uint64_t, void, CSIPhoneNumber *, void, uint64_t, void, uint64_t))(*(void *)v13 + 232))(v13, a2, 0, &v65, 0, a3, 0, 5);
            unint64_t v38 = &v65;
            goto LABEL_89;
          default:
            uint32_t v36 = a1[1];
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_67;
            }
            *(_WORD *)std::string buf = 0;
            goto LABEL_66;
        }
        goto LABEL_96;
      case 2uLL:
        uint64_t v23 = sub_10103C1A8(v16 + 24);
        if (!v23)
        {
          double v24 = a1[1];
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N Unknown Service Class Code", buf, 2u);
          }
        }
        switch((int)a5)
        {
          case 1:
          case 4:
            if (*(char *)(*a4 + 23) < 0) {
              uint64_t v25 = *(void *)(*a4 + 8);
            }
            else {
              uint64_t v25 = *(unsigned __int8 *)(*a4 + 23);
            }
            double v54 = a1[1];
            BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
            if (v25)
            {
              if (v55)
              {
                *(_DWORD *)std::string buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = a5;
                _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Registering Call Forwarding with MMI Procedure %d", buf, 8u);
              }
              uint64_t v75 = 0;
              long long v73 = 0u;
              long long v74 = 0u;
              long long v71 = 0u;
              long long v72 = 0u;
              long long v69 = 0u;
              long long v70 = 0u;
              memset(buf, 0, sizeof(buf));
              CSIPhoneNumber::CSIPhoneNumber();
              sub_10009DB3C((uint64_t)v64, (uint64_t)buf);
              (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, void, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 232))(v13, a2, 1, v64, 0, a3, v23, a5);
              uint64_t v53 = v64;
              goto LABEL_88;
            }
            if (v55)
            {
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = a5;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Activation Call Forwarding with MMI Procedure %d", buf, 8u);
            }
            uint64_t v42 = 1;
LABEL_101:
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 224))(v13, a2, v42, a3, v23, a5);
            break;
          case 2:
            std::string::size_type v40 = a1[1];
            BOOL v41 = os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
            uint64_t v42 = 0;
            if (v41)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Deactivation Call Forwarding", buf, 2u);
              uint64_t v42 = 0;
            }
            goto LABEL_101;
          case 3:
            std::string::size_type v46 = a1[1];
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Interrogation of Call Forwarding", buf, 2u);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v13 + 216))(v13, a2, a3, v23, 0);
            uint64_t v21 = 0;
            goto LABEL_96;
          case 5:
            unint64_t v43 = a1[1];
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Erase of Call Forwarding", buf, 2u);
            }
            CSIPhoneNumber::CSIPhoneNumber(&v63);
            (*(void (**)(uint64_t, uint64_t, void, CSIPhoneNumber *, void, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 232))(v13, a2, 0, &v63, 0, a3, v23, 5);
            unint64_t v38 = &v63;
            goto LABEL_89;
          default:
            uint32_t v36 = a1[1];
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_67;
            }
            *(_WORD *)std::string buf = 0;
            goto LABEL_66;
        }
        goto LABEL_90;
      case 3uLL:
        uint64_t v26 = sub_10103C1A8(v16 + 24);
        if (!v26)
        {
          std::string::size_type v27 = a1[1];
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N Unknown Service Class Code", buf, 2u);
          }
        }
        int v62 = 0;
        uint64_t v28 = (const char *)(*a4 + 48);
        if (*(char *)(*a4 + 71) < 0) {
          uint64_t v28 = *(const char **)v28;
        }
        sscanf(v28, "%u", &v62);
        uint64_t v29 = v62;
        BOOL v30 = a1[1];
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v29;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Timer provided is of value %u", buf, 8u);
        }
        switch((int)a5)
        {
          case 1:
          case 4:
            unsigned int v59 = v26;
            if (*(char *)(*a4 + 23) < 0) {
              uint64_t v31 = *(void *)(*a4 + 8);
            }
            else {
              uint64_t v31 = *(unsigned __int8 *)(*a4 + 23);
            }
            os_log_t v56 = a1[1];
            BOOL v57 = os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
            if (v31)
            {
              if (v57)
              {
                *(_DWORD *)std::string buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = a5;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Registering Call Forwarding with MMI Procedure %d", buf, 8u);
              }
              uint64_t v75 = 0;
              long long v73 = 0u;
              long long v74 = 0u;
              long long v71 = 0u;
              long long v72 = 0u;
              long long v69 = 0u;
              long long v70 = 0u;
              memset(buf, 0, sizeof(buf));
              CSIPhoneNumber::CSIPhoneNumber();
              sub_10009DB3C((uint64_t)v61, (uint64_t)buf);
              (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, uint64_t, void, uint64_t))(*(void *)v13 + 232))(v13, a2, 1, v61, v29, a3, v59, a5);
              uint64_t v53 = v61;
LABEL_88:
              sub_100087E24((uint64_t)v53);
              unint64_t v38 = buf;
LABEL_89:
              sub_100087E24((uint64_t)v38);
            }
            else
            {
              if (v57)
              {
                *(_DWORD *)std::string buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = a5;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Activation Call Forwarding with MMI Procedure %d", buf, 8u);
              }
              uint64_t v49 = 1;
              uint64_t v26 = v59;
LABEL_105:
              (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 224))(v13, a2, v49, a3, v26, a5);
            }
            break;
          case 2:
            std::string::size_type v47 = a1[1];
            BOOL v48 = os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT);
            uint64_t v49 = 0;
            if (v48)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Deactivation Call Forwarding", buf, 2u);
              uint64_t v49 = 0;
            }
            goto LABEL_105;
          case 3:
            unint64_t v50 = a1[1];
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Interrogation of Call Forwarding", buf, 2u);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v13 + 216))(v13, a2, a3, v26, 0);
            uint64_t v21 = 0;
            goto LABEL_96;
          case 5:
            uint64_t v44 = a1[1];
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Erase of Call Forwarding", buf, 2u);
            }
            CSIPhoneNumber::CSIPhoneNumber(&v60);
            (*(void (**)(uint64_t, uint64_t, void, CSIPhoneNumber *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 232))(v13, a2, 0, &v60, v29, a3, v26, 5);
            unint64_t v38 = &v60;
            goto LABEL_89;
          default:
            uint32_t v36 = a1[1];
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
LABEL_66:
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#N Unsupported MMI Procedure", buf, 2u);
            }
            goto LABEL_67;
        }
LABEL_90:
        uint64_t v21 = 0;
        goto LABEL_96;
      default:
        break;
    }
  }
LABEL_67:
  uint64_t v21 = 1;
LABEL_96:
  sub_10004D2C8(v12);
  return v21;
}

void sub_10103C0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100087E24((uint64_t)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

uint64_t sub_10103C1A8(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 23);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a1 + 8);
  }
  if (v2 != 2) {
    goto LABEL_18;
  }
  if (v3 >= 0) {
    double v4 = (_WORD *)a1;
  }
  else {
    double v4 = *(_WORD **)a1;
  }
  switch(*v4)
  {
    case 0x3031:
      return 13;
    case 0x3131:
      return 1;
    case 0x3231:
      return 12;
    case 0x3331:
      return 4;
    case 0x3631:
      return 8;
    case 0x3931:
      return 5;
    case 0x3032:
      return 48;
    case 0x3132:
      return 160;
    case 0x3232:
      return 80;
    case 0x3432:
      return 16;
    case 0x3532:
      return 32;
  }
LABEL_18:
  if (sub_1002E6B08((const void **)a1, "26")) {
    return 17;
  }
  if (sub_1002E6B08((const void **)a1, "99")) {
    return 64;
  }
  return 0;
}

uint64_t sub_10103C330(void *a1, uint64_t a2, uint64_t a3, long long **a4, uint64_t a5)
{
  uint64_t v6 = (std::__shared_weak_count *)a1[10];
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = a1[9];
      if (v13)
      {
        uint64_t v14 = a1[1];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3);
          *(_DWORD *)std::string buf = 134218240;
          *(void *)&uint8_t buf[4] = v15;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MMI Arguments list size %ld, MMI Procedure %d", buf, 0x12u);
        }
        uint64_t v16 = *a4;
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((char *)a4[1] - (char *)*a4) >> 3);
        switch(v17)
        {
          case 2uLL:
            memset(buf, 0, sizeof(buf));
            if (*((char *)v16 + 23) < 0)
            {
              sub_10004FC84(buf, *(void **)v16, *((void *)v16 + 1));
              uint64_t v16 = *a4;
            }
            else
            {
              long long v21 = *v16;
              *(void *)&uint8_t buf[16] = *((void *)v16 + 2);
              *(_OWORD *)std::string buf = v21;
            }
            uint64_t v23 = sub_10103C1A8((uint64_t)v16 + 24);
            if (!v23)
            {
              double v24 = a1[1];
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(__p[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Unknown Service Class Code", (uint8_t *)__p, 2u);
              }
            }
            switch((int)a5)
            {
              case 1:
              case 4:
                uint64_t v25 = a1[1];
                if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Activation/Registration of Call Barring", (uint8_t *)__p, 2u);
                }
                uint64_t v26 = 1;
                goto LABEL_38;
              case 2:
              case 5:
                uint64_t v29 = a1[1];
                BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
                uint64_t v26 = 0;
                if (v30)
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Deactivation/Erase of Call Barring", (uint8_t *)__p, 2u);
                  uint64_t v26 = 0;
                }
LABEL_38:
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 136))(v13, a2, v26, buf, a3, v23, a5);
                goto LABEL_52;
              case 3:
                long long v35 = a1[1];
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Interrogation of Call Barring", (uint8_t *)__p, 2u);
                }
                sub_100058DB0(__p, "");
                (*(void (**)(uint64_t, uint64_t, void **, uint64_t, uint64_t, void))(*(void *)v13 + 120))(v13, a2, __p, a3, v23, 0);
LABEL_50:
                if (v38 < 0) {
                  operator delete(__p[0]);
                }
LABEL_52:
                uint64_t v20 = 0;
                break;
              default:
                uint64_t v34 = a1[1];
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
LABEL_55:
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#N Unsupported MMI Procedure", (uint8_t *)__p, 2u);
                }
LABEL_56:
                uint64_t v20 = 1;
                break;
            }
LABEL_57:
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_59;
          case 1uLL:
            memset(buf, 0, sizeof(buf));
            if (*((char *)v16 + 23) < 0)
            {
              sub_10004FC84(buf, *(void **)v16, *((void *)v16 + 1));
            }
            else
            {
              long long v22 = *v16;
              *(void *)&uint8_t buf[16] = *((void *)v16 + 2);
              *(_OWORD *)std::string buf = v22;
            }
            switch((int)a5)
            {
              case 1:
              case 4:
                std::string::size_type v27 = a1[1];
                if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Activation/Registration of Call Barring", (uint8_t *)__p, 2u);
                }
                uint64_t v28 = 1;
                goto LABEL_41;
              case 2:
              case 5:
                uint64_t v31 = a1[1];
                BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
                uint64_t v28 = 0;
                if (v32)
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Deactivation/Erase of Call Barring", (uint8_t *)__p, 2u);
                  uint64_t v28 = 0;
                }
LABEL_41:
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *, uint64_t, void, uint64_t))(*(void *)v13 + 136))(v13, a2, v28, buf, a3, 0, a5);
                uint64_t v20 = 0;
                goto LABEL_57;
              case 3:
                BOOL v33 = a1[1];
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Interrogation of Call Barring", (uint8_t *)__p, 2u);
                }
                sub_100058DB0(__p, "");
                (*(void (**)(uint64_t, uint64_t, void **, uint64_t, void, void))(*(void *)v13 + 120))(v13, a2, __p, a3, 0, 0);
                goto LABEL_50;
              default:
                uint64_t v34 = a1[1];
                if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_56;
                }
                LOWORD(__p[0]) = 0;
                goto LABEL_55;
            }
          case 0uLL:
            int v18 = a1[1];
            BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
            if (a5 == 3)
            {
              if (v19)
              {
                *(_WORD *)std::string buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Interrogation of Call Barring", buf, 2u);
              }
              sub_100058DB0(buf, "");
              (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, void, void))(*(void *)v13 + 120))(v13, a2, buf, a3, 0, 0);
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              uint64_t v20 = 0;
              goto LABEL_59;
            }
            if (v19)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Unsupported MMI Procedure", buf, 2u);
            }
            break;
        }
      }
      uint64_t v20 = 1;
LABEL_59:
      sub_10004D2C8(v12);
      return v20;
    }
  }
  return 1;
}

void sub_10103C994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_10103CA1C(os_log_t *a1, unsigned __int8 *a2)
{
  if ((char)a2[23] < 0)
  {
    if ((unint64_t)(*((void *)a2 + 1) - 9) >= 0xFFFFFFFFFFFFFFFBLL)
    {
      a2 = *(unsigned __int8 **)a2;
      goto LABEL_8;
    }
LABEL_5:
    uint64_t v2 = *a1;
    BOOL v3 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v3) {
      return result;
    }
    __int16 v13 = 0;
    uint64_t v5 = (uint8_t *)&v13;
    goto LABEL_17;
  }
  if ((unint64_t)a2[23] - 9 <= 0xFFFFFFFFFFFFFFFALL) {
    goto LABEL_5;
  }
LABEL_8:
  int v6 = *a2;
  if (*a2)
  {
    uint64_t v7 = a2 + 1;
    while ((v6 - 58) > 0xFFFFFFF5)
    {
      int v8 = *v7++;
      int v6 = v8;
      if (!v8) {
        goto LABEL_12;
      }
    }
    uint64_t v2 = *a1;
    BOOL v10 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v10)
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v5 = buf;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Not a valid PIN", v5, 2u);
      return 0;
    }
  }
  else
  {
LABEL_12:
    uint64_t v9 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I A Valid PIN", v11, 2u);
    }
    return 1;
  }
  return result;
}

uint64_t sub_10103CB54(void *a1, unsigned int a2, std::string::value_type *a3)
{
  uint64_t v5 = a1[1];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (a3[23] >= 0) {
      int v6 = a3;
    }
    else {
      int v6 = *(std::string::value_type **)a3;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Processing MMI String %s", buf, 0xCu);
  }
  long long v73 = 0;
  long long v74 = 0;
  uint64_t v75 = 0;
  sub_100CC3120(&v73, 4uLL);
  std::string::size_type v46 = a3;
  if (a3[23] >= 0) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = *(std::string::value_type **)a3;
  }
  std::string::value_type v8 = *v7;
  if (*v7)
  {
    int v9 = 0;
    int v10 = 0;
    uint64_t v11 = 0;
    int v12 = 0;
    LODWORD(v13) = 0;
    while (1)
    {
      switch(v12)
      {
        case 0:
          if (v8 == 42)
          {
            int v12 = 1;
          }
          else
          {
            if (v8 != 35) {
              goto LABEL_113;
            }
            int v12 = 2;
          }
          goto LABEL_58;
        case 1:
          if ((v8 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[v8] & 0x400) != 0)
          {
            --v7;
            int v12 = 4;
            uint64_t v11 = 1;
          }
          else if (v8 == 35)
          {
            uint64_t v11 = 3;
            int v12 = 3;
          }
          else
          {
            if (v8 != 42) {
              goto LABEL_113;
            }
            int v12 = 3;
            uint64_t v11 = 4;
          }
          goto LABEL_58;
        case 2:
          if (v8 < 0) {
            goto LABEL_113;
          }
          if ((_DefaultRuneLocale.__runetype[v8] & 0x400) != 0)
          {
            --v7;
            int v12 = 4;
            uint64_t v11 = 2;
          }
          else
          {
            if (v8 != 35) {
              goto LABEL_113;
            }
            int v12 = 3;
            uint64_t v11 = 5;
          }
          goto LABEL_58;
        case 3:
          if (v8 < 0 || (_DefaultRuneLocale.__runetype[v8] & 0x400) == 0) {
            goto LABEL_113;
          }
          --v7;
          goto LABEL_43;
        case 4:
          if (v8 == 35) {
            goto LABEL_35;
          }
          if (v8 == 42)
          {
            uint64_t v14 = (uint64_t *)v73;
            goto LABEL_54;
          }
          if (v8 < 0) {
            goto LABEL_113;
          }
          if ((_DefaultRuneLocale.__runetype[v8] & 0x400) == 0) {
            goto LABEL_113;
          }
          if (++v10 == 4) {
            goto LABEL_113;
          }
          int v9 = v8 + 10 * v9 - 48;
LABEL_43:
          int v12 = 4;
          goto LABEL_58;
        case 5:
          if (v8 == 35)
          {
LABEL_35:
            int v12 = 6;
            goto LABEL_58;
          }
          if (v8 == 42)
          {
            unint64_t v15 = (char *)&v73[(int)v13];
            if (v15[23] < 0)
            {
              if (!*((void *)v15 + 1))
              {
                *((void *)v15 + 1) = 12;
                unint64_t v15 = *(char **)v15;
LABEL_51:
                strcpy(v15, "Place Holder");
              }
            }
            else if (!v15[23])
            {
              v15[23] = 12;
              goto LABEL_51;
            }
            uint64_t v13 = (int)v13 + 1;
            if (v13 == 4) {
              goto LABEL_113;
            }
            uint64_t v14 = (uint64_t *)&v73[v13];
LABEL_54:
            if (*((char *)v14 + 23) < 0)
            {
              v14[1] = 0;
              uint64_t v14 = (uint64_t *)*v14;
            }
            else
            {
              *((unsigned char *)v14 + 23) = 0;
            }
            *(unsigned char *)uint64_t v14 = 0;
            int v12 = 5;
            goto LABEL_58;
          }
          if (v8 < 0 || v8 != 43 && (_DefaultRuneLocale.__runetype[v8] & 0x400) == 0) {
            goto LABEL_113;
          }
          std::string::push_back(&v73[(int)v13], v8);
          int v12 = 5;
LABEL_58:
          int v16 = *++v7;
          std::string::value_type v8 = v16;
          if (!v16) {
            goto LABEL_61;
          }
          break;
        case 6:
          goto LABEL_113;
        default:
          goto LABEL_58;
      }
    }
  }
  int v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
LABEL_61:
  int v47 = v9;
  uint64_t v17 = v11;
  uint64_t v18 = 3;
  while (1)
  {
    uint64_t v19 = v18;
    uint64_t v20 = v73;
    uint64_t v21 = (uint64_t)&v73[v18];
    uint64_t v22 = *(char *)(v21 + 23) < 0 ? *(void *)(v21 + 8) : *(unsigned __int8 *)(v21 + 23);
    uint64_t v23 = v74;
    if (v22) {
      break;
    }
    sub_1000D935C((uint64_t)buf, (long long *)(v21 + 24), v74, v21);
    uint64_t v23 = v24;
    for (uint64_t i = v74; i != v23; uint64_t i = (long long *)((char *)i - 24))
    {
      if (*((char *)i - 1) < 0) {
        operator delete(*((void **)i - 3));
      }
    }
    long long v74 = v23;
    uint64_t v18 = v19 - 1;
    if (!v19)
    {
      uint64_t v20 = v73;
      break;
    }
  }
  sub_100058DB0(buf, "Place Holder");
  sub_100058DB0(&__str, "");
  if (v20 != (std::string *)v23)
  {
    while (1)
    {
      uint64_t v26 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
      if ((v26 & 0x80u) == 0) {
        std::string::size_type size = HIBYTE(v20->__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v20->__r_.__value_.__l.__size_;
      }
      uint64_t v28 = HIBYTE(v78);
      if (v78 < 0) {
        uint64_t v28 = *(void *)&buf[8];
      }
      if (size != v28) {
        goto LABEL_91;
      }
      uint64_t v29 = v78 >= 0 ? buf : *(unsigned char **)buf;
      if ((v26 & 0x80) == 0) {
        break;
      }
      if (!memcmp(v20->__r_.__value_.__l.__data_, v29, v20->__r_.__value_.__l.__size_)) {
        goto LABEL_90;
      }
LABEL_91:
      if (++v20 == (std::string *)v23) {
        goto LABEL_92;
      }
    }
    if (*((unsigned char *)&v20->__r_.__value_.__s + 23))
    {
      uint64_t v30 = 0;
      while (v20->__r_.__value_.__s.__data_[v30] == v29[v30])
      {
        if (v26 == ++v30) {
          goto LABEL_90;
        }
      }
      goto LABEL_91;
    }
LABEL_90:
    std::string::operator=(v20, &__str);
    goto LABEL_91;
  }
LABEL_92:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v78) < 0) {
    operator delete(*(void **)buf);
  }
  BOOL v32 = (long long *)v73;
  uint64_t v31 = v74;
  if (v73 != (std::string *)v74)
  {
    do
    {
      BOOL v33 = a1[1];
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = v32;
        if (*((char *)v32 + 23) < 0) {
          uint64_t v34 = *(long long **)v32;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I MMI Argument: %s", buf, 0xCu);
      }
      BOOL v32 = (long long *)((char *)v32 + 24);
    }
    while (v32 != v31);
  }
  if (v12 == 6)
  {
    if (v10 == 3)
    {
      uint64_t v36 = 0;
      if (v47 > 329)
      {
        switch(v47)
        {
          case 330:
            uint32_t v37 = v51;
            v51[0] = _NSConcreteStackBlock;
            v51[1] = 0x40000000;
            char v38 = &unk_101A80490;
            std::string::size_type v39 = sub_10103F478;
            goto LABEL_157;
          case 331:
            uint32_t v37 = v54;
            v54[0] = _NSConcreteStackBlock;
            v54[1] = 0x40000000;
            char v38 = &unk_101A80430;
            std::string::size_type v39 = sub_10103F3B8;
            goto LABEL_157;
          case 332:
            uint32_t v37 = v53;
            v53[0] = _NSConcreteStackBlock;
            v53[1] = 0x40000000;
            char v38 = &unk_101A80450;
            std::string::size_type v39 = sub_10103F3F8;
            goto LABEL_157;
          case 333:
            uint32_t v37 = v50;
            v50[0] = _NSConcreteStackBlock;
            v50[1] = 0x40000000;
            char v38 = &unk_101A804B0;
            std::string::size_type v39 = sub_10103F4B8;
            goto LABEL_157;
          default:
            if (v47 == 351)
            {
              uint32_t v37 = v52;
              v52[0] = _NSConcreteStackBlock;
              v52[1] = 0x40000000;
              char v38 = &unk_101A80470;
              std::string::size_type v39 = sub_10103F438;
            }
            else
            {
              if (v47 != 353) {
                goto LABEL_160;
              }
              uint32_t v37 = v49;
              v49[0] = _NSConcreteStackBlock;
              v49[1] = 0x40000000;
              char v38 = &unk_101A804D0;
              std::string::size_type v39 = sub_10103F4F8;
            }
            break;
        }
        goto LABEL_157;
      }
      if (v47 <= 41)
      {
        if (v47 == 2)
        {
          uint32_t v37 = v59;
          v59[0] = _NSConcreteStackBlock;
          v59[1] = 0x40000000;
          char v38 = &unk_101A80390;
          std::string::size_type v39 = sub_10103EF40;
          goto LABEL_157;
        }
        if (v47 == 4)
        {
          uint32_t v37 = v58;
          v58[0] = _NSConcreteStackBlock;
          v58[1] = 0x40000000;
          char v38 = &unk_101A803B0;
          std::string::size_type v39 = sub_10103EF80;
          goto LABEL_157;
        }
      }
      else
      {
        switch(v47)
        {
          case 42:
            uint32_t v37 = v57;
            v57[0] = _NSConcreteStackBlock;
            v57[1] = 0x40000000;
            char v38 = &unk_101A803D0;
            std::string::size_type v39 = sub_10103EFC0;
            goto LABEL_157;
          case 52:
            uint32_t v37 = v56;
            v56[0] = _NSConcreteStackBlock;
            v56[1] = 0x40000000;
            char v38 = &unk_101A803F0;
            std::string::size_type v39 = sub_10103F124;
            goto LABEL_157;
          case 300:
            uint32_t v37 = v55;
            v55[0] = _NSConcreteStackBlock;
            v55[1] = 0x40000000;
            char v38 = &unk_101A80410;
            std::string::size_type v39 = sub_10103F2A8;
            goto LABEL_157;
        }
      }
    }
    else if (v10 == 2)
    {
      long long v35 = a1[1];
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v47;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I MMI code is of length 2 with service code %d", buf, 8u);
      }
      uint64_t v36 = 0;
      if (v47 > 42)
      {
        if (v47 <= 61)
        {
          if (v47 == 43)
          {
            uint32_t v37 = v65;
            v65[0] = _NSConcreteStackBlock;
            v65[1] = 0x40000000;
            char v38 = &unk_101A802D0;
            std::string::size_type v39 = sub_10103E838;
            goto LABEL_157;
          }
          if (v47 == 61)
          {
            uint32_t v37 = v61;
            v61[0] = _NSConcreteStackBlock;
            v61[1] = 0x40000000;
            char v38 = &unk_101A80350;
            std::string::size_type v39 = sub_10103EEC0;
            goto LABEL_157;
          }
        }
        else
        {
          switch(v47)
          {
            case '>':
              uint32_t v37 = v60;
              v60[0] = _NSConcreteStackBlock;
              v60[1] = 0x40000000;
              char v38 = &unk_101A80370;
              std::string::size_type v39 = sub_10103EF00;
              goto LABEL_157;
            case 'C':
              uint32_t v37 = v62;
              v62[0] = _NSConcreteStackBlock;
              v62[1] = 0x40000000;
              char v38 = &unk_101A80330;
              std::string::size_type v39 = sub_10103EE80;
              goto LABEL_157;
            case 'M':
              uint32_t v37 = v64;
              v64[0] = _NSConcreteStackBlock;
              v64[1] = 0x40000000;
              char v38 = &unk_101A802F0;
              std::string::size_type v39 = sub_10103ED3C;
              goto LABEL_157;
          }
        }
      }
      else
      {
        if (v47 > 20)
        {
          switch(v47)
          {
            case 30:
              uint32_t v37 = v69;
              v69[0] = _NSConcreteStackBlock;
              v69[1] = 0x40000000;
              char v38 = &unk_101A80250;
              std::string::size_type v39 = sub_10103E3E4;
              goto LABEL_157;
            case 31:
              uint32_t v37 = v68;
              v68[0] = _NSConcreteStackBlock;
              v68[1] = 0x40000000;
              char v38 = &unk_101A80270;
              std::string::size_type v39 = sub_10103E5D0;
              goto LABEL_157;
            case 32:
            case 34:
              goto LABEL_160;
            case 33:
              uint32_t v37 = v67;
              v67[0] = _NSConcreteStackBlock;
              v67[1] = 0x40000000;
              char v38 = &unk_101A80290;
              std::string::size_type v39 = sub_10103E7B8;
              goto LABEL_157;
            case 35:
              uint32_t v37 = v66;
              v66[0] = _NSConcreteStackBlock;
              v66[1] = 0x40000000;
              char v38 = &unk_101A802B0;
              std::string::size_type v39 = sub_10103E7F8;
              goto LABEL_157;
            default:
              if (v47 != 21) {
                goto LABEL_160;
              }
              uint32_t v37 = v63;
              v63[0] = _NSConcreteStackBlock;
              v63[1] = 0x40000000;
              char v38 = &unk_101A80310;
              std::string::size_type v39 = sub_10103EE40;
              break;
          }
          goto LABEL_157;
        }
        switch(v47)
        {
          case 3:
            uint32_t v37 = v72;
            v72[0] = _NSConcreteStackBlock;
            v72[1] = 0x40000000;
            char v38 = &unk_101A801F0;
            std::string::size_type v39 = sub_10103DA78;
            goto LABEL_157;
          case 4:
            uint32_t v37 = v71;
            v71[0] = _NSConcreteStackBlock;
            v71[1] = 0x40000000;
            char v38 = &unk_101A80210;
            std::string::size_type v39 = sub_10103DE3C;
            goto LABEL_157;
          case 5:
            uint32_t v37 = v70;
            v70[0] = _NSConcreteStackBlock;
            v70[1] = 0x40000000;
            char v38 = &unk_101A80230;
            std::string::size_type v39 = sub_10103E100;
LABEL_157:
            v37[2] = v39;
            v37[3] = v38;
            v37[4] = a1;
            *((_DWORD *)v37 + 10) = a2;
            (*(void (**)(void *))(*a1 + 32))(a1);
            *(_DWORD *)std::string buf = 0;
            ((void (*)(void *, std::string **, uint64_t, unsigned char *))v37[2])(v37, &v73, v17, buf);
            if (*(_DWORD *)buf) {
              (*(void (**)(void *, void))(*a1 + 40))(a1, a2);
            }
            uint64_t v36 = 1;
            break;
        }
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
LABEL_160:
    BOOL v41 = a1[1];
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v42 = subscriber::asString();
      if (v46[23] >= 0) {
        unint64_t v43 = v46;
      }
      else {
        unint64_t v43 = *(std::string::value_type **)v46;
      }
      uint64_t v44 = "was not";
      *(_DWORD *)std::string buf = 136315650;
      if (v36) {
        uint64_t v44 = "was";
      }
      *(void *)&uint8_t buf[4] = v42;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v43;
      __int16 v78 = 2080;
      long long v79 = v44;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I on %s: %s %s handled as MMI", buf, 0x20u);
    }
    goto LABEL_167;
  }
LABEL_113:
  std::string::size_type v40 = a1[1];
  uint64_t v36 = 0;
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#N MMI String parsing has failed", buf, 2u);
    uint64_t v36 = 0;
  }
LABEL_167:
  *(void *)std::string buf = &v73;
  sub_100047F64((void ***)buf);
  return v36;
}

void sub_10103D9D4(_Unwind_Exception *a1)
{
  *(void *)(v1 - 168) = v1 - 192;
  sub_100047F64((void ***)(v1 - 168));
  _Unwind_Resume(a1);
}

void sub_10103DA78(uint64_t a1, const char **a2, uint64_t a3, int *a4)
{
  if (a2[1] - *a2 == 96
    && (uint64_t v5 = *(void *)(a1 + 32), *(void *)(v5 + 80))
    && (uint64_t v8 = *(unsigned int *)(a1 + 40),
        (int v9 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v5 + 80))) != 0))
  {
    int v10 = v9;
    uint64_t v11 = *(void *)(v5 + 72);
    if (v11)
    {
      int v12 = *a2;
      if ((*a2)[23] < 0) {
        int v12 = *(const char **)v12;
      }
      int v13 = atoi(v12);
      if (v13 <= 329)
      {
        if (v13 == 33)
        {
          uint64_t v22 = *(NSObject **)(v5 + 8);
          uint64_t v17 = 0;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)double v24 = 0;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I BAOC (barr[sic] all outgoing calls)", v24, 2u);
            uint64_t v17 = 0;
          }
        }
        else if (v13 == 35)
        {
          int v16 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)double v24 = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I BAIC (barr[sic] all incoming calls)", v24, 2u);
          }
          uint64_t v17 = 3;
        }
        else
        {
LABEL_37:
          uint64_t v14 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)double v24 = 0;
LABEL_39:
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I All Barring Services", v24, 2u);
          }
LABEL_40:
          uint64_t v17 = 6;
        }
      }
      else
      {
        switch(v13)
        {
          case 330:
            uint64_t v14 = *(NSObject **)(v5 + 8);
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_40;
            }
            *(_WORD *)double v24 = 0;
            goto LABEL_39;
          case 331:
            uint64_t v19 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)double v24 = 0;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I BAOIC (barr[sic] all outgoing international calls)", v24, 2u);
            }
            uint64_t v17 = 1;
            break;
          case 332:
            uint64_t v20 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)double v24 = 0;
              uint64_t v17 = 2;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I BAOIC exc home (barr[sic] all outgoing international calls except to home country)", v24, 2u);
            }
            else
            {
              uint64_t v17 = 2;
            }
            break;
          case 333:
            uint64_t v21 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)double v24 = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Outgoing Barring Services", v24, 2u);
            }
            uint64_t v17 = 7;
            break;
          default:
            if (v13 == 351)
            {
              uint64_t v23 = *(NSObject **)(v5 + 8);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)double v24 = 0;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I BAIC roaming (barr[sic] all incoming calls when roaming outside the home country)", v24, 2u);
              }
              uint64_t v17 = 4;
            }
            else
            {
              if (v13 != 353) {
                goto LABEL_37;
              }
              uint64_t v18 = *(NSObject **)(v5 + 8);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)double v24 = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Incoming Barring Services", v24, 2u);
              }
              uint64_t v17 = 8;
            }
            break;
        }
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, const char *, const char *, const char *, uint64_t))(*(void *)v11 + 144))(v11, v8, v17, *a2 + 24, *a2 + 48, *a2 + 72, a3);
      int v15 = 0;
    }
    else
    {
      int v15 = 1;
    }
    sub_10004D2C8(v10);
  }
  else
  {
    int v15 = 1;
  }
  *a4 = v15;
}

void sub_10103DE18(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10103DE3C(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (os_log_t *)(v6 + 8);
  if (sub_10103CA1C((os_log_t *)(v6 + 8), *a2)
    && sub_10103CA1C((os_log_t *)(v6 + 8), *a2 + 24))
  {
    uint64_t v8 = *a2;
    uint64_t v9 = (*a2)[47];
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = (*a2)[47];
    }
    else {
      uint64_t v10 = *((void *)*a2 + 4);
    }
    uint64_t v11 = v8[71];
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *((void *)v8 + 7);
    }
    if (v10 == v11)
    {
      int v13 = (const void **)(v8 + 24);
      int v16 = (unsigned __int8 *)*((void *)v8 + 6);
      uint64_t v14 = v8 + 48;
      int v15 = v16;
      if (v12 >= 0) {
        uint64_t v17 = v14;
      }
      else {
        uint64_t v17 = v15;
      }
      if ((v9 & 0x80) == 0)
      {
        if ((*a2)[47])
        {
          while (*(unsigned __int8 *)v13 == *v17)
          {
            int v13 = (const void **)((char *)v13 + 1);
            ++v17;
            if (!--v9) {
              goto LABEL_22;
            }
          }
          goto LABEL_18;
        }
LABEL_22:
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        sGetSubscriberSimInterface();
        uint64_t v20 = *(NSObject **)(v6 + 8);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Subscriber sim controller not found.", buf, 2u);
        }
        int v19 = 1;
        if (v23) {
          sub_10004D2C8(v23);
        }
        goto LABEL_21;
      }
      if (!memcmp(*v13, v17, *((void *)*a2 + 4))) {
        goto LABEL_22;
      }
    }
  }
LABEL_18:
  uint64_t v18 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#N Invalid arguments of PIN", buf, 2u);
  }
  int v19 = 40;
LABEL_21:
  *a4 = v19;
}

void sub_10103E0B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103E100(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (os_log_t *)(v6 + 8);
  uint64_t v8 = *a2;
  if (sub_10103CA1C((os_log_t *)(v6 + 8), *a2))
  {
    uint64_t v9 = v8[23];
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *((void *)v8 + 1);
    }
    if (v9 == 8 && sub_10103CA1C((os_log_t *)(v6 + 8), *a2 + 24))
    {
      uint64_t v10 = *a2;
      uint64_t v11 = (*a2)[47];
      if ((v11 & 0x80u) == 0) {
        uint64_t v12 = (*a2)[47];
      }
      else {
        uint64_t v12 = *((void *)*a2 + 4);
      }
      uint64_t v13 = v10[71];
      int v14 = (char)v13;
      if ((v13 & 0x80u) != 0) {
        uint64_t v13 = *((void *)v10 + 7);
      }
      if (v12 == v13)
      {
        int v15 = (const void **)(v10 + 24);
        uint64_t v18 = (unsigned __int8 *)*((void *)v10 + 6);
        int v16 = v10 + 48;
        uint64_t v17 = v18;
        if (v14 >= 0) {
          int v19 = v16;
        }
        else {
          int v19 = v17;
        }
        if ((v11 & 0x80) == 0)
        {
          if ((*a2)[47])
          {
            while (*(unsigned __int8 *)v15 == *v19)
            {
              int v15 = (const void **)((char *)v15 + 1);
              ++v19;
              if (!--v11) {
                goto LABEL_25;
              }
            }
            goto LABEL_21;
          }
LABEL_25:
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          sGetSubscriberSimInterface();
          uint64_t v22 = *(NSObject **)(v6 + 8);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Subscriber sim controller not found.", buf, 2u);
          }
          int v21 = 1;
          if (v25) {
            sub_10004D2C8(v25);
          }
          goto LABEL_24;
        }
        if (!memcmp(*v15, v19, *((void *)*a2 + 4))) {
          goto LABEL_25;
        }
      }
    }
  }
LABEL_21:
  uint64_t v20 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Invalid arguments of PIN", buf, 2u);
  }
  int v21 = 40;
LABEL_24:
  *a4 = v21;
}

void sub_10103E39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103E3E4(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 80))
  {
    uint64_t v7 = *(unsigned int *)(a1 + 40);
    uint64_t v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v5 + 80));
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v5 + 72);
      if (v10)
      {
        if (a3 == 3)
        {
          uint64_t v11 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15) = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I MMI Interrogation on CLIP", (uint8_t *)&v15, 2u);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 176))(v10, v7, 1, 0);
          int v12 = 0;
          goto LABEL_16;
        }
        if ((a3 - 1) <= 1)
        {
          uint64_t v13 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            int v14 = "Deactivation";
            if (a3 == 1) {
              int v14 = "Activation";
            }
            int v15 = 136315138;
            int v16 = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I MMI %s on CLIP", (uint8_t *)&v15, 0xCu);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)v10 + 192))(v10, v7, 1, a3 == 1);
          int v12 = 0;
          goto LABEL_16;
        }
      }
      int v12 = 1;
LABEL_16:
      sub_10004D2C8(v9);
      goto LABEL_17;
    }
  }
  int v12 = 1;
LABEL_17:
  *a4 = v12;
}

void sub_10103E5B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10103E5D0(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 80))
  {
    uint64_t v7 = *(unsigned int *)(a1 + 40);
    uint64_t v8 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v5 + 80));
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v5 + 72);
      if (v10)
      {
        if (a3 == 3)
        {
          uint64_t v11 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v15) = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I MMI Interrogation on CLIR", (uint8_t *)&v15, 2u);
          }
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v10 + 88))(v10, v7, 0);
          int v12 = 0;
          goto LABEL_16;
        }
        if ((a3 - 1) <= 1)
        {
          uint64_t v13 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            int v14 = "Deactivation";
            if (a3 == 1) {
              int v14 = "Activation";
            }
            int v15 = 136315138;
            int v16 = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I MMI %s on CLIR", (uint8_t *)&v15, 0xCu);
          }
          (*(void (**)(uint64_t, uint64_t, BOOL, void))(*(void *)v10 + 104))(v10, v7, a3 == 1, 0);
          int v12 = 0;
          goto LABEL_16;
        }
      }
      int v12 = 1;
LABEL_16:
      sub_10004D2C8(v9);
      goto LABEL_17;
    }
  }
  int v12 = 1;
LABEL_17:
  *a4 = v12;
}

void sub_10103E7A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10103E7B8(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 0, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103E7F8(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 3, a2, a3);
  *a4 = result;
  return result;
}

void sub_10103E838(uint64_t a1, uint64_t *a2, uint64_t a3, int *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 80))
  {
    uint64_t v8 = *(unsigned int *)(a1 + 40);
    uint64_t v9 = std::__shared_weak_count::lock(*(std::__shared_weak_count **)(v5 + 80));
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(v5 + 72);
      if (!v11) {
        goto LABEL_34;
      }
      int v12 = *(NSObject **)(v5 + 8);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
        int v29 = 134218240;
        unint64_t v30 = v13;
        __int16 v31 = 1024;
        int v32 = a3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MMI Arguments list size %ld, MMI Procedure %d", (uint8_t *)&v29, 0x12u);
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
      if (v14 == 1)
      {
        uint64_t v18 = sub_10103C1A8(*a2);
        if (!v18)
        {
          int v19 = *(NSObject **)(v5 + 8);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v29) = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Unknown Service Class Code", (uint8_t *)&v29, 2u);
          }
        }
        switch((int)a3)
        {
          case 1:
          case 4:
            uint64_t v20 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v29) = 0;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Activation Call Waiting", (uint8_t *)&v29, 2u);
            }
            uint64_t v21 = 1;
            goto LABEL_25;
          case 2:
          case 5:
            uint64_t v24 = *(NSObject **)(v5 + 8);
            BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
            uint64_t v21 = 0;
            if (v25)
            {
              LOWORD(v29) = 0;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Deactivation Call Waiting", (uint8_t *)&v29, 2u);
              uint64_t v21 = 0;
            }
LABEL_25:
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 160))(v11, v8, v21, v18, a3);
            int v17 = 0;
            break;
          case 3:
            uint64_t v28 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v29) = 0;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Interrogation Call Waiting", (uint8_t *)&v29, 2u);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v11 + 152))(v11, v8, v18, 0);
            int v17 = 0;
            break;
          default:
            uint64_t v26 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v29) = 0;
LABEL_33:
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Unsupported MMI Procedure", (uint8_t *)&v29, 2u);
            }
            goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (v14)
      {
LABEL_34:
        int v17 = 1;
      }
      else
      {
        switch((int)a3)
        {
          case 1:
          case 4:
            int v15 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v29) = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Activation Call Waiting", (uint8_t *)&v29, 2u);
            }
            uint64_t v16 = 1;
            goto LABEL_22;
          case 2:
          case 5:
            uint64_t v22 = *(NSObject **)(v5 + 8);
            BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
            uint64_t v16 = 0;
            if (v23)
            {
              LOWORD(v29) = 0;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Deactivation Call Waiting", (uint8_t *)&v29, 2u);
              uint64_t v16 = 0;
            }
LABEL_22:
            (*(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v11 + 160))(v11, v8, v16, 0, a3);
            int v17 = 0;
            break;
          case 3:
            std::string::size_type v27 = *(NSObject **)(v5 + 8);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v29) = 0;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Interrogation Call Waiting", (uint8_t *)&v29, 2u);
            }
            (*(void (**)(uint64_t, uint64_t, void, void))(*(void *)v11 + 152))(v11, v8, 0, 0);
            int v17 = 0;
            break;
          default:
            uint64_t v26 = *(NSObject **)(v5 + 8);
            if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_34;
            }
            LOWORD(v29) = 0;
            goto LABEL_33;
        }
      }
LABEL_35:
      sub_10004D2C8(v10);
      goto LABEL_36;
    }
  }
  int v17 = 1;
LABEL_36:
  *a4 = v17;
}

void sub_10103ECFC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10103ED3C(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v6 = *(void **)(a1 + 32);
  uint64_t v7 = (std::__shared_weak_count *)v6[10];
  if (v7 && (uint64_t v9 = *(unsigned int *)(a1 + 40), (v10 = std::__shared_weak_count::lock(v7)) != 0))
  {
    uint64_t v11 = v10;
    int v12 = 1;
    if (a3 == 3)
    {
      uint64_t v13 = v6[9];
      if (v13)
      {
        unint64_t v14 = v6[1];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MMI Interrogation on COLR", v15, 2u);
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 200))(v13, v9);
        int v12 = 0;
      }
    }
    sub_10004D2C8(v11);
  }
  else
  {
    int v12 = 1;
  }
  *a4 = v12;
}

void sub_10103EE2C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10103EE40(uint64_t a1, void *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103B374(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 0, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103EE80(uint64_t a1, void *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103B374(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 1, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103EEC0(uint64_t a1, void *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103B374(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 2, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103EF00(uint64_t a1, void *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103B374(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 3, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103EF40(uint64_t a1, void *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103B374(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 4, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103EF80(uint64_t a1, void *a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103B374(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 5, a2, a3);
  *a4 = result;
  return result;
}

void sub_10103EFC0(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int *a4)
{
  uint64_t v6 = (os_log_t *)(*(void *)(a1 + 32) + 8);
  if (sub_10103CA1C(v6, *a2) && sub_10103CA1C(v6, *a2 + 24))
  {
    uint64_t v7 = *a2;
    uint64_t v8 = (*a2)[47];
    if ((v8 & 0x80u) == 0) {
      uint64_t v9 = (*a2)[47];
    }
    else {
      uint64_t v9 = *((void *)*a2 + 4);
    }
    uint64_t v10 = v7[71];
    int v11 = (char)v10;
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *((void *)v7 + 7);
    }
    if (v9 == v10)
    {
      int v12 = (const void **)(v7 + 24);
      int v15 = (unsigned __int8 *)*((void *)v7 + 6);
      uint64_t v13 = v7 + 48;
      unint64_t v14 = v15;
      if (v11 >= 0) {
        uint64_t v16 = v13;
      }
      else {
        uint64_t v16 = v14;
      }
      if ((v8 & 0x80) == 0)
      {
        if ((*a2)[47])
        {
          while (*(unsigned __int8 *)v12 == *v16)
          {
            int v12 = (const void **)((char *)v12 + 1);
            ++v16;
            if (!--v8) {
              goto LABEL_22;
            }
          }
          goto LABEL_18;
        }
LABEL_22:
        int v19 = *v6;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          v20[0] = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Not handling PIN2 changes", (uint8_t *)v20, 2u);
        }
        int v18 = 1;
        goto LABEL_21;
      }
      if (!memcmp(*v12, v16, *((void *)*a2 + 4))) {
        goto LABEL_22;
      }
    }
  }
LABEL_18:
  int v17 = *v6;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Invalid arguments of PIN2", buf, 2u);
  }
  int v18 = 40;
LABEL_21:
  *a4 = v18;
}

void sub_10103F124(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int *a4)
{
  uint64_t v6 = (os_log_t *)(*(void *)(a1 + 32) + 8);
  uint64_t v7 = *a2;
  if (sub_10103CA1C(v6, *a2))
  {
    uint64_t v8 = v7[23];
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)v7 + 1);
    }
    if (v8 == 8 && sub_10103CA1C(v6, *a2 + 24))
    {
      uint64_t v9 = *a2;
      uint64_t v10 = (*a2)[47];
      if ((v10 & 0x80u) == 0) {
        uint64_t v11 = (*a2)[47];
      }
      else {
        uint64_t v11 = *((void *)*a2 + 4);
      }
      uint64_t v12 = v9[71];
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *((void *)v9 + 7);
      }
      if (v11 == v12)
      {
        unint64_t v14 = (const void **)(v9 + 24);
        int v17 = (unsigned __int8 *)*((void *)v9 + 6);
        int v15 = v9 + 48;
        uint64_t v16 = v17;
        if (v13 >= 0) {
          int v18 = v15;
        }
        else {
          int v18 = v16;
        }
        if ((v10 & 0x80) == 0)
        {
          if ((*a2)[47])
          {
            while (*(unsigned __int8 *)v14 == *v18)
            {
              unint64_t v14 = (const void **)((char *)v14 + 1);
              ++v18;
              if (!--v10) {
                goto LABEL_25;
              }
            }
            goto LABEL_21;
          }
LABEL_25:
          uint64_t v21 = *v6;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            v22[0] = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Not handling PIN2 changes", (uint8_t *)v22, 2u);
          }
          int v20 = 1;
          goto LABEL_24;
        }
        if (!memcmp(*v14, v18, *((void *)*a2 + 4))) {
          goto LABEL_25;
        }
      }
    }
  }
LABEL_21:
  int v19 = *v6;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Invalid arguments of PIN2", buf, 2u);
  }
  int v20 = 40;
LABEL_24:
  *a4 = v20;
}

void sub_10103F2A8(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v6 = *(void **)(a1 + 32);
  uint64_t v7 = (std::__shared_weak_count *)v6[10];
  if (v7 && (uint64_t v9 = *(unsigned int *)(a1 + 40), (v10 = std::__shared_weak_count::lock(v7)) != 0))
  {
    uint64_t v11 = v10;
    int v12 = 1;
    if (a3 == 3)
    {
      uint64_t v13 = v6[9];
      if (v13)
      {
        unint64_t v14 = v6[1];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MMI Interrogation on CNAP", v15, 2u);
        }
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v13 + 264))(v13, v9, 0);
        int v12 = 0;
      }
    }
    sub_10004D2C8(v11);
  }
  else
  {
    int v12 = 1;
  }
  *a4 = v12;
}

void sub_10103F3A4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10103F3B8(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 1, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103F3F8(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 2, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103F438(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 4, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103F478(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 6, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103F4B8(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 7, a2, a3);
  *a4 = result;
  return result;
}

uint64_t sub_10103F4F8(uint64_t a1, long long **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result = sub_10103C330(*(void **)(a1 + 32), *(unsigned int *)(a1 + 40), 8, a2, a3);
  *a4 = result;
  return result;
}

void sub_10103F538(uint64_t a1, signed int a2)
{
  unsigned int v11 = a2;
  for (uint64_t i = *(uint64_t **)(a1 + 56); i; uint64_t i = (uint64_t *)*i)
  {
    signed int v4 = *((_DWORD *)i + 7);
    if (v4 <= a2)
    {
      if (v4 >= a2)
      {
        *(void *)std::string buf = &v11;
        int v6 = *((unsigned __int8 *)sub_10005CE78((uint64_t **)(a1 + 48), (int *)&v11, (uint64_t)&unk_10144E20E, (_DWORD **)buf)+ 32);
        uint64_t v7 = *(NSObject **)(a1 + 8);
        if (v6)
        {
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            uint64_t v8 = "USSD Session was already on!";
            uint64_t v9 = v7;
            uint32_t v10 = 2;
            goto LABEL_16;
          }
        }
        else
        {
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Starting USSD session", buf, 2u);
          }
          *(void *)std::string buf = &v11;
          *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 48), (int *)&v11, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = 1;
          (*(void (**)(void, void))(**(void **)(a1 + 88) + 88))(*(void *)(a1 + 88), v11);
        }
        return;
      }
      ++i;
    }
  }
  uint64_t v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    uint64_t v8 = "Cannot find slot %s!!";
    uint64_t v9 = v5;
    uint32_t v10 = 12;
LABEL_16:
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v10);
  }
}

void sub_10103F710(uint64_t a1, int a2, int a3)
{
  int v15 = a2;
  signed int v4 = *(uint64_t **)(a1 + 56);
  if (!v4)
  {
LABEL_7:
    uint64_t v7 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    int v12 = "Cannot find slot %s!!";
    uint64_t v13 = v7;
    uint32_t v14 = 12;
    goto LABEL_18;
  }
  while (1)
  {
    int v6 = *((_DWORD *)v4 + 7);
    if (v6 <= a2) {
      break;
    }
LABEL_6:
    signed int v4 = (uint64_t *)*v4;
    if (!v4) {
      goto LABEL_7;
    }
  }
  if (v6 < a2)
  {
    ++v4;
    goto LABEL_6;
  }
  *(void *)std::string buf = &v15;
  int v8 = *((unsigned __int8 *)sub_10005CE78((uint64_t **)(a1 + 48), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32);
  uint64_t v9 = *(NSObject **)(a1 + 8);
  if (!v8)
  {
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    int v12 = "USSD Session does not exist";
    uint64_t v13 = v9;
    uint32_t v14 = 2;
LABEL_18:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = CSIErrorString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I USSD session complete, error %s", buf, 0xCu);
  }
  *(void *)std::string buf = &v15;
  *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 48), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = 0;
  uint64_t v11 = **(void **)(a1 + 88);
  if (a3) {
    (*(void (**)(void))(v11 + 104))();
  }
  else {
    (*(void (**)(void))(v11 + 96))();
  }
}

void sub_10103F92C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 48);
  uint64_t v2 = (void *)(a1 + 56);
  if (v1 != (void *)(a1 + 56))
  {
    do
    {
      signed int v4 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = subscriber::asString();
        if (*((unsigned char *)v1 + 32)) {
          int v6 = "true";
        }
        else {
          int v6 = "false";
        }
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v11 = v5;
        __int16 v12 = 2080;
        uint64_t v13 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Ussd Session on %s: %s", buf, 0x16u);
      }
      uint64_t v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v9);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
}

void sub_10103FA70(uint64_t a1)
{
  *(void *)a1 = off_101A801B8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  sub_1000346F8(a1 + 48, *(void **)(a1 + 56));
  signed int v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  MMIInterface::~MMIInterface((MMIInterface *)a1);
}

void sub_10103FB04(uint64_t a1)
{
  *(void *)a1 = off_101A801B8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  sub_1000346F8(a1 + 48, *(void **)(a1 + 56));
  signed int v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  MMIInterface::~MMIInterface((MMIInterface *)a1);

  operator delete();
}

void sub_10103FBAC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10103FC2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10103FC68(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10103FCA0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10103FCD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10103FD14(uint64_t a1)
{
  *(void *)a1 = off_101A805E0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    _Block_release(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10103FD84(uint64_t a1)
{
  sub_10103FD14(a1);

  operator delete();
}

void sub_10103FDBC()
{
}

void sub_10103FE58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  operator delete();
}

uint64_t sub_10103FE88(uint64_t a1)
{
  *(void *)a1 = off_101A80650;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + 24) = 0;
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  sub_100057D78((const void **)(a1 + 56));
  uint64_t v5 = (void **)(a1 + 32);
  sub_101040A6C(&v5);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10103FF18(uint64_t a1)
{
  sub_10103FE88(a1);

  operator delete();
}

void sub_10103FF50()
{
}

void sub_101040000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (v10) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101040058(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))();
}

uint64_t sub_101040080(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_1010400A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))();
}

uint64_t sub_1010400D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))();
}

uint64_t sub_1010400F8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))();
}

uint64_t sub_101040120(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))();
}

uint64_t sub_101040148(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_101040D50;
  v5[3] = &unk_101A806F8;
  void v5[4] = a3;
  v5[5] = a1;
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 64))(v3, a2, v5);
}

uint64_t sub_1010401DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))();
}

uint64_t sub_101040204(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 80))();
}

uint64_t sub_10104022C(uint64_t a1)
{
  uint64_t result = a1 + 32;
  if (*(char *)(a1 + 55) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_101040248(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))();
}

uint64_t sub_101040270(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_101040298(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))();
}

const void **sub_1010402C0(uint64_t a1, CFDictionaryRef theDict)
{
  signed int v4 = (CFDictionaryRef *)(a1 + 56);
  if (*(void *)(a1 + 56)) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    uint64_t result = (const void **)CFDictionaryGetCount(theDict);
    if (result)
    {
      unint64_t v7 = (unint64_t)result;
      CFIndex Count = CFDictionaryGetCount(*v4);
      MutableCopy = CFDictionaryCreateMutableCopy(0, Count + v7, *v4);
      keys = 0;
      int v15 = 0;
      uint64_t v16 = 0;
      sub_10019E8F0(&keys, v7);
      values = 0;
      __int16 v12 = 0;
      uint64_t v13 = 0;
      sub_10004EE3C(&values, v7);
      CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
      for (uint64_t i = 0; i != v7; ++i)
        CFDictionaryAddValue(MutableCopy, keys[i], values[i]);
      sub_10004EFE4(&v10, (CFTypeRef *)&MutableCopy);
      if (v4 != &v10)
      {
        CFDictionaryRef v18 = *v4;
        *signed int v4 = v10;
        CFDictionaryRef v10 = 0;
        sub_100057D78((const void **)&v18);
      }
      sub_100057D78((const void **)&v10);
      (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 56));
      if (values)
      {
        __int16 v12 = values;
        operator delete(values);
      }
      if (keys)
      {
        int v15 = keys;
        operator delete(keys);
      }
      return sub_10005717C((const void **)&MutableCopy);
    }
  }
  else
  {
    keys = (void **)theDict;
    sub_100282490((const void **)(a1 + 56), (CFTypeRef *)&keys);
    return (const void **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 56));
  }
  return result;
}

void sub_101040474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  sub_10005717C((const void **)(v15 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_1010404C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))();
}

uint64_t sub_1010404E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))();
}

void sub_101040510(void *a1, NSObject *a2, void *aBlock)
{
  if (aBlock) {
    uint64_t v5 = _Block_copy(aBlock);
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v7 = (char *)a1[5];
  unint64_t v6 = a1[6];
  if ((unint64_t)v7 < v6)
  {
    *(void *)unint64_t v7 = v5;
    int v8 = v7 + 8;
    goto LABEL_23;
  }
  BOOL v9 = (char *)a1[4];
  uint64_t v10 = (v7 - v9) >> 3;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61) {
    sub_10006A748();
  }
  uint64_t v12 = v6 - (void)v9;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      sub_10006A7CC();
    }
    uint32_t v14 = (char *)operator new(8 * v13);
  }
  else
  {
    uint32_t v14 = 0;
  }
  uint64_t v15 = &v14[8 * v10];
  *(void *)uint64_t v15 = v5;
  if (v7 == v9)
  {
    int v8 = v15 + 8;
    a1[4] = v15;
    a1[5] = v15 + 8;
    a1[6] = &v14[8 * v13];
    if (v9) {
LABEL_22:
    }
      operator delete(v9);
  }
  else
  {
    uint64_t v16 = v7;
    int v17 = &v14[8 * v10];
    do
    {
      uint64_t v18 = *((void *)v16 - 1);
      v16 -= 8;
      *((void *)v17 - 1) = v18;
      v17 -= 8;
      *(void *)uint64_t v16 = 0;
    }
    while (v16 != v9);
    int v8 = v15 + 8;
    a1[4] = v17;
    a1[5] = v15 + 8;
    a1[6] = &v14[8 * v13];
    do
    {
      int v19 = (const void *)*((void *)v7 - 1);
      v7 -= 8;
      sub_101040AEC(v19);
    }
    while (v7 != v9);
    if (v9) {
      goto LABEL_22;
    }
  }
LABEL_23:
  a1[5] = v8;
  int v20 = a1[3];
  if (v20)
  {
    if (v20 != a2) {
      __assert_rtn("startSync", "CallServicesSyncBase.cpp", 191, "fQueue == queue");
    }
  }
  else
  {
    dispatch_retain(a2);
    a1[3] = a2;
    uint64_t v21 = a1[1];
    uint64_t v22 = (std::__shared_weak_count *)a1[2];
    uint64_t v23 = v21;
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v23 = a1[1];
    }
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 1174405120;
    v24[2] = sub_101041198;
    v24[3] = &unk_101A80718;
    v24[4] = a1;
    v24[5] = v21;
    BOOL v25 = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, NSObject *, void *))(*(void *)v23 + 64))(v23, a2, v24);
    if (v25) {
      std::__shared_weak_count::__release_weak(v25);
    }
    if (v22) {
      std::__shared_weak_count::__release_weak(v22);
    }
  }
}

void sub_101040754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101040794(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))();
}

uint64_t sub_1010407BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 80))();
}

uint64_t sub_1010407E4(uint64_t a1)
{
  uint64_t result = a1 + 64;
  if (*(char *)(a1 + 87) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_101040800(uint64_t a1, void *a2, const char *a3, void *aBlock)
{
  *(void *)a1 = off_101A805E0;
  *(void *)(a1 + 8) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 16) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if (aBlock) {
    unint64_t v7 = _Block_copy(aBlock);
  }
  else {
    unint64_t v7 = 0;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = v7;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  int v8 = (char *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 88))(*(void *)(a1 + 8));
  sub_100058DB0(&v19, v8);
  BOOL v9 = std::string::append(&v19, "(filtered:", 0xAuLL);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  size_t v11 = strlen(a3);
  uint64_t v12 = std::string::append(&v20, a3, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  uint32_t v14 = std::string::append(&v21, ")", 1uLL);
  std::string::size_type v15 = v14->__r_.__value_.__r.__words[0];
  v22[0] = v14->__r_.__value_.__l.__size_;
  *(void *)((char *)v22 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
  char v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v17 = v22[0];
  *(void *)(a1 + 32) = v15;
  *(void *)(a1 + 40) = v17;
  *(void *)(a1 + 47) = *(void *)((char *)v22 + 7);
  *(unsigned char *)(a1 + 55) = v16;
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_1010409D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_101040A6C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    signed int v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (const void *)*((void *)v4 - 1);
        v4 -= 8;
        sub_101040AEC(v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_101040AEC(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

uint64_t sub_101040B0C(uint64_t a1, uint64_t *a2, const char *a3)
{
  *(void *)a1 = off_101A80650;
  uint64_t v5 = a1 + 8;
  sub_1008DF41C((uint64_t *)(a1 + 8), a2);
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  sub_100058DB0(&v18, "splitter(");
  size_t v6 = strlen(a3);
  unint64_t v7 = std::string::append(&v18, a3, v6);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  BOOL v9 = std::string::append(&v19, ")->", 3uLL);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  size_t v11 = (const char *)(*(uint64_t (**)(void))(**(void **)v5 + 88))();
  size_t v12 = strlen(v11);
  long long v13 = std::string::append(&v20, v11, v12);
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[0];
  v21[0] = v13->__r_.__value_.__l.__size_;
  *(void *)((char *)v21 + 7) = *(std::string::size_type *)((char *)&v13->__r_.__value_.__r.__words[1] + 7);
  char v15 = HIBYTE(v13->__r_.__value_.__r.__words[2]);
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v16 = v21[0];
  *(void *)(a1 + 64) = v14;
  *(void *)(a1 + 72) = v16;
  *(void *)(a1 + 79) = *(void *)((char *)v21 + 7);
  *(unsigned char *)(a1 + 87) = v15;
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  return a1;
}

void sub_101040CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,const void **a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (*(char *)(v28 + 87) < 0) {
    operator delete(*(void **)(v28 + 64));
  }
  sub_100057D78(v29);
  a23 = v29 - 3;
  sub_101040A6C((void ***)&a23);
  __int16 v31 = *(std::__shared_weak_count **)(v28 + 16);
  if (v31) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(a1);
}

const void **sub_101040D50(uint64_t a1, CFDictionaryRef theDict, CFArrayRef theArray, int a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  CFMutableArrayRef theArraya = 0;
  BOOL v33 = 0;
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
    size_t v11 = (void **)theArraya;
    CFMutableArrayRef theArraya = Mutable;
    keys = v11;
    sub_1000440D4((const void **)&keys);
    for (CFIndex i = 0; i < CFArrayGetCount(theArray); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      std::string::size_type v14 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v15 = CFGetTypeID(ValueAtIndex);
        if (v15 == CFStringGetTypeID())
        {
          if (theDict) {
            CFDictionaryGetValue(theDict, v14);
          }
          if ((*(unsigned int (**)(void))(*(void *)(v7 + 24) + 16))()) {
            CFArrayAppendValue(theArraya, v14);
          }
        }
      }
    }
  }
  if (theDict)
  {
    CFIndex v16 = CFDictionaryGetCount(theDict);
    CFMutableDictionaryRef v17 = CFDictionaryCreateMutable(0, v16, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    std::string v18 = (void **)v33;
    BOOL v33 = v17;
    keys = v18;
    sub_10005717C((const void **)&keys);
    keys = 0;
    *(void *)long long v35 = 0;
    *(void *)&void v35[8] = 0;
    sub_10019E8F0(&keys, v16);
    values = 0;
    unint64_t v30 = 0;
    uint64_t v31 = 0;
    sub_10004EE3C(&values, v16);
    CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
    if (v16)
    {
      for (uint64_t j = 0; j != v16; ++j)
      {
        if (keys[j] && (*(unsigned int (**)(void))(*(void *)(v7 + 24) + 16))()) {
          CFDictionaryAddValue(v33, keys[j], values[j]);
        }
      }
    }
    if (values)
    {
      unint64_t v30 = values;
      operator delete(values);
    }
    if (keys)
    {
      *(void *)long long v35 = keys;
      operator delete(keys);
    }
  }
  if (theArraya) {
    std::string v20 = sub_100289354;
  }
  else {
    std::string v20 = 0;
  }
  if (v20)
  {
    CFIndex v21 = CFArrayGetCount(theArraya);
    int v22 = v21;
    if (v21) {
      goto LABEL_34;
    }
  }
  else
  {
    int v22 = 0;
  }
  if (a4)
  {
LABEL_34:
    values = 0;
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&values, kCtLoggingSystemName, "ps.kvs");
    BOOL v25 = values;
    if (os_log_type_enabled((os_log_t)values, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = (void *)(v7 + 32);
      if (*(char *)(v7 + 55) < 0) {
        uint64_t v26 = (void *)*v26;
      }
      std::string::size_type v27 = ". FULL SYNC";
      LODWORD(keys) = 67109634;
      HIDWORD(keys) = v22;
      *(_WORD *)long long v35 = 2080;
      if (a4) {
        std::string::size_type v27 = "";
      }
      *(void *)&v35[2] = v26;
      *(_WORD *)&v35[10] = 2080;
      *(void *)&v35[12] = v27;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Received %d record(s) for %s%s", (uint8_t *)&keys, 0x1Cu);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    goto LABEL_41;
  }
  values = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&values, kCtLoggingSystemName, "ps.kvs");
  uint64_t v23 = values;
  if (os_log_type_enabled((os_log_t)values, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = (void *)(v7 + 32);
    if (*(char *)(v7 + 55) < 0) {
      uint64_t v24 = (void *)*v24;
    }
    keys = (void **)67109378;
    *(_WORD *)long long v35 = 2080;
    *(void *)&v35[2] = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Received %d record(s) for %s - ignored", (uint8_t *)&keys, 0x12u);
  }
LABEL_41:
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&values);
  sub_1000440D4((const void **)&theArraya);
  return sub_10005717C((const void **)&v33);
}

void sub_101041110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, const void *a13, const void *a14, void *a15, uint64_t a16)
{
}

void sub_101041198(void *a1, uint64_t a2, const __CFArray *a3, int a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v8 = a1[4];
    BOOL v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      long long v10 = v9;
      if (a1[5])
      {
        if (a3) {
          int Count = CFArrayGetCount(a3);
        }
        else {
          int Count = 0;
        }
        os_log_t oslog = 0;
        ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&oslog, kCtLoggingSystemName, "ps.kvs");
        size_t v12 = oslog;
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
        {
          long long v13 = (void *)(v8 + 64);
          if (*(char *)(v8 + 87) < 0) {
            long long v13 = (void *)*v13;
          }
          std::string::size_type v14 = ". FULL SYNC";
          *(_DWORD *)std::string buf = 67109634;
          int v19 = Count;
          __int16 v20 = 2080;
          if (a4) {
            std::string::size_type v14 = "";
          }
          CFIndex v21 = v13;
          __int16 v22 = 2080;
          uint64_t v23 = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received %d record(s) for %s%s", buf, 0x1Cu);
        }
        uint64_t v15 = *(void *)(v8 + 32);
        if (*(void *)(v8 + 40) != v15)
        {
          unint64_t v16 = 0;
          do
          {
            (*(void (**)(void))(*(void *)(v15 + 8 * v16++) + 16))();
            uint64_t v15 = *(void *)(v8 + 32);
          }
          while (v16 < (*(void *)(v8 + 40) - v15) >> 3);
        }
        ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&oslog);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10104133C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101041364(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101041380(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101041390(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1010413F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101041434(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10104146C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10104149C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1010414E0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101041594(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *sub_1010415C8(void *a1, uint64_t a2, NSObject **a3)
{
  uint64_t v5 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, "pwr.iokit");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger(v5, (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_101A807D0;
  size_t v6 = *a3;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  v7.fObj.fObuint64_t j = (dispatch_object_s *)&object;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 4), "com.apple.system.powersources.source", v7);
  if (object) {
    dispatch_release(object);
  }
  return a1;
}

void sub_1010416B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, char a10, uint64_t a11, char a12)
{
  if (object) {
    dispatch_release(object);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)v12 + 3);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  IoKitPowerSourceInterface::~IoKitPowerSourceInterface(v12);
  _Unwind_Resume(a1);
}

void sub_101041714(void *a1)
{
  *a1 = off_101A807D0;
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 4));
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  IoKitPowerSourceInterface::~IoKitPowerSourceInterface((IoKitPowerSourceInterface *)a1);
}

void sub_101041780(void *a1)
{
  sub_101041714(a1);

  operator delete();
}

void sub_1010417B8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v3 || (uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16), (v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  queue v7 = v6;
  p_unint64_t shared_weak_owners = &v6->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_101041A24;
  v12[3] = &unk_101A807F8;
  v12[4] = v5;
  long long v13 = v7;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  xpc_set_event_stream_handler("com.apple.notifyd.matching", (dispatch_queue_t)&_dispatch_main_q, v12);
  v16[0] = v5;
  v16[1] = v7;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  sub_1000F0058((uint64_t)v17, a2);
  NotifySubscription::cancel((NotifySubscription *)(a1 + 32));
  BOOL v9 = (char *)operator new(0x48uLL);
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 1) = 0;
  *(void *)BOOL v9 = off_101A80948;
  *(_OWORD *)(v9 + 24) = *(_OWORD *)v16;
  v16[0] = 0;
  v16[1] = 0;
  sub_1000DA470((uint64_t)(v9 + 40), (uint64_t)v17);
  OsLogContext v10 = *(const char **)(a1 + 32);
  size_t v11 = *(NSObject **)(a1 + 40);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 1174405120;
  handler[2] = sub_101041E58;
  handler[3] = &unk_101A80908;
  handler[4] = v9 + 24;
  uint64_t v15 = (std::__shared_weak_count *)v9;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v9 + 1, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v10, (int *)(a1 + 48), v11, handler);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8((std::__shared_weak_count *)v9);
  sub_10003B34C(v17);
  if (v16[1]) {
    std::__shared_weak_count::__release_weak(v16[1]);
  }
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  std::__shared_weak_count::__release_weak(v7);
}

void sub_1010419C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,char a21,std::__shared_weak_count *a22)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_10004D2C8(v23);
  sub_101041BA8((uint64_t)&a21);
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  std::__shared_weak_count::__release_weak(v22);
  _Unwind_Resume(a1);
}

void sub_101041A24(uint64_t a1, void *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      size_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7)
      {
        uint64_t v8 = *(NSObject **)(v7 + 8);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t object = a2;
          if (a2) {
            xpc_retain(a2);
          }
          else {
            xpc_object_t object = xpc_null_create();
          }
          xpc::object::to_string((uint64_t *)__p, (xpc::object *)&object);
          if (v12 >= 0) {
            BOOL v9 = __p;
          }
          else {
            BOOL v9 = (void **)__p[0];
          }
          *(_DWORD *)std::string buf = 136315138;
          std::string::size_type v14 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Got XPC stream event: %s", buf, 0xCu);
          if (v12 < 0) {
            operator delete(__p[0]);
          }
          xpc_release(object);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_101041B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_101041B7C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101041B98(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_101041BA8(uint64_t a1)
{
  sub_10003B34C((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_101041BE0(uint64_t a1)
{
  return NotifySubscription::cancel((NotifySubscription *)(a1 + 32));
}

uint64_t sub_101041BE8(uint64_t a1)
{
  CFTypeRef v2 = IOPSCopyPowerSourcesInfo();
  char v12 = v2;
  if (v2) {
    uint64_t v3 = sub_100080934;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3)
  {
    size_t v6 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      uint64_t v5 = 0;
      goto LABEL_13;
    }
    __int16 v11 = 0;
    uint64_t v7 = "Could not get power source info!";
    uint64_t v8 = (uint8_t *)&v11;
LABEL_15:
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v7, v8, 2u);
    goto LABEL_12;
  }
  CFStringRef v4 = IOPSGetProvidingPowerSourceType(v2);
  if (!v4)
  {
    size_t v6 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    __int16 v10 = 0;
    uint64_t v7 = "Could not get power source type";
    uint64_t v8 = (uint8_t *)&v10;
    goto LABEL_15;
  }
  if (CFEqual(v4, @"Battery Power")) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 2;
  }
LABEL_13:
  sub_1000577C4(&v12);
  return v5;
}

void sub_101041CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_101041CF0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101041D70(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101041DAC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101041DE4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_101041E14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_101041E58(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  CFTypeRef v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFStringRef v4 = v3;
      if (*v1)
      {
        uint64_t v5 = v1[5];
        if (!v5) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_101041EE8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101041EFC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101041F18(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_101041F28(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A80948;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101041F48(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A80948;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101041F9C(uint64_t a1)
{
  sub_10003B34C((void *)(a1 + 40));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_101041FEC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_101042078(uint64_t a1, int a2, int a3, int a4)
{
  int v14 = a3;
  int v15 = a2;
  sub_1010421C0(&v12, a4);
  uint64_t v5 = v12;
  size_t v6 = v13;
  if (v12 != v13)
  {
    uint64_t v7 = v12;
    do
    {
      int v11 = *v7;
      uint64_t v8 = *(void ***)(a1 + 8);
      CFMutableDictionaryRef v17 = 0;
      BOOL v9 = operator new(0x20uLL);
      *BOOL v9 = off_101A80B80;
      v9[1] = &v14;
      v9[2] = &v11;
      v9[3] = &v15;
      CFMutableDictionaryRef v17 = v9;
      sub_100043ED0((uint64_t)v16, *v8);
      sub_100043E48(v16);
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_101042190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_1010421C0(int **a1, int a2)
{
  CFStringRef v4 = 0;
  uint64_t v5 = 0;
  size_t v6 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  for (int i = 1; i < 129; i *= 2)
  {
    if ((i & a2) != 0)
    {
      if (v6 >= v5)
      {
        uint64_t v9 = v6 - v4;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 62) {
          sub_10006A748();
        }
        if (((char *)v5 - (char *)v4) >> 1 > v10) {
          unint64_t v10 = ((char *)v5 - (char *)v4) >> 1;
        }
        if ((unint64_t)((char *)v5 - (char *)v4) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11)
        {
          if (v11 >> 62) {
            sub_10006A7CC();
          }
          char v12 = (char *)operator new(4 * v11);
        }
        else
        {
          char v12 = 0;
        }
        long long v13 = (int *)&v12[4 * v9];
        int *v13 = i;
        uint64_t v8 = v13 + 1;
        while (v6 != v4)
        {
          int v14 = *--v6;
          *--long long v13 = v14;
        }
        uint64_t v5 = (int *)&v12[4 * v11];
        *a1 = v13;
        a1[1] = v8;
        a1[2] = v5;
        if (v4) {
          operator delete(v4);
        }
        CFStringRef v4 = v13;
      }
      else
      {
        int *v6 = i;
        uint64_t v8 = v6 + 1;
      }
      a1[1] = v8;
      size_t v6 = v8;
    }
  }
}

void sub_1010422E8(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10104230C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v16 = a3;
  int v17 = a2;
  int v15 = a5;
  sub_1010421C0(&v13, a4);
  size_t v6 = v13;
  uint64_t v7 = v14;
  if (v13 != v14)
  {
    uint64_t v8 = v13;
    do
    {
      int v12 = *v8;
      uint64_t v9 = *(void ***)(a1 + 8);
      int v19 = 0;
      unint64_t v10 = operator new(0x28uLL);
      *unint64_t v10 = off_101A80C00;
      v10[1] = &v16;
      void v10[2] = &v12;
      v10[3] = &v15;
      void v10[4] = &v17;
      int v19 = v10;
      sub_100043ED0((uint64_t)v18, *v9);
      sub_100043E48(v18);
      ++v8;
    }
    while (v8 != v7);
  }
  if (v6) {
    operator delete(v6);
  }
}

void sub_101042430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100043E48((uint64_t *)va);
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void sub_101042460(uint64_t a1, int a2, int a3, int a4, char a5, int a6, uint64_t a7)
{
  int v20 = a3;
  int v21 = a2;
  char v19 = a5;
  int v18 = a6;
  sub_1010421C0(&v16, a4);
  uint64_t v9 = v17;
  std::string __p = v16;
  if (v16 != v17)
  {
    unint64_t v10 = v16;
    do
    {
      int v15 = *v10;
      unint64_t v11 = *(void ***)(a1 + 8);
      uint64_t v23 = 0;
      int v12 = operator new(0x38uLL);
      void *v12 = off_101A80C80;
      v12[1] = &v20;
      void v12[2] = &v15;
      v12[3] = &v19;
      v12[4] = a7;
      void v12[5] = &v18;
      void v12[6] = &v21;
      uint64_t v23 = v12;
      sub_100043ED0((uint64_t)v22, *v11);
      sub_100043E48(v22);
      ++v10;
    }
    while (v10 != v9);
  }
  if (__p) {
    operator delete(__p);
  }
}

void sub_101042598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1010425CC(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v16 = a3;
  int v17 = a2;
  int v15 = a5;
  sub_1010421C0(&v13, a4);
  size_t v6 = v13;
  uint64_t v7 = v14;
  if (v13 != v14)
  {
    uint64_t v8 = v13;
    do
    {
      int v12 = *v8;
      uint64_t v9 = *(void ***)(a1 + 8);
      char v19 = 0;
      unint64_t v10 = operator new(0x28uLL);
      *unint64_t v10 = off_101A80D00;
      v10[1] = &v16;
      void v10[2] = &v12;
      v10[3] = &v15;
      void v10[4] = &v17;
      char v19 = v10;
      sub_100043ED0((uint64_t)v18, *v9);
      sub_100043E48(v18);
      ++v8;
    }
    while (v8 != v7);
  }
  if (v6) {
    operator delete(v6);
  }
}

void sub_1010426F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100043E48((uint64_t *)va);
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void *sub_101042720(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A80D80;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1010427CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1010427E8(uint64_t a1, int a2, int a3)
{
  int v12 = a2;
  sub_1010421C0(&v10, a3);
  CFStringRef v4 = v10;
  uint64_t v5 = v11;
  if (v10 != v11)
  {
    char v6 = v10;
    do
    {
      int v9 = *v6;
      int v7 = *(void ***)(a1 + 8);
      v13[0] = off_101A80E00;
      v13[1] = &v9;
      uint64_t v13[2] = &v12;
      v13[3] = v13;
      sub_100043ED0((uint64_t)v13, *v7);
      sub_100043E48(v13);
      ++v6;
    }
    while (v6 != v5);
  }
  if (v4) {
    operator delete(v4);
  }
}

void sub_1010428F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_10104291C(uint64_t a1, int a2, int a3, int a4)
{
  int v14 = a4;
  int v15 = a2;
  sub_1010421C0(&v12, a3);
  uint64_t v5 = v12;
  char v6 = v13;
  if (v12 != v13)
  {
    int v7 = v12;
    do
    {
      int v11 = *v7;
      uint64_t v8 = *(void ***)(a1 + 8);
      int v17 = 0;
      int v9 = operator new(0x20uLL);
      *int v9 = off_101A80E80;
      v9[1] = &v11;
      v9[2] = &v14;
      v9[3] = &v15;
      int v17 = v9;
      sub_100043ED0((uint64_t)v16, *v8);
      sub_100043E48(v16);
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_101042A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_101042A64(uint64_t a1, int a2, int a3, char a4)
{
  int v15 = a2;
  char v14 = a4;
  sub_1010421C0(&v12, a3);
  uint64_t v5 = v12;
  char v6 = v13;
  if (v12 != v13)
  {
    int v7 = v12;
    do
    {
      int v11 = *v7;
      uint64_t v8 = *(void ***)(a1 + 8);
      int v17 = 0;
      int v9 = operator new(0x20uLL);
      *int v9 = off_101A80F00;
      v9[1] = &v11;
      v9[2] = &v14;
      v9[3] = &v15;
      int v17 = v9;
      sub_100043ED0((uint64_t)v16, *v8);
      sub_100043E48(v16);
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_101042B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_101042BB0(uint64_t a1, int a2, int a3, int a4)
{
  int v14 = a4;
  int v15 = a2;
  sub_1010421C0(&v12, a3);
  uint64_t v5 = v12;
  char v6 = v13;
  if (v12 != v13)
  {
    int v7 = v12;
    do
    {
      int v11 = *v7;
      uint64_t v8 = *(void ***)(a1 + 8);
      int v17 = 0;
      int v9 = operator new(0x20uLL);
      *int v9 = off_101A80F80;
      v9[1] = &v11;
      v9[2] = &v14;
      v9[3] = &v15;
      int v17 = v9;
      sub_100043ED0((uint64_t)v16, *v8);
      sub_100043E48(v16);
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_101042CC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_101042CF8(uint64_t a1, int a2, int a3, int a4)
{
  int v14 = a4;
  int v15 = a2;
  sub_1010421C0(&v12, a3);
  uint64_t v5 = v12;
  char v6 = v13;
  if (v12 != v13)
  {
    int v7 = v12;
    do
    {
      int v11 = *v7;
      uint64_t v8 = *(void ***)(a1 + 8);
      int v17 = 0;
      int v9 = operator new(0x20uLL);
      *int v9 = off_101A81000;
      v9[1] = &v11;
      v9[2] = &v14;
      v9[3] = &v15;
      int v17 = v9;
      sub_100043ED0((uint64_t)v16, *v8);
      sub_100043E48(v16);
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_101042E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  if (v6) {
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_101042E40(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v16 = a4;
  int v17 = a2;
  int v15 = a5;
  sub_1010421C0(&v13, a3);
  char v6 = v13;
  int v7 = v14;
  if (v13 != v14)
  {
    uint64_t v8 = v13;
    do
    {
      int v12 = *v8;
      int v9 = *(void ***)(a1 + 8);
      char v19 = 0;
      unint64_t v10 = operator new(0x28uLL);
      *unint64_t v10 = off_101A81080;
      v10[1] = &v12;
      void v10[2] = &v16;
      v10[3] = &v15;
      void v10[4] = &v17;
      char v19 = v10;
      sub_100043ED0((uint64_t)v18, *v9);
      sub_100043E48(v18);
      ++v8;
    }
    while (v8 != v7);
  }
  if (v6) {
    operator delete(v6);
  }
}

void sub_101042F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100043E48((uint64_t *)va);
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void sub_101042F94(uint64_t a1, int a2, int a3, int a4, char a5)
{
  int v16 = a4;
  int v17 = a2;
  char v15 = a5;
  sub_1010421C0(&v13, a3);
  char v6 = v13;
  int v7 = v14;
  if (v13 != v14)
  {
    uint64_t v8 = v13;
    do
    {
      int v12 = *v8;
      int v9 = *(void ***)(a1 + 8);
      char v19 = 0;
      unint64_t v10 = operator new(0x28uLL);
      *unint64_t v10 = off_101A81100;
      v10[1] = &v12;
      void v10[2] = &v16;
      v10[3] = &v15;
      void v10[4] = &v17;
      char v19 = v10;
      sub_100043ED0((uint64_t)v18, *v9);
      sub_100043E48(v18);
      ++v8;
    }
    while (v8 != v7);
  }
  if (v6) {
    operator delete(v6);
  }
}

void sub_1010430B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100043E48((uint64_t *)va);
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void sub_1010430E8(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v16 = a4;
  int v17 = a2;
  int v15 = a5;
  sub_1010421C0(&v13, a3);
  char v6 = v13;
  int v7 = v14;
  if (v13 != v14)
  {
    uint64_t v8 = v13;
    do
    {
      int v12 = *v8;
      int v9 = *(void ***)(a1 + 8);
      char v19 = 0;
      unint64_t v10 = operator new(0x28uLL);
      *unint64_t v10 = off_101A81180;
      v10[1] = &v12;
      void v10[2] = &v16;
      v10[3] = &v15;
      void v10[4] = &v17;
      char v19 = v10;
      sub_100043ED0((uint64_t)v18, *v9);
      sub_100043E48(v18);
      ++v8;
    }
    while (v8 != v7);
  }
  if (v6) {
    operator delete(v6);
  }
}

void sub_10104320C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100043E48((uint64_t *)va);
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void *sub_10104323C(uint64_t a1, int a2, __int16 a3)
{
  int v7 = a2;
  __int16 v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81200;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1010432E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043304(uint64_t a1, int a2, __int16 a3)
{
  int v7 = a2;
  __int16 v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81280;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1010433B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010433CC(uint64_t a1, int a2, int a3, char a4)
{
  int v9 = a3;
  int v10 = a2;
  char v8 = a4;
  CFStringRef v4 = *(void ***)(a1 + 8);
  uint64_t v5 = operator new(0x20uLL);
  *uint64_t v5 = off_101A81300;
  v5[1] = &v9;
  void v5[2] = &v8;
  v5[3] = &v10;
  v11[3] = v5;
  sub_100043ED0((uint64_t)v11, *v4);
  return sub_100043E48(v11);
}

void sub_101043484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010434A0(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81380;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_10104354C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043568(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81400;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_101043610(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10104362C(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81480;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1010436D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010436F0(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81500;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_101043794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010437B0(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81580;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_101043858(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043874(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81600;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_10104391C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043938(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81680;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_1010439DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010439F8(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81700;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_101043AA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043ABC(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81780;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_101043B64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043B80(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81800;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_101043C28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043C44(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81880;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_101043CE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043D04(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81900;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_101043DA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043DC4(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A81980;
  v8[1] = &v6;
  _DWORD v8[2] = &v7;
  void v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_101043E6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043E88(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81A00;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_101043F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101043F48(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81A80;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_101043FEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101044008(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81B00;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_1010440AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010440C8(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81B80;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10104416C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101044188(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81C00;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10104422C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101044248(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81C80;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_1010442EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101044308(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81D00;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_1010443AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1010443C8(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81D80;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10104446C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101044488(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A81E00;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_10104452C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

const void **sub_101044548(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v15 = a2;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)int v12 = *(_OWORD *)a4;
    uint64_t v13 = *(void *)(a4 + 16);
  }
  if (SHIBYTE(v13) < 0)
  {
    sub_10004FC84(__dst, v12[0], (unint64_t)v12[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v12;
    uint64_t v18 = v13;
  }
  int v16 = 0;
  if (SHIBYTE(v18) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v20 = v18;
  }
  int v21 = 0;
  if (ctu::cf::convert_copy())
  {
    int v6 = v16;
    int v16 = v21;
    __int16 v22 = v6;
    sub_1000558F4(&v22);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  int v7 = (void *)v16;
  int v14 = v16;
  int v16 = 0;
  sub_1000558F4(&v16);
  if (SHIBYTE(v18) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  id v8 = v7;
  __p[0] = +[CTXPCError errorForCode:a3 errorString:v8];
  int v9 = *(void ***)(a1 + 8);
  v23[0] = off_101A81E80;
  v23[1] = &v15;
  v23[2] = __p;
  v23[3] = v23;
  sub_100043ED0((uint64_t)v23, *v9);
  sub_100043E48(v23);

  return sub_1000558F4(&v14);
}

void sub_101044738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1010447C0(CTXPCSuppServicesNotificationInterface *this)
{
  *(void *)this = off_101A80998;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCSuppServicesNotificationInterface::~CTXPCSuppServicesNotificationInterface(this);
}

void sub_10104481C(CTXPCSuppServicesNotificationInterface *this)
{
  *(void *)this = off_101A80998;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCSuppServicesNotificationInterface::~CTXPCSuppServicesNotificationInterface(this);

  operator delete();
}

void sub_10104488C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1010448F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 320))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101044938(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101044970(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 320))();
  }
  return result;
}

uint64_t sub_1010449A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1010449F0()
{
}

__n128 sub_101044A04(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A80B80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101044A58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80B80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101044A90(unsigned int **a1, id *a2)
{
  id v7 = *a2;
  uint64_t v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallForwardingReason:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setCallClass:v5];

  int v6 = +[CTXPCPlaceholder simSlot:*a1[3]];
  [v7 suppServicesEvent:v6 event:2 settingsType:1 data:v3];
}

void sub_101044B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101044BC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101044C00()
{
}

void sub_101044C10()
{
}

__n128 sub_101044C24(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A80C00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101044C78(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80C00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101044CB0(unsigned int **a1, id *a2)
{
  id v8 = *a2;
  uint64_t v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallForwardingReason:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setCallClass:v5];

  int v6 = +[NSNumber numberWithInt:*a1[3]];
  [v3 setMmiProcedure:v6];

  id v7 = +[CTXPCPlaceholder simSlot:*a1[4]];
  [v8 suppServicesEvent:v7 event:4 settingsType:1 data:v3];
}

void sub_101044DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101044E0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101044E4C()
{
}

void sub_101044E5C()
{
}

__n128 sub_101044E70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = off_101A80C80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 sub_101044ECC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80C80;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101044F0C(uint64_t a1, id *a2)
{
  id v3 = *a2;
  CFStringRef v4 = objc_opt_new();
  int v5 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v4 setCallForwardingReason:v5];

  int v6 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 16)];
  [v4 setCallClass:v6];

  id v7 = +[NSNumber numberWithBool:**(unsigned __int8 **)(a1 + 24)];
  [v4 setEnabled:v7];

  CSIPhoneNumber::getFullNumber((uint64_t *)v17, *(CSIPhoneNumber **)(a1 + 32));
  if (SHIBYTE(v18) < 0)
  {
    sub_10004FC84(__dst, v17[0], (unint64_t)v17[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v17;
    uint64_t v22 = v18;
  }
  uint64_t v20 = 0;
  if (SHIBYTE(v22) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v24 = v22;
  }
  BOOL v25 = 0;
  if (ctu::cf::convert_copy())
  {
    id v8 = v20;
    uint64_t v20 = v25;
    uint64_t v26 = v8;
    sub_1000558F4((const void **)&v26);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  int v9 = v20;
  char v19 = v20;
  uint64_t v20 = 0;
  sub_1000558F4((const void **)&v20);
  if (SHIBYTE(v22) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  if (v9) {
    int v10 = sub_1000810B8;
  }
  else {
    int v10 = 0;
  }
  if (v10) {
    [v4 setCallForwardingNumber:v9];
  }
  if (**(_DWORD **)(a1 + 8) == 2)
  {
    int v11 = **(_DWORD **)(a1 + 40);
    __dst[0] = 0;
    LODWORD(__p[0]) = v11;
    CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, __p);
    if (v12)
    {
      uint64_t v13 = __dst[0];
      __dst[0] = v12;
      __p[0] = v13;
      sub_1000570E8((const void **)__p);
    }
    int v14 = __dst[0];
    uint64_t v26 = __dst[0];
    __dst[0] = 0;
    sub_1000570E8((const void **)__dst);
    if (v14) {
      int v15 = sub_100081E58;
    }
    else {
      int v15 = 0;
    }
    if (v15) {
      [v4 setCallForwardingNoReplyTime:v14];
    }
    sub_1000570E8((const void **)&v26);
  }
  int v16 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 48)];
  [v3 suppServicesEvent:v16 event:1 settingsType:1 data:v4];

  sub_1000558F4(&v19);
}

void sub_1010451BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_1000570E8((const void **)(v34 - 56));
  sub_1000558F4(&a16);

  _Unwind_Resume(a1);
}

uint64_t sub_101045278(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010452B8()
{
}

void sub_1010452C8()
{
}

__n128 sub_1010452DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A80D00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101045330(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80D00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101045368(unsigned int **a1, id *a2)
{
  id v8 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallForwardingReason:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setCallClass:v5];

  int v6 = +[NSNumber numberWithInt:*a1[3]];
  [v3 setMmiProcedure:v6];

  id v7 = +[CTXPCPlaceholder simSlot:*a1[4]];
  [v8 suppServicesEvent:v7 event:3 settingsType:1 data:v3];
}

void sub_101045480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010454C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101045504()
{
}

void sub_101045514()
{
}

__n128 sub_101045528(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A80D80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101045574(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80D80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010455A4(uint64_t a1, id *a2)
{
  id v6 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithBool:**(unsigned __int8 **)(a1 + 8)];
  [v3 setActive:v4];

  int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:5 settingsType:2 data:v3];
}

void sub_10104566C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010456A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010456E8()
{
}

void sub_1010456F8()
{
}

__n128 sub_10104570C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A80E00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101045758(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80E00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101045788(uint64_t a1, id *a2)
{
  id v6 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setCallClass:v4];

  int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:2 settingsType:3 data:v3];
}

void sub_101045850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_10104588C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010458CC()
{
}

void sub_1010458DC()
{
}

__n128 sub_1010458F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A80E80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101045944(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80E80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10104597C(unsigned int **a1, id *a2)
{
  id v7 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setMmiProcedure:v5];

  id v6 = +[CTXPCPlaceholder simSlot:*a1[3]];
  [v7 suppServicesEvent:v6 event:4 settingsType:3 data:v3];
}

void sub_101045A6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101045AAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101045AEC()
{
}

void sub_101045AFC()
{
}

__n128 sub_101045B10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A80F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101045B64(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101045B9C(uint64_t a1, id *a2)
{
  id v7 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithBool:**(unsigned __int8 **)(a1 + 16)];
  [v3 setEnabled:v5];

  id v6 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 24)];
  [v7 suppServicesEvent:v6 event:1 settingsType:3 data:v3];
}

void sub_101045C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101045CCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101045D0C()
{
}

void sub_101045D1C()
{
}

__n128 sub_101045D30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A80F80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101045D84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A80F80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101045DBC(unsigned int **a1, id *a2)
{
  id v7 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setMmiProcedure:v5];

  id v6 = +[CTXPCPlaceholder simSlot:*a1[3]];
  [v7 suppServicesEvent:v6 event:3 settingsType:3 data:v3];
}

void sub_101045EAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101045EEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101045F2C()
{
}

void sub_101045F3C()
{
}

__n128 sub_101045F50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A81000;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101045FA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81000;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101045FDC(unsigned int **a1, id *a2)
{
  id v7 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setCallBarringFacility:v5];

  id v6 = +[CTXPCPlaceholder simSlot:*a1[3]];
  [v7 suppServicesEvent:v6 event:2 settingsType:4 data:v3];
}

void sub_1010460CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_10104610C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10104614C()
{
}

void sub_10104615C()
{
}

__n128 sub_101046170(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A81080;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1010461C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81080;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010461FC(unsigned int **a1, id *a2)
{
  id v8 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setMmiProcedure:v5];

  id v6 = +[NSNumber numberWithInt:*a1[3]];
  [v3 setCallBarringFacility:v6];

  id v7 = +[CTXPCPlaceholder simSlot:*a1[4]];
  [v8 suppServicesEvent:v7 event:4 settingsType:4 data:v3];
}

void sub_101046314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101046358(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101046398()
{
}

void sub_1010463A8()
{
}

__n128 sub_1010463BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A81100;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101046410(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81100;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101046448(uint64_t a1, id *a2)
{
  id v8 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 16)];
  [v3 setCallBarringFacility:v5];

  id v6 = +[NSNumber numberWithBool:**(unsigned __int8 **)(a1 + 24)];
  [v3 setEnabled:v6];

  id v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 32)];
  [v8 suppServicesEvent:v7 event:1 settingsType:4 data:v3];
}

void sub_101046560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010465A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010465E4()
{
}

void sub_1010465F4()
{
}

__n128 sub_101046608(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A81180;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10104665C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101046694(unsigned int **a1, id *a2)
{
  id v8 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:*a1[1]];
  [v3 setCallClass:v4];

  int v5 = +[NSNumber numberWithInt:*a1[2]];
  [v3 setMmiProcedure:v5];

  id v6 = +[NSNumber numberWithInt:*a1[3]];
  [v3 setCallBarringFacility:v6];

  id v7 = +[CTXPCPlaceholder simSlot:*a1[4]];
  [v8 suppServicesEvent:v7 event:3 settingsType:4 data:v3];
}

void sub_1010467AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010467F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101046830()
{
}

void sub_101046840()
{
}

__n128 sub_101046854(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81200;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010468A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81200;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010468D0(uint64_t a1, id *a2)
{
  id v6 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithUnsignedInt:**(unsigned __int16 **)(a1 + 8)];
  [v3 setSupplementaryServiceType:v4];

  int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:3 settingsType:5 data:v3];
}

void sub_101046998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010469D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101046A14()
{
}

void sub_101046A24()
{
}

__n128 sub_101046A38(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81280;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101046A84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81280;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101046AB4(uint64_t a1, id *a2)
{
  id v6 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithUnsignedInt:**(unsigned __int16 **)(a1 + 8)];
  [v3 setSupplementaryServiceType:v4];

  int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:4 settingsType:5 data:v3];
}

void sub_101046B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101046BB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101046BF8()
{
}

void sub_101046C08()
{
}

__n128 sub_101046C1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A81300;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101046C70(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81300;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101046CA8(uint64_t a1, id *a2)
{
  id v8 = *a2;
  id v3 = objc_opt_new();
  CFStringRef v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setCallingLineIdRestriction:v4];

  if (**(unsigned char **)(a1 + 16))
  {
    if (**(unsigned char **)(a1 + 16) == 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = 2;
    }
    id v6 = +[NSNumber numberWithInt:v5];
    [v3 setCallingLineIdRestrictionModification:v6];
  }
  id v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 24)];
  [v8 suppServicesEvent:v7 event:1 settingsType:6 data:v3];
}

void sub_101046DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101046DEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101046E2C()
{
}

void sub_101046E3C()
{
}

__n128 sub_101046E50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81380;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101046E9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81380;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101046ECC(uint64_t a1, id *a2)
{
  id v7 = *a2;
  id v3 = objc_opt_new();
  if (**(unsigned char **)(a1 + 8))
  {
    if (**(unsigned char **)(a1 + 8) == 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = 2;
    }
    uint64_t v5 = +[NSNumber numberWithInt:v4];
    [v3 setCallingLineIdRestrictionModification:v5];
  }
  id v6 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v7 suppServicesEvent:v6 event:2 settingsType:6 data:v3];
}

void sub_101046FA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101046FE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047024()
{
}

void sub_101047034()
{
}

__n128 sub_101047048(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101047094(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010470C4(uint64_t a1, id *a2)
{
  id v6 = *a2;
  id v3 = objc_opt_new();
  uint64_t v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setMmiProcedure:v4];

  uint64_t v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:4 settingsType:6 data:v3];
}

void sub_10104718C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010471C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047208()
{
}

void sub_101047218()
{
}

__n128 sub_10104722C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101047278(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010472A8(uint64_t a1, id *a2)
{
  id v6 = *a2;
  id v3 = objc_opt_new();
  uint64_t v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setMmiProcedure:v4];

  uint64_t v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:3 settingsType:6 data:v3];
}

void sub_101047370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1010473AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010473EC()
{
}

void sub_1010473FC()
{
}

void *sub_101047410(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81500;
  result[1] = v3;
  return result;
}

uint64_t sub_101047458(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81500;
  a2[1] = v2;
  return result;
}

void sub_101047484(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesEvent:v3 event:6 settingsType:6 data:0];
}

void sub_101047504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101047524(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047564()
{
}

void sub_101047574()
{
}

__n128 sub_101047588(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81580;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010475D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81580;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101047604(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setConnectedLineIdRestriction:v4];

  uint64_t v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:1 settingsType:7 data:v3];
}

void sub_1010476CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101047708(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047748()
{
}

void sub_101047758()
{
}

__n128 sub_10104776C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81600;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1010477B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81600;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1010477E8(uint64_t a1, id *a2)
{
  id v5 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  if (**(_DWORD **)(a1 + 16)) {
    uint64_t v4 = 8;
  }
  else {
    uint64_t v4 = 9;
  }
  [v5 suppServicesEvent:v3 event:2 settingsType:v4 data:0];
}

void sub_101047878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101047898(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010478D8()
{
}

void sub_1010478E8()
{
}

void *sub_1010478FC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81680;
  result[1] = v3;
  return result;
}

uint64_t sub_101047944(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81680;
  a2[1] = v2;
  return result;
}

void sub_101047970(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesEvent:v3 event:2 settingsType:7 data:0];
}

void sub_1010479F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101047A10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047A50()
{
}

void sub_101047A60()
{
}

__n128 sub_101047A74(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101047AC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101047AF0(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setConnectedLinePresentation:v4];

  id v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:1 settingsType:9 data:v3];
}

void sub_101047BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101047BF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047C34()
{
}

void sub_101047C44()
{
}

__n128 sub_101047C58(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101047CA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101047CD4(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setCallingLinePresentation:v4];

  id v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:1 settingsType:8 data:v3];
}

void sub_101047D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101047DD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047E18()
{
}

void sub_101047E28()
{
}

__n128 sub_101047E3C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101047E88(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101047EB8(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setCallingLinePresentation:v4];

  id v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:3 settingsType:8 data:v3];
}

void sub_101047F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101047FBC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101047FFC()
{
}

void sub_10104800C()
{
}

void *sub_101048020(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81880;
  result[1] = v3;
  return result;
}

uint64_t sub_101048068(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81880;
  a2[1] = v2;
  return result;
}

void sub_101048094(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesEvent:v3 event:4 settingsType:8 data:0];
}

void sub_101048114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048134(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101048174()
{
}

void sub_101048184()
{
}

void *sub_101048198(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81900;
  result[1] = v3;
  return result;
}

uint64_t sub_1010481E0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81900;
  a2[1] = v2;
  return result;
}

void sub_10104820C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesEvent:v3 event:2 settingsType:11 data:0];
}

void sub_10104828C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1010482AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010482EC()
{
}

void sub_1010482FC()
{
}

__n128 sub_101048310(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10104835C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10104838C(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = +[NSNumber numberWithBool:**(_DWORD **)(a1 + 8) != 0];
  [v3 setCallingNamePresentation:v4];

  id v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 suppServicesEvent:v5 event:1 settingsType:11 data:v3];
}

void sub_10104845C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFNumberRef v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_101048498(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010484D8()
{
}

void sub_1010484E8()
{
}

void *sub_1010484FC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81A00;
  result[1] = v3;
  return result;
}

uint64_t sub_101048544(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81A00;
  a2[1] = v2;
  return result;
}

void sub_101048570(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 spcUnlockSuccessful:v3];
}

void sub_1010485E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048604(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101048644()
{
}

void sub_101048654()
{
}

void *sub_101048668(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81A80;
  result[1] = v3;
  return result;
}

uint64_t sub_1010486B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81A80;
  a2[1] = v2;
  return result;
}

void sub_1010486DC(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 phoneBookSelected:v3];
}

void sub_101048750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048770(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010487B0()
{
}

void sub_1010487C0()
{
}

void *sub_1010487D4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81B00;
  result[1] = v3;
  return result;
}

uint64_t sub_10104881C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81B00;
  a2[1] = v2;
  return result;
}

void sub_101048848(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 phoneBookFetched:v3];
}

void sub_1010488BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1010488DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10104891C()
{
}

void sub_10104892C()
{
}

void *sub_101048940(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81B80;
  result[1] = v3;
  return result;
}

uint64_t sub_101048988(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81B80;
  a2[1] = v2;
  return result;
}

void sub_1010489B4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 phoneBookWritten:v3];
}

void sub_101048A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101048A88()
{
}

void sub_101048A98()
{
}

void *sub_101048AAC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81C00;
  result[1] = v3;
  return result;
}

uint64_t sub_101048AF4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81C00;
  a2[1] = v2;
  return result;
}

void sub_101048B20(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 phoneBookError:v3];
}

void sub_101048B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048BB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101048BF4()
{
}

void sub_101048C04()
{
}

void *sub_101048C18(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81C80;
  result[1] = v3;
  return result;
}

uint64_t sub_101048C60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81C80;
  a2[1] = v2;
  return result;
}

void sub_101048C8C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 phoneNumberAvailable:v3];
}

void sub_101048D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048D20(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101048D60()
{
}

void sub_101048D70()
{
}

void *sub_101048D84(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81D00;
  result[1] = v3;
  return result;
}

uint64_t sub_101048DCC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81D00;
  a2[1] = v2;
  return result;
}

void sub_101048DF8(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 phoneNumberChanged:v3];
}

void sub_101048E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048E8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101048ECC()
{
}

void sub_101048EDC()
{
}

void *sub_101048EF0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81D80;
  result[1] = v3;
  return result;
}

uint64_t sub_101048F38(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81D80;
  a2[1] = v2;
  return result;
}

void sub_101048F64(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesStarted:v3];
}

void sub_101048FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101048FF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101049038()
{
}

void sub_101049048()
{
}

void *sub_10104905C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A81E00;
  result[1] = v3;
  return result;
}

uint64_t sub_1010490A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A81E00;
  a2[1] = v2;
  return result;
}

void sub_1010490D0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesCompleted:v3];
}

void sub_101049144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101049164(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010491A4()
{
}

void sub_1010491B4()
{
}

__n128 sub_1010491C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A81E80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_101049214(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A81E80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101049244(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 suppServicesError:v3 error:**(void **)(a1 + 16)];
}

void sub_1010492C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1010492E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101049320()
{
}

void *sub_101049334(void *a1, NSObject **a2, uint64_t *a3)
{
  *a1 = off_101A81F38;
  id v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, "cp.meta.helper");
  sub_10104946C(v6, a2, &v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *a1 = off_101A81F00;
  uint64_t v7 = *a3;
  a1[6] = *a3;
  uint64_t v8 = a3[1];
  a1[7] = v8;
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = a1[6];
  }
  if (!v7) {
    __assert_rtn("CellularPlanMetaDataHelperImpl", "CellularPlanMetaDataHelper.mm", 31, "fSettings && \"settings is null\"");
  }
  return a1;
}

void sub_10104942C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10104946C(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  id v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1010494D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_1010494F8(void *a1)
{
  *a1 = off_101A81F00;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_10104955C(void *a1)
{
  sub_1010494F8(a1);

  operator delete();
}

uint64_t sub_101049594(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
  uint64_t v7 = v6;
  if (v6) {
    *((_DWORD *)v6 + 3) = 0;
  }
  __src = 0;
  unsigned int v27 = 0;
  if (*(void *)(a2 + 24))
  {
    uint64_t v8 = (uint64_t *)(a2 + 16);
    while (1)
    {
      uint64_t v8 = (uint64_t *)*v8;
      if (!v8)
      {
        int v22 = sub_100463664(v7, &__src, &v27);
        if (v22)
        {
          int v23 = v22;
          uint64_t v24 = *(NSObject **)(a1 + 40);
          uint64_t v18 = 0;
          if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_49;
          }
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v23;
          char v19 = "#E Buffer creation failure (encodeDeviceInfo): %d";
          uint64_t v20 = v24;
          uint32_t v21 = 8;
          goto LABEL_48;
        }
        a3[1] = *a3;
        if (__src)
        {
          sub_10006E4A8(a3, (char *)__src, (char *)__src + v27, v27);
          free(__src);
        }
        uint64_t v18 = 1;
        if (v7) {
          goto LABEL_50;
        }
        return v18;
      }
      int v9 = v8 + 2;
      if (*((char *)v8 + 39) < 0)
      {
        sub_10004FC84(buf, (void *)v8[2], v8[3]);
      }
      else
      {
        *(_OWORD *)std::string buf = *v9;
        uint64_t v30 = v8[4];
      }
      if (*((char *)v8 + 63) < 0)
      {
        sub_10004FC84(&__p, (void *)v8[5], v8[6]);
      }
      else
      {
        long long __p = *(_OWORD *)(v8 + 5);
        uint64_t v32 = v8[7];
      }
      OsLogContext v10 = (uint64_t *)malloc_type_calloc(0x10uLL, 1uLL, 0xBCCD4226uLL);
      int v11 = v10;
      if (v10) {
        *((_DWORD *)v10 + 3) = 0;
      }
      CFNumberRef v12 = v30 >= 0 ? buf : *(uint8_t **)buf;
      unsigned int v13 = v30 >= 0 ? HIBYTE(v30) : *(_DWORD *)&buf[8];
      if (!sub_1004632FC(v10, 0, 0xCu, v12, v13, 0))
      {
        int v14 = v32 >= 0 ? &__p : (long long *)__p;
        unsigned int v15 = v32 >= 0 ? HIBYTE(v32) : DWORD2(__p);
        if (!sub_1004632FC(v11, 0, 0xCu, v14, v15, 0)) {
          break;
        }
      }
      BOOL v16 = 0;
      if (v11) {
        goto LABEL_29;
      }
LABEL_30:
      if (SHIBYTE(v32) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v30) < 0)
      {
        operator delete(*(void **)buf);
        if (!v16)
        {
LABEL_44:
          BOOL v25 = *(NSObject **)(a1 + 40);
          uint64_t v18 = 0;
          if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_49;
          }
          if (*((char *)v8 + 39) < 0) {
            int v9 = *(_OWORD **)v9;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v9;
          char v19 = "#E Failure adding key (%s)";
          uint64_t v20 = v25;
          uint32_t v21 = 12;
          goto LABEL_48;
        }
      }
      else if (!v16)
      {
        goto LABEL_44;
      }
    }
    BOOL v16 = sub_100463720(v11, v7, 0, 0x10u) == 0;
    if (!v11) {
      goto LABEL_30;
    }
LABEL_29:
    sub_100463290(v11);
    goto LABEL_30;
  }
  int v17 = *(NSObject **)(a1 + 40);
  uint64_t v18 = 0;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    char v19 = "#E No device information";
    uint64_t v20 = v17;
    uint32_t v21 = 2;
LABEL_48:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
    uint64_t v18 = 0;
  }
LABEL_49:
  if (v7) {
LABEL_50:
  }
    sub_100463290(v7);
  return v18;
}

void sub_1010498DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (v16) {
    sub_100463290(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10104992C(double *a1, uint64_t a2, unint64_t *a3)
{
  sub_10024081C(a3, a1[2] > 0.0, 1uLL);
  unsigned int v5 = vcvtad_u64_f64(fabs(a1[2]) * 2097151.0 / 90.0);
  sub_10024081C(a3, BYTE2(v5), 5uLL);
  sub_10024081C(a3, BYTE1(v5), 8uLL);
  sub_10024081C(a3, v5, 8uLL);
  sub_10024081C(a3, a1[1] > 0.0, 1uLL);
  unsigned int v6 = vcvtad_u64_f64(fabs(a1[1]) * 4194303.0 / 180.0);
  sub_10024081C(a3, BYTE2(v6), 6uLL);
  sub_10024081C(a3, BYTE1(v6), 8uLL);
  sub_10024081C(a3, v6, 8uLL);
  double v7 = a1[4] + 450.0;
  if (v7 < 0.0) {
    double v7 = 0.0;
  }
  if (v7 <= 9350.0) {
    double v8 = v7 * 2047.0 / 9350.0;
  }
  else {
    double v8 = 2047.0;
  }
  unsigned int v9 = llround(v8);
  sub_10024081C(a3, v9 >> 8, 3uLL);
  sub_10024081C(a3, v9, 8uLL);
  int v10 = sub_101049AFC(ceil(a1[7] + 3.4));
  sub_10024081C(a3, v10, 4uLL);
  double v11 = a1[8];
  double v12 = 2.3;
  if (v11 <= 0.0) {
    double v12 = 0.0;
  }
  int v13 = sub_101049AFC(ceil(v11 + v12));

  sub_10024081C(a3, v13, 4uLL);
}

uint64_t sub_101049AFC(double a1)
{
  uint64_t v2 = operator new(0x78uLL);
  uint64_t v3 = 0;
  v2[14] = 0x408F400000000000;
  *((_OWORD *)v2 + 4) = xmmword_1015B3700;
  *((_OWORD *)v2 + 5) = unk_1015B3710;
  *((_OWORD *)v2 + 6) = xmmword_1015B3720;
  *(_OWORD *)uint64_t v2 = xmmword_1015B36C0;
  *((_OWORD *)v2 + 1) = unk_1015B36D0;
  *((_OWORD *)v2 + 2) = xmmword_1015B36E0;
  *((_OWORD *)v2 + 3) = unk_1015B36F0;
  do
  {
    if (*(double *)&v2[v3] >= a1) {
      break;
    }
    ++v3;
  }
  while (v3 != 15);
  operator delete(v2);
  return v3;
}

void sub_101049B80(EmergencyNumbersModelFactoryInterface *a1)
{
  *(void *)a1 = off_101A82018;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  EmergencyNumbersModelFactoryInterface::~EmergencyNumbersModelFactoryInterface(a1);
}

void sub_101049BE0(EmergencyNumbersModelFactoryInterface *a1)
{
  sub_101049B80(a1);

  operator delete();
}

void sub_101049C18(uint64_t a1@<X0>, uint64_t a2@<X1>, NSObject **a3@<X2>, _OWORD *a4@<X8>)
{
  unsigned int v6 = (capabilities::ct *)(a1 + 8);
  double v7 = *a3;
  if (*a3) {
    dispatch_retain(v7);
  }
  double v8 = *(std::__shared_weak_count **)(a2 + 8);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100BA6E14(v6, &v9);
  *a4 = v9;
  long long v9 = 0uLL;
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_101049CB4(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_101049CD8(uint64_t a1)
{
  sub_100C62700(a1, "kModifyLogSettings", (unint64_t)sub_101049D6C, 0xEu);
  sub_100C62700(a1, "kModuleOperation", (unint64_t)sub_10104A404, 0xEu);

  return sub_100C62700(a1, "kCSIPropertyOperation", (unint64_t)nullsub_4471, 0xEu);
}

void sub_101049D6C(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, xpc_object_t **a5)
{
  if (xpc_dictionary_get_value(*a4, "kGetLogDomains"))
  {
    pthread_mutex_lock(&stru_101B0B0D0);
    uint64_t v7 = qword_101B0B110;
    if (!qword_101B0B110)
    {
      double v8 = (std::__shared_weak_count *)qword_101B0B118;
      qword_101B0B110 = 0;
      qword_101B0B118 = 0;
      if (!v8)
      {
        uint64_t v7 = 0;
        long long v9 = 0;
        goto LABEL_20;
      }
      sub_10004D2C8(v8);
      uint64_t v7 = qword_101B0B110;
    }
    long long v9 = (std::__shared_weak_count *)qword_101B0B118;
    if (qword_101B0B118)
    {
      char v10 = 0;
      atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_101B0B118 + 8), 1uLL, memory_order_relaxed);
LABEL_21:
      pthread_mutex_unlock(&stru_101B0B0D0);
      if (!v7) {
        goto LABEL_47;
      }
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 1174405120;
      void block[2] = sub_10104A8DC;
      block[3] = &unk_101A82050;
      void block[4] = v7;
      std::string::size_type v46 = v9;
      if ((v10 & 1) == 0) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v17 = (std::__shared_weak_count *)a5[1];
      int v47 = *a5;
      BOOL v48 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(global_queue, block);
      if (v48) {
        sub_10004D2C8(v48);
      }
      uint64_t v18 = v46;
      if (!v46) {
        goto LABEL_47;
      }
      goto LABEL_46;
    }
LABEL_20:
    char v10 = 1;
    goto LABEL_21;
  }
  if (xpc_dictionary_get_value(*a4, "kGetLogConfig"))
  {
    pthread_mutex_lock(&stru_101B0B0D0);
    uint64_t v11 = qword_101B0B110;
    if (!qword_101B0B110)
    {
      double v12 = (std::__shared_weak_count *)qword_101B0B118;
      qword_101B0B110 = 0;
      qword_101B0B118 = 0;
      if (!v12)
      {
        uint64_t v11 = 0;
        long long v9 = 0;
        goto LABEL_37;
      }
      sub_10004D2C8(v12);
      uint64_t v11 = qword_101B0B110;
    }
    long long v9 = (std::__shared_weak_count *)qword_101B0B118;
    if (qword_101B0B118)
    {
      char v10 = 0;
      atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_101B0B118 + 8), 1uLL, memory_order_relaxed);
LABEL_38:
      pthread_mutex_unlock(&stru_101B0B0D0);
      if (!v11) {
        goto LABEL_47;
      }
      int v23 = dispatch_get_global_queue(0, 0);
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 1174405120;
      v41[2] = sub_10104AA04;
      v41[3] = &unk_101A82080;
      v41[4] = v11;
      uint64_t v42 = v9;
      if ((v10 & 1) == 0) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v24 = (std::__shared_weak_count *)a5[1];
      unint64_t v43 = *a5;
      uint64_t v44 = v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(v23, v41);
      if (v44) {
        sub_10004D2C8(v44);
      }
      uint64_t v18 = v42;
      if (!v42)
      {
LABEL_47:
        if (v10) {
          return;
        }
        goto LABEL_48;
      }
LABEL_46:
      sub_10004D2C8(v18);
      goto LABEL_47;
    }
LABEL_37:
    char v10 = 1;
    goto LABEL_38;
  }
  if (!xpc_dictionary_get_value(*a4, "kSetLogConfig"))
  {
    if (xpc_dictionary_get_value(*a4, "kResetLogConfig"))
    {
      pthread_mutex_lock(&stru_101B0B0D0);
      char v19 = (ctu::LogServer *)qword_101B0B110;
      if (!qword_101B0B110)
      {
        uint64_t v20 = (std::__shared_weak_count *)qword_101B0B118;
        qword_101B0B110 = 0;
        qword_101B0B118 = 0;
        if (!v20)
        {
          char v19 = 0;
          uint32_t v21 = 0;
          goto LABEL_79;
        }
        sub_10004D2C8(v20);
        char v19 = (ctu::LogServer *)qword_101B0B110;
      }
      uint32_t v21 = (std::__shared_weak_count *)qword_101B0B118;
      if (qword_101B0B118)
      {
        char v22 = 0;
        atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_101B0B118 + 8), 1uLL, memory_order_relaxed);
        goto LABEL_80;
      }
LABEL_79:
      char v22 = 1;
LABEL_80:
      pthread_mutex_unlock(&stru_101B0B0D0);
      if (v19) {
        sub_100F342F4(v19);
      }
LABEL_86:
      if ((v22 & 1) == 0)
      {
        sub_10004D2C8(v21);
      }
      return;
    }
    if (!xpc_dictionary_get_value(*a4, "kSaveLogConfig"))
    {
      if (xpc_dictionary_get_value(*a4, "kGetSavedLogConfig"))
      {
        sub_100F33964(&v29);
        char v38 = *a5;
        std::string::size_type v39 = "kGetSavedLogConfig";
        sub_10014E03C((uint64_t)&v38, &v29, &v30);
        xpc_release(v30);
        xpc_object_t v30 = 0;
        xpc_release(v29);
      }
      return;
    }
    pthread_mutex_lock(&stru_101B0B0D0);
    BOOL v25 = (ctu::LogServer *)qword_101B0B110;
    if (!qword_101B0B110)
    {
      uint64_t v26 = (std::__shared_weak_count *)qword_101B0B118;
      qword_101B0B110 = 0;
      qword_101B0B118 = 0;
      if (!v26)
      {
        BOOL v25 = 0;
        uint32_t v21 = 0;
        goto LABEL_83;
      }
      sub_10004D2C8(v26);
      BOOL v25 = (ctu::LogServer *)qword_101B0B110;
    }
    uint32_t v21 = (std::__shared_weak_count *)qword_101B0B118;
    if (qword_101B0B118)
    {
      char v22 = 0;
      atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_101B0B118 + 8), 1uLL, memory_order_relaxed);
      goto LABEL_84;
    }
LABEL_83:
    char v22 = 1;
LABEL_84:
    pthread_mutex_unlock(&stru_101B0B0D0);
    if (v25) {
      sub_100F3413C(v25);
    }
    goto LABEL_86;
  }
  pthread_mutex_lock(&stru_101B0B0D0);
  uint64_t v13 = qword_101B0B110;
  if (!qword_101B0B110)
  {
    int v14 = (std::__shared_weak_count *)qword_101B0B118;
    qword_101B0B110 = 0;
    qword_101B0B118 = 0;
    if (!v14)
    {
      uint64_t v13 = 0;
      long long v9 = 0;
      goto LABEL_57;
    }
    sub_10004D2C8(v14);
    uint64_t v13 = qword_101B0B110;
  }
  long long v9 = (std::__shared_weak_count *)qword_101B0B118;
  if (!qword_101B0B118)
  {
LABEL_57:
    char v15 = 1;
    goto LABEL_58;
  }
  char v15 = 0;
  atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_101B0B118 + 8), 1uLL, memory_order_relaxed);
LABEL_58:
  pthread_mutex_unlock(&stru_101B0B0D0);
  std::string::size_type v39 = "kSetLogConfig";
  xpc_object_t object = 0;
  char v38 = a4;
  sub_10000CB28((uint64_t)&v38, &object);
  if (v13 && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unsigned int v27 = dispatch_get_global_queue(0, 0);
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 1174405120;
    _OWORD v33[2] = sub_10104AAA8;
    v33[3] = &unk_101A820B0;
    uint8_t v33[4] = v13;
    uint64_t v34 = v9;
    if ((v15 & 1) == 0) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v35 = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t v35 = xpc_null_create();
    }
    uint64_t v28 = (std::__shared_weak_count *)a5[1];
    uint64_t v36 = *a5;
    uint32_t v37 = v28;
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_async(v27, v33);
    if (v37) {
      sub_10004D2C8(v37);
    }
    xpc_release(v35);
    xpc_object_t v35 = 0;
    if (v34) {
      sub_10004D2C8(v34);
    }
  }
  else
  {
    xpc_object_t v31 = xpc_BOOL_create(0);
    if (!v31) {
      xpc_object_t v31 = xpc_null_create();
    }
    char v38 = *a5;
    std::string::size_type v39 = "kSetLogConfig";
    sub_100035E70((uint64_t)&v38, &v31, &v32);
    xpc_release(v32);
    xpc_object_t v32 = 0;
    xpc_release(v31);
    xpc_object_t v31 = 0;
  }
  xpc_release(object);
  if ((v15 & 1) == 0) {
LABEL_48:
  }
    sub_10004D2C8(v9);
}

void sub_10104A394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t object)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_10104A404(Registry **a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  v29[0] = a4;
  v29[1] = "kModuleOperation";
  if (sub_10104AC58((uint64_t)v29, "get"))
  {
    long long v27 = 0uLL;
    uint64_t v28 = 0;
    xpc_object_t v24 = a4;
    char v25 = "kModuleResourcePath";
    sub_100048BAC((uint64_t)&v24, &v26);
    xpc_object_t v30 = 0;
    xpc_object_t v31 = 0;
    uint64_t v32 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v32) < 0) {
      operator delete(v30);
    }
    xpc_release(v26);
    xpc_object_t v24 = 0;
    xpc_object_t v30 = a4;
    xpc_object_t v31 = (std::__shared_weak_count *)"kModuleValue";
    sub_100048BAC((uint64_t)&v30, &v24);
    uint64_t v8 = HIBYTE(v28);
    if (v28 < 0) {
      uint64_t v8 = *((void *)&v27 + 1);
    }
    if (v8)
    {
      Registry::getRestServer((uint64_t *)&v30, *a1);
      long long v9 = (uint64_t *)v30;
      if (SHIBYTE(v28) < 0)
      {
        sub_10004FC84(&__p, (void *)v27, *((unint64_t *)&v27 + 1));
      }
      else
      {
        long long __p = v27;
        uint64_t v23 = v28;
      }
      xpc_object_t object = v24;
      if (v24) {
        xpc_retain(v24);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 1174405120;
      v19[2] = sub_10104ACFC;
      v19[3] = &unk_101A820E0;
      double v12 = (std::__shared_weak_count *)a5[1];
      _OWORD v19[4] = *a5;
      uint64_t v20 = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1011D7C38(v9, &__p, &object, (uint64_t)v19);
      xpc_release(object);
      xpc_object_t object = 0;
      if (SHIBYTE(v23) < 0) {
        operator delete((void *)__p);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
      if (v20) {
        sub_10004D2C8(v20);
      }
    }
    xpc_release(v24);
  }
  else
  {
    if (!sub_10104AC58((uint64_t)v29, "set")) {
      return;
    }
    long long v27 = 0uLL;
    uint64_t v28 = 0;
    xpc_object_t v24 = a4;
    char v25 = "kModuleResourcePath";
    sub_100048BAC((uint64_t)&v24, &v26);
    xpc_object_t v30 = 0;
    xpc_object_t v31 = 0;
    uint64_t v32 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v32) < 0) {
      operator delete(v30);
    }
    xpc_release(v26);
    xpc_object_t v24 = 0;
    xpc_object_t v30 = a4;
    xpc_object_t v31 = (std::__shared_weak_count *)"kModuleValue";
    sub_100048BAC((uint64_t)&v30, &v24);
    uint64_t v10 = HIBYTE(v28);
    if (v28 < 0) {
      uint64_t v10 = *((void *)&v27 + 1);
    }
    if (v10)
    {
      Registry::getRestServer((uint64_t *)&v30, *a1);
      uint64_t v11 = (uint64_t *)v30;
      if (SHIBYTE(v28) < 0)
      {
        sub_10004FC84(__dst, (void *)v27, *((unint64_t *)&v27 + 1));
      }
      else
      {
        *(_OWORD *)std::string __dst = v27;
        uint64_t v18 = v28;
      }
      xpc_object_t v16 = v24;
      if (v24) {
        xpc_retain(v24);
      }
      else {
        xpc_object_t v16 = xpc_null_create();
      }
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 1174405120;
      v14[2] = sub_10104AD80;
      v14[3] = &unk_101A82110;
      uint64_t v13 = (std::__shared_weak_count *)a5[1];
      void v14[4] = *a5;
      char v15 = v13;
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1011D8274(v11, (long long *)__dst, &v16, (uint64_t)v14);
      xpc_release(v16);
      xpc_object_t v16 = 0;
      if (SHIBYTE(v18) < 0) {
        operator delete(__dst[0]);
      }
      if (v31) {
        sub_10004D2C8(v31);
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    xpc_release(v24);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete((void *)v27);
  }
}

void sub_10104A798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint32_t v37 = *(std::__shared_weak_count **)(v35 - 64);
  if (v37) {
    sub_10004D2C8(v37);
  }
  xpc_release(*(xpc_object_t *)(v35 - 136));
  if (*(char *)(v35 - 89) < 0) {
    operator delete(*(void **)(v35 - 112));
  }
  _Unwind_Resume(a1);
}

void sub_10104A8DC(uint64_t a1)
{
  xpc_object_t v5 = 0;
  ctu::LogServer::getConfig((uint64_t *)&v5, *(ctu::LogServer **)(a1 + 32));
  xpc_object_t v3 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  v2[0] = *(void *)(a1 + 48);
  v2[1] = "kGetLogDomains";
  sub_10014E03C((uint64_t)v2, &v3, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v3);
  xpc_object_t v3 = 0;
  xpc_release(v5);
}

void *sub_10104A980(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10104A9B4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_10104AA04(uint64_t a1)
{
  xpc_object_t v5 = 0;
  ctu::LogServer::getSimpleConfig((uint64_t *)&v5, *(ctu::LogServer **)(a1 + 32));
  xpc_object_t v3 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  v2[0] = *(void *)(a1 + 48);
  v2[1] = "kGetLogConfig";
  sub_10014E03C((uint64_t)v2, &v3, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v3);
  xpc_object_t v3 = 0;
  xpc_release(v5);
}

void sub_10104AAA8(void *a1)
{
  uint64_t v2 = (ctu::LogServer *)a1[4];
  xpc_object_t v3 = (void *)a1[6];
  xpc_object_t v8 = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v8 = xpc_null_create();
  }
  v4.fObj.fObuint64_t j = (dispatch_object_s *)&v8;
  ctu::LogServer::updateConfig(v2, v4);
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_object_t v6 = xpc_BOOL_create(1);
  if (!v6) {
    xpc_object_t v6 = xpc_null_create();
  }
  v5[0] = a1[7];
  v5[1] = "kSetLogConfig";
  sub_100035E70((uint64_t)v5, &v6, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v6);
}

void sub_10104AB68(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 24));
  _Unwind_Resume(a1);
}

xpc_object_t sub_10104AB84(void *a1, void *a2)
{
  uint64_t v4 = a2[5];
  a1[4] = a2[4];
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  xpc_object_t v5 = (void *)a2[6];
  a1[6] = v5;
  if (v5)
  {
    xpc_object_t result = xpc_retain(v5);
  }
  else
  {
    xpc_object_t result = xpc_null_create();
    a1[6] = result;
  }
  uint64_t v7 = a2[8];
  a1[7] = a2[7];
  a1[8] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10104ABF8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

BOOL sub_10104AC58(uint64_t a1, const char *a2)
{
  xpc_object_t object1 = 0;
  sub_100048BAC(a1, &object1);
  xpc_object_t v3 = xpc_string_create(a2);
  if (!v3) {
    xpc_object_t v3 = xpc_null_create();
  }
  BOOL v4 = xpc_equal(object1, v3);
  xpc_release(v3);
  xpc_release(object1);
  return v4;
}

void sub_10104ACD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(v10);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_10104ACFC(uint64_t a1, void **a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v5 = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  v4[0] = *(void *)(a1 + 32);
  v4[1] = "kModuleValue";
  sub_100035E70((uint64_t)v4, &v5, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v5);
}

void sub_10104AD80(uint64_t a1, void **a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v5 = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  v4[0] = *(void *)(a1 + 32);
  v4[1] = "kModuleValue";
  sub_100035E70((uint64_t)v4, &v5, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v5);
}

uint64_t sub_10104AE04()
{
  if ((byte_101B0B120 & 1) == 0)
  {
    byte_101B0B120 = 1;
    return __cxa_atexit((void (*)(void *))sub_100B15780, &unk_101B0B0D0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_10104AE40()
{
  return sub_100C624B8((uint64_t)&unk_101B130C8, (uint64_t)sub_101049CD8);
}

const char *sub_10104AE5C(int a1)
{
  uint64_t v1 = "wea.cfg.?";
  if (a1 == 2) {
    uint64_t v1 = "wea.2";
  }
  if (a1 == 1) {
    return "wea.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10104AE88(uint64_t a1)
{
  sub_100060644((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 24), 0);
  BOOL v4 = *(NSObject **)(a1 + 16);
  if (v4) {
    dispatch_release(v4);
  }
  xpc_object_t v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

CFStringRef CellBroadcastConfig::getEnhancedDeliveryPrefKey@<X0>(const __CFString *a1@<X1>, CFStringRef *a2@<X8>)
{
  CFStringRef result = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", a1, @"EnhancedDeliveryPref");
  *a2 = result;
  return result;
}

void CellBroadcastConfig::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10104B620(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, NotifySubscription *a9, ctu::OsLogLogger *a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, uint64_t a16, dispatch_object_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

const void **sub_10104B954(void *a1, Registry **a2, uint64_t a3)
{
  CFTypeRef cf = 0;
  sub_1007EC524(a2, a3, 2, @"CellBroadcast", 0, 0, &v5);
  sub_10004EFE4(&cf, &v5);
  sub_1000577C4(&v5);
  sub_100062708(a1, cf);
  return sub_100057D78(&cf);
}

void sub_10104B9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **sub_10104B9E0(void *a1, Registry **a2, uint64_t a3, const void *a4, const void *a5)
{
  CFDictionaryRef theDict = 0;
  sub_10104B954(&v13, a2, a3);
  sub_10004EFE4(&theDict, &v13);
  sub_1000577C4(&v13);
  if (theDict) {
    xpc_object_t v8 = sub_100080778;
  }
  else {
    xpc_object_t v8 = 0;
  }
  if (v8)
  {
    Value = CFDictionaryGetValue(theDict, a4);
    uint64_t v10 = Value;
    uint64_t v13 = Value;
    if (Value)
    {
      uint64_t v11 = sub_100080934;
      CFRetain(Value);
    }
    else
    {
      uint64_t v11 = 0;
    }
    if (v11)
    {
      *a1 = v10;
      uint64_t v13 = 0;
    }
    else
    {
      sub_100062708(a1, a5);
    }
    sub_1000577C4(&v13);
  }
  else
  {
    sub_100062708(a1, a5);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_10104BADC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10104BB00(uint64_t result, int a2)
{
  if (a2 == 2)
  {
    uint64_t v16 = v2;
    uint64_t v17 = v3;
    uint64_t v4 = result;
    if (*(_DWORD *)(result + 512) == 1)
    {
      CFStringRef result = subscriber::makeSimSlotRange();
      xpc_object_t v6 = v13;
      xpc_object_t v5 = v14;
      if (v13 != v14)
      {
        uint64_t v7 = v15;
        while (1)
        {
          CFStringRef result = v15(*v6);
          if (result) {
            break;
          }
          if (++v6 == v14)
          {
            xpc_object_t v6 = v14;
            break;
          }
        }
        xpc_object_t v8 = v14;
        while (v6 != v8)
        {
          uint64_t v9 = *v6;
          CFStringRef result = sub_10104BC90(v4, v9);
          if (result)
          {
            uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v9);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v12 = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Invalidating all Cell Broadcast Messages", (uint8_t *)&v12, 2u);
            }
            CFStringRef result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 176) + 24))(*(void *)(v4 + 176), v9);
          }
          uint64_t v11 = v6 + 1;
          xpc_object_t v6 = v5;
          if (v11 != v5)
          {
            xpc_object_t v6 = v11;
            while (1)
            {
              CFStringRef result = v7(*v6);
              if (result) {
                break;
              }
              if (++v6 == v5)
              {
                xpc_object_t v6 = v5;
                break;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10104BC90(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef theDict = 0;
  sub_10104B9E0(&v12, *(Registry ***)(a1 + 368), a2, @"MessageValidityPeriod", 0);
  sub_10004EFE4(&theDict, &v12);
  sub_1000577C4(&v12);
  if (theDict) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    Value = (BOOL *)CFDictionaryGetValue(theDict, @"AirplaneMode");
    xpc_object_t v5 = Value;
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 == CFBooleanGetTypeID())
      {
        LOBYTE(v12) = 0;
        ctu::cf::assign((ctu::cf *)&v12, v5, v7);
        if (!(_BYTE)v12)
        {
          uint64_t v9 = 1;
          goto LABEL_13;
        }
      }
    }
    xpc_object_t v8 = *(NSObject **)(a1 + 40);
    uint64_t v9 = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      uint64_t v10 = "#I No Airplane mode invalidation in the operator bundle";
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v12, 2u);
      uint64_t v9 = 0;
    }
  }
  else
  {
    xpc_object_t v8 = *(NSObject **)(a1 + 40);
    uint64_t v9 = 0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      uint64_t v10 = "#I No information on validity period in the operator bundle";
      goto LABEL_12;
    }
  }
LABEL_13:
  sub_100057D78((const void **)&theDict);
  return v9;
}

void sub_10104BDE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_10104BE04(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10105A3DC;
  uint64_t v7[3] = &unk_101A82898;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  xpc_object_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005B554;
    __int16 v12 = &unk_101A828D8;
    uint64_t v13 = &v15;
    int v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A7F0;
    __int16 v12 = &unk_101A828B8;
    uint64_t v13 = &v15;
    int v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_10104BF3C(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10105A3EC;
  uint64_t v7[3] = &unk_101A828F8;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  xpc_object_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10105A9A4;
    __int16 v12 = &unk_101A82938;
    uint64_t v13 = a3;
    int v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10105A92C;
    __int16 v12 = &unk_101A82918;
    uint64_t v13 = a3;
    int v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

uint64_t sub_10104C060(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (sub_10104C2DC((capabilities::ct *)a1))
  {
    *(void *)std::string buf = 0;
    sub_10104B9E0(&v8, *(Registry ***)(a1 + 368), a2, @"AlertTypes", 0);
    sub_10004EFE4(buf, &v8);
    sub_1000577C4(&v8);
    uint64_t v5 = *(void *)buf;
    *(void *)std::string buf = 0;
    sub_100057D78((const void **)buf);
  }
  else
  {
    int v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Copy Cell Broadcast Alert Types: Device does not support CMAS", buf, 2u);
    }
    return 0;
  }
  return v5;
}

void sub_10104C15C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10104C170(uint64_t a1)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  Registry::getMobileHelper(&v9, *(Registry **)(a1 + 240));
  if (v9)
  {
    *(void *)std::string buf = 0;
    (*(void (**)(const void **__return_ptr))(*(void *)v9 + 16))(&v7);
    sub_1000057AC(buf, &v7);
    sub_1000577C4(&v7);
    if (*(void *)buf) {
      uint64_t v3 = sub_100084B4C;
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3)
    {
      LOBYTE(v7) = 0;
      ctu::cf::assign((ctu::cf *)&v7, *(BOOL **)buf, v2);
      BOOL v4 = (_BYTE)v7 != 0;
    }
    else
    {
      BOOL v4 = 0;
    }
    sub_100062778((const void **)buf);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "MobileHelperInterface is absent. Defaulting the stored MMI preference to false", buf, 2u);
    }
    BOOL v4 = 0;
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  return v4;
}

void sub_10104C2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10104C2DC(capabilities::ct *a1)
{
  xpc_object_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  capabilities::ct::getSupportedMessageModes((uint64_t *)&v8, a1);
  CFBooleanRef v2 = v8;
  uint64_t v3 = v9;
  BOOL v4 = v8;
  if (v8 != v9)
  {
    while (*v4 != 4)
    {
      if (++v4 == v9)
      {
        BOOL v4 = v9;
        break;
      }
    }
  }
  if (v4 == v9)
  {
    uint64_t v5 = *((void *)a1 + 5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device does not support CMAS", (uint8_t *)&v7, 2u);
      CFBooleanRef v2 = v8;
    }
  }
  if (v2)
  {
    uint64_t v9 = v2;
    operator delete(v2);
  }
  return v4 != v3;
}

const void **sub_10104C3A8(void *a1, Registry **a2, uint64_t a3)
{
  *a1 = 0;
  sub_10104B9E0(&v5, a2, a3, @"AutoReadOutLanguages", 0);
  sub_100044D6C(a1, &v5);
  return sub_1000577C4(&v5);
}

void sub_10104C3FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10104C410(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1;
  int v8 = a2;
  uint64_t v9 = a3;
  uint64_t v10 = a4;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10105AA1C;
  v11[3] = &unk_101A82958;
  void v11[4] = a1 + 8;
  v11[5] = &v7;
  __int16 v12 = v11;
  uint64_t v5 = a1 + 24;
  BOOL v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    char v15 = sub_10005B554;
    uint64_t v16 = &unk_101A828D8;
    uint64_t v17 = &v19;
    uint64_t v18 = &v12;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    char v15 = sub_10005A7F0;
    uint64_t v16 = &unk_101A828B8;
    uint64_t v17 = &v19;
    uint64_t v18 = &v12;
    dispatch_sync(v4, &block);
  }
  return v19 != 0;
}

BOOL sub_10104C54C(uint64_t a1, uint64_t a2)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_10105AA30;
  v6[3] = &unk_101A82978;
  void v6[4] = a1 + 8;
  void v6[5] = v5;
  uint64_t v7 = v6;
  uint64_t v3 = a1 + 24;
  CFBooleanRef v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10005B554;
    uint64_t v11 = &unk_101A828D8;
    __int16 v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10005A7F0;
    uint64_t v11 = &unk_101A828B8;
    __int16 v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v2, &block);
  }
  return v14 != 0;
}

BOOL sub_10104C680(uint64_t a1, char a2)
{
  uint64_t v5 = a1;
  char v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10105AB28;
  uint64_t v7[3] = &unk_101A82998;
  v7[4] = a1 + 8;
  v7[5] = &v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  CFBooleanRef v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005B554;
    __int16 v12 = &unk_101A828D8;
    uint64_t v13 = &v15;
    char v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A7F0;
    __int16 v12 = &unk_101A828B8;
    uint64_t v13 = &v15;
    char v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

BOOL sub_10104C7B8(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  char v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v20 = 0;
  uint32_t v21 = 0;
  Registry::getMobileHelper(&v20, *(Registry **)(a1 + 240));
  if (v20)
  {
    char v19 = 0;
    (*(void (**)(unsigned char *__return_ptr))(*(void *)v20 + 16))(buf);
    sub_1000057AC(&v19, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v19) {
      int v8 = sub_100084B4C;
    }
    else {
      int v8 = 0;
    }
    if (v8)
    {
      buf[0] = 0;
      ctu::cf::assign((ctu::cf *)buf, v19, v7);
      int v9 = buf[0];
      *a3 = buf[0];
      uint64_t v10 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = "true";
        if (!v9) {
          uint64_t v11 = "false";
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Auto read out preference set by user to %s", buf, 0xCu);
      }
      BOOL v12 = 1;
      goto LABEL_24;
    }
    *(void *)std::string buf = 0;
    sub_10104C3A8(buf, *(Registry ***)(a1 + 368), a2);
    if (*(void *)buf) {
      char v14 = sub_100083F10;
    }
    else {
      char v14 = 0;
    }
    BOOL v12 = v14 != 0;
    if (v14)
    {
      *a3 = 1;
      char v15 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v18 = 0;
        uint64_t v16 = "#I Auto read out languages exist in bundle, preference set to true";
LABEL_22:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, v18, 2u);
      }
    }
    else
    {
      char v15 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v18 = 0;
        uint64_t v16 = "#I Auto read out languages don't exist in bundle, preference set to false";
        goto LABEL_22;
      }
    }
    sub_100044D00((const void **)buf);
LABEL_24:
    sub_100062778((const void **)&v19);
    goto LABEL_25;
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Mobile helper interface is absent", buf, 2u);
  }
  BOOL v12 = 0;
LABEL_25:
  if (v21) {
    sub_10004D2C8(v21);
  }
  return v12;
}

void sub_10104CA64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t CellBroadcastConfig::getCellBroadcastSettingForAlertType_sync(uint64_t a1, uint64_t a2, const void *a3, unsigned char *a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (a3)
  {
    int v9 = (os_log_t *)v8;
    CFDictionaryRef theDict = (CFDictionaryRef)sub_10104C060(a1, a2);
    if (theDict) {
      uint64_t v10 = sub_100080778;
    }
    else {
      uint64_t v10 = 0;
    }
    if (!v10)
    {
      uint64_t v13 = 0;
LABEL_31:
      sub_100057D78((const void **)&theDict);
      return v13;
    }
    *(void *)std::string buf = 0;
    uint64_t v34 = 0;
    Registry::getMobileHelper((uint64_t *)buf, *(Registry **)(a1 + 240));
    if (!*(void *)buf)
    {
      char v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v36 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "MobileHelperInterface is absent", v36, 2u);
      }
      uint64_t v13 = 0;
      goto LABEL_29;
    }
    xpc_object_t v31 = 0;
    CFStringRef v32 = CFStringCreateWithFormat(0, 0, @"%@%@", @"CellBroadcastSetting", a3);
    (*(void (**)(uint8_t *__return_ptr))(**(void **)buf + 16))(v36);
    sub_1000057AC(&v31, (CFTypeRef *)v36);
    sub_1000577C4((const void **)v36);
    if (v31) {
      BOOL v12 = sub_100084B4C;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      v36[0] = 0;
      ctu::cf::assign((ctu::cf *)v36, v31, v11);
      *a4 = v36[0];
    }
    else
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, a3);
      CFDictionaryRef v17 = Value;
      if (!Value || (CFTypeID v18 = CFGetTypeID(Value), v18 != CFDictionaryGetTypeID()))
      {
        uint64_t v23 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v36 = 138543362;
          uint32_t v37 = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No alert type found in the operator bundle with name %{public}@", v36, 0xCu);
        }
        uint64_t v13 = 0;
        goto LABEL_28;
      }
      char v19 = (BOOL *)CFDictionaryGetValue(v17, @"EnabledByDefault");
      uint64_t v20 = v19;
      if (v19 && (CFTypeID v21 = CFGetTypeID(v19), v21 == CFBooleanGetTypeID()))
      {
        v36[0] = 0;
        ctu::cf::assign((ctu::cf *)v36, v20, v22);
        *a4 = v36[0];
      }
      else
      {
        char v25 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v36 = 138543362;
          uint32_t v37 = a3;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Cannot retrieve EnabledByDefault from the carrier bundle for alert type %{public}@", v36, 0xCu);
        }
      }
      xpc_object_t v26 = (BOOL *)CFDictionaryGetValue(v17, @"UseMMI");
      long long v27 = v26;
      if (v26)
      {
        CFTypeID v28 = CFGetTypeID(v26);
        if (v28 == CFBooleanGetTypeID())
        {
          v36[0] = 0;
          ctu::cf::assign((ctu::cf *)v36, v27, v29);
          if (v36[0])
          {
            if (!sub_10104C170(a1))
            {
              *a4 = 0;
              xpc_object_t v30 = *v9;
              if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v36 = 138543362;
                uint32_t v37 = a3;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Alert disabled: [%{public}@] - as MMI command is not set", v36, 0xCu);
              }
            }
          }
        }
      }
    }
    uint64_t v13 = 1;
LABEL_28:
    sub_100062778((const void **)&v31);
    sub_1000558F4((const void **)&v32);
LABEL_29:
    if (v34) {
      sub_10004D2C8(v34);
    }
    goto LABEL_31;
  }
  char v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid alert type", buf, 2u);
  }
  return 0;
}

void sub_10104CEBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  BOOL v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  char v6 = va_arg(va2, const void *);
  uint64_t v8 = va_arg(va2, void);
  int v9 = va_arg(va2, std::__shared_weak_count *);
  uint64_t v10 = va_arg(va2, void);
  sub_100062778((const void **)va);
  sub_1000558F4((const void **)va1);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_100057D78((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_10104CF24(uint64_t a1, int a2, uint64_t a3, char a4)
{
  uint64_t v7 = a1;
  int v8 = a2;
  uint64_t v9 = a3;
  char v10 = a4;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10105AE3C;
  v11[3] = &unk_101A829B8;
  void v11[4] = a1 + 8;
  v11[5] = &v7;
  BOOL v12 = v11;
  uint64_t v5 = a1 + 24;
  BOOL v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    char v15 = sub_10005B554;
    uint64_t v16 = &unk_101A828D8;
    CFDictionaryRef v17 = &v19;
    CFTypeID v18 = &v12;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    char v15 = sub_10005A7F0;
    uint64_t v16 = &unk_101A828B8;
    CFDictionaryRef v17 = &v19;
    CFTypeID v18 = &v12;
    dispatch_sync(v4, &block);
  }
  return v19 != 0;
}

uint64_t sub_10104D064(uint64_t a1, uint64_t a2, const __CFString *a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (!a3)
  {
    CFBooleanRef v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    LOWORD(__p[0]) = 0;
    BOOL v12 = "Invalid alert type";
    uint64_t v13 = v11;
    uint32_t v14 = 2;
LABEL_67:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)__p, v14);
    return 0;
  }
  double v54 = (os_log_t *)v8;
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  CFDictionaryRef v9 = (const __CFDictionary *)sub_10104C060(a1, a2);
  CFDictionaryRef theDict = v9;
  if (v9) {
    char v10 = sub_100080778;
  }
  else {
    char v10 = 0;
  }
  if (!v10)
  {
    sub_100057D78((const void **)&theDict);
LABEL_48:
    os_log_t v43 = *v54;
    if (!os_log_type_enabled(*v54, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    LODWORD(__p[0]) = 138543362;
    *(void **)((char *)__p + 4) = (void *)a3;
    BOOL v12 = "Not a known alert type %{public}@";
    uint64_t v13 = v43;
    uint32_t v14 = 12;
    goto LABEL_67;
  }
  uint64_t v53 = a1;
  int v52 = a4;
  if (CFDictionaryContainsKey(v9, a3))
  {
    sub_100057D78((const void **)&theDict);
    goto LABEL_35;
  }
  CFIndex Count = CFDictionaryGetCount(theDict);
  memset(__p, 0, 24);
  values = 0;
  sub_10039E2FC(__p, Count, &values);
  values = 0;
  os_log_t v56 = 0;
  uint64_t v57 = 0;
  CFBooleanRef v59 = 0;
  sub_10039E2FC(&values, Count, &v59);
  CFDictionaryGetKeysAndValues(theDict, (const void **)__p[0], (const void **)values);
  CFStringRef theString2 = a3;
  if (Count < 1)
  {
    BOOL v17 = 0;
  }
  else
  {
    uint64_t v16 = 0;
    BOOL v17 = 1;
    while (1)
    {
      CFDictionaryRef v18 = (const __CFDictionary *)values[v16];
      if (v18)
      {
        CFTypeID v19 = CFGetTypeID(values[v16]);
        if (v19 == CFDictionaryGetTypeID())
        {
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v18, @"CustomPreferences");
          CFArrayRef v21 = Value;
          if (Value)
          {
            CFTypeID v22 = CFGetTypeID(Value);
            if (v22 == CFArrayGetTypeID())
            {
              CFIndex v23 = CFArrayGetCount(v21);
              if (v23 >= 1) {
                break;
              }
            }
          }
        }
      }
LABEL_27:
      BOOL v17 = ++v16 < Count;
      if (v16 == Count) {
        goto LABEL_30;
      }
    }
    CFIndex v24 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v21, v24);
      CFDictionaryRef v26 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v27 = CFGetTypeID(ValueAtIndex);
        if (v27 == CFDictionaryGetTypeID())
        {
          CFDictionaryRef v28 = (const __CFDictionary *)CFDictionaryGetValue(v26, @"AlertType");
          CFDictionaryRef v29 = v28;
          if (v28)
          {
            CFTypeID v30 = CFGetTypeID(v28);
            if (v30 == CFDictionaryGetTypeID())
            {
              CFStringRef v31 = (const __CFString *)CFDictionaryGetValue(v29, @"SwitchName");
              CFStringRef v32 = v31;
              if (v31)
              {
                CFTypeID v33 = CFGetTypeID(v31);
                if (v33 == CFStringGetTypeID() && CFEqual(v32, theString2)) {
                  break;
                }
              }
            }
          }
        }
      }
      if (v23 == ++v24) {
        goto LABEL_27;
      }
    }
  }
LABEL_30:
  if (values)
  {
    os_log_t v56 = (std::__shared_weak_count *)values;
    operator delete(values);
  }
  a3 = theString2;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  sub_100057D78((const void **)&theDict);
  if (!v17) {
    goto LABEL_48;
  }
LABEL_35:
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  __p[2] = sub_10015CDE0;
  __p[3] = &unk_1019A5020;
  __p[4] = (void *)v53;
  int v62 = 0;
  sub_10015CC00((wis::MetricFactory *)0x80042);
  uint64_t v34 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v53 + 48) + 16))(*(void *)(v53 + 48), a2);
  values = 0;
  os_log_t v56 = 0;
  Registry::getMobileHelper((uint64_t *)&values, *(Registry **)(v53 + 240));
  if (!values)
  {
    uint64_t v44 = *(NSObject **)(v53 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "MobileHelperInterface is absent", (uint8_t *)__p, 2u);
    }
    uint64_t v38 = 0;
    goto LABEL_63;
  }
  uint64_t v35 = *v34;
  if (os_log_type_enabled(*v34, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p[0]) = 138543618;
    *(void **)((char *)__p + 4) = (void *)a3;
    WORD2(__p[1]) = 1024;
    *(_DWORD *)((char *)&__p[1] + 6) = v52;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Saving the Cell Broadcast settings for alert type %{public}@: %d to the persistent store", (uint8_t *)__p, 0x12u);
  }
  uint64_t v36 = (CFDictionaryRef *)&kCFBooleanTrue;
  CFBooleanRef v59 = 0;
  if (!v52) {
    uint64_t v36 = (CFDictionaryRef *)&kCFBooleanFalse;
  }
  CFDictionaryRef theDict = *v36;
  __p[0] = 0;
  sub_100062778((const void **)__p);
  CFBooleanRef v59 = theDict;
  CFDictionaryRef theDict = 0;
  sub_100062778((const void **)&theDict);
  CFDictionaryRef theDict = 0;
  CFDictionaryRef theDict = (CFDictionaryRef)CFStringCreateWithFormat(0, 0, @"%@%@", @"CellBroadcastSetting", a3);
  CFBooleanRef BOOLean = 0;
  uint64_t v37 = kCommCenterSharedSettingsBundleId;
  (*((void (**)(void **__return_ptr))*values + 2))(__p);
  sub_1000057AC(&BOOLean, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  uint64_t v38 = (*((uint64_t (**)(void **, uint64_t, CFDictionaryRef, CFBooleanRef))*values + 3))(values, v37, theDict, v59);
  if ((v38 & 1) == 0)
  {
    BOOL v45 = *v34;
    if (os_log_type_enabled(*v34, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to save preferences...", (uint8_t *)__p, 2u);
    }
    goto LABEL_62;
  }
  if (BOOLean) {
    std::string::size_type v39 = sub_100084B4C;
  }
  else {
    std::string::size_type v39 = 0;
  }
  if (!v39)
  {
    BOOL v41 = *(NSObject **)(v53 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      uint64_t v42 = "#I Dispatching Darwin notification for Emergency Alerts initial change";
      goto LABEL_57;
    }
LABEL_58:
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, @"kCTSMSCellBroadcastConfigChangedNotification", 0, 0, 0);
    goto LABEL_59;
  }
  int v40 = CFBooleanGetValue(BOOLean);
  if (v40 != CFBooleanGetValue(v59))
  {
    BOOL v41 = *(NSObject **)(v53 + 40);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      uint64_t v42 = "#I Dispatching Darwin notification for Emergency Alerts preference change";
LABEL_57:
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v42, (uint8_t *)__p, 2u);
      goto LABEL_58;
    }
    goto LABEL_58;
  }
LABEL_59:
  uint64_t v47 = *(void *)(v53 + 192);
  if (v47)
  {
    CFDictionaryRef v48 = theDict;
    uint64_t v49 = operator new(8uLL);
    __p[0] = v49;
    *uint64_t v49 = v48;
    __p[1] = v49 + 1;
    __p[2] = v49 + 1;
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v47 + 16))(v47, v37, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
LABEL_62:
  sub_100062778((const void **)&BOOLean);
  sub_1000558F4((const void **)&theDict);
  sub_100062778((const void **)&v59);
LABEL_63:
  if (v56) {
    sub_10004D2C8(v56);
  }
  return v38;
}

void sub_10104D7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, std::__shared_weak_count *a18, uint64_t a19, const void *a20,const void *a21,const void *a22,void *__p,uint64_t a24)
{
  if (__p)
  {
    a24 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100062778(&a20);
  sub_1000558F4(&a22);
  sub_100062778(&a21);
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

void sub_10104D8A8(const __CFDictionary **a1, uint64_t a2, const void *a3, const void *a4)
{
  if (!a4)
  {
    char v25 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFStringRef v32 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid inputs while reading always deliver pref", v32, 2u);
    }
    goto LABEL_37;
  }
  subscriber::makeSimSlotRange();
  char v6 = *(unsigned int **)v32;
  uint64_t v5 = v33;
  if (*(unsigned int **)v32 == v33) {
    goto LABEL_37;
  }
  uint64_t v7 = v34;
  while ((v34(*v6) & 1) == 0)
  {
    if (++v6 == v33)
    {
      char v6 = v33;
      break;
    }
  }
  CFDictionaryRef v29 = v33;
  if (v6 == v33)
  {
LABEL_37:
    *a1 = 0;
    return;
  }
  while (1)
  {
    uint64_t v8 = *v6;
    CFDictionaryRef v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), v8);
    CFDictionaryRef theDict = 0;
    sub_10104B9E0(buf, *(Registry ***)(a2 + 368), v8, @"AlertTypes", 0);
    sub_10004EFE4(&theDict, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (theDict ? sub_100080778 : 0)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, a3);
      CFDictionaryRef v12 = Value;
      if (!Value || (CFTypeID v13 = CFGetTypeID(Value), v13 != CFDictionaryGetTypeID()))
      {
        CFDictionaryRef v18 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 138543362;
          uint64_t v36 = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to read %{public}@ from bundle", buf, 0xCu);
        }
        goto LABEL_20;
      }
      uint32_t v14 = CFDictionaryGetValue(v12, @"CustomPreferences");
      char v15 = v14;
      if (v14)
      {
        CFTypeID v16 = CFGetTypeID(v14);
        CFArrayRef v17 = v16 == CFArrayGetTypeID() ? (const __CFArray *)v15 : 0;
      }
      else
      {
        CFArrayRef v17 = 0;
      }
      CFIndex Count = CFArrayGetCount(v17);
      if (Count >= 1) {
        break;
      }
    }
LABEL_20:
    sub_100057D78((const void **)&theDict);
    CFTypeID v19 = v6 + 1;
    char v6 = v5;
    if (v19 != v5)
    {
      char v6 = v19;
      while ((v7(*v6) & 1) == 0)
      {
        if (++v6 == v5)
        {
          char v6 = v5;
          break;
        }
      }
    }
    if (v6 == v29) {
      goto LABEL_37;
    }
  }
  CFIndex v21 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v17, v21);
    CFDictionaryRef v23 = ValueAtIndex;
    if (ValueAtIndex)
    {
      CFTypeID v24 = CFGetTypeID(ValueAtIndex);
      if (v24 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryContainsKey(v23, a4)) {
          break;
        }
      }
    }
    if (Count == ++v21) {
      goto LABEL_20;
    }
  }
  CFDictionaryRef v26 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138543618;
    uint64_t v36 = a3;
    __int16 v37 = 2114;
    uint64_t v38 = a4;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Found Custom preference for %{public}@.%{public}@", buf, 0x16u);
  }
  *a1 = v23;
  CFRetain(v23);
  sub_100057D78((const void **)&theDict);
}

void sub_10104DC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10104DC78@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v8 = a1;
  sub_100058198(&v9, a2);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_10105AE54;
  v10[3] = &unk_101A829D8;
  void v10[4] = v5;
  void v10[5] = &v8;
  CFBooleanRef v11 = v10;
  char v6 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *a3 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint32_t v14 = sub_10105A9A4;
    char v15 = &unk_101A82938;
    CFTypeID v16 = a3;
    CFArrayRef v17 = &v11;
    dispatch_async_and_wait(v6, &block);
  }
  else
  {
    *a3 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    uint32_t v14 = sub_10105A92C;
    char v15 = &unk_101A82918;
    CFTypeID v16 = a3;
    CFArrayRef v17 = &v11;
    dispatch_sync(v6, &block);
  }
  return sub_100057D78(&v9);
}

BOOL sub_10104DDCC(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10105BA74;
  v5[3] = &unk_101A829F8;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  char v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    CFDictionaryRef v9 = sub_10005B554;
    char v10 = &unk_101A828D8;
    CFBooleanRef v11 = &v13;
    CFDictionaryRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    CFDictionaryRef v9 = sub_10005A7F0;
    char v10 = &unk_101A828B8;
    CFBooleanRef v11 = &v13;
    CFDictionaryRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_10104DEFC(uint64_t a1, uint64_t a2)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_10105BEA0;
  v6[3] = &unk_101A82A18;
  void v6[4] = a1 + 8;
  void v6[5] = v5;
  uint64_t v7 = v6;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    char v10 = sub_10005B554;
    CFBooleanRef v11 = &unk_101A828D8;
    CFDictionaryRef v12 = &v14;
    char v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    char v10 = sub_10005A7F0;
    CFBooleanRef v11 = &unk_101A828B8;
    CFDictionaryRef v12 = &v14;
    char v13 = &v7;
    dispatch_sync(v2, &block);
  }
  return v14 != 0;
}

BOOL sub_10104E030(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  uint64_t v8 = a3;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10105C63C;
  v9[3] = &unk_101A82A38;
  void v9[4] = a1 + 8;
  void v9[5] = &v6;
  char v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    char v13 = sub_10005B554;
    char v14 = &unk_101A828D8;
    char v15 = &v17;
    CFTypeID v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    char v13 = sub_10005A7F0;
    char v14 = &unk_101A828B8;
    char v15 = &v17;
    CFTypeID v16 = &v10;
    dispatch_sync(v3, &block);
  }
  return v17 != 0;
}

uint64_t sub_10104E168(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (sub_10104C2DC((capabilities::ct *)a1))
  {
    *(void *)std::string buf = 0;
    sub_10104B9E0(&v11, *(Registry ***)(a1 + 368), a2, a3, 0);
    sub_100044D6C(buf, &v11);
    sub_1000577C4(&v11);
    uint64_t v7 = *(void *)buf;
    if (*(void *)buf) {
      uint64_t v8 = sub_100083F10;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8) {
      *(void *)std::string buf = 0;
    }
    else {
      uint64_t v7 = 0;
    }
    sub_100044D00((const void **)buf);
  }
  else
  {
    uint64_t v9 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Copy CMAS Configuration: Device does not support CMAS", buf, 2u);
    }
    return 0;
  }
  return v7;
}

void sub_10104E288(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

__CFArray *sub_10104E29C(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, int a5)
{
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (!a3)
  {
    double v54 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "Invalid protocol section identifier", buf, 2u);
    }
    return 0;
  }
  char v10 = (os_log_t *)v9;
  CFArrayRef v11 = (const __CFArray *)sub_10104E168(a1, a2, a3);
  CFArrayRef theArray = v11;
  if (v11) {
    uint64_t v12 = sub_100083F10;
  }
  else {
    uint64_t v12 = 0;
  }
  if (!v12 || (CFIndex Count = CFArrayGetCount(v11), Count < 1))
  {
    CFMutableDictionaryRef Mutable = 0;
    goto LABEL_65;
  }
  CFIndex v14 = 0;
  CFMutableDictionaryRef Mutable = 0;
  CFIndex v58 = Count;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v14);
    CFDictionaryRef v17 = ValueAtIndex;
    if (ValueAtIndex)
    {
      CFTypeID v18 = CFGetTypeID(ValueAtIndex);
      if (v18 == CFDictionaryGetTypeID()) {
        CFDictionaryRef v19 = v17;
      }
      else {
        CFDictionaryRef v19 = 0;
      }
    }
    else
    {
      CFDictionaryRef v19 = 0;
    }
    char v60 = 0;
    (*(void (**)(uint64_t, const __CFDictionary *, char *))(a4 + 16))(a4, v19, &v60);
    if (!v60) {
      goto LABEL_62;
    }
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 3, &kCFTypeArrayCallBacks);
    CFDictionaryRef Value = CFDictionaryGetValue(v19, @"AlertType");
    CFIndex v21 = Value;
    if (Value)
    {
      CFTypeID v22 = CFGetTypeID(Value);
      if (v22 == CFStringGetTypeID())
      {
        int v62 = 0;
        CFDictionaryRef v23 = (const void *)sub_10104C060(a1, a2);
        int v62 = v23;
        if (v23) {
          CFTypeID v24 = sub_100080778;
        }
        else {
          CFTypeID v24 = 0;
        }
        if (v24)
        {
          char v25 = CFDictionaryGetValue((CFDictionaryRef)v23, v21);
          CFDictionaryRef v26 = v25;
          if (v25)
          {
            CFTypeID v27 = CFGetTypeID(v25);
            if (v27 == CFDictionaryGetTypeID())
            {
              CFArrayAppendValue(Mutable, v26);
              sub_100057D78(&v62);
              goto LABEL_25;
            }
          }
          os_log_t v49 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 138543362;
            *(void *)&uint8_t buf[4] = v21;
            unint64_t v50 = v49;
            os_log_t v51 = "#I No alert type %{public}@ found in the types defined";
            uint32_t v52 = 12;
LABEL_59:
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v51, buf, v52);
          }
        }
        else
        {
          os_log_t v53 = *v10;
          if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            unint64_t v50 = v53;
            os_log_t v51 = "#I No alert types found";
            uint32_t v52 = 2;
            goto LABEL_59;
          }
        }
        CFDictionaryRef v48 = &v62;
        goto LABEL_61;
      }
    }
    CFDictionaryRef v28 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Could not find AlertType in the CMAS configuration", buf, 2u);
    }
LABEL_25:
    if (!a5) {
      goto LABEL_37;
    }
    CFDictionaryRef v29 = CFDictionaryGetValue(v19, @"EmergencyAlertConfiguration");
    CFTypeID v30 = v29;
    if (v29)
    {
      CFTypeID v31 = CFGetTypeID(v29);
      if (v31 != CFStringGetTypeID()) {
        CFTypeID v30 = 0;
      }
    }
    CFStringRef v32 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138543362;
      *(void *)&uint8_t buf[4] = v30;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Emergency Alert Configuration name: %{public}@", buf, 0xCu);
    }
    if (!v30)
    {
LABEL_37:
      CFTypeID v33 = CFDictionaryGetValue(v19, @"AlertConfiguration");
      CFTypeID v30 = v33;
      if (v33)
      {
        CFTypeID v34 = CFGetTypeID(v33);
        if (v34 != CFStringGetTypeID()) {
          CFTypeID v30 = 0;
        }
      }
      uint64_t v35 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 138543362;
        *(void *)&uint8_t buf[4] = v30;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Alert Configuration name: %{public}@", buf, 0xCu);
      }
      if (!v30) {
        break;
      }
    }
    CFBooleanRef v59 = 0;
    uint64_t v36 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (sub_10104C2DC((capabilities::ct *)a1))
    {
      *(void *)std::string buf = 0;
      sub_10104B9E0(&v62, *(Registry ***)(a1 + 368), a2, @"AlertConfigurations", 0);
      sub_10004EFE4(buf, &v62);
      sub_1000577C4(&v62);
      __int16 v37 = *(const void **)buf;
      *(void *)std::string buf = 0;
      sub_100057D78((const void **)buf);
    }
    else
    {
      uint64_t v38 = *v36;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Copy Cell Broadcast Alert Configuration: Device does not support CMAS", buf, 2u);
      }
      __int16 v37 = 0;
    }
    CFBooleanRef v59 = v37;
    if (v37) {
      std::string::size_type v39 = sub_100080778;
    }
    else {
      std::string::size_type v39 = 0;
    }
    if (v39)
    {
      int v40 = CFDictionaryGetValue((CFDictionaryRef)v37, v30);
      BOOL v41 = v40;
      if (v40)
      {
        CFTypeID v42 = CFGetTypeID(v40);
        if (v42 == CFDictionaryGetTypeID())
        {
          CFArrayAppendValue(Mutable, v41);
          sub_100057D78(&v59);
          goto LABEL_65;
        }
      }
      os_log_t v43 = *v10;
      if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(_DWORD *)std::string buf = 138412290;
      *(void *)&uint8_t buf[4] = v30;
      uint64_t v44 = v43;
      BOOL v45 = "#I Configuration %@{public} was not found in the defined configurations";
      uint32_t v46 = 12;
      goto LABEL_53;
    }
    os_log_t v47 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v44 = v47;
      BOOL v45 = "#I No alert configurations found";
      uint32_t v46 = 2;
LABEL_53:
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v45, buf, v46);
    }
LABEL_54:
    CFDictionaryRef v48 = &v59;
LABEL_61:
    sub_100057D78(v48);
LABEL_62:
    if (v58 == ++v14) {
      goto LABEL_65;
    }
  }
  os_log_t v56 = *v10;
  if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Could not find AlertConfiguration in the CMAS configuration", buf, 2u);
  }
LABEL_65:
  sub_100044D00((const void **)&theArray);
  return Mutable;
}

void sub_10104E920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  CFIndex v14 = va_arg(va1, const void *);
  uint64_t v16 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_100044D00((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10104E978(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v5 = a3 - 4352;
  if ((a3 - 4352) < 5)
  {
LABEL_4:
    uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (v5 > 5) {
        uint64_t v8 = "???";
      }
      else {
        uint64_t v8 = off_101A82CB8[v5];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v8;
      CFDictionaryRef v17 = "#I ETWS Alert type: %s";
      CFTypeID v18 = v7;
      uint32_t v19 = 12;
      goto LABEL_18;
    }
    return 1;
  }
  if ((a3 - 4357) <= 2)
  {
    unsigned int v5 = 5;
    goto LABEL_4;
  }
  CFDictionaryRef theDict = 0;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  CFTypeID v24 = sub_101055604;
  char v25 = &unk_101A82270;
  int v26 = a3;
  sub_1010553D4((const void **)&theDict, a1, a2, @"MessageIDParameters3GPP", (uint64_t)&buf);
  uint64_t v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (theDict) {
    char v10 = sub_100080778;
  }
  else {
    char v10 = 0;
  }
  if (!v10)
  {
    CFIndex v21 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = a3;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Unable to find the config dictionary for Service ID: %u", (uint8_t *)&buf, 8u);
    }
    goto LABEL_22;
  }
  CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"ProcessAsETWSMessage");
  uint64_t v12 = Value;
  if (!Value || (CFTypeID v13 = CFGetTypeID(Value), v13 != CFBooleanGetTypeID()))
  {
LABEL_22:
    sub_100057D78((const void **)&theDict);
    return 0;
  }
  LOBYTE(buf) = 0;
  ctu::cf::assign((ctu::cf *)&buf, v12, v14);
  int v15 = buf;
  sub_100057D78((const void **)&theDict);
  if (v15)
  {
    uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      CFDictionaryRef v17 = "#I ETWS Alert type: carrier-driven";
      CFTypeID v18 = v16;
      uint32_t v19 = 2;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&buf, v19);
    }
    return 1;
  }
  return 0;
}

void sub_10104EC5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_10104EC7C(uint64_t a1, CFDictionaryRef theDict, unsigned char *a3)
{
  CFDictionaryRef Value = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"FromServiceID");
  uint64_t v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFNumberGetTypeID()) {
      uint64_t v7 = 0;
    }
  }
  uint64_t v9 = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"ToServiceID");
  if (v9 && (char v10 = v9, v11 = CFGetTypeID(v9), TypeID = CFNumberGetTypeID(), v7) && v11 == TypeID)
  {
    unsigned __int16 v19 = 0;
    ctu::cf::assign((ctu::cf *)&v19, v7, v13);
    unsigned int v14 = v19;
    unsigned __int16 v20 = 0;
    ctu::cf::assign((ctu::cf *)&v20, v10, v15);
    unsigned int v16 = *(_DWORD *)(a1 + 40);
    if (v16 >= v14 && v16 <= v20) {
      *a3 = 1;
    }
  }
  else
  {
    CFDictionaryRef v17 = **(NSObject ***)(a1 + 32);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeID v18 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "FromServiceId or ToServiceId not present in bundle", v18, 2u);
    }
  }
}

uint64_t sub_10104EDA8(uint64_t a1, CFDictionaryRef theDict, unsigned char *a3)
{
  CFDictionaryRef Value = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"Category");
  if (Value)
  {
    uint64_t v7 = Value;
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFNumberGetTypeID()) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned __int16 v11 = 0;
  uint64_t result = ctu::cf::assign((ctu::cf *)&v11, v9, v6);
  if (*(_DWORD *)(a1 + 32) == v11) {
    *a3 = 1;
  }
  return result;
}

BOOL sub_10104EE38(uint64_t a1, int a2, __int16 a3, int a4)
{
  uint64_t v7 = a1;
  int v8 = a2;
  __int16 v9 = a3;
  int v10 = a4;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10105C860;
  v11[3] = &unk_101A82A58;
  void v11[4] = a1 + 8;
  v11[5] = &v7;
  uint64_t v12 = v11;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    CFNumberRef v15 = sub_10005B554;
    unsigned int v16 = &unk_101A828D8;
    CFDictionaryRef v17 = &v19;
    CFTypeID v18 = &v12;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    CFNumberRef v15 = sub_10005A7F0;
    unsigned int v16 = &unk_101A828B8;
    CFDictionaryRef v17 = &v19;
    CFTypeID v18 = &v12;
    dispatch_sync(v4, &block);
  }
  return v19 != 0;
}

BOOL sub_10104EF78(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  __int16 v9 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = a3;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = asString();
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Applying Language filtering for Message ID %d Language %s", buf, 0x12u);
  }
  if ((a3 - 4370) >= 0xD && (a3 & 0xFFFFFFFD) != 0x112C)
  {
    if (a4 == 25 || a4 == 15)
    {
      int v10 = *v8;
      BOOL v11 = 0;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        CFNumberRef v13 = "#I CellBroadcast Language Unknown %s, filtering not applicable";
        uint64_t v14 = v10;
        uint32_t v15 = 12;
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
        return 0;
      }
      return v11;
    }
    memset(buf, 0, sizeof(buf));
    CellBroadcastConfig::getPrimaryBroadcastLanguages_sync(a1, a2, (uint64_t *)buf);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v29 = 0;
    if (*(char *)(a1 + 479) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 456), *(void *)(a1 + 464));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 456);
      uint64_t v29 = *(void *)(a1 + 472);
    }
    v30[0] = 0;
    uint64_t v17 = sub_1000D8740(*(uint64_t *)buf, *(uint64_t *)&buf[8], (unsigned __int8 **)__p);
    if (v17 == *(void *)&buf[8])
    {
      char v19 = *v8;
      BOOL v11 = 0;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeID v22 = __p;
        if (v29 < 0) {
          CFTypeID v22 = (void **)__p[0];
        }
        *(_DWORD *)CFTypeID v30 = 136446210;
        CFTypeID v31 = v22;
        CFIndex v21 = "#I Phones language %{public}s not present in primary language list of carrier, filtering not applicable";
        goto LABEL_28;
      }
    }
    else
    {
      if (v29 >= 0) {
        CFTypeID v18 = __p;
      }
      else {
        CFTypeID v18 = (void **)__p[0];
      }
      if (getBroadcastLanguageFromLocale((const char *)v18) != 15)
      {
        if (v29 >= 0) {
          CFDictionaryRef v23 = __p;
        }
        else {
          CFDictionaryRef v23 = (void **)__p[0];
        }
        int BroadcastLanguageFromLocale = getBroadcastLanguageFromLocale((const char *)v23);
        BOOL v11 = BroadcastLanguageFromLocale != a4;
        char v25 = *v8;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          int v26 = "false";
          if (BroadcastLanguageFromLocale != a4) {
            int v26 = "true";
          }
          *(_DWORD *)CFTypeID v30 = 136315138;
          CFTypeID v31 = (void *)v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Will Filter CMAS Message: %s.", v30, 0xCu);
        }
        goto LABEL_36;
      }
      char v19 = *v8;
      BOOL v11 = 0;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        unsigned __int16 v20 = __p;
        if (v29 < 0) {
          unsigned __int16 v20 = (void **)__p[0];
        }
        *(_DWORD *)CFTypeID v30 = 136446210;
        CFTypeID v31 = v20;
        CFIndex v21 = "#I Localized Language %{public}s not available for filtering";
LABEL_28:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v21, v30, 0xCu);
        BOOL v11 = 0;
      }
    }
LABEL_36:
    if (SHIBYTE(v29) < 0) {
      operator delete(__p[0]);
    }
    __p[0] = buf;
    sub_100047F64((void ***)__p);
    return v11;
  }
  os_log_t v16 = *v8;
  BOOL v11 = 0;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = a3;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = 4396;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&uint8_t buf[16] = 4398;
    CFNumberRef v13 = "#I Message Identifier %d is in primary range, %d, or %d; filtering not applicable";
    uint64_t v14 = v16;
    uint32_t v15 = 20;
    goto LABEL_11;
  }
  return v11;
}

void sub_10104F350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  long long __p = &a18;
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

const void **CellBroadcastConfig::getPrimaryBroadcastLanguages_sync@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  CFArrayRef theArray = 0;
  sub_10104B9E0(__p, *(Registry ***)(a1 + 368), a2, @"PrimaryBroadcastLanguages", 0);
  sub_100044D6C(&theArray, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  CFArrayRef v4 = theArray;
  if (theArray) {
    uint64_t v5 = sub_100083F10;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5 && (__p[0] = 0, __p[1] = 0, uint64_t v18 = 0, context = __p, theArray))
  {
    v19.length = CFArrayGetCount(theArray);
    v19.location = 0;
    CFArrayApplyFunction(v4, v19, (CFArrayApplierFunction)sub_1002CED68, &context);
    CFNumberRef v6 = (char *)__p[0];
    uint64_t v7 = (char *)__p[1];
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    if (v6 != v7)
    {
      int v8 = v6;
      do
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v18 = 0;
        sub_100058DB0(&v13, "");
        ctu::cf::assign();
        *(_OWORD *)long long __p = v13;
        uint64_t v18 = v14;
        uint64_t v14 = 0;
        long long v13 = 0uLL;
        unint64_t v9 = a3[1];
        if (v9 >= a3[2])
        {
          uint64_t v11 = sub_100048008(a3, (long long *)__p);
        }
        else
        {
          if (SHIBYTE(v18) < 0)
          {
            sub_10004FC84((unsigned char *)a3[1], __p[0], (unint64_t)__p[1]);
          }
          else
          {
            long long v10 = *(_OWORD *)__p;
            *(void *)(v9 + 16) = v18;
            *(_OWORD *)unint64_t v9 = v10;
          }
          uint64_t v11 = v9 + 24;
          a3[1] = v9 + 24;
        }
        a3[1] = v11;
        if (SHIBYTE(v18) < 0) {
          operator delete(__p[0]);
        }
        v8 += 8;
      }
      while (v8 != v7);
    }
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_10104F544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100044D00(&a16);
  _Unwind_Resume(a1);
}

BOOL sub_10104F5CC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  int v9 = a5;
  int v10 = a2;
  v8[0] = &v10;
  v8[1] = a1;
  _DWORD v8[2] = a3;
  void v8[3] = a4;
  void v8[4] = &v9;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10105C878;
  v11[3] = &unk_101A82A78;
  void v11[4] = a1 + 8;
  v11[5] = v8;
  uint64_t v12 = v11;
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(v6 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint32_t v15 = sub_10005B554;
    os_log_t v16 = &unk_101A828D8;
    uint64_t v17 = &v19;
    uint64_t v18 = &v12;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint32_t v15 = sub_10005A7F0;
    os_log_t v16 = &unk_101A828B8;
    uint64_t v17 = &v19;
    uint64_t v18 = &v12;
    dispatch_sync(v5, &block);
  }
  return v19 != 0;
}

BOOL sub_10104F714(uint64_t a1, int a2, int a3, int a4)
{
  int v9 = a3;
  int v10 = a2;
  int v8 = a4;
  v7[0] = a1;
  v7[1] = &v10;
  void v7[2] = &v9;
  uint64_t v7[3] = &v8;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10105C914;
  v11[3] = &unk_101A82A98;
  void v11[4] = a1 + 8;
  v11[5] = v7;
  uint64_t v12 = v11;
  uint64_t v5 = a1 + 24;
  CFArrayRef v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint32_t v15 = sub_10005B554;
    os_log_t v16 = &unk_101A828D8;
    uint64_t v17 = &v19;
    uint64_t v18 = &v12;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint32_t v15 = sub_10005A7F0;
    os_log_t v16 = &unk_101A828B8;
    uint64_t v17 = &v19;
    uint64_t v18 = &v12;
    dispatch_sync(v4, &block);
  }
  return v19 != 0;
}

uint64_t sub_10104F860(uint64_t a1, uint64_t a2)
{
  CFArrayRef v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v5 = *(Registry ***)(a1 + 368);
  uint64_t v6 = operator new(0x18uLL);
  CFArrayRef theArray = 0;
  __p[0] = v6;
  __p[1] = v6 + 3;
  os_log_t v43 = v6 + 3;
  void *v6 = @"CellBroadcast";
  v6[1] = @"TranslationParameters";
  void v6[2] = @"NativeLanguages";
  sub_1007EC3B4(v5, a2, 2, (uint64_t)__p, 0, 0, v39);
  sub_100044D6C(&theArray, (CFTypeRef *)v39);
  sub_1000577C4((const void **)v39);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (theArray) {
    uint64_t v7 = sub_100083F10;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
LABEL_58:
      uint64_t v33 = 1;
      goto LABEL_62;
    }
    CFIndex v9 = 0;
    int v10 = (const void **)(a1 + 456);
    while (1)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v9);
      if (!ValueAtIndex) {
        goto LABEL_57;
      }
      CFTypeID v12 = CFGetTypeID(ValueAtIndex);
      if (v12 != CFStringGetTypeID()) {
        goto LABEL_57;
      }
      __p[0] = 0;
      __p[1] = 0;
      os_log_t v43 = 0;
      ctu::cf::assign();
      int v40 = v43;
      *(_OWORD *)std::string::size_type v39 = *(_OWORD *)__p;
      uint64_t v13 = *(unsigned __int8 *)(a1 + 479);
      if ((v13 & 0x80u) == 0) {
        uint64_t v14 = (void *)*(unsigned __int8 *)(a1 + 479);
      }
      else {
        uint64_t v14 = *(void **)(a1 + 464);
      }
      uint32_t v15 = (void *)HIBYTE(v40);
      int v16 = SHIBYTE(v40);
      if (SHIBYTE(v40) < 0) {
        uint32_t v15 = v39[1];
      }
      if (v14 == v15)
      {
        if (SHIBYTE(v40) >= 0) {
          uint64_t v17 = v39;
        }
        else {
          uint64_t v17 = (void **)v39[0];
        }
        if ((v13 & 0x80) != 0)
        {
          if (!memcmp(*v10, v17, *(void *)(a1 + 464)))
          {
LABEL_47:
            BOOL v32 = 1;
            if ((v16 & 0x80000000) == 0) {
              goto LABEL_52;
            }
            goto LABEL_56;
          }
        }
        else
        {
          if (!*(unsigned char *)(a1 + 479)) {
            goto LABEL_47;
          }
          uint64_t v18 = (unsigned __int8 *)(a1 + 456);
          while (*v18 == *(unsigned __int8 *)v17)
          {
            ++v18;
            uint64_t v17 = (void **)((char *)v17 + 1);
            if (!--v13) {
              goto LABEL_47;
            }
          }
        }
      }
      __p[0] = 0;
      __p[1] = 0;
      os_log_t v43 = 0;
      ctu::cf::assign();
      uint64_t v38 = v43;
      *(_OWORD *)__int16 v37 = *(_OWORD *)__p;
      uint64_t v19 = *(unsigned __int8 *)(a1 + 503);
      if ((v19 & 0x80u) == 0) {
        unsigned __int16 v20 = (void *)*(unsigned __int8 *)(a1 + 503);
      }
      else {
        unsigned __int16 v20 = *(void **)(a1 + 488);
      }
      CFIndex v21 = (void *)HIBYTE(v38);
      int v22 = SHIBYTE(v38);
      if (SHIBYTE(v38) < 0) {
        CFIndex v21 = v37[1];
      }
      if (v20 != v21)
      {
        BOOL v32 = 0;
        if ((SHIBYTE(v38) & 0x80000000) == 0) {
          goto LABEL_51;
        }
        goto LABEL_55;
      }
      CFDictionaryRef v23 = SHIBYTE(v38) >= 0 ? v37 : (void **)v37[0];
      if ((v19 & 0x80) != 0) {
        break;
      }
      if (*(unsigned char *)(a1 + 503))
      {
        uint64_t v24 = v19 - 1;
        char v25 = (unsigned __int8 *)(a1 + 480);
        do
        {
          int v27 = *v25++;
          int v26 = v27;
          int v29 = *(unsigned __int8 *)v23;
          CFDictionaryRef v23 = (void **)((char *)v23 + 1);
          int v28 = v29;
          BOOL v31 = v24-- != 0;
          BOOL v32 = v26 == v28;
        }
        while (v26 == v28 && v31);
LABEL_50:
        if ((v22 & 0x80000000) == 0) {
          goto LABEL_51;
        }
        goto LABEL_55;
      }
      BOOL v32 = 1;
      if ((SHIBYTE(v38) & 0x80000000) == 0)
      {
LABEL_51:
        if ((v16 & 0x80000000) == 0) {
          goto LABEL_52;
        }
        goto LABEL_56;
      }
LABEL_55:
      operator delete(v37[0]);
      if ((v16 & 0x80000000) == 0)
      {
LABEL_52:
        if (v32) {
          goto LABEL_63;
        }
        goto LABEL_57;
      }
LABEL_56:
      operator delete(v39[0]);
      if (v32)
      {
LABEL_63:
        uint64_t v36 = *v4;
        uint64_t v33 = 0;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a1 + 479) < 0) {
            int v10 = (const void **)*v10;
          }
          LODWORD(__p[0]) = 136446210;
          *(void **)((char *)__p + 4) = v10;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Native language %{public}s will not be translated", (uint8_t *)__p, 0xCu);
          goto LABEL_61;
        }
        goto LABEL_62;
      }
LABEL_57:
      if (++v9 == Count) {
        goto LABEL_58;
      }
    }
    BOOL v32 = memcmp(*(const void **)(a1 + 480), v23, *(void *)(a1 + 488)) == 0;
    goto LABEL_50;
  }
  CFTypeID v34 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Native Languages not found in bundle.. Translations skipped", (uint8_t *)__p, 2u);
  }
LABEL_61:
  uint64_t v33 = 0;
LABEL_62:
  sub_100044D00((const void **)&theArray);
  return v33;
}

void sub_10104FC38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
}

BOOL sub_10104FCB4(uint64_t a1, char a2)
{
  char v5 = a2;
  uint64_t v6 = a1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10105C954;
  uint64_t v7[3] = &unk_101A82AB8;
  void v7[4] = a1 + 8;
  v7[5] = &v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005B554;
    CFTypeID v12 = &unk_101A828D8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A7F0;
    CFTypeID v12 = &unk_101A828B8;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_10104FDE8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

uint64_t sub_10104FEE0(CellBroadcastConfig *a1, int a2, unsigned int a3)
{
  CFDictionaryRef theDict = 0;
  CellBroadcastConfig::getAppleSafetyAlertConfig_sync(a1, &theDict);
  if (theDict) {
    uint64_t v6 = sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    if (a2 == 2)
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"MessageIDParameters3GPP2");
      CFArrayRef v8 = Value;
      if (!Value) {
        goto LABEL_28;
      }
    }
    else
    {
      if (a2 != 1) {
        goto LABEL_28;
      }
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"MessageIDParameters3GPP");
      CFArrayRef v8 = Value;
      if (!Value) {
        goto LABEL_28;
      }
    }
    CFTypeID v14 = CFGetTypeID(Value);
    if (v14 == CFArrayGetTypeID())
    {
      for (CFIndex i = 0; i < CFArrayGetCount(v8); ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, i);
        CFDictionaryRef v17 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v18 = CFGetTypeID(ValueAtIndex);
          if (v18 != CFDictionaryGetTypeID()) {
            CFDictionaryRef v17 = 0;
          }
        }
        uint64_t v19 = (unsigned __int16 *)CFDictionaryGetValue(v17, @"FromServiceID");
        unsigned __int16 v20 = v19;
        if (v19)
        {
          CFTypeID v21 = CFGetTypeID(v19);
          if (v21 != CFNumberGetTypeID()) {
            unsigned __int16 v20 = 0;
          }
        }
        int v22 = (unsigned __int16 *)CFDictionaryGetValue(v17, @"ToServiceID");
        CFDictionaryRef v23 = v22;
        if (!v22 || (CFTypeID v24 = CFGetTypeID(v22), v24 != CFNumberGetTypeID()) || !v20)
        {
          int v27 = *((void *)a1 + 5);
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
            goto LABEL_29;
          }
          *(_DWORD *)long long buf = 138412290;
          CFDictionaryRef v34 = theDict;
          int v29 = "Invalid message ID in Apple safety alert dict: %@";
          goto LABEL_36;
        }
        *(_WORD *)long long buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v20, v25);
        if (*(unsigned __int16 *)buf <= a3)
        {
          *(_WORD *)long long buf = 0;
          ctu::cf::assign((ctu::cf *)buf, v23, v26);
          if (*(unsigned __int16 *)buf >= a3)
          {
            BOOL v31 = *((void *)a1 + 5);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 67109120;
              LODWORD(v34) = a3;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Channel: %u supports Apple safety alert", buf, 8u);
            }
            uint64_t v10 = 1;
            goto LABEL_30;
          }
        }
      }
      CFTypeID v30 = *((void *)a1 + 5);
      uint64_t v10 = 0;
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v34) = a3;
      uint64_t v11 = "#I Channel: %u doesn't support Apple safety alert";
      CFTypeID v12 = v30;
      uint32_t v13 = 8;
      goto LABEL_11;
    }
LABEL_28:
    int v27 = *((void *)a1 + 5);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      CFDictionaryRef v34 = theDict;
      int v29 = "Invalid Apple safety alert dict: %@";
LABEL_36:
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
    }
    goto LABEL_29;
  }
  CFIndex v9 = *((void *)a1 + 5);
  uint64_t v10 = 0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v11 = "#I Apple safety alert not supported";
    CFTypeID v12 = v9;
    uint32_t v13 = 2;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
LABEL_29:
    uint64_t v10 = 0;
  }
LABEL_30:
  sub_100057D78((const void **)&theDict);
  return v10;
}

void sub_101050254(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **CellBroadcastConfig::getAppleSafetyAlertConfig_sync@<X0>(CellBroadcastConfig *this@<X0>, void *a2@<X8>)
{
  CFDictionaryRef v23 = 0;
  subscriber::makeSimSlotRange();
  char v5 = v20;
  CFArrayRef v4 = v21;
  if (v20 == v21) {
    goto LABEL_19;
  }
  uint64_t v6 = v22;
  while ((v22(*v5) & 1) == 0)
  {
    if (++v5 == v21)
    {
      char v5 = v21;
      break;
    }
  }
  uint64_t v7 = v21;
  if (v5 == v21)
  {
LABEL_19:
    *a2 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v8 = *v5;
      CFIndex v9 = (Registry **)*((void *)this + 46);
      uint64_t v10 = operator new(0x10uLL);
      int v16 = v10 + 2;
      CFDictionaryRef v17 = v10 + 2;
      *uint64_t v10 = @"CellBroadcast";
      v10[1] = @"AppleSafetyAlert";
      long long __p = v10;
      sub_1007EC3B4(v9, v8, 2, (uint64_t)&__p, 0, 0, &v18);
      sub_10004EFE4(&v19, &v18);
      uint64_t v11 = v23;
      CFDictionaryRef v23 = v19;
      CFTypeID v24 = v11;
      uint64_t v19 = 0;
      sub_100057D78(&v24);
      sub_100057D78(&v19);
      sub_1000577C4(&v18);
      if (__p)
      {
        int v16 = __p;
        operator delete(__p);
      }
      if (v23 ? sub_100080778 : 0) {
        break;
      }
      uint32_t v13 = v5 + 1;
      char v5 = v4;
      if (v13 != v4)
      {
        char v5 = v13;
        while ((v6(*v5) & 1) == 0)
        {
          if (++v5 == v4)
          {
            char v5 = v4;
            break;
          }
        }
      }
      if (v5 == v7) {
        goto LABEL_19;
      }
    }
    *a2 = v23;
    CFDictionaryRef v23 = 0;
  }
  return sub_100057D78(&v23);
}

void sub_10105041C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17)
{
}

void sub_101050464(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_101050580(uint64_t a1, sms::Model **a2)
{
  uint64_t v4 = *((unsigned int *)*a2 + 2);
  char v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
  uint64_t v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Preparing the cell broadcast notification", buf, 2u);
  }
  uint64_t v7 = *a2;
  uint64_t v8 = (std::__shared_weak_count *)a2[1];
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    int v9 = *((_DWORD *)v7 + 12);
    sub_10004D2C8(v8);
    uint64_t v7 = *a2;
    if (v9 != 2)
    {
      uint64_t v10 = (std::__shared_weak_count *)a2[1];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        int v11 = *((_DWORD *)v7 + 12);
        sub_10004D2C8(v10);
        if (v11 != 1) {
          goto LABEL_32;
        }
        uint64_t v7 = *a2;
        goto LABEL_18;
      }
      int v12 = *((_DWORD *)v7 + 12);
LABEL_17:
      if (v12 != 1) {
        goto LABEL_32;
      }
LABEL_18:
      int v19 = (*(uint64_t (**)(sms::Model *))(*(void *)v7 + 368))(v7);
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_101055604;
      *(void *)&uint8_t buf[24] = &unk_101A82270;
      LODWORD(v315) = v19;
      sub_1010553D4((const void **)&v312, a1, v4, @"MessageIDParameters3GPP", (uint64_t)buf);
      if ((void)v312) {
        CFTypeID v14 = sub_100080778;
      }
      else {
        CFTypeID v14 = 0;
      }
      BOOL v15 = v14 != 0;
      sub_100057D78((const void **)&v312);
      int v16 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        unsigned __int16 v20 = "false";
        if (v14) {
          unsigned __int16 v20 = "true";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v20;
        CFTypeID v18 = "#I Received message is a 3GPP message, and is it valid: %s";
        goto LABEL_25;
      }
      goto LABEL_31;
    }
  }
  else
  {
    int v12 = *((_DWORD *)v7 + 12);
    if (v12 != 2) {
      goto LABEL_17;
    }
  }
  int v13 = (*(uint64_t (**)(sms::Model *))(*(void *)v7 + 424))(v7);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_1010556E8;
  *(void *)&uint8_t buf[24] = &unk_101A82290;
  LODWORD(v315) = v13;
  sub_1010553D4((const void **)&v312, a1, v4, @"MessageIDParameters3GPP2", (uint64_t)buf);
  if ((void)v312) {
    CFTypeID v14 = sub_100080778;
  }
  else {
    CFTypeID v14 = 0;
  }
  BOOL v15 = v14 != 0;
  sub_100057D78((const void **)&v312);
  int v16 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    CFDictionaryRef v17 = "false";
    if (v14) {
      CFDictionaryRef v17 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    CFTypeID v18 = "#I Received message is a 3GPP2 message, and is it valid: %s";
LABEL_25:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v18, buf, 0xCu);
    if (v14) {
      goto LABEL_26;
    }
LABEL_32:
    CFNumberRef v26 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      int v27 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 424))(*a2);
      int v28 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 368))(*a2);
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v27;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Received an invalid cell broadcast message with Category: %u, Message Identifier: %u, not sending it out", buf, 0xEu);
    }
    return;
  }
LABEL_31:
  if (!v15) {
    goto LABEL_32;
  }
LABEL_26:
  CFTypeID v21 = *a2;
  int v22 = (std::__shared_weak_count *)a2[1];
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    int v23 = *((_DWORD *)v21 + 12);
    sub_10004D2C8(v22);
    CFTypeID v21 = *a2;
    if (v23 != 2)
    {
      CFTypeID v24 = (std::__shared_weak_count *)a2[1];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        int v25 = *((_DWORD *)v21 + 12);
        sub_10004D2C8(v24);
        if (v25 == 1)
        {
          CFTypeID v21 = *a2;
LABEL_40:
          unsigned int v37 = (*(uint64_t (**)(sms::Model *))(*(void *)v21 + 368))(v21);
          int v31 = sub_10104FEE0((CellBroadcastConfig *)a1, 1, v37);
          uint64_t v38 = *(Registry ***)(a1 + 368);
          *(void *)long long buf = 0;
          sub_10104B9E0(&v312, v38, v4, @"CheckDuplicatesAcross3GPPAnd3GPP2", kCFBooleanFalse);
          sub_1000057AC(buf, (CFTypeRef *)&v312);
          sub_1000577C4((const void **)&v312);
          LOBYTE(v312) = 0;
          ctu::cf::assign((ctu::cf *)&v312, *(BOOL **)buf, v39);
          int v40 = v312;
          sub_100062778((const void **)buf);
          if (v40)
          {
            BOOL v41 = *(uint64_t (****)(void, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 176);
            uint64_t v42 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 368))(*a2);
            uint64_t v43 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 408))(*a2);
            if (((**v41)(v41, v4, 1, v42, v43) & 1) == 0)
            {
              CFDictionaryRef v34 = *v5;
              if (!os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT)) {
                return;
              }
              int v44 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 408))(*a2);
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v44;
              uint64_t v36 = "#I Message with Serial Number: %u is already seen";
LABEL_44:
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v36, buf, 8u);
              return;
            }
          }
          goto LABEL_46;
        }
LABEL_45:
        int v31 = 0;
        goto LABEL_46;
      }
      int v29 = *((_DWORD *)v21 + 12);
LABEL_39:
      if (v29 == 1) {
        goto LABEL_40;
      }
      goto LABEL_45;
    }
  }
  else
  {
    int v29 = *((_DWORD *)v21 + 12);
    if (v29 != 2) {
      goto LABEL_39;
    }
  }
  unsigned int MessageID = sms::Model::getMessageID(v21);
  int v31 = sub_10104FEE0((CellBroadcastConfig *)a1, 2, MessageID);
  BOOL v32 = *(uint64_t (****)(void, uint64_t, uint64_t, void, uint64_t))(a1 + 176);
  uint64_t v33 = sms::Model::getMessageID(*a2);
  if (((**v32)(v32, v4, 2, 0, v33) & 1) == 0)
  {
    CFDictionaryRef v34 = *v5;
    if (!os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v35 = sms::Model::getMessageID(*a2);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v35;
    uint64_t v36 = "#I Message with MSG ID: %u is already seen";
    goto LABEL_44;
  }
LABEL_46:
  (*(void (**)(void **__return_ptr))(*(void *)*a2 + 192))(v295);
  if ((*(unsigned int (**)(void, uint64_t, void **))(**(void **)(a1 + 176) + 8))(*(void *)(a1 + 176), v4, v295))
  {
    BOOL v45 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Message filtered based on content...", buf, 2u);
    }
    goto LABEL_433;
  }
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (theDict) {
    uint32_t v46 = sub_1000C06D0;
  }
  else {
    uint32_t v46 = 0;
  }
  if (!v46)
  {
    BOOL v55 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Failed to allocate dictionary for notification", buf, 2u);
    }
    goto LABEL_432;
  }
  v293 = 0;
  unsigned int v47 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 368))(*a2);
  *(void *)&long long v312 = 0;
  *(void *)long long buf = v47;
  CFNumberRef v48 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
  if (v48)
  {
    uint64_t v49 = v312;
    *(void *)&long long v312 = v48;
    *(void *)long long buf = v49;
    sub_1000570E8((const void **)buf);
  }
  v293 = (const void *)v312;
  *(void *)&long long v312 = 0;
  sub_1000570E8((const void **)&v312);
  CFDictionarySetValue(theDict, @"AlertMessageID", v293);
  if (v31) {
    CFDictionarySetValue(theDict, @"kCTSMSAppleSafetyAlertSupport", kCFBooleanTrue);
  }
  CFArrayRef v292 = 0;
  unint64_t v50 = *a2;
  os_log_t v51 = (std::__shared_weak_count *)a2[1];
  if (!v51)
  {
    int v56 = *((_DWORD *)v50 + 12);
    if (v56 != 2) {
      goto LABEL_84;
    }
LABEL_65:
    int v57 = (*(uint64_t (**)(sms::Model *))(*(void *)v50 + 424))(v50);
    *(void *)&long long v312 = 0;
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1010556E8;
    *(void *)&uint8_t buf[24] = &unk_101A82290;
    LODWORD(v315) = v57;
    sub_1010553D4((const void **)&v312, a1, v4, @"MessageIDParameters3GPP2", (uint64_t)buf);
    if ((void)v312) {
      CFBooleanRef v59 = sub_100080778;
    }
    else {
      CFBooleanRef v59 = 0;
    }
    if (v59)
    {
      char v60 = (BOOL *)CFDictionaryGetValue((CFDictionaryRef)v312, @"EmergencyAlert");
      uint64_t v61 = v60;
      if (v60)
      {
        CFTypeID v62 = CFGetTypeID(v60);
        if (v62 != CFBooleanGetTypeID()) {
          uint64_t v61 = 0;
        }
      }
    }
    else
    {
      uint64_t v61 = 0;
    }
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_10104EDA8;
    *(void *)&uint8_t buf[24] = &unk_101A82250;
    LODWORD(v315) = v57;
    LOBYTE(theArray[0]) = 0;
    ctu::cf::assign((ctu::cf *)theArray, v61, v58);
    CSIPhoneNumber v63 = sub_10104E29C(a1, v4, @"MessageIDParameters3GPP2", (uint64_t)buf, LOBYTE(theArray[0]));
    uint64_t v65 = v64;
    theArray[0] = v63;
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CSIPhoneNumber v67 = Mutable;
    if (v61) {
      CFBooleanRef v68 = (CFBooleanRef)v61;
    }
    else {
      CFBooleanRef v68 = kCFBooleanFalse;
    }
    CFArrayAppendValue(Mutable, v68);
    CFArrayRef v69 = theArray[0];
    if (theArray[0]) {
      long long v70 = sub_100083F10;
    }
    else {
      long long v70 = 0;
    }
    if (v70)
    {
      v321.length = CFArrayGetCount(theArray[0]);
      v321.location = 0;
      CFArrayAppendArray(v67, v69, v321);
    }
    sub_100044D00((const void **)theArray);
    sub_100057D78((const void **)&v312);
    CFArrayRef v71 = v292;
    CFArrayRef v292 = v67;
    goto LABEL_114;
  }
  atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
  int v52 = *((_DWORD *)v50 + 12);
  sub_10004D2C8(v51);
  unint64_t v50 = *a2;
  if (v52 == 2) {
    goto LABEL_65;
  }
  os_log_t v53 = (std::__shared_weak_count *)a2[1];
  if (!v53)
  {
    int v56 = *((_DWORD *)v50 + 12);
LABEL_84:
    if (v56 == 1) {
      goto LABEL_85;
    }
    goto LABEL_95;
  }
  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  int v54 = *((_DWORD *)v50 + 12);
  sub_10004D2C8(v53);
  if (v54 == 1)
  {
    unint64_t v50 = *a2;
LABEL_85:
    int v72 = (*(uint64_t (**)(sms::Model *))(*(void *)v50 + 368))(v50);
    int v73 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 400))(*a2);
    long long v74 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    *(void *)&long long v312 = 0;
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_101055604;
    *(void *)&uint8_t buf[24] = &unk_101A82270;
    LODWORD(v315) = v72;
    sub_1010553D4((const void **)&v312, a1, v4, @"MessageIDParameters3GPP", (uint64_t)buf);
    if ((void)v312) {
      uint64_t v75 = sub_100080778;
    }
    else {
      uint64_t v75 = 0;
    }
    if (v75
      && (long long v76 = (BOOL *)CFDictionaryGetValue((CFDictionaryRef)v312, @"EmergencyAlert"), (v77 = v76) != 0)
      && (CFTypeID v78 = CFGetTypeID(v76), v78 == CFBooleanGetTypeID()))
    {
      buf[0] = 0;
      ctu::cf::assign((ctu::cf *)buf, v77, v79);
      int v80 = buf[0];
      int v81 = buf[0] != 0;
      long long v82 = *v74;
      if (os_log_type_enabled(*v74, OS_LOG_TYPE_DEFAULT))
      {
        long long v83 = "false";
        if (v80) {
          long long v83 = "true";
        }
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v72;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v83;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I Message ID %u needs to be marked as an Emergency Alert: %s", buf, 0x12u);
      }
    }
    else
    {
      int v85 = sub_10104E978(a1, v4, v72);
      uint64_t v86 = *v74;
      if (os_log_type_enabled(*v74, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v87 = "false";
        if (v85) {
          uint64_t v88 = "true";
        }
        else {
          uint64_t v88 = "false";
        }
        *(_DWORD *)long long buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v72;
        *(void *)&buf[10] = v88;
        *(_WORD *)&uint8_t buf[8] = 2080;
        if (v73) {
          uint64_t v87 = "true";
        }
        *(_WORD *)&unsigned char buf[18] = 2080;
        *(void *)&buf[20] = v87;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I Message ID %u has been processed as ETWS message: %s and is an Emergency Alert: %s", buf, 0x1Cu);
      }
      int v81 = v73 & v85;
    }
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_10104EC7C;
    *(void *)&uint8_t buf[24] = &unk_101A82230;
    DWORD2(v315) = v72;
    *(void *)&long long v315 = v74;
    uint64_t v89 = sub_10104E29C(a1, v4, @"MessageIDParameters3GPP", (uint64_t)buf, v81);
    uint64_t v65 = v90;
    theArray[0] = v89;
    __int16 v91 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    id v92 = v91;
    __int16 v93 = (const void **)&kCFBooleanTrue;
    if (!v81) {
      __int16 v93 = (const void **)&kCFBooleanFalse;
    }
    CFArrayAppendValue(v91, *v93);
    CFArrayRef v94 = theArray[0];
    if (theArray[0]) {
      __int16 v95 = sub_100083F10;
    }
    else {
      __int16 v95 = 0;
    }
    if (v95)
    {
      v322.length = CFArrayGetCount(theArray[0]);
      v322.location = 0;
      CFArrayAppendArray(v92, v94, v322);
    }
    sub_100044D00((const void **)theArray);
    sub_100057D78((const void **)&v312);
    CFArrayRef v71 = v292;
    CFArrayRef v292 = v92;
LABEL_114:
    *(void *)long long buf = v71;
    sub_100044D00((const void **)buf);
    goto LABEL_115;
  }
LABEL_95:
  uint64_t v84 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "Unknown message type", buf, 2u);
  }
  uint64_t v65 = 0;
LABEL_115:
  uint64_t v96 = (std::__shared_weak_count *)a2[1];
  v290 = *a2;
  v291 = v96;
  if (v96) {
    atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CellBroadcastConfig::postAWDMetric_sync(a1, (uint64_t *)&v290);
  if (v291) {
    sub_10004D2C8(v291);
  }
  value = 0;
  if (v292) {
    uint64_t v97 = sub_100083F10;
  }
  else {
    uint64_t v97 = 0;
  }
  if (!v97)
  {
    long long v102 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v102, OS_LOG_TYPE_ERROR)) {
      goto LABEL_150;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v103 = "Failed to get configuration for this message";
    goto LABEL_129;
  }
  CFIndex Count = CFArrayGetCount(v292);
  if (Count < 1) {
    goto LABEL_150;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v292, 0);
  uint64_t v100 = ValueAtIndex;
  if (ValueAtIndex && (CFTypeID v101 = CFGetTypeID(ValueAtIndex), v101 == CFBooleanGetTypeID()))
  {
    CFDictionarySetValue(theDict, @"kCTSMSCellBroadcastEmergencyUserAlert", v100);
  }
  else
  {
    uint64_t v104 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_ERROR, "Failed to get the emergency user alert from configuration", buf, 2u);
    }
  }
  if ((unint64_t)Count < 2) {
    goto LABEL_150;
  }
  *(void *)&long long v312 = CFArrayGetValueAtIndex(v292, 1);
  *(void *)long long buf = 0;
  sub_10004EFE4(buf, (CFTypeRef *)&v312);
  uint64_t v105 = value;
  value = *(void **)buf;
  *(void *)long long buf = v105;
  sub_100057D78((const void **)buf);
  uint64_t v107 = *a2;
  uint64_t v106 = (std::__shared_weak_count *)a2[1];
  if (v106)
  {
    atomic_fetch_add_explicit(&v106->__shared_owners_, 1uLL, memory_order_relaxed);
    int v108 = *((_DWORD *)v107 + 12);
    sub_10004D2C8(v106);
    if (v108 != 1) {
      goto LABEL_138;
    }
    goto LABEL_137;
  }
  if (*((_DWORD *)v107 + 12) == 1)
  {
LABEL_137:
    sub_100058198(&v288, (const void **)&value);
    unsigned int v109 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 368))(*a2);
    sub_101053A04((CFDictionaryRef *)&v312, a1, v4, (CFDictionaryRef *)&v288, v65, v109);
    *(void *)long long buf = value;
    value = (void *)v312;
    *(void *)&long long v312 = 0;
    sub_100057D78((const void **)buf);
    sub_100057D78((const void **)&v312);
    sub_100057D78(&v288);
  }
LABEL_138:
  if (value) {
    char v110 = sub_100080778;
  }
  else {
    char v110 = 0;
  }
  if (v110)
  {
    CFDictionarySetValue(theDict, @"AlertType", value);
  }
  else
  {
    uint64_t v111 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "Failed to get the alert title from configuration", buf, 2u);
    }
  }
  if ((unint64_t)Count >= 3)
  {
    char v112 = CFArrayGetValueAtIndex(v292, 2);
    uint64_t v113 = v112;
    if (v112)
    {
      CFTypeID v114 = CFGetTypeID(v112);
      if (v114 == CFDictionaryGetTypeID())
      {
        CFDictionarySetValue(theDict, @"AlertConfiguration", v113);
        goto LABEL_150;
      }
    }
    long long v102 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v103 = "Failed to get the alert configuration from configuration";
LABEL_129:
      _os_log_error_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, v103, buf, 2u);
    }
  }
LABEL_150:
  std::string v115 = *a2;
  uint64_t v116 = (std::__shared_weak_count *)a2[1];
  if (v116)
  {
    atomic_fetch_add_explicit(&v116->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*((_DWORD *)v115 + 12) == 1)
    {
      std::string v115 = *a2;
      goto LABEL_154;
    }
    sub_10004D2C8(v116);
  }
  else if (*((_DWORD *)v115 + 12) == 1)
  {
LABEL_154:
    unsigned __int16 v117 = (*(uint64_t (**)(sms::Model *))(*(void *)v115 + 368))(v115);
    int v118 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 440))(*a2);
    BOOL v119 = sub_10104EF78(a1, v4, v117, v118);
    if (v116) {
      sub_10004D2C8(v116);
    }
    if (v119)
    {
      __int16 v120 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I Dropping multi-lang Alert...", buf, 2u);
      }
      goto LABEL_431;
    }
  }
  CFTypeRef cf = 0;
  if (v296 >= 0) {
    uint64_t v121 = v295;
  }
  else {
    uint64_t v121 = (void **)v295[0];
  }
  CFStringRef v122 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v121, 0x8000100u);
  CFTypeRef cf = v122;
  if (v122) {
    int v123 = sub_1000810B8;
  }
  else {
    int v123 = 0;
  }
  if (!v123)
  {
    v153 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_ERROR, "Failed to allocate string for broadcasted message", buf, 2u);
    }
    goto LABEL_430;
  }
  CFDictionarySetValue(theDict, @"kCTSMSCellBroadcastString", v122);
  v284 = 0;
  v285 = 0;
  v286 = 0;
  unsigned int v274 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 368))(*a2);
  CFStringRef theString = (CFStringRef)cf;
  if (cf) {
    CFRetain(cf);
  }
  v276 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
  long long v312 = 0uLL;
  v313 = 0;
  v311 = 0;
  sub_1007EC524(*(Registry ***)(a1 + 368), v4, 2, @"CellBroadcast", 0, 0, buf);
  sub_10004EFE4(&v311, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v311) {
    uint64_t v124 = sub_100080778;
  }
  else {
    uint64_t v124 = 0;
  }
  if (!v124)
  {
    v154 = *v276;
    if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_ERROR, "Translation failed. No CellBroadcast dict", buf, 2u);
    }
    sub_101057B70((const void **)&v284, (const void **)&v312);
    goto LABEL_278;
  }
  CFArrayRef v310 = 0;
  uint64_t v125 = *(Registry ***)(a1 + 368);
  __int16 v126 = operator new(0x18uLL);
  *(void *)&uint8_t buf[16] = v126 + 3;
  void *v126 = @"CellBroadcast";
  v126[1] = @"TranslationParameters";
  v126[2] = @"MessageIDRange";
  *(void *)long long buf = v126;
  *(void *)&uint8_t buf[8] = v126 + 3;
  sub_1007EC3B4(v125, v4, 2, (uint64_t)buf, 0, 0, theArray);
  sub_100044D6C(&v310, (CFTypeRef *)theArray);
  sub_1000577C4((const void **)theArray);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v310) {
    uint64_t v127 = sub_100083F10;
  }
  else {
    uint64_t v127 = 0;
  }
  if (!v127)
  {
LABEL_276:
    sub_101057B70((const void **)&v284, (const void **)&v312);
    goto LABEL_277;
  }
  CFIndex v128 = CFArrayGetCount(v310);
  if (v128 < 1)
  {
LABEL_274:
    v189 = *v276;
    if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_ERROR, "Failed to match Translation reference", buf, 2u);
    }
    goto LABEL_276;
  }
  CFIndex v129 = 0;
  while (1)
  {
    CFDictionaryRef v130 = (const __CFDictionary *)CFArrayGetValueAtIndex(v310, v129);
    CFDictionaryRef v131 = v130;
    if (v130)
    {
      CFTypeID v132 = CFGetTypeID(v130);
      if (v132 == CFDictionaryGetTypeID()) {
        break;
      }
    }
    os_log_t v137 = *v276;
    if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v129;
      __int16 v138 = v137;
      BOOL v139 = "Invalid Message ID dictionary at index: %ld";
      uint32_t v140 = 12;
LABEL_204:
      _os_log_error_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_ERROR, v139, buf, v140);
    }
LABEL_205:
    if (v128 == ++v129) {
      goto LABEL_274;
    }
  }
  unint64_t v133 = (unsigned __int16 *)CFDictionaryGetValue(v131, @"FromServiceID");
  __int16 v134 = v133;
  if (v133)
  {
    CFTypeID v135 = CFGetTypeID(v133);
    if (v135 == CFNumberGetTypeID()) {
      __int16 v136 = v134;
    }
    else {
      __int16 v136 = 0;
    }
  }
  else
  {
    __int16 v136 = 0;
  }
  int v141 = (unsigned __int16 *)CFDictionaryGetValue(v131, @"ToServiceID");
  __int16 v142 = v141;
  if (!v141 || (CFTypeID v143 = CFGetTypeID(v141), v143 != CFNumberGetTypeID()) || !v136)
  {
    os_log_t v152 = *v276;
    if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      __int16 v138 = v152;
      BOOL v139 = "Invalid From / To reference";
      uint32_t v140 = 2;
      goto LABEL_204;
    }
    goto LABEL_205;
  }
  *(_WORD *)long long buf = 0;
  ctu::cf::assign((ctu::cf *)buf, v136, v144);
  unsigned int v145 = *(unsigned __int16 *)buf;
  *(_WORD *)long long buf = 0;
  ctu::cf::assign((ctu::cf *)buf, v142, v146);
  if (v274 < v145) {
    goto LABEL_205;
  }
  int v147 = *(unsigned __int16 *)buf;
  if (v274 > *(unsigned __int16 *)buf) {
    goto LABEL_205;
  }
  theArray[0] = 0;
  *(void *)long long buf = CFDictionaryGetValue(v131, @"TranslationReference");
  sub_100056248(theArray, (CFTypeRef *)buf);
  CFArrayRef v148 = theArray[0];
  if (theArray[0]) {
    uint64_t v149 = sub_1000810B8;
  }
  else {
    uint64_t v149 = 0;
  }
  __int16 v150 = *v276;
  v151 = *v276;
  if (!v149)
  {
    if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_ERROR, "Failed to read Translation reference", buf, 2u);
    }
    sub_1000558F4((const void **)theArray);
    goto LABEL_205;
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v145;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v147;
    _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I Translation possible [%d %d]", buf, 0xEu);
    CFArrayRef v148 = theArray[0];
  }
  sub_1000558F4((const void **)theArray);
  if (!v148) {
    goto LABEL_274;
  }
  if ((sub_10104F860(a1, v4) & 1) == 0) {
    goto LABEL_276;
  }
  CFArrayRef v156 = v148;
  v157 = (const __CFString **)(a1 + 456);
  if (*(char *)(a1 + 479) < 0) {
    v157 = (const __CFString **)*v157;
  }
  v307.__r_.__value_.__r.__words[0] = 0;
  theArray[0] = 0;
  if (ctu::cf::convert_copy((ctu::cf *)theArray, v157, (const char *)0x8000100, kCFAllocatorDefault, v155))
  {
    std::string::size_type v158 = v307.__r_.__value_.__r.__words[0];
    v307.__r_.__value_.__l.__data_ = (std::string::pointer)theArray[0];
    *(void *)long long buf = v158;
    sub_1000558F4((const void **)buf);
  }
  v306.__r_.__value_.__r.__words[0] = v307.__r_.__value_.__r.__words[0];
  v307.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&v307.__r_.__value_.__l.__data_);
  key = (void *)v306.__r_.__value_.__r.__words[0];
  sub_1000558F4((const void **)&v306.__r_.__value_.__l.__data_);
  theArray[0] = 0;
  theArray[1] = 0;
  v309 = 0;
  memset(buf, 0, 24);
  ctu::cf::assign();
  std::string v306 = *(std::string *)buf;
  sub_100058DB0(&v305, " ");
  if ((v305.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v159 = &v305;
  }
  else {
    v159 = (std::string *)v305.__r_.__value_.__r.__words[0];
  }
  if ((v305.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v305.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v305.__r_.__value_.__l.__size_;
  }
  v161 = std::string::append(&v306, (const std::string::value_type *)v159, size);
  long long v162 = *(_OWORD *)&v161->__r_.__value_.__l.__data_;
  v307.__r_.__value_.__r.__words[2] = v161->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v307.__r_.__value_.__l.__data_ = v162;
  v161->__r_.__value_.__l.__size_ = 0;
  v161->__r_.__value_.__r.__words[2] = 0;
  v161->__r_.__value_.__r.__words[0] = 0;
  memset(buf, 0, 24);
  ctu::cf::assign();
  long long __p = *(_OWORD *)buf;
  uint64_t v304 = *(void *)&buf[16];
  if (buf[23] >= 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if (buf[23] >= 0) {
    std::string::size_type v164 = buf[23];
  }
  else {
    std::string::size_type v164 = *((void *)&__p + 1);
  }
  v165 = std::string::append(&v307, p_p, v164);
  long long v166 = *(_OWORD *)&v165->__r_.__value_.__l.__data_;
  v309 = (const void *)v165->__r_.__value_.__r.__words[2];
  *(_OWORD *)CFArrayRef theArray = v166;
  v165->__r_.__value_.__l.__size_ = 0;
  v165->__r_.__value_.__r.__words[2] = 0;
  v165->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v304) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v307.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v307.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v305.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v305.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v306.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v306.__r_.__value_.__l.__data_);
  }
  memset(&v307, 0, sizeof(v307));
  memset(buf, 0, 24);
  ctu::cf::assign();
  std::string v305 = *(std::string *)buf;
  sub_100058DB0(&__p, " ");
  if (v304 >= 0) {
    v167 = (const std::string::value_type *)&__p;
  }
  else {
    v167 = (const std::string::value_type *)__p;
  }
  if (v304 >= 0) {
    std::string::size_type v168 = HIBYTE(v304);
  }
  else {
    std::string::size_type v168 = *((void *)&__p + 1);
  }
  v169 = std::string::append(&v305, v167, v168);
  long long v170 = *(_OWORD *)&v169->__r_.__value_.__l.__data_;
  v306.__r_.__value_.__r.__words[2] = v169->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v306.__r_.__value_.__l.__data_ = v170;
  v169->__r_.__value_.__l.__size_ = 0;
  v169->__r_.__value_.__r.__words[2] = 0;
  v169->__r_.__value_.__r.__words[0] = 0;
  memset(buf, 0, 24);
  ctu::cf::assign();
  long long v301 = *(_OWORD *)buf;
  uint64_t v302 = *(void *)&buf[16];
  if (buf[23] >= 0) {
    v171 = (const std::string::value_type *)&v301;
  }
  else {
    v171 = (const std::string::value_type *)v301;
  }
  if (buf[23] >= 0) {
    std::string::size_type v172 = buf[23];
  }
  else {
    std::string::size_type v172 = *((void *)&v301 + 1);
  }
  v173 = std::string::append(&v306, v171, v172);
  long long v174 = *(_OWORD *)&v173->__r_.__value_.__l.__data_;
  v307.__r_.__value_.__r.__words[2] = v173->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v307.__r_.__value_.__l.__data_ = v174;
  v173->__r_.__value_.__l.__size_ = 0;
  v173->__r_.__value_.__r.__words[2] = 0;
  v173->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v302) < 0) {
    operator delete((void *)v301);
  }
  if (SHIBYTE(v306.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v306.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v304) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v305.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v305.__r_.__value_.__l.__data_);
  }
  v305.__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v309) >= 0) {
    v175 = theArray;
  }
  else {
    v175 = (CFArrayRef *)theArray[0];
  }
  v305.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v175, 0x8000100u);
  *(void *)&long long __p = 0;
  if ((v307.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v176 = &v307;
  }
  else {
    v176 = (std::string *)v307.__r_.__value_.__r.__words[0];
  }
  *(void *)&long long __p = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v176, 0x8000100u);
  *(void *)&long long v301 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v177, *(Registry **)(a1 + 240));
  v179 = ServiceMap;
  uint64_t v181 = v180;
  if (v180 < 0)
  {
    v182 = (unsigned __int8 *)(v180 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v183 = 5381;
    do
    {
      uint64_t v181 = v183;
      unsigned int v184 = *v182++;
      uint64_t v183 = (33 * v183) ^ v184;
    }
    while (v184);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v181;
  v185 = sub_10004D37C(&v179[1].__m_.__sig, (unint64_t *)buf);
  if (v185)
  {
    uint64_t v187 = v185[3];
    v186 = (std::__shared_weak_count *)v185[4];
    if (v186)
    {
      atomic_fetch_add_explicit(&v186->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v179);
      atomic_fetch_add_explicit(&v186->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v186);
      char v188 = 0;
      goto LABEL_439;
    }
  }
  else
  {
    uint64_t v187 = 0;
  }
  std::mutex::unlock(v179);
  v186 = 0;
  char v188 = 1;
LABEL_439:
  uint64_t v243 = kCellBroadcastLocalizationTable;
  (*(void (**)(long long *__return_ptr, uint64_t, void, std::string::size_type, uint64_t))(*(void *)v187 + 16))(&v301, v187, kCellBroadcastLocalizationTable, v305.__r_.__value_.__r.__words[0], 1);
  if ((v188 & 1) == 0) {
    sub_10004D2C8(v186);
  }
  v300 = 0;
  v245 = (std::mutex *)Registry::getServiceMap(v244, *(Registry **)(a1 + 240));
  v246 = v245;
  if (v180 < 0)
  {
    v247 = (unsigned __int8 *)(v180 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v248 = 5381;
    do
    {
      uint64_t v180 = v248;
      unsigned int v249 = *v247++;
      uint64_t v248 = (33 * v248) ^ v249;
    }
    while (v249);
  }
  std::mutex::lock(v245);
  *(void *)long long buf = v180;
  v250 = sub_10004D37C(&v246[1].__m_.__sig, (unint64_t *)buf);
  if (v250)
  {
    uint64_t v252 = v250[3];
    v251 = (std::__shared_weak_count *)v250[4];
    if (v251)
    {
      atomic_fetch_add_explicit(&v251->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v246);
      atomic_fetch_add_explicit(&v251->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v251);
      char v253 = 0;
      goto LABEL_449;
    }
  }
  else
  {
    uint64_t v252 = 0;
  }
  std::mutex::unlock(v246);
  v251 = 0;
  char v253 = 1;
LABEL_449:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, void, uint64_t))(*(void *)v252 + 16))(&v300, v252, v243, __p, 1);
  if ((v253 & 1) == 0) {
    sub_10004D2C8(v251);
  }
  CFDictionaryRef v299 = 0;
  v254 = *(Registry ***)(a1 + 368);
  v255 = operator new(0x28uLL);
  *(void *)&uint8_t buf[16] = v255 + 5;
  void *v255 = @"CellBroadcast";
  v255[1] = @"TranslationParameters";
  v255[2] = @"Translations";
  v255[3] = v156;
  v255[4] = key;
  *(void *)long long buf = v255;
  *(void *)&uint8_t buf[8] = v255 + 5;
  sub_1007EC3B4(v254, v4, 2, (uint64_t)buf, 0, 0, &v306);
  sub_10004EFE4(&v299, (CFTypeRef *)&v306.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&v306.__r_.__value_.__l.__data_);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  CFDictionaryRef v256 = v299;
  if (v299) {
    v257 = sub_100080778;
  }
  else {
    v257 = 0;
  }
  if (!v257)
  {
    v258 = *v276;
    if (os_log_type_enabled(*v276, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v258, OS_LOG_TYPE_DEFAULT, "#I Attempting to read default language", buf, 2u);
    }
    v259 = *(Registry ***)(a1 + 368);
    v260 = operator new(0x28uLL);
    *(void *)&uint8_t buf[16] = v260 + 5;
    void *v260 = @"CellBroadcast";
    v260[1] = @"TranslationParameters";
    v260[2] = @"Translations";
    v260[3] = v156;
    v260[4] = @"default";
    *(void *)long long buf = v260;
    *(void *)&uint8_t buf[8] = v260 + 5;
    sub_1007EC3B4(v259, v4, 2, (uint64_t)buf, 0, 0, &v297);
    sub_10004EFE4(v298, &v297);
    v306.__r_.__value_.__r.__words[0] = (std::string::size_type)v299;
    CFDictionaryRef v299 = *(CFDictionaryRef *)v298;
    *(void *)v298 = 0;
    sub_100057D78((const void **)&v306.__r_.__value_.__l.__data_);
    sub_100057D78((const void **)v298);
    sub_1000577C4(&v297);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    CFDictionaryRef v256 = v299;
  }
  if (v256) {
    v261 = sub_100080778;
  }
  else {
    v261 = 0;
  }
  if (v261)
  {
    v306.__r_.__value_.__r.__words[0] = 0;
    v262 = *(Registry ***)(a1 + 368);
    v263 = operator new(0x28uLL);
    *(void *)&uint8_t buf[16] = v263 + 5;
    void *v263 = @"CellBroadcast";
    v263[1] = @"TranslationParameters";
    v263[2] = @"Translations";
    v263[3] = @"AlertKeywords";
    v263[4] = v156;
    *(void *)long long buf = v263;
    *(void *)&uint8_t buf[8] = v263 + 5;
    sub_1007EC3B4(v262, v4, 2, (uint64_t)buf, 0, 0, v298);
    sub_100044D6C(&v306, (CFTypeRef *)v298);
    sub_1000577C4((const void **)v298);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    CFArrayRef v264 = (const __CFArray *)v306.__r_.__value_.__r.__words[0];
    if (v306.__r_.__value_.__r.__words[0]) {
      v265 = sub_100083F10;
    }
    else {
      v265 = 0;
    }
    if (v265)
    {
      for (CFIndex i = 0; i < CFArrayGetCount(v264); ++i)
      {
        CFStringRef v267 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v306.__r_.__value_.__l.__data_, i);
        CFStringRef v268 = v267;
        if (v267)
        {
          CFTypeID v269 = CFGetTypeID(v267);
          if (v269 == CFStringGetTypeID())
          {
            v323.length = CFStringGetLength(theString);
            v323.location = 0;
            if (!CFStringFindWithOptions(theString, v268, v323, 1uLL, 0))
            {
              v273 = *v276;
              if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v273, OS_LOG_TYPE_ERROR, "Failed to match essential expression", buf, 2u);
              }
              sub_101057B70((const void **)&v284, (const void **)&v312);
              goto LABEL_485;
            }
          }
        }
        CFArrayRef v264 = (const __CFArray *)v306.__r_.__value_.__r.__words[0];
      }
    }
    *(void *)long long buf = 0;
    *(void *)v298 = CFDictionaryGetValue(v299, @"Sound");
    sub_100056248(buf, (CFTypeRef *)v298);
    if (*(void *)buf) {
      v270 = sub_1000810B8;
    }
    else {
      v270 = 0;
    }
    if (!v270)
    {
      v271 = *v276;
      if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v298 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v271, OS_LOG_TYPE_ERROR, "Translated Sound is null", v298, 2u);
      }
    }
    sub_100083DA4((const void **)&v284, &v300);
    sub_100083DA4((const void **)&v285, (const void **)&v301);
    sub_100083DA4((const void **)&v286, (const void **)buf);
    sub_1000558F4((const void **)buf);
LABEL_485:
    sub_100044D00((const void **)&v306.__r_.__value_.__l.__data_);
  }
  else
  {
    v272 = *v276;
    if (os_log_type_enabled(*v276, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v272, OS_LOG_TYPE_ERROR, "Translations not found", buf, 2u);
    }
    sub_101057B70((const void **)&v284, (const void **)&v312);
  }
  sub_100057D78((const void **)&v299);
  sub_1000558F4(&v300);
  sub_1000558F4((const void **)&v301);
  sub_1000558F4((const void **)&__p);
  sub_1000558F4((const void **)&v305.__r_.__value_.__l.__data_);
  if (SHIBYTE(v307.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v307.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v309) < 0) {
    operator delete(theArray[0]);
  }
LABEL_277:
  sub_100044D00((const void **)&v310);
LABEL_278:
  sub_100057D78(&v311);
  sub_1000558F4(&v313);
  sub_1000558F4((const void **)&v312 + 1);
  sub_1000558F4((const void **)&v312);
  sub_1000558F4((const void **)&theString);
  if (v284) {
    v190 = sub_1000810B8;
  }
  else {
    v190 = 0;
  }
  if (v190) {
    CFDictionarySetValue(theDict, @"kCTSMSCellBroadcastTranslatedTitle", v284);
  }
  if (v285) {
    v191 = sub_1000810B8;
  }
  else {
    v191 = 0;
  }
  if (v191) {
    CFDictionarySetValue(theDict, @"kCTSMSCellBroadcastTranslatedText", v285);
  }
  if (v286) {
    v192 = sub_1000810B8;
  }
  else {
    v192 = 0;
  }
  if (v192) {
    CFDictionarySetValue(theDict, @"kCTSMSCellBroadcastTranslatedSound", v286);
  }
  *(void *)&long long __p = 0;
  v193 = *(Registry ***)(a1 + 368);
  v194 = operator new(0x10uLL);
  *(void *)&uint8_t buf[16] = v194 + 2;
  void *v194 = @"CellBroadcast";
  v194[1] = @"PreventScreenCapture";
  *(void *)long long buf = v194;
  *(void *)&uint8_t buf[8] = v194 + 2;
  sub_1007EC3B4(v193, v4, 2, (uint64_t)buf, (uint64_t)kCFBooleanFalse, 0, &v312);
  sub_1000057AC(&__p, (CFTypeRef *)&v312);
  sub_1000577C4((const void **)&v312);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, (BOOL *)__p, v195);
  if (buf[0]) {
    CFDictionarySetValue(theDict, @"PreventScreenCapture", kCFBooleanTrue);
  }
  CFMutableDictionaryRef v282 = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  CellBroadcastConfig::updateWeaWithAppleSafetyAlert_sync((void *)a1, &v282, v295);
  sub_10005717C((const void **)&v282);
  if (*(unsigned char *)(a1 + 448))
  {
    CFDictionarySetValue(theDict, @"BatterySaverModeEnabled", kCFBooleanTrue);
    v196 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    v197 = *v196;
    if (os_log_type_enabled(*v196, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "#I Requesting Baseband online assertion", buf, 2u);
    }
    v198 = operator new(0x10uLL);
    *(void *)&uint8_t buf[16] = v198 + 2;
    void *v198 = @"CellBroadcast";
    v198[1] = @"OnlineTimerDuringBatterySaverModeInMinutes";
    *(void *)long long buf = v198;
    *(void *)&uint8_t buf[8] = v198 + 2;
    *(void *)&long long v312 = 0;
    sub_1007EC3B4(*(Registry ***)(a1 + 368), v4, 2, (uint64_t)buf, 0, 0, theArray);
    sub_1000842D0(&v312, (CFTypeRef *)theArray);
    sub_1000577C4((const void **)theArray);
    LODWORD(theArray[0]) = 3;
    ctu::cf::assign((ctu::cf *)theArray, (unsigned int *)v312, v199);
    unsigned int v200 = theArray[0];
    sub_1000570E8((const void **)&v312);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (v200 >= 3) {
      uint64_t v201 = 3;
    }
    else {
      uint64_t v201 = v200;
    }
    if (*(void *)(a1 + 320))
    {
      sub_1010B5CD8(a1 + 280, 60 * v201);
      v202 = *v196;
      if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v201;
        _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_DEFAULT, "#I Extending baseband online assertion to another %ld minutes", buf, 0xCu);
      }
    }
    else
    {
      v203 = *v196;
      if (os_log_type_enabled(v203, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v201;
        _os_log_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_DEFAULT, "#I Setting baseband online assertion to %ld minutes", buf, 0xCu);
      }
      sub_100118194(a1 + 280, a1 + 544, 60 * v201);
      *(void *)long long buf = off_101A82AE8;
      *(void *)&uint8_t buf[8] = a1;
      *(void *)&uint8_t buf[16] = v4;
      *(void *)&uint8_t buf[24] = buf;
      sub_10033A644((void *)(a1 + 336), (uint64_t)buf);
      sub_100060644(buf);
    }
  }
  theArray[0] = 0;
  theArray[1] = 0;
  v309 = 0;
  int v204 = (*(uint64_t (**)(sms::Model *))(*(void *)*a2 + 440))(*a2);
  *(void *)&long long v312 = 0;
  sub_10104C3A8(&v312, *(Registry ***)(a1 + 368), v4);
  if ((void)v312) {
    v205 = sub_100083F10;
  }
  else {
    v205 = 0;
  }
  if (!v205
    || ((v306.__r_.__value_.__s.__data_[0] = 0, BOOL v206 = sub_10104C7B8(a1, v4, &v306), v306.__r_.__value_.__s.__data_[0])
      ? (BOOL v207 = v206)
      : (BOOL v207 = 0),
        !v207 || (CFIndex v208 = CFArrayGetCount((CFArrayRef)v312), v208 < 1)))
  {
LABEL_343:
    sub_100058DB0(theArray, "");
    goto LABEL_344;
  }
  CFIndex v209 = 0;
  while (2)
  {
    v307.__r_.__value_.__r.__words[0] = 0;
    *(void *)long long buf = CFArrayGetValueAtIndex((CFArrayRef)v312, v209);
    sub_100056248(&v307, (CFTypeRef *)buf);
    if (v307.__r_.__value_.__r.__words[0]) {
      v210 = sub_1000810B8;
    }
    else {
      v210 = 0;
    }
    if (!v210)
    {
LABEL_342:
      sub_1000558F4((const void **)&v307.__r_.__value_.__l.__data_);
      if (++v209 == v208) {
        goto LABEL_343;
      }
      continue;
    }
    break;
  }
  theArray[0] = 0;
  theArray[1] = 0;
  v309 = 0;
  memset(buf, 0, 24);
  ctu::cf::assign();
  *(_OWORD *)CFArrayRef theArray = *(_OWORD *)buf;
  v309 = *(const void **)&buf[16];
  CFArrayRef v211 = *(CFArrayRef *)buf;
  char v212 = buf[23];
  if (buf[23] >= 0) {
    v213 = (CFArrayRef *)((char *)theArray + buf[23]);
  }
  else {
    v213 = (CFArrayRef *)(*(void *)buf + *(void *)&buf[8]);
  }
  if (buf[23] >= 0) {
    v214 = theArray;
  }
  else {
    v214 = *(CFArrayRef **)buf;
  }
  if (v214 != v213)
  {
    do
    {
      *(unsigned char *)v214 = __tolower(*(char *)v214);
      v214 = (CFArrayRef *)((char *)v214 + 1);
    }
    while (v214 != v213);
    char v212 = HIBYTE(v309);
    CFArrayRef v211 = theArray[0];
  }
  if (v212 >= 0) {
    v215 = theArray;
  }
  else {
    v215 = (CFArrayRef *)v211;
  }
  if (getBroadcastLanguageFromLocale((const char *)v215) != v204)
  {
    if (SHIBYTE(v309) < 0) {
      operator delete(theArray[0]);
    }
    goto LABEL_342;
  }
  sub_1000558F4((const void **)&v307.__r_.__value_.__l.__data_);
LABEL_344:
  sub_100044D00((const void **)&v312);
  int v216 = _os_feature_enabled_impl();
  if (SHIBYTE(v309) < 0)
  {
    if (theArray[1]) {
      char v218 = v216;
    }
    else {
      char v218 = 0;
    }
    if (v218)
    {
      *(void *)&long long v301 = 0;
      sub_10004FC84(__dst, theArray[0], (unint64_t)theArray[1]);
LABEL_355:
      if (SHIBYTE(v281) < 0)
      {
        sub_10004FC84(&v312, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        long long v312 = *(_OWORD *)__dst;
        v313 = v281;
      }
      v305.__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v313) < 0)
      {
        sub_10004FC84(buf, (void *)v312, *((unint64_t *)&v312 + 1));
      }
      else
      {
        *(_OWORD *)long long buf = v312;
        *(void *)&uint8_t buf[16] = v313;
      }
      v306.__r_.__value_.__r.__words[0] = 0;
      if (ctu::cf::convert_copy())
      {
        std::string::size_type v219 = v305.__r_.__value_.__r.__words[0];
        v305.__r_.__value_.__r.__words[0] = v306.__r_.__value_.__r.__words[0];
        v307.__r_.__value_.__r.__words[0] = v219;
        sub_1000558F4((const void **)&v307.__r_.__value_.__l.__data_);
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      *(void *)&long long v301 = v305.__r_.__value_.__r.__words[0];
      v305.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v305.__r_.__value_.__l.__data_);
      if (SHIBYTE(v313) < 0) {
        operator delete((void *)v312);
      }
      if (SHIBYTE(v281) < 0) {
        operator delete(__dst[0]);
      }
      CFDictionarySetValue(theDict, @"kCTSMSAutoReadOutAlertLanguage", (const void *)v301);
      sub_1000558F4((const void **)&v301);
    }
  }
  else
  {
    if (HIBYTE(v309)) {
      int v217 = v216;
    }
    else {
      int v217 = 0;
    }
    if (v217 == 1)
    {
      *(void *)&long long v301 = 0;
      *(_OWORD *)std::string __dst = *(_OWORD *)theArray;
      v281 = v309;
      goto LABEL_355;
    }
  }
  CFMutableDictionaryRef v279 = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  CellBroadcastConfig::sendCmasNotification_sync(a1, &v279);
  sub_10005717C((const void **)&v279);
  v220 = (std::__shared_weak_count *)a2[1];
  v277 = *a2;
  v278 = v220;
  if (v220) {
    atomic_fetch_add_explicit(&v220->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v319, 0, sizeof(v319));
  uint64_t v320 = 0;
  long long v317 = 0u;
  long long v318 = 0u;
  long long v315 = 0u;
  long long v316 = 0u;
  memset(buf, 0, sizeof(buf));
  *(_DWORD *)&uint8_t buf[24] = 11;
  LODWORD(v316) = 25;
  DWORD2(v316) = 3;
  *(_OWORD *)((char *)&v319[1] + 5) = 0u;
  uint64_t v221 = *(void *)(a1 + 216);
  uint64_t v222 = *(void *)(a1 + 224);
  *(void *)&long long v312 = &v277;
  *((void *)&v312 + 1) = buf;
  if (v221 != v222)
  {
    while ((sub_101057EF4(&v312, v221) & 1) == 0)
    {
      v221 += 144;
      if (v221 == v222)
      {
        uint64_t v221 = v222;
        goto LABEL_390;
      }
    }
  }
  if (v221 != v222)
  {
    for (uint64_t j = v221 + 144; j != v222; j += 144)
    {
      if ((sub_101057EF4(&v312, j) & 1) == 0)
      {
        if (*(char *)(v221 + 23) < 0) {
          operator delete(*(void **)v221);
        }
        long long v224 = *(_OWORD *)j;
        *(void *)(v221 + 16) = *(void *)(j + 16);
        *(_OWORD *)uint64_t v221 = v224;
        *(unsigned char *)(j + 23) = 0;
        *(unsigned char *)uint64_t j = 0;
        long long v225 = *(_OWORD *)(j + 56);
        long long v226 = *(_OWORD *)(j + 40);
        *(_OWORD *)(v221 + 24) = *(_OWORD *)(j + 24);
        *(_OWORD *)(v221 + 40) = v226;
        *(_OWORD *)(v221 + 56) = v225;
        v227 = (void **)(v221 + 72);
        if (*(char *)(v221 + 95) < 0) {
          operator delete(*v227);
        }
        long long v228 = *(_OWORD *)(j + 72);
        *(void *)(v221 + 88) = *(void *)(j + 88);
        *(_OWORD *)v227 = v228;
        *(unsigned char *)(j + 95) = 0;
        *(unsigned char *)(j + 72) = 0;
        v229 = (void **)(v221 + 96);
        if (*(char *)(v221 + 119) < 0) {
          operator delete(*v229);
        }
        long long v230 = *(_OWORD *)(j + 96);
        *(void *)(v221 + 112) = *(void *)(j + 112);
        *(_OWORD *)v229 = v230;
        *(unsigned char *)(j + 119) = 0;
        *(unsigned char *)(j + 96) = 0;
        long long v231 = *(_OWORD *)(j + 120);
        *(void *)(v221 + 136) = *(void *)(j + 136);
        *(_OWORD *)(v221 + 120) = v231;
        v221 += 144;
      }
    }
  }
LABEL_390:
  sub_101056A98(a1 + 216, v221, *(void *)(a1 + 224));
  *(_OWORD *)&v307.__r_.__value_.__l.__data_ = 0uLL;
  (*(void (**)(std::string *__return_ptr))(*(void *)v277 + 416))(&v307);
  if (v307.__r_.__value_.__r.__words[0])
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v277 + 192))(&v312);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    *(_OWORD *)long long buf = v312;
    *(void *)&uint8_t buf[16] = v313;
    int v232 = *((_DWORD *)v277 + 12);
    *(_DWORD *)&uint8_t buf[24] = *(_DWORD *)(v307.__r_.__value_.__r.__words[0] + 12);
    *(_DWORD *)&unsigned char buf[28] = v232;
    if (v232 == 1) {
      int v233 = (*(uint64_t (**)(void))(*(void *)v277 + 368))();
    }
    else {
      int v233 = sms::Model::getMessageID(v277);
    }
    LODWORD(v315) = v233;
    v235 = *(Registry **)(a1 + 240);
    v236 = *(std::__shared_weak_count **)(a1 + 248);
    if (v236) {
      atomic_fetch_add_explicit(&v236->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *((void *)&v315 + 1) = sub_101056BF0(v235);
    if (v236) {
      sub_10004D2C8(v236);
    }
    LODWORD(v316) = (*(uint64_t (**)(sms::Model *))(*(void *)v277 + 440))(v277);
    std::string::size_type v237 = v307.__r_.__value_.__r.__words[0];
    uint64_t v238 = *(void *)(v307.__r_.__value_.__r.__words[0] + 16);
    v239 = *(std::__shared_weak_count **)(v307.__r_.__value_.__r.__words[0] + 24);
    if (v239) {
      atomic_fetch_add_explicit(&v239->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v238)
    {
      DWORD2(v316) = *(_DWORD *)(v237 + 8);
      *(void *)&long long v317 = sub_1012F6F24(v238);
    }
    if (v239) {
      sub_10004D2C8(v239);
    }
    *(void *)&long long v312 = 0;
    CellBroadcastConfig::getAppleSafetyAlertConfig_sync((CellBroadcastConfig *)a1, &v312);
    if ((void)v312) {
      v240 = sub_100080778;
    }
    else {
      v240 = 0;
    }
    if (v240)
    {
      sub_100057D78((const void **)&v312);
      if (v320)
      {
        sub_101055F08(a1, (uint64_t)buf);
      }
      else
      {
        sub_101055AA8(a1, (long long *)buf);
        v241 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v241, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v242 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a1 + 224) - *(void *)(a1 + 216)) >> 4);
          LODWORD(v312) = 134217984;
          *(void *)((char *)&v312 + 4) = v242;
          _os_log_impl((void *)&_mh_execute_header, v241, OS_LOG_TYPE_DEFAULT, "#I WEA metric submission scheduled. [ %zu ] metrics total", (uint8_t *)&v312, 0xCu);
        }
      }
    }
    else
    {
      sub_101055F08(a1, (uint64_t)buf);
      sub_100057D78((const void **)&v312);
    }
  }
  else
  {
    v234 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v234, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v312) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v234, OS_LOG_TYPE_ERROR, "Invalid CB PDU decoder while submitting metric", (uint8_t *)&v312, 2u);
    }
  }
  if (v307.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v307.__r_.__value_.__l.__size_);
  }
  if (SHIBYTE(v319[2]) < 0) {
    operator delete(v319[0]);
  }
  if (SHIBYTE(v318) < 0) {
    operator delete(*((void **)&v317 + 1));
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v278) {
    sub_10004D2C8(v278);
  }
  if (SHIBYTE(v309) < 0) {
    operator delete(theArray[0]);
  }
  sub_100062778((const void **)&__p);
  sub_1000558F4((const void **)&v286);
  sub_1000558F4((const void **)&v285);
  sub_1000558F4((const void **)&v284);
LABEL_430:
  sub_1000558F4(&cf);
LABEL_431:
  sub_100057D78((const void **)&value);
  sub_100044D00((const void **)&v292);
  sub_1000570E8(&v293);
LABEL_432:
  sub_10005717C((const void **)&theDict);
LABEL_433:
  if (v296 < 0) {
    operator delete(v295[0]);
  }
}

void sub_101053404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,const void *a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29,uint64_t a30,const void *a31,uint64_t a32,uint64_t a33,const void *a34,const void *a35,const void *a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,const void *a43,uint64_t a44,uint64_t a45,const void *a46,const void *a47,const void *a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1000577C4(&a43);
  long long v76 = (void *)STACK[0x210];
  if (STACK[0x210])
  {
    STACK[0x218] = (unint64_t)v76;
    operator delete(v76);
  }
  sub_100057D78(&a46);
  sub_1000558F4(&a47);
  sub_1000558F4(&a48);
  sub_1000558F4((const void **)&a52);
  sub_1000558F4((const void **)&a56);
  if (a69 < 0) {
    operator delete(a64);
  }
  if (a72 < 0) {
    operator delete(a71);
  }
  sub_100044D00(&a73);
  sub_100057D78(&a74);
  sub_1002E26CC((const void **)&a75);
  sub_1000558F4(&a25);
  sub_1000558F4(&a29);
  sub_100057D78(&a31);
  sub_100044D00(&a34);
  sub_1000570E8(&a35);
  sub_10005717C(&a36);
  if (a42 < 0) {
    operator delete(a37);
  }
  _Unwind_Resume(a1);
}

const void **sub_101053A04(CFDictionaryRef *a1, uint64_t a2, uint64_t a3, CFDictionaryRef *a4, uint64_t a5, unsigned int a6)
{
  CFMutableDictionaryRef theDict = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *a4);
  if (theDict) {
    int v12 = sub_1000C06D0;
  }
  else {
    int v12 = 0;
  }
  if (!v12)
  {
    int v19 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Unable to create dict", (uint8_t *)__p, 2u);
    }
    goto LABEL_11;
  }
  int v13 = *(Registry ***)(a2 + 368);
  CFTypeID v14 = operator new(0x10uLL);
  __p[1] = v14 + 2;
  __p[2] = v14 + 2;
  void *v14 = @"CellBroadcast";
  v14[1] = @"SoundIsMutableInRelayMode";
  __p[0] = v14;
  sub_1007EC3B4(v13, a3, 2, (uint64_t)__p, (uint64_t)kCFBooleanFalse, 0, cf);
  BOOL v15 = *(BOOL **)cf;
  LOBYTE(v73) = 0;
  if (*(void *)cf)
  {
    CFTypeID v16 = CFGetTypeID(*(CFTypeRef *)cf);
    if (v16 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)&v73, v15, v17);
    }
    int v18 = v73;
  }
  else
  {
    int v18 = 0;
  }
  sub_1000577C4((const void **)cf);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v18) {
    CFDictionarySetValue(theDict, @"SoundIsMutableInRelayMode", kCFBooleanTrue);
  }
  if (!CFDictionaryContainsKey(*a4, @"CustomPreferences")) {
    goto LABEL_21;
  }
  CFDictionaryRemoveValue(theDict, @"CustomPreferences");
  if (*(_DWORD *)(a2 + 504))
  {
    unsigned __int16 v20 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v21 = (void *)asString();
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I AlwaysDeliverPref not added, Ringer state: %s", (uint8_t *)__p, 0xCu);
    }
    goto LABEL_21;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*a4, @"CustomPreferences");
  CFArrayRef v24 = Value;
  if (!Value) {
    goto LABEL_70;
  }
  CFTypeID v25 = CFGetTypeID(Value);
  CFTypeID TypeID = CFArrayGetTypeID();
  if (v25 != TypeID) {
    CFArrayRef v24 = 0;
  }
  if (!a5 || v25 != TypeID)
  {
LABEL_70:
    int v56 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Unable to filter custom preference", (uint8_t *)__p, 2u);
    }
LABEL_11:
    *a1 = *a4;
    *a4 = 0;
    return sub_10005717C((const void **)&theDict);
  }
  if (CFArrayGetCount(v24) < 1)
  {
LABEL_68:
    BOOL v55 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Custom preference not applicable for this alert", (uint8_t *)__p, 2u);
    }
    goto LABEL_70;
  }
  CFIndex v27 = 0;
  while (1)
  {
    __p[0] = 0;
    *(void *)CFTypeRef cf = CFArrayGetValueAtIndex(v24, v27);
    sub_10004EFE4(__p, (CFTypeRef *)cf);
    if (__p[0]) {
      int v28 = sub_100080778;
    }
    else {
      int v28 = 0;
    }
    if (!v28)
    {
      BOOL v32 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFTypeRef cf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Invalid format for custom preference", cf, 2u);
      }
      goto LABEL_39;
    }
    CFBooleanRef v29 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)__p[0], @"ShowAlwaysDeliverSwitch");
    CFBooleanRef v30 = v29;
    if (v29)
    {
      CFTypeID v31 = CFGetTypeID(v29);
      if (v31 == CFBooleanGetTypeID()) {
        break;
      }
    }
LABEL_39:
    sub_100057D78((const void **)__p);
    if (++v27 >= CFArrayGetCount(v24)) {
      goto LABEL_68;
    }
  }
  if (!CFBooleanGetValue(v30))
  {
    int v54 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeRef cf = 0;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Show always deliver is set to false. Not adding custom preference", cf, 2u);
    }
    goto LABEL_66;
  }
  CFDictionaryRef v34 = (BOOL *)CFDictionaryGetValue((CFDictionaryRef)__p[0], @"EnableAlwaysDeliverByDefault");
  int v35 = v34;
  if (v34)
  {
    CFTypeID v36 = CFGetTypeID(v34);
    if (v36 != CFBooleanGetTypeID()) {
      int v35 = 0;
    }
  }
  CFArrayRef v37 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)__p[0], @"MessageIDParameters3GPP");
  CFArrayRef v38 = v37;
  if (!v37 || (CFTypeID v39 = CFGetTypeID(v37), v39 != CFArrayGetTypeID()) || !v35)
  {
    os_log_t v53 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Invalid format for custom preference, missing 3GPPRange/ enable by default", cf, 2u);
    }
LABEL_66:
    sub_100057D78((const void **)__p);
    goto LABEL_70;
  }
  CFIndex v40 = 0;
  long long v70 = v35;
  while (1)
  {
    if (v40 >= CFArrayGetCount(v38))
    {
      sub_100057D78((const void **)__p);
      goto LABEL_68;
    }
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, v40);
    CFDictionaryRef v42 = ValueAtIndex;
    if (ValueAtIndex)
    {
      CFTypeID v43 = CFGetTypeID(ValueAtIndex);
      if (v43 != CFDictionaryGetTypeID()) {
        CFDictionaryRef v42 = 0;
      }
    }
    int v44 = (unsigned __int16 *)CFDictionaryGetValue(v42, @"FromServiceID");
    BOOL v45 = v44;
    if (v44)
    {
      CFTypeID v46 = CFGetTypeID(v44);
      if (v46 != CFNumberGetTypeID()) {
        BOOL v45 = 0;
      }
    }
    unsigned int v47 = (unsigned __int16 *)CFDictionaryGetValue(v42, @"ToServiceID");
    uint64_t v49 = v47;
    if (v47)
    {
      CFTypeID v50 = CFGetTypeID(v47);
      if (v50 != CFNumberGetTypeID()) {
        uint64_t v49 = 0;
      }
    }
    *(_WORD *)CFTypeRef cf = 0;
    ctu::cf::assign((ctu::cf *)cf, v45, v48);
    if (*(unsigned __int16 *)cf <= a6)
    {
      *(_WORD *)CFTypeRef cf = 0;
      ctu::cf::assign((ctu::cf *)cf, v49, v51);
      if (*(unsigned __int16 *)cf >= a6) {
        break;
      }
    }
    ++v40;
  }
  cf[0] = 0;
  ctu::cf::assign((ctu::cf *)cf, v70, v52);
  int v57 = cf[0];
  sub_100057D78((const void **)__p);
  *(_OWORD *)long long __p = 0uLL;
  Registry::getMobileHelper((uint64_t *)__p, *(Registry **)(a2 + 240));
  CFBooleanRef v58 = __p[0];
  if (__p[0])
  {
    int v73 = 0;
    CFStringRef v72 = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", a5, @"AlwaysDeliverPref");
    (*(void (**)(unsigned char *__return_ptr, void *, void, CFStringRef))(*(void *)v58 + 16))(cf, v58, kCommCenterSharedSettingsBundleId, v72);
    sub_1000057AC(&v73, (CFTypeRef *)cf);
    sub_1000577C4((const void **)cf);
    sub_1000558F4((const void **)&v72);
    if (v73) {
      char v60 = sub_100084B4C;
    }
    else {
      char v60 = 0;
    }
    if (v60)
    {
      cf[0] = 0;
      ctu::cf::assign((ctu::cf *)cf, v73, v59);
      int v57 = cf[0];
      uint64_t v61 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeID v62 = "true";
        if (!v57) {
          CFTypeID v62 = "false";
        }
        *(_DWORD *)CFTypeRef cf = 136446210;
        *(void *)&cf[4] = v62;
        CSIPhoneNumber v63 = "#I AlwaysDeliverPref (From user-setting): %{public}s";
        uint64_t v64 = v61;
        uint32_t v65 = 12;
LABEL_83:
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, v63, cf, v65);
      }
    }
    else
    {
      __int16 v66 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFTypeRef cf = 0;
        CSIPhoneNumber v63 = "#I No user pref for AlwaysDeliverPref";
        uint64_t v64 = v66;
        uint32_t v65 = 2;
        goto LABEL_83;
      }
    }
    sub_100062778((const void **)&v73);
  }
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  if (v57) {
    CFBooleanRef v67 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v67 = kCFBooleanFalse;
  }
  CFDictionarySetValue(theDict, @"AlwaysDeliverPref", v67);
  CFBooleanRef v68 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
  {
    CFArrayRef v69 = "true";
    if (!v57) {
      CFArrayRef v69 = "false";
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)v69;
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Added AlwaysDeliverPref: %s", (uint8_t *)__p, 0xCu);
  }
LABEL_21:
  sub_10004EFE4(a1, (CFTypeRef *)&theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_10105422C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, __int16 a17, char a18, char a19, int a20,const void *a21,void *__p,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  sub_10005717C(&a16);
  _Unwind_Resume(a1);
}

void CellBroadcastConfig::sendCmasNotification_sync(uint64_t a1, void *a2)
{
  v51[0] = 0;
  v51[1] = 0;
  uint64_t v52 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 240));
  char v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v12 + 152))(v51, v12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  CFTypeID v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v15 = v51;
    if (v52 < 0) {
      BOOL v15 = (void **)v51[0];
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Bundle path the cell broadcast resources: %{public}s", (uint8_t *)&buf, 0xCu);
  }
  CFTypeID v50 = 0;
  copyBundleIdentifier();
  CFTypeID v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    int v44 = v51;
    if (v52 < 0) {
      int v44 = (void **)v51[0];
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v44;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get bundle identifier for bundle at %{public}s", (uint8_t *)&buf, 0xCu);
  }
  CFNumberRef v48 = 0;
  value = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (SHIBYTE(v52) < 0)
  {
    sub_10004FC84(__dst, v51[0], (unint64_t)v51[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v51;
    uint64_t v47 = v52;
  }
  if (SHIBYTE(v47) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v57 = v47;
  }
  key = 0;
  if (SHIBYTE(v57) < 0)
  {
    sub_10004FC84(&buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long buf = *(_OWORD *)__p;
    uint64_t v59 = v57;
  }
  int v54 = 0;
  if (ctu::cf::convert_copy())
  {
    CFBooleanRef v17 = (ctu *)key;
    key = v54;
    BOOL v55 = v17;
    sub_1000558F4((const void **)&v55);
  }
  if (SHIBYTE(v59) < 0) {
    operator delete((void *)buf);
  }
  CFNumberRef v48 = key;
  key = 0;
  sub_1000558F4((const void **)&key);
  if (SHIBYTE(v57) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  CFArrayAppendValue((CFMutableArrayRef)value, v48);
  int v54 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v19 = v54;
  int v54 = Mutable;
  *(void *)&long long buf = v19;
  sub_10005717C((const void **)&buf);
  unsigned __int16 v20 = v54;
  BOOL v55 = 0;
  __p[0] = 0;
  if (ctu::cf::convert_copy((ctu::cf *)__p, (const __CFString **)"kLoadBundle", (const char *)0x8000100, kCFAllocatorDefault, v21))
  {
    int v22 = v55;
    BOOL v55 = (ctu *)__p[0];
    *(void *)&long long buf = v22;
    sub_1000558F4((const void **)&buf);
  }
  key = v55;
  BOOL v55 = 0;
  sub_1000558F4((const void **)&v55);
  CFDictionarySetValue(v20, key, value);
  sub_1000558F4((const void **)&key);
  BOOL v55 = 0;
  int v23 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 240));
  CFArrayRef v24 = v23;
  if (v25 < 0)
  {
    CFNumberRef v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(v23);
  *(void *)&long long buf = v25;
  CFBooleanRef v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)&buf);
  if (v29)
  {
    uint64_t v31 = v29[3];
    CFBooleanRef v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v32 = 0;
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  std::mutex::unlock(v24);
  CFBooleanRef v30 = 0;
  char v32 = 1;
LABEL_43:
  (*(void (**)(ctu **__return_ptr, uint64_t, void, void, uint64_t))(*(void *)v31 + 56))(&v55, v31, kCellBroadcastLocalizationTable, *a2, 1);
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  key = 0;
  ctu::cf_to_xpc((uint64_t *)&buf, v55, v33);
  CFDictionaryRef v34 = (void *)buf;
  key = (void *)buf;
  if ((void)buf && xpc_get_type((xpc_object_t)buf) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v34);
  }
  else {
    key = xpc_null_create();
  }
  xpc_release((xpc_object_t)buf);
  ctu::cf_to_xpc((uint64_t *)&buf, v54, v35);
  CFTypeID v36 = (void *)buf;
  xpc_object_t object = (xpc_object_t)buf;
  if ((void)buf && xpc_get_type((xpc_object_t)buf) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v36);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc_release((xpc_object_t)buf);
  CFArrayRef v37 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)&buf, (xpc::object *)&key);
    if (v59 >= 0) {
      p_long long buf = &buf;
    }
    else {
      p_long long buf = (long long *)buf;
    }
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = p_buf;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Cell Broadcast message notification: %s", (uint8_t *)__p, 0xCu);
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)buf);
    }
    CFArrayRef v37 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)&buf, (xpc::object *)&object);
    CFTypeID v39 = v59 >= 0 ? &buf : (long long *)buf;
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = v39;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Cell Broadcast message additional: %s", (uint8_t *)__p, 0xCu);
    if (SHIBYTE(v59) < 0) {
      operator delete((void *)buf);
    }
  }
  CFIndex v40 = key;
  *(void *)&long long buf = key;
  if (key)
  {
    xpc_retain(key);
  }
  else
  {
    CFIndex v40 = xpc_null_create();
    *(void *)&long long buf = v40;
  }
  xpc_object_t v41 = object;
  __p[0] = object;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v41 = xpc_null_create();
    __p[0] = v41;
  }
  sub_1000452AC(28, (xpc_object_t *)&buf, __p);
  xpc_release(v41);
  xpc_release(v40);
  CFDictionaryRef v42 = key;
  *(void *)&long long buf = key;
  if (key)
  {
    xpc_retain(key);
  }
  else
  {
    CFDictionaryRef v42 = xpc_null_create();
    *(void *)&long long buf = v42;
  }
  xpc_object_t v43 = object;
  __p[0] = object;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v43 = xpc_null_create();
    __p[0] = v43;
  }
  sub_1000452AC(27, (xpc_object_t *)&buf, __p);
  xpc_release(v43);
  xpc_release(v42);
  xpc_release(object);
  xpc_release(key);
  sub_100057D78((const void **)&v55);
  sub_10005717C((const void **)&v54);
  sub_1000558F4((const void **)&v48);
  sub_1000440D4((const void **)&value);
  sub_1000558F4(&v50);
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
}

void sub_101054B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, const void *a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,xpc_object_t a27,char a28,int a29,__int16 a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1000440D4(&a19);
  sub_1000558F4(&a20);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101054CC0(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  uint64_t v8 = a3;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10105DAE4;
  v9[3] = &unk_101A82B58;
  void v9[4] = a1 + 8;
  void v9[5] = &v6;
  uint64_t v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    char v13 = sub_10105DB34;
    CFTypeID v14 = &unk_101A82B98;
    BOOL v15 = &v17;
    CFTypeID v16 = &v10;
    uint64_t v17 = 0;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    char v13 = sub_10105DAF8;
    CFTypeID v14 = &unk_101A82B78;
    BOOL v15 = &v17;
    CFTypeID v16 = &v10;
    uint64_t v17 = 0;
    dispatch_sync(v3, &block);
  }
  return v17;
}

__CFArray *CellBroadcastConfig::copyCurrentActiveCMASConfiguration_sync(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  int v7 = v6;
  if (a3)
  {
    CFArrayRef theArray = (CFArrayRef)sub_10104E168(a1, a2, a3);
    if (theArray) {
      uint64_t v8 = sub_100083F10;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8)
    {
      CFDictionaryRef theDict = (CFDictionaryRef)sub_10104C060(a1, a2);
      CFIndex Count = CFArrayGetCount(theArray);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Count >= 1)
      {
        for (CFIndex i = 0; Count != i; ++i)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
          CFDictionaryRef v12 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v13 = CFGetTypeID(ValueAtIndex);
            if (v13 == CFDictionaryGetTypeID()) {
              CFDictionaryRef v14 = v12;
            }
            else {
              CFDictionaryRef v14 = 0;
            }
          }
          else
          {
            CFDictionaryRef v14 = 0;
          }
          CFArrayRef Value = CFDictionaryGetValue(v14, @"AlertType");
          CFTypeID v16 = Value;
          if (Value && (CFTypeID v17 = CFGetTypeID(Value), v17 == CFStringGetTypeID()))
          {
            char v42 = 0;
            if (theDict) {
              int v18 = sub_100080778;
            }
            else {
              int v18 = 0;
            }
            if (v18)
            {
              CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(theDict, v16);
              CFDictionaryRef v20 = v19;
              if (!v19 || (CFTypeID v21 = CFGetTypeID(v19), v21 != CFDictionaryGetTypeID()))
              {
                os_log_t v30 = *v7;
                if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138543362;
                  CFTypeID v46 = v16;
                  uint64_t v31 = v30;
                  char v32 = "Invalid content for: [%{public}@]";
                  goto LABEL_39;
                }
                continue;
              }
              if (CFDictionaryContainsKey(v20, @"UseMMI"))
              {
                int v22 = (BOOL *)CFDictionaryGetValue(v20, @"UseMMI");
                int v23 = v22;
                buf[0] = 0;
                if (v22)
                {
                  CFTypeID v24 = CFGetTypeID(v22);
                  if (v24 == CFBooleanGetTypeID()) {
                    ctu::cf::assign((ctu::cf *)buf, v23, v25);
                  }
                  if (buf[0])
                  {
                    BOOL v26 = sub_10104C170(a1);
                    uint64_t v27 = *v7;
                    BOOL v28 = os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT);
                    if (!v26)
                    {
                      if (!v28) {
                        continue;
                      }
                      *(_DWORD *)long long buf = 138543362;
                      CFTypeID v46 = v16;
                      CFTypeID v36 = v27;
                      CFArrayRef v37 = "#I Removing MMI alert type: [%{public}@]";
                      goto LABEL_44;
                    }
                    if (v28)
                    {
                      *(_DWORD *)long long buf = 138543362;
                      CFTypeID v46 = v16;
                      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I MMI Alert allowed: [%{public}@]", buf, 0xCu);
                    }
                  }
                }
              }
            }
            if (CellBroadcastConfig::getCellBroadcastSettingForAlertType_sync(a1, a2, v16, &v42))
            {
              if (v42)
              {
                CFArrayAppendValue(Mutable, v14);
              }
              else
              {
                os_log_t v35 = *v7;
                if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138543362;
                  CFTypeID v46 = v16;
                  CFTypeID v36 = v35;
                  CFArrayRef v37 = "#I Alert disabled by user: [%{public}@]";
LABEL_44:
                  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v37, buf, 0xCu);
                }
              }
            }
            else
            {
              os_log_t v33 = *v7;
              if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138543362;
                CFTypeID v46 = v16;
                uint64_t v31 = v33;
                char v32 = "Failed to get current setting for alert type %{public}@";
LABEL_39:
                uint32_t v34 = 12;
LABEL_41:
                _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, v32, buf, v34);
              }
            }
          }
          else
          {
            os_log_t v29 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              uint64_t v31 = v29;
              char v32 = "Alert type was not found in the dictionary";
              uint32_t v34 = 2;
              goto LABEL_41;
            }
          }
        }
      }
      sub_100057D78((const void **)&theDict);
      CFArrayRef v38 = Mutable;
    }
    else
    {
      CFArrayRef v38 = 0;
    }
    sub_100044D00((const void **)&theArray);
  }
  else
  {
    CFTypeID v39 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Invalid protocol section identifier", buf, 2u);
    }
    return 0;
  }
  return v38;
}

void sub_10105526C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_100044D00((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL sub_1010552A4(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_10105DB70;
  v5[3] = &unk_101A82BB8;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10005B554;
    uint64_t v10 = &unk_101A828D8;
    int v11 = &v13;
    CFDictionaryRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    unsigned int v9 = sub_10005A7F0;
    uint64_t v10 = &unk_101A828B8;
    int v11 = &v13;
    CFDictionaryRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_1010553D4(const void **a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5)
{
  *a1 = 0;
  uint64_t v10 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  int v11 = v10;
  if (a4)
  {
    CFDictionaryRef v12 = CellBroadcastConfig::copyCurrentActiveCMASConfiguration_sync(a2, a3, a4);
    CFArrayRef theArray = v12;
    if (v12) {
      char v13 = sub_100083F10;
    }
    else {
      char v13 = 0;
    }
    if (v13)
    {
      CFIndex Count = CFArrayGetCount(v12);
      if (Count >= 1)
      {
        CFIndex v15 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v15);
          CFTypeID v17 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v18 = CFGetTypeID(ValueAtIndex);
            if (v18 != CFDictionaryGetTypeID()) {
              CFTypeID v17 = 0;
            }
          }
          char v21 = 0;
          (*(void (**)(uint64_t, const void *, char *))(a5 + 16))(a5, v17, &v21);
          if (v21) {
            break;
          }
          if (Count == ++v15) {
            goto LABEL_19;
          }
        }
        *(void *)long long buf = v17;
        sub_100282490(a1, (CFTypeRef *)buf);
      }
    }
    else
    {
      CFDictionaryRef v20 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = a4;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I There is no active configuration for %{public}@", buf, 0xCu);
      }
    }
LABEL_19:
    sub_100044D00((const void **)&theArray);
  }
  else
  {
    CFDictionaryRef v19 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid protocol section identifier", buf, 2u);
    }
  }
}

void sub_1010555D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  sub_100057D78(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_101055604(uint64_t a1, CFDictionaryRef theDict, unsigned char *a3)
{
  CFArrayRef Value = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"FromServiceID");
  int v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFNumberGetTypeID()) {
      int v7 = 0;
    }
  }
  unsigned int v9 = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"ToServiceID");
  int v11 = v9;
  if (v9)
  {
    CFTypeID v12 = CFGetTypeID(v9);
    if (v12 != CFNumberGetTypeID()) {
      int v11 = 0;
    }
  }
  unsigned __int16 v17 = 0;
  ctu::cf::assign((ctu::cf *)&v17, v7, v10);
  unsigned int v13 = v17;
  unsigned __int16 v18 = 0;
  uint64_t result = ctu::cf::assign((ctu::cf *)&v18, v11, v14);
  unsigned int v16 = *(_DWORD *)(a1 + 32);
  if (v16 >= v13 && v16 <= v18) {
    *a3 = 1;
  }
  return result;
}

uint64_t sub_1010556E8(uint64_t a1, CFDictionaryRef theDict, unsigned char *a3)
{
  CFArrayRef Value = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"Category");
  if (Value)
  {
    int v7 = Value;
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFNumberGetTypeID()) {
      unsigned int v9 = v7;
    }
    else {
      unsigned int v9 = 0;
    }
  }
  else
  {
    unsigned int v9 = 0;
  }
  unsigned __int16 v11 = 0;
  uint64_t result = ctu::cf::assign((ctu::cf *)&v11, v9, v6);
  if (*(_DWORD *)(a1 + 32) == v11) {
    *a3 = 1;
  }
  return result;
}

BOOL sub_101055778(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  int v8 = a3;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10105DB7C;
  v9[3] = &unk_101A82BD8;
  void v9[4] = a1 + 8;
  void v9[5] = &v6;
  CFNumberRef v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    unsigned int v13 = sub_10005B554;
    CFNumberRef v14 = &unk_101A828D8;
    CFIndex v15 = &v17;
    unsigned int v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    unsigned int v13 = sub_10005A7F0;
    CFNumberRef v14 = &unk_101A828B8;
    CFIndex v15 = &v17;
    unsigned int v16 = &v10;
    dispatch_sync(v3, &block);
  }
  return v17 != 0;
}

void sub_1010558B0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  uint64_t v8 = a3;
  uint64_t v9 = a4;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_10105DB8C;
  block[3] = &unk_101A82BF8;
  void block[4] = a1 + 8;
  void block[5] = &v6;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8)) {
    dispatch_async_and_wait(v4, block);
  }
  else {
    dispatch_sync(v4, block);
  }
}

uint64_t sub_101055940(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 144))(a1, 1, a2, a3);
}

BOOL sub_101055970(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10105DD80;
  uint64_t v7[3] = &unk_101A82C18;
  void v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unsigned __int16 v11 = sub_10005B554;
    uint64_t v12 = &unk_101A828D8;
    unsigned int v13 = &v15;
    CFNumberRef v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unsigned __int16 v11 = sub_10005A7F0;
    uint64_t v12 = &unk_101A828B8;
    unsigned int v13 = &v15;
    CFNumberRef v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_101055AA8(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3 || (uint64_t v5 = *(void *)(a1 + 8), (v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  uint64_t v8 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  Registry::getTimerService(&v37, *(Registry **)(a1 + 240));
  uint64_t v9 = v37;
  sub_100058DB0(v35, "CMAS metric submission timer");
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  *(_OWORD *)long long __p = *(_OWORD *)v35;
  uint64_t v41 = v36;
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  int v44 = 0;
  uint64_t v10 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v10 = off_101A82C48;
  *((void *)v10 + 1) = a1;
  *((void *)v10 + 2) = v5;
  *((void *)v10 + 3) = v7;
  int v44 = v10;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, char **))(*(void *)v9 + 40))(&v39, v9, __p, 1, 300000000, 0, &v42);
  sub_10003B34C(&v42);
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v11 = v39;
  uint64_t v39 = 0;
  uint64_t v12 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    uint64_t v13 = v39;
    uint64_t v39 = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[0]);
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  unint64_t v14 = *(void *)(a1 + 232);
  unint64_t v15 = *(void *)(a1 + 224);
  if (v15 >= v14)
  {
    uint64_t v17 = *(void *)(a1 + 216);
    unint64_t v18 = 0x8E38E38E38E38E39 * ((uint64_t)(v15 - v17) >> 4);
    if (v18 + 1 > 0x1C71C71C71C71C7) {
      sub_10006A748();
    }
    unint64_t v19 = 0x8E38E38E38E38E39 * ((uint64_t)(v14 - v17) >> 4);
    uint64_t v20 = 2 * v19;
    if (2 * v19 <= v18 + 1) {
      uint64_t v20 = v18 + 1;
    }
    if (v19 >= 0xE38E38E38E38E3) {
      unint64_t v21 = 0x1C71C71C71C71C7;
    }
    else {
      unint64_t v21 = v20;
    }
    uint64_t v45 = a1 + 232;
    if (v21)
    {
      if (v21 > 0x1C71C71C71C71C7) {
        sub_10006A7CC();
      }
      int v22 = (char *)operator new(144 * v21);
    }
    else
    {
      int v22 = 0;
    }
    char v42 = v22;
    v43.i64[0] = (uint64_t)&v22[144 * v18];
    v43.i64[1] = v43.i64[0];
    int v44 = &v22[144 * v21];
    sub_101057BB4((char *)v43.i64[0], a2);
    uint64_t v24 = *(void *)(a1 + 216);
    unint64_t v23 = *(void *)(a1 + 224);
    uint64_t v25 = v43.i64[1];
    uint64_t v26 = v43.i64[0];
    if (v23 == v24)
    {
      int64x2_t v33 = vdupq_n_s64(v23);
    }
    else
    {
      do
      {
        long long v27 = *(_OWORD *)(v23 - 144);
        *(void *)(v26 - 128) = *(void *)(v23 - 128);
        *(_OWORD *)(v26 - 144) = v27;
        *(void *)(v23 - 136) = 0;
        *(void *)(v23 - 128) = 0;
        *(void *)(v23 - 144) = 0;
        long long v28 = *(_OWORD *)(v23 - 120);
        long long v29 = *(_OWORD *)(v23 - 104);
        *(_OWORD *)(v26 - 88) = *(_OWORD *)(v23 - 88);
        *(_OWORD *)(v26 - 104) = v29;
        *(_OWORD *)(v26 - 120) = v28;
        long long v30 = *(_OWORD *)(v23 - 72);
        *(void *)(v26 - 56) = *(void *)(v23 - 56);
        *(_OWORD *)(v26 - 72) = v30;
        *(void *)(v23 - 64) = 0;
        *(void *)(v23 - 56) = 0;
        *(void *)(v23 - 72) = 0;
        long long v31 = *(_OWORD *)(v23 - 48);
        *(void *)(v26 - 32) = *(void *)(v23 - 32);
        *(_OWORD *)(v26 - 48) = v31;
        *(void *)(v23 - 48) = 0;
        *(void *)(v23 - 40) = 0;
        *(void *)(v23 - 32) = 0;
        long long v32 = *(_OWORD *)(v23 - 24);
        *(void *)(v26 - 8) = *(void *)(v23 - 8);
        *(_OWORD *)(v26 - 24) = v32;
        v26 -= 144;
        v23 -= 144;
      }
      while (v23 != v24);
      int64x2_t v33 = *(int64x2_t *)(a1 + 216);
    }
    uint64_t v16 = v25 + 144;
    *(void *)(a1 + 216) = v26;
    *(void *)(a1 + 224) = v25 + 144;
    int64x2_t v43 = v33;
    uint32_t v34 = *(char **)(a1 + 232);
    *(void *)(a1 + 232) = v44;
    int v44 = v34;
    char v42 = (char *)v33.i64[0];
    sub_101057CC4((uint64_t)&v42);
  }
  else
  {
    sub_101057BB4(*(char **)(a1 + 224), a2);
    uint64_t v16 = v15 + 144;
    *(void *)(a1 + 224) = v15 + 144;
  }
  *(void *)(a1 + 224) = v16;
  std::__shared_weak_count::__release_weak(v7);
}

void sub_101055E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  sub_101057CC4((uint64_t)&a25);
  std::__shared_weak_count::__release_weak(v25);
  _Unwind_Resume(a1);
}

void sub_101055F08(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 240));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    unint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get analytics interface...", buf, 2u);
    }
    goto LABEL_67;
  }
LABEL_11:
  xpc_object_t v59 = 0;
  xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v16 = v15;
  if (v15)
  {
    xpc_object_t v59 = v15;
  }
  else
  {
    xpc_object_t v16 = xpc_null_create();
    xpc_object_t v59 = v16;
    if (!v16)
    {
      xpc_object_t v17 = xpc_null_create();
      xpc_object_t v16 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v16);
    goto LABEL_19;
  }
  xpc_object_t v17 = xpc_null_create();
LABEL_18:
  xpc_object_t v59 = v17;
LABEL_19:
  xpc_release(v16);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v18 = *(void *)(a2 + 8);
  }
  if (*(unsigned char *)(a2 + 124))
  {
    xpc_object_t v53 = xpc_int64_create(*(unsigned __int8 *)(a2 + 124));
    if (!v53) {
      xpc_object_t v53 = xpc_null_create();
    }
    *(void *)long long buf = &v59;
    int v56 = "InternetPath";
    sub_100035E70((uint64_t)buf, &v53, &v54);
    xpc_release(v54);
    xpc_object_t v54 = 0;
    xpc_release(v53);
    xpc_object_t v53 = 0;
    if (!v18) {
      goto LABEL_45;
    }
  }
  else
  {
    xpc_object_t v57 = xpc_int64_create(*(unsigned __int8 *)(a1 + 508));
    if (!v57) {
      xpc_object_t v57 = xpc_null_create();
    }
    *(void *)long long buf = &v59;
    int v56 = "InternetPath";
    sub_100035E70((uint64_t)buf, &v57, &v58);
    xpc_release(v58);
    xpc_object_t v58 = 0;
    xpc_release(v57);
    xpc_object_t v57 = 0;
    if (!v18) {
      goto LABEL_45;
    }
  }
  int64_t v19 = sub_100206390((uint64_t)&v50, a2);
  xpc_object_t v51 = xpc_int64_create(v19);
  if (!v51) {
    xpc_object_t v51 = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "Body";
  sub_100035E70((uint64_t)buf, &v51, &v52);
  xpc_release(v52);
  xpc_object_t v52 = 0;
  xpc_release(v51);
  xpc_object_t v51 = 0;
  xpc_object_t object = xpc_int64_create(*(int *)(a2 + 24));
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "RAT";
  sub_100035E70((uint64_t)buf, &object, &v49);
  xpc_release(v49);
  xpc_object_t v49 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_object_t v46 = xpc_int64_create(*(int *)(a2 + 28));
  if (!v46) {
    xpc_object_t v46 = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "MessageType";
  sub_100035E70((uint64_t)buf, &v46, &v47);
  xpc_release(v47);
  xpc_object_t v47 = 0;
  xpc_release(v46);
  xpc_object_t v46 = 0;
  xpc_object_t v44 = xpc_int64_create(*(unsigned int *)(a2 + 32));
  if (!v44) {
    xpc_object_t v44 = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "Channel";
  sub_100035E70((uint64_t)buf, &v44, &v45);
  xpc_release(v45);
  xpc_object_t v45 = 0;
  xpc_release(v44);
  xpc_object_t v44 = 0;
  xpc_object_t v42 = xpc_int64_create(*(int *)(a2 + 48));
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "Language";
  sub_100035E70((uint64_t)buf, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  xpc_object_t v40 = xpc_int64_create(*(int *)(a2 + 56));
  if (!v40) {
    xpc_object_t v40 = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "TriggerType";
  sub_100035E70((uint64_t)buf, &v40, &v41);
  xpc_release(v41);
  xpc_object_t v41 = 0;
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_object_t v38 = xpc_int64_create(*(void *)(a2 + 64));
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  *(void *)long long buf = &v59;
  int v56 = "GeofencingDuration";
  sub_100035E70((uint64_t)buf, &v38, &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
LABEL_45:
  uint64_t v20 = *(unsigned __int8 *)(a2 + 95);
  if ((v20 & 0x80u) != 0) {
    uint64_t v20 = *(void *)(a2 + 80);
  }
  if (v20)
  {
    int64_t v21 = sub_100206390((uint64_t)&v50, a2 + 72);
    xpc_object_t v36 = xpc_int64_create(v21);
    if (!v36) {
      xpc_object_t v36 = xpc_null_create();
    }
    *(void *)long long buf = &v59;
    int v56 = "CmamText";
    sub_100035E70((uint64_t)buf, &v36, &v37);
    xpc_release(v37);
    xpc_object_t v37 = 0;
    xpc_release(v36);
    xpc_object_t v36 = 0;
    int64_t v22 = sub_100206390((uint64_t)&v50, a2 + 96);
    xpc_object_t v34 = xpc_int64_create(v22);
    if (!v34) {
      xpc_object_t v34 = xpc_null_create();
    }
    *(void *)long long buf = &v59;
    int v56 = "CmamLongText";
    sub_100035E70((uint64_t)buf, &v34, &v35);
    xpc_release(v35);
    xpc_object_t v35 = 0;
    xpc_release(v34);
    xpc_object_t v34 = 0;
    xpc_object_t v32 = xpc_int64_create(*(unsigned int *)(a2 + 120));
    if (!v32) {
      xpc_object_t v32 = xpc_null_create();
    }
    *(void *)long long buf = &v59;
    int v56 = "WeaHandlingType";
    sub_100035E70((uint64_t)buf, &v32, &v33);
    xpc_release(v33);
    xpc_object_t v33 = 0;
    xpc_release(v32);
    xpc_object_t v32 = 0;
    uint64_t v23 = *(void *)(a2 + 136);
    if (v23)
    {
      uint64_t v24 = *(void *)(a2 + 40);
      if (v24)
      {
        xpc_object_t v30 = xpc_int64_create(v24 - v23);
        if (!v30) {
          xpc_object_t v30 = xpc_null_create();
        }
        *(void *)long long buf = &v59;
        int v56 = "WeaLatencyAfterAppleSafetyAlertReception";
        sub_100035E70((uint64_t)buf, &v30, &v31);
        xpc_release(v31);
        xpc_object_t v31 = 0;
        xpc_release(v30);
        xpc_object_t v30 = 0;
      }
    }
    else
    {
      uint64_t v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Invalid latency timestamp", buf, 2u);
      }
      *(void *)long long buf = &v59;
      int v56 = "WeaLatencyAfterAppleSafetyAlertReception";
      sub_10021ACC8((uint64_t)buf, &v29);
      xpc_release(v29);
      xpc_object_t v29 = 0;
    }
  }
  xpc_object_t v28 = v59;
  if (v59) {
    xpc_retain(v59);
  }
  else {
    xpc_object_t v28 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v12 + 16))(v12, "commCenterEmergencyAlerts", &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if (*(void *)(a1 + 224) == *(void *)(a1 + 216))
  {
    uint64_t v26 = *(void *)(a1 + 208);
    if (v26)
    {
      (*(void (**)(uint64_t))(*(void *)v26 + 16))(v26);
      uint64_t v27 = *(void *)(a1 + 208);
      *(void *)(a1 + 208) = 0;
      if (v27) {
        (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
      }
    }
  }
  xpc_release(v59);
LABEL_67:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_101056664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(*(xpc_object_t *)(v12 - 72));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void CellBroadcastConfig::addAppleSafetyAlertMetric_sync(uint64_t a1, uint64_t a2)
{
  memset(__p, 0, sizeof(__p));
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)uint64_t v20 = 0u;
  long long v21 = 0u;
  DWORD2(v21) = 11;
  LODWORD(v23) = 25;
  DWORD2(v23) = 3;
  *(_OWORD *)uint64_t v24 = 0u;
  long long v25 = 0u;
  uint64_t v5 = *(void *)(a1 + 216);
  uint64_t v6 = *(void *)(a1 + 224);
  uint64_t v4 = a1 + 216;
  *(_OWORD *)&__p[13] = 0u;
  *(void *)&long long buf = a2;
  *((void *)&buf + 1) = v20;
  if (v5 != v6)
  {
    while ((sub_101057D14(&buf, v5) & 1) == 0)
    {
      v5 += 144;
      if (v5 == v6)
      {
        uint64_t v5 = v6;
        goto LABEL_17;
      }
    }
  }
  if (v5 != v6)
  {
    for (uint64_t i = v5 + 144; i != v6; i += 144)
    {
      if ((sub_101057D14(&buf, i) & 1) == 0)
      {
        if (*(char *)(v5 + 23) < 0) {
          operator delete(*(void **)v5);
        }
        long long v8 = *(_OWORD *)i;
        *(void *)(v5 + 16) = *(void *)(i + 16);
        *(_OWORD *)uint64_t v5 = v8;
        *(unsigned char *)(i + 23) = 0;
        *(unsigned char *)uint64_t i = 0;
        long long v9 = *(_OWORD *)(i + 56);
        long long v10 = *(_OWORD *)(i + 40);
        *(_OWORD *)(v5 + 24) = *(_OWORD *)(i + 24);
        *(_OWORD *)(v5 + 40) = v10;
        *(_OWORD *)(v5 + 56) = v9;
        char v11 = (void **)(v5 + 72);
        if (*(char *)(v5 + 95) < 0) {
          operator delete(*v11);
        }
        long long v12 = *(_OWORD *)(i + 72);
        *(void *)(v5 + 88) = *(void *)(i + 88);
        *(_OWORD *)char v11 = v12;
        *(unsigned char *)(i + 95) = 0;
        *(unsigned char *)(i + 72) = 0;
        char v13 = (void **)(v5 + 96);
        if (*(char *)(v5 + 119) < 0) {
          operator delete(*v13);
        }
        long long v14 = *(_OWORD *)(i + 96);
        *(void *)(v5 + 112) = *(void *)(i + 112);
        *(_OWORD *)char v13 = v14;
        *(unsigned char *)(i + 119) = 0;
        *(unsigned char *)(i + 96) = 0;
        long long v15 = *(_OWORD *)(i + 120);
        *(void *)(v5 + 136) = *(void *)(i + 136);
        *(_OWORD *)(v5 + 120) = v15;
        v5 += 144;
      }
    }
  }
LABEL_17:
  sub_101056A98(v4, v5, *(void *)(a1 + 224));
  std::string::operator=((std::string *)&v24[1], (const std::string *)(a2 + 40));
  std::string::operator=((std::string *)__p, (const std::string *)(a2 + 16));
  *(_DWORD *)&__p[24] = *(_DWORD *)(a2 + 236);
  xpc_object_t v16 = *(Registry **)(a1 + 240);
  xpc_object_t v17 = *(std::__shared_weak_count **)(a1 + 248);
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v28 = sub_101056BF0(v16);
  if (v17) {
    sub_10004D2C8(v17);
  }
  __p[28] = *(unsigned char *)(a1 + 508);
  if (*((void *)&v22 + 1))
  {
    sub_101055F08(a1, (uint64_t)v20);
  }
  else
  {
    sub_101055AA8(a1, (long long *)v20);
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v19 = 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a1 + 224) - *(void *)(a1 + 216)) >> 4);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Apple safety alert metric submission scheduled. [ %zu ] metrics total", (uint8_t *)&buf, 0xCu);
    }
  }
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[1]);
  }
  if (SBYTE7(v21) < 0) {
    operator delete(v20[0]);
  }
}

void sub_101056A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_101056C98((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_101056A98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    uint64_t v5 = a3;
    uint64_t v6 = *(void *)(a1 + 8);
    if (a3 != v6)
    {
      uint64_t v7 = 16 * ((a3 - a2) >> 4);
      do
      {
        if (*(char *)(v3 + 23) < 0) {
          operator delete(*(void **)v3);
        }
        long long v8 = (unsigned char *)(v3 + v7);
        long long v9 = *(_OWORD *)(v3 + v7);
        *(void *)(v3 + 16) = *(void *)(v3 + v7 + 16);
        *(_OWORD *)uint64_t v3 = v9;
        v8[23] = 0;
        unsigned char *v8 = 0;
        long long v10 = *(_OWORD *)(v3 + v7 + 56);
        long long v11 = *(_OWORD *)(v3 + v7 + 40);
        *(_OWORD *)(v3 + 24) = *(_OWORD *)(v3 + v7 + 24);
        *(_OWORD *)(v3 + 40) = v11;
        *(_OWORD *)(v3 + 56) = v10;
        long long v12 = (void **)(v3 + 72);
        if (*(char *)(v3 + 95) < 0) {
          operator delete(*v12);
        }
        char v13 = v8 + 72;
        uint64_t v14 = v3 + v7;
        long long v15 = *(_OWORD *)v13;
        *(void *)(v3 + 88) = *((void *)v13 + 2);
        *(_OWORD *)long long v12 = v15;
        *(unsigned char *)(v3 + v7 + 95) = 0;
        unsigned char *v13 = 0;
        xpc_object_t v16 = (void **)(v3 + 96);
        if (*(char *)(v3 + 119) < 0) {
          operator delete(*v16);
        }
        long long v17 = *(_OWORD *)(v14 + 96);
        *(void *)(v3 + 112) = *(void *)(v14 + 112);
        *(_OWORD *)xpc_object_t v16 = v17;
        *(unsigned char *)(v14 + 119) = 0;
        *(unsigned char *)(v14 + 96) = 0;
        uint64_t v18 = *(void *)(v14 + 136);
        *(_OWORD *)(v3 + 120) = *(_OWORD *)(v14 + 120);
        *(void *)(v3 + 136) = v18;
        v3 += 144;
      }
      while (v3 + v7 != v6);
      uint64_t v5 = *(void *)(a1 + 8);
    }
    while (v5 != v3)
    {
      v5 -= 144;
      sub_101057B08(v5);
    }
    *(void *)(a1 + 8) = v3;
  }
}

uint64_t sub_101056BF0(Registry *a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  Registry::getTimerService((uint64_t *)&v3, a1);
  if (v3) {
    uint64_t v1 = (**v3)(v3) / 1000000;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v1;
}

void sub_101056C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101056C98(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

const void **sub_101056CEC(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  long long v22 = 0;
  long long v23 = 0;
  CellBroadcastConfig::getEnhancedDeliverySwitchState_sync(a1, &v23, &v22);
  uint64_t v20 = 0;
  long long v21 = 0;
  Registry::getMobileHelper(&v20, *(Registry **)(a1 + 240));
  uint64_t v6 = v20;
  if (v20)
  {
    if (v23) {
      uint64_t v7 = sub_1000810B8;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      *(void *)long long buf = 0;
      *(void *)long long v17 = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", v23, @"EnhancedDeliveryPref");
      (*(void (**)(CFStringRef *__return_ptr, uint64_t, void, void))(*(void *)v6 + 16))(&v18, v6, kCommCenterSharedSettingsBundleId, *(void *)v17);
      sub_1000057AC(buf, (CFTypeRef *)&v18);
      sub_1000577C4((const void **)&v18);
      sub_1000558F4((const void **)v17);
      LOBYTE(v18) = 0;
      ctu::cf::assign((ctu::cf *)&v18, *(BOOL **)buf, v8);
      *a3 = (_BYTE)v18;
      CFStringRef v18 = CFStringCreateWithFormat(0, 0, @"%@%@", @"CellBroadcastSetting", v23);
      if (v18) {
        long long v9 = sub_1000810B8;
      }
      else {
        long long v9 = 0;
      }
      if (!v9)
      {
        long long v10 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v17 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not get emergency alert preferences key", v17, 2u);
        }
      }
      *(void *)long long v17 = 0;
      (*(void (**)(const void **__return_ptr))(*(void *)v20 + 16))(&v16);
      sub_1000057AC(v17, &v16);
      sub_1000577C4(&v16);
      if (*(void *)v17) {
        long long v12 = sub_100084B4C;
      }
      else {
        long long v12 = 0;
      }
      if (v12)
      {
        LOBYTE(v16) = 0;
        ctu::cf::assign((ctu::cf *)&v16, *(BOOL **)v17, v11);
        *a2 = (_BYTE)v16;
      }
      sub_100062778((const void **)v17);
      sub_1000558F4((const void **)&v18);
      sub_100062778((const void **)buf);
    }
    else
    {
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not get root key for CellBroadcast preferences", buf, 2u);
      }
      *a2 = 0;
      *a3 = 0;
    }
  }
  else
  {
    char v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not get mobileHelper in onCellBroadcastSettingsSynced_sync", buf, 2u);
    }
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_100057D78(&v22);
  return sub_1000558F4(&v23);
}

void sub_101056FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, const void *a14, const void *a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  sub_100062778(&a13);
  sub_1000558F4(&a14);
  sub_100062778(&a15);
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_100057D78((const void **)(v18 - 64));
  sub_1000558F4((const void **)(v18 - 56));
  _Unwind_Resume(a1);
}

void sub_101057074(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I CellBroadcast handling bundle change", buf, 2u);
  }
  int v5 = *a2;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v33 = 0;
  if ((char)a2[31] < 0)
  {
    sub_10004FC84(__p, *((void **)a2 + 1), *((void *)a2 + 2));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a2 + 8);
    uint64_t v33 = *((void *)a2 + 3);
  }
  if (!v5)
  {
    long long v10 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    *(_WORD *)long long buf = 0;
    CFBooleanRef v11 = "Trying to handle operator bundle change, but no change detected";
    goto LABEL_59;
  }
  if (v5 != 255) {
    goto LABEL_11;
  }
  uint64_t v6 = (void *)HIBYTE(v33);
  if (v33 < 0) {
    uint64_t v6 = __p[1];
  }
  if (v6)
  {
LABEL_11:
    CFDictionaryRef theDict = 0;
    CellBroadcastConfig::getEarthquakeAlertsConfiguration_sync((CellBroadcastConfig *)a1, &theDict);
    if (theDict) {
      uint64_t v7 = sub_100080778;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"EnhancedDeliveryAvailability");
      CFBooleanRef v13 = Value;
      if (Value)
      {
        CFTypeID v14 = CFGetTypeID(Value);
        if (v14 != CFBooleanGetTypeID()) {
          CFBooleanRef v13 = 0;
        }
      }
      CFBooleanRef v15 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"AppleSafetyAlertsAvailability");
      CFBooleanRef v16 = v15;
      if (v15)
      {
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 == CFBooleanGetTypeID())
        {
          if (v13)
          {
            if (!*(unsigned char *)(a1 + 72))
            {
              uint64_t v18 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Initializing Enhanced Delivery availability", buf, 2u);
              }
              *(void *)(a1 + 64) = v13;
              *(unsigned char *)(a1 + 72) = 1;
            }
            if (!*(unsigned char *)(a1 + 88))
            {
              unint64_t v19 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Initializing Safety Alerts availability", buf, 2u);
              }
              *(void *)(a1 + 80) = v16;
              *(unsigned char *)(a1 + 88) = 1;
            }
            __int16 v30 = 0;
            sub_101056CEC(a1, (unsigned char *)&v30 + 1, &v30);
            uint64_t v20 = *(NSObject **)(a1 + 40);
            if (!*(unsigned char *)(a1 + 99))
            {
              if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Initializing Emergency Alerts preference", buf, 2u);
                uint64_t v20 = *(NSObject **)(a1 + 40);
              }
              *(_WORD *)(a1 + 98) = HIBYTE(v30) | 0x100;
            }
            if (!*(unsigned char *)(a1 + 97))
            {
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Initializing Enhanced Delivery preference", buf, 2u);
                uint64_t v20 = *(NSObject **)(a1 + 40);
              }
              *(_WORD *)(a1 + 96) = v30 | 0x100;
            }
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I CellBroadcast availability and prefs variables initialized", buf, 2u);
            }
            int v21 = *(unsigned __int8 *)(a1 + 72);
            CFBooleanRef v22 = *(const __CFBoolean **)(a1 + 64);
            if (!*(unsigned char *)(a1 + 72) || v13 != v22 || !*(unsigned char *)(a1 + 88) || v16 != *(const __CFBoolean **)(a1 + 80))
            {
              long long v23 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                if (!v21 || (int v24 = CFBooleanGetValue(v22), v25 = CFBooleanGetValue(v13), !*(unsigned char *)(a1 + 88))) {
                  sub_10016C840();
                }
                int v26 = v25;
                int v27 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 80));
                int v28 = CFBooleanGetValue(v16);
                *(_DWORD *)long long buf = 67109888;
                int v35 = v24;
                __int16 v36 = 1024;
                int v37 = v26;
                __int16 v38 = 1024;
                int v39 = v27;
                __int16 v40 = 1024;
                int v41 = v28;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Dispatching Darwin notification due to bundle change [%d -> %d], [%d -> %d]", buf, 0x1Au);
              }
              *(void *)(a1 + 64) = v13;
              *(unsigned char *)(a1 + 72) = 1;
              *(void *)(a1 + 80) = v16;
              *(unsigned char *)(a1 + 88) = 1;
              DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
              CFNotificationCenterPostNotification(DarwinNotifyCenter, @"kCTSMSCellBroadcastConfigChangedNotification", 0, 0, 0);
            }
            goto LABEL_53;
          }
        }
      }
      CFBooleanRef v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        long long v9 = "Earthquake Alerts configuration dictionary is incomplete";
        goto LABEL_61;
      }
    }
    else
    {
      CFBooleanRef v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        long long v9 = "Failed to get Earthquake Alerts configuration";
LABEL_61:
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
      }
    }
LABEL_53:
    sub_100057D78((const void **)&theDict);
    goto LABEL_54;
  }
  long long v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    CFBooleanRef v11 = "Empty bundle ID";
LABEL_59:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, buf, 2u);
  }
LABEL_54:
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
}

void sub_101057594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1010575D4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dumping State of CellBroadcastConfig", buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  int v3 = *(unsigned __int8 *)(a1 + 72);
  BOOL v4 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v4) {
      goto LABEL_9;
    }
    int Value = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 64));
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = Value;
    uint64_t v6 = "#I Earthquake Alerts delivery availability %d";
    uint64_t v7 = v2;
    uint32_t v8 = 8;
  }
  else
  {
    if (!v4) {
      goto LABEL_9;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v6 = "#I Earthquake Alerts delivery availability not set";
    uint64_t v7 = v2;
    uint32_t v8 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
LABEL_9:
  int v9 = *(unsigned __int8 *)(a1 + 88);
  long long v10 = *(NSObject **)(a1 + 40);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (!v11) {
      goto LABEL_15;
    }
    int v12 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 80));
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v12;
    CFBooleanRef v13 = "#I Earthquake Alerts availability %d";
    CFTypeID v14 = v10;
    uint32_t v15 = 8;
  }
  else
  {
    if (!v11) {
      goto LABEL_15;
    }
    *(_WORD *)long long buf = 0;
    CFBooleanRef v13 = "#I Earthquake Alerts availability not set";
    CFTypeID v14 = v10;
    uint32_t v15 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
LABEL_15:
  int v16 = *(unsigned __int8 *)(a1 + 99);
  CFTypeID v17 = *(NSObject **)(a1 + 40);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v16)
  {
    if (!v18) {
      goto LABEL_21;
    }
    int v19 = *(unsigned __int8 *)(a1 + 98);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v19;
    uint64_t v20 = "#I Emergency Alerts pref %d";
    int v21 = v17;
    uint32_t v22 = 8;
  }
  else
  {
    if (!v18) {
      goto LABEL_21;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v20 = "#I Emergency Alerts pref not set";
    int v21 = v17;
    uint32_t v22 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, buf, v22);
LABEL_21:
  int v23 = *(unsigned __int8 *)(a1 + 97);
  int v24 = *(NSObject **)(a1 + 40);
  BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
  if (v23)
  {
    if (!v25) {
      goto LABEL_27;
    }
    int v26 = *(unsigned __int8 *)(a1 + 96);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v26;
    int v27 = "#I Enhanced Delivery pref %d";
    int v28 = v24;
    uint32_t v29 = 8;
  }
  else
  {
    if (!v25) {
      goto LABEL_27;
    }
    *(_WORD *)long long buf = 0;
    int v27 = "#I Enhanced Delivery pref not set";
    int v28 = v24;
    uint32_t v29 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
LABEL_27:
  uint64_t v31 = *(void *)(a1 + 152);
  uint64_t v30 = *(void *)(a1 + 160);
  if (v30 == v31)
  {
    int v37 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Earthquake Alerts list empty", buf, 2u);
    }
  }
  else
  {
    do
    {
      memset(v44, 0, sizeof(v44));
      *(void *)long long buf = &off_1019D3D50;
      uint64_t v43 = *(void *)(v31 + 8);
      if (*(char *)(v31 + 39) < 0)
      {
        sub_10004FC84(v44, *(void **)(v31 + 16), *(void *)(v31 + 24));
      }
      else
      {
        long long v32 = *(_OWORD *)(v31 + 16);
        *(void *)&v44[1] = *(void *)(v31 + 32);
        v44[0] = v32;
      }
      if (*(char *)(v31 + 63) < 0)
      {
        sub_10004FC84((unsigned char *)&v44[1] + 8, *(void **)(v31 + 40), *(void *)(v31 + 48));
      }
      else
      {
        long long v33 = *(_OWORD *)(v31 + 40);
        *((void *)&v44[2] + 1) = *(void *)(v31 + 56);
        *(_OWORD *)((char *)&v44[1] + 8) = v33;
      }
      xpc_object_t v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (v44[2] >= 0) {
          int v35 = (char *)&v44[1] + 8;
        }
        else {
          int v35 = (char *)*((void *)&v44[1] + 1);
        }
        if ((SBYTE7(v44[1]) & 0x80u) == 0) {
          __int16 v36 = v44;
        }
        else {
          __int16 v36 = *(_OWORD **)&v44[0];
        }
        *(_DWORD *)__int16 v38 = 136446466;
        int v39 = v35;
        __int16 v40 = 2082;
        int v41 = v36;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Stored Earthquake Alert: %{public}s, %{public}s", v38, 0x16u);
      }
      *(void *)long long buf = &off_1019D3D50;
      if (SHIBYTE(v44[2]) < 0) {
        operator delete(*((void **)&v44[1] + 1));
      }
      if (SBYTE7(v44[1]) < 0) {
        operator delete(*(void **)&v44[0]);
      }
      v31 += 64;
    }
    while (v31 != v30);
  }
}

void sub_101057A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101057A4C(uint64_t a1)
{
  sub_101058138(a1);

  operator delete();
}

void sub_101057A84(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 144;
        sub_101057B08(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_101057B08(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

const void **sub_101057B70(const void **a1, const void **a2)
{
  uint64_t v4 = sub_100083DA4(a1, a2);
  sub_100083DA4(v4 + 1, a2 + 1);
  sub_100083DA4(a1 + 2, a2 + 2);
  return a1;
}

char *sub_101057BB4(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  long long v5 = *(long long *)((char *)a2 + 24);
  long long v6 = *(long long *)((char *)a2 + 40);
  *(_OWORD *)(__dst + 56) = *(long long *)((char *)a2 + 56);
  *(_OWORD *)(__dst + 40) = v6;
  *(_OWORD *)(__dst + 24) = v5;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(__dst + 72, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)(__dst + 72) = v7;
  }
  uint32_t v8 = __dst + 96;
  if (*((char *)a2 + 119) < 0)
  {
    sub_10004FC84(v8, *((void **)a2 + 12), *((void *)a2 + 13));
  }
  else
  {
    long long v9 = a2[6];
    *((void *)__dst + 14) = *((void *)a2 + 14);
    *(_OWORD *)uint32_t v8 = v9;
  }
  long long v10 = *(long long *)((char *)a2 + 120);
  *((void *)__dst + 17) = *((void *)a2 + 17);
  *(_OWORD *)(__dst + 120) = v10;
  return __dst;
}

void sub_101057C90(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101057CC4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 144;
    sub_101057B08(i - 144);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_101057D14(void *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (*(char *)(*a1 + 63) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(v4 + 40), *(void *)(v4 + 48));
    uint64_t v4 = *a1;
  }
  else
  {
    long long __dst = *(_OWORD *)(v4 + 40);
    uint64_t v15 = *(void *)(v4 + 56);
  }
  if (*(char *)(v4 + 39) < 0)
  {
    sub_10004FC84(&v16, *(void **)(v4 + 16), *(void *)(v4 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(v4 + 16);
    v17[0] = *(void *)(v4 + 32);
    long long v16 = v5;
  }
  sub_1004AD8F8((uint64_t)v13, (void **)&__dst, 2);
  uint64_t v6 = sub_100145EC0((unsigned __int8 *)a2, v13);
  sub_10005CD2C((uint64_t)v13, (char *)v13[1]);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v17[i]) < 0) {
      operator delete((void *)v17[i - 2]);
    }
  }
  if (v6)
  {
    uint64_t v8 = a1[1];
    std::string::operator=((std::string *)v8, (const std::string *)a2);
    long long v9 = *(_OWORD *)(a2 + 24);
    long long v10 = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(v8 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(v8 + 40) = v10;
    *(_OWORD *)(v8 + 24) = v9;
    std::string::operator=((std::string *)(v8 + 72), (const std::string *)(a2 + 72));
    std::string::operator=((std::string *)(v8 + 96), (const std::string *)(a2 + 96));
    long long v11 = *(_OWORD *)(a2 + 120);
    *(void *)(v8 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(v8 + 120) = v11;
  }
  return v6;
}

void sub_101057E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101057EF4(void *a1, uint64_t a2)
{
  (*(void (**)(void **__return_ptr))(**(void **)*a1 + 192))(__p);
  if (*(char *)(a2 + 95) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long __dst = *(_OWORD *)(a2 + 72);
    uint64_t v15 = *(void *)(a2 + 88);
  }
  if (*(char *)(a2 + 119) < 0)
  {
    sub_10004FC84(&v16, *(void **)(a2 + 96), *(void *)(a2 + 104));
  }
  else
  {
    long long v16 = *(_OWORD *)(a2 + 96);
    v17[0] = *(void *)(a2 + 112);
  }
  sub_1004AD8F8((uint64_t)v11, (void **)&__dst, 2);
  uint64_t v4 = sub_100145EC0((unsigned __int8 *)__p, v11);
  sub_10005CD2C((uint64_t)v11, (char *)v11[1]);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v17[i]) < 0) {
      operator delete((void *)v17[i - 2]);
    }
  }
  if ((v13 & 0x80000000) == 0)
  {
    if (!v4) {
      return v4;
    }
    goto LABEL_15;
  }
  operator delete(__p[0]);
  if (v4)
  {
LABEL_15:
    uint64_t v6 = a1[1];
    std::string::operator=((std::string *)v6, (const std::string *)a2);
    long long v7 = *(_OWORD *)(a2 + 24);
    long long v8 = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(v6 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(v6 + 40) = v8;
    *(_OWORD *)(v6 + 24) = v7;
    std::string::operator=((std::string *)(v6 + 72), (const std::string *)(a2 + 72));
    std::string::operator=((std::string *)(v6 + 96), (const std::string *)(a2 + 96));
    long long v9 = *(_OWORD *)(a2 + 120);
    *(void *)(v6 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(v6 + 120) = v9;
  }
  return v4;
}

void sub_1010580B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_101058138(uint64_t a1)
{
  *(void *)a1 = &off_101A82150;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 552);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000346F8(a1 + 520, *(void **)(a1 + 528));
  sub_1001085D8(a1 + 456);
  sub_10013C44C(a1 + 384);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 376);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100060644((void *)(a1 + 336));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 328);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 312);
  *(void *)(a1 + 312) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 304), 0);
  uint64_t v6 = *(NSObject **)(a1 + 296);
  if (v6) {
    dispatch_release(v6);
  }
  long long v7 = *(std::__shared_weak_count **)(a1 + 288);
  if (v7) {
    sub_10004D2C8(v7);
  }
  long long v8 = *(std::__shared_weak_count **)(a1 + 272);
  if (v8) {
    sub_10004D2C8(v8);
  }
  long long v9 = *(std::__shared_weak_count **)(a1 + 248);
  if (v9) {
    sub_10004D2C8(v9);
  }
  CFTypeID v14 = (void **)(a1 + 216);
  sub_101057A84(&v14);
  uint64_t v10 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  long long v11 = *(std::__shared_weak_count **)(a1 + 200);
  if (v11) {
    sub_10004D2C8(v11);
  }
  int v12 = *(std::__shared_weak_count **)(a1 + 184);
  if (v12) {
    sub_10004D2C8(v12);
  }
  CFTypeID v14 = (void **)(a1 + 152);
  sub_1004AC990(&v14);
  CFTypeID v14 = (void **)(a1 + 128);
  sub_1004AD838(&v14);
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 104));
  uint64_t v13 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  CellBroadcastConfigInterface::~CellBroadcastConfigInterface((CellBroadcastConfigInterface *)a1);
}

void sub_101058300()
{
}

uint64_t sub_101058314(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_101058324(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10105835C(uint64_t a1)
{
}

uint64_t sub_101058378(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1010583BC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  return result;
}

void sub_1010583E8(ServiceManager::Service *this)
{
  *(void *)this = off_101A824C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_101058444(ServiceManager::Service *this)
{
  *(void *)this = off_101A824C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1010584B4@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CellBroadcastConfig");
}

unsigned char *sub_1010584C4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101058500(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(v2 + 8));
  operator new();
}

uint64_t sub_1010585F8()
{
  return 1;
}

uint64_t sub_101058600()
{
  return 1;
}

uint64_t sub_101058608()
{
  return 2;
}

void sub_101058610(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_null_create();
  }
  global_queue = dispatch_get_global_queue(2, 0);
  if (global_queue) {
    dispatch_retain(global_queue);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 16);
  if (v6)
  {
    long long v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      long long v8 = *a3;
      if (v8)
      {
        dispatch_retain(v8);
        dispatch_group_enter(v8);
      }
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10105873C(_Unwind_Exception *a1)
{
  if (v2) {
    dispatch_release(v2);
  }
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_101058764(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

void sub_101058878(ServiceManager::Service *this)
{
  *(void *)this = off_101A824C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1010588D4(ServiceManager::Service *this)
{
  *(void *)this = off_101A824C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_101058944()
{
  return 0;
}

uint64_t sub_10105894C()
{
  return 0;
}

uint64_t *sub_101058958(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v28 = a1;
  uint64_t v29 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping CellBroadcastConfig", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v30, *(Registry **)(v2 + 240));
  ctu::RestModule::connect();
  if (v31) {
    sub_10004D2C8(v31);
  }
  sub_101058EF0(v2 + 384);
  sub_100058DB0(__p, "/cc/props/localized_language");
  *(void *)long long buf = off_101A825A8;
  uint64_t v35 = v2 + 456;
  int v37 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/ringer_state");
  *(void *)long long buf = off_101A82628;
  uint64_t v35 = v2 + 504;
  int v37 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_1000DDC20(v2 + 508);
  sub_100058DB0(__p, "/cc/props/airplane_mode_user_preference");
  uint64_t v4 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v4 = off_101A826A8;
  *((void *)v4 + 1) = v2 + 512;
  *((void *)v4 + 2) = v2;
  *((void *)v4 + 3) = sub_10104BB00;
  *((void *)v4 + 4) = 0;
  int v37 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_10012E258(v2 + 520);
  if (capabilities::ct::supportsMeadowMode(v5)) {
    sub_10054E158(v2 + 448);
  }
  sub_100058DB0(__p, "/cc/events/operator_bundle_event");
  uint64_t v6 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v6 = off_101A82728;
  *((void *)v6 + 1) = v2;
  *((void *)v6 + 2) = sub_101057074;
  *((void *)v6 + 3) = 0;
  int v37 = v6;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  long long v7 = (uint8_t *)operator new(0x20uLL);
  *(void *)long long v7 = off_101A827A8;
  *((void *)v7 + 1) = v2;
  *((void *)v7 + 2) = sub_1010575D4;
  *((void *)v7 + 3) = 0;
  int v37 = v7;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  long long v8 = (uint64_t *)v33;
  if ((v8 & 0x80000000) != 0) {
    operator delete(__p[0]);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(v2 + 240));
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    CFTypeID v17 = (GestaltUtilityInterface *)v15[3];
    long long v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    CFTypeID v17 = 0;
  }
  std::mutex::unlock(v10);
  long long v16 = 0;
  char v18 = 1;
LABEL_25:
  int isWatch = GestaltUtilityInterface::isWatch(v17);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (isWatch)
  {
    uint64_t v20 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v20 || (int v21 = *(std::__shared_weak_count_vtbl **)(v2 + 8), (v22 = std::__shared_weak_count::lock(v20)) == 0)) {
      sub_100088B9C();
    }
    int v23 = v22;
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
    NotifySubscription::cancel((NotifySubscription *)(v2 + 104));
    int v24 = (std::__shared_weak_count *)operator new(0x28uLL);
    v24->__shared_weak_owners_ = 0;
    v24->__shared_owners_ = 0;
    v24->__vftable = (std::__shared_weak_count_vtbl *)off_101A82858;
    v24[1].__vftable = v21;
    v24[1].__shared_owners_ = (uint64_t)v23;
    BOOL v25 = *(const char **)(v2 + 104);
    int v26 = *(NSObject **)(v2 + 112);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v35 = 1174405120;
    __int16 v36 = sub_1010597F8;
    int v37 = (uint8_t *)&unk_101A82818;
    __int16 v38 = v24 + 1;
    int v39 = v24;
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v25, (int *)(v2 + 120), v26, buf);
    if (v39) {
      sub_10004D2C8(v39);
    }
    sub_10004D2C8(v24);
  }
  sub_100088C88(&v29);
  return sub_100046B58((uint64_t *)&v28);
}

void sub_101058E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  sub_10004D2C8(v25);
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_101058EF0(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/last_visible_plmns");
  v4[0] = off_101A82528;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_101058FA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_101058FD4()
{
}

void *sub_101058FE8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A82528;
  result[1] = v3;
  return result;
}

uint64_t sub_101059030(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A82528;
  a2[1] = v2;
  return result;
}

uint64_t sub_10105905C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10105909C()
{
}

void sub_1010590AC()
{
}

void *sub_1010590C0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A825A8;
  result[1] = v3;
  return result;
}

uint64_t sub_101059108(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A825A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_101059134()
{
  return read_rest_value();
}

uint64_t sub_10105913C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10105917C()
{
}

void sub_10105918C()
{
}

void *sub_1010591A0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A82628;
  result[1] = v3;
  return result;
}

uint64_t sub_1010591E8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A82628;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_101059214(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_1010592B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010592F0()
{
}

void sub_101059300()
{
}

__n128 sub_101059314(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A826A8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101059368(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A826A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1010593A0(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_101059498(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010594D8()
{
}

void sub_1010594E8()
{
}

__n128 sub_1010594FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A82728;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101059550(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A82728;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101059588(void *a1)
{
  uint64_t v5 = 255;
  *(_OWORD *)uint64_t v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)__p_8 = 0u;
  uint64_t v9 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (SHIBYTE(__p_8[1]) < 0) {
    operator delete(*((void **)&v7 + 1));
  }
  if (SBYTE7(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_101059648(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101059674(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010596B4()
{
}

void sub_1010596C4()
{
}

__n128 sub_1010596D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A827A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10105972C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A827A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101059764(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1010597AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1010597EC()
{
}

void sub_1010597F8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (!v2) {
    return;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *v1;
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I CellBroadcast settings synced to watch", buf, 2u);
    }
    __int16 v14 = 0;
    sub_101056CEC(v5, (unsigned char *)&v14 + 1, &v14);
    if (!*(unsigned char *)(v5 + 99) || !*(unsigned char *)(v5 + 97))
    {
      uint64_t v11 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "CellBroadcast preferences were not initialized", buf, 2u);
        uint64_t v11 = *(NSObject **)(v5 + 40);
      }
      *(_WORD *)(v5 + 98) = HIBYTE(v14) | 0x100;
      *(_WORD *)(v5 + 96) = v14 | 0x100;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_29;
      }
      *(_WORD *)long long buf = 0;
      goto LABEL_28;
    }
    int v7 = HIBYTE(v14);
    int v8 = *(unsigned __int8 *)(v5 + 98);
    if (HIBYTE(v14) != v8)
    {
      uint64_t v11 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109376;
        int v16 = v8;
        __int16 v17 = 1024;
        int v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I EmergencyAlertsPref synced: %d -> %d", buf, 0xEu);
        BOOL v12 = *(unsigned char *)(v5 + 97) == 0;
        uint64_t v11 = *(NSObject **)(v5 + 40);
      }
      else
      {
        BOOL v12 = 0;
      }
      *(_WORD *)(v5 + 98) = v7 | 0x100;
      int v9 = v14;
      int v10 = *(unsigned __int8 *)(v5 + 96);
      if (!v12 && v14 == v10) {
        goto LABEL_26;
      }
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:
        *(_WORD *)(v5 + 96) = v9 | 0x100;
LABEL_26:
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
LABEL_29:
          DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
          CFNotificationCenterPostNotification(DarwinNotifyCenter, @"kCTSMSCellBroadcastConfigChangedNotification", 0, 0, 0);
          goto LABEL_30;
        }
        *(_WORD *)long long buf = 0;
LABEL_28:
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Dispatching Darwin notification due to synced preferences change", buf, 2u);
        goto LABEL_29;
      }
      if (v12) {
        sub_10016C840();
      }
LABEL_24:
      *(_DWORD *)long long buf = 67109376;
      int v16 = v10;
      __int16 v17 = 1024;
      int v18 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I EnhancedDeliveryPref synced: %d -> %d", buf, 0xEu);
      uint64_t v11 = *(NSObject **)(v5 + 40);
      goto LABEL_25;
    }
    int v9 = v14;
    int v10 = *(unsigned __int8 *)(v5 + 96);
    if (v14 != v10)
    {
      uint64_t v11 = *(NSObject **)(v5 + 40);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
  }
LABEL_30:

  sub_10004D2C8(v4);
}

void sub_101059B20(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101059B34(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101059B50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_101059B60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A82858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101059B80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A82858;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101059BD4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t *sub_101059BE8(uint64_t *a1)
{
  uint64_t v1 = a1;
  xpc_object_t v51 = a1;
  uint64_t v2 = *a1;
  CFNumberRef v48 = (uint64_t *)(*a1 + 240);
  subscriber::makeSimSlotRange();
  uint64_t v4 = v63;
  uint64_t v3 = v64;
  if (v63 != v64)
  {
    uint64_t v5 = v65;
    while ((v65(*v4) & 1) == 0)
    {
      if (++v4 == v64)
      {
        uint64_t v4 = v64;
        break;
      }
    }
    xpc_object_t v47 = v64;
    if (v4 != v64)
    {
      xpc_object_t v44 = v1;
      uint64_t v50 = v2;
      while (1)
      {
        uint64_t v6 = (std::__shared_weak_count *)v1[2];
        if (!v6) {
          return sub_1006DF1FC((uint64_t *)&v51);
        }
        uint64_t v7 = *v4;
        int v8 = std::__shared_weak_count::lock(v6);
        if (!v8) {
          return sub_1006DF1FC((uint64_t *)&v51);
        }
        int v9 = v8;
        if (!v1[1]) {
          goto LABEL_77;
        }
        CFDictionaryRef v62 = 0;
        CFDictionaryRef v62 = (const __CFDictionary *)sub_10104C060(v2, v7);
        int v10 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v7);
        uint64_t v11 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Performing CMAS settings data migration", (uint8_t *)&buf, 2u);
        }
        if (!(v62 ? sub_100080778 : 0)) {
          break;
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(v48, (Registry *)*v48);
        __int16 v14 = ServiceMap;
        if ((v15 & 0x8000000000000000) != 0)
        {
          int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v17 = 5381;
          do
          {
            std::string::size_type v15 = v17;
            unsigned int v18 = *v16++;
            uint64_t v17 = (33 * v17) ^ v18;
          }
          while (v18);
        }
        std::mutex::lock(ServiceMap);
        buf.__r_.__value_.__r.__words[0] = v15;
        int v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&buf);
        unsigned int v49 = v7;
        if (v19)
        {
          uint64_t v20 = v19[3];
          int v21 = (std::__shared_weak_count *)v19[4];
          if (v21)
          {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v14);
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            uint32_t v22 = v21;
            sub_10004D2C8(v21);
            char v23 = 0;
            if (v20) {
              goto LABEL_27;
            }
            goto LABEL_23;
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
        std::mutex::unlock(v14);
        uint32_t v22 = 0;
        char v23 = 1;
        if (v20)
        {
LABEL_27:
          xpc_object_t v45 = v22;
          xpc_object_t v46 = v9;
          (*(void (**)(uint64_t))(*(void *)v20 + 112))(v20);
          CFIndex Count = CFDictionaryGetCount(v62);
          keys = 0;
          char v60 = 0;
          uint64_t v61 = 0;
          buf.__r_.__value_.__r.__words[0] = 0;
          sub_10039E2FC(&keys, Count, &buf);
          values = 0;
          xpc_object_t v57 = 0;
          uint64_t v58 = 0;
          buf.__r_.__value_.__r.__words[0] = 0;
          sub_10039E2FC(&values, Count, &buf);
          CFDictionaryGetKeysAndValues(v62, (const void **)keys, (const void **)values);
          int v26 = (CFTypeRef *)keys;
          int v27 = v60;
          while (1)
          {
            if (v26 == (CFTypeRef *)v27)
            {
              if (values)
              {
                xpc_object_t v57 = values;
                operator delete(values);
              }
              uint32_t v22 = v45;
              int v9 = v46;
              uint64_t v2 = v50;
              if (keys)
              {
                char v60 = keys;
                operator delete(keys);
              }
              goto LABEL_64;
            }
            CFStringRef v28 = (const __CFString *)*v26;
            if (*v26)
            {
              CFTypeID v29 = CFGetTypeID(*v26);
              if (v29 == CFStringGetTypeID()) {
                break;
              }
            }
LABEL_59:
            ++v26;
          }
          unsigned __int8 v55 = 0;
          __p[0] = 0;
          __p[1] = 0;
          int64_t v54 = 0;
          memset(&buf, 0, sizeof(buf));
          ctu::cf::assign();
          std::string v52 = buf;
          uint64_t v30 = std::string::insert(&v52, 0, "CellBroadcastSetting:", 0x15uLL);
          long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
          int64_t v54 = v30->__r_.__value_.__r.__words[2];
          *(_OWORD *)long long __p = v31;
          v30->__r_.__value_.__l.__size_ = 0;
          v30->__r_.__value_.__r.__words[2] = 0;
          v30->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v52.__r_.__value_.__l.__data_);
          }
          if ((*(uint64_t (**)(uint64_t, void **, unsigned __int8 *))(*(void *)v20 + 32))(v20, __p, &v55))
          {
            long long v32 = *v10;
            if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
            {
              char v33 = __p;
              if (v54 < 0) {
                char v33 = (void **)__p[0];
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Migrating legacy key %s", (uint8_t *)&buf, 0xCu);
            }
            memset(&buf, 0, sizeof(buf));
            ctu::cf::assign();
            std::string v52 = buf;
            std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = v52.__r_.__value_.__l.__size_;
            }
            if (size == 5)
            {
              uint64_t v35 = (std::string *)v52.__r_.__value_.__r.__words[0];
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v35 = &v52;
              }
              int data = (int)v35->__r_.__value_.__l.__data_;
              int v37 = v35->__r_.__value_.__s.__data_[4];
              BOOL v39 = data == 1700949313 && v37 == 114;
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
LABEL_52:
              }
                operator delete(v52.__r_.__value_.__l.__data_);
            }
            else
            {
              BOOL v39 = 0;
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_52;
              }
            }
            if (v39)
            {
              __int16 v40 = *v10;
              CFStringRef v28 = @"AMBER";
              if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Migrating settings with correct capitalization", (uint8_t *)&buf, 2u);
              }
            }
            sub_10104D064(v50, v49, v28, v55);
            (*(void (**)(uint64_t, void **))(*(void *)v20 + 96))(v20, __p);
          }
          if (SHIBYTE(v54) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_59;
        }
LABEL_23:
        int v24 = *v10;
        uint64_t v2 = v50;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Missing CSIPersistentPropertiesInterface", (uint8_t *)&buf, 2u);
        }
LABEL_64:
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v22);
        }
        sub_100057D78((const void **)&v62);
        sub_10004D2C8(v9);
        uint64_t v1 = v44;
        if (v20)
        {
          int v41 = v4 + 1;
          uint64_t v4 = v3;
          if (v41 != v3)
          {
            uint64_t v4 = v41;
            while ((v5(*v4) & 1) == 0)
            {
              if (++v4 == v3)
              {
                uint64_t v4 = v3;
                break;
              }
            }
          }
          if (v4 != v47) {
            continue;
          }
        }
        return sub_1006DF1FC((uint64_t *)&v51);
      }
      xpc_object_t v42 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I There are no alert types in operator bundle, no settings to migrate", (uint8_t *)&buf, 2u);
      }
      sub_100057D78((const void **)&v62);
LABEL_77:
      sub_10004D2C8(v9);
    }
  }
  return sub_1006DF1FC((uint64_t *)&v51);
}

void sub_10105A230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, __int16 a19, char a20,char a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,void *a38,uint64_t a39)
{
}

uint64_t *sub_10105A334(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down CellBroadcastConfig", buf, 2u);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 104));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 544));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10105A3C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10105A3DC(uint64_t a1)
{
  return sub_10104BC90(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8));
}

const void **sub_10105A3EC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  unsigned int v5 = *(_DWORD *)(v3 + 8);
  CFDictionaryRef v6 = (const __CFDictionary *)sub_10104C060(*(void *)v3, v5);
  CFDictionaryRef theDict = v6;
  if (v6) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7)
  {
    *a2 = 0;
    return sub_100057D78((const void **)&theDict);
  }
  CFIndex Count = CFDictionaryGetCount(v6);
  keys = 0;
  xpc_object_t v42 = 0;
  uint64_t v43 = 0;
  values = 0;
  sub_10039E2FC(&keys, Count, &values);
  values = 0;
  BOOL v39 = 0;
  uint64_t v40 = 0;
  *(void *)std::string buf = 0;
  sub_10039E2FC(&values, Count, buf);
  CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
  unsigned int v34 = v5;
  BOOL v9 = sub_10104C170(v4);
  value = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Count >= 1)
  {
    for (uint64_t i = 0; Count != i; ++i)
    {
      uint64_t v11 = keys[i];
      if (v11)
      {
        CFTypeID v12 = CFGetTypeID(keys[i]);
        if (v12 == CFStringGetTypeID()) {
          uint64_t v13 = v11;
        }
        else {
          uint64_t v13 = 0;
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
      CFMutableDictionaryRef MutableCopy = 0;
      CFDictionaryRef v14 = (const __CFDictionary *)values[i];
      if (v14)
      {
        CFTypeID v15 = CFGetTypeID(values[i]);
        if (v15 == CFDictionaryGetTypeID()) {
          CFDictionaryRef v16 = v14;
        }
        else {
          CFDictionaryRef v16 = 0;
        }
      }
      else
      {
        CFDictionaryRef v16 = 0;
      }
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v16);
      uint64_t v17 = (BOOL *)CFDictionaryGetValue(MutableCopy, @"UseMMI");
      unsigned int v18 = v17;
      buf[0] = 0;
      if (v17)
      {
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 == CFBooleanGetTypeID()) {
          ctu::cf::assign((ctu::cf *)buf, v18, v20);
        }
        if (buf[0])
        {
          if (!v9)
          {
            int v21 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 138543362;
              *(void *)&uint8_t buf[4] = v13;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Alert type removed from notification: [%{public}@]", buf, 0xCu);
            }
            goto LABEL_24;
          }
          CFDictionarySetValue(MutableCopy, @"UserConfigurable", kCFBooleanTrue);
        }
      }
      CFDictionaryRemoveValue(MutableCopy, @"UseMMI");
      CFDictionarySetValue((CFMutableDictionaryRef)value, v13, MutableCopy);
LABEL_24:
      sub_10005717C((const void **)&MutableCopy);
    }
  }
  CFMutableDictionaryRef MutableCopy = 0;
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(MutableCopy, @"AlertTypes", value);
  uint64_t v35 = 0;
  sub_10104B9E0(buf, *(Registry ***)(v4 + 368), v34, @"SwitchGroupTitle", 0);
  sub_100056248(&v35, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v35) {
    uint32_t v22 = (uint64_t *)sub_1000810B8;
  }
  else {
    uint32_t v22 = 0;
  }
  if (v22) {
    CFDictionarySetValue(MutableCopy, @"SwitchGroupTitle", v35);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *(Registry **)(v4 + 240));
  int v24 = ServiceMap;
  if (v25 < 0)
  {
    int v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v25;
  CFTypeID v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
  if (!v29)
  {
    uint64_t v31 = 0;
    goto LABEL_41;
  }
  uint64_t v31 = v29[3];
  uint64_t v30 = (std::__shared_weak_count *)v29[4];
  if (!v30)
  {
LABEL_41:
    std::mutex::unlock(v24);
    uint64_t v30 = 0;
    char v32 = 1;
    goto LABEL_42;
  }
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v24);
  atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v30);
  char v32 = 0;
LABEL_42:
  (*(void (**)(uint64_t, void, CFMutableDictionaryRef, uint64_t))(*(void *)v31 + 56))(v31, kCellBroadcastLocalizationTable, MutableCopy, 1);
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  sub_1000558F4((const void **)&v35);
  sub_10005717C((const void **)&MutableCopy);
  sub_10005717C((const void **)&value);
  if (values)
  {
    BOOL v39 = values;
    operator delete(values);
  }
  if (keys)
  {
    xpc_object_t v42 = keys;
    operator delete(keys);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_10105A864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, const void *a16, const void *a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,const void *a24)
{
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }
  sub_100057D78(&a24);
  _Unwind_Resume(a1);
}

const void **sub_10105A92C(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    CFDictionaryRef v6 = v3;
    *uint64_t v2 = v5;
    unsigned int v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_10105A9A4(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    CFDictionaryRef v6 = v3;
    *uint64_t v2 = v5;
    unsigned int v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

uint64_t sub_10105AA1C(uint64_t a1)
{
  return CellBroadcastConfig::getCellBroadcastSettingForAlertType_sync(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), *(const void **)(*(void *)(a1 + 40) + 16), *(unsigned char **)(*(void *)(a1 + 40) + 24));
}

uint64_t sub_10105AA30(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = (unsigned char *)v1[1];
  *uint64_t v3 = 0;
  subscriber::makeSimSlotRange();
  uint64_t v4 = v8;
  if (v8 == v9) {
    goto LABEL_16;
  }
  while ((v10(*v4) & 1) == 0)
  {
    if (++v4 == v9)
    {
      uint64_t v4 = v9;
      break;
    }
  }
  if (v4 == v9)
  {
LABEL_16:
    char v5 = 0;
  }
  else
  {
    char v5 = 0;
    do
    {
      if (sub_10104C7B8(v2, *v4, v3))
      {
        char v5 = 1;
        if (*v3) {
          break;
        }
      }
      CFDictionaryRef v6 = v4 + 1;
      uint64_t v4 = v9;
      if (v6 != v9)
      {
        uint64_t v4 = v6;
        while ((v10(*v4) & 1) == 0)
        {
          if (++v4 == v9)
          {
            uint64_t v4 = v9;
            break;
          }
        }
      }
    }
    while (v4 != v9);
  }
  return v5 & 1;
}

uint64_t sub_10105AB28(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  int v3 = *((unsigned __int8 *)v1 + 8);
  subscriber::makeSimSlotRange();
  uint64_t v4 = v18;
  if (v18 == v19) {
    goto LABEL_31;
  }
  while ((v20(*v4) & 1) == 0)
  {
    if (++v4 == v19)
    {
      uint64_t v4 = v19;
      break;
    }
  }
  if (v4 == v19)
  {
LABEL_31:
    char v5 = 0;
  }
  else
  {
    char v5 = 0;
    CFDictionaryRef v6 = "true";
    if (!v3) {
      CFDictionaryRef v6 = "false";
    }
    CFDictionaryRef v16 = v6;
    if (v3) {
      uint64_t v7 = &kCFBooleanTrue;
    }
    else {
      uint64_t v7 = &kCFBooleanFalse;
    }
    CFBooleanRef v8 = *v7;
    uint64_t v17 = kCommCenterSharedSettingsBundleId;
    do
    {
      BOOL v9 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v4);
      uint64_t v22 = 0;
      char v23 = 0;
      Registry::getMobileHelper(&v22, *(Registry **)(v2 + 240));
      if (v22)
      {
        int v10 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Saving the auto read out preference: %s to the persistent store", buf, 0xCu);
        }
        *(void *)std::string buf = 0;
        sub_100062778((const void **)buf);
        CFBooleanRef v21 = v8;
        *(void *)std::string buf = 0;
        sub_100062778((const void **)buf);
        char v11 = (*(uint64_t (**)(uint64_t, uint64_t, const __CFString *, CFBooleanRef))(*(void *)v22 + 24))(v22, v17, @"AutoReadOutPref", v8);
        if ((v11 & 1) == 0)
        {
          CFTypeID v12 = *v9;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to save auto read out preferences", buf, 2u);
          }
        }
        sub_100062778((const void **)&v21);
      }
      else
      {
        uint64_t v13 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Mobile helper interface is absent", buf, 2u);
        }
        char v11 = 0;
      }
      if (v23) {
        sub_10004D2C8(v23);
      }
      CFDictionaryRef v14 = v4 + 1;
      uint64_t v4 = v19;
      if (v14 != v19)
      {
        uint64_t v4 = v14;
        while ((v20(*v4) & 1) == 0)
        {
          if (++v4 == v19)
          {
            uint64_t v4 = v19;
            break;
          }
        }
      }
      v5 |= v11;
    }
    while (v4 != v19);
  }
  return v5 & 1;
}

void sub_10105AE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10105AE3C(uint64_t a1)
{
  return sub_10104D064(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), *(const __CFString **)(*(void *)(a1 + 40) + 16), *(unsigned __int8 *)(*(void *)(a1 + 40) + 24));
}

const void **sub_10105AE54@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  sub_100058198((const void **)&theDict, (const void **)(v3 + 8));
  *(void *)CFBooleanRef v67 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFDictionaryRef v6 = *(__CFDictionary **)v67;
    *(void *)CFBooleanRef v67 = Mutable;
    *(void *)std::string buf = v6;
    sub_10005717C((const void **)buf);
  }
  if (theDict) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7)
  {
    uint64_t v17 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Empty settings dict", buf, 2u);
    }
    goto LABEL_19;
  }
  int Value = CFDictionaryGetValue(theDict, @"AlertType");
  BOOL v9 = Value;
  if (!Value || (CFTypeID v10 = CFGetTypeID(Value), v10 != CFStringGetTypeID()))
  {
    CFDictionaryRef v16 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Empty alert name", buf, 2u);
    }
LABEL_19:
    sub_10004EFE4(a2, (CFTypeRef *)v67);
    goto LABEL_89;
  }
  CFTypeRef v66 = 0;
  CFDictionaryRef v74 = 0;
  sub_10104D8A8(&v74, v4, v9, @"EnableAlwaysDeliverByDefault");
  if (v74) {
    char v11 = sub_100080778;
  }
  else {
    char v11 = 0;
  }
  if (v11)
  {
    CFDictionaryRef v73 = 0;
    CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(v74, @"EnableAlwaysDeliverByDefault");
    CFDictionaryRef v13 = v12;
    if (v12)
    {
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 == CFBooleanGetTypeID()) {
        CFDictionaryRef v15 = v13;
      }
      else {
        CFDictionaryRef v15 = 0;
      }
    }
    else
    {
      CFDictionaryRef v15 = 0;
    }
    CFDictionaryRef v73 = v15;
    uint64_t v70 = 0;
    CFArrayRef v71 = 0;
    Registry::getMobileHelper(&v70, *(Registry **)(v4 + 240));
    uint64_t v19 = v70;
    if (v70)
    {
      CFTypeRef cf = 0;
      CFTypeRef v69 = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", v9, @"AlwaysDeliverPref");
      (*(void (**)(unsigned char *__return_ptr, uint64_t, void, CFTypeRef))(*(void *)v19 + 16))(buf, v19, kCommCenterSharedSettingsBundleId, v69);
      sub_1000057AC(&cf, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      sub_1000558F4(&v69);
      if (cf) {
        CFBooleanRef v20 = sub_100084B4C;
      }
      else {
        CFBooleanRef v20 = 0;
      }
      if (v20)
      {
        CFTypeRef v66 = cf;
        if (cf) {
          CFRetain(cf);
        }
        CFBooleanRef v21 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          LOBYTE(v69) = 0;
          ctu::cf::assign((ctu::cf *)&v69, (BOOL *)v66, v22);
          char v23 = "enable";
          if (!(_BYTE)v69) {
            char v23 = "disabled";
          }
          *(_DWORD *)std::string buf = 138543618;
          *(void *)&uint8_t buf[4] = v9;
          __int16 v76 = 2080;
          CFStringRef v77 = (const __CFString *)v23;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Custom preference read for %{public}@ - [Always Deliver: %s]", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v25 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          LOBYTE(v69) = 0;
          ctu::cf::assign((ctu::cf *)&v69, (BOOL *)v73, v26);
          uint64_t v27 = "enable";
          if (!(_BYTE)v69) {
            uint64_t v27 = "disabled";
          }
          *(_DWORD *)std::string buf = 138543618;
          *(void *)&uint8_t buf[4] = v9;
          __int16 v76 = 2080;
          CFStringRef v77 = (const __CFString *)v27;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Custom preference read from bundle for %{public}@ - [Always Deliver: %s]", buf, 0x16u);
        }
        CFTypeRef v66 = v73;
        CFDictionaryRef v73 = 0;
      }
      sub_100062778(&cf);
    }
    else
    {
      int v24 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper using bundle config for Always deliver", buf, 2u);
      }
      CFTypeRef v66 = v73;
      CFDictionaryRef v73 = 0;
    }
    if (v71) {
      sub_10004D2C8(v71);
    }
    sub_100062778((const void **)&v73);
  }
  else
  {
    unsigned int v18 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138543618;
      *(void *)&uint8_t buf[4] = v9;
      __int16 v76 = 2112;
      CFStringRef v77 = @"EnableAlwaysDeliverByDefault";
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Missing key for %{public}@ - %@", buf, 0x16u);
    }
    CFTypeRef v66 = 0;
  }
  sub_100057D78((const void **)&v74);
  if (v66) {
    unsigned int v28 = sub_100084B4C;
  }
  else {
    unsigned int v28 = 0;
  }
  if (v28) {
    sub_10012C97C(*(__CFDictionary **)v67, @"AlwaysDeliverPref", (uint64_t)v66);
  }
  CFTypeRef v65 = 0;
  *(void *)std::string buf = 0;
  sub_100062778((const void **)buf);
  CFDictionaryRef v74 = kCFBooleanFalse;
  *(void *)std::string buf = 0;
  sub_100062778((const void **)buf);
  CFDictionaryRef v73 = 0;
  sub_10104D8A8(&v73, v4, v9, @"EnableEnhancedDelivery");
  if (v73) {
    CFTypeID v29 = sub_100080778;
  }
  else {
    CFTypeID v29 = 0;
  }
  if (!v29)
  {
    xpc_object_t v47 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
      goto LABEL_82;
    }
    *(_WORD *)std::string buf = 0;
    xpc_object_t v46 = "Missing bundle dict";
    CFNumberRef v48 = v47;
    uint32_t v49 = 2;
LABEL_79:
    _os_log_error_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, v46, buf, v49);
    goto LABEL_82;
  }
  uint64_t v30 = (BOOL *)CFDictionaryGetValue(v73, @"EnableEnhancedDelivery");
  uint64_t v31 = v30;
  buf[0] = 0;
  if (!v30) {
    goto LABEL_72;
  }
  CFTypeID v32 = CFGetTypeID(v30);
  if (v32 == CFBooleanGetTypeID()) {
    ctu::cf::assign((ctu::cf *)buf, v31, v33);
  }
  if (!buf[0])
  {
LABEL_72:
    xpc_object_t v45 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      goto LABEL_82;
    }
    *(_DWORD *)std::string buf = 138412290;
    *(void *)&uint8_t buf[4] = @"EnableAlwaysDeliverByDefault";
    xpc_object_t v46 = "Feature disabled from bundle: %@";
    goto LABEL_78;
  }
  CFDictionaryRef v34 = (const __CFDictionary *)CFDictionaryGetValue(v73, @"AlertType");
  CFDictionaryRef v35 = v34;
  if (!v34 || (CFTypeID v36 = CFGetTypeID(v34), v36 != CFDictionaryGetTypeID()))
  {
    xpc_object_t v45 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      goto LABEL_82;
    }
    *(_DWORD *)std::string buf = 138412290;
    *(void *)&uint8_t buf[4] = @"AlertType";
    xpc_object_t v46 = "Missing bundle config: EnhancedDelivery.%@";
LABEL_78:
    CFNumberRef v48 = v45;
    uint32_t v49 = 12;
    goto LABEL_79;
  }
  int v37 = (BOOL *)CFDictionaryGetValue(v35, @"UserConfigurable");
  __int16 v38 = v37;
  buf[0] = 0;
  if (v37)
  {
    CFTypeID v39 = CFGetTypeID(v37);
    if (v39 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v38, v40);
    }
    if (buf[0])
    {
      CFTypeRef cf = 0;
      int v41 = CFDictionaryGetValue(v35, @"EnabledByDefault");
      xpc_object_t v42 = v41;
      if (v41 && (CFTypeID v43 = CFGetTypeID(v41), v43 == CFBooleanGetTypeID()))
      {
        CFTypeRef cf = v42;
        CFRetain(v42);
        CFTypeRef v44 = cf;
      }
      else
      {
        CFTypeRef v44 = 0;
        CFTypeRef cf = 0;
      }
      if (v44) {
        xpc_object_t v53 = sub_100084B4C;
      }
      else {
        xpc_object_t v53 = 0;
      }
      if (v53)
      {
        uint64_t v70 = 0;
        CFArrayRef v71 = 0;
        Registry::getMobileHelper(&v70, *(Registry **)(v4 + 240));
        uint64_t v54 = v70;
        if (v70)
        {
          CFTypeRef v69 = 0;
          CFStringRef v68 = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", v9, @"EnhancedDeliveryPref");
          (*(void (**)(unsigned char *__return_ptr, uint64_t, void, CFStringRef))(*(void *)v54 + 16))(buf, v54, kCommCenterSharedSettingsBundleId, v68);
          sub_1000057AC(&v69, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          sub_1000558F4((const void **)&v68);
          if (v69) {
            unsigned __int8 v55 = sub_100084B4C;
          }
          else {
            unsigned __int8 v55 = 0;
          }
          if (v55)
          {
            CFTypeRef v65 = 0;
            sub_1000627AC(&v65, v69);
            int v56 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              LOBYTE(v68) = 0;
              ctu::cf::assign((ctu::cf *)&v68, (BOOL *)v65, v57);
              uint64_t v58 = "enable";
              if (!(_BYTE)v68) {
                uint64_t v58 = "disabled";
              }
              *(_DWORD *)std::string buf = 138543618;
              *(void *)&uint8_t buf[4] = v9;
              __int16 v76 = 2080;
              CFStringRef v77 = (const __CFString *)v58;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I Custom preference read for %{public}@ - [Enhanced delivery: %s]", buf, 0x16u);
            }
          }
          else
          {
            uint64_t v61 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
            {
              LOBYTE(v68) = 0;
              ctu::cf::assign((ctu::cf *)&v68, (BOOL *)cf, v62);
              CSIPhoneNumber v63 = "enable";
              if (!(_BYTE)v68) {
                CSIPhoneNumber v63 = "disabled";
              }
              *(_DWORD *)std::string buf = 138543618;
              *(void *)&uint8_t buf[4] = v9;
              __int16 v76 = 2080;
              CFStringRef v77 = (const __CFString *)v63;
              _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Custom preference read from bundle for %{public}@ - [Enhanced delivery: %s]", buf, 0x16u);
            }
            CFTypeRef v65 = cf;
            CFTypeRef cf = 0;
          }
          sub_100062778(&v69);
        }
        else
        {
          char v60 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper using bundle config for enhanced delivery", buf, 2u);
          }
          CFTypeRef v65 = v74;
          CFDictionaryRef v74 = 0;
        }
        if (v71) {
          sub_10004D2C8(v71);
        }
      }
      else
      {
        xpc_object_t v59 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 138412290;
          *(void *)&uint8_t buf[4] = @"EnabledByDefault";
          _os_log_error_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "Missing bundle config: EnhancedDelivery.%@", buf, 0xCu);
        }
        CFTypeRef v65 = v74;
        CFDictionaryRef v74 = 0;
      }
      sub_100062778(&cf);
      goto LABEL_83;
    }
  }
  uint64_t v50 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Enhanced delivery not user configurable", buf, 2u);
  }
LABEL_82:
  CFTypeRef v65 = v74;
  CFDictionaryRef v74 = 0;
LABEL_83:
  sub_100057D78((const void **)&v73);
  sub_100062778((const void **)&v74);
  if (v65) {
    xpc_object_t v51 = sub_100084B4C;
  }
  else {
    xpc_object_t v51 = 0;
  }
  if (v51) {
    sub_10012C97C(*(__CFDictionary **)v67, @"EnhancedDeliveryPref", (uint64_t)v65);
  }
  sub_10004EFE4(a2, (CFTypeRef *)v67);
  sub_100062778(&v65);
  sub_100062778(&v66);
LABEL_89:
  sub_10005717C((const void **)v67);
  return sub_100057D78((const void **)&theDict);
}

void sub_10105B91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va6, a4);
  va_start(va5, a4);
  va_start(va4, a4);
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  char v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  CFBooleanRef v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFTypeID v10 = va_arg(va3, const void *);
  uint64_t v12 = va_arg(va3, void);
  va_copy(va4, va3);
  CFDictionaryRef v13 = va_arg(va4, const void *);
  uint64_t v15 = va_arg(va4, void);
  CFDictionaryRef v16 = va_arg(va4, std::__shared_weak_count *);
  va_copy(va5, va4);
  uint64_t v17 = va_arg(va5, const void *);
  va_copy(va6, va5);
  uint64_t v19 = va_arg(va6, const void *);
  sub_100062778((const void **)va3);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_100062778((const void **)va4);
  sub_100057D78((const void **)va5);
  sub_100062778((const void **)va6);
  sub_100062778((const void **)va1);
  sub_10005717C((const void **)va2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10105BA74(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  subscriber::makeSimSlotRange();
  uint64_t v3 = *(unsigned int **)v39;
  uint64_t v2 = v40;
  if (*(unsigned int **)v39 != v40)
  {
    uint64_t v4 = v41;
    while ((v41(*v3) & 1) == 0)
    {
      if (++v3 == v40)
      {
        uint64_t v3 = v40;
        break;
      }
    }
    char v5 = v40;
    if (v3 != v40)
    {
      CFTypeID v29 = v40;
      uint64_t v30 = v1;
      while (1)
      {
        uint64_t v6 = *v3;
        CFDictionaryRef theDict = 0;
        sub_10104B954(&keys, *(Registry ***)(v1 + 368), v6);
        sub_10004EFE4(&theDict, (CFTypeRef *)&keys);
        sub_1000577C4((const void **)&keys);
        if (theDict) {
          uint64_t v7 = sub_100080778;
        }
        else {
          uint64_t v7 = 0;
        }
        if (!v7) {
          goto LABEL_28;
        }
        CFDictionaryRef v37 = 0;
        keys = (void **)CFDictionaryGetValue(theDict, @"AlertConfigurations");
        sub_10004EFE4(&v37, (CFTypeRef *)&keys);
        if (!(v37 ? sub_100080778 : 0)) {
          break;
        }
        CFIndex Count = CFDictionaryGetCount(v37);
        keys = 0;
        CFDictionaryRef v35 = 0;
        uint64_t v36 = 0;
        values = 0;
        sub_10039E2FC(&keys, Count, &values);
        values = 0;
        CFTypeID v32 = 0;
        uint64_t v33 = 0;
        *(void *)std::string buf = 0;
        sub_10039E2FC(&values, Count, buf);
        CFDictionaryGetKeysAndValues(v37, (const void **)keys, (const void **)values);
        if (Count < 1)
        {
          BOOL v11 = 0;
        }
        else
        {
          uint64_t v10 = 0;
          BOOL v11 = 1;
          while (1)
          {
            uint64_t v12 = values[v10];
            if (v12)
            {
              CFTypeID v13 = CFGetTypeID(values[v10]);
              CFDictionaryRef v14 = v13 == CFDictionaryGetTypeID() ? (const __CFDictionary *)v12 : 0;
            }
            else
            {
              CFDictionaryRef v14 = 0;
            }
            int Value = (BOOL *)CFDictionaryGetValue(v14, @"OverrideAccessibilityVibrationSetting");
            CFDictionaryRef v16 = Value;
            if (Value)
            {
              CFTypeID v17 = CFGetTypeID(Value);
              if (v17 == CFBooleanGetTypeID()) {
                break;
              }
            }
            BOOL v11 = ++v10 < Count;
            if (Count == v10)
            {
              char v5 = v29;
              goto LABEL_34;
            }
          }
          buf[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, v16, v18);
          int v19 = buf[0];
          BOOL v28 = buf[0] != 0;
          CFBooleanRef v20 = *(NSObject **)(v30 + 40);
          char v5 = v29;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = subscriber::asString();
            *(_DWORD *)std::string buf = 136315394;
            CFBooleanRef v22 = "false";
            if (v19) {
              CFBooleanRef v22 = "true";
            }
            *(void *)&uint8_t buf[4] = v22;
            __int16 v43 = 2080;
            uint64_t v44 = v21;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Override accessibility vibration setting %s [slot:%s]", buf, 0x16u);
          }
        }
LABEL_34:
        if (values)
        {
          CFTypeID v32 = values;
          operator delete(values);
        }
        if (keys)
        {
          CFDictionaryRef v35 = keys;
          operator delete(keys);
        }
        sub_100057D78((const void **)&v37);
        sub_100057D78((const void **)&theDict);
        if (v11) {
          return v28;
        }
        uint64_t v1 = v30;
LABEL_40:
        char v23 = v3 + 1;
        uint64_t v3 = v2;
        if (v23 != v2)
        {
          uint64_t v3 = v23;
          while ((v4(*v3) & 1) == 0)
          {
            if (++v3 == v2)
            {
              uint64_t v3 = v2;
              break;
            }
          }
        }
        if (v3 == v5) {
          goto LABEL_46;
        }
      }
      sub_100057D78((const void **)&v37);
LABEL_28:
      sub_100057D78((const void **)&theDict);
      goto LABEL_40;
    }
  }
LABEL_46:
  int v24 = *(NSObject **)(v1 + 40);
  BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
  BOOL v26 = 0;
  if (v25)
  {
    *(_WORD *)CFTypeID v39 = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Override accessibility vibration setting: false", v39, 2u);
    return 0;
  }
  return v26;
}

void sub_10105BE24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,const void *a21,const void *a22)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  sub_100057D78(&a21);
  sub_100057D78(&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_10105BEA0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  sub_100058198((const void **)&theDict, (const void **)v1[1]);
  if (theDict) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    uint64_t v50 = 0;
    *(void *)std::string buf = CFDictionaryGetValue(theDict, @"AlertType");
    sub_100056248(&v50, (CFTypeRef *)buf);
    if (v50) {
      uint64_t v4 = sub_1000810B8;
    }
    else {
      uint64_t v4 = 0;
    }
    if (!v4)
    {
      BOOL v11 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Empty alert name", buf, 2u);
      }
      uint64_t v10 = 0;
      goto LABEL_72;
    }
    uint64_t v48 = 0;
    uint32_t v49 = 0;
    Registry::getMobileHelper(&v48, *(Registry **)(v2 + 240));
    if (!v48)
    {
      uint64_t v12 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper", buf, 2u);
      }
      uint64_t v10 = 0;
      goto LABEL_70;
    }
    int Value = (BOOL *)CFDictionaryGetValue(theDict, @"AlwaysDeliverPref");
    uint64_t v6 = Value;
    if (Value)
    {
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFBooleanGetTypeID()) {
        CFBooleanRef v8 = v6;
      }
      else {
        CFBooleanRef v8 = 0;
      }
    }
    else
    {
      CFBooleanRef v8 = 0;
    }
    CFTypeID v13 = (BOOL *)CFDictionaryGetValue(theDict, @"EnhancedDeliveryPref");
    CFDictionaryRef v14 = v13;
    if (v13)
    {
      CFTypeID v15 = CFGetTypeID(v13);
      if (v15 != CFBooleanGetTypeID()) {
        CFDictionaryRef v14 = 0;
      }
      CFStringRef v47 = 0;
      if (!v8)
      {
        if (v14)
        {
          CFStringRef v16 = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", v50, @"EnhancedDeliveryPref");
          *(void *)std::string buf = v47;
          xpc_object_t v46 = 0;
          CFStringRef v47 = v16;
          sub_1000558F4((const void **)buf);
          sub_1000558F4((const void **)&v46);
          xpc_object_t v46 = 0;
          uint64_t v17 = kCommCenterSharedSettingsBundleId;
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v48 + 16))(buf);
          sub_1000057AC(&v46, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          if (((*(uint64_t (**)(uint64_t, uint64_t, CFStringRef, BOOL *))(*(void *)v48 + 24))(v48, v17, v47, v14) & 1) == 0)
          {
            uint64_t v31 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to store custom preference", buf, 2u);
            }
            sub_100062778((const void **)&v46);
            goto LABEL_68;
          }
          if (v46) {
            CFBooleanRef v18 = sub_100084B4C;
          }
          else {
            CFBooleanRef v18 = 0;
          }
          if (v18)
          {
            if (v46 == v14)
            {
LABEL_53:
              uint64_t v33 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
              {
                CFDictionaryRef v35 = v50;
                CFStringRef v36 = v47;
                char v51 = 0;
                ctu::cf::assign((ctu::cf *)&v51, v14, v34);
                *(_DWORD *)std::string buf = 138543874;
                if (v51) {
                  CFDictionaryRef v37 = "enabled";
                }
                else {
                  CFDictionaryRef v37 = "disabled";
                }
                *(void *)&uint8_t buf[4] = v35;
                *(_WORD *)&unsigned char buf[12] = 2112;
                *(void *)&buf[14] = v36;
                *(_WORD *)&unsigned char buf[22] = 2080;
                xpc_object_t v53 = v37;
                _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Stored custom preference for %{public}@ - [%@: %s]", buf, 0x20u);
              }
              sub_100062778((const void **)&v46);
              goto LABEL_59;
            }
            int v19 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              CFBooleanRef v20 = "#I Dispatching Darwin notification for Enhanced Delivery preference change";
LABEL_51:
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 2u);
            }
          }
          else
          {
            int v19 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              CFBooleanRef v20 = "#I Dispatching Darwin notification for Enhanced Delivery initial change";
              goto LABEL_51;
            }
          }
          DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
          CFNotificationCenterPostNotification(DarwinNotifyCenter, @"kCTSMSCellBroadcastConfigChangedNotification", 0, 0, 0);
          goto LABEL_53;
        }
LABEL_59:
        CFStringRef v38 = v47;
        if (v47) {
          CFTypeID v39 = sub_1000810B8;
        }
        else {
          CFTypeID v39 = 0;
        }
        if (v39)
        {
          uint64_t v40 = *(void *)(v2 + 192);
          if (v40)
          {
            int v41 = operator new(8uLL);
            uint64_t v42 = kCommCenterSharedSettingsBundleId;
            *(void *)std::string buf = v41;
            void *v41 = v38;
            *(void *)&uint8_t buf[8] = v41 + 1;
            *(void *)&uint8_t buf[16] = v41 + 1;
            (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v40 + 16))(v40, v42, buf);
            if (*(void *)buf)
            {
              *(void *)&uint8_t buf[8] = *(void *)buf;
              operator delete(*(void **)buf);
            }
          }
          uint64_t v10 = 1;
          goto LABEL_69;
        }
        __int16 v43 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
LABEL_68:
          uint64_t v10 = 0;
LABEL_69:
          sub_1000558F4((const void **)&v47);
LABEL_70:
          if (v49) {
            sub_10004D2C8(v49);
          }
LABEL_72:
          sub_1000558F4(&v50);
          goto LABEL_73;
        }
        *(_DWORD *)std::string buf = 138543362;
        *(void *)&uint8_t buf[4] = v50;
        BOOL v28 = "No valid custom preference for %{public}@";
        CFTypeID v29 = v43;
        uint32_t v30 = 12;
LABEL_75:
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v28, buf, v30);
        goto LABEL_68;
      }
    }
    else
    {
      CFStringRef v47 = 0;
      if (!v8) {
        goto LABEL_59;
      }
    }
    CFStringRef v21 = CFStringCreateWithFormat(0, 0, @"%@%@%@", @"CellBroadcastSetting", v50, @"AlwaysDeliverPref");
    *(void *)std::string buf = v47;
    xpc_object_t v46 = 0;
    CFStringRef v47 = v21;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)&v46);
    char v22 = (*(uint64_t (**)(uint64_t, void, CFStringRef, BOOL *))(*(void *)v48 + 24))(v48, kCommCenterSharedSettingsBundleId, v47, v8);
    char v23 = *(NSObject **)(v2 + 40);
    if ((v22 & 1) == 0)
    {
      if (!os_log_type_enabled(*(os_log_t *)(v2 + 40), OS_LOG_TYPE_ERROR)) {
        goto LABEL_68;
      }
      *(_WORD *)std::string buf = 0;
      BOOL v28 = "Failed to store custom preference";
      CFTypeID v29 = v23;
      uint32_t v30 = 2;
      goto LABEL_75;
    }
    if (os_log_type_enabled(*(os_log_t *)(v2 + 40), OS_LOG_TYPE_DEFAULT))
    {
      BOOL v25 = v50;
      CFStringRef v26 = v47;
      LOBYTE(v46) = 0;
      ctu::cf::assign((ctu::cf *)&v46, v8, v24);
      *(_DWORD *)std::string buf = 138543874;
      if ((_BYTE)v46) {
        uint64_t v27 = "enabled";
      }
      else {
        uint64_t v27 = "disabled";
      }
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v26;
      *(_WORD *)&unsigned char buf[22] = 2080;
      xpc_object_t v53 = v27;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Stored custom preference for %{public}@ - [%@: %s]", buf, 0x20u);
    }
    goto LABEL_59;
  }
  BOOL v9 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Empty settings dict", buf, 2u);
  }
  uint64_t v10 = 0;
LABEL_73:
  sub_100057D78((const void **)&theDict);
  return v10;
}

void sub_10105C5A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, const void *a14, uint64_t a15, std::__shared_weak_count *a16, const void *a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_1000558F4(&a17);
  sub_100057D78(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10105C63C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  uint64_t v4 = *(unsigned char **)(v1 + 16);
  char v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v3);
  *uint64_t v4 = 0;
  CFDictionaryRef v6 = (const __CFDictionary *)sub_10104C060(v2, v3);
  CFDictionaryRef theDict = v6;
  if (v6) {
    CFTypeID v7 = sub_100080778;
  }
  else {
    CFTypeID v7 = 0;
  }
  if (v7)
  {
    CFIndex Count = CFDictionaryGetCount(v6);
    char v22 = 0;
    keys = 0;
    CFBooleanRef v20 = 0;
    uint64_t v21 = 0;
    values = 0;
    sub_10039E2FC(&keys, Count, &values);
    values = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    sub_10039E2FC(&values, Count, &v15);
    CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
    if (Count >= 1)
    {
      for (uint64_t i = 0; i != Count; ++i)
      {
        uint64_t v10 = keys[i];
        if (v10)
        {
          CFTypeID v11 = CFGetTypeID(keys[i]);
          if (v11 == CFStringGetTypeID()) {
            uint64_t v12 = v10;
          }
          else {
            uint64_t v12 = 0;
          }
        }
        else
        {
          uint64_t v12 = 0;
        }
        if (CellBroadcastConfig::getCellBroadcastSettingForAlertType_sync(v2, v3, v12, &v22)) {
          *v4 |= v22;
        }
      }
    }
    if (values)
    {
      uint64_t v17 = values;
      operator delete(values);
    }
    if (keys)
    {
      CFBooleanRef v20 = keys;
      operator delete(keys);
    }
  }
  else
  {
    CFTypeID v13 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(keys) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "No Alert types found", (uint8_t *)&keys, 2u);
    }
  }
  sub_100057D78((const void **)&theDict);
  return 1;
}

void sub_10105C814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  sub_100057D78(&a18);
  _Unwind_Resume(a1);
}

BOOL sub_10105C860(uint64_t a1)
{
  return sub_10104EF78(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), *(unsigned __int16 *)(*(void *)(a1 + 40) + 12), *(_DWORD *)(*(void *)(a1 + 40) + 16));
}

uint64_t sub_10105C878(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = v1[1];
  uint64_t v3 = **v1;
  uint64_t v5 = *((void *)v2 + 22);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 23);
  uint64_t v12 = v5;
  CFTypeID v13 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFDictionaryRef v6 = v1[2];
  CFTypeID v7 = v1[3];
  long long v8 = *(_OWORD *)(v7 + 3);
  v11[0] = *(_OWORD *)v7;
  *(_OWORD *)((char *)v11 + 12) = v8;
  uint64_t v9 = sub_1001457E4(v3, &v12, v6, v11, *v1[4]);
  if (v13) {
    sub_10004D2C8(v13);
  }
  return v9;
}

void sub_10105C8FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10105C914(uint64_t a1)
{
  uint64_t v1 = *(unsigned int ***)(a1 + 40);
  return (*(uint64_t (**)(void, void, void, void))(**((void **)*v1 + 22) + 16))(*((void *)*v1 + 22), *v1[1], *v1[2], *v1[3]);
}

uint64_t sub_10105C954(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 40);
  uint64_t v2 = *((void *)v1 + 1);
  int v3 = *v1;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  Registry::getMobileHelper(&v16, *(Registry **)(v2 + 240));
  if (v16)
  {
    uint64_t v4 = &kCFBooleanTrue;
    if (!v3) {
      uint64_t v4 = &kCFBooleanFalse;
    }
    CFBooleanRef v5 = *v4;
    *(void *)std::string buf = 0;
    sub_100062778((const void **)buf);
    CFBooleanRef v15 = v5;
    *(void *)std::string buf = 0;
    sub_100062778((const void **)buf);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, void, const __CFString *, CFBooleanRef))(*(void *)v16 + 24))(v16, kCommCenterSharedSettingsBundleId, @"CellBroadcastMMIPref", v5);
    CFTypeID v7 = *(NSObject **)(v2 + 40);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v8)
      {
        uint64_t v9 = "true";
        if (!v3) {
          uint64_t v9 = "false";
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        uint64_t v10 = "#I MMI preference saved successfully value:[%s]";
        CFTypeID v11 = v7;
        uint32_t v12 = 12;
        goto LABEL_14;
      }
    }
    else if (v8)
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "#I MMI preference save error";
      CFTypeID v11 = v7;
      uint32_t v12 = 2;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
    }
    sub_100062778((const void **)&v15);
    goto LABEL_16;
  }
  CFTypeID v13 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "MobileHelperInterface is absent", buf, 2u);
  }
  uint64_t v6 = 0;
LABEL_16:
  if (v17) {
    sub_10004D2C8(v17);
  }
  return v6;
}

void sub_10105CB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_10105CB64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFBooleanRef v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(atomic_ullong **)(v1 + 16);
  v7[0] = *(sms::Model **)(v1 + 8);
  v7[1] = (sms::Model *)v3;
  if (v3) {
    atomic_fetch_add_explicit(v3 + 1, 1uLL, memory_order_relaxed);
  }
  sub_101050580(v2, v7);
  if (v3) {
    sub_10004D2C8((std::__shared_weak_count *)v3);
  }
  sub_1000E1A60(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10105CBD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1000E1A60(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10105CBF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 16);
  if (v1) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_10105D5CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,xpc_object_t object,char a34)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_10105D8CC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_10105D924()
{
}

__n128 sub_10105D938(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A82AE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10105D984(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A82AE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10105D9B4(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  int v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 8) + 48) + 16))(*(void *)(*(void *)(a1 + 8) + 48), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "is";
    if (!v2) {
      uint64_t v4 = "is not";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband online assertion %s granted", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_10105DA98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10105DAD8()
{
}

__CFArray *sub_10105DAE4(uint64_t a1)
{
  return CellBroadcastConfig::copyCurrentActiveCMASConfiguration_sync(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), *(const void **)(*(void *)(a1 + 40) + 16));
}

uint64_t sub_10105DAF8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10105DB34(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

BOOL sub_10105DB70(uint64_t a1)
{
  return sub_10104C2DC(**(capabilities::ct ***)(a1 + 40));
}

uint64_t sub_10105DB7C(uint64_t a1)
{
  return sub_10104E978(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), *(_DWORD *)(*(void *)(a1 + 40) + 12));
}

const void **sub_10105DB8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  int v2 = *(Registry ****)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  int v5 = *(unsigned char **)(v1 + 16);
  uint64_t v4 = *(_DWORD **)(v1 + 24);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v3);
  uint64_t result = (const void **)sub_10104C2DC((capabilities::ct *)v2);
  if (result)
  {
    CFBooleanRef v15 = 0;
    sub_10104B9E0(buf, v2[46], v3, @"DataThrottleOnMessageReceive", 0);
    sub_1000057AC(&v15, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v15) {
      uint64_t v9 = sub_100084B4C;
    }
    else {
      uint64_t v9 = 0;
    }
    if (v9)
    {
      buf[0] = 0;
      ctu::cf::assign((ctu::cf *)buf, v15, v8);
      *int v5 = buf[0];
      *(void *)std::string buf = 0;
      sub_10104B9E0(&v13, v2[46], v3, @"DataThrottleTimeout", 0);
      sub_1000842D0(buf, &v13);
      sub_1000577C4(&v13);
      if (*(void *)buf) {
        CFTypeID v11 = sub_100081E58;
      }
      else {
        CFTypeID v11 = 0;
      }
      if (v11)
      {
        LODWORD(v13) = 0;
        ctu::cf::assign((ctu::cf *)&v13, *(unsigned int **)buf, v10);
        *uint64_t v4 = v13;
      }
      sub_1000570E8((const void **)buf);
    }
    else
    {
      uint32_t v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I No throttling key specified, assuming not enabled", buf, 2u);
      }
      *int v5 = 0;
    }
    return sub_100062778((const void **)&v15);
  }
  else
  {
    *int v5 = 0;
  }
  return result;
}

void sub_10105DD38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_1000570E8((const void **)va);
  sub_100062778((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_10105DD80(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = v1[2];
  uint64_t v3 = *(Registry ***)(*(void *)v1 + 368);
  CFBooleanRef v8 = 0;
  sub_10104B9E0(&v7, v3, v2, @"IgnoreInvalidLengthPage", kCFBooleanFalse);
  sub_1000057AC(&v8, &v7);
  sub_1000577C4(&v7);
  LOBYTE(v7) = 0;
  ctu::cf::assign((ctu::cf *)&v7, v8, v4);
  uint64_t v5 = v7;
  sub_100062778((const void **)&v8);
  return v5;
}

void sub_10105DE08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_10105DE2C(void *a1)
{
  *a1 = off_101A82C48;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10105DE78(void *a1)
{
  *a1 = off_101A82C48;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10105DEE4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A82C48;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10105DF48(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A82C48;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10105DF88(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10105DF98(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10105DFD8(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v1);
  operator new();
}

uint64_t sub_10105E0CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10105E10C()
{
}

uint64_t *sub_10105E118(void **a1)
{
  uint64_t v1 = *a1;
  CFDictionaryRef v14 = a1;
  CFBooleanRef v15 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = (void *)v1[2];
    CFBooleanRef v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*v1)
      {
        uint64_t v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = v3[28] - v3[27];
          unint64_t v8 = 0x8E38E38E38E38E39 * (v7 >> 4);
          if (v7 == 144) {
            uint64_t v9 = "";
          }
          else {
            uint64_t v9 = "s";
          }
          *(_DWORD *)std::string buf = 134218242;
          unint64_t v17 = v8;
          __int16 v18 = 2080;
          int v19 = v9;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Submitting %lu metric%s now.", buf, 0x16u);
        }
        uint64_t v10 = v3[27];
        uint64_t v11 = v3[28];
        if (v10 != v11)
        {
          do
          {
            sub_101055F08((uint64_t)v3, v10);
            v10 += 144;
          }
          while (v10 != v11);
          uint64_t v12 = v3[27];
          uint64_t v10 = v3[28];
          if (v10 != v12)
          {
            do
            {
              v10 -= 144;
              sub_101057B08(v10);
            }
            while (v10 != v12);
            uint64_t v10 = v12;
          }
        }
        v3[28] = v10;
      }
      sub_10004D2C8(v5);
    }
  }
  sub_10105E2AC((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10105E288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10105E2AC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10105E2AC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void BBDataDriver::create()
{
}

void sub_10105E3F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBDataDriver::BBDataDriver(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, dispatch_object_t *a5, void *a6)
{
  *(void *)(a1 + 24) = off_101A84620;
  *(void *)a1 = off_101A84778;
  PersonalitySpecificImpl::PersonalitySpecificImpl();
  *(void *)(a1 + 24) = off_101A83B90;
  *(void *)a1 = off_101A83FA0;
  sub_100B77D00((uint64_t *)(a1 + 32), (uint64_t *)off_101A838F8, a2, a3);
  *(void *)a1 = off_101A82D70;
  *(void *)(a1 + 24) = off_101A83280;
  *(void *)(a1 + 32) = off_101A837A0;
  uint64_t v11 = sub_10105E894((PersonalitySpecificImpl *)a1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, v11);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v12 = *a5;
  *(void *)(a1 + 80) = *a5;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 88) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v22, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 96), (const ctu::OsLogLogger *)v22);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v22);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  *(void *)a1 = off_101A82D70;
  *(void *)(a1 + 24) = off_101A83280;
  *(void *)(a1 + 32) = off_101A837A0;
  *(void *)(a1 + 104) = *a6;
  uint64_t v13 = a6[1];
  *(void *)(a1 + 112) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  CFDictionaryRef v14 = (char *)sub_10105E894((PersonalitySpecificImpl *)a1);
  sub_100058DB0(&__p, v14);
  __int16 v18 = *a5;
  if (*a5) {
    dispatch_retain(*a5);
  }
  CFBooleanRef v15 = *(NSObject **)(a1 + 88);
  xpc_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v18) {
    dispatch_release(v18);
  }
  if (v20 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = a1 + 184;
  *(void *)(a1 + 192) = a1 + 184;
  *(void *)(a1 + 200) = 0;
  *(_WORD *)(a1 + 208) = 0;
  *(void *)(a1 + 212) = 0;
  *(void *)(a1 + 217) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 228) = -1;
  *(void *)(a1 + 236) = -1;
  *(_DWORD *)(a1 + 288) = 0;
  *(_WORD *)(a1 + 292) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(void *)(a1 + 277) = 0;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_WORD *)(a1 + 377) = 1;
  *(unsigned char *)(a1 + 379) = 1;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 384) = a1 + 392;
  *(_DWORD *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 412) = 1;
  *(_DWORD *)(a1 + 416) = 0;
  DataBBResetThrottling::DataBBResetThrottling((DataBBResetThrottling *)(a1 + 424));
  *(_DWORD *)(a1 + 440) = 0;
  *(unsigned char *)(a1 + 444) = 0;
  return a1;
}

void sub_10105E738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  sub_1000346F8(v29, *(void **)(v21 + 392));
  uint32_t v30 = *(std::__shared_weak_count **)(v21 + 360);
  if (v30) {
    sub_10004D2C8(v30);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v21 + 336);
  if (v31) {
    sub_10004D2C8(v31);
  }
  CFTypeID v32 = *(std::__shared_weak_count **)(v21 + 320);
  if (v32) {
    sub_10004D2C8(v32);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(v21 + 304);
  if (v33) {
    sub_10004D2C8(v33);
  }
  CFBooleanRef v34 = *v26;
  if (*v26)
  {
    *(void *)(v21 + 256) = v34;
    operator delete(v34);
  }
  sub_100160A84(v28);
  uint64_t v35 = *(void *)(v21 + 176);
  *(void *)(v21 + 176) = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  sub_10105E8EC(v27);
  CFStringRef v36 = *(std::__shared_weak_count **)(v21 + 152);
  if (v36) {
    sub_10004D2C8(v36);
  }
  sub_10005CBF0((void ***)&a19);
  CFDictionaryRef v37 = *(std::__shared_weak_count **)(v21 + 112);
  if (v37) {
    sub_10004D2C8(v37);
  }
  ctu::OsLogLogger::~OsLogLogger(v25);
  sub_100087E88(v24);
  sub_100B77DF4(v23, (uint64_t *)(v22 + 40));
  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)v21);
  PersonalitySpecific::~PersonalitySpecific((PersonalitySpecific *)v21);
  _Unwind_Resume(a1);
}

const char *sub_10105E894(PersonalitySpecificImpl *a1)
{
  if (PersonalitySpecificImpl::simSlot(a1) == 1) {
    return "DATA.BBDriver.1";
  }
  if (PersonalitySpecificImpl::simSlot(a1) == 2) {
    return "DATA.BBDriver.2";
  }
  return "DATA.BBDriver.X";
}

uint64_t *sub_10105E8EC(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *a1;
  *a1 = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_10105E970(uint64_t a1)
{
  *(void *)a1 = off_101A82D70;
  *(void *)(a1 + 24) = off_101A83280;
  uint64_t v2 = (uint64_t *)(a1 + 32);
  *(void *)(a1 + 32) = off_101A837A0;
  DataBBResetThrottling::~DataBBResetThrottling((DataBBResetThrottling *)(a1 + 424));
  sub_1000346F8(a1 + 384, *(void **)(a1 + 392));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 360);
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFBooleanRef v4 = *(std::__shared_weak_count **)(a1 + 336);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 320);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 304);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(void **)(a1 + 248);
  if (v7)
  {
    *(void *)(a1 + 256) = v7;
    operator delete(v7);
  }
  sub_100160A84((atomic_uint **)(a1 + 184));
  uint64_t v8 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 152);
  if (v11) {
    sub_10004D2C8(v11);
  }
  CFDictionaryRef v14 = (void **)(a1 + 120);
  sub_10005CBF0(&v14);
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 112);
  if (v12) {
    sub_10004D2C8(v12);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 96));
  sub_100087E88((void *)(a1 + 64));
  sub_100B77DF4(v2, (uint64_t *)off_101A838F8);
  PersonalitySpecificImpl::~PersonalitySpecificImpl((PersonalitySpecificImpl *)a1);

  PersonalitySpecific::~PersonalitySpecific(v13);
}

void sub_10105EB54(uint64_t a1)
{
}

void sub_10105EB5C(uint64_t a1)
{
}

void sub_10105EB64(uint64_t a1)
{
  sub_10105E970(a1);

  operator delete();
}

void sub_10105EB9C(uint64_t a1)
{
  sub_10105E970(a1 - 24);

  operator delete();
}

void sub_10105EBD8(uint64_t a1)
{
  sub_10105E970(a1 - 32);

  operator delete();
}

void sub_10105EC14(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (!v2 || (v3 = a1[13], uint64_t v4 = a1[8], (v5 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v5);
  uint64_t v7 = std::__shared_weak_count::lock(v6);
  uint64_t v8 = v7;
  if (v7)
  {
    if (v4) {
      uint64_t v9 = v4 + 24;
    }
    else {
      uint64_t v9 = 0;
    }
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v6);
    sub_10004D2C8(v8);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v9 = 0;
  }
  uint64_t v11 = v9;
  uint64_t v12 = v8;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 56))(v3, &v11);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  sub_10019E028(a1 + 15);
  uint64_t v10 = a1[12];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    CFDictionaryRef v14 = "initBBDriver";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: created", buf, 0xCu);
  }
}

void sub_10105ED84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10105ED9C(uint64_t a1)
{
}

void sub_10105EDA4(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(a1 + 40));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(&v11, "/cc/props/reg_network_scan");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A84998;
  v2[1] = a1 + 384;
  void v2[2] = a1;
  v2[3] = sub_10105F440;
  v2[4] = 0;
  *((void *)&v10 + 1) = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v12 < 0) {
    operator delete(v11);
  }
  sub_100058DB0(&v11, "/cc/props/radio_mode");
  uint64_t v3 = operator new(0x28uLL);
  *uint64_t v3 = off_101A84A18;
  v3[1] = a1 + 408;
  void v3[2] = a1;
  v3[3] = sub_10105FBC0;
  v3[4] = 0;
  *((void *)&v10 + 1) = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v12 < 0) {
    operator delete(v11);
  }
  sub_100058DB0(&v11, "/cc/props/current_calls");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A84A98;
  v4[1] = a1 + 416;
  void v4[2] = a1;
  v4[3] = sub_101060404;
  void v4[4] = 0;
  *((void *)&v10 + 1) = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v12 < 0) {
    operator delete(v11);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5))
    {
      uint64_t v6 = *(NSObject **)(a1 + 80);
      dispatch_retain(v6);
      *(_OWORD *)std::string buf = 0u;
      long long v10 = 0u;
      dispatch_retain(v6);
      dispatch_retain(v6);
      dispatch_retain(v6);
      uint64_t v11 = 0;
      dispatch_retain(v6);
      dispatch_retain(v6);
      dispatch_retain(v6);
      dispatch_retain(v6);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10105F2CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16)
{
  if (a2)
  {
    sub_100163BC8(v18 - 88);
    if (a14) {
      (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
    }
    std::__shared_weak_count::__release_weak(v17);
    sub_10097F2DC((uint64_t)&a15);
    dispatch_release(v16);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10105F440(PersonalitySpecificImpl *this)
{
  uint64_t v2 = (PersonalitySpecificImpl *)*((void *)this + 48);
  if (v2 == (PersonalitySpecificImpl *)((char *)this + 392))
  {
    int v3 = 0;
  }
  else
  {
    LOBYTE(v3) = 0;
    do
    {
      int v3 = (*((unsigned __int8 *)v2 + 32) | v3 & 1) != 0;
      uint64_t v4 = (PersonalitySpecificImpl *)*((void *)v2 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = *(PersonalitySpecificImpl **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (PersonalitySpecificImpl *)*((void *)v2 + 2);
          BOOL v6 = *(void *)v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != (PersonalitySpecificImpl *)((char *)this + 392));
  }
  int v7 = *((unsigned __int8 *)this + 293);
  if (v7 != v3)
  {
    uint64_t v8 = *((void *)this + 12);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = "active";
      *(void *)&uint8_t buf[4] = "handleNetworkScan_sync";
      if (v7) {
        long long v10 = "active";
      }
      else {
        long long v10 = "inactive";
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&buf[14] = v10;
      *(_WORD *)&unsigned char buf[12] = 2080;
      if (!v3) {
        uint64_t v9 = "inactive";
      }
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v54 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: fNetworkScan %s->%s", buf, 0x20u);
    }
    *((unsigned char *)this + 293) = v3;
    if (v3)
    {
      *((_DWORD *)this + 93) = 0;
      uint64_t v11 = (uint64_t *)*((void *)this + 15);
      for (uint64_t i = (uint64_t *)*((void *)this + 16); v11 != i; v11 += 2)
      {
        uint64_t v14 = *v11;
        uint64_t v13 = (std::__shared_weak_count *)v11[1];
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v14)
        {
          int v15 = (*(unsigned int (**)(uint64_t, void))(*(void *)v14 + 928))(v14, 0)
             && (*(unsigned int (**)(uint64_t, void, uint64_t))(*(void *)v14 + 96))(v14, 0, 32)
              ? (*(uint64_t (**)(uint64_t, void))(*(void *)v14 + 88))(v14, 0) ^ 1
              : 0;
          if ((v15 | (*(unsigned int (**)(uint64_t, void, uint64_t, const char *, const char *))(*(void *)v14 + 728))(v14, 0, 32, "unknown", "CommCenter")) == 1)
          {
            long long __p = 0;
            uint64_t v44 = 0;
            uint64_t v45 = 0;
            sub_100058DB0(buf, "");
            int v52 = 1;
            char v51 = 0;
            uint64_t v50 = 0;
            int v49 = 0;
            char v48 = 0;
            sub_100DA199C(&v52, (uint64_t)&__p, (long long *)buf, &v51, &v50, &v49, &v48, &v46);
            (*(void (**)(uint64_t, void, uint64_t *))(*(void *)v14 + 440))(v14, 0, &v46);
            if (v47) {
              sub_10004D2C8(v47);
            }
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            if (__p)
            {
              uint64_t v44 = __p;
              operator delete(__p);
            }
          }
        }
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      uint64_t v16 = *((void *)this + 7);
      uint64_t v17 = PersonalitySpecificImpl::simSlot(this);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v16 + 352))(v16, v17, *((unsigned int *)this + 93));
    }
    else
    {
      uint64_t v18 = (uint64_t *)*((void *)this + 15);
      for (uint64_t j = (uint64_t *)*((void *)this + 16); v18 != j; v18 += 2)
      {
        uint64_t v20 = *v18;
        uint64_t v21 = (std::__shared_weak_count *)v18[1];
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v20) {
          (*(void (**)(uint64_t, void, const char *, void, void))(*(void *)v20 + 424))(v20, 0, "network scan complete", 0, 0);
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
      }
      *((_DWORD *)this + 93) = 0;
      uint64_t v22 = *((void *)this + 7);
      uint64_t v23 = PersonalitySpecificImpl::simSlot(this);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v22 + 352))(v22, v23, *((unsigned int *)this + 93));
    }
    uint64_t v24 = *((void *)this + 7);
    if (v24)
    {
      uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 264))(v24);
      CFStringRef v26 = *(void **)v25;
      uint64_t v27 = *(void **)(v25 + 8);
      if (*(void **)v25 != v27)
      {
        do
        {
          (*(void (**)(void, const char *))(*(void *)*v26 + 224))(*v26, "BBDataDriver::handleNetworkScan_sync");
          v26 += 2;
        }
        while (v26 != v27);
      }
      uint64_t v28 = *((void *)this + 7);
      if (v28)
      {
        uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 264))(v28);
        uint32_t v30 = *(uint64_t **)v29;
        uint64_t v31 = *(uint64_t **)(v29 + 8);
        while (v30 != v31)
        {
          uint64_t v32 = *v30;
          (*(void (**)(uint8_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)this + 16))(buf, this);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v32 + 232))(v32, buf);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          v30 += 2;
        }
        uint64_t v33 = *((void *)this + 7);
        if (v33)
        {
          CFBooleanRef v34 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v33 + 264))(v33);
          uint64_t v35 = *v34;
          uint64_t v36 = v34[1];
          while (v35 != v36)
          {
            (*(void (**)(void))(**(void **)v35 + 240))();
            v35 += 16;
          }
        }
      }
    }
  }
  if ((v3 & 1) == 0)
  {
    memset(buf, 0, sizeof(buf));
    sub_100058DB0(buf, "BBDataDriver::handleNetworkScan_sync");
    uint64_t v37 = *((void *)this + 7);
    uint64_t v38 = PersonalitySpecificImpl::simSlot(this);
    CFTypeID v39 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
    (*(void (**)(uint64_t, uint64_t, void, uint8_t *, uint64_t))(*(void *)v37 + 216))(v37, v38, 0, v39, 2);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v40 = *((void *)this + 7);
  uint64_t v41 = PersonalitySpecificImpl::simSlot(this);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v40 + 224))(v40, v41, 24, v3 ^ 1u);
}

void sub_10105FB20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10105FBC0(uint64_t a1, unint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 408);
  char v5 = *(unsigned char *)(a1 + 412);
  int v6 = *(unsigned __int8 *)(a1 + 413);
  if (!operator!=()) {
    return;
  }
  int v7 = *(NSObject **)(a1 + 96);
  uint64_t v8 = (a2 >> 40) & 1;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = v5 & 1;
    *(_DWORD *)std::string buf = 136316674;
    *(void *)&uint8_t buf[4] = "handleRadioModeChange_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asString();
    __int16 v51 = 2080;
    uint64_t v52 = asString();
    __int16 v53 = 2080;
    uint64_t v54 = asStringBool(a2 & 0x100000000);
    uint64_t v8 = (a2 >> 40) & 1;
    __int16 v55 = 2080;
    uint64_t v56 = asStringBool(v5 & 1);
    __int16 v57 = 2080;
    uint64_t v58 = asStringBool(v8);
    __int16 v59 = 2080;
    uint64_t v60 = asStringBool(v6 & 1);
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: radio status %s => %s, reset %s => %s, cmas camp only %s => %s", buf, 0x48u);
    if (!v4)
    {
LABEL_24:
      if (!*(unsigned char *)(a1 + 208))
      {
        uint64_t v17 = *(NSObject **)(a1 + 96);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = asStringBool(v9);
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "handleRadioOff_sync";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: handleRadioOff_sync: reset=%s", buf, 0x16u);
          uint64_t v17 = *(NSObject **)(a1 + 96);
        }
        *(unsigned char *)(a1 + 283) = 0;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = "handleRadioOff_sync";
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: fPoweredOnStatus is false", buf, 0xCu);
        }
      }
      goto LABEL_47;
    }
  }
  else
  {
    BOOL v9 = v5 & 1;
    if (!v4) {
      goto LABEL_24;
    }
  }
  if (v9) {
    goto LABEL_24;
  }
  if (v4 == 2)
  {
    *(unsigned char *)(a1 + 283) = 1;
    long long v10 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "handleRadioModeChange_sync";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: fPoweredOnStatus is true", buf, 0xCu);
    }
    if (!*(unsigned char *)(a1 + 379)) {
      goto LABEL_46;
    }
    *(unsigned char *)(a1 + 379) = 0;
    uint64_t v11 = *(void *)(a1 + 56);
    if (v11)
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 264))(v11);
      uint64_t v13 = *(void **)v12;
      uint64_t v14 = *(void **)(v12 + 8);
      while (v13 != v14)
      {
        if ((*(unsigned int (**)(void, uint64_t))(*(void *)*v13 + 152))(*v13, 1))
        {
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          (*(void (**)(unsigned char *__return_ptr))(*(void *)*v13 + 576))(buf);
          if (*(void *)buf
            && (int v15 = *(_DWORD *)(*(void *)buf + 52),
                v15 == PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1)))
          {
            int v16 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v13 + 312))(*v13, 1);
          }
          else
          {
            int v16 = 3;
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (v16 != 3 && v16)
          {
            CFStringRef v47 = *(NSObject **)(a1 + 96);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = "handleRadioModeChange_sync";
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I %s: Not resetting WiFiCalling AttachAPN back to default: Wi-Fi IMS active", buf, 0xCu);
            }
            goto LABEL_46;
          }
        }
        v13 += 2;
      }
    }
    int v19 = *(std::__shared_weak_count **)(a1 + 72);
    if (!v19 || (uint64_t v20 = std::__shared_weak_count::lock(v19)) == 0) {
      sub_100088B9C();
    }
    uint64_t v21 = v20;
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v20);
    uint64_t v22 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "handleRadioModeChange_sync";
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s: Resetting WiFiCalling AttachAPN back to default", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(a1 + 40));
    uint64_t v25 = ServiceMap;
    if (v26 < 0)
    {
      uint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        uint64_t v26 = v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v26;
    uint32_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
    if (v30)
    {
      uint64_t v32 = v30[3];
      uint64_t v31 = (std::__shared_weak_count *)v30[4];
      if (v31)
      {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v25);
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v31);
        char v48 = 0;
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    std::mutex::unlock(v25);
    uint64_t v31 = 0;
    char v48 = 1;
LABEL_41:
    int v33 = v8;
    uint64_t v34 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v35 = *(std::__shared_weak_count **)(a1 + 72);
    if (!v35 || (v8 = *(void *)(a1 + 64), (uint64_t v36 = std::__shared_weak_count::lock(v35)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v37 = v36;
    atomic_fetch_add_explicit(&v36->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v36);
    uint64_t v38 = operator new(0x20uLL);
    void *v38 = off_101A84DC8;
    v38[1] = a1;
    _OWORD v38[2] = v8;
    v38[3] = v37;
    v49[3] = v38;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v32 + 64))(v32, v34, 6, v49);
    sub_10003B34C(v49);
    LODWORD(v8) = v33;
    if ((v48 & 1) == 0) {
      sub_10004D2C8(v31);
    }
    std::__shared_weak_count::__release_weak(v21);
LABEL_46:
    (*(void (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "Radio On");
  }
LABEL_47:
  if (v8 != (v6 & 1))
  {
    CFTypeID v39 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = asStringBool((a2 & 0x10000000000) != 0);
      uint64_t v41 = asStringBool((v6 & 1) != 0);
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "handleRadioModeChange_sync";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v40;
      __int16 v51 = 2080;
      uint64_t v52 = v41;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s: new cmas camp mode state: %s ==>> %s ", buf, 0x20u);
    }
    uint64_t v42 = *(void *)(a1 + 56);
    if (v42)
    {
      uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 264))(v42);
      uint64_t v44 = *(uint64_t **)v43;
      uint64_t v45 = *(uint64_t **)(v43 + 8);
      if (*(uint64_t **)v43 != v45)
      {
        do
        {
          uint64_t v46 = *v44;
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)a1 + 16))(buf, a1);
          (*(void (**)(uint64_t, const char *, BOOL, unsigned char *))(*(void *)v46 + 560))(v46, "CMAS", v6 == 0, buf);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          v44 += 2;
        }
        while (v44 != v45);
      }
    }
  }
}

void sub_101060388(_Unwind_Exception *a1, uint64_t a2, char a3, ...)
{
  va_start(va, a3);
  sub_10003B34C(va);
  if ((a3 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  std::__shared_weak_count::__release_weak(v3);
  _Unwind_Resume(a1);
}

uint64_t sub_101060404(uint64_t a1, __int16 a2)
{
  int v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v12 = "handleAnyCallInfo_sync";
    __int16 v13 = 2080;
    uint64_t v14 = asStringBool(a2 != 0);
    __int16 v15 = 2080;
    uint64_t v16 = asStringBool((a2 & 0xFF00) != 0);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: %s : %s", buf, 0x20u);
  }
  uint64_t result = AnyCallInfo::operator!=();
  if (result)
  {
    int v6 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 418));
      uint64_t v8 = asStringBool(*(unsigned char *)(a1 + 416));
      uint64_t v9 = asStringBool(*(unsigned char *)(a1 + 419));
      uint64_t v10 = asStringBool(*(unsigned char *)(a1 + 417));
      *(_DWORD *)std::string buf = 136316162;
      uint64_t v12 = "handleAnyCallInfo_sync";
      __int16 v13 = 2080;
      uint64_t v14 = v7;
      __int16 v15 = 2080;
      uint64_t v16 = v8;
      __int16 v17 = 2080;
      uint64_t v18 = v9;
      __int16 v19 = 2080;
      uint64_t v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: fIsBBCallActive: %s ==>> %s; fIsEmCallActive: %s ==>> %s",
        buf,
        0x34u);
    }
    *(_WORD *)(a1 + 418) = *(_WORD *)(a1 + 416);
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 632))(a1);
  }
  return result;
}

uint64_t sub_1010605D8(uint64_t a1, int a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 284);
  if (v4 != a2)
  {
    char v5 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 136315650;
      *(void *)uint64_t v21 = "handleECBMChange_sync";
      *(_WORD *)&v21[8] = 2080;
      *(void *)&v21[10] = asStringBool(v4 != 0);
      __int16 v22 = 2080;
      uint64_t v23 = asStringBool(a2);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: from %s to %s", (uint8_t *)&v20, 0x20u);
    }
    *(unsigned char *)(a1 + 284) = a2;
  }
  if (a2)
  {
    sub_101060C24((uint64_t *)(a1 + 160));
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 264))(v6);
      uint64_t v8 = *(uint64_t **)v7;
      uint64_t v9 = *(uint64_t **)(v7 + 8);
      if (*(uint64_t **)v7 != v9)
      {
        do
        {
          uint64_t v10 = *v8;
          (*(void (**)(int *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v20, a1);
          (*(void (**)(uint64_t, void, int *, uint64_t, const char *))(*(void *)v10 + 248))(v10, 0, &v20, 26, "CommCenter");
          if (*(void *)&v21[4]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v21[4]);
          }
          v8 += 2;
        }
        while (v8 != v9);
      }
    }
    uint64_t v11 = *(uint64_t **)(a1 + 120);
    for (uint64_t i = *(uint64_t **)(a1 + 128); v11 != i; v11 += 2)
    {
      uint64_t v13 = *v11;
      uint64_t v14 = (std::__shared_weak_count *)v11[1];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v13) {
        (*(void (**)(uint64_t, void, uint64_t, const char *, const char *))(*(void *)v13 + 728))(v13, 0, 26, "ECBM change", "CommCenter");
      }
      if (v14) {
        sub_10004D2C8(v14);
      }
    }
  }
  uint64_t v15 = *(void *)(a1 + 56);
  if (v15)
  {
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 264))(v15);
    __int16 v17 = *(void **)v16;
    uint64_t v18 = *(void **)(v16 + 8);
    if (*(void **)v16 != v18)
    {
      do
      {
        (*(void (**)(void, const char *))(*(void *)*v17 + 224))(*v17, "BBDataDriver::handleECBMChange_sync");
        v17 += 2;
      }
      while (v17 != v18);
    }
  }
  return (*(uint64_t (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "ECBM change");
}

void sub_1010608EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106091C(uint64_t a1)
{
}

void sub_101060924(uint64_t a1)
{
  pthread_mutex_lock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
  uint64_t v2 = xmmword_101B0AA30;
  if (!(void)xmmword_101B0AA30) {
    sub_1008415C0();
  }
  int v3 = (std::__shared_weak_count *)*((void *)&xmmword_101B0AA30 + 1);
  if (*((void *)&xmmword_101B0AA30 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0AA30 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
  if (sub_100501F90(v2))
  {
    pthread_mutex_lock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
    uint64_t v4 = xmmword_101B0AA30;
    if (!(void)xmmword_101B0AA30) {
      sub_1008415C0();
    }
    char v5 = (std::__shared_weak_count *)*((void *)&xmmword_101B0AA30 + 1);
    if (*((void *)&xmmword_101B0AA30 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0AA30 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
    *(unsigned char *)(a1 + 209) = !sub_1005020BC(v4);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 209) = 0;
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  *(_WORD *)(a1 + 418) = *(_WORD *)(a1 + 416);
  uint64_t v6 = *(void *)(a1 + 56);
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 264))(v6);
    uint64_t v8 = *(void **)v7;
    uint64_t v9 = *(void **)(v7 + 8);
    while (v8 != v9)
    {
      (*(void (**)(void, void))(*(void *)*v8 + 24))(*v8, 0);
      v8 += 2;
    }
  }
  uint64_t v10 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136315138;
    uint64_t v12 = "startBBDriver";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: started", (uint8_t *)&v11, 0xCu);
  }
}

void sub_101060B58(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

void sub_101060BBC(uint64_t a1)
{
}

uint64_t sub_101060BC4(uint64_t a1)
{
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 144));
  uint64_t result = sub_101060C24((uint64_t *)(a1 + 160));
  for (uint64_t i = *(void *)(a1 + 192); i != a1 + 184; uint64_t i = *(void *)(i + 8))
    uint64_t result = (uint64_t)sub_10016111C((uint64_t *)(i + 16));
  *(unsigned char *)(a1 + 208) = 1;
  return result;
}

uint64_t sub_101060C24(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = a1[1];
  a1[1] = 0;
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

uint64_t sub_101060CBC(void *a1)
{
  return sub_101060BC4((uint64_t)a1 + *(void *)(*a1 - 120));
}

uint64_t sub_101060CD8(uint64_t a1, int a2)
{
  if (a2 && (uint64_t v2 = *(void *)(a1 + 56)) != 0)
  {
    uint64_t v3 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 488);
    return v4(v2, v3);
  }
  else
  {
    return *(unsigned char *)(a1 + 418) || *(unsigned char *)(a1 + 209) != 0;
  }
}

uint64_t sub_101060D6C(uint64_t a1, int a2)
{
  return sub_101060CD8(a1 - 24, a2);
}

uint64_t sub_101060D74(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 80))();
}

uint64_t sub_101060D9C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 80))();
}

uint64_t sub_101060DC4(PersonalitySpecificImpl *a1, long long *a2)
{
  unsigned int v19 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v16, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v16 = *a2;
    uint64_t v17 = *((void *)a2 + 2);
  }
  uint64_t v18 = a1;
  uint64_t v3 = *((void *)a1 + 7);
  if (v3)
  {
    uint64_t v4 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    int v20 = &v19;
    if (SHIBYTE(v17) < 0)
    {
      sub_10004FC84(&__s1, (void *)v16, *((unint64_t *)&v16 + 1));
    }
    else
    {
      long long __s1 = v16;
      uint64_t v22 = v17;
    }
    uint64_t v23 = v18;
    if (v5 != v6)
    {
      while (1)
      {
        uint64_t v7 = v23;
        uint64_t v28 = 0;
        unsigned int v29 = 0;
        (*(void (**)(uint64_t *__return_ptr))(**(void **)v5 + 488))(&v28);
        if (v28)
        {
          int v8 = (*(uint64_t (**)(uint64_t))(*(void *)(v28 + *(void *)(*(void *)v28 - 56)) + 24))(v28 + *(void *)(*(void *)v28 - 56));
          if (v8 == PersonalitySpecificImpl::simSlot(v7)) {
            break;
          }
        }
LABEL_30:
        if (v29) {
          sub_10004D2C8(v29);
        }
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_33;
        }
      }
      long long __p = 0;
      long long v25 = 0uLL;
      (*(void (**)(void **__return_ptr))(*(void *)v28 + 240))(&__p);
      uint64_t v9 = HIBYTE(v22);
      if (v22 >= 0) {
        uint64_t v10 = HIBYTE(v22);
      }
      else {
        uint64_t v10 = *((void *)&__s1 + 1);
      }
      uint64_t v11 = HIBYTE(v25);
      char v12 = HIBYTE(v25);
      if (v25 < 0) {
        uint64_t v11 = v25;
      }
      if (v10 == v11)
      {
        if (v25 >= 0) {
          p_p = (unsigned __int8 *)&__p;
        }
        else {
          p_p = (unsigned __int8 *)__p;
        }
        if (v22 < 0)
        {
          if (memcmp((const void *)__s1, p_p, *((size_t *)&__s1 + 1))) {
            goto LABEL_28;
          }
        }
        else if (HIBYTE(v22))
        {
          p_s1 = &__s1;
          while (*(unsigned __int8 *)p_s1 == *p_p)
          {
            p_s1 = (long long *)((char *)p_s1 + 1);
            ++p_p;
            if (!--v9) {
              goto LABEL_27;
            }
          }
          goto LABEL_28;
        }
LABEL_27:
        ++*v20;
        char v12 = HIBYTE(v25);
      }
LABEL_28:
      if (v12 < 0) {
        operator delete(__p);
      }
      goto LABEL_30;
    }
LABEL_33:
    long long __p = v20;
    if (SHIBYTE(v22) < 0)
    {
      sub_10004FC84(&v25, (void *)__s1, *((unint64_t *)&__s1 + 1));
    }
    else
    {
      long long v25 = __s1;
      uint64_t v26 = v22;
    }
    uint64_t v27 = v23;
    if (SHIBYTE(v26) < 0) {
      operator delete((void *)v25);
    }
    if (SHIBYTE(v22) < 0) {
      operator delete((void *)__s1);
    }
  }
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
  return v19;
}

void sub_1010610B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101061100(uint64_t a1, long long *a2)
{
  return sub_101060DC4((PersonalitySpecificImpl *)(a1 - 24), a2);
}

uint64_t sub_101061108(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = *((void *)a1 + 7);
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 416);

  return v3(v1, v2);
}

uint64_t sub_10106116C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 24));
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 416);

  return v3(v1, v2);
}

void sub_1010611D8(uint64_t a1, int a2)
{
  if (a2) {
    int v2 = 163;
  }
  else {
    int v2 = 164;
  }
  xpc_object_t v3 = xpc_null_create();
  xpc_object_t v6 = v3;
  xpc_object_t v4 = xpc_null_create();
  xpc_object_t v5 = v4;
  sub_1000452AC(v2, &v6, &v5);
  xpc_release(v4);
  xpc_release(v3);
}

void sub_101061250(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_101061280(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = a1[7];
  if (!v4)
  {
LABEL_19:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 248))(&v13);
  uint64_t v5 = v13;
  if (!v13) {
    goto LABEL_11;
  }
  lpsrc = 0;
  char v12 = 0;
  (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v9, a1);
  (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t *))(*(void *)v5 + 496))(&lpsrc, v5, 0, &v9);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (!lpsrc)
  {
    if (v12) {
      sub_10004D2C8(v12);
    }
LABEL_11:
    int v8 = 1;
    goto LABEL_16;
  }
  if (v6)
  {
    uint64_t v7 = v12;
    *a2 = v6;
    a2[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  int v8 = 0;
LABEL_16:
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v8) {
    goto LABEL_19;
  }
}

void sub_10106140C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_101061438(uint64_t a1@<X0>, void *a2@<X8>)
{
}

uint64_t sub_101061440@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (sub_1010614A0((Registry **)a1, a2)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 209)) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 418)) {
    return 0;
  }
  uint64_t result = sub_101061690((Registry **)a1);
  if (result) {
    return *(unsigned char *)(a1 + 419) == 0;
  }
  return result;
}

BOOL sub_1010614A0@<W0>(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1[5]);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    xpc_object_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v19);
  if (!v9)
  {
    std::mutex::unlock(v4);
    return 0;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v4);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    if (!v11)
    {
      BOOL v12 = 0;
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  std::mutex::unlock(v4);
  if (!v11) {
    return 0;
  }
LABEL_11:
  uint64_t v13 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  uint64_t v14 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v11 + 32))(v11, v13, kSimultaneousCallAndDataCurrentlySupported);
  BOOL v12 = (BOOL)v14;
  char v18 = 0;
  if (v14)
  {
    CFTypeID v15 = CFGetTypeID(v14);
    if (v15 != CFBooleanGetTypeID())
    {
      BOOL v12 = 0;
      if (!v10) {
        return v12;
      }
      goto LABEL_15;
    }
    ctu::cf::assign((ctu::cf *)&v18, (BOOL *)v12, v16);
    BOOL v12 = v18 != 0;
  }
  if (v10) {
LABEL_15:
  }
    sub_10004D2C8(v10);
  return v12;
}

void sub_101061618(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101061630(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 418)) {
    return 0;
  }
  uint64_t result = sub_101061690((Registry **)a1);
  if (result) {
    return *(unsigned char *)(a1 + 419) == 0;
  }
  return result;
}

uint64_t sub_101061674(void *a1)
{
  return sub_101061440((uint64_t)a1 + *(void *)(*a1 - 176), *(uint64_t **)(*a1 - 176));
}

uint64_t sub_101061690(Registry **a1)
{
  int v2 = a1 + 5;
  uint64_t v3 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if (suspendInternetOnBBCall(v2, v3)) {
    return 1;
  }
  unint64_t v5 = a1[15];
  xpc_object_t v6 = a1[16];
  if (v5 != v6)
  {
    while (1)
    {
      uint64_t v7 = *(void *)v5;
      unsigned int v8 = (std::__shared_weak_count *)*((void *)v5 + 1);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v7 && ((*(uint64_t (**)(uint64_t))(*(void *)v7 + 144))(v7) & 1) != 0) {
        break;
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      unint64_t v5 = (Registry *)((char *)v5 + 16);
      if (v5 == v6) {
        return 0;
      }
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
    return 1;
  }
  return 0;
}

void sub_101061750(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101061768(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 184);
  if (!v1[418]) {
    return 0;
  }
  uint64_t result = sub_101061690((Registry **)((char *)a1 + *(void *)(*a1 - 184)));
  if (result) {
    return v1[419] == 0;
  }
  return result;
}

BOOL sub_1010617C4(void **a1)
{
  return !(*(unsigned int (**)(void *))(*a1[13] + 144))(a1[13])
      || ((unsigned int (*)(void **))(*a1)[32])(a1) != 2;
}

BOOL sub_101061854(uint64_t a1)
{
  return sub_1010617C4((void **)(a1 - 24));
}

BOOL sub_10106185C(uint64_t a1, uint64_t a2)
{
  long long __p = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_1008DB9AC(&__p, *(const void **)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2));
  if (*(unsigned char *)(a1 + 281))
  {
    if (*(unsigned char *)(a1 + 280))
    {
LABEL_3:
      if (__p != v9)
      {
        uint64_t v3 = (char *)__p;
        while ((*v3 & 1) == 0)
        {
          v3 += 12;
          if (v3 == v9)
          {
            uint64_t v4 = (char *)__p;
            while ((v4[1] & 1) != 0)
            {
              v4 += 12;
              if (v4 == v9) {
                goto LABEL_17;
              }
            }
            goto LABEL_16;
          }
        }
LABEL_17:
        BOOL v6 = *(_DWORD *)(a1 + 228) > 0;
        if (!__p) {
          return v6;
        }
        goto LABEL_20;
      }
LABEL_16:
      if (*(_DWORD *)(a1 + 288)) {
        goto LABEL_17;
      }
    }
    else if (__p != v9)
    {
      unint64_t v5 = (char *)__p;
      while ((v5[1] & 1) != 0)
      {
        v5 += 12;
        if (v5 == v9) {
          goto LABEL_3;
        }
      }
    }
  }
  BOOL v6 = 0;
  if (__p)
  {
LABEL_20:
    uint64_t v9 = (char *)__p;
    operator delete(__p);
  }
  return v6;
}

BOOL sub_101061958(uint64_t a1, uint64_t a2)
{
  return sub_10106185C(a1 - 24, a2);
}

uint64_t sub_101061960(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 292);
  if (v3 != a2)
  {
    BOOL v4 = a2;
    unint64_t v5 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315650;
      unsigned int v8 = "setDormancy";
      __int16 v9 = 2080;
      uint64_t v10 = asStringBool(v3 != 0);
      __int16 v11 = 2080;
      uint64_t v12 = asStringBool(v4);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: from %s to %s", (uint8_t *)&v7, 0x20u);
    }
    *(unsigned char *)(a1 + 292) = v4;
  }
  return sub_101061A54((PersonalitySpecificImpl *)a1);
}

uint64_t sub_101061A54(PersonalitySpecificImpl *a1)
{
  if (*((unsigned char *)a1 + 208)) {
    return 0;
  }
  BOOL v3 = *((unsigned char *)a1 + 292) == 0;
  uint64_t v4 = *((void *)a1 + 13);
  uint64_t v5 = (*(uint64_t (**)(PersonalitySpecificImpl *))(*(void *)a1 + 256))(a1);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 136))(v4, v5);
  uint64_t v7 = *((void *)a1 + 7);
  uint64_t v8 = PersonalitySpecificImpl::simSlot(a1);
  __int16 v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)v7 + 56);

  return v9(v7, v8, v6, v3);
}

uint64_t sub_101061B50(uint64_t a1, int a2)
{
  return sub_101061960(a1 - 24, a2);
}

uint64_t sub_101061B58(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 282) || !*(unsigned char *)(a1 + 283)) {
    return 0;
  }
  sub_1010702C4((uint64_t)__p);
  if (sub_10106185C(a1, (uint64_t)__p) && (uint64_t v4 = *(void *)(a1 + 56)) != 0) {
    uint64_t v1 = (*(unsigned int (**)(uint64_t))(*(void *)v4 + 136))(v4) ^ 1;
  }
  else {
    uint64_t v1 = 0;
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v1;
}

void sub_101061BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101061C18(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 282);
}

uint64_t sub_101061C20(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 283);
}

uint64_t sub_101061C28(uint64_t a1)
{
  return sub_101061B58(a1 - 24);
}

uint64_t sub_101061C30(uint64_t a1)
{
  uint64_t result = sub_101061B58(a1);
  if (result)
  {
    return sub_101061C78(a1);
  }
  return result;
}

uint64_t sub_101061C78(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 272))(a1 + 32);
  if (!(*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)v3 + 240))(v3, v4, *(unsigned int *)(v2 + 196)))return 1; {
  int v5 = *(_DWORD *)(a1 + 228);
  }
  int v6 = *(_DWORD *)(a1 + 216);
  unsigned int v7 = v5 - 3;
  if ((v5 - 1) >= 2) {
    int v8 = 0;
  }
  else {
    int v8 = 2;
  }
  BOOL v9 = v7 < 3 || (v5 - 1) < 2;
  if (v7 >= 3) {
    int v10 = v8;
  }
  else {
    int v10 = 3;
  }
  if ((v6 - 1) > 4) {
    int v11 = 0;
  }
  else {
    int v11 = dword_1015B5480[v6 - 1];
  }
  if (v10 != v11) {
    BOOL v9 = 0;
  }
  if (!*(unsigned char *)(a1 + 224)) {
    return 0;
  }
  if (v5 == v6 || v5 == 16 && v6 == 14) {
    return 1;
  }
  return v5 == 14 && v6 == 16 || v9;
}

uint64_t sub_101061DA8(uint64_t a1)
{
  uint64_t v1 = a1 - 24;
  uint64_t result = sub_101061B58(a1 - 24);
  if (result)
  {
    return sub_101061C78(v1);
  }
  return result;
}

uint64_t sub_101061DF4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 258);
}

uint64_t sub_101061DFC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 259);
}

uint64_t sub_101061E04(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 413);
}

uint64_t sub_101061E0C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 389);
}

uint64_t sub_101061E14(uint64_t a1)
{
  uint64_t result = sub_101061B58(a1);
  if (result)
  {
    unsigned int v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 256))(a1);
    uint64_t result = 0;
    if (v3 <= 6)
    {
      int v4 = 1 << v3;
      if ((v4 & 0x72) != 0)
      {
        return 3;
      }
      else if ((v4 & 0xC) != 0)
      {
        if (capabilities::ct::supportsCapabilityeHRPDDevice(0)) {
          return 3;
        }
        else {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_101061EB0(uint64_t a1)
{
  return sub_101061E14(a1 - 24);
}

void sub_101061EB8(unint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1010702C4((uint64_t)__p);
  BOOL v6 = sub_10106185C(a1, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  int v7 = *(_DWORD *)(a1 + 228);
  int v8 = *(_DWORD *)(a1 + 232);
  if (v8 == a3 && v7 == a2) {
    goto LABEL_69;
  }
  int v10 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asString();
    uint64_t v13 = asString();
    uint64_t v14 = asString();
    uint64_t v15 = asString();
    *(_DWORD *)std::string buf = 136316162;
    *(void *)&uint8_t buf[4] = "handleDataModeChanged_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v12;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v62 = v13;
    __int16 v63 = 2080;
    uint64_t v64 = v14;
    __int16 v65 = 2080;
    uint64_t v66 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: fDataMode %s->%s fDataModeActual %s->%s", buf, 0x34u);
  }
  *(_DWORD *)(a1 + 232) = a3;
  if (v8 != a3)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 40));
    char v18 = ServiceMap;
    if (v19 < 0)
    {
      int v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v19;
    uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
    if (v23)
    {
      uint64_t v25 = v23[3];
      uint64_t v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        if (!v25)
        {
LABEL_22:
          if ((v26 & 1) == 0) {
            sub_10004D2C8(v24);
          }
          if (v7 == a2)
          {
            sub_101062710(a1, 4);
LABEL_38:
            int v16 = *(_DWORD *)(a1 + 232);
            goto LABEL_39;
          }
LABEL_26:
          uint64_t v28 = *(NSObject **)(a1 + 96);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = "handleDataModeChanged_sync";
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn", buf, 0xCu);
          }
          if (a2 != -2 && a2 != 18) {
            *(_DWORD *)(a1 + 212) = DataUtils::toCellularDataTechnology();
          }
          if (*(_DWORD *)(a1 + 228) != a2)
          {
            *(_DWORD *)(a1 + 228) = a2;
            uint64_t v29 = *(void *)(a1 + 56);
            uint64_t v30 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v29 + 408))(v29, v30, a2);
          }
          if (v8 == a3) {
            sub_1010640FC(a1, 4u, 0);
          }
          else {
            sub_101062710(a1, 4);
          }
          uint64_t v31 = *(NSObject **)(a1 + 96);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = "handleDataModeChanged_sync";
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s: (3) refreshapn", buf, 0xCu);
          }
          goto LABEL_38;
        }
LABEL_21:
        uint64_t v27 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v25 + 1032))(v25, v27, 4, a3, 1);
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v24 = 0;
    char v26 = 1;
    if (!v25) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  int v16 = a3;
  if (v7 != a2) {
    goto LABEL_26;
  }
LABEL_39:
  if (v16 >= 1 && v16 != *(_DWORD *)(a1 + 236))
  {
    uint64_t v32 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = asString();
      uint64_t v34 = asString();
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "handleDataModeChanged_sync";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v33;
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v62 = v34;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s: fDataModeLastValid %s->%s", buf, 0x20u);
      int v16 = *(_DWORD *)(a1 + 232);
    }
    *(_DWORD *)(a1 + 236) = v16;
  }
  (*(void (**)(unint64_t))(*(void *)a1 + 632))(a1);
  int v35 = *(_DWORD *)(a1 + 228);
  sub_101064A60(a1);
  uint64_t v36 = *(void *)(a1 + 56);
  uint64_t v37 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  BOOL v38 = *(int *)(a1 + 228) >= 1 && *(unsigned char *)(a1 + 281) != 0;
  (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v36 + 48))(v36, v37, v38);
  uint64_t v39 = *(void *)(a1 + 56);
  if (v39)
  {
    uint64_t v40 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 264))(v39);
    uint64_t v41 = *(void **)v40;
    uint64_t v42 = *(void **)(v40 + 8);
    if (*(void **)v40 != v42)
    {
      do
      {
        (*(void (**)(void, const char *))(*(void *)*v41 + 224))(*v41, "BBDataDriver::handleDataModeChanged_sync");
        v41 += 2;
      }
      while (v41 != v42);
    }
    uint64_t v43 = *(void *)(a1 + 56);
    if (v43)
    {
      uint64_t v44 = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 264))(v43);
      uint64_t v45 = *(uint64_t **)v44;
      uint64_t v46 = *(uint64_t **)(v44 + 8);
      while (v45 != v46)
      {
        uint64_t v47 = *v45;
        (*(void (**)(uint8_t *__return_ptr, unint64_t))(*(void *)a1 + 16))(buf, a1);
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v47 + 232))(v47, buf);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        v45 += 2;
      }
      uint64_t v48 = *(void *)(a1 + 56);
      if (v48)
      {
        int v49 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v48 + 264))(v48);
        uint64_t v50 = *v49;
        uint64_t v51 = v49[1];
        while (v50 != v51)
        {
          (*(void (**)(void))(**(void **)v50 + 240))();
          v50 += 16;
        }
      }
    }
  }
  if (v8 != a3)
  {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 104) + 168))(*(void *)(a1 + 104), a2, a3);
    if (v35 > 0) {
      goto LABEL_62;
    }
LABEL_69:
    uint64_t v55 = 0;
    goto LABEL_70;
  }
  if (v35 < 1) {
    goto LABEL_69;
  }
LABEL_62:
  memset(buf, 0, sizeof(buf));
  sub_100058DB0(buf, "BBDataDriver::handleDataModeChanged");
  uint64_t v52 = *(void *)(a1 + 56);
  uint64_t v53 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v54 = buf;
  }
  else {
    uint64_t v54 = *(uint8_t **)buf;
  }
  (*(void (**)(uint64_t, uint64_t, void, uint8_t *, uint64_t))(*(void *)v52 + 216))(v52, v53, 0, v54, 2);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v55 = 1;
LABEL_70:
  uint64_t v56 = *(void *)(a1 + 56);
  uint64_t v57 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v56 + 224))(v56, v57, 23, v55);
  sub_1010702C4((uint64_t)v59);
  int v58 = v6 ^ sub_10106185C(a1, (uint64_t)v59);
  if (v59[0])
  {
    v59[1] = v59[0];
    operator delete(v59[0]);
  }
  if (v58) {
    sub_101064B88((void *)a1, (uint64_t)"data mode changed");
  }
}

void sub_101062690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101062710(uint64_t a1, int a2)
{
  int v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = sub_100B15758(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn : %s", buf, 0x16u);
  }
  uint64_t v125 = (uint64_t *)(a1 + 40);
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(a1 + 40), *(Registry **)(a1 + 40));
  BOOL v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v7;
  int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v6);
    uint64_t v13 = 0;
    char v14 = 1;
    if (!v12) {
      goto LABEL_9;
    }
LABEL_12:
    uint64_t v16 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    int v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 56))(v12, v16);
    goto LABEL_13;
  }
  uint64_t v12 = v11[3];
  uint64_t v13 = (std::__shared_weak_count *)v11[4];
  if (!v13) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v14 = 0;
  if (v12) {
    goto LABEL_12;
  }
LABEL_9:
  int v15 = 0;
LABEL_13:
  char v122 = v14;
  uint64_t v17 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 56) + 264))(*(void *)(a1 + 56));
  uint64_t v18 = (v17[1] - *v17) >> 4;
  uint64_t v19 = (void *)(a1 + 120);
  uint64_t v20 = (*(void *)(a1 + 128) - *(void *)(a1 + 120)) >> 4;
  if (v15 > (int)v18) {
    LODWORD(v18) = v15;
  }
  if ((int)v18 <= (int)v20) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = v18;
  }
  sub_10106B050((uint64_t *)(a1 + 120), (int)v21);
  if (v12 && (int)v21 >= 1)
  {
    for (unint64_t i = 0; i != v21; ++i)
    {
      uint64_t v23 = *(void *)(*v19 + 16 * i);
      if (v23)
      {
        if (i >= (uint64_t)(*(void *)(a1 + 128) - *v19) >> 4) {
          sub_10015B728();
        }
        unint64_t v24 = (*(uint64_t (**)(uint64_t, void))(*(void *)v23 + 312))(v23, 0);
        ConnectionMaskToType(v24);
        if (isSlice())
        {
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint64_t v25 = *(void *)(a1 + 120);
          if (i >= (*(void *)(a1 + 128) - v25) >> 4) {
            sub_10015B728();
          }
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(v25 + 16 * i) + 464))(buf);
          if (*(void *)buf)
          {
            for (uint64_t j = 0; j != v21; ++j)
            {
              long long v139 = 0uLL;
              uint64_t v27 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
              (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 72))(&v139, v12, v27, j);
              if ((void)v139 && *(void *)(v139 + 152) == v24)
              {
                uint64_t v28 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 80))(v12, v28, j, *(void *)buf + 48);
              }
              if (*((void *)&v139 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v139 + 1));
              }
            }
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
      }
    }
  }
  unsigned int v123 = a2;
  uint64_t v29 = a1 + 32;
  if ((int)v21 < 1)
  {
    int v127 = -1;
    int v128 = -1;
    int v58 = -1;
    int v126 = -1;
    goto LABEL_77;
  }
  uint64_t v121 = v13;
  uint64_t v30 = 0;
  unint64_t v31 = 0;
  char v32 = 0;
  int v128 = -1;
  int v124 = -1;
  int v126 = -1;
  int v127 = -1;
  do
  {
    uint64_t v33 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v31;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s: for %d", buf, 0x12u);
    }
    if (v12)
    {
      uint64_t v34 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, unint64_t))(*(void *)v12 + 72))(buf, v12, v34, v31);
      uint64_t v36 = *(void *)buf;
      int v35 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)buf)
      {
        uint64_t v37 = *(void *)(*v19 + v30);
        if (!v37)
        {
          uint64_t v38 = *(void *)(a1 + 56);
          uint64_t v39 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
          (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, unint64_t))(*(void *)v38 + 280))(buf, v38, v39, v31);
          uint64_t v40 = *v19 + v30;
          long long v41 = *(_OWORD *)buf;
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint64_t v42 = *(std::__shared_weak_count **)(v40 + 8);
          *(_OWORD *)uint64_t v40 = v41;
          if (v42) {
            sub_10004D2C8(v42);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          uint64_t v37 = *(void *)(*v19 + v30);
        }
        (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v37 + 824))(v37, 0, v36, 0);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 272))(v29))
        {
          uint64_t v43 = *(void *)(a1 + 120);
          if (v31 >= (*(void *)(a1 + 128) - v43) >> 4) {
            goto LABEL_211;
          }
          if (((*(uint64_t (**)(void, void))(**(void **)(v43 + v30) + 312))(*(void *)(v43 + v30), 0) & 0x200) != 0)
          {
            uint64_t v44 = *(NSObject **)(a1 + 96);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v31;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN index %d taken from 'native' APN", buf, 0x12u);
            }
            int v124 = v31;
          }
          uint64_t v45 = *(void *)(a1 + 120);
          if (v31 >= (*(void *)(a1 + 128) - v45) >> 4) {
            goto LABEL_211;
          }
          char v46 = (*(uint64_t (**)(void, void))(**(void **)(v45 + v30) + 312))(*(void *)(v45 + v30), 0);
          int v47 = v128;
          if (v46) {
            int v47 = v31;
          }
          int v128 = v47;
          uint64_t v48 = *(void *)(a1 + 120);
          if (v31 >= (*(void *)(a1 + 128) - v48) >> 4) {
            goto LABEL_211;
          }
          char v49 = (*(uint64_t (**)(void, void))(**(void **)(v48 + v30) + 312))(*(void *)(v48 + v30), 0);
          int v50 = v127;
          if ((v49 & 0x20) != 0) {
            int v50 = v31;
          }
          int v127 = v50;
          uint64_t v51 = *(void *)(a1 + 120);
          if (v31 >= (*(void *)(a1 + 128) - v51) >> 4) {
LABEL_211:
          }
            sub_10015B728();
          char v52 = (*(uint64_t (**)(void, void))(**(void **)(v51 + v30) + 312))(*(void *)(v51 + v30), 0);
          int v53 = v126;
          if ((v52 & 0x10) != 0) {
            int v53 = v31;
          }
          int v126 = v53;
        }
        char v32 = 1;
        goto LABEL_71;
      }
    }
    else
    {
      int v35 = 0;
    }
    uint64_t v54 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v31;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I %s: APN info not present for %d", buf, 0x12u);
    }
    uint64_t v55 = *(void *)(*v19 + v30);
    if (v55)
    {
      (*(void (**)(uint64_t, void, uint64_t, const char *, const char *))(*(void *)v55 + 728))(v55, 0, 27, "no APN for context", "CommCenter");
      uint64_t v56 = (void *)(*v19 + v30);
      uint64_t v57 = (std::__shared_weak_count *)v56[1];
      *uint64_t v56 = 0;
      v56[1] = 0;
      if (v57) {
        sub_10004D2C8(v57);
      }
    }
LABEL_71:
    if (v35) {
      sub_10004D2C8(v35);
    }
    ++v31;
    v30 += 16;
  }
  while (v21 != v31);
  uint64_t v13 = v121;
  int v58 = v124;
  if ((v32 & 1) == 0) {
LABEL_77:
  }
    *(unsigned char *)(a1 + 377) = 1;
  memset(buf, 0, sizeof(buf));
  long long v139 = 0uLL;
  uint64_t v140 = 0;
  long long v137 = 0uLL;
  uint64_t v138 = 0;
  __int16 v59 = (std::mutex *)Registry::getServiceMap(v125, (Registry *)*v125);
  uint64_t v60 = v59;
  if (v61 < 0)
  {
    uint64_t v62 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v63 = 5381;
    do
    {
      uint64_t v61 = v63;
      unsigned int v64 = *v62++;
      uint64_t v63 = (33 * v63) ^ v64;
    }
    while (v64);
  }
  std::mutex::lock(v59);
  CFTypeID v135 = (const void *)v61;
  __int16 v65 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)&v135);
  if (v65)
  {
    uint64_t v67 = v65[3];
    uint64_t v66 = (std::__shared_weak_count *)v65[4];
    if (v66)
    {
      atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v60);
      atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v66);
      unsigned int v68 = v123;
      if (!v67) {
        goto LABEL_108;
      }
      goto LABEL_87;
    }
    std::mutex::unlock(v60);
    unsigned int v68 = v123;
    if (v67)
    {
LABEL_87:
      CFTypeID v135 = 0;
      __int16 v136 = 0;
      uint64_t v69 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t))(*(void *)v67 + 16))(&v135, v67, v69);
      if (v135
        && (*(unsigned int (**)(const void *))(*(void *)v135 + 88))(v135)
        && (*(unsigned int (**)(const void *, uint8_t *, long long *, long long *))(*(void *)v135 + 80))(v135, buf, &v139, &v137))
      {
        uint64_t v70 = *(void *)(a1 + 104);
        if ((char)buf[23] < 0)
        {
          sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)buf;
          uint64_t v134 = *(void *)&buf[16];
        }
        if (SHIBYTE(v140) < 0)
        {
          sub_10004FC84(v131, (void *)v139, *((unint64_t *)&v139 + 1));
        }
        else
        {
          *(_OWORD *)CFDictionaryRef v131 = v139;
          uint64_t v132 = v140;
        }
        if (SHIBYTE(v138) < 0)
        {
          sub_10004FC84(__p, (void *)v137, *((unint64_t *)&v137 + 1));
        }
        else
        {
          *(_OWORD *)long long __p = v137;
          uint64_t v130 = v138;
        }
        (*(void (**)(uint64_t, void **, void **, void **))(*(void *)v70 + 152))(v70, __dst, v131, __p);
        if (SHIBYTE(v130) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v132) < 0) {
          operator delete(v131[0]);
        }
        if (SHIBYTE(v134) < 0) {
          operator delete(__dst[0]);
        }
      }
      if (v136) {
        sub_10004D2C8(v136);
      }
      if (v66) {
LABEL_108:
      }
        sub_10004D2C8(v66);
    }
  }
  else
  {
    std::mutex::unlock(v60);
    unsigned int v68 = v123;
  }
  if (SHIBYTE(v138) < 0) {
    operator delete((void *)v137);
  }
  if (SHIBYTE(v140) < 0) {
    operator delete((void *)v139);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 272))(v29))
  {
    if (v128 == -1) {
      int v71 = 0;
    }
    else {
      int v71 = v128;
    }
    if (v58 == -1)
    {
      CFStringRef v72 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v71;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN index %d taken from Internet APN", buf, 0x12u);
      }
      int v58 = v71;
    }
    *(void *)&long long v139 = 0;
    CFDictionaryRef v73 = (std::mutex *)Registry::getServiceMap(v125, (Registry *)*v125);
    CFDictionaryRef v74 = v73;
    if (v75 < 0)
    {
      __int16 v76 = (unsigned __int8 *)(v75 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v77 = 5381;
      do
      {
        uint64_t v75 = v77;
        unsigned int v78 = *v76++;
        uint64_t v77 = (33 * v77) ^ v78;
      }
      while (v78);
    }
    std::mutex::lock(v73);
    *(void *)std::string buf = v75;
    CFBooleanRef v79 = sub_10004D37C(&v74[1].__m_.__sig, (unint64_t *)buf);
    if (v79)
    {
      uint64_t v81 = v79[3];
      int v80 = (std::__shared_weak_count *)v79[4];
      if (v80)
      {
        atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v74);
        atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v80);
        char v82 = 0;
        goto LABEL_131;
      }
    }
    else
    {
      uint64_t v81 = 0;
    }
    std::mutex::unlock(v74);
    int v80 = 0;
    char v82 = 1;
LABEL_131:
    uint64_t v83 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v81 + 96))(&v139, v81, v83, 1, @"AllowOTAActivation", kCFBooleanTrue, 0);
    if ((v82 & 1) == 0) {
      sub_10004D2C8(v80);
    }
    uint64_t v84 = (BOOL *)v139;
    buf[0] = 1;
    if (!(void)v139) {
      goto LABEL_137;
    }
    CFTypeID v85 = CFGetTypeID((CFTypeRef)v139);
    if (v85 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v84, v86);
    }
    if (!buf[0])
    {
      std::string v99 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I %s: Carrier Bundle is disabling OTA activation", buf, 0xCu);
      }
      sub_1000577C4((const void **)&v139);
      uint64_t v87 = 0;
      BOOL v88 = 0;
    }
    else
    {
LABEL_137:
      sub_1000577C4((const void **)&v139);
      uint64_t v87 = 0;
      BOOL v88 = v58 >= 0;
      if (v12 && (v58 & 0x80000000) == 0)
      {
        uint64_t v89 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void))(*(void *)v12 + 72))(buf, v12, v89, v58);
        uint64_t v90 = *(void *)buf;
        uint64_t v87 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)buf)
        {
          uint64_t v91 = *(void *)(a1 + 296);
          if (!v91)
          {
            id v92 = *(NSObject **)(a1 + 96);
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v58;
              _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I %s: (internet) OTA APN created with index: %d (1)", buf, 0x12u);
            }
            (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v139, a1);
            sub_10106AFA0(*(void *)(a1 + 56));
            __int16 v93 = *(NSObject **)(a1 + 80);
            if (v93) {
              dispatch_retain(v93);
            }
            sub_10106B0E0();
          }
          uint64_t v94 = sub_10106AFA0(*(void *)(a1 + 56));
          (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v91 + 824))(v91, 0, v90, v94);
          if ((*(unsigned int (**)(void))(**(void **)(a1 + 104) + 144))(*(void *)(a1 + 104)))
          {
            if (v58)
            {
              uint64_t v95 = *(void *)(a1 + 312);
              if (!v95)
              {
                uint64_t v96 = *(NSObject **)(a1 + 96);
                if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 0;
                  _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I %s: (internet cdma) OTA APN created with index: %d (1)", buf, 0x12u);
                }
                (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v139, a1);
                sub_10106AFA0(*(void *)(a1 + 56));
                uint64_t v97 = *(NSObject **)(a1 + 80);
                if (v97) {
                  dispatch_retain(v97);
                }
                sub_10106B0E0();
              }
              uint64_t v98 = sub_10106AFA0(*(void *)(a1 + 56));
              (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v95 + 824))(v95, 0, v90, v98);
            }
            else
            {
              uint64_t v104 = *(std::__shared_weak_count **)(a1 + 320);
              *(void *)(a1 + 312) = 0;
              *(void *)(a1 + 320) = 0;
              if (v104) {
                sub_10004D2C8(v104);
              }
            }
          }
          CFTypeID v135 = 0;
LABEL_172:
          uint64_t v105 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
          sub_100C9B3A0((Registry **)v125, v105, (uint64_t *)&v139);
          *(void *)std::string buf = v135;
          CFTypeID v135 = (const void *)v139;
          *(void *)&long long v139 = 0;
          sub_100057D78((const void **)buf);
          sub_100057D78((const void **)&v139);
          uint64_t v103 = v135;
          goto LABEL_173;
        }
        BOOL v88 = 1;
      }
    }
    uint64_t v100 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
      _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN Info not present", buf, 0xCu);
    }
    CFTypeID v101 = *(std::__shared_weak_count **)(a1 + 304);
    *(void *)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
    if (v101) {
      sub_10004D2C8(v101);
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 104) + 144))(*(void *)(a1 + 104))
      && (long long v102 = *(std::__shared_weak_count **)(a1 + 320), *(void *)(a1 + 312) = 0,
                                                           *(void *)(a1 + 320) = 0,
                                                           v102))
    {
      sub_10004D2C8(v102);
      uint64_t v103 = 0;
      CFTypeID v135 = 0;
      if (v88) {
        goto LABEL_172;
      }
    }
    else
    {
      uint64_t v103 = 0;
      CFTypeID v135 = 0;
      if (v88) {
        goto LABEL_172;
      }
    }
LABEL_173:
    if (v103) {
      uint64_t v106 = sub_100080778;
    }
    else {
      uint64_t v106 = 0;
    }
    if (v106)
    {
      long long v139 = 0uLL;
      PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      long long v139 = 0uLL;
      operator new();
    }
    CFTypeID v114 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
      _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN dictionary not present", buf, 0xCu);
    }
    std::string v115 = *(std::__shared_weak_count **)(a1 + 336);
    *(void *)(a1 + 328) = 0;
    *(void *)(a1 + 336) = 0;
    unsigned int v68 = v123;
    if (v115) {
      sub_10004D2C8(v115);
    }
    if (!*(void *)(a1 + 344))
    {
      uint64_t v107 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
        _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN assigned Internet settings", buf, 0xCu);
      }
      *(void *)(a1 + 344) = a1 + 296;
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 104) + 144))(*(void *)(a1 + 104)))
    {
      if (v12)
      {
        uint64_t v108 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, void))(*(void *)v12 + 72))(buf, v12, v108, 0);
        uint64_t v109 = *(void *)buf;
        char v110 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)buf && (v127 != -1 || v126 != -1))
        {
          uint64_t v111 = *(void *)(a1 + 352);
          if (!v111)
          {
            (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v139, a1);
            sub_10106AFA0(*(void *)(a1 + 56));
            char v112 = *(NSObject **)(a1 + 80);
            if (v112) {
              dispatch_retain(v112);
            }
            sub_10106B2E0();
          }
          uint64_t v113 = sub_10106AFA0(*(void *)(a1 + 56));
          (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v111 + 824))(v111, 0, v109, v113);
          goto LABEL_200;
        }
      }
      else
      {
        char v110 = 0;
      }
      uint64_t v116 = *(std::__shared_weak_count **)(a1 + 360);
      *(void *)(a1 + 352) = 0;
      *(void *)(a1 + 360) = 0;
      if (v116) {
        sub_10004D2C8(v116);
      }
LABEL_200:
      if (v110) {
        sub_10004D2C8(v110);
      }
    }
    sub_100057D78(&v135);
    if (v87) {
      sub_10004D2C8(v87);
    }
  }
  unsigned __int16 v117 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
  {
    int v118 = sub_100B15758(v68);
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v118;
    _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn : %s", buf, 0x16u);
  }
  sub_1010640FC(a1, v68, 1);
  BOOL v119 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v120 = sub_100B15758(v68);
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refreshAllDataSettings";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v120;
    _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "#I %s: refreshapn done : %s", buf, 0x16u);
  }
  if ((v122 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_101063E48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,char a43,uint64_t a44)
{
  if (v44) {
    dispatch_release(v44);
  }
  char v49 = *(std::__shared_weak_count **)(v47 - 144);
  if (v49) {
    sub_10004D2C8(v49);
  }
  if (v45) {
    sub_10004D2C8(v45);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(v46);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010640FC(uint64_t a1, unsigned int a2, BOOL a3)
{
  BOOL v6 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = sub_100B15758(a2);
    __int16 v57 = 2080;
    uint64_t v58 = asStringBool(a3);
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn: reason = %s changed = %s", buf, 0x20u);
  }
  char v54 = a3;
  if (*(void *)(a1 + 128) == *(void *)(a1 + 120))
  {
    char v32 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
    uint64_t v33 = "#I %s: no data settings present yet, bailing";
    uint64_t v34 = v32;
    uint32_t v35 = 12;
    goto LABEL_52;
  }
  if (a2 <= 0x11 && ((1 << a2) & 0x30002) != 0)
  {
    uint64_t v7 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = sub_100B15758(a2);
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: reset settings due to %s", buf, 0x16u);
    }
    uint64_t v9 = 0;
    do
    {
      unsigned int v10 = *(void (****)(void, void, uint64_t, uint64_t, uint64_t *, char *))(a1 + 56);
      uint64_t v11 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      uint64_t v52 = 0;
      int v53 = 0;
      (**v10)(v10, 0, v11, v9, &v52, &v54);
      if (v53) {
        sub_10004D2C8(v53);
      }
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v13 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint64_t, uint64_t, void, void, uint64_t))(*(void *)v12 + 40))(v12, v13, 0, 0, v9);
      uint64_t v9 = (v9 + 1);
    }
    while (v9 != 36);
    char v54 = 1;
    *(unsigned char *)(a1 + 377) = 1;
  }
  char v14 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = sub_100B15758(a2);
    uint64_t v16 = asStringBool(a3);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v15;
    __int16 v57 = 2080;
    uint64_t v58 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn: reason = %s changed = %s", buf, 0x20u);
  }
  unsigned __int8 v55 = 0;
  uint64_t v17 = *(uint64_t **)(a1 + 120);
  uint64_t v18 = *(uint64_t **)(a1 + 128);
  if (v17 == v18)
  {
LABEL_23:
    uint64_t v19 = 0;
    uint64_t v20 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v20 = *v17;
      uint64_t v19 = (std::__shared_weak_count *)v17[1];
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v20 && (*(uint64_t (**)(uint64_t, void))(*(void *)v20 + 312))(v20, 0) == 0x40000) {
        break;
      }
      if (v19) {
        sub_10004D2C8(v19);
      }
      v17 += 2;
      if (v17 == v18) {
        goto LABEL_23;
      }
    }
    uint64_t v48 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "setupEmergencyConfiguration";
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I %s: Found Em data settings", buf, 0xCu);
    }
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
    }
  }
  uint64_t v21 = *(uint64_t (****)(void, void, uint64_t, uint64_t, unsigned char *, unsigned __int8 *))(a1 + 56);
  uint64_t v22 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  *(void *)std::string buf = v20;
  *(void *)&uint8_t buf[8] = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v23 = (**v21)(v21, 0, v22, 18, buf, &v55);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v24 = *(void *)(a1 + 56);
  uint64_t v25 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(uint64_t, uint64_t, void, uint64_t, uint64_t))(*(void *)v24 + 40))(v24, v25, v55, v23, 18);
  if (v20) {
    (*(void (**)(uint64_t, void))(*(void *)v20 + 832))(v20, 0);
  }
  unsigned __int8 v26 = v55;
  if (v19) {
    sub_10004D2C8(v19);
  }
  v54 |= v26;
  char v27 = sub_101061C78(a1);
  uint64_t v28 = *(NSObject **)(a1 + 96);
  if (v27)
  {
LABEL_36:
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 256))(a1);
      uint64_t v31 = asString();
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v31;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s:  reconfiguring with %s", buf, 0x16u);
    }
    switch((*(unsigned int (**)(uint64_t))(*(void *)a1 + 256))(a1))
    {
      case 0u:
        if (*(unsigned char *)(a1 + 377))
        {
          BOOL v36 = sub_101068F9C(a1, 0, 1);
          goto LABEL_42;
        }
        break;
      case 1u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        BOOL v36 = sub_101068F9C(a1, 0, 0);
        goto LABEL_42;
      case 2u:
        BOOL v36 = sub_101068F9C(a1, 1, 0);
LABEL_42:
        v54 |= v36;
        break;
      default:
        break;
    }
    uint64_t v37 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = sub_100B15758(a2);
      uint64_t v39 = asStringBool(a3);
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v38;
      __int16 v57 = 2080;
      uint64_t v58 = v39;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: (3) refreshapn: reason = %s changed = %s", buf, 0x20u);
    }
    sub_10106A1EC((PersonalitySpecificImpl *)a1);
    uint64_t v40 = *(void *)(a1 + 56);
    uint64_t v41 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    sub_100058DB0(__p, "BB setup reconfigured");
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v40 + 88))(v40, v41, __p);
    if (v51 < 0) {
      operator delete(__p[0]);
    }
    if (v54)
    {
      *(_DWORD *)std::string buf = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      sub_10106A300(a1 + 144, (int *)buf);
      uint64_t v42 = 0;
      do
      {
        uint64_t v43 = *(void *)(a1 + 56);
        uint64_t v44 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v43 + 8))(v43, v44, 0, v42);
        uint64_t v42 = (v42 + 1);
      }
      while (v42 != 36);
    }
    uint64_t v45 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      char v46 = sub_100B15758(a2);
      uint64_t v47 = asStringBool(a3);
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v46;
      __int16 v57 = 2080;
      uint64_t v58 = v47;
      uint64_t v33 = "#I %s: refreshapn done: reason = %s changed = %s";
      uint64_t v34 = v45;
      uint32_t v35 = 32;
LABEL_52:
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, buf, v35);
      return;
    }
    return;
  }
  int v29 = *(unsigned __int8 *)(a1 + 377);
  BOOL v30 = os_log_type_enabled(*(os_log_t *)(a1 + 96), OS_LOG_TYPE_DEFAULT);
  if (v29)
  {
    if (v30)
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s: No data bearer available, but config was not set up yet, trying", buf, 0xCu);
      uint64_t v28 = *(NSObject **)(a1 + 96);
    }
    goto LABEL_36;
  }
  if (v30)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 256))(a1);
    uint64_t v49 = asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "refreshDataServiceConfiguration";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v49;
    uint64_t v33 = "#I %s: No data bearer available, not reconfiguring with %s";
    uint64_t v34 = v28;
    uint32_t v35 = 22;
    goto LABEL_52;
  }
}

void sub_1010649E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_101064A60(unint64_t result)
{
  if (!*(unsigned char *)(result + 208))
  {
    uint64_t v1 = (PersonalitySpecificImpl *)result;
    uint64_t v2 = *(NSObject **)(result + 96);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)BOOL v6 = 136315394;
      *(void *)&void v6[4] = asString();
      *(_WORD *)&v6[12] = 2080;
      *(void *)&v6[14] = asString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I ImsTechnologyChanged: data mode %s, rat %s", v6, 0x16u);
    }
    sub_10106A1EC(v1);
    uint64_t result = sub_10106A400((uint64_t)v1);
    *(void *)BOOL v6 = result;
    *(void *)&v6[8] = v3;
    uint64_t v4 = *((void *)v1 + 7);
    if (v4)
    {
      uint64_t v5 = PersonalitySpecificImpl::simSlot(v1);
      return (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v4 + 328))(v4, v5, v6);
    }
  }
  return result;
}

void sub_101064B88(void *a1, uint64_t a2)
{
  sub_1010702C4((uint64_t)__p);
  BOOL v4 = sub_10106185C((uint64_t)a1, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  uint64_t v5 = a1[12];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(v4);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)char v14 = "handleCellularNetworkAvailability";
    *(_WORD *)&v14[8] = 2080;
    *(void *)&v14[10] = v6;
    __int16 v15 = 2080;
    uint64_t v16 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: network available: %s (%s)", buf, 0x20u);
  }
  uint64_t v7 = a1[7];
  if (v7)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 264))(v7);
    uint64_t v9 = *(uint64_t **)v8;
    unsigned int v10 = *(uint64_t **)(v8 + 8);
    while (v9 != v10)
    {
      uint64_t v11 = *v9;
      (*(void (**)(uint8_t *__return_ptr, void *))(*a1 + 16))(buf, a1);
      (*(void (**)(uint64_t, uint64_t, BOOL, uint8_t *))(*(void *)v11 + 560))(v11, a2, v4, buf);
      if (*(void *)&v14[4]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v14[4]);
      }
      v9 += 2;
    }
  }
}

void sub_101064D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101064D7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_101064D84(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 176))();
  }
  return result;
}

uint64_t sub_101064DB4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 176))();
  }
  return result;
}

unint64_t sub_101064DE4(unint64_t result, int a2)
{
  if (*(_DWORD *)(result + 240) != a2)
  {
    unint64_t v3 = result;
    BOOL v4 = *(NSObject **)(result + 96);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315394;
      uint64_t v6 = asString();
      __int16 v7 = 2080;
      uint64_t v8 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fRat %s->%s (change states)", (uint8_t *)&v5, 0x16u);
    }
    *(_DWORD *)(v3 + 240) = a2;
    return sub_101064A60(v3);
  }
  return result;
}

unint64_t sub_101064EC4(uint64_t a1, int a2)
{
  return sub_101064DE4(a1 - 24, a2);
}

uint64_t sub_101064ED4(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = *((void *)a1 + 7);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);
  unint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 376);

  return v3(v1, v2);
}

uint64_t sub_101064F4C(void *a1)
{
  return sub_101064ED4((PersonalitySpecificImpl *)((char *)a1 + *(void *)(*a1 - 168)));
}

uint64_t sub_101064F68(uint64_t result, unsigned int a2)
{
  if (a2 <= 6 && ((0x73u >> a2) & 1) != 0) {
    *(_DWORD *)(result + 288) = dword_1015B5494[a2];
  }
  return result;
}

uint64_t sub_101064F90(uint64_t result, unsigned int a2)
{
  if (a2 <= 6 && ((0x73u >> a2) & 1) != 0) {
    *(_DWORD *)(result + 264) = dword_1015B5494[a2];
  }
  return result;
}

void sub_101064FB8(uint64_t a1, unsigned int a2)
{
  if (!*(unsigned char *)(a1 + 208))
  {
    int v4 = *(_DWORD *)(a1 + 288);
    sub_1010702C4((uint64_t)__p);
    BOOL v5 = sub_10106185C(a1, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (a2 < 7 && ((0x73u >> a2) & 1) != 0 && (int v6 = dword_1015B5494[a2], *(_DWORD *)(a1 + 288) != v6))
    {
      *(_DWORD *)(a1 + 288) = v6;
      unsigned int v10 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = asString();
        uint64_t v12 = asString();
        *(_DWORD *)std::string buf = 136315650;
        uint64_t v19 = "handleRegistrationStatus_sync";
        __int16 v20 = 2080;
        uint64_t v21 = v11;
        __int16 v22 = 2080;
        uint64_t v23 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: fRoamingResult %s, changed (raw:%s)", buf, 0x20u);
      }
      sub_101062710(a1, 19);
      if (!v4) {
        sub_101065260(a1);
      }
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)v13 + 224))(v13, v14, 25, *(_DWORD *)(a1 + 288) != 0);
    }
    else
    {
      __int16 v7 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = asString();
        uint64_t v9 = asString();
        *(_DWORD *)std::string buf = 136315650;
        uint64_t v19 = "handleRegistrationStatus_sync";
        __int16 v20 = 2080;
        uint64_t v21 = v8;
        __int16 v22 = 2080;
        uint64_t v23 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: fRoamingResult %s, not changed (raw:%s)", buf, 0x20u);
      }
    }
    sub_1010702C4((uint64_t)v16);
    int v15 = v5 ^ sub_10106185C(a1, (uint64_t)v16);
    if (v16[0])
    {
      v16[1] = v16[0];
      operator delete(v16[0]);
    }
    if (v15) {
      sub_101064B88((void *)a1, (uint64_t)"registration status changed");
    }
  }
}

void sub_10106522C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (__p)
  {
    void *v12 = __p;
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101065260(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    v22[0] = "handleDataAvailable_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", buf, 0xCu);
  }
  if (!*(_DWORD *)(a1 + 288))
  {
    int v6 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    v22[0] = "handleDataAvailable_sync";
    __int16 v7 = "#I %s: Roaming unknown, bailing out";
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 0xCu);
    return;
  }
  if (!*(unsigned char *)(a1 + 281))
  {
    int v6 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)std::string buf = 136315138;
    v22[0] = "handleDataAvailable_sync";
    __int16 v7 = "#I %s: Data not attached (raw), bailing out";
    goto LABEL_13;
  }
  if (*(int *)(a1 + 228) >= 1) {
    (*(void (**)(uint64_t))(*(void *)a1 + 632))(a1);
  }
  (*(void (**)(void))(**(void **)(a1 + 104) + 128))(*(void *)(a1 + 104));
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  BOOL v5 = *(int *)(a1 + 228) >= 1 && *(unsigned char *)(a1 + 281) != 0;
  (*(void (**)(uint64_t, uint64_t, BOOL))(*(void *)v3 + 48))(v3, v4, v5);
  uint64_t v8 = *(void *)(a1 + 56);
  if (v8)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 264))(v8);
    unsigned int v10 = *(void **)v9;
    uint64_t v11 = *(void **)(v9 + 8);
    if (*(void **)v9 != v11)
    {
      do
      {
        (*(void (**)(void, const char *))(*(void *)*v10 + 224))(*v10, "BBDataDriver::handleDataAttached_sync");
        v10 += 2;
      }
      while (v10 != v11);
    }
    uint64_t v12 = *(void *)(a1 + 56);
    if (v12)
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 264))(v12);
      uint64_t v14 = *(uint64_t **)v13;
      int v15 = *(uint64_t **)(v13 + 8);
      while (v14 != v15)
      {
        uint64_t v16 = *v14;
        (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(buf, a1);
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v16 + 232))(v16, buf);
        if (*(void *)((char *)v22 + 4)) {
          sub_10004D2C8(*(std::__shared_weak_count **)((char *)v22 + 4));
        }
        v14 += 2;
      }
    }
  }
  uint64_t v17 = *(void *)(a1 + 56);
  uint64_t v18 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  sub_100058DB0(__p, "Data attached");
  (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v17 + 72))(v17, v18, __p, 0);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
}

void sub_101065600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101065638(uint64_t a1, unsigned int a2)
{
}

void sub_101065640(uint64_t a1, int a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 40));
  BOOL v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v7;
  uint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v11)
  {
    std::mutex::unlock(v5);
    return;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    sub_10004D2C8(v12);
    if (!v13) {
      return;
    }
  }
  else
  {
    std::mutex::unlock(v5);
    if (!v13) {
      return;
    }
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v14 || (int v15 = std::__shared_weak_count::lock(v14)) == 0) {
    sub_100088B9C();
  }
  uint64_t v16 = v15;
  atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  uint64_t v17 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = "disable";
    if (a2) {
      uint64_t v19 = "enable";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "checkAndSetDataOffAttachAPN";
    __int16 v38 = 2080;
    uint64_t v39 = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: %s DataOff Attach APN if needed", buf, 0x16u);
  }
  char v20 = (std::mutex *)Registry::getServiceMap(v18, *(Registry **)(a1 + 40));
  uint64_t v21 = v20;
  if (v6 < 0)
  {
    __int16 v22 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      uint64_t v6 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v20);
  *(void *)std::string buf = v6;
  uint64_t v25 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)buf);
  if (!v25)
  {
    uint64_t v27 = 0;
    goto LABEL_23;
  }
  uint64_t v27 = v25[3];
  unsigned __int8 v26 = (std::__shared_weak_count *)v25[4];
  if (!v26)
  {
LABEL_23:
    std::mutex::unlock(v21);
    unsigned __int8 v26 = 0;
    char v28 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v21);
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v26);
  char v28 = 0;
LABEL_24:
  uint64_t v29 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  if (a2) {
    uint64_t v30 = 7;
  }
  else {
    uint64_t v30 = 8;
  }
  uint64_t v31 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v31 || (uint64_t v32 = *(void *)(a1 + 64), (v33 = std::__shared_weak_count::lock(v31)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v34 = v33;
  atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v33);
  uint32_t v35 = operator new(0x20uLL);
  *uint32_t v35 = off_101A84C38;
  v35[1] = a1;
  v35[2] = v32;
  int v35[3] = v34;
  v36[3] = v35;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v27 + 64))(v27, v29, v30, v36);
  sub_10003B34C(v36);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  std::__shared_weak_count::__release_weak(v16);
}

void sub_101065954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10003B34C(&a9);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  std::__shared_weak_count::__release_weak(v9);
  _Unwind_Resume(a1);
}

void sub_1010659C0(uint64_t a1, int a2)
{
}

uint64_t sub_1010659C8(uint64_t result)
{
  if (!*(unsigned char *)(result + 208))
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = *(NSObject **)(result + 96);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      uint64_t v9 = "handleCellularDataStatusChangedInternal_sync";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v8, 0xCu);
    }
    uint64_t v3 = v1[7];
    if (v3)
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
      BOOL v5 = *(uint64_t **)v4;
      uint64_t v6 = *(uint64_t **)(v4 + 8);
      if (*(uint64_t **)v4 != v6)
      {
        do
        {
          uint64_t v7 = *v5;
          v5 += 2;
          (*(void (**)(uint64_t, const char *))(*(void *)v7 + 224))(v7, "DataDriver::handleCellularDataStatusChangedInternal_sync");
        }
        while (v5 != v6);
      }
    }
    return (*(uint64_t (**)(void *, void, const char *))(*v1 + 584))(v1, 0, "Cellular Data change");
  }
  return result;
}

uint64_t sub_101065B34(uint64_t a1)
{
  return sub_1010659C8(a1 - 24);
}

uint64_t sub_101065B40(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 296))();
}

uint64_t sub_101065B70(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 296))();
}

uint64_t sub_101065BA0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 256))();
}

uint64_t sub_101065BD0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 256))();
}

uint64_t sub_101065C00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 264))();
}

uint64_t sub_101065C30(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 264))();
}

uint64_t sub_101065C60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 272))();
}

uint64_t sub_101065C90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 272))();
}

uint64_t sub_101065CC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 104);
  sub_10012CA20((uint64_t)v7, a3);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v4 + 280))(v4, a2, v7);
  sub_10012C330(v7);
  return v5;
}

void sub_101065D6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012C330((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101065D88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_101065CC0(a1 - 24, a2, a3);
}

uint64_t sub_101065D90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 288))();
}

uint64_t sub_101065DC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 288))();
}

void sub_101065DF0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    uint64_t v9 = "handleCallActive_sync";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: ", (uint8_t *)&v8, 0xCu);
  }
  if (*(unsigned char *)(a2 + 2))
  {
    if (!*(unsigned char *)(a1 + 209))
    {
      uint64_t v5 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136315138;
        uint64_t v9 = "handleCallActive_sync";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: fIsCSCallActive: false ==>> true", (uint8_t *)&v8, 0xCu);
      }
      *(unsigned char *)(a1 + 209) = 1;
      if (!sub_1010614A0((Registry **)a1, (uint64_t *)1)) {
        (*(void (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "Active call is a CS call");
      }
    }
    sub_101066048(a1, 1);
  }
  else if (*(unsigned char *)(a1 + 209))
  {
    uint64_t v6 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      uint64_t v9 = "handleCallActive_sync";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: fIsCSCallActive: true ==>> false", (uint8_t *)&v8, 0xCu);
    }
    *(unsigned char *)(a1 + 209) = 0;
    if (!sub_1010614A0((Registry **)a1, v7)) {
      (*(void (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "Active call is no longer a CS call");
    }
    sub_101066228(a1, 1);
  }
  if (*(unsigned char *)(a2 + 1)) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 912))(a1, 1);
  }
}

void sub_101066048(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 376) |= a2;
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v14 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 56) + 208))(v13);
  uint64_t v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = SHIBYTE(v14);
    uint64_t v6 = (void **)v13[0];
    if (a2 == 1) {
      uint64_t v7 = "kBlockOpportunisticActiveCall";
    }
    else {
      uint64_t v7 = "kBlockOpportunisticFDBackoff";
    }
    sub_100058DB0(__p, v7);
    int v8 = v13;
    if (v5 < 0) {
      int v8 = v6;
    }
    if (v12 >= 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = (void **)__p[0];
    }
    int v10 = *(unsigned __int8 *)(a1 + 376);
    *(_DWORD *)std::string buf = 136315906;
    uint64_t v16 = "blockOpportunisticConnections_sync";
    __int16 v17 = 2080;
    uint64_t v18 = v8;
    __int16 v19 = 2080;
    char v20 = v9;
    __int16 v21 = 1024;
    int v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Blocking opportunistic connections for %s, source: %s (mask=0x%02x)", buf, 0x26u);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 960))(a1, v13);
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
}

void sub_101066200(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101066228(uint64_t a1, int a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 376);
  *(unsigned char *)(a1 + 376) = v4 & ~(_BYTE)a2;
  if ((v4 & (a2 ^ 0xFF)) != 0)
  {
    int v5 = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (a2 == 1) {
      uint64_t v6 = "kBlockOpportunisticActiveCall";
    }
    else {
      uint64_t v6 = "kBlockOpportunisticFDBackoff";
    }
    sub_100058DB0(v17, v6);
    if (v18 >= 0) {
      uint64_t v7 = v17;
    }
    else {
      uint64_t v7 = (void **)v17[0];
    }
    int v8 = *(unsigned __int8 *)(a1 + 376);
    *(_DWORD *)std::string buf = 136315650;
    char v20 = "unblockOpportunisticConnections_sync";
    __int16 v21 = 2080;
    int v22 = v7;
    __int16 v23 = 1024;
    LODWORD(v24) = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: Not unblocking opportunistic connections for source: %s - other block is still in effect (mask=%0x02x)", buf, 0x1Cu);
  }
  else
  {
    v17[0] = 0;
    v17[1] = 0;
    uint64_t v18 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 56) + 208))(v17);
    uint64_t v9 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = SHIBYTE(v18);
      char v11 = (void **)v17[0];
      if (a2 == 1) {
        char v12 = "kBlockOpportunisticActiveCall";
      }
      else {
        char v12 = "kBlockOpportunisticFDBackoff";
      }
      sub_100058DB0(__p, v12);
      uint64_t v13 = v17;
      if (v10 < 0) {
        uint64_t v13 = v11;
      }
      if (v16 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136315650;
      char v20 = "unblockOpportunisticConnections_sync";
      __int16 v21 = 2080;
      int v22 = v13;
      __int16 v23 = 2080;
      unsigned int v24 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: Unblocking opportunistic connections for %s, source: %s", buf, 0x20u);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
    }
    (*(void (**)(uint64_t, void **))(*(void *)a1 + 968))(a1, v17);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
}

void sub_10106647C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010664A4(void *a1, uint64_t a2)
{
}

void sub_1010664C0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = "handleCallInactive_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", (uint8_t *)&v5, 0xCu);
  }
  if (*(unsigned char *)(a1 + 209))
  {
    uint64_t v3 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      uint64_t v6 = "handleCallInactive_sync";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: fIsCSCallActive: true ==>> false", (uint8_t *)&v5, 0xCu);
    }
    *(unsigned char *)(a1 + 209) = 0;
    if (!sub_1010614A0((Registry **)a1, v4)) {
      (*(void (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "CS call stopped.");
    }
  }
  else
  {
    (*(void (**)(uint64_t, void))(*(void *)a1 + 912))(a1, 0);
  }
  sub_101066228(a1, 1);
}

void sub_10106664C(void *a1)
{
}

void sub_101066668(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 40));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12) {
    goto LABEL_16;
  }
LABEL_10:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v16 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  dispatch_object_t object = (dispatch_object_t)&_dispatch_main_q;
  dispatch_retain((dispatch_object_t)&_dispatch_main_q);
  v17[0] = off_101A84CB8;
  v17[1] = a1 + 96;
  v17[3] = v17;
  (*(void (**)(uint64_t, void **, uint64_t, dispatch_object_t *, void *))(*(void *)v12 + 40))(v12, __p, 1, &object, v17);
  sub_1004D6DC0(v17);
  if (object) {
    dispatch_release(object);
  }
  if ((SHIBYTE(v16) & 0x80000000) == 0)
  {
LABEL_16:
    if (v13) {
      return;
    }
    goto LABEL_17;
  }
  operator delete(__p[0]);
  if (v13) {
    return;
  }
LABEL_17:
  sub_10004D2C8(v11);
}

void sub_101066850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010668A8(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 40));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  char v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (!v12) {
    goto LABEL_16;
  }
LABEL_10:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v16 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  dispatch_object_t object = (dispatch_object_t)&_dispatch_main_q;
  dispatch_retain((dispatch_object_t)&_dispatch_main_q);
  v17[0] = off_101A84D48;
  v17[1] = a1 + 96;
  v17[3] = v17;
  (*(void (**)(uint64_t, void **, void, dispatch_object_t *, void *))(*(void *)v12 + 40))(v12, __p, 0, &object, v17);
  sub_1004D6DC0(v17);
  if (object) {
    dispatch_release(object);
  }
  if ((SHIBYTE(v16) & 0x80000000) == 0)
  {
LABEL_16:
    if (v13) {
      return;
    }
    goto LABEL_17;
  }
  operator delete(__p[0]);
  if (v13) {
    return;
  }
LABEL_17:
  sub_10004D2C8(v11);
}

void sub_101066A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(exception_object);
}

void sub_101066AE8(uint64_t a1, uint64_t a2)
{
  sub_101066048(a1, 2);
  uint64_t v4 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  int v5 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "processFDBackoffTimeout";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: scheduling fast dormancy backoff timer", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v6 || (uint64_t v7 = *(void *)(a1 + 64), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 40));
  uint64_t v10 = buf;
  sub_100058DB0(__p, "fast dormancy backoff timeout");
  char v11 = *(NSObject **)(a1 + 80);
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 1174405120;
  aBlock[2] = sub_101066DF4;
  aBlock[3] = &unk_101A83940;
  aBlock[4] = a1;
  aBlock[5] = v7;
  uint64_t v16 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  __int16 v17 = _Block_copy(aBlock);
  sub_100118A44(v10, (uint64_t)__p, 0, 1000 * a2, &object, &v17);
  uint64_t v12 = v21;
  uint64_t v21 = 0;
  uint64_t v13 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = v12;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    uint64_t v14 = v21;
    uint64_t v21 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
  }
  if (v17) {
    _Block_release(v17);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  std::__shared_weak_count::__release_weak(v9);
}

void sub_101066D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_101066DF4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 96);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315138;
          unsigned int v9 = "processFDBackoffTimeout_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: fast dormancy backoff timer fired", (uint8_t *)&v8, 0xCu);
        }
        uint64_t v7 = *(void *)(v3 + 176);
        *(void *)(v3 + 176) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        sub_101066228(v3, 2);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_101066F04(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101066F18(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101066F34(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101066F44(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_101066F4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

uint64_t sub_101066F84(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

void sub_101066FBC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    uint64_t v4 = "processDeactivationRejected";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: context deactivation rejected by connection", (uint8_t *)&v3, 0xCu);
  }
  ++*(_DWORD *)(a1 + 372);
}

void sub_10106706C(uint64_t a1)
{
}

void *sub_101067074(void *a1)
{
  uint64_t v2 = a1[12];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 136315138;
    int v15 = "resetDataObjects_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: resetDataObjects_sync", (uint8_t *)&v14, 0xCu);
  }
  sub_101060C24(a1 + 20);
  uint64_t v3 = a1[7];
  if (v3)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    int v5 = *(void **)v4;
    uint64_t v6 = *(void **)(v4 + 8);
    while (v5 != v6)
    {
      (*(void (**)(void, void))(*(void *)*v5 + 264))(*v5, 0);
      v5 += 2;
    }
  }
  uint64_t v7 = (uint64_t *)a1[15];
  for (unint64_t i = (uint64_t *)a1[16]; v7 != i; v7 += 2)
  {
    uint64_t v9 = *v7;
    uint64_t v10 = (std::__shared_weak_count *)v7[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v9) {
      (*(void (**)(uint64_t, void, const char *))(*(void *)v9 + 736))(v9, 0, "Radio Reset");
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  uint64_t result = (void *)a1[7];
  if (result)
  {
    uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 264))(result);
    uint64_t v12 = (void *)*result;
    uint64_t v13 = (void *)result[1];
    if ((void *)*result != v13)
    {
      do
      {
        uint64_t result = (void *)(*(uint64_t (**)(void, void, const char *))(*(void *)*v12 + 272))(*v12, 0, "Radio Reset");
        v12 += 2;
      }
      while (v12 != v13);
    }
  }
  return result;
}

void sub_1010672B0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1010672D0(uint64_t a1)
{
  return sub_101067074((void *)(a1 - 24));
}

void sub_1010672D8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 208))
  {
    uint64_t v1 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      int v2 = 136315138;
      uint64_t v3 = "handleBasebandOn_sync";
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: handleBasebandOn_sync", (uint8_t *)&v2, 0xCu);
    }
  }
}

void sub_101067380(uint64_t a1)
{
}

uint64_t sub_101067388(uint64_t result)
{
  if (!*(unsigned char *)(result + 208))
  {
    uint64_t v1 = (PersonalitySpecificImpl *)result;
    int v2 = *(NSObject **)(result + 96);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315138;
      uint64_t v4 = "handleBasebandOff_sync";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: handleBasebandOff_sync", (uint8_t *)&v3, 0xCu);
    }
    (*(void (**)(PersonalitySpecificImpl *, void, void))(*(void *)v1 + 480))(v1, 0, 0);
    (*(void (**)(PersonalitySpecificImpl *, void, const char *))(*(void *)v1 + 584))(v1, 0, "Baseband Off");
    return sub_101061A54(v1);
  }
  return result;
}

uint64_t sub_1010674BC(uint64_t a1)
{
  return sub_101067388(a1 - 24);
}

uint64_t sub_1010674C4(uint64_t a1)
{
  return sub_101061C78(a1 - 24);
}

uint64_t sub_1010674CC(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v25 = 136315394;
    *(void *)&v25[4] = "airplaneModeChange";
    *(_WORD *)&v25[12] = 2080;
    *(void *)&v25[14] = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: airplane mode %s", v25, 0x16u);
  }
  if (a2)
  {
    sub_101060C24((uint64_t *)(a1 + 160));
    int v5 = *(uint64_t **)(a1 + 120);
    for (unint64_t i = *(uint64_t **)(a1 + 128); v5 != i; v5 += 2)
    {
      uint64_t v8 = *v5;
      uint64_t v7 = (std::__shared_weak_count *)v5[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v8)
      {
        *(void *)uint64_t v25 = 0;
        *(void *)&v25[8] = 0;
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)v8 + 224))(v25, v8, 0);
        BOOL v9 = !*(void *)v25 || !*(unsigned char *)(*(void *)v25 + 64);
        (*(void (**)(uint64_t, void, const char *, void, BOOL))(*(void *)v8 + 424))(v8, 0, "airplane mode", 0, v9);
        if (*(void *)&v25[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v25[8]);
        }
      }
      if (v7) {
        sub_10004D2C8(v7);
      }
    }
    uint64_t v10 = *(void *)(a1 + 56);
    if (v10)
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 264))(v10);
      uint64_t v12 = *(uint64_t **)v11;
      uint64_t v13 = *(uint64_t **)(v11 + 8);
      if (*(uint64_t **)v11 != v13)
      {
        do
        {
          uint64_t v14 = *v12;
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)a1 + 16))(v25, a1);
          (*(void (**)(uint64_t, void, unsigned char *, uint64_t, const char *))(*(void *)v14 + 248))(v14, 0, v25, 1, "CommCenter");
          if (*(void *)&v25[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v25[8]);
          }
          v12 += 2;
        }
        while (v12 != v13);
      }
    }
    int v15 = *(uint64_t **)(a1 + 120);
    for (uint64_t j = *(uint64_t **)(a1 + 128); v15 != j; v15 += 2)
    {
      uint64_t v17 = *v15;
      char v18 = (std::__shared_weak_count *)v15[1];
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v17) {
        (*(void (**)(uint64_t, void, uint64_t, const char *, const char *))(*(void *)v17 + 728))(v17, 0, 1, "Radio Disabled", "CommCenter");
      }
      if (v18) {
        sub_10004D2C8(v18);
      }
    }
    *(unsigned char *)(a1 + 282) = 1;
    uint64_t v19 = *(void *)(a1 + 56);
    if (!v19
      || (uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 264))(v19),
          uint64_t v21 = *(void **)v20,
          int v22 = *(void **)(v20 + 8),
          *(void **)v20 == v22))
    {
      __int16 v23 = "Airplane mode ON";
    }
    else
    {
      __int16 v23 = "Airplane mode ON";
      do
      {
        (*(void (**)(void, const char *))(*(void *)*v21 + 224))(*v21, "BBDataDriver::Airplane mode ON");
        v21 += 2;
      }
      while (v21 != v22);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 282) = 0;
    __int16 v23 = "Airplane off";
  }
  return (*(uint64_t (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, v23);
}

void sub_1010678BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101067900(void *a1, BOOL a2)
{
  return sub_1010674CC((uint64_t)a1 + *(void *)(*a1 - 288), a2);
}

uint64_t sub_101067920(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asStringBool(*(unsigned char *)(a1 + 280));
    int v20 = 136315394;
    *(void *)uint64_t v21 = v5;
    *(_WORD *)&v21[8] = 2080;
    *(void *)&v21[10] = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Service provisioned: %s ==>> %s", (uint8_t *)&v20, 0x16u);
  }
  *(unsigned char *)(a1 + 280) = a2;
  if (!a2)
  {
    sub_101060C24((uint64_t *)(a1 + 160));
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 264))(v6);
      uint64_t v8 = *(uint64_t **)v7;
      BOOL v9 = *(uint64_t **)(v7 + 8);
      if (*(uint64_t **)v7 != v9)
      {
        do
        {
          uint64_t v10 = *v8;
          (*(void (**)(int *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v20, a1);
          (*(void (**)(uint64_t, void, int *, uint64_t, const char *))(*(void *)v10 + 248))(v10, 0, &v20, 3, "CommCenter");
          if (*(void *)&v21[4]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v21[4]);
          }
          v8 += 2;
        }
        while (v8 != v9);
      }
    }
    uint64_t v11 = *(uint64_t **)(a1 + 120);
    for (unint64_t i = *(uint64_t **)(a1 + 128); v11 != i; v11 += 2)
    {
      uint64_t v13 = *v11;
      uint64_t v14 = (std::__shared_weak_count *)v11[1];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v13) {
        (*(void (**)(uint64_t, void, uint64_t, const char *, const char *))(*(void *)v13 + 728))(v13, 0, 3, "Service Provisioning change", "CommCenter");
      }
      if (v14) {
        sub_10004D2C8(v14);
      }
    }
  }
  uint64_t v15 = *(void *)(a1 + 56);
  if (v15)
  {
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 264))(v15);
    uint64_t v17 = *(void **)v16;
    char v18 = *(void **)(v16 + 8);
    if (*(void **)v16 != v18)
    {
      do
      {
        (*(void (**)(void, const char *))(*(void *)*v17 + 224))(*v17, "BBDataDriver::handleServiceProvisioned_sync");
        v17 += 2;
      }
      while (v17 != v18);
    }
  }
  return (*(uint64_t (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "Service Provisioning change");
}

void sub_101067C14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101067C44(uint64_t a1, BOOL a2)
{
  return sub_101067920(a1 - 24, a2);
}

void sub_101067C4C(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v10 = "handleDataAttachedRaw_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", buf, 0xCu);
  }
  sub_1010702C4((uint64_t)__p);
  BOOL v3 = sub_10106185C(a1, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(unsigned char *)(a1 + 281) = 1;
  sub_101065260(a1);
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 224))(v4, v5, 18, 1);
  sub_1010702C4((uint64_t)v7);
  int v6 = v3 ^ sub_10106185C(a1, (uint64_t)v7);
  if (v7[0])
  {
    v7[1] = v7[0];
    operator delete(v7[0]);
  }
  if (v6) {
    sub_101064B88((void *)a1, (uint64_t)"data attached (raw)");
  }
}

void sub_101067DBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (__p)
  {
    void *v12 = __p;
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101067DF0(uint64_t a1)
{
}

void sub_101067DF8(void *a1)
{
  int v2 = a1[12];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    char v18 = "handleDataNotAttachedRaw_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: ", buf, 0xCu);
  }
  sub_1010702C4((uint64_t)__p);
  BOOL v3 = sub_10106185C((uint64_t)a1, (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *((unsigned char *)a1 + 281) = 0;
  (*(void (**)(void *))(*a1 + 632))(a1);
  uint64_t v4 = a1[7];
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 264))(v4);
    int v6 = *(void **)v5;
    uint64_t v7 = *(void **)(v5 + 8);
    if (*(void **)v5 != v7)
    {
      do
      {
        (*(void (**)(void, const char *))(*(void *)*v6 + 224))(*v6, "BBDataDriver::handleDataNotAttachedRaw_sync");
        v6 += 2;
      }
      while (v6 != v7);
    }
  }
  uint64_t v8 = a1[7];
  uint64_t v9 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  sub_100058DB0(v14, "Data not attached (raw)");
  (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v8 + 72))(v8, v9, v14, 0);
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  uint64_t v10 = a1[7];
  uint64_t v11 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 80))(v10, v11, 17);
  sub_1010702C4((uint64_t)v13);
  int v12 = v3 ^ sub_10106185C((uint64_t)a1, (uint64_t)v13);
  if (v13[0])
  {
    v13[1] = v13[0];
    operator delete(v13[0]);
  }
  if (v12) {
    sub_101064B88(a1, (uint64_t)"data not attached (raw)");
  }
}

void sub_101068064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1010680B0(uint64_t a1)
{
}

uint64_t sub_1010680B8(uint64_t a1)
{
  if (*(int *)(a1 + 228) <= 0) {
    uint64_t v2 = dataContextSuspendMask();
  }
  else {
    uint64_t v2 = 0;
  }
  if (sub_101061690((Registry **)a1) && *(unsigned char *)(a1 + 418) && !*(unsigned char *)(a1 + 419)) {
    return dataContextSuspendMask() | v2;
  }
  return v2;
}

void sub_101068124(void *a1, int a2)
{
  uint64_t v4 = sub_1010680B8((uint64_t)a1) & a2;
  uint64_t v5 = a1[12];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    *(void *)uint64_t v17 = "suspendTimerProcedure";
    *(_WORD *)&uint8_t v17[8] = 1024;
    *(_DWORD *)&v17[10] = v4;
    __int16 v18 = 1024;
    int v19 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: mask %d (%d)", buf, 0x18u);
  }
  if (v4)
  {
    uint64_t v6 = a1[7];
    if (v6)
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 264))(v6);
      uint64_t v8 = *(void **)v7;
      uint64_t v9 = *(void **)(v7 + 8);
      if (*(void **)v7 != v9)
      {
        do
        {
          char v15 = 0;
          int v10 = (*(uint64_t (**)(void, uint64_t, char *))(*(void *)*v8 + 520))(*v8, 2, &v15);
          if (v15) {
            int v11 = 0;
          }
          else {
            int v11 = v10;
          }
          if (v11 == 1)
          {
            int v12 = a1[12];
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              int v13 = (*(uint64_t (**)(void))(*(void *)*v8 + 72))();
              *(_DWORD *)long long buf = 136315394;
              *(void *)uint64_t v17 = "operator()";
              *(_WORD *)&uint8_t v17[8] = 1024;
              *(_DWORD *)&v17[10] = v13;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: PDP %d is in active handover, postponing the suspend procedure", buf, 0x12u);
            }
          }
          else
          {
            uint64_t v14 = *v8;
            (*(void (**)(uint8_t *__return_ptr, void *))(*a1 + 16))(buf, a1);
            (*(void (**)(uint64_t, void, uint8_t *, uint64_t, uint64_t))(*(void *)v14 + 280))(v14, 0, buf, v4, 1);
            if (*(void *)&v17[4]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v17[4]);
            }
          }
          v8 += 2;
        }
        while (v8 != v9);
      }
    }
    (*(void (**)(void *, void, const char *))(*a1 + 584))(a1, 0, "Data suspend (no data).");
  }
}

void sub_1010683F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_101068418(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    BOOL v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = v3[12];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = 136315138;
          int v10 = "checkSuspendedNoData_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: suspend timer fired (no data)", (uint8_t *)&v9, 0xCu);
        }
        uint64_t v7 = v3[20];
        v3[20] = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        int v8 = dataContextSuspendMask();
        sub_101068124(v3, v8);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_101068530(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_101068544(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5] && !*(unsigned char *)(v3 + 419))
      {
        uint64_t v6 = *(NSObject **)(v3 + 96);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = 136315138;
          int v10 = "checkSuspendedBBCall_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: suspend timer fired (BBCall)", (uint8_t *)&v9, 0xCu);
        }
        uint64_t v7 = *(void *)(v3 + 168);
        *(void *)(v3 + 168) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        int v8 = dataContextSuspendMask();
        sub_101068124((void *)v3, v8);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_101068664(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101068678(uint64_t a1)
{
  uint64_t v2 = sub_1010680B8(a1);
  uint64_t v3 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "checkSuspended";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: mask %d", buf, 0x12u);
  }
  if ((dataContextSuspendMask() & v2) != 0)
  {
    uint64_t v4 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v6 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 432))(v5, v6);
    unint64_t NoDataSuspendDelayTimeout = getNoDataSuspendDelayTimeout((Registry **)(a1 + 40), v4, v7, v8);
    if (!*(void *)(a1 + 160))
    {
      unint64_t v10 = NoDataSuspendDelayTimeout;
      int v11 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "checkSuspendedNoData";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: scheduling suspend timer %lld secs", buf, 0x16u);
      }
      int v12 = *(std::__shared_weak_count **)(a1 + 72);
      if (!v12 || (uint64_t v13 = *(void *)(a1 + 64), (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
        sub_100088B9C();
      }
      char v15 = v14;
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      Registry::getTimerService(&v52, *(Registry **)(a1 + 40));
      uint64_t v16 = v52;
      sub_100058DB0(__p, "suspend delay timeout");
      uint64_t v17 = *(NSObject **)(a1 + 80);
      dispatch_object_t object = v17;
      if (v17) {
        dispatch_retain(v17);
      }
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_101068418;
      uint64_t v56 = &unk_101A83970;
      uint64_t v57 = a1;
      uint64_t v58 = v13;
      __int16 v59 = v15;
      atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlock = _Block_copy(buf);
      sub_100118A44(v16, (uint64_t)__p, 0, 1000000 * v10, &object, &aBlock);
      uint64_t v18 = v54;
      uint64_t v54 = 0;
      uint64_t v19 = *(void *)(a1 + 160);
      *(void *)(a1 + 160) = v18;
      if (v19)
      {
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        uint64_t v20 = v54;
        uint64_t v54 = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v51 < 0) {
        operator delete(__p[0]);
      }
      if (v53) {
        sub_10004D2C8(v53);
      }
      if (v59) {
        std::__shared_weak_count::__release_weak(v59);
      }
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if ((dataContextSuspendMask() & v2) != 0)
  {
    uint64_t v21 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t BBCallSuspendDelayTimeout = getBBCallSuspendDelayTimeout((Registry **)(a1 + 40), v21, v22);
    if (!*(void *)(a1 + 168))
    {
      uint64_t v24 = BBCallSuspendDelayTimeout;
      uint64_t v25 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = "checkSuspendedBBCall";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s: scheduling suspend timer %lld secs", buf, 0x16u);
      }
      unsigned __int8 v26 = *(std::__shared_weak_count **)(a1 + 72);
      if (!v26 || (uint64_t v27 = *(void *)(a1 + 64), (v28 = std::__shared_weak_count::lock(v26)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v29 = v28;
      atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      Registry::getTimerService(&v52, *(Registry **)(a1 + 40));
      uint64_t v30 = v52;
      sub_100058DB0(__p, "suspend delay timeout");
      uint64_t v31 = *(NSObject **)(a1 + 80);
      dispatch_object_t object = v31;
      if (v31) {
        dispatch_retain(v31);
      }
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 1174405120;
      *(void *)&uint8_t buf[16] = sub_101068544;
      uint64_t v56 = &unk_101A839A0;
      uint64_t v57 = a1;
      uint64_t v58 = v27;
      __int16 v59 = v29;
      atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      aBlock = _Block_copy(buf);
      sub_100118A44(v30, (uint64_t)__p, 0, 1000000 * v24 + 1000, &object, &aBlock);
      uint64_t v32 = v54;
      uint64_t v54 = 0;
      uint64_t v33 = *(void *)(a1 + 168);
      *(void *)(a1 + 168) = v32;
      if (v33)
      {
        (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
        uint64_t v34 = v54;
        uint64_t v54 = 0;
        if (v34) {
          (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v51 < 0) {
        operator delete(__p[0]);
      }
      if (v53) {
        sub_10004D2C8(v53);
      }
      if (v59) {
        std::__shared_weak_count::__release_weak(v59);
      }
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if ((dataContextSuspendMask() & v2) != 0)
  {
    uint64_t result = dataContextSuspendMask();
    if ((result & v2) != 0) {
      return result;
    }
  }
  else
  {
    uint64_t v36 = *(void *)(a1 + 160);
    *(void *)(a1 + 160) = 0;
    if (v36) {
      (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
    }
    if ((dataContextSuspendMask() & v2) != 0) {
      goto LABEL_55;
    }
  }
  uint64_t v37 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
  }
LABEL_55:
  __int16 v38 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "checkSuspended";
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s: Trying to resume Data", buf, 0xCu);
  }
  uint64_t v39 = *(void *)(a1 + 56);
  if (v39)
  {
    uint64_t v40 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 264))(v39);
    uint64_t v41 = *(void **)v40;
    uint64_t v42 = *(void **)(v40 + 8);
    if (*(void **)v40 != v42)
    {
      do
      {
        LOBYTE(__p[0]) = 0;
        int v43 = (*(uint64_t (**)(void, uint64_t, void **))(*(void *)*v41 + 520))(*v41, 2, __p);
        if (LOBYTE(__p[0])) {
          int v44 = 0;
        }
        else {
          int v44 = v43;
        }
        if (v44 == 1)
        {
          uint64_t v45 = *(NSObject **)(a1 + 96);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            int v46 = (*(uint64_t (**)(void))(*(void *)*v41 + 72))();
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = "operator()";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v46;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I %s: PDP %d is in active handover, postponing the resume procedure", buf, 0x12u);
          }
        }
        else
        {
          uint64_t v47 = *v41;
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)a1 + 16))(buf, a1);
          (*(void (**)(uint64_t, void, unsigned char *, uint64_t))(*(void *)v47 + 288))(v47, 0, buf, v2);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        v41 += 2;
      }
      while (v41 != v42);
    }
  }
  return (*(uint64_t (**)(uint64_t, void, const char *))(*(void *)a1 + 584))(a1, 0, "Data resume");
}

void sub_101068EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *aBlock, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101068F80(void *a1)
{
  return sub_101068678((uint64_t)a1 + *(void *)(*a1 - 160));
}

BOOL sub_101068F9C(uint64_t a1, BOOL a2, int a3)
{
  uint64_t v5 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(a2);
    uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 378));
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "setupConfiguration";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v6;
    __int16 v159 = 2080;
    uint64_t v160 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: setup config: modeCDMA=%s fUseCDMATetheringSettings = %s", buf, 0x20u);
  }
  int v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 144))(*(void *)(a1 + 104));
  bzero(buf, 0x240uLL);
  v155[0] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 40));
  int v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFArrayRef v148 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v148);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v19 = 1;
LABEL_11:
  uint64_t v20 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  (*(void (**)(_OWORD *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v18 + 96))(v153, v18, v20, 1, @"UseTetheringAuthenticationOnCDMA", kCFBooleanTrue, 0);
  sub_1000057AC(v155, (CFTypeRef *)v153);
  sub_1000577C4((const void **)v153);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  v148[0] = 0;
  ctu::cf::assign((ctu::cf *)v148, v155[0], v21);
  int v22 = v148[0];
  __int16 v23 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = "FALSE";
    if (v22) {
      uint64_t v24 = "TRUE";
    }
    *(_DWORD *)CFArrayRef v148 = 136315394;
    *(void *)&v148[4] = "shouldUseTetheringVerification";
    __int16 v149 = 2080;
    *(void *)__int16 v150 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s: shouldUseTetheringVerification() result is %s", v148, 0x16u);
  }
  sub_100062778((const void **)v155);
  int v140 = v22;
  if (v22)
  {
    uint64_t v25 = *(uint64_t **)(a1 + 120);
    unsigned __int8 v26 = *(uint64_t **)(a1 + 128);
    if (v25 == v26)
    {
      char v27 = 0;
      LOBYTE(v22) = 0;
    }
    else
    {
      int v22 = 0;
      char v27 = 0;
      do
      {
        uint64_t v28 = *v25;
        uint64_t v29 = (std::__shared_weak_count *)v25[1];
        if (v29) {
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v28)
        {
          char v30 = (*(uint64_t (**)(uint64_t, void))(*(void *)v28 + 312))(v28, 0);
          if ((v30 & 0x10) != 0) {
            char v27 = 1;
          }
          if ((v30 & 0x20) != 0) {
            int v22 = 1;
          }
        }
        if (v29) {
          sub_10004D2C8(v29);
        }
        v25 += 2;
      }
      while (v25 != v26);
    }
    LODWORD(v136) = v22;
    BYTE4(v136) = v27 & 1;
  }
  else
  {
    BOOL v136 = 0;
  }
  uint64_t v31 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = asStringBool(SBYTE4(v136));
    uint64_t v33 = asStringBool(v136);
    *(_DWORD *)CFArrayRef v148 = 136315650;
    *(void *)&v148[4] = "setupConfiguration";
    __int16 v149 = 2080;
    *(void *)__int16 v150 = v32;
    *(_WORD *)&v150[8] = 2080;
    *(void *)&v150[10] = v33;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s: setup config: wirelessTrafficIsPresent=%s wirelessAuthIsPresent = %s", v148, 0x20u);
  }
  int v144 = v8 & a2;
  uint64_t v34 = *(uint64_t **)(a1 + 120);
  __int16 v142 = *(uint64_t **)(a1 + 128);
  if (v34 != v142)
  {
    uint64_t v141 = a1 + 32;
    while (1)
    {
      uint64_t v35 = *v34;
      uint64_t v36 = (std::__shared_weak_count *)v34[1];
      if (v36) {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v35)
      {
        *(unsigned char *)(a1 + 377) = 0;
        unint64_t v37 = (*(uint64_t (**)(uint64_t, void))(*(void *)v35 + 312))(v35, 0);
        if (v37) {
          break;
        }
      }
LABEL_110:
      if (v36) {
        sub_10004D2C8(v36);
      }
      v34 += 2;
      if (v34 == v142) {
        goto LABEL_113;
      }
    }
    unint64_t v38 = 0;
    while (1)
    {
      if ((v37 & 1) == 0 || v38 == 9) {
        goto LABEL_98;
      }
      uint64_t v39 = &buf[16 * v38];
      if (*v39)
      {
        uint64_t v40 = *(NSObject **)(a1 + 96);
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_98;
        }
        uint64_t v41 = asString();
        *(_DWORD *)CFArrayRef v148 = 136315394;
        *(void *)&v148[4] = "setupConfiguration";
        __int16 v149 = 2080;
        *(void *)__int16 v150 = v41;
        uint64_t v42 = v40;
        int v43 = "#I %s: setup config: already set for %s";
        goto LABEL_48;
      }
      if (!v144)
      {
        int v46 = *(NSObject **)(a1 + 96);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v47 = asString();
          *(_DWORD *)CFArrayRef v148 = 136315394;
          *(void *)&v148[4] = "setupConfiguration";
          __int16 v149 = 2080;
          *(void *)__int16 v150 = v47;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I %s: setup config: set non-CDMA for %s", v148, 0x16u);
        }
        if (v36) {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *uint64_t v39 = v35;
        uint64_t v48 = &buf[16 * v38];
        uint64_t v49 = (std::__shared_weak_count *)*((void *)v48 + 1);
        *((void *)v48 + 1) = v36;
        if (!v49) {
          goto LABEL_98;
        }
        goto LABEL_97;
      }
      uint64_t v44 = 0;
      while (v38 != dword_1015B45B8[v44])
      {
        if (++v44 == 4)
        {
          uint64_t v45 = (int *)"12BBDataDriver";
          goto LABEL_61;
        }
      }
      uint64_t v45 = &dword_1015B45B8[v44];
LABEL_61:
      if ((char *)v45 - (char *)dword_1015B45B8 == 16) {
        break;
      }
      uint64_t v62 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v63 = asString();
        *(_DWORD *)CFArrayRef v148 = 136315394;
        *(void *)&v148[4] = "setupConfiguration";
        __int16 v149 = 2080;
        *(void *)__int16 v150 = v63;
        uint64_t v42 = v62;
        int v43 = "#I %s: setup config: Not setting %s for CDMA";
LABEL_48:
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v43, v148, 0x16u);
      }
LABEL_98:
      if (v37 >= 2)
      {
        v37 >>= 1;
        if (v38++ < 0x23) {
          continue;
        }
      }
      goto LABEL_110;
    }
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v141 + 272))(v141)) {
      goto LABEL_200;
    }
    char v51 = *(uint64_t **)(a1 + 120);
    int v50 = *(uint64_t **)(a1 + 128);
    if (v50 == v51) {
      goto LABEL_196;
    }
    if (!*v51)
    {
LABEL_200:
      if ((*(uint64_t (**)(uint64_t))(*(void *)v141 + 272))(v141)) {
        goto LABEL_98;
      }
      unsigned int v64 = *(uint64_t **)(a1 + 120);
      __int16 v65 = *(uint64_t **)(a1 + 128);
      if (v65 == v64) {
        goto LABEL_196;
      }
      if (!*v64) {
        goto LABEL_98;
      }
      log = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v66 = asString();
        *(_DWORD *)CFArrayRef v148 = 136315394;
        *(void *)&v148[4] = "setupConfiguration";
        __int16 v149 = 2080;
        *(void *)__int16 v150 = v66;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I %s: Setting Non-Data preferred SIM setting for connection %s", v148, 0x16u);
        unsigned int v64 = *(uint64_t **)(a1 + 120);
        __int16 v65 = *(uint64_t **)(a1 + 128);
      }
      if (v65 == v64) {
LABEL_196:
      }
        sub_10015B728();
      uint64_t v68 = *v64;
      uint64_t v67 = v64[1];
      if (!v67) {
        goto LABEL_86;
      }
LABEL_85:
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 8), 1uLL, memory_order_relaxed);
LABEL_86:
      *uint64_t v39 = v68;
      goto LABEL_96;
    }
    uint64_t v52 = *(void *)(a1 + 352);
    if (v140 && v52)
    {
      if (v38 == 4) {
        char v53 = BYTE4(v136);
      }
      else {
        char v53 = 0;
      }
      BOOL v54 = v136;
      if (v38 != 5) {
        BOOL v54 = 0;
      }
      if ((v53 & 1) != 0 || v54)
      {
        unsigned __int8 v55 = *(NSObject **)(a1 + 96);
        uint64_t v56 = *(void *)(a1 + 352);
        BOOL v57 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
        uint64_t v58 = v56;
        if (v57)
        {
          *(_DWORD *)CFArrayRef v148 = 136315138;
          *(void *)&v148[4] = "setupConfiguration";
          __int16 v59 = v55;
          uint64_t v60 = "#I %s: setup config: setting CDMA+Auth tethering data settings";
          uint32_t v61 = 12;
          goto LABEL_92;
        }
        goto LABEL_93;
      }
LABEL_88:
      if (*(unsigned char *)(a1 + 378))
      {
        uint64_t v69 = *(NSObject **)(a1 + 96);
        if (v140)
        {
          uint64_t v70 = *(NSObject **)(a1 + 96);
          uint64_t v71 = *(void *)(a1 + 352);
          BOOL v72 = os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT);
          uint64_t v58 = v71;
          if (v72)
          {
            uint64_t v73 = asString();
            *(_DWORD *)CFArrayRef v148 = 136315394;
            *(void *)&v148[4] = "setupConfiguration";
            __int16 v149 = 2080;
            *(void *)__int16 v150 = v73;
            __int16 v59 = v70;
            uint64_t v60 = "#I %s: setup config: setting tethering settings for %s";
            uint32_t v61 = 22;
LABEL_92:
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, v60, v148, v61);
            uint64_t v58 = *(void *)(a1 + 352);
          }
LABEL_93:
          uint64_t v67 = *(void *)(a1 + 360);
          if (v67) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 8), 1uLL, memory_order_relaxed);
          }
          *uint64_t v39 = v58;
LABEL_96:
          CFDictionaryRef v74 = &buf[16 * v38];
          uint64_t v49 = (std::__shared_weak_count *)*((void *)v74 + 1);
          *((void *)v74 + 1) = v67;
          if (!v49) {
            goto LABEL_98;
          }
LABEL_97:
          sub_10004D2C8(v49);
          goto LABEL_98;
        }
        logb = *(NSObject **)(a1 + 96);
        if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
        {
LABEL_106:
          if (v50 == v51) {
            goto LABEL_196;
          }
          uint64_t v68 = *v51;
          uint64_t v67 = v51[1];
          if (!v67) {
            goto LABEL_86;
          }
          goto LABEL_85;
        }
        *(_DWORD *)CFArrayRef v148 = 136315138;
        *(void *)&v148[4] = "setupConfiguration";
        _os_log_error_impl((void *)&_mh_execute_header, logb, OS_LOG_TYPE_ERROR, "%s: setup config: Tethering Auth has to be set in CDMA !", v148, 0xCu);
LABEL_104:
        char v51 = *(uint64_t **)(a1 + 120);
        int v50 = *(uint64_t **)(a1 + 128);
        goto LABEL_106;
      }
    }
    else if (v52)
    {
      goto LABEL_88;
    }
    loga = *(NSObject **)(a1 + 96);
    if (!os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_106;
    }
    uint64_t v76 = asString();
    *(_DWORD *)CFArrayRef v148 = 136315394;
    *(void *)&v148[4] = "setupConfiguration";
    __int16 v149 = 2080;
    *(void *)__int16 v150 = v76;
    _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, "#I %s: setup config: set CDMA for %s", v148, 0x16u);
    goto LABEL_104;
  }
LABEL_113:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 272))(a1 + 32)) {
    goto LABEL_149;
  }
  if (!*(void *)buf)
  {
    uint64_t v77 = *(uint64_t **)(a1 + 120);
    if (*(uint64_t **)(a1 + 128) == v77) {
      sub_10015B728();
    }
    uint64_t v79 = *v77;
    uint64_t v78 = v77[1];
    if (v78) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v78 + 8), 1uLL, memory_order_relaxed);
    }
    int v80 = *(std::__shared_weak_count **)&buf[8];
    *(void *)long long buf = v79;
    *(void *)&uint8_t buf[8] = v78;
    if (v80) {
      sub_10004D2C8(v80);
    }
  }
  if (v144)
  {
    uint64_t v81 = *(void *)(a1 + 312);
    if (v81)
    {
      char v82 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFArrayRef v148 = 136315138;
        *(void *)&v148[4] = "setupConfiguration";
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN configured with CDMA", v148, 0xCu);
        uint64_t v81 = *(void *)(a1 + 312);
      }
      uint64_t v83 = *(std::__shared_weak_count **)(a1 + 320);
      if (v83) {
        atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v84 = v162;
      uint64_t v161 = v81;
LABEL_133:
      long long v162 = v83;
      if (v84) {
        sub_10004D2C8(v84);
      }
      goto LABEL_135;
    }
  }
  CFTypeID v85 = *(uint64_t **)(a1 + 344);
  if (v85)
  {
    CFBooleanRef v86 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFArrayRef v148 = 136315138;
      *(void *)&v148[4] = "setupConfiguration";
      _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN configured", v148, 0xCu);
      CFTypeID v85 = *(uint64_t **)(a1 + 344);
    }
    uint64_t v87 = *v85;
    uint64_t v83 = (std::__shared_weak_count *)v85[1];
    if (v83) {
      atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v84 = v162;
    uint64_t v161 = v87;
    goto LABEL_133;
  }
LABEL_135:
  uint64_t v88 = *(void *)buf;
  uint64_t v89 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v90 = v164;
  uint64_t v163 = v88;
  std::string::size_type v164 = v89;
  if (v90)
  {
    sub_10004D2C8(v90);
    uint64_t v88 = v163;
  }
  if (!v88)
  {
    uint64_t v91 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFArrayRef v148 = 136315138;
      *(void *)&v148[4] = "setupConfiguration";
      _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "#I %s: BootstrapRoamingInternetBypass does not have settings configured", v148, 0xCu);
    }
  }
  uint64_t v92 = *(void *)buf;
  __int16 v93 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v94 = v166;
  uint64_t v165 = v92;
  long long v166 = v93;
  if (v94)
  {
    sub_10004D2C8(v94);
    uint64_t v92 = v165;
  }
  if (!v92)
  {
    uint64_t v95 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)CFArrayRef v148 = 136315138;
      *(void *)&v148[4] = "setupConfiguration";
      _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I %s: kDataConnectionInternetProbe does not have settings configured", v148, 0xCu);
    }
  }
LABEL_149:
  uint64_t v96 = 0;
  int v157 = 0;
  *(_OWORD *)CFAllocatorRef v155 = 0u;
  long long v156 = 0u;
  memset(v153, 0, sizeof(v153));
  uint64_t v97 = (long long *)buf;
  int v154 = 0;
  do
  {
    if (v96 == 19 && a3)
    {
      uint64_t v98 = *(NSObject **)(a1 + 96);
      if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_166;
      }
      *(_DWORD *)CFArrayRef v148 = 136315138;
      *(void *)&v148[4] = "setupConfiguration";
      std::string v99 = v98;
      uint64_t v100 = "#I %s: skip bootstrap on first setup";
      uint32_t v101 = 12;
      goto LABEL_161;
    }
    if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 56) + 96))(*(void *)(a1 + 56), v96))
    {
      long long v102 = *(uint64_t (****)(void, void, uint64_t, uint64_t, long long *, char *))(a1 + 56);
      uint64_t v103 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      long long v104 = *v97;
      long long v147 = v104;
      if (*((void *)&v104 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v104 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      char v105 = (**v102)(v102, 0, v103, v96, &v147, (char *)v153 + v96);
      *((unsigned char *)v155 + v96) = v105;
      if (*((void *)&v147 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v147 + 1));
      }
      uint64_t v106 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v107 = asStringBool(v105);
        uint64_t v108 = asStringBool(*((unsigned char *)v153 + v96));
        uint64_t v109 = asStringBool(*(void *)v97 != 0);
        *(_DWORD *)CFArrayRef v148 = 136316162;
        *(void *)&v148[4] = "setupConfiguration";
        __int16 v149 = 1024;
        *(_DWORD *)__int16 v150 = v96;
        *(_WORD *)&v150[4] = 2080;
        *(void *)&v150[6] = v107;
        *(_WORD *)&v150[14] = 2080;
        *(void *)&v150[16] = v108;
        __int16 v151 = 2080;
        uint64_t v152 = v109;
        std::string v99 = v106;
        uint64_t v100 = "#I %s: supportedDataConnection %d: toReactivate = %s : settingsChanged = %s : configuration present: %s";
        uint32_t v101 = 48;
LABEL_161:
        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, v100, v148, v101);
      }
    }
    else
    {
      char v110 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v111 = asString();
        *(_DWORD *)CFArrayRef v148 = 136315394;
        *(void *)&v148[4] = "setupConfiguration";
        __int16 v149 = 2080;
        *(void *)__int16 v150 = v111;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I %s: %s is configured but not supported at this moment", v148, 0x16u);
      }
      *((unsigned char *)v155 + v96) = 0;
      char v112 = *(void (****)(void, void, uint64_t, uint64_t, uint64_t *, char *))(a1 + 56);
      uint64_t v113 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      uint64_t v145 = 0;
      CFNumberRef v146 = 0;
      (**v112)(v112, 0, v113, v96, &v145, (char *)v153 + v96);
      if (v146) {
        sub_10004D2C8(v146);
      }
    }
LABEL_166:
    ++v96;
    ++v97;
  }
  while (v96 != 36);
  uint64_t v114 = 0;
  std::string v115 = buf;
  do
  {
    uint64_t v116 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v117 = asStringBool(*((unsigned char *)v155 + v114));
      uint64_t v118 = asStringBool(*((unsigned char *)v153 + v114));
      uint64_t v119 = asStringBool(*v115 != 0);
      *(_DWORD *)CFArrayRef v148 = 136316162;
      *(void *)&v148[4] = "setupConfiguration";
      __int16 v149 = 1024;
      *(_DWORD *)__int16 v150 = v114;
      *(_WORD *)&v150[4] = 2080;
      *(void *)&v150[6] = v117;
      *(_WORD *)&v150[14] = 2080;
      *(void *)&v150[16] = v118;
      __int16 v151 = 2080;
      uint64_t v152 = v119;
      _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "#I %s: reactivate %d: toReactivate = %s : settingsChanged = %s : configuration present: %s", v148, 0x30u);
    }
    uint64_t v120 = *(void *)(a1 + 56);
    uint64_t v121 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    (*(void (**)(uint64_t, uint64_t, void, void, uint64_t))(*(void *)v120 + 40))(v120, v121, *((unsigned __int8 *)v153 + v114), *((unsigned __int8 *)v155 + v114), v114);
    ++v114;
    v115 += 2;
  }
  while (v114 != 36);
  char v122 = *(uint64_t **)(a1 + 120);
  for (unint64_t i = *(uint64_t **)(a1 + 128); v122 != i; v122 += 2)
  {
    uint64_t v124 = *v122;
    uint64_t v125 = (std::__shared_weak_count *)v122[1];
    if (v125) {
      atomic_fetch_add_explicit(&v125->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v124) {
      (*(void (**)(uint64_t, void))(*(void *)v124 + 832))(v124, 0);
    }
    if (v125) {
      sub_10004D2C8(v125);
    }
  }
  uint64_t v126 = *(void *)(a1 + 296);
  if (v126) {
    (*(void (**)(uint64_t, void))(*(void *)v126 + 832))(v126, 0);
  }
  uint64_t v127 = *(void *)(a1 + 312);
  if (v127) {
    (*(void (**)(uint64_t, void))(*(void *)v127 + 832))(v127, 0);
  }
  uint64_t v128 = *(void *)(a1 + 328);
  if (v128) {
    (*(void (**)(uint64_t, void))(*(void *)v128 + 832))(v128, 0);
  }
  uint64_t v129 = *(void *)(a1 + 352);
  if (v129) {
    (*(void (**)(uint64_t, void))(*(void *)v129 + 832))(v129, 0);
  }
  uint64_t v130 = 0;
  do
  {
    int v131 = *((unsigned __int8 *)v153 + v130);
    if (*((unsigned char *)v153 + v130)) {
      break;
    }
  }
  while (v130++ != 35);
  for (uint64_t j = 568; j != -8; j -= 16)
  {
    uint64_t v134 = *(std::__shared_weak_count **)&buf[j];
    if (v134) {
      sub_10004D2C8(v134);
    }
  }
  return v131 != 0;
}

void sub_10106A0F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (v45) {
    sub_10004D2C8(v45);
  }
  uint64_t v47 = 568;
  while (1)
  {
    uint64_t v48 = *(std::__shared_weak_count **)(&a45 + v47);
    if (v48) {
      sub_10004D2C8(v48);
    }
    v47 -= 16;
    if (v47 == -8) {
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_10106A1EC(PersonalitySpecificImpl *a1)
{
  unint64_t v2 = sub_10106A400((uint64_t)a1);
  if (v3)
  {
    uint64_t v4 = v2;
    uint64_t v5 = *((void *)a1 + 12);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315394;
      uint64_t v7 = "updateCurrentImsPrefOnAllConnections";
      __int16 v8 = 2048;
      uint64_t v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: got IMS pref matching current data mode, send IMS pref(%lu).", (uint8_t *)&v6, 0x16u);
    }
    sub_10106A650(a1, v4);
  }
  else
  {
    sub_10106A81C(a1);
  }
}

void sub_10106A300(uint64_t a1, int *a2)
{
  xpc_object_t v8 = 0;
  unint64_t v2 = (ctu::rest::detail *)*a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/data_service_config_refreshed");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_10106A3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_10106A3E8(uint64_t a1, unsigned int a2, BOOL a3)
{
}

uint64_t sub_10106A3F0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 292);
}

uint64_t sub_10106A3F8(uint64_t a1)
{
  return sub_101061A54((PersonalitySpecificImpl *)(a1 - 24));
}

unint64_t sub_10106A400(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 848))(a1))
  {
    if ((*(unsigned char *)(a1 + 272) & 1) != 0
      || !DataUtils::lteishDataMode()
      || (uint64_t v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1),
          (CarrierAssignedVoLTEServiceMask = getCarrierAssignedVoLTEServiceMask((Registry **)(a1 + 40), v2)) == 0))
    {
      CarrierAssignedVoLTEServiceMask = *(unsigned int **)(a1 + 272);
    }
    unint64_t v4 = (unint64_t)CarrierAssignedVoLTEServiceMask & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    unint64_t v4 = 0;
    LOBYTE(CarrierAssignedVoLTEServiceMask) = 0;
  }
  return CarrierAssignedVoLTEServiceMask | v4;
}

void sub_10106A4A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    asString();
    char v7 = v12 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = "handleImsPrefUpdate_sync";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    __int16 v14 = 2048;
    uint64_t v15 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: got IMS pref from BB for %s, %llu.", buf, 0x20u);
    if (v12 < 0) {
      operator delete(__p);
    }
  }
  if (!*(unsigned char *)(a1 + 208))
  {
    if (a1 + 248 != a2) {
      sub_10008A534((char *)(a1 + 248), *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    }
    *(void *)(a1 + 272) = a3;
    if (a3 | ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2)) {
      sub_10106A1EC((PersonalitySpecificImpl *)a1);
    }
    else {
      sub_10106A650((PersonalitySpecificImpl *)a1, 0);
    }
    *(void *)long long buf = sub_10106A400(a1);
    *(void *)&uint8_t buf[8] = v8;
    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      uint64_t v10 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v9 + 328))(v9, v10, buf);
    }
  }
}

void sub_10106A650(PersonalitySpecificImpl *a1, uint64_t a2)
{
  unint64_t v4 = *((void *)a1 + 12);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    uint64_t v8 = "updateCurrentImsPrefOnAllConnections";
    __int16 v9 = 2048;
    uint64_t v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: %lu", (uint8_t *)&v7, 0x16u);
  }
  uint64_t v5 = *((void *)a1 + 7);
  if (v5)
  {
    uint64_t v6 = PersonalitySpecificImpl::simSlot(a1);
    (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v5 + 320))(v5, v6, 0, a2);
  }
}

void sub_10106A758(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_10106A760(uint64_t a1)
{
  uint64_t v3 = *(_DWORD **)(a1 + 248);
  uint64_t v2 = *(_DWORD **)(a1 + 256);
  if (v3 != v2)
  {
    while (*v3 != *(_DWORD *)(a1 + 232))
    {
      if (++v3 == v2)
      {
        uint64_t v3 = *(_DWORD **)(a1 + 256);
        break;
      }
    }
  }
  if (v3 != v2) {
    return 1;
  }
  uint64_t result = capabilities::ct::supports5G((capabilities::ct *)a1);
  if (result)
  {
    uint64_t result = DataUtils::lteishDataMode();
    if (result)
    {
      if (*(_DWORD *)(a1 + 240) == 7)
      {
        uint64_t v6 = *(_DWORD **)(a1 + 248);
        uint64_t v5 = *(_DWORD **)(a1 + 256);
        if (v6 != v5)
        {
          while (*v6 != 14)
          {
            if (++v6 == v5)
            {
              uint64_t v6 = *(_DWORD **)(a1 + 256);
              return v6 != v5;
            }
          }
        }
        return v6 != v5;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10106A814(uint64_t a1)
{
  return sub_10106A760(a1 - 24);
}

void sub_10106A81C(PersonalitySpecificImpl *a1)
{
  sub_10106A400((uint64_t)a1);
  if (!v2)
  {
    uint64_t v3 = *((void *)a1 + 7);
    if (!v3
      || (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3),
          uint64_t v5 = *(uint64_t **)v4,
          uint64_t v6 = *(uint64_t **)(v4 + 8),
          *(uint64_t **)v4 == v6))
    {
LABEL_11:
      __int16 v9 = *((void *)a1 + 12);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 136315138;
        int v11 = "checkUnmatchedIMSPref";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: There is no IMS pref matching current data mode yet, and no activated IMS Context, send IMS pref as 0.", (uint8_t *)&v10, 0xCu);
      }
      sub_10106A650(a1, 0);
    }
    else
    {
      while (1)
      {
        uint64_t v8 = *v5;
        int v7 = (std::__shared_weak_count *)v5[1];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if ((*(unsigned int (**)(uint64_t, void))(*(void *)v8 + 312))(v8, 0)
          && ((*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 320))(v8, 0) & 1) == 0)
        {
          break;
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
        v5 += 2;
        if (v5 == v6) {
          goto LABEL_11;
        }
      }
      if (v7)
      {
        sub_10004D2C8(v7);
      }
    }
  }
}

void sub_10106AA0C(_Unwind_Exception *exception_object)
{
}

void sub_10106AA2C(void *a1@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = a1[7];
  if (v3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (void **)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    unint64_t v37 = 0;
    unint64_t v38 = 0;
    uint64_t v39 = 0;
    sub_101070334(&v37, *v5, v5[1], ((char *)v5[1] - (char *)*v5) >> 4);
    uint64_t v6 = v37;
    int v7 = v38;
    if (v37 != v38)
    {
      uint64_t v8 = 0;
      uint64_t v29 = v38;
      char v30 = v4;
      do
      {
        uint64_t v11 = *v6;
        int v10 = (std::__shared_weak_count *)v6[1];
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        lpsrc = 0;
        uint64_t v36 = 0;
        (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v33, a1);
        (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t *))(*(void *)v11 + 496))(&lpsrc, v11, 0, &v33);
        if (v34) {
          sub_10004D2C8(v34);
        }
        if (lpsrc)
        {
          if (v12)
          {
            uint64_t v13 = v36;
            if (v36) {
              atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            long long v32 = 0uLL;
            (*(void (**)(long long *__return_ptr))(*(void *)v12 + 664))(&v32);
            __int16 v14 = (std::__shared_weak_count *)*((void *)&v32 + 1);
            if ((void)v32)
            {
              unint64_t v15 = (unint64_t)v4[2];
              if ((unint64_t)v8 >= v15)
              {
                uint64_t v17 = v9;
                uint64_t v18 = *v4;
                uint64_t v19 = (v8 - *v4) >> 4;
                unint64_t v20 = v19 + 1;
                if ((unint64_t)(v19 + 1) >> 60) {
                  sub_10006A748();
                }
                long long v31 = v32;
                uint64_t v21 = v15 - (void)v18;
                if (v21 >> 3 > v20) {
                  unint64_t v20 = v21 >> 3;
                }
                if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v20;
                }
                if (v22 >> 60) {
                  sub_10006A7CC();
                }
                __int16 v23 = (char *)operator new(16 * v22);
                uint64_t v24 = &v23[16 * v19];
                *(_OWORD *)uint64_t v24 = v31;
                if (v14) {
                  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v25 = &v23[16 * v22];
                uint64_t v16 = v24 + 16;
                if (v8 == v18)
                {
                  uint64_t v4 = v30;
                  *char v30 = v24;
                  v30[1] = v16;
                  v30[2] = v25;
                }
                else
                {
                  uint64_t v4 = v30;
                  do
                  {
                    long long v26 = *((_OWORD *)v8 - 1);
                    v8 -= 16;
                    *((_OWORD *)v24 - 1) = v26;
                    v24 -= 16;
                    *(void *)uint64_t v8 = 0;
                    *((void *)v8 + 1) = 0;
                  }
                  while (v8 != v18);
                  uint64_t v8 = *v30;
                  char v27 = v30[1];
                  *char v30 = v24;
                  v30[1] = v16;
                  v30[2] = v25;
                  while (v27 != v8)
                  {
                    uint64_t v28 = (std::__shared_weak_count *)*((void *)v27 - 1);
                    if (v28) {
                      sub_10004D2C8(v28);
                    }
                    v27 -= 16;
                  }
                }
                __int16 v9 = v17;
                if (v8) {
                  operator delete(v8);
                }
                int v7 = v29;
              }
              else
              {
                *(_OWORD *)uint64_t v8 = v32;
                if (v14) {
                  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v16 = v8 + 16;
              }
              v4[1] = v16;
              __int16 v14 = (std::__shared_weak_count *)*((void *)&v32 + 1);
              uint64_t v8 = v16;
            }
            if (v14) {
              sub_10004D2C8(v14);
            }
            if (v13) {
              sub_10004D2C8(v13);
            }
          }
        }
        if (v36) {
          sub_10004D2C8(v36);
        }
        if (v10) {
          sub_10004D2C8(v10);
        }
        v6 += 2;
      }
      while (v6 != v7);
    }
    lpsrc = &v37;
    sub_10005CBF0((void ***)&lpsrc);
  }
}

void sub_10106AD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void **a20)
{
  a20 = v20;
  sub_10077EE24(&a20);
  _Unwind_Resume(a1);
}

void sub_10106AE14(uint64_t a1@<X0>, char **a2@<X8>)
{
}

uint64_t sub_10106AE1C(PersonalitySpecificImpl *a1, int a2)
{
  uint64_t result = *((void *)a1 + 7);
  if (result)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)result + 264))(result);
    uint64_t v6 = *(void **)v5;
    int v7 = *(void **)(v5 + 8);
    while (1)
    {
      if (v6 == v7) {
        return 0;
      }
      if ((*(unsigned int (**)(void))(*(void *)*v6 + 72))() == a2
        && (*(unsigned int (**)(void, void))(*(void *)*v6 + 152))(*v6, 0))
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        (*(void (**)(uint64_t *__return_ptr))(*(void *)*v6 + 576))(&v10);
        if (v10)
        {
          int v8 = *(_DWORD *)(v10 + 52);
          int v9 = v8 == PersonalitySpecificImpl::simSlot(a1);
        }
        else
        {
          int v9 = 3;
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (v9 != 3 && v9) {
          break;
        }
      }
      v6 += 2;
    }
    return 1;
  }
  return result;
}

void sub_10106AF80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10106AF98(uint64_t a1, int a2)
{
  return sub_10106AE1C((PersonalitySpecificImpl *)(a1 - 24), a2);
}

uint64_t sub_10106AFA0(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 248))(&v3);
  if (v3) {
    uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  else {
    uint64_t v1 = 0;
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v1;
}

void sub_10106B038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106B050(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 4;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *a1 + 16 * a2;
      while (v3 != v6)
      {
        int v7 = *(std::__shared_weak_count **)(v3 - 8);
        if (v7) {
          sub_10004D2C8(v7);
        }
        v3 -= 16;
      }
      a1[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    sub_1010703FC(a1, v5);
  }
}

void sub_10106B0E0()
{
}

void sub_10106B26C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[6], v1, (dispatch_function_t)sub_1010706DC);
  __cxa_rethrow();
}

void sub_10106B294(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void sub_10106B2E0()
{
}

void sub_10106B448(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[6], v1, (dispatch_function_t)sub_1010707A4);
  __cxa_rethrow();
}

void sub_10106B470(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(a1);
}

void sub_10106B4BC(uint64_t a1, int a2)
{
}

uint64_t sub_10106B4C4(uint64_t a1, char a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 144))(*(void *)(a1 + 104));
  if (result)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 256))(a1) == 2)
    {
      *(unsigned char *)(a1 + 378) = a2;
      sub_101068F9C(a1, 1, 0);
      return 0;
    }
    else
    {
      unint64_t v5 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315138;
        int v7 = "useTetheringSettings";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: no tethering settings switch needed while not on CDMA", (uint8_t *)&v6, 0xCu);
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_10106B5F0(uint64_t a1, char a2)
{
  return sub_10106B4C4(a1 - 24, a2);
}

uint64_t sub_10106B5F8(PersonalitySpecificImpl *a1, int a2)
{
  if (a2)
  {
    if ((*(unsigned int (**)(PersonalitySpecificImpl *))(*(void *)a1 + 256))(a1) == 2
      || !*((void *)a1 + 41))
    {
      return 0;
    }
    uint64_t v3 = (void *)((char *)a1 + 328);
    unint64_t v4 = *((void *)a1 + 12);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v26 = "useOTASettings";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: 'native' OTA APN used", buf, 0xCu);
    }
  }
  else
  {
    unint64_t v5 = *((void *)a1 + 12);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v26 = "useOTASettings";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: OTA APN assigned internet settings (2)", buf, 0xCu);
    }
    uint64_t v3 = (void *)((char *)a1 + 296);
  }
  *((void *)a1 + 43) = v3;
  buf[0] = 0;
  if ((*(unsigned int (**)(void))(**((void **)a1 + 13) + 144))(*((void *)a1 + 13))
    && (*(unsigned int (**)(PersonalitySpecificImpl *))(*(void *)a1 + 256))(a1) == 2
    && *((void *)a1 + 39))
  {
    int v6 = (uint64_t (***)(void, void, uint64_t, uint64_t, uint64_t *, uint8_t *))*((void *)a1 + 7);
    uint64_t v7 = PersonalitySpecificImpl::simSlot(a1);
    int v8 = (std::__shared_weak_count *)*((void *)a1 + 40);
    uint64_t v23 = *((void *)a1 + 39);
    uint64_t v24 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = (**v6)(v6, 0, v7, 9, &v23, buf);
    if (v24) {
      sub_10004D2C8(v24);
    }
    uint64_t v10 = *((void *)a1 + 7);
    uint64_t v11 = PersonalitySpecificImpl::simSlot(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 40))(v10, v11, 1, v9, 9);
  }
  else
  {
    char v12 = (uint64_t (***)(void, void, uint64_t, uint64_t, uint64_t *, uint8_t *))*((void *)a1 + 7);
    uint64_t v13 = PersonalitySpecificImpl::simSlot(a1);
    __int16 v14 = (uint64_t *)*((void *)a1 + 43);
    uint64_t v16 = *v14;
    unint64_t v15 = (std::__shared_weak_count *)v14[1];
    uint64_t v21 = v16;
    unint64_t v22 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v17 = (**v12)(v12, 0, v13, 9, &v21, buf);
    if (v22) {
      sub_10004D2C8(v22);
    }
    uint64_t v18 = *((void *)a1 + 7);
    uint64_t v19 = PersonalitySpecificImpl::simSlot(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 40))(v18, v19, 1, v17, 9);
  }
  return 1;
}

void sub_10106B930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10106B960(uint64_t a1, int a2)
{
  return sub_10106B5F8((PersonalitySpecificImpl *)(a1 - 24), a2);
}

void sub_10106B968(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[7];
  if (v3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    int v6 = *(uint64_t **)v5;
    uint64_t v7 = *(uint64_t **)(v5 + 8);
    if (*(uint64_t **)v5 != v7)
    {
      do
      {
        uint64_t v8 = *v6;
        (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v9, a1);
        (*(void (**)(uint64_t, void, uint64_t *, uint64_t, const char *))(*(void *)v8 + 248))(v8, 0, &v9, a2, "CommCenter");
        if (v10) {
          sub_10004D2C8(v10);
        }
        v6 += 2;
      }
      while (v6 != v7);
    }
  }
}

void sub_10106BA6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106BA84(void *a1, uint64_t a2)
{
}

void *sub_10106BAA0(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[13];
  if (v3)
  {
    sub_1000F0058((uint64_t)v5, a2);
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v3 + 112))(v3, v5, a3);
    return sub_10003B34C(v5);
  }
  return result;
}

void sub_10106BB3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10106BB58(void *a1, uint64_t a2, uint64_t a3)
{
  return sub_10106BAA0((void *)((char *)a1 + *(void *)(*a1 - 256)), a2, a3);
}

void sub_10106BB74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 104);
    v3();
  }
  else
  {
    unint64_t v4 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "invalid fCmdDriver", v5, 2u);
    }
  }
}

void sub_10106BC24(void *a1)
{
}

void sub_10106BC40(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 120);
    v3();
  }
  else
  {
    unint64_t v4 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "invalid fCmdDriver", v5, 2u);
    }
  }
}

void sub_10106BCF0(void *a1)
{
}

void sub_10106BD0C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v7 = (void **)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 264))(v4);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  char v12 = 0;
  sub_101070334(&v12, *v7, v7[1], ((char *)v7[1] - (char *)*v7) >> 4);
  uint64_t v8 = v12;
  uint64_t v9 = v13;
  if (v12 == v13)
  {
    char v10 = 0;
  }
  else
  {
    char v10 = 0;
    do
    {
      if ((*(unsigned int (**)(void))(*(void *)*v8 + 72))() == a3)
      {
        (*(void (**)(void, uint64_t))(*(void *)*v8 + 80))(*v8, a2);
        char v10 = 1;
      }
      v8 += 2;
    }
    while (v8 != v9);
  }
  unint64_t v15 = (void **)&v12;
  sub_10005CBF0(&v15);
  if ((v10 & 1) == 0)
  {
LABEL_10:
    uint64_t v11 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Error: matching pdpId not found!", (uint8_t *)&v12, 2u);
    }
  }
}

void sub_10106BE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10005CBF0(&a12);
  _Unwind_Resume(a1);
}

void sub_10106BE98(uint64_t a1, uint64_t a2, int a3)
{
}

uint64_t sub_10106BEA0(PersonalitySpecificImpl *a1)
{
  uint64_t v2 = *((void *)a1 + 7);
  if (v2)
  {
    uint64_t v3 = (void **)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 264))(v2);
    memset(buf, 0, sizeof(buf));
    sub_101070334(buf, *v3, v3[1], ((char *)v3[1] - (char *)*v3) >> 4);
    uint64_t v4 = *(uint64_t **)buf;
    uint64_t v5 = *(uint64_t **)&buf[8];
    if (*(void *)buf == *(void *)&buf[8])
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 0;
      do
      {
        uint64_t v8 = *v4;
        uint64_t v7 = (std::__shared_weak_count *)v4[1];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (((*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 320))(v8, 0) & 1) == 0)
        {
          (*(void (**)(uint8_t **__return_ptr, uint64_t))(*(void *)v8 + 576))(&v18, v8);
          (*(void (**)(uint64_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)a1 + 16))(&v16, a1);
          int matched = DataUtils::matchPersonality();
          if (v17) {
            sub_10004D2C8(v17);
          }
          if (v19) {
            sub_10004D2C8(v19);
          }
          uint64_t v6 = (v6 + matched);
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
        v4 += 2;
      }
      while (v4 != v5);
    }
    uint64_t v18 = buf;
    sub_10005CBF0((void ***)&v18);
  }
  else
  {
    uint64_t v6 = 0;
  }
  int v10 = *((_DWORD *)a1 + 92);
  if (v10 != v6)
  {
    uint64_t v11 = *((void *)a1 + 12);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = "countActiveContexts";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v6;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: activeContextsCnt changing from %d to %d", buf, 0x18u);
    }
    *((_DWORD *)a1 + 92) = v6;
    uint64_t v12 = *((void *)a1 + 7);
    uint64_t v13 = PersonalitySpecificImpl::simSlot(a1);
    uint64_t v14 = (unsigned int *)((char *)a1 + 368);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 336))(v12, v13, *v14);
    return *v14;
  }
  return v6;
}

void sub_10106C140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_10106C19C(void *a1)
{
  return sub_10106BEA0((PersonalitySpecificImpl *)((char *)a1 + *(void *)(*a1 - 240)));
}

uint64_t sub_10106C1B8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 368);
}

uint64_t sub_10106C1C0(void *a1)
{
  return *(unsigned int *)((char *)a1 + *(void *)(*a1 - 248) + 368);
}

void sub_10106C1E8(uint64_t a1, BOOL a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "handleDataContextDeactivated";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = asStringBool(a2);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn: isImsSupported = %s", buf, 0x16u);
  }
  if (a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "handleDataContextDeactivated";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: IMS context went down.", buf, 0xCu);
    }
    sub_10106A81C((PersonalitySpecificImpl *)a1);
  }
  (*(void (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56));
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  _OWORD v11[2] = sub_10106C428;
  v11[3] = &unk_101A839D0;
  void v11[4] = a1;
  BOOL v12 = a2;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v6 || (uint64_t v7 = *(void *)(a1 + 64), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  int v10 = *(NSObject **)(a1 + 80);
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 1174405120;
  *(void *)&uint8_t buf[16] = sub_101071EC4;
  uint64_t v14 = &unk_101A84E40;
  uint64_t v16 = v7;
  uint64_t v17 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v15 = v11;
  dispatch_async(v10, buf);
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_10004D2C8(v9);
}

void sub_10106C41C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10106C428(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 96);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asStringBool(*(unsigned char *)(a1 + 40));
    int v7 = 136315394;
    uint64_t v8 = "handleDataContextDeactivated_block_invoke";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn: isImsSupported = %s", (uint8_t *)&v7, 0x16u);
  }
  sub_1010640FC(v2, 0xEu, 0);
  uint64_t v5 = *(NSObject **)(v2 + 96);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 40));
    int v7 = 136315394;
    uint64_t v8 = "handleDataContextDeactivated_block_invoke";
    __int16 v9 = 2080;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: (3) refreshapn: isImsSupported = %s", (uint8_t *)&v7, 0x16u);
  }
}

void sub_10106C55C(void *a1, BOOL a2)
{
}

uint64_t sub_10106C578(uint64_t a1)
{
  return *(unsigned int *)(a1 + 228);
}

uint64_t sub_10106C580(void *a1)
{
  return *(unsigned int *)((char *)a1 + *(void *)(*a1 - 208) + 228);
}

uint64_t sub_10106C5A0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

uint64_t sub_10106C5A8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 208);
}

uint64_t sub_10106C5B0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 236);
}

uint64_t sub_10106C5B8(void *a1)
{
  return *(unsigned int *)((char *)a1 + *(void *)(*a1 - 216) + 236);
}

uint64_t sub_10106C5D8(capabilities::ipc *a1)
{
  uint64_t v2 = (capabilities::ipc *)capabilities::ipc::supportsHSIC(a1);
  int v3 = (int)v2;
  int v4 = capabilities::ipc::supportsPCI(v2);
  uint64_t v5 = *((void *)a1 + 7);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 264))(v5);
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  if (*v6 == v8) {
    return 0;
  }
  LODWORD(v9) = 0;
  char v10 = 0;
  int v11 = v3 | v4;
  do
  {
    BOOL v12 = *(std::__shared_weak_count **)(v7 + 8);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      if (v11) {
        int v13 = 1 << v10;
      }
      else {
        int v13 = 0;
      }
      sub_10004D2C8(v12);
    }
    else if (v11)
    {
      int v13 = 1 << v10;
    }
    else
    {
      int v13 = 0;
    }
    uint64_t v9 = v13 | v9;
    ++v10;
    v7 += 16;
  }
  while (v7 != v8);
  return v9;
}

uint64_t sub_10106C6C0(void *a1)
{
  return sub_10106C5D8((capabilities::ipc *)((char *)a1 + *(void *)(*a1 - 80)));
}

void sub_10106C6DC(PersonalitySpecificImpl *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = *((void *)a1 + 12);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asString();
    asStringDataSoMask((uint64_t *)__p, HIDWORD(a2));
    int v8 = v20;
    uint64_t v9 = (void **)__p[0];
    uint64_t v10 = asStringBool(a3 & 1);
    *(void *)unint64_t v22 = "updateDataBearerInfo";
    int v11 = __p;
    *(_DWORD *)long long buf = 136316162;
    if (v8 < 0) {
      int v11 = v9;
    }
    *(_WORD *)&unsigned char v22[8] = 2080;
    *(void *)&v22[10] = v7;
    __int16 v23 = 2082;
    uint64_t v24 = v11;
    __int16 v25 = 1024;
    int v26 = HIDWORD(a2);
    __int16 v27 = 2080;
    uint64_t v28 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: The data bearer data mode is: %s, soMask is: %{public}s (%u), available: %s", buf, 0x30u);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  (*(void (**)(PersonalitySpecificImpl *, uint64_t, void))(*(void *)a1 + 480))(a1, a2, a3);
  sub_1010640FC((uint64_t)a1, 0xDu, 0);
  (*(void (**)(PersonalitySpecificImpl *, void, const char *))(*(void *)a1 + 584))(a1, 0, "Data Bearer change");
  uint64_t v12 = *((void *)a1 + 7);
  uint64_t v13 = PersonalitySpecificImpl::simSlot(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v12 + 224))(v12, v13, 26, 0);
  uint64_t v14 = *((void *)a1 + 7);
  if (v14)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 264))(v14);
    uint64_t v16 = *(uint64_t **)v15;
    uint64_t v17 = *(uint64_t **)(v15 + 8);
    while (v16 != v17)
    {
      uint64_t v18 = *v16;
      (*(void (**)(uint8_t *__return_ptr, PersonalitySpecificImpl *))(*(void *)a1 + 16))(buf, a1);
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v18 + 232))(v18, buf);
      if (*(void *)&v22[4]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&v22[4]);
      }
      v16 += 2;
    }
  }
}

void sub_10106C98C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106C9C4(uint64_t a1, uint64_t a2, unsigned int a3)
{
}

void sub_10106C9D0(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 264))(v3);
    uint64_t v7 = *(uint64_t **)v5;
    uint64_t v6 = *(uint64_t **)(v5 + 8);
    if (*(uint64_t **)v5 != v6)
    {
      do
      {
        uint64_t v9 = *v7;
        int v8 = (std::__shared_weak_count *)v7[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v18 = 3 - *a2;
        if (ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v5))
        {
          (*(void (**)(uint64_t))(*(void *)v9 + 72))(v9);
          int KeepaliveOffloadFrames = ApplePDPHelperInterface::getKeepaliveOffloadFrames();
          int v11 = *(NSObject **)(a1 + 96);
          uint64_t v5 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
          if (v5)
          {
            int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72))(v9);
            *(_DWORD *)long long buf = 136315906;
            char v20 = "getKeepaliveOffloadFrames";
            __int16 v21 = 1024;
            int v22 = v12;
            __int16 v23 = 1024;
            int v24 = KeepaliveOffloadFrames;
            __int16 v25 = 1024;
            int v26 = v18;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: <keepalive_offload>2: pdp=%d: status=%d: frames=%d", buf, 0x1Eu);
          }
          if (KeepaliveOffloadFrames)
          {
            unsigned int v13 = *a2 + v18;
            int v14 = v13 >= 3 ? 3 : *a2 + v18;
            *a2 = v14;
            if (v13 > 2)
            {
              char v15 = 1;
              if (!v8) {
                goto LABEL_19;
              }
LABEL_18:
              sub_10004D2C8(v8);
              goto LABEL_19;
            }
          }
        }
        else
        {
          uint64_t v16 = *(NSObject **)(a1 + 96);
          uint64_t v5 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
          if (v5)
          {
            *(_DWORD *)long long buf = 136315138;
            char v20 = "getKeepaliveOffloadFrames";
            _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%s: PDPHelper is null !", buf, 0xCu);
          }
        }
        char v15 = 0;
        if (v8) {
          goto LABEL_18;
        }
LABEL_19:
        v7 += 2;
        if (v7 == v6) {
          char v17 = 1;
        }
        else {
          char v17 = v15;
        }
      }
      while ((v17 & 1) == 0);
    }
  }
}

void sub_10106CC58(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106CC78(uint64_t a1, _DWORD *a2)
{
}

void sub_10106CC80(uint64_t a1, uint64_t a2)
{
  int v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "setTCPNoAckPrioritization";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: setTCPNoAckPrioritization: %d", buf, 0x12u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 56) + 248))(buf);
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 56) + 248))(&v10);
  long long v5 = v10;
  long long v10 = 0uLL;
  uint64_t v6 = *(std::__shared_weak_count **)&buf[8];
  *(_OWORD *)long long buf = v5;
  if (!v6)
  {
    uint64_t v7 = v5;
    if (!(void)v5) {
      goto LABEL_15;
    }
    goto LABEL_9;
  }
  sub_10004D2C8(v6);
  if (*((void *)&v10 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
  }
  uint64_t v7 = *(void *)buf;
  if (*(void *)buf)
  {
LABEL_9:
    long long v10 = 0uLL;
    (*(void (**)(long long *__return_ptr))(*(void *)v7 + 64))(&v10);
    if ((void)v10)
    {
      (*(void (**)(void, uint64_t))(*(void *)v10 + 272))(v10, a2);
    }
    else
    {
      int v8 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v9 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No valid PDPManager exist for the PDP ID", v9, 2u);
      }
    }
    if (*((void *)&v10 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
    }
  }
LABEL_15:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_10106CE9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106CED4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10106CEDC(uint64_t a1, uint64_t a2)
{
  int v4 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315394;
    uint64_t v7 = "updateUlHealthEmergencyBottleneckState";
    __int16 v8 = 1024;
    int v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: updateUlHealthEmergencyBottleneckState: %d", (uint8_t *)&v6, 0x12u);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 480))(*(void *)(a1 + 56), a2);
}

uint64_t sub_10106CFCC(uint64_t a1, uint64_t a2)
{
  return sub_10106CEDC(a1 - 24, a2);
}

void sub_10106CFD4(void **a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (*a2)
  {
    if ((*(uint64_t (**)(void, void))(*(void *)*a2 + 88))(*a2, 0))
    {
      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = "emergency";
      *(void *)(a4 + 16) = "";
      *(_DWORD *)(a4 + 24) = 0;
      *(unsigned char *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 32) = 2;
      *(void *)(a4 + 44) = 0;
      *(void *)(a4 + 36) = 0;
      *(_DWORD *)(a4 + 52) = 0;
      return;
    }
    uint64_t v8 = *a2;
  }
  else
  {
    uint64_t v8 = 0;
  }
  long long v38 = 0u;
  memset(v39, 0, sizeof(v39));
  long long v37 = 0u;
  int v9 = (std::__shared_weak_count *)a2[1];
  v36[0] = v8;
  v36[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long __p = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  sub_1008DB9AC(&__p, *(const void **)a3, *(void *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2));
  sub_10106D4F4((uint64_t)a1, v36, (const void **)&__p, (int *)&v37);
  if (__p)
  {
    uint64_t v34 = __p;
    operator delete(__p);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v37)
  {
    long long v10 = v38;
    *(_OWORD *)a4 = v37;
    *(_OWORD *)(a4 + 16) = v10;
    *(void *)(a4 + 32) = v39[0];
    *(_OWORD *)(a4 + 40) = *(_OWORD *)&v39[1];
    return;
  }
  long long v32 = 0uLL;
  (*(void (**)(long long *__return_ptr))(*a1[7] + 248))(&v32);
  uint64_t v11 = v32;
  if ((void)v32)
  {
    ((void (*)(uint64_t *__return_ptr, void **))(*a1)[2])(&v27, a1);
    (*(void (**)(_OWORD *__return_ptr, uint64_t, void, uint64_t *, void))(*(void *)v11 + 544))(v29, v11, 0, &v27, 0);
    long long v37 = v29[0];
    long long v38 = v29[1];
    v39[0] = v30;
    long long v12 = v31;
    long long v31 = 0uLL;
    unsigned int v13 = (std::__shared_weak_count *)v39[2];
    *(_OWORD *)&v39[1] = v12;
    if (v13)
    {
      sub_10004D2C8(v13);
      if (*((void *)&v31 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v31 + 1));
      }
    }
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v37) {
      goto LABEL_21;
    }
    goto LABEL_32;
  }
  (*(void (**)(_OWORD *__return_ptr))(*a1[7] + 248))(v29);
  long long v15 = v29[0];
  v29[0] = 0uLL;
  uint64_t v16 = (std::__shared_weak_count *)*((void *)&v32 + 1);
  long long v32 = v15;
  if (v16)
  {
    sub_10004D2C8(v16);
    if (*((void *)&v29[0] + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v29[0] + 1));
    }
    uint64_t v17 = v32;
    if (!(void)v32) {
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v17 = v15;
    if (!(void)v15) {
      goto LABEL_32;
    }
  }
  v29[0] = 0uLL;
  (*(void (**)(_OWORD *__return_ptr))(*(void *)v17 + 64))(v29);
  if (*(void *)&v29[0]
    && ((*(uint64_t (**)(void))(**(void **)&v29[0] + 144))(*(void *)&v29[0]) & 1) == 0)
  {
    uint64_t v21 = asString();
    *(_DWORD *)a4 = 4;
    int v22 = "";
    if (v21) {
      int v22 = (const char *)v21;
    }
    *(void *)(a4 + 8) = "PDPActivator not ready (2)";
    *(void *)(a4 + 16) = v22;
    *(_DWORD *)(a4 + 24) = 0;
    *(unsigned char *)(a4 + 28) = 0;
    *(void *)(a4 + 40) = 0;
    *(void *)(a4 + 48) = 0;
    *(void *)(a4 + 32) = 0;
    if (*((void *)&v29[0] + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v29[0] + 1));
    }
    goto LABEL_40;
  }
  if (*((void *)&v29[0] + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v29[0] + 1));
  }
LABEL_32:
  uint64_t v18 = *a2;
  uint64_t v19 = (std::__shared_weak_count *)a2[1];
  v26[0] = v18;
  v26[1] = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 v23 = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  sub_1008DB9AC(&v23, *(const void **)a3, *(void *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2));
  char v20 = sub_10106DECC((uint64_t)a1, v26, (uint64_t *)&v23, 0);
  if (v23)
  {
    int v24 = v23;
    operator delete(v23);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if ((v20 & 1) == 0)
  {
    *(_DWORD *)a4 = 24;
    *(void *)(a4 + 8) = "radio is not ready";
    *(void *)(a4 + 16) = "";
    *(_DWORD *)(a4 + 24) = 0;
    *(unsigned char *)(a4 + 28) = 0;
    *(void *)(a4 + 40) = 0;
    *(void *)(a4 + 48) = 0;
    *(void *)(a4 + 32) = 0;
    goto LABEL_40;
  }
LABEL_21:
  long long v14 = v38;
  *(_OWORD *)a4 = v37;
  *(_OWORD *)(a4 + 16) = v14;
  *(void *)(a4 + 32) = v39[0];
  *(_OWORD *)(a4 + 40) = *(_OWORD *)&v39[1];
  v39[1] = 0;
  v39[2] = 0;
LABEL_40:
  if (*((void *)&v32 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v32 + 1));
  }
  if (v39[2]) {
    sub_10004D2C8((std::__shared_weak_count *)v39[2]);
  }
}

void sub_10106D450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,void *a28,uint64_t a29)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }
  if (*(void *)(v29 - 80)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v29 - 80));
  }
  _Unwind_Resume(exception_object);
}

void sub_10106D4F4(uint64_t a1@<X0>, void *a2@<X1>, const void **a3@<X2>, int *a4@<X8>)
{
  uint64_t v8 = *a2;
  if (!*a2)
  {
LABEL_16:
    *(_OWORD *)a4 = 0u;
    *((_OWORD *)a4 + 1) = 0u;
    *((void *)a4 + 1) = "";
    *((void *)a4 + 2) = "";
    a4[8] = 2;
    uint64_t v11 = a4 + 8;
    *(void *)(a4 + 11) = 0;
    *(void *)(a4 + 9) = 0;
    a4[13] = 0;
    if (v8)
    {
      (*(void (**)(long long *__return_ptr))(*(void *)v8 + 64))(&v65);
      long long v12 = v66;
      *(_OWORD *)a4 = v65;
      *((_OWORD *)a4 + 1) = v12;
      *((void *)a4 + 4) = v67[0];
      long long v13 = *(_OWORD *)&v67[1];
      *(_OWORD *)&v67[1] = 0uLL;
      long long v14 = (std::__shared_weak_count *)*((void *)a4 + 6);
      *(_OWORD *)(a4 + 10) = v13;
      if (v14)
      {
        sub_10004D2C8(v14);
        if (v67[2]) {
          sub_10004D2C8((std::__shared_weak_count *)v67[2]);
        }
      }
    }
    long long buf = 0uLL;
    uint64_t v69 = 0;
    int v15 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 56) + 304))(*(void *)(a1 + 56), &buf);
    if (!*a4)
    {
      if (((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 464))(*(void *)(a1 + 56)) ^ 1 | v15) == 1)
      {
        uint64_t v16 = (char *)*a3;
        uint64_t v17 = (char *)a3[1];
        if (*a3 == v17)
        {
          *a4 = -1;
          uint64_t v18 = "Data is not Allowed or Blocked: PDP Context cannot be made active while Data is disabled(0)";
        }
        else
        {
          while ((v16[4] & 1) != 0)
          {
            v16 += 12;
            if (v16 == v17) {
              goto LABEL_30;
            }
          }
          *a4 = -1;
          uint64_t v18 = "Data is not Allowed or Blocked: PDP Context cannot be made active while Data is disabled(1)";
        }
        *((void *)a4 + 1) = v18;
        *((void *)a4 + 2) = "";
        a4[6] = 0;
        *((unsigned char *)a4 + 28) = 0;
        *uint64_t v11 = 0;
        *((void *)a4 + 5) = 0;
        uint64_t v19 = (std::__shared_weak_count *)*((void *)a4 + 6);
        *((void *)a4 + 6) = 0;
        if (v19) {
          sub_10004D2C8(v19);
        }
      }
LABEL_30:
      if (!*a4
        && (!*a2
         || !(*(unsigned int (**)(void))(*(void *)*a2 + 136))(*a2)
         || *(_DWORD *)(a1 + 228) != -2))
      {
        long long __p = 0;
        uint64_t v63 = 0;
        uint64_t v64 = 0;
        sub_1008DB9AC(&__p, *a3, (uint64_t)a3[1], 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a3[1] - (unsigned char *)*a3) >> 2));
        BOOL v20 = sub_10106185C(a1, (uint64_t)&__p);
        if (__p)
        {
          uint64_t v63 = __p;
          operator delete(__p);
        }
        if (!v20)
        {
          if (*(int *)(a1 + 228) < 1)
          {
            uint64_t v21 = "Data network is not available: DataMode is not ready";
          }
          else if (*(_DWORD *)(a1 + 288))
          {
            if (*(unsigned char *)(a1 + 280)) {
              uint64_t v21 = *(unsigned char *)(a1 + 281)
            }
                  ? "Data network is not available: Data is not attached, or DataMode is not ready, or InHomeCountry is n"
                    "ot known, or something else"
                  : "Data network is not available: Data is not attached (raw)";
            else {
              uint64_t v21 = "Data is not provisioned";
            }
          }
          else
          {
            uint64_t v21 = "Data network is not available: InHomeCountry is not known";
          }
          *a4 = -5;
          *((void *)a4 + 1) = v21;
          *((void *)a4 + 2) = "";
          a4[6] = 0;
          *((unsigned char *)a4 + 28) = 0;
          *uint64_t v11 = 0;
          *((void *)a4 + 5) = 0;
          int v22 = (std::__shared_weak_count *)*((void *)a4 + 6);
          *((void *)a4 + 6) = 0;
          if (v22) {
            sub_10004D2C8(v22);
          }
        }
      }
    }
    uint64_t v23 = *(void *)(a1 + 56);
    if (v23)
    {
      uint64_t v24 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      LODWORD(v23) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v23 + 376))(v23, v24);
    }
    int v25 = *a4;
    if (*a4)
    {
LABEL_81:
      uint64_t v40 = (const char *)*((void *)a4 + 1);
      int v41 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 464))(*(void *)(a1 + 56));
      __int16 v59 = 0;
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      sub_1008DB9AC(&v59, *a3, (uint64_t)a3[1], 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a3[1] - (unsigned char *)*a3) >> 2));
      BOOL v42 = sub_10106185C(a1, (uint64_t)&v59);
      if (v40) {
        int v43 = v40;
      }
      else {
        int v43 = "";
      }
      if (v23) {
        int v44 = 0x1000000;
      }
      else {
        int v44 = 0;
      }
      if (v42) {
        int v45 = 0x10000;
      }
      else {
        int v45 = 0;
      }
      if (v15) {
        int v46 = 256;
      }
      else {
        int v46 = 0;
      }
      *a4 = v25;
      *((void *)a4 + 1) = v43;
      *((void *)a4 + 2) = "";
      a4[6] = v44 | v46 | v45 | v41;
      *((unsigned char *)a4 + 28) = 1;
      *((void *)a4 + 4) = 2;
      uint64_t v47 = (std::__shared_weak_count *)*((void *)a4 + 6);
      *((void *)a4 + 5) = 0;
      *((void *)a4 + 6) = 0;
      if (v47) {
        sub_10004D2C8(v47);
      }
      if (v59)
      {
        uint64_t v60 = v59;
        operator delete(v59);
      }
      *(_DWORD *)uint64_t v11 = 0;
LABEL_98:
      if (SHIBYTE(v69) < 0) {
        operator delete((void *)buf);
      }
      return;
    }
    int v26 = (char *)*a3;
    uint64_t v27 = (char *)a3[1];
    if (*a3 == v27)
    {
LABEL_55:
      uint64_t v29 = *(void *)(a1 + 56);
      if (!v29) {
        goto LABEL_80;
      }
      uint64_t v30 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
      if ((v23 | (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v29 + 368))(v29, v30))) {
        goto LABEL_80;
      }
      long long v31 = (char *)*a3;
      long long v32 = (char *)a3[1];
      if (*a3 != v32)
      {
        while ((v31[5] & 1) != 0)
        {
          v31 += 12;
          if (v31 == v32) {
            goto LABEL_80;
          }
        }
      }
      uint64_t v33 = "Roaming info has not settled yet";
      int v34 = *(_DWORD *)(a1 + 288);
      if (v34) {
        BOOL v35 = v34 == 5;
      }
      else {
        BOOL v35 = 1;
      }
      uint64_t v36 = "International roaming is not allowed";
    }
    else
    {
      uint64_t v28 = (char *)*a3;
      while ((v28[10] & 1) == 0)
      {
        v28 += 12;
        if (v28 == v27) {
          goto LABEL_55;
        }
      }
      if (v23)
      {
LABEL_80:
        int v25 = *a4;
        if (!*a4)
        {
          uint64_t v48 = *a2;
          if (!*a2) {
            goto LABEL_119;
          }
          *(void *)&long long v65 = 0;
          *((void *)&v65 + 1) = "";
          long long v66 = (unint64_t)"";
          LODWORD(v67[0]) = 2;
          memset((char *)v67 + 4, 0, 20);
          if ((*(unsigned int (**)(uint64_t, void, long long *))(*(void *)v48 + 248))(v48, 0, &v65))
          {
            if (!v65)
            {
              LODWORD(v65) = 24;
              *((void *)&v65 + 1) = "We are in throttling mode";
              *(void *)&long long v66 = "";
              DWORD2(v66) = 0;
              BYTE12(v66) = 0;
              memset(v67, 0, sizeof(v67));
              if (v67[2]) {
                sub_10004D2C8((std::__shared_weak_count *)v67[2]);
              }
            }
            uint64_t v49 = (char *)*a3;
            int v50 = (char *)a3[1];
            if (*a3 != v50)
            {
              while ((v49[6] & 1) != 0)
              {
                v49 += 12;
                if (v49 == v50) {
                  goto LABEL_114;
                }
              }
            }
            long long v51 = v66;
            *(_OWORD *)a4 = v65;
            *((_OWORD *)a4 + 1) = v51;
            uint64_t v52 = v67[1];
            *((void *)a4 + 4) = v67[0];
            uint64_t v53 = v67[2];
            if (v67[2]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v67[2] + 8), 1uLL, memory_order_relaxed);
            }
            BOOL v54 = (std::__shared_weak_count *)*((void *)a4 + 6);
            *((void *)a4 + 5) = v52;
            *((void *)a4 + 6) = v53;
            if (v54) {
              sub_10004D2C8(v54);
            }
          }
LABEL_114:
          if (v67[2]) {
            sub_10004D2C8((std::__shared_weak_count *)v67[2]);
          }
          int v25 = *a4;
          if (!*a4)
          {
LABEL_119:
            if ((sub_101061C78(a1) & 1) == 0
              && (!*a2 || ((*(uint64_t (**)(void))(*(void *)*a2 + 136))(*a2) & 1) == 0))
            {
              unsigned __int8 v55 = (char *)*a3;
              uint64_t v56 = (char *)a3[1];
              if (*a3 != v56)
              {
                while ((v55[8] & 1) != 0)
                {
                  v55 += 12;
                  if (v55 == v56) {
                    goto LABEL_126;
                  }
                }
              }
              *a4 = -6;
              *((void *)a4 + 1) = "No data bearer";
              *((void *)a4 + 2) = "";
              a4[6] = 0;
              *((unsigned char *)a4 + 28) = 0;
              *uint64_t v11 = 0;
              *((void *)a4 + 5) = 0;
              BOOL v57 = (std::__shared_weak_count *)*((void *)a4 + 6);
              *((void *)a4 + 6) = 0;
              if (v57) {
                sub_10004D2C8(v57);
              }
            }
LABEL_126:
            int v25 = *a4;
            if (!*a4)
            {
              if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 400))(*(void *)(a1 + 56)) & 1) == 0)
              {
                *a4 = -9;
                *((void *)a4 + 1) = "SIM slot to be reconfigured";
                *((void *)a4 + 2) = "";
                a4[6] = 0;
                *((unsigned char *)a4 + 28) = 0;
                *uint64_t v11 = 0;
                *((void *)a4 + 5) = 0;
                uint64_t v58 = (std::__shared_weak_count *)*((void *)a4 + 6);
                *((void *)a4 + 6) = 0;
                if (v58) {
                  sub_10004D2C8(v58);
                }
              }
              int v25 = *a4;
              if (!*a4) {
                goto LABEL_98;
              }
            }
          }
        }
        goto LABEL_81;
      }
      while ((v26[5] & 1) != 0)
      {
        v26 += 12;
        if (v26 == v27) {
          goto LABEL_80;
        }
      }
      uint64_t v33 = "Roaming info has not settled yet";
      int v37 = *(_DWORD *)(a1 + 288);
      if (v37) {
        BOOL v35 = v37 == 5;
      }
      else {
        BOOL v35 = 1;
      }
      uint64_t v36 = "International roaming is not allowed (forced)";
    }
    if (v35) {
      int v38 = -9;
    }
    else {
      int v38 = -2;
    }
    if (!v35) {
      uint64_t v33 = v36;
    }
    *a4 = v38;
    *((void *)a4 + 1) = v33;
    *((void *)a4 + 2) = "";
    a4[6] = 0;
    *((unsigned char *)a4 + 28) = 0;
    *uint64_t v11 = 0;
    *((void *)a4 + 5) = 0;
    uint64_t v39 = (std::__shared_weak_count *)*((void *)a4 + 6);
    *((void *)a4 + 6) = 0;
    if (v39) {
      sub_10004D2C8(v39);
    }
    goto LABEL_80;
  }
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)v8 + 232))(v8, 0))
  {
    *a4 = 94;
    *((void *)a4 + 1) = "FatalActivationBlocker: No Reconnection Allowed (bb1)";
    *((void *)a4 + 2) = "";
    a4[6] = 0;
    *((unsigned char *)a4 + 28) = 0;
    *((void *)a4 + 5) = 0;
    *((void *)a4 + 6) = 0;
    *((void *)a4 + 4) = 0;
    return;
  }
  long long v65 = 0uLL;
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 224))(&v65);
  if ((void)v65)
  {
    if (!sub_1004FCA34(v65))
    {
      int v10 = 0;
      *a4 = 94;
      *((void *)a4 + 1) = "ActivationBlocker: No Reconnection Allowed (bb2)";
      *((void *)a4 + 2) = "";
      a4[6] = 0;
      *((unsigned char *)a4 + 28) = 0;
      *((void *)a4 + 5) = 0;
      *((void *)a4 + 6) = 0;
      *((void *)a4 + 4) = 0;
      goto LABEL_12;
    }
    int v9 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "dataContextActivationPossible";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: ActivationBlocker: exists, but it can be passed through", (uint8_t *)&buf, 0xCu);
    }
  }
  if ((*(unsigned int (**)(void, void))(*(void *)*a2 + 88))(*a2, 0))
  {
    int v10 = 0;
    *a4 = 0;
    *((void *)a4 + 1) = "emergency";
    *((void *)a4 + 2) = "";
    a4[6] = 0;
    *((unsigned char *)a4 + 28) = 0;
    a4[8] = 2;
    *(void *)(a4 + 11) = 0;
    *(void *)(a4 + 9) = 0;
    a4[13] = 0;
  }
  else
  {
    int v10 = 1;
  }
LABEL_12:
  if (*((void *)&v65 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v65 + 1));
  }
  if (v10)
  {
    uint64_t v8 = *a2;
    goto LABEL_16;
  }
}

void sub_10106DE38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v28 + 48);
  if (v30) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10106DECC(uint64_t a1, void *a2, uint64_t *a3, _DWORD *a4)
{
  if (a4) {
    *a4 = 0;
  }
  if (*a2 && ((*(uint64_t (**)(void, void))(*(void *)*a2 + 88))(*a2, 0) & 1) != 0) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 282))
  {
    uint64_t v8 = *(NSObject **)(a1 + 96);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v9) {
      return result;
    }
    int v17 = 136315138;
    uint64_t v18 = "dataContextActivationRadioReady";
    int v10 = "#I %s: in airplane mode";
    goto LABEL_15;
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 136))(*(void *)(a1 + 56)))
  {
    uint64_t v8 = *(NSObject **)(a1 + 96);
    BOOL v11 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v11) {
      return result;
    }
    int v17 = 136315138;
    uint64_t v18 = "dataContextActivationRadioReady";
    int v10 = "#I %s: radio off";
    goto LABEL_15;
  }
  if (*(unsigned char *)(a1 + 284))
  {
    uint64_t v8 = *(NSObject **)(a1 + 96);
    BOOL v12 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v12) {
      return result;
    }
    int v17 = 136315138;
    uint64_t v18 = "dataContextActivationRadioReady";
    int v10 = "#I %s: in ECBM mode";
    goto LABEL_15;
  }
  if (*(unsigned char *)(a1 + 280))
  {
LABEL_19:
    if (*(unsigned char *)(a1 + 283)) {
      return 1;
    }
    long long v13 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 136315138;
      uint64_t v18 = "dataContextActivationRadioReady";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: modem power is off", (uint8_t *)&v17, 0xCu);
    }
    if (a4)
    {
      uint64_t result = 0;
      *a4 = 74;
      return result;
    }
    return 0;
  }
  uint64_t v14 = *a3;
  uint64_t v15 = a3[1];
  if (*a3 != v15)
  {
    while ((*(unsigned char *)(v14 + 1) & 1) != 0)
    {
      v14 += 12;
      if (v14 == v15) {
        goto LABEL_19;
      }
    }
  }
  uint64_t v8 = *(NSObject **)(a1 + 96);
  BOOL v16 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v16)
  {
    int v17 = 136315138;
    uint64_t v18 = "dataContextActivationRadioReady";
    int v10 = "#I %s: service is not provisioned";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v17, 0xCu);
    return 0;
  }
  return result;
}

void sub_10106E17C(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
}

void sub_10106E19C(uint64_t a1@<X0>, void *a2@<X1>, const void **a3@<X2>, int *a4@<X8>)
{
}

uint64_t sub_10106E1A4(uint64_t a1, void *a2, uint64_t *a3, _DWORD *a4)
{
  return sub_10106DECC(a1 - 24, a2, a3, a4);
}

uint64_t sub_10106E1AC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)sub_10105E894((PersonalitySpecificImpl *)a1);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------------------- %s --------------------------", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v3 = subscriber::asString();
    uint64_t v4 = asString();
    uint64_t v5 = asString();
    uint64_t v6 = asString();
    uint64_t v7 = asString();
    uint64_t v8 = asStringBool(*(unsigned char *)(a1 + 413));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316418;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v3;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v4;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)uint64_t v70 = v5;
    *(_WORD *)&v70[8] = 2080;
    *(void *)&v70[10] = v6;
    *(_WORD *)&v70[18] = 2080;
    *(void *)&v70[20] = v7;
    __int16 v71 = 2080;
    uint64_t v72 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: simSlot = %s fDataMode = %s, fRat = %s, fCellularDataTechnology = %s, fRoamingResult=%s, fCmasCampOnlyMode = %s", (uint8_t *)&buf, 0x3Eu);
    uint64_t v2 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asString();
    asStringDataSoMask((uint64_t *)__p, *(_DWORD *)(a1 + 220));
    if (v68 >= 0) {
      int v10 = __p;
    }
    else {
      int v10 = *(unsigned char **)__p;
    }
    int v11 = *(_DWORD *)(a1 + 220);
    uint64_t v12 = asStringBool(*(unsigned char *)(a1 + 224));
    uint64_t v13 = asStringBool(*(unsigned char *)(a1 + 282));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v9;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    *(_DWORD *)uint64_t v70 = v11;
    *(_WORD *)&v70[4] = 2080;
    *(void *)&void v70[6] = v12;
    *(_WORD *)&v70[14] = 2080;
    *(void *)&v70[16] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataBearerInfo = %s/%{public}s (%u)/%s, fAirplaneMode = %s", (uint8_t *)&buf, 0x30u);
    if (v68 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v2 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v14 = asStringBool(*(unsigned char *)(a1 + 283));
    std::string::size_type v15 = asStringBool(*(unsigned char *)(a1 + 284));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v14;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fPoweredOnStatus = %s, fInECBM = %s", (uint8_t *)&buf, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v16 = asStringBool(*(unsigned char *)(a1 + 292));
    int v17 = *(_DWORD *)(a1 + 368);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v16;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDormancy = %s fActiveContextsCnt = %u", (uint8_t *)&buf, 0x12u);
    uint64_t v2 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v18 = asStringBool(*(void *)(a1 + 160) != 0);
    std::string::size_type v19 = asStringBool(*(void *)(a1 + 168) != 0);
    uint64_t v20 = asStringBool(*(unsigned char *)(a1 + 280));
    uint64_t v21 = asStringBool(*(unsigned char *)(a1 + 281));
    uint64_t v22 = asStringBool(*(unsigned char *)(a1 + 378));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v18;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v19;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)uint64_t v70 = v20;
    *(_WORD *)&v70[8] = 2080;
    *(void *)&v70[10] = v21;
    *(_WORD *)&v70[18] = 2080;
    *(void *)&v70[20] = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fSuspendDelayTimerNoData = %s, fSuspendDelayTimerBBCall = %s, fDataProvisionedStatus = %s, fDataAttachStatusRaw = %s, fUseCDMATetheringSettings = %s", (uint8_t *)&buf, 0x34u);
    uint64_t v2 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v23 = asStringBool(*(unsigned char *)(a1 + 208));
    std::string::size_type v24 = asStringBool(*(unsigned char *)(a1 + 377));
    uint64_t v25 = asStringBool(*(unsigned char *)(a1 + 209));
    uint64_t v26 = asStringBool(*(unsigned char *)(a1 + 418));
    uint64_t v27 = asStringBool(*(unsigned char *)(a1 + 419));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v23;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v24;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)uint64_t v70 = v25;
    *(_WORD *)&v70[8] = 2080;
    *(void *)&v70[10] = v26;
    *(_WORD *)&v70[18] = 2080;
    *(void *)&v70[20] = v27;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: fShutDown = %s, fFirstSetup = %s, fIsCSCallActive = %s, fIsBBCallActive = %s, fIsEmCallActive = %s", (uint8_t *)&buf, 0x34u);
  }
  int Timeout = DataBBResetThrottling::getTimeout((DataBBResetThrottling *)(a1 + 424));
  int Reset = DataBBResetThrottling::timeSinceLastReset((DataBBResetThrottling *)(a1 + 424));
  uint64_t v30 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    int v31 = *(_DWORD *)(a1 + 440);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109632;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = Timeout;
    LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = Reset;
    HIWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
    LODWORD(buf.__r_.__value_.__r.__words[2]) = v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DATA:: bbResetSecondsint Timeout = %u, timeSinceLastReset = %u, fBBResetTimerFactor = %u", (uint8_t *)&buf, 0x14u);
    uint64_t v30 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DATA:: \tfCurrentImsDataModes(", (uint8_t *)&buf, 2u);
  }
  uint64_t v32 = *(void *)(a1 + 248);
  for (uint64_t i = *(void *)(a1 + 256); v32 != i; v32 += 4)
  {
    int v34 = *(NSObject **)(a1 + 96);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = asString();
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t%s", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v36 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t)", (uint8_t *)&buf, 2u);
    uint64_t v36 = *(NSObject **)(a1 + 96);
  }
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------- BB DataContexts --------------", (uint8_t *)&buf, 2u);
  }
  uint64_t v37 = *(void *)(a1 + 56);
  if (v37)
  {
    uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 264))(v37);
    uint64_t v39 = *(uint64_t **)v38;
    uint64_t v40 = *(uint64_t **)(v38 + 8);
    if (*(uint64_t **)v38 != v40)
    {
      do
      {
        uint64_t v41 = *v39;
        BOOL v42 = (std::__shared_weak_count *)v39[1];
        if (v42) {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, void))(*(void *)v41 + 176))(v41, 0);
        if (v42) {
          sub_10004D2C8(v42);
        }
        v39 += 2;
      }
      while (v39 != v40);
    }
  }
  int v43 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------- BB DataSettings --------------", (uint8_t *)&buf, 2u);
  }
  for (uint64_t j = *(uint64_t **)(a1 + 120); j != *(uint64_t **)(a1 + 128); j += 2)
  {
    uint64_t v45 = *j;
    int v46 = (std::__shared_weak_count *)j[1];
    if (v46) {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v45)
    {
      (*(void (**)(uint64_t))(*(void *)v45 + 664))(v45);
    }
    else
    {
      uint64_t v47 = *(NSObject **)(a1 + 96);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I DATA:: ---------------- **Null DataSetting** -------------------", (uint8_t *)&buf, 2u);
      }
    }
    if (v46) {
      sub_10004D2C8(v46);
    }
  }
  uint64_t v48 = *(void *)(a1 + 296);
  uint64_t v49 = *(NSObject **)(a1 + 96);
  BOOL v50 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
  if (v48)
  {
    if (v50)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I DATA:: -fDataAPNSettingsOTAActivationInternet:", (uint8_t *)&buf, 2u);
      uint64_t v48 = *(void *)(a1 + 296);
    }
    (*(void (**)(uint64_t))(*(void *)v48 + 664))(v48);
  }
  else if (v50)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataAPNSettingsOTAActivationInternet: NULL", (uint8_t *)&buf, 2u);
  }
  uint64_t v51 = *(void *)(a1 + 312);
  uint64_t v52 = *(NSObject **)(a1 + 96);
  BOOL v53 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
  if (v51)
  {
    if (v53)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I DATA:: -fDataAPNSettingsOTAActivationInternetCDMA:", (uint8_t *)&buf, 2u);
      uint64_t v51 = *(void *)(a1 + 312);
    }
    (*(void (**)(uint64_t))(*(void *)v51 + 664))(v51);
  }
  else if (v53)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataAPNSettingsOTAActivationInternetCDMA: NULL", (uint8_t *)&buf, 2u);
  }
  uint64_t v54 = *(void *)(a1 + 328);
  unsigned __int8 v55 = *(NSObject **)(a1 + 96);
  BOOL v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
  if (v54)
  {
    if (v56)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I DATA:: -fDataAPNSettingsOTAActivationOTA:", (uint8_t *)&buf, 2u);
      uint64_t v54 = *(void *)(a1 + 328);
    }
    (*(void (**)(uint64_t))(*(void *)v54 + 664))(v54);
  }
  else if (v56)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataAPNSettingsOTAActivationOTA: NULL", (uint8_t *)&buf, 2u);
  }
  if (*(void *)(a1 + 344))
  {
    memset(&buf, 0, sizeof(buf));
    sub_100058DB0(&buf, "Nothing");
    uint64_t v57 = **(void **)(a1 + 344);
    if (v57 == *(void *)(a1 + 296))
    {
      uint64_t v58 = "fDataAPNSettingsOTAActivationInternet";
      size_t v59 = 37;
    }
    else if (v57 == *(void *)(a1 + 312))
    {
      uint64_t v58 = "fDataAPNSettingsOTAActivationInternetCDMA";
      size_t v59 = 41;
    }
    else
    {
      if (v57 != *(void *)(a1 + 328))
      {
LABEL_79:
        uint64_t v61 = *(NSObject **)(a1 + 96);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          p_std::string buf = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long __p = 136315138;
          *(void *)&__p[4] = p_buf;
          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataAPNSettingsOTAActivationCurrent is pointing to %s", __p, 0xCu);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        goto LABEL_85;
      }
      uint64_t v58 = "fDataAPNSettingsOTAActivationOTA";
      size_t v59 = 32;
    }
    sub_10003ECB8(&buf, v58, v59);
    goto LABEL_79;
  }
  uint64_t v60 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataAPNSettingsOTAActivationCurrent is NULL", (uint8_t *)&buf, 2u);
  }
LABEL_85:
  uint64_t v63 = *(void *)(a1 + 352);
  uint64_t v64 = *(NSObject **)(a1 + 96);
  BOOL v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
  if (v63)
  {
    if (v65)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I DATA:: -fDataSettingsCDMATethering:", (uint8_t *)&buf, 2u);
      uint64_t v63 = *(void *)(a1 + 352);
    }
    (*(void (**)(uint64_t))(*(void *)v63 + 664))(v63);
  }
  else if (v65)
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I DATA:: fDataSettingsCDMATethering: NULL", (uint8_t *)&buf, 2u);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 160))(*(void *)(a1 + 104));
}

void sub_10106ED30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10106ED8C(void *a1)
{
  return sub_10106E1AC((uint64_t)a1 + *(void *)(*a1 - 264));
}

uint64_t sub_10106EDAC(ApplePDPHelperInterface *a1, uint64_t a2)
{
  uint64_t Instance = ApplePDPHelperInterface::getInstance(a1);

  return ApplePDPHelperInterface::addFlow(Instance, 8, a2);
}

uint64_t sub_10106EDE8(ApplePDPHelperInterface *a1, uint64_t a2)
{
  uint64_t Instance = ApplePDPHelperInterface::getInstance(a1);

  return ApplePDPHelperInterface::addFlow(Instance, 8, a2);
}

uint64_t sub_10106EE24(ApplePDPHelperInterface *a1)
{
  uint64_t Instance = ApplePDPHelperInterface::getInstance(a1);

  return ApplePDPHelperInterface::removeFlow(Instance, 8);
}

uint64_t sub_10106EE50(ApplePDPHelperInterface *a1)
{
  uint64_t Instance = ApplePDPHelperInterface::getInstance(a1);

  return ApplePDPHelperInterface::removeFlow(Instance, 8);
}

const void **sub_10106EE7C(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(NSObject **)(a1 + 96);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "processDataTransmitSpeed";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: processDataTransmitSpeed", buf, 0xCu);
  }
  if (a2 > 2) {
    uint64_t v4 = (const void **)&kCTRadioTransmitSpeedUnknown;
  }
  else {
    uint64_t v4 = (const void **)*(&off_101A84E70 + (int)a2);
  }
  uint64_t v5 = *v4;
  *(void *)std::string buf = 0;
  *(void *)std::string buf = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, kCTRadioTransmitSpeed, v5);
  ctu::cf_to_xpc((uint64_t *)&object, *(ctu **)buf, v6);
  xpc_object_t v7 = object;
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  xpc_release(object);
  xpc_object_t object = v7;
  if (v7)
  {
    xpc_retain(v7);
    xpc_object_t v8 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t object = v8;
  }
  xpc_object_t v9 = xpc_null_create();
  xpc_object_t v11 = v9;
  sub_1000452AC(100, &object, &v11);
  xpc_release(v9);
  xpc_release(v8);
  xpc_release(v7);
  return sub_10005717C((const void **)buf);
}

void sub_10106F02C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

const void **sub_10106F0A8(uint64_t a1, unsigned int a2)
{
  return sub_10106EE7C(a1 - 24, a2);
}

uint64_t sub_10106F0B0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 232))();
}

uint64_t sub_10106F0D8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 232))();
}

uint64_t sub_10106F100(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 208)) {
    return 0;
  }
  uint64_t result = *(void *)(a1 + 104);
  if (result)
  {
    if ((*(uint64_t (**)(uint64_t))(*(void *)result + 200))(result)) {
      return 1;
    }
    uint64_t v3 = *(NSObject **)(a1 + 96);
    uint64_t result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "failed to report PDPStatistics", v4, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10106F1AC(uint64_t a1)
{
  return sub_10106F100(a1 - 24);
}

uint64_t sub_10106F1B4(PersonalitySpecificImpl *a1)
{
  uint64_t v1 = *((void *)a1 + 7);
  uint64_t v2 = PersonalitySpecificImpl::simSlot(a1);
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 128);

  return v3(v1, v2);
}

uint64_t sub_10106F218(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 24));
  uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 128);

  return v3(v1, v2);
}

void *sub_10106F284@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2) {
    return (void *)(*(uint64_t (**)(void))(*(void *)v2 + 72))();
  }
  else {
    return sub_100058DB0(a2, "");
  }
}

void *sub_10106F2C0@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_10106F284((uint64_t)a1 + *(void *)(*a1 - 112), a2);
}

uint64_t sub_10106F2DC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t sub_10106F30C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t sub_10106F33C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

uint64_t sub_10106F36C(void *a1)
{
  uint64_t result = *(void *)((char *)a1 + *(void *)(*a1 - 128) + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

void sub_10106F3B4(PersonalitySpecificImpl *a1)
{
}

void sub_10106F404()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/rf_band_type_changed");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10106F498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_10106F4DC(uint64_t a1)
{
}

void sub_10106F534(PersonalitySpecificImpl *a1, char a2, char *a3)
{
  int v5 = PersonalitySpecificImpl::simSlot(a1);
  sub_100058DB0(v6, a3);
  int v8 = v5;
  char v9 = a2;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(&__p, v6[0], (unint64_t)v6[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v6;
    uint64_t v11 = v7;
  }
  sub_10011AE40();
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_10106F5E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106F614(uint64_t a1, char a2, char *a3)
{
}

void sub_10106F61C(uint64_t a1, int a2, int a3, int a4)
{
  sub_100CC96D8((uint64_t)&v5, a2, a3, a4);
  uint64_t v4 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
  sub_100A01420(v4, (uint64_t)&v5);
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void sub_10106F66C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10106F68C(PersonalitySpecificImpl *a1, _DWORD *a2)
{
  *a2 = PersonalitySpecificImpl::simSlot(a1);
  xpc_object_t v3 = *((void *)a1 + 12);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I processAttachApnChanged", buf, 2u);
  }
  xpc_object_t v7 = 0;
  write_rest_value();
  sub_100058DB0(buf, "/cc/events/data_attach_apn_params");
  xpc_object_t object = v7;
  xpc_object_t v7 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v6 < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v7);
}

void sub_10106F774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(a17);
  _Unwind_Resume(a1);
}

void sub_10106F7B8(uint64_t a1, _DWORD *a2)
{
}

void *sub_10106F7C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4)
  {
    sub_1000DFC90((uint64_t)v8, a3);
    (*(void (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v4 + 216))(v4, a2, v8, a4);
    return sub_100060644(v8);
  }
  else
  {
    return (void *)sub_1000607A8(a3, 1);
  }
}

void sub_10106F8B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10106F8D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10106F7C0(a1 - 24, a2, a3, a4);
}

uint64_t sub_10106F8D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 224))();
  }
  return result;
}

uint64_t sub_10106F908(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 224))();
  }
  return result;
}

void *sub_10106F938(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 104);
  if (v3)
  {
    sub_100017108((uint64_t)v6, a3);
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 208))(v3, a2, v6);
    return sub_10001C9D4(v6);
  }
  else
  {
    return (void *)sub_100060854(a3, 0x600000001);
  }
}

void sub_10106FA1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001C9D4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10106FA38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10106F938(a1 - 24, a2, a3);
}

uint64_t sub_10106FA40(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 232))();
  }
  return result;
}

uint64_t sub_10106FA70(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 232))();
  }
  return result;
}

uint64_t sub_10106FAA0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 224);
}

uint64_t sub_10106FAA8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200);
}

uint64_t sub_10106FAB0(uint64_t result, uint64_t a2, char a3)
{
  *(void *)(result + 216) = a2;
  *(unsigned char *)(result + 224) = a3;
  return result;
}

uint64_t sub_10106FABC(uint64_t result, uint64_t a2, char a3)
{
  *(void *)(result + 192) = a2;
  *(unsigned char *)(result + 200) = a3;
  return result;
}

void sub_10106FAC8(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2)
  {
    uint64_t v3 = (void **)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 264))(v2);
    int v17 = 0;
    uint64_t v18 = 0;
    uint64_t v16 = 0;
    sub_101070334(&v16, *v3, v3[1], ((char *)v3[1] - (char *)*v3) >> 4);
    uint64_t v4 = v16;
    for (uint64_t i = v17; v4 != i; v4 += 2)
    {
      uint64_t v7 = *v4;
      char v6 = (std::__shared_weak_count *)v4[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      lpsrc = 0;
      std::string::size_type v15 = 0;
      (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v12, a1);
      (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t *))(*(void *)v7 + 496))(&lpsrc, v7, 0, &v12);
      if (v13) {
        sub_10004D2C8(v13);
      }
      if (lpsrc)
      {
        if (v8)
        {
          char v9 = v15;
          if (v15) {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v10 = 0;
          uint64_t v11 = 0;
          (*(void (**)(uint64_t *__return_ptr))(*(void *)v8 + 664))(&v10);
          if (v10) {
            (*(void (**)(uint64_t))(*(void *)v10 + 376))(v10);
          }
          if (v11) {
            sub_10004D2C8(v11);
          }
          if (v9) {
            sub_10004D2C8(v9);
          }
        }
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
      if (v6) {
        sub_10004D2C8(v6);
      }
    }
    lpsrc = &v16;
    sub_10005CBF0((void ***)&lpsrc);
  }
}

void sub_10106FD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, void **a14, std::__shared_weak_count *a15, char a16)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  a14 = (void **)&a16;
  sub_10005CBF0(&a14);
  _Unwind_Resume(a1);
}

void sub_10106FD7C(uint64_t a1)
{
}

uint64_t sub_10106FD84(PersonalitySpecificImpl *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 12);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    asStringUiMask((uint64_t *)__p, a2);
    if (v10 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I soMask: %{public}s", buf, 0xCu);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v6 = *((void *)a1 + 7);
  uint64_t v7 = PersonalitySpecificImpl::simSlot(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 440))(v6, v7, a2);
}

uint64_t sub_10106FEA4(uint64_t a1, uint64_t a2)
{
  return sub_10106FD84((PersonalitySpecificImpl *)(a1 - 24), a2);
}

void sub_10106FEAC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[12];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Searching through each PDP to send VoLTE data call type", (uint8_t *)&v10, 2u);
  }
  uint64_t v5 = a1[7];
  if (v5)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 264))(v5);
    uint64_t v7 = *(void **)v6;
    int v8 = *(void **)(v6 + 8);
    while (v7 != v8)
    {
      if ((*(unsigned int (**)(void, void))(*(void *)*v7 + 312))(*v7, 0))
      {
        uint64_t v9 = *v7;
        (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 16))(&v10, a1);
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v9 + 608))(v9, a2, &v10);
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      v7 += 2;
    }
  }
}

void sub_101070024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10107003C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_101070044(PersonalitySpecificImpl *a1, uint64_t a2)
{
  uint64_t v3 = *((void *)a1 + 7);
  uint64_t v4 = PersonalitySpecificImpl::simSlot(a1);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 448);

  return v5(v3, v4, a2);
}

uint64_t sub_1010700B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)(a1 - 24));
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 448);

  return v5(v3, v4, a2);
}

uint64_t sub_101070124(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 248))();
  }
  return result;
}

uint64_t sub_101070154(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 248))();
  }
  return result;
}

BOOL sub_101070184(uint64_t a1)
{
  return *(unsigned char *)(a1 + 377) == 0;
}

BOOL sub_101070194(uint64_t a1)
{
  return *(_DWORD *)(a1 + 288) == 4;
}

uint64_t sub_1010701A4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 212);
}

uint64_t sub_1010701AC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 208);
}

uint64_t sub_1010701B4(uint64_t a1)
{
  return *(void *)(a1 + 216);
}

uint64_t sub_1010701C4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 112);
  *a2 = *(void *)(result + 104);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1010701E0(uint64_t a1)
{
  return a1 + 424;
}

uint64_t sub_1010701E8(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 440) + 1);
  *(_DWORD *)(a1 + 440) = v1;
  return v1;
}

uint64_t sub_1010701FC(uint64_t result)
{
  return result;
}

uint64_t sub_10107020C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 293);
}

BOOL sub_101070214(void *a1)
{
  return *((unsigned char *)a1 + *(void *)(*a1 - 64) + 377) == 0;
}

uint64_t sub_10107023C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 88);
  *a2 = *(void *)(result + 80);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

BOOL sub_101070258(uint64_t a1)
{
  return *(_DWORD *)(a1 + 264) == 4;
}

uint64_t sub_101070268(uint64_t a1)
{
  return *(unsigned int *)(a1 + 188);
}

uint64_t sub_101070270(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 184);
}

uint64_t sub_101070278(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

uint64_t sub_101070288(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 268);
}

uint64_t sub_101070290(uint64_t a1)
{
  return a1 + 400;
}

uint64_t sub_101070298(uint64_t a1)
{
  uint64_t v1 = (*(_DWORD *)(a1 + 416) + 1);
  *(_DWORD *)(a1 + 416) = v1;
  return v1;
}

uint64_t sub_1010702AC(uint64_t result)
{
  return result;
}

uint64_t sub_1010702BC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 269);
}

uint64_t sub_1010702C4(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = 16777217;
  int v4 = 1;
  sub_100D96EEC((char **)a1, &v3);
  return a1;
}

void sub_101070318(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_101070334(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    int v4 = result;
    if (a4 >> 60) {
      sub_10006A748();
    }
    uint64_t result = sub_10006A794((uint64_t)(result + 2), a4);
    *int v4 = result;
    v4[1] = result;
    void v4[2] = &result[2 * v7];
    if (a2 != a3)
    {
      int v8 = result;
      do
      {
        void *v8 = *a2;
        uint64_t v9 = a2[1];
        v8[1] = v9;
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        result += 2;
        a2 += 2;
        v8 += 2;
      }
      while (a2 != a3);
    }
    v4[1] = result;
  }
  return result;
}

void sub_1010703E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1010703FC(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_10006A748();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    uint64_t v18 = v4;
    if (v12) {
      uint64_t v13 = (char *)sub_10006A794(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    std::string::size_type v14 = v13;
    std::string::size_type v15 = &v13[16 * v10];
    int v17 = &v13[16 * v12];
    bzero(v15, 16 * a2);
    uint64_t v16 = &v15[16 * a2];
    sub_101070500(a1, &v14);
    sub_1006C59A4(&v14);
  }
}

void sub_1010704EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006C59A4((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_101070500(uint64_t *a1, void *a2)
{
  uint64_t result = sub_101070578((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_101070578(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  void v12[2] = &v14;
  v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v14 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_101070608((uint64_t)v12);
  return v10;
}

uint64_t sub_101070608(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1006C5960(a1);
  }
  return a1;
}

void sub_101070644(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10107067C(uint64_t a1)
{
}

uint64_t sub_101070698(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1010706DC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10107070C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101070744(uint64_t a1)
{
}

uint64_t sub_101070760(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1010707A4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1010707D0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10107089C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[10], v1, (dispatch_function_t)sub_101070974);
  __cxa_rethrow();
}

void sub_1010708C4(_Unwind_Exception *a1)
{
}

void sub_1010708DC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101070914(uint64_t a1)
{
}

uint64_t sub_101070930(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101070974(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1010709A4()
{
}

__n128 sub_1010709B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A84998;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101070A0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A84998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101070A44(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_101070AC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101070B00()
{
}

void sub_101070B10()
{
}

__n128 sub_101070B24(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A84A18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101070B78(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A84A18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101070BB0(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 8);
  read_rest_value();
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }

  return v3(v5, v2);
}

uint64_t sub_101070C34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101070C74()
{
}

void sub_101070C84()
{
}

__n128 sub_101070C98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A84A98;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101070CEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A84A98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101070D24(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (unsigned char *)a1[1];
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_1001F299C((uint64_t *)&v10, a2);
  unsigned __int16 v9 = *(_WORD *)v3;
  long long v7 = v10;
  uint64_t v8 = v11;
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_100F78B08(v3, (void ***)&v7);
  unint64_t v12 = (void **)&v7;
  sub_1001F1FAC(&v12);
  if (AnyCallInfo::operator!=())
  {
    uint64_t v4 = (void (*)(void *, void))a1[3];
    uint64_t v5 = a1[4];
    uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
    if (v5) {
      uint64_t v4 = *(void (**)(void *, void))(*v6 + v4);
    }
    v4(v6, v9);
  }
  unint64_t v12 = (void **)&v10;
  sub_1001F1FAC(&v12);
}

void sub_101070E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 40) = v13;
  sub_1001F1FAC((void ***)(v14 - 40));
  *(void *)(v14 - 40) = &a13;
  sub_1001F1FAC((void ***)(v14 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_101070E44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101070E84()
{
}

uint64_t sub_101070E90(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)__n128 result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015B4EFALL & 0x7FFFFFFFFFFFFFFFLL)
        || (__n128 result = strcmp((const char *)result, (const char *)(0x80000001015B4EFALL & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_101070FD0(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_101A84B48 + 1;
  operator new();
}

void sub_101071104()
{
}

uint64_t sub_101071138(uint64_t a1)
{
  sub_1003595BC(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100980A44(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1010711BC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015B4F5BLL & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015B4F5BLL & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_101071264(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

void *sub_1010712AC(void *a1)
{
  *a1 = off_101A84BA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1010712F8(void *a1)
{
  *a1 = off_101A84BA8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_101071364(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_101071414(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10107142C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_10107144C()
{
}

void *sub_1010714B8(void *a1)
{
  *a1 = off_101A84BF8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101071504(void *a1)
{
  *a1 = off_101A84BF8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_101071570()
{
}

void *sub_1010715DC(void *a1)
{
  *a1 = off_101A84C38;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101071628(void *a1)
{
  *a1 = off_101A84C38;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_101071694(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A84C38;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1010716F8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A84C38;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101071738(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101071748(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101071788(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (a1[2])
      {
        uint64_t v6 = *(NSObject **)(v3 + 96);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = 136315138;
          uint64_t v8 = "operator()";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: new type is pushed", (uint8_t *)&v7, 0xCu);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_10107185C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10107189C()
{
}

void sub_1010718AC()
{
}

void *sub_1010718C0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A84CB8;
  result[1] = v3;
  return result;
}

uint64_t sub_101071908(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A84CB8;
  a2[1] = v2;
  return result;
}

void sub_101071934(uint64_t a1, unsigned __int8 *a2, uint64_t *a3)
{
  uint64_t v3 = *(os_log_t **)(a1 + 8);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = *a3;
    uint64_t v6 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315650;
      uint64_t v8 = "operator()";
      __int16 v9 = 1024;
      int v10 = v4;
      __int16 v11 = 2048;
      uint64_t v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: set_opportunistic_completion_t: success = %d, count = %lu", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

uint64_t sub_101071A04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101071A44()
{
}

void sub_101071A54()
{
}

void *sub_101071A68(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A84D48;
  result[1] = v3;
  return result;
}

uint64_t sub_101071AB0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A84D48;
  a2[1] = v2;
  return result;
}

void sub_101071ADC(uint64_t a1, unsigned __int8 *a2, uint64_t *a3)
{
  uint64_t v3 = *(os_log_t **)(a1 + 8);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = *a3;
    uint64_t v6 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315650;
      uint64_t v8 = "operator()";
      __int16 v9 = 1024;
      int v10 = v4;
      __int16 v11 = 2048;
      uint64_t v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: clear_opportunistic_completion_t: success = %d, count = %lu", (uint8_t *)&v7, 0x1Cu);
    }
  }
}

uint64_t sub_101071BAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101071BEC()
{
}

void *sub_101071BF8(void *a1)
{
  *a1 = off_101A84DC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101071C44(void *a1)
{
  *a1 = off_101A84DC8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_101071CB0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A84DC8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101071D14(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A84DC8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101071D54(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101071D64(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101071DA4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[2])
      {
        uint64_t v6 = *(NSObject **)(v3 + 96);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = 136315138;
          uint64_t v8 = "operator()";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: WiFiCalling AttachAPN has been reset", (uint8_t *)&v7, 0xCu);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_101071E78(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_101071EB8()
{
}

uint64_t sub_101071EC4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_101071ED4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101071EF0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_101071F00()
{
  {
    return __cxa_atexit((void (*)(void *))sub_10083FB4C, &ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_101071F40(id a1)
{
  qword_101B14150 = (uint64_t)os_log_create((const char *)qword_101B130D0, "msg.mms");
}

void sub_101071F70(id a1)
{
  qword_101B14160 = (uint64_t)os_log_create((const char *)qword_101B130D0, "msg.ctr");
}

void sub_101071FA0(id a1)
{
  qword_101B14170 = (uint64_t)os_log_create((const char *)qword_101B130D0, "msg.mms.pdu");
}

void sub_101071FD0()
{
  qword_101B130D0 = kCtLoggingSystemName;
}

const char *sub_101071FE8(int a1)
{
  uint64_t v1 = "lazuli.ims.del.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.ims.del.2";
  }
  if (a1 == 1) {
    return "lazuli.ims.del.1";
  }
  else {
    return v1;
  }
}

capabilities::ct *sub_101072014(capabilities::ct *a1)
{
  *(void *)a1 = 0;
  if ((capabilities::ct::supportsGemini(a1) & 1) == 0) {
    operator new();
  }
  if (!*(void *)a1) {
    operator new();
  }
  return a1;
}

void sub_10107216C(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

void sub_1010721D8(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleIncomingChat] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5565C(v9, (uint64_t)&__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010723BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101072418(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleSessionReady] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D56F40(v9, (uint64_t)&__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010725FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101072658(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleMessageReceived] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D572CC(v9, (uint64_t)&__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10107283C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101072898(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleMessageSend] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D58414(v9, (uint64_t)&__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101072A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101072AD8(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleSessionEvent] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D597F0(v9);
        xpc_release(object);
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101072CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101072D18(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleSessionTerminated] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5895C(v9, (uint64_t)&__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101072EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101072F58(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        __int16 v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleParticipantChange] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5987C(v9);
        xpc_release(object);
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10107313C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101073198(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 72);
      if (v7)
      {
        uint64_t v8 = SlotIdFromPersonalityId();
        uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          sub_100120074(a2, __p);
          uint64_t v10 = v14 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)std::string buf = 136380675;
          uint64_t v16 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleCapabilitiesReceived] %{private}s", buf, 0xCu);
          if (v14 < 0) {
            operator delete(__p[0]);
          }
        }
        xpc_object_t v11 = *a2;
        xpc_object_t object = v11;
        if (v11) {
          xpc_retain(v11);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5E05C(v7, &object);
        xpc_release(object);
        xpc_object_t object = 0;
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_101073308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10107334C(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleGroupChatUpdate] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5AF68(v9, (uint64_t)&__p, (uint64_t)&object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101073530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_10107358C(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleGroupChatCreated] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D59BD4(v9, &__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101073770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_1010737CC(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleParticipantAdded] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5CBEC(v9, (uint64_t)&__p, (uint64_t)&object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1010739B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101073A0C(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleParticipantRemoved] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5D2FC(v9, (uint64_t)&__p, (uint64_t)&object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101073BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101073C4C(uint64_t a1, void **a2, xpc_object_t *a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9)
      {
        uint64_t v10 = SlotIdFromPersonalityId();
        xpc_object_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *a2;
          sub_100120074(a3, &__p);
          uint64_t v13 = "OK";
          if (!v12) {
            uint64_t v13 = "(null)";
          }
          if (v21 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136315395;
          std::string::size_type v23 = v13;
          __int16 v24 = 2081;
          uint64_t v25 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleLeaveGroupChat] -> chat:%s, info: %{private}s", buf, 0x16u);
          if (v21 < 0) {
            operator delete(__p);
          }
        }
        std::string::size_type v15 = *a2;
        uint64_t v16 = (std::__shared_weak_count *)a2[1];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v20 = v16;
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        else
        {
          uint64_t v20 = 0;
        }
        xpc_object_t v17 = *a3;
        xpc_object_t object = v17;
        long long __p = v15;
        if (v17) {
          xpc_retain(v17);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D5DA0C(v9, (uint64_t)&__p, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v20) {
          sub_10004D2C8(v20);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_101073E30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_101073E8C(uint64_t a1, void **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 72);
      if (v7)
      {
        uint64_t v8 = SlotIdFromPersonalityId();
        uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [handleSpamReportResponse]", buf, 2u);
        }
        uint64_t v10 = *a2;
        xpc_object_t object = v10;
        if (v10) {
          xpc_retain(v10);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        sub_100D64184(v7, &object);
        xpc_release(object);
        xpc_object_t object = 0;
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_101073F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_101073FC0(uint64_t a1, uint64_t *a2, xpc_object_t *a3)
{
  uint64_t v6 = SlotIdFromPersonalityId();
  uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *a2 ? "OK" : "(null)";
    sub_100120074(a3, __p);
    uint64_t v9 = v14 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315395;
    uint64_t v16 = v8;
    __int16 v17 = 2081;
    uint64_t v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [sendMessage] -> chat:%s, info: %{private}s", buf, 0x16u);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v10 = *a2;
  xpc_object_t v11 = *a3;
  xpc_object_t object = v11;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v10 + 32))(v10, &object);
  xpc_release(object);
}

void sub_101074158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

void sub_101074190(uint64_t a1@<X0>, void *a2@<X1>, xpc_object_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = SlotIdFromPersonalityId();
  uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *a2 ? "OK" : "(null)";
    sub_100120074(a3, __p);
    xpc_object_t v11 = v18 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315395;
    uint64_t v20 = v10;
    __int16 v21 = 2081;
    uint64_t v22 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [startChat] -> chat:%s, info: %{private}s", buf, 0x16u);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  char v14 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t object = *a3;
  if (*a3) {
    xpc_retain(*a3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ims::lazuli::Chat::startChat();
  *a4 = v15;
  a4[1] = v16;
  if (v16)
  {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v16);
  }
  xpc_release(object);
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_101074358(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11)
{
}

void sub_1010743A0(uint64_t a1)
{
  uint64_t v2 = SlotIdFromPersonalityId();
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 104) + 16))(*(void *)(a1 + 104), v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [CT] <<== laz <<== [IPT] [getChatServices]", buf, 2u);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 64);
  uint64_t v5 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ims::lazuli::ChatServices::create();
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_101074478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

ims::lazuli::ChatDelegate *sub_101074490(ims::lazuli::ChatDelegate *a1)
{
  sub_10132CB50(a1);
  uint64_t v3 = *(void *)(v2 + 104);
  *((void *)a1 + 13) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)a1 + 12);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1010744F4(ims::lazuli::ChatDelegate *a1)
{
  sub_10132CB50(a1);
  uint64_t v3 = *(void *)(v2 + 104);
  *((void *)a1 + 13) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = (std::__shared_weak_count *)*((void *)a1 + 12);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void sub_10107457C()
{
}

uint64_t sub_101074590(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  SlotIdFromPersonalityId();
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 104) + 16);

  return v2();
}

void sub_1010745F4(unsigned int *a1@<X1>, uint64_t *a2@<X2>, NSObject **a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X5>, void *a6@<X8>)
{
  uint64_t v12 = operator new(0x88uLL);
  sub_101074698(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;

  sub_1000B3BC8((uint64_t)a6, v12 + 14, (uint64_t)(v12 + 3));
}

void sub_101074684(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_101074698(void *a1, unsigned int *a2, uint64_t *a3, NSObject **a4, uint64_t *a5, uint64_t *a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A850A8;
  sub_101074790(a1 + 3, a2, a3, a4, a5, a6);
  return a1;
}

void sub_1010746E0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1010746F4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A850A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101074714(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A850A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101074768(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_101074790(void *a1, unsigned int *a2, uint64_t *a3, NSObject **a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v8 = *a2;
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = *a3;
  uint64_t v16 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a5;
  uint64_t v10 = (std::__shared_weak_count *)a5[1];
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *a6;
  uint64_t v12 = (std::__shared_weak_count *)a6[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  a1[11] = 0;
  a1[12] = 0;
  v21[0] = off_101999E18;
  v21[1] = sub_101071FE8;
  v21[3] = v21;
  sub_101072014((capabilities::ct *)(a1 + 13));
  sub_10008863C(v21);
  uint64_t v19 = v15;
  uint64_t v20 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v18[0] = v11;
  v18[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v17[0] = v13;
  v17[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132C89C(a1, v8, &v19, a4, v18, v17);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_101A84F58;
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  return a1;
}

void sub_10107495C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, char a18)
{
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  uint64_t v23 = *v21;
  *__int16 v21 = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  __int16 v24 = *(std::__shared_weak_count **)(v18 + 96);
  if (v24)
  {
    std::__shared_weak_count::__release_weak(v24);
    if (!v20)
    {
LABEL_11:
      if (!v19) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else if (!v20)
  {
    goto LABEL_11;
  }
  std::__shared_weak_count::__release_weak(v20);
  if (!v19)
  {
LABEL_13:
    if (a11) {
      sub_10004D2C8(a11);
    }
    _Unwind_Resume(exception_object);
  }
LABEL_12:
  sub_10004D2C8(v19);
  goto LABEL_13;
}

void sub_101074A08(unsigned int *a1@<X1>, uint64_t *a2@<X2>, NSObject **a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0x88uLL);
  sub_101074A9C(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;

  sub_1000B3BC8((uint64_t)a5, v10 + 14, (uint64_t)(v10 + 3));
}

void sub_101074A88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_101074A9C(void *a1, unsigned int *a2, uint64_t *a3, NSObject **a4, uint64_t *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A850A8;
  sub_101074AF8(a1 + 3, a2, a3, a4, a5);
  return a1;
}

void sub_101074AE4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *sub_101074AF8(void *a1, unsigned int *a2, uint64_t *a3, NSObject **a4, uint64_t *a5)
{
  uint64_t v7 = *a2;
  uint64_t v8 = (std::__shared_weak_count *)a3[1];
  uint64_t v12 = *a3;
  uint64_t v13 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *a5;
  uint64_t v9 = (std::__shared_weak_count *)a5[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  a1[11] = 0;
  a1[12] = 0;
  v17[0] = off_101999E18;
  v17[1] = sub_101071FE8;
  v17[3] = v17;
  sub_101072014((capabilities::ct *)(a1 + 13));
  sub_10008863C(v17);
  uint64_t v15 = v12;
  uint64_t v16 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v14[0] = v10;
  v14[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132C974(a1, v7, &v15, a4, v14);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  *a1 = off_101A84F58;
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  return a1;
}

void sub_101074C78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, char a16)
{
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  uint64_t v20 = *v18;
  *uint64_t v18 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  __int16 v21 = *(std::__shared_weak_count **)(v16 + 96);
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_101074D00()
{
}

uint64_t sub_101074D74@<X0>(void *a1@<X8>)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = a1 + 1;
  uint64_t result = subscriber::makeSimSlotRange();
  uint64_t v2 = v4;
  if (v4 != v5)
  {
    while (1)
    {
      uint64_t result = v6(*v2);
      if (result) {
        break;
      }
      if (++v2 == v5)
      {
        uint64_t v2 = v5;
        break;
      }
    }
    if (v2 != v5) {
      sub_10013B994(&v3);
    }
  }
  return result;
}

void sub_101074EFC(_Unwind_Exception *a1)
{
  sub_10005D0E4(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_101074F34(NetworkNameFactoryInterface *this)
{
  *(void *)this = off_101A850F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  NetworkNameFactoryInterface::~NetworkNameFactoryInterface(this);
}

void sub_101074F90(NetworkNameFactoryInterface *this)
{
  *(void *)this = off_101A850F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NetworkNameFactoryInterface::~NetworkNameFactoryInterface(this);

  operator delete();
}

void sub_101075000()
{
}

void sub_101075098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  if (v10) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *sub_1010750CC(void *a1, void *a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "pp.cb");
  sub_1010751C8(a1 + 1, a3, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *a1 = off_101A85160;
  a1[6] = *a2;
  uint64_t v6 = a2[1];
  a1[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  a1[10] = 0;
  a1[9] = 0;
  a1[8] = a1 + 9;
  return a1;
}

void sub_1010751A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CarrierBundleMatchProxyInterface::~CarrierBundleMatchProxyInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_1010751C8(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_101075230(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_101075254(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *(void *)a1 = off_101A85160;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    int v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  int v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11)
  {
LABEL_14:
    if (v12) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_10:
  if (*(void *)(a1 + 80))
  {
    sub_10069AF38(v15, a1 + 64);
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v11 + 88))(v11, v15);
    sub_10069AE60((uint64_t)v15, (const void **)v15[1]);
    if (v12) {
      goto LABEL_16;
    }
LABEL_15:
    sub_10004D2C8(v10);
    goto LABEL_16;
  }
  uint64_t v13 = *(NSObject **)(a1 + 40);
  if (!os_log_type_enabled(v13, OS_LOG_TYPE_FAULT)) {
    goto LABEL_14;
  }
  *(_WORD *)std::string buf = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "Empty matching results", buf, 2u);
  if ((v12 & 1) == 0) {
    goto LABEL_15;
  }
LABEL_16:
  sub_10069AE60(a1 + 64, *(const void ***)(a1 + 72));
  char v14 = *(std::__shared_weak_count **)(a1 + 56);
  if (v14) {
    sub_10004D2C8(v14);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  CarrierBundleMatchProxyInterface::~CarrierBundleMatchProxyInterface((CarrierBundleMatchProxyInterface *)a1);
}

void sub_10107542C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  sub_101075254(a1, a2);

  operator delete();
}

void sub_101075464(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_10000BE9C((uint64_t)v6, a3);
  v6[200] = *(unsigned char *)(a3 + 200);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10107564C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101075718(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1010757F0);
  __cxa_rethrow();
}

void sub_101075740(_Unwind_Exception *a1)
{
}

void sub_101075758(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101075790(uint64_t a1)
{
}

uint64_t sub_1010757AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1010757F0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_10107581C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v35 = a1;
  uint64_t v36 = v1;
  uint64_t v2 = *(void *)v1;
  long long v3 = (uint64_t *)(*(void *)v1 + 72);
  uint64_t v4 = *v3;
  if (!*v3) {
    goto LABEL_11;
  }
  int v5 = *(_DWORD *)(v1 + 8);
  uint64_t v6 = *(void *)v1 + 72;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < v5;
    if (v7 >= v5) {
      uint64_t v9 = (uint64_t *)v4;
    }
    else {
      uint64_t v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if ((uint64_t *)v6 == v3 || (long long v3 = (uint64_t *)*(unsigned int *)(v6 + 32), v5 < (int)v3))
  {
LABEL_11:
    ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v2 + 48));
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v12;
    uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint64_t v18 = v16[3];
      __int16 v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        if (!v18) {
          goto LABEL_17;
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    __int16 v17 = 0;
    char v19 = 1;
    if (!v18)
    {
LABEL_17:
      uint64_t v20 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Could not get CarrierBundleInterface", buf, 2u);
      }
LABEL_25:
      if ((v19 & 1) == 0) {
        sub_10004D2C8(v17);
      }
      goto LABEL_29;
    }
LABEL_21:
    uint64_t v21 = *(unsigned int *)(v1 + 8);
    uint64_t v22 = *(std::__shared_weak_count **)(v2 + 16);
    *(void *)std::string buf = *(void *)(v2 + 8);
    if (v22)
    {
      *(void *)&uint8_t buf[8] = std::__shared_weak_count::lock(v22);
      if (*(void *)&buf[8])
      {
        int v38 = *(_DWORD *)(v1 + 8);
        sub_10000BE9C((uint64_t)&v39, v1 + 16);
        char v23 = *(unsigned char *)(v1 + 216);
        char v56 = v23;
        uint64_t v58 = 0;
        __int16 v24 = (char *)operator new(0xF0uLL);
        *(void *)__int16 v24 = off_101A85290;
        *(_OWORD *)(v24 + 8) = *(_OWORD *)buf;
        memset(buf, 0, sizeof(buf));
        *((_DWORD *)v24 + 6) = v38;
        *((_OWORD *)v24 + 2) = v39;
        *((void *)v24 + 6) = v40;
        long long v39 = 0uLL;
        uint64_t v40 = 0;
        *(_OWORD *)(v24 + 56) = v41;
        *((void *)v24 + 9) = v42;
        long long v41 = 0uLL;
        long long v25 = v43;
        *((void *)v24 + 12) = v44;
        *((_OWORD *)v24 + 5) = v25;
        uint64_t v42 = 0;
        long long v43 = 0uLL;
        uint64_t v44 = 0;
        long long v26 = v45;
        uint64_t v27 = v48;
        *((void *)v24 + 15) = v46;
        *(_OWORD *)(v24 + 104) = v26;
        long long v45 = 0uLL;
        long long v28 = v47;
        *((void *)v24 + 18) = v27;
        *((_OWORD *)v24 + 8) = v28;
        uint64_t v46 = 0;
        long long v47 = 0uLL;
        uint64_t v48 = 0;
        v24[152] = v49;
        long long v29 = v50;
        *((void *)v24 + 22) = v51;
        *((_OWORD *)v24 + 10) = v29;
        long long v50 = 0uLL;
        long long v30 = v52;
        uint64_t v31 = v55;
        *((void *)v24 + 25) = v53;
        *(_OWORD *)(v24 + 184) = v30;
        uint64_t v51 = 0;
        long long v52 = 0uLL;
        uint64_t v53 = 0;
        long long v32 = v54;
        *((void *)v24 + 28) = v31;
        *((_OWORD *)v24 + 13) = v32;
        long long v54 = 0uLL;
        uint64_t v55 = 0;
        v24[232] = v23;
        uint64_t v58 = v24;
        (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v18 + 208))(v18, v21, v57);
        sub_100687DFC(v57);
        sub_10000BDF8((uint64_t)&v39);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_25;
      }
    }
    else
    {
      *(void *)&uint8_t buf[8] = 0;
    }
    sub_100088B9C();
  }
  uint64_t v33 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Already have match result for %s", buf, 0xCu);
  }
LABEL_29:
  sub_101075C34(&v36);
  return sub_100046B58((uint64_t *)&v35);
}

void sub_101075BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_100687DFC((void *)(v15 - 104));
  sub_10000BDF8(v13);
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_101075C34(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101075C34(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10000BDF8(v1 + 16);
    operator delete();
  }
  return result;
}

void *sub_101075C84(void *a1)
{
  *a1 = off_101A85290;
  sub_10000BDF8((uint64_t)(a1 + 4));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101075CD4(void *a1)
{
  *a1 = off_101A85290;
  sub_10000BDF8((uint64_t)(a1 + 4));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_101075D44(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xF0uLL);
  *uint64_t v2 = off_101A85290;
  sub_1010760F0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_101075D98(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101075DAC(uint64_t a1, void *a2)
{
  *a2 = off_101A85290;
  return sub_1010760F0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_101075DD8(uint64_t a1)
{
}

void sub_101075DE0(void *a1)
{
  sub_101076164((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101075E1C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10000BE9C((uint64_t)v7, a1 + 32);
  v7[200] = *(unsigned char *)(a1 + 232);
  v7[208] = *(unsigned char *)a2;
  sub_100058198((const void **)&v8, (const void **)(a2 + 8));
  sub_100058198((const void **)&v8 + 1, (const void **)(a2 + 16));
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101076088(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1010760A4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A85300)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1010760E4()
{
  return &off_101A85300;
}

uint64_t sub_1010760F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  sub_10000BE9C(a1 + 24, a2 + 24);
  *(unsigned char *)(a1 + 224) = *(unsigned char *)(a2 + 224);
  return a1;
}

void sub_10107614C(_Unwind_Exception *exception_object)
{
  long long v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101076164(uint64_t a1)
{
  sub_10000BDF8(a1 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t *sub_1010761B0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  sub_10000BE9C((uint64_t)&v17, v1 + 24);
  char v34 = *(unsigned char *)(v1 + 224);
  char v35 = *(unsigned char *)(v1 + 232);
  sub_100058198((const void **)&v36, (const void **)(v1 + 240));
  sub_100058198((const void **)&v36 + 1, (const void **)(v1 + 248));
  uint64_t v5 = *(uint64_t **)(v2 + 72);
  uint64_t v4 = (uint64_t **)(v2 + 72);
  long long v3 = v5;
  int v6 = *(_DWORD *)(v1 + 16);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v3;
        int v8 = *((_DWORD *)v3 + 8);
        if (v8 <= v6) {
          break;
        }
        long long v3 = *v7;
        uint64_t v9 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= v6) {
        break;
      }
      long long v3 = v7[1];
      if (!v3)
      {
        uint64_t v9 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = v4;
    int v7 = v4;
LABEL_9:
    int v10 = (char *)operator new(0x110uLL);
    *((_DWORD *)v10 + 8) = v6;
    *((void *)v10 + 7) = v18;
    *((void *)v10 + 10) = v20;
    *((void *)v10 + 13) = v22;
    *((void *)v10 + 16) = v24;
    *((void *)v10 + 19) = v26;
    v10[160] = v27;
    uint64_t v11 = v31;
    *((void *)v10 + 23) = v29;
    *(_OWORD *)(v10 + 40) = v17;
    long long v17 = 0uLL;
    *((_OWORD *)v10 + 4) = v19;
    uint64_t v18 = 0;
    long long v19 = 0uLL;
    uint64_t v20 = 0;
    *(_OWORD *)(v10 + 88) = v21;
    long long v21 = 0uLL;
    *((_OWORD *)v10 + 7) = v23;
    uint64_t v22 = 0;
    long long v23 = 0uLL;
    uint64_t v24 = 0;
    *(_OWORD *)(v10 + 136) = v25;
    long long v25 = 0uLL;
    *(_OWORD *)(v10 + 168) = v28;
    uint64_t v26 = 0;
    long long v28 = 0uLL;
    long long v12 = v30;
    *((void *)v10 + 26) = v11;
    *((_OWORD *)v10 + 12) = v12;
    uint64_t v31 = 0;
    uint64_t v29 = 0;
    long long v30 = 0uLL;
    long long v13 = v32;
    *((void *)v10 + 29) = v33;
    *(_OWORD *)(v10 + 216) = v13;
    long long v32 = 0uLL;
    uint64_t v33 = 0;
    v10[240] = v34;
    v10[248] = v35;
    *((_OWORD *)v10 + 16) = v36;
    long long v36 = 0uLL;
    sub_100046C38(v4 - 1, (uint64_t)v7, v9, (uint64_t *)v10);
  }
  sub_100057D78((const void **)&v36 + 1);
  sub_100057D78((const void **)&v36);
  sub_10000BDF8((uint64_t)&v17);
  sub_1010763E0(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_1010763A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  sub_100057D78(v3);
  sub_100057D78(v2);
  sub_10000BDF8((uint64_t)va2);
  sub_1010763E0((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1010763E0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100057D78((const void **)(v1 + 248));
    sub_100057D78((const void **)(v1 + 240));
    sub_10000BDF8(v1 + 24);
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

BOOL sub_10107644C(uint64_t a1)
{
  BOOL v11 = 0;
  uint64_t v2 = sub_100365D74();
  sub_100058DB0(__p, "EnableThumperByDefault");
  BOOL v3 = sub_1002260B0(v2, __p, &v11);
  BOOL v4 = v3;
  if (v10 < 0)
  {
    operator delete(__p[0]);
    if (v4) {
      goto LABEL_3;
    }
  }
  else if (v3)
  {
LABEL_3:
    LODWORD(v5) = v11;
    return v5 != 0;
  }
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 160) + 472))(__p);
  uint64_t v5 = (BOOL *)__p[0];
  unsigned __int8 v12 = 0;
  if (__p[0])
  {
    CFTypeID v6 = CFGetTypeID(__p[0]);
    if (v6 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v12, v5, v7);
      LODWORD(v5) = v12;
    }
    else
    {
      LODWORD(v5) = 0;
    }
  }
  sub_1000577C4((const void **)__p);
  return v5 != 0;
}

void sub_101076550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

BOOL sub_10107657C(uint64_t a1)
{
  void (***v10)(uint64_t *__return_ptr, void, uint64_t);
  char v11;
  const void *Value;
  CFBooleanRef v13;
  uint64_t (*v14)(uint64_t);
  BOOL v15;
  const void *v17;
  BOOL *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;

  long long v21 = 0;
  uint64_t v22 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  BOOL v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  long long v19 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v19);
  if (v8)
  {
    char v10 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      BOOL v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    char v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  BOOL v11 = 1;
LABEL_9:
  (**v10)(&v21, v10, **(void **)(a1 + 144) + 24);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v21)
  {
    long long v19 = 0;
    uint64_t v20 = 0;
    (*(void (**)(unint64_t *__return_ptr))(*(void *)v21 + 64))(&v19);
    if (v19)
    {
      uint64_t v18 = 0;
      int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v19 + 64), @"DisableSecondaryCredentials");
      long long v17 = Value;
      if (Value) {
        CFRetain(Value);
      }
      sub_1000057AC(&v18, &v17);
      sub_1000577C4(&v17);
      if (v18) {
        char v14 = sub_100084B4C;
      }
      else {
        char v14 = 0;
      }
      if (v14)
      {
        LOBYTE(v17) = 0;
        ctu::cf::assign((ctu::cf *)&v17, v18, v13);
        uint64_t v15 = (_BYTE)v17 != 0;
      }
      else
      {
        uint64_t v15 = 1;
      }
      sub_100062778((const void **)&v18);
    }
    else
    {
      uint64_t v15 = 1;
    }
    if (v20) {
      sub_10004D2C8(v20);
    }
  }
  else
  {
    uint64_t v15 = 1;
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  return v15;
}

void sub_10107677C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(a1);
}

void sub_1010767D0()
{
  if (v0) {
    JUMPOUT(0x1010767C8);
  }
  JUMPOUT(0x1010767C0);
}

BOOL *sub_1010767E0(uint64_t a1)
{
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)a1 + 472))(&cf);
  uint64_t v1 = (BOOL *)cf;
  char v6 = 0;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v6, v1, v3);
      uint64_t v1 = (BOOL *)(v6 != 0);
    }
    else
    {
      uint64_t v1 = 0;
    }
  }
  sub_1000577C4(&cf);
  return v1;
}

void sub_101076890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL *sub_1010768A4(uint64_t a1)
{
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 160) + 472))(&cf);
  uint64_t v1 = (BOOL *)cf;
  char v6 = 0;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v6, v1, v3);
      uint64_t v1 = (BOOL *)(v6 != 0);
    }
    else
    {
      uint64_t v1 = 0;
    }
  }
  sub_1000577C4(&cf);
  return v1;
}

void sub_101076958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_10107696C(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  CFBooleanRef v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v18);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  int v12 = 1;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v10 + 96))(&cf, v10, *(unsigned int *)(**(void **)(a1 + 144) + 52), 1, @"PrimaryDeviceGetsProvisioningInformation", 0, 0);
  long long v13 = (BOOL *)cf;
  LOBYTE(v18) = 1;
  if (cf)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v18, v13, v15);
      int v12 = v18;
    }
    else
    {
      int v12 = 1;
    }
  }
  sub_1000577C4(&cf);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return v12 == 0;
}