uint64_t sub_1007C8FD8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void sub_1007C8FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315906;
    *(void *)&buf[4] = "handleContextActivateError";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = asString();
    __int16 v10 = 2080;
    uint64_t v11 = asString();
    __int16 v12 = 2048;
    uint64_t v13 = a7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s: %s: %s connectionMask %lld", buf, 0x2Au);
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = 0;
  sub_1007C1FA8();
}

void sub_1007C91C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007C91F8(uint64_t a1, uint64_t a2, void *a3, unsigned int a4, int a5, int a6)
{
  if (a5)
  {
    v9 = a3;
    uint64_t v11 = (*(uint64_t (**)(void))(*(void *)*a3 + 152))();
    memset(&buf, 0, sizeof(buf));
    (*(void (**)(void, uint64_t))(*(void *)*v9 + 96))(*v9, a2);
    CSIPacketAddress::operator std::string();
    *(_DWORD *)((char *)v104 + 3) = 0;
    v104[0] = 0;
    *(_DWORD *)((char *)v103 + 3) = 0;
    v103[0] = 0;
    v100 = 0;
    v101 = 0;
    uint64_t v102 = 0;
    __int16 v12 = (uint64_t *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v9 + 120))(*v9, a2);
    v100 = 0;
    v101 = 0;
    uint64_t v102 = 0;
    sub_1007CC088(&v100, *v12, v12[1], 0xAAAAAAAAAAAAAAABLL * ((v12[1] - *v12) >> 3));
    uint64_t v13 = v101;
    if (v101 == v100)
    {
      __src = 0;
      unint64_t v14 = 0;
      char v54 = 0;
      v15 = v101;
    }
    else
    {
      CSIPacketAddress::operator std::string();
      unint64_t v14 = *(void *)&__dst.tv_usec;
      __src = (void *)__dst.tv_sec;
      v104[0] = v99;
      *(_DWORD *)((char *)v104 + 3) = *(_DWORD *)((char *)&v99 + 3);
      char v54 = HIBYTE(v99);
      uint64_t v13 = v100;
      v15 = v101;
    }
    int v61 = a2;
    unint64_t v53 = v14;
    if (0xAAAAAAAAAAAAAAABLL * ((v15 - v13) >> 3) < 2)
    {
      tv_sec = 0;
      unint64_t v52 = 0;
      char v18 = 0;
    }
    else
    {
      CSIPacketAddress::operator std::string();
      tv_sec = (void *)__dst.tv_sec;
      unint64_t v52 = *(void *)&__dst.tv_usec;
      v103[0] = v99;
      *(_DWORD *)((char *)v103 + 3) = *(_DWORD *)((char *)&v99 + 3);
      char v18 = HIBYTE(v99);
    }
    int v19 = (*(uint64_t (**)(void))(*(void *)*v9 + 56))();
    if (v19 == 1) {
      int v20 = a6;
    }
    else {
      int v20 = a5;
    }
    int v59 = v20;
    int v60 = v19;
    int v58 = (*(uint64_t (**)(void))(*(void *)*v9 + 64))();
    __dst.tv_sec = 0;
    *(void *)&__dst.unint64_t tv_usec = 0;
    gettimeofday(&__dst, 0);
    __darwin_time_t v21 = __dst.tv_sec;
    unint64_t tv_usec = __dst.tv_usec;
    uint64_t v23 = *(void *)(v11 + 160);
    __dst.tv_sec = 0;
    *(void *)&__dst.unint64_t tv_usec = 0;
    uint64_t v99 = 0;
    if (*(char *)(v11 + 103) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(v11 + 80), *(void *)(v11 + 88));
    }
    else
    {
      timeval __dst = *(timeval *)(v11 + 80);
      uint64_t v99 = *(void *)(v11 + 96);
    }
    long long v96 = 0uLL;
    uint64_t v97 = 0;
    if (*(char *)(v11 + 127) < 0)
    {
      sub_10004FC84(&v96, *(void **)(v11 + 104), *(void *)(v11 + 112));
    }
    else
    {
      long long v96 = *(_OWORD *)(v11 + 104);
      uint64_t v97 = *(void *)(v11 + 120);
    }
    long long v94 = 0uLL;
    uint64_t v95 = 0;
    if (*(char *)(v11 + 151) < 0)
    {
      sub_10004FC84(&v94, *(void **)(v11 + 128), *(void *)(v11 + 136));
    }
    else
    {
      long long v94 = *(_OWORD *)(v11 + 128);
      uint64_t v95 = *(void *)(v11 + 144);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    v25 = ServiceMap;
    if (v26 < 0)
    {
      v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        uint64_t v26 = v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v92 = v26;
    v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&v92);
    unint64_t v50 = tv_usec;
    if (v30)
    {
      *(void *)v56 = v11;
      __darwin_time_t v31 = v21;
      uint64_t v32 = v23;
      v33 = v9;
      uint64_t v35 = v30[3];
      v34 = (std::__shared_weak_count *)v30[4];
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v25);
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        v49 = v34;
        sub_10004D2C8(v34);
        char v51 = 0;
        v9 = v33;
        uint64_t v23 = v32;
        __darwin_time_t v21 = v31;
        uint64_t v11 = *(void *)v56;
        if (!v35)
        {
LABEL_28:
          int v57 = -1;
LABEL_33:
          uint64_t v36 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v9 + 192))(*v9, 1);
          int v37 = *(_DWORD *)(v11 + 168);
          long long v92 = 0uLL;
          uint64_t v93 = 0;
          uint64_t v38 = *(void *)(a1 + 88);
          uint64_t v39 = (*(uint64_t (**)(void))(*(void *)*v9 + 56))();
          (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v38 + 40))(&v92, v38, v39);
          v90[1] = 0;
          v90[0] = 0;
          uint64_t v91 = 0;
          if (*(char *)(v11 + 31) < 0)
          {
            sub_10004FC84(v90, *(void **)(v11 + 8), *(void *)(v11 + 16));
          }
          else
          {
            *(_OWORD *)v90 = *(_OWORD *)(v11 + 8);
            uint64_t v91 = *(void *)(v11 + 24);
          }
          int v40 = 0;
          uint64_t v41 = 1000 * v21 + v50 / 0x3E8 - v23;
          unint64_t v42 = 1;
          do
          {
            int v43 = v40 | 0x10000000;
            if (v42 <= 0x10000000) {
              int v43 = v40 | v42;
            }
            if ((v42 & v36) != 0) {
              int v40 = v43;
            }
            unint64_t v44 = v42 >> 35;
            v42 *= 2;
          }
          while (!v44);
          uint64_t v45 = a1;
          int v46 = *(_DWORD *)(a1 + 80);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v89, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
          }
          else {
            std::string v89 = buf;
          }
          if (v54 < 0)
          {
            sub_10004FC84(&v86, __src, v53);
          }
          else
          {
            *(void *)&long long v86 = __src;
            *((void *)&v86 + 1) = v53;
            *(_DWORD *)v87 = v104[0];
            *(_DWORD *)&v87[3] = *(_DWORD *)((char *)v104 + 3);
            char v88 = v54;
          }
          if (v18 < 0)
          {
            sub_10004FC84(&v83, tv_sec, v52);
          }
          else
          {
            *(void *)&long long v83 = tv_sec;
            *((void *)&v83 + 1) = v52;
            *(_DWORD *)v84 = v103[0];
            *(_DWORD *)&v84[3] = *(_DWORD *)((char *)v103 + 3);
            char v85 = v18;
          }
          if (SHIBYTE(v93) < 0)
          {
            sub_10004FC84(v81, (void *)v92, *((unint64_t *)&v92 + 1));
          }
          else
          {
            *(_OWORD *)v81 = v92;
            uint64_t v82 = v93;
          }
          if (SHIBYTE(v99) < 0)
          {
            sub_10004FC84(v79, (void *)__dst.tv_sec, *(unint64_t *)&__dst.tv_usec);
          }
          else
          {
            *(timeval *)v79 = __dst;
            uint64_t v80 = v99;
          }
          if (SHIBYTE(v97) < 0)
          {
            sub_10004FC84(v77, (void *)v96, *((unint64_t *)&v96 + 1));
          }
          else
          {
            *(_OWORD *)v77 = v96;
            uint64_t v78 = v97;
          }
          if (SHIBYTE(v95) < 0)
          {
            sub_10004FC84(v75, (void *)v94, *((unint64_t *)&v94 + 1));
          }
          else
          {
            *(_OWORD *)v75 = v94;
            uint64_t v76 = v95;
          }
          if (SHIBYTE(v91) < 0)
          {
            sub_10004FC84(__p, v90[0], (unint64_t)v90[1]);
          }
          else
          {
            *(_OWORD *)__p = *(_OWORD *)v90;
            uint64_t v74 = v91;
          }
          sub_10017C370(a4, v46, 0, v59, &v89, &v86, &v83, v57, (long long *)v81, v60, v40, v41, (long long *)v79, (long long *)v77, (long long *)v75, v58, v61, v37, (long long *)__p);
          if (SHIBYTE(v74) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v76) < 0) {
            operator delete(v75[0]);
          }
          if (SHIBYTE(v78) < 0) {
            operator delete(v77[0]);
          }
          if (SHIBYTE(v80) < 0) {
            operator delete(v79[0]);
          }
          if (SHIBYTE(v82) < 0) {
            operator delete(v81[0]);
          }
          if (v85 < 0) {
            operator delete((void *)v83);
          }
          if (v88 < 0) {
            operator delete((void *)v86);
          }
          if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v89.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v91) < 0)
          {
            sub_10004FC84(v71, v90[0], (unint64_t)v90[1]);
          }
          else
          {
            *(_OWORD *)v71 = *(_OWORD *)v90;
            uint64_t v72 = v91;
          }
          if (SHIBYTE(v93) < 0)
          {
            sub_10004FC84(v69, (void *)v92, *((unint64_t *)&v92 + 1));
          }
          else
          {
            *(_OWORD *)v69 = v92;
            uint64_t v70 = v93;
          }
          int v47 = *(_DWORD *)(v45 + 80);
          if (SHIBYTE(v95) < 0)
          {
            sub_10004FC84(v67, (void *)v94, *((unint64_t *)&v94 + 1));
          }
          else
          {
            *(_OWORD *)v67 = v94;
            uint64_t v68 = v95;
          }
          if (SHIBYTE(v97) < 0)
          {
            sub_10004FC84(v65, (void *)v96, *((unint64_t *)&v96 + 1));
          }
          else
          {
            *(_OWORD *)v65 = v96;
            uint64_t v66 = v97;
          }
          if (SHIBYTE(v99) < 0)
          {
            sub_10004FC84(v63, (void *)__dst.tv_sec, *(unint64_t *)&__dst.tv_usec);
          }
          else
          {
            *(timeval *)v63 = __dst;
            uint64_t v64 = v99;
          }
          LODWORD(v48) = v58;
          sub_1007C2160(v45, (const char *)v71, v41, (const char *)v69, v36, v47, v60, (const char *)v67, __SPAIR64__(v57, v61), __SPAIR64__(v59, v37), a4, 0, v48, (uint64_t)v65, (uint64_t)v63);
          if (SHIBYTE(v64) < 0) {
            operator delete(v63[0]);
          }
          if (SHIBYTE(v66) < 0) {
            operator delete(v65[0]);
          }
          if (SHIBYTE(v68) < 0) {
            operator delete(v67[0]);
          }
          if (SHIBYTE(v70) < 0) {
            operator delete(v69[0]);
          }
          if (SHIBYTE(v72) < 0) {
            operator delete(v71[0]);
          }
          if (SHIBYTE(v91) < 0) {
            operator delete(v90[0]);
          }
          if (SHIBYTE(v93) < 0) {
            operator delete((void *)v92);
          }
          if ((v51 & 1) == 0) {
            sub_10004D2C8(v49);
          }
          if (SHIBYTE(v95) < 0) {
            operator delete((void *)v94);
          }
          if (SHIBYTE(v97) < 0) {
            operator delete((void *)v96);
          }
          if (SHIBYTE(v99) < 0) {
            operator delete((void *)__dst.tv_sec);
          }
          if (v100)
          {
            v101 = v100;
            operator delete(v100);
          }
          if (v18 < 0)
          {
            operator delete(tv_sec);
            if ((v54 & 0x80) == 0) {
              goto LABEL_123;
            }
          }
          else if ((v54 & 0x80) == 0)
          {
            goto LABEL_123;
          }
          operator delete(__src);
LABEL_123:
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          return;
        }
LABEL_32:
        int v57 = (*(uint64_t (**)(uint64_t, void))(*(void *)v35 + 976))(v35, a4);
        goto LABEL_33;
      }
      v9 = v33;
      uint64_t v23 = v32;
      __darwin_time_t v21 = v31;
      uint64_t v11 = *(void *)v56;
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v25);
    v49 = 0;
    char v51 = 1;
    if (!v35) {
      goto LABEL_28;
    }
    goto LABEL_32;
  }
  v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"reportContextActivateErrorMetrics";
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s: Activate failed without error, huh?", (uint8_t *)&buf, 0xCu);
  }
}

void sub_1007C9C3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, int a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  if (a53 < 0) {
    operator delete(a48);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  if (SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  if (SLOBYTE(STACK[0x25F]) < 0) {
    operator delete((void *)STACK[0x248]);
  }
  if ((a21 & 1) == 0) {
    sub_10004D2C8(a18);
  }
  if (*(char *)(v64 - 233) < 0) {
    operator delete(*(void **)(v64 - 256));
  }
  if (*(char *)(v64 - 201) < 0) {
    operator delete(*(void **)(v64 - 224));
  }
  if (*(char *)(v64 - 169) < 0) {
    operator delete(*(void **)(v64 - 192));
  }
  uint64_t v66 = *(void **)(v64 - 168);
  if (v66)
  {
    *(void *)(v64 - 160) = v66;
    operator delete(v66);
    if ((v60 & 0x80) == 0)
    {
LABEL_23:
      if ((v61 & 0x80) == 0)
      {
LABEL_28:
        if (*(char *)(v64 - 105) < 0) {
          operator delete(*(void **)(v64 - 128));
        }
        _Unwind_Resume(a1);
      }
LABEL_27:
      operator delete(v62);
      goto LABEL_28;
    }
  }
  else if ((v60 & 0x80) == 0)
  {
    goto LABEL_23;
  }
  operator delete(v63);
  if ((v61 & 0x80) == 0) {
    goto LABEL_28;
  }
  goto LABEL_27;
}

void sub_1007C9F48()
{
}

uint64_t sub_1007C9F50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (!v2) {
    return 0;
  }
  uint64_t v11 = 0;
  __int16 v12 = 0;
  uint64_t v13 = 0;
  (*(void (**)(uint64_t **__return_ptr))(*(void *)v2 + 16))(&v11);
  v4 = v11;
  v5 = v12;
  if (v11 == v12)
  {
    uint64_t v6 = 0;
  }
  else
  {
    LODWORD(v6) = 0;
    do
    {
      uint64_t v7 = *v4;
      v8 = (std::__shared_weak_count *)v4[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 80))(v7, a2);
      if (v9 <= (int)v6) {
        uint64_t v6 = v6;
      }
      else {
        uint64_t v6 = v9;
      }
      if (v8) {
        sub_10004D2C8(v8);
      }
      v4 += 2;
    }
    while (v4 != v5);
  }
  unint64_t v14 = (void **)&v11;
  sub_10005CBF0(&v14);
  return v6;
}

void sub_1007CA058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  a12 = (void **)&a9;
  sub_10005CBF0(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1007CA080(void *a1)
{
  int v2 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 240))(a1, 3);
  uint64_t v3 = a1[11];
  if (!v3) {
    return 0;
  }
  __int16 v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  (*(void (**)(uint64_t **__return_ptr))(*(void *)v3 + 16))(&v10);
  v4 = v10;
  v5 = v11;
  if (v10 == v11)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v8 = *v4;
      uint64_t v7 = (std::__shared_weak_count *)v4[1];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v2 == (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 80))(v8, 3)) {
        uint64_t v6 = (*(unsigned int (**)(uint64_t))(*(void *)v8 + 200))(v8) | v6;
      }
      if (v7) {
        sub_10004D2C8(v7);
      }
      v4 += 2;
    }
    while (v4 != v5);
  }
  uint64_t v13 = (void **)&v10;
  sub_10005CBF0(&v13);
  return v6;
}

void sub_1007CA1E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  a12 = (void **)&a9;
  sub_10005CBF0(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1007CA20C(void *a1, int a2, void *a3)
{
  *a3 = *((int *)a1 + 20);
  uint64_t v6 = 0;
  switch((*(unsigned int (**)(void *, uint64_t))(*a1 + 240))(a1, 3))
  {
    case 0u:
    case 1u:
    case 2u:
    case 4u:
      goto LABEL_6;
    case 3u:
      (*(void (**)(void))(*(void *)a1[11] + 144))(a1[11]);
      if (validContextType()) {
        goto LABEL_3;
      }
      uint64_t v6 = 0;
LABEL_6:
      a3[1] = 0;
      break;
    case 5u:
      uint64_t v6 = 1;
      goto LABEL_6;
    case 6u:
LABEL_3:
      uint64_t v6 = 0;
      a3[1] = 2;
      break;
    default:
      break;
  }
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = 1;
  a3[5] = sub_1007C5EAC((uint64_t)a1, a2);
  a3[7] = sub_1007CA080(a1);
  if (qword_101B14190
    && (uint64_t v7 = (capabilities::ct *)std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190)) != 0)
  {
    uint64_t v8 = (std::__shared_weak_count *)v7;
    uint64_t v9 = DataPlanManagerBootstrap::sInstance;
    if (DataPlanManagerBootstrap::sInstance)
    {
      if (capabilities::ct::supportsDataPlanNotifications(v7)) {
        LODWORD(v9) = (*(uint64_t (**)(void))(*(void *)(v9 + 8) + 88))();
      }
      else {
        LODWORD(v9) = 0;
      }
    }
    sub_10004D2C8(v8);
  }
  else
  {
    LODWORD(v9) = 0;
  }
  a3[8] = v9;
  a3[9] = v6;
  a3[10] = 0;
  a3[11] = subscriber::simSlotAsInstance();
  return 12;
}

void sub_1007CA3B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007CA3E0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = (uint64_t)a3;
  sub_1007CA20C((void *)a1, a2, a3);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v17);
  if (v12)
  {
    uint64_t v13 = v12[3];
    unint64_t v14 = (std::__shared_weak_count *)v12[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v15 = 0;
      if (!v13) {
        goto LABEL_7;
      }
LABEL_11:
      uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 936))(v13, a2, v3, 12);
      if (v15) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v7);
  unint64_t v14 = 0;
  char v15 = 1;
  if (v13) {
    goto LABEL_11;
  }
LABEL_7:
  if ((v15 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v14);
LABEL_13:
  if (v13) {
    return v3;
  }
  else {
    return 0;
  }
}

void sub_1007CA524(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007CA540(uint64_t a1, int a2)
{
  if (a2) {
    sub_1007CA7E4();
  }
  uint64_t v18 = 0;
  int v19 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 112))(&v18);
  if (v18)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 160))(v18, 1, 7);
    if (qword_101B14190)
    {
      v4 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v4)
      {
        v5 = v4;
        if (DataPlanManagerBootstrap::sInstance
          && (*(unsigned int (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 96))())
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18 + 160))(v18, 1, 5);
        }
        sub_10004D2C8(v5);
      }
    }
  }
  if (a2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
    uint64_t v7 = ServiceMap;
    if ((v8 & 0x8000000000000000) != 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        unint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v20 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v20);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        if (!v14)
        {
LABEL_22:
          if ((v15 & 1) == 0) {
            sub_10004D2C8(v13);
          }
          goto LABEL_24;
        }
LABEL_20:
        sub_100058DB0(__p, "Throttling cleared");
        (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v14 + 1096))(v14, 3, __p, 0);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }
LABEL_24:
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_1007CA78C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16)
{
  sub_10004D2C8(v16);
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007CA7E4()
{
  uint64_t result = sub_10017B48C();
  if (result) {
    operator new();
  }
  return result;
}

void sub_1007CA94C(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10006A6AC(a1);
}

void sub_1007CA9C0(uint64_t a1, int a2)
{
  uint64_t v3 = 0;
  v4 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 88) + 112))(&v3);
  if (v3) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v3 + 160))(v3, 0, 7);
  }
  if (a2) {
    sub_1007CA7E4();
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_1007CAA6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007CAA84(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1007CAABC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2)
  {
    uint64_t v28 = 0;
    unsigned int v29 = 0;
    uint64_t v30 = 0;
    (*(void (**)(uint64_t **__return_ptr))(*(void *)v2 + 16))(&v28);
    uint64_t v3 = v28;
    v4 = v29;
    if (v28 != v29)
    {
      while (1)
      {
        uint64_t v6 = *v3;
        v5 = (std::__shared_weak_count *)v3[1];
        if (v5) {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        memset(&v33, 0, sizeof(v33));
        uint64_t v7 = *(void *)(a1 + 88);
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 56))(v6);
        (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v7 + 40))(&v33, v7, v8);
        uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 192))(v6, 0);
        int v10 = 0;
        unint64_t v11 = 1;
        do
        {
          int v12 = v10 | 0x10000000;
          if (v11 <= 0x10000000) {
            int v12 = v10 | v11;
          }
          if ((v11 & v9) != 0) {
            int v10 = v12;
          }
          unint64_t v13 = v11 >> 35;
          v11 *= 2;
        }
        while (!v13);
        int v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1);
        int v15 = v14;
        if (v14 != *(_DWORD *)(a1 + 48))
        {
          *(_DWORD *)(a1 + 48) = v14;
          int v16 = *(_DWORD *)(a1 + 80);
          if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__p, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = v33;
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__str, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else {
            std::string __str = __p;
          }
          __dst.__r_.__value_.__r.__words[0] = 0;
          __dst.__r_.__value_.__l.__size_ = 524435;
          if (sub_10017B48C()) {
            operator new();
          }
          std::string::size_type v17 = __dst.__r_.__value_.__r.__words[0];
          if (__dst.__r_.__value_.__r.__words[0])
          {
            int v18 = *(_DWORD *)(__dst.__r_.__value_.__r.__words[0] + 40);
            *(_DWORD *)(__dst.__r_.__value_.__r.__words[0] + 16) = v16;
            *(_DWORD *)(v17 + 20) = v15;
            *(_DWORD *)(v17 + 40) = v18 | 0xE;
            int v19 = *(std::string **)(v17 + 24);
            if (v19 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
              operator new();
            }
            std::string::operator=(v19, &__str);
            std::string::size_type v20 = __dst.__r_.__value_.__r.__words[0];
            *(_DWORD *)(__dst.__r_.__value_.__r.__words[0] + 40) |= 0x10u;
            *(_DWORD *)(v20 + 32) = v10;
          }
          sub_1007CC330((uint64_t *)&__dst);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        int v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 2);
        int v22 = v21;
        if (v21 != *(_DWORD *)(a1 + 52))
        {
          *(_DWORD *)(a1 + 52) = v21;
          int v23 = *(_DWORD *)(a1 + 80);
          if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = v33;
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string __str = __dst;
          }
          v35[0] = 0;
          v35[1] = 524436;
          if (sub_10017B48C()) {
            operator new();
          }
          uint64_t v24 = v35[0];
          if (v35[0])
          {
            int v25 = *(_DWORD *)(v35[0] + 40);
            *(_DWORD *)(v35[0] + 16) = v23;
            *(_DWORD *)(v24 + 20) = v22;
            *(_DWORD *)(v24 + 40) = v25 | 0xE;
            uint64_t v26 = *(std::string **)(v24 + 24);
            if (v26 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
              operator new();
            }
            std::string::operator=(v26, &__str);
            uint64_t v27 = v35[0];
            *(_DWORD *)(v35[0] + 40) |= 0x10u;
            *(_DWORD *)(v27 + 32) = v10;
          }
          sub_1007CC4E0(v35);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
        }
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
          break;
        }
        if (v5) {
          goto LABEL_47;
        }
LABEL_48:
        v3 += 2;
        if (v3 == v4) {
          goto LABEL_52;
        }
      }
      operator delete(v33.__r_.__value_.__l.__data_);
      if (!v5) {
        goto LABEL_48;
      }
LABEL_47:
      sub_10004D2C8(v5);
      goto LABEL_48;
    }
LABEL_52:
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v28;
    sub_10005CBF0((void ***)&__str);
  }
}

void sub_1007CAF8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (v37) {
    sub_10004D2C8(v37);
  }
  *(void *)(v38 - 96) = &a10;
  sub_10005CBF0((void ***)(v38 - 96));
  _Unwind_Resume(a1);
}

void sub_1007CB0EC()
{
}

void sub_1007CB4DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  if ((a17 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007CB550(uint64_t a1, uint64_t a2, unsigned int a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 64));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v25 = v8;
  int v12 = sub_10004D37C(&v7[1].__m_.__sig, &v25);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      if (!v14)
      {
LABEL_26:
        sub_10004D2C8(v13);
        return a2;
      }
    }
    else
    {
      std::mutex::unlock(v7);
      if (!v14) {
        return a2;
      }
    }
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 776))(v14);
    unsigned int v24 = a3;
    unint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    (*(void (**)(unint64_t *__return_ptr))(**(void **)(a1 + 88) + 16))(&v25);
    unint64_t v16 = v25;
    uint64_t v17 = v26;
    if (v25 != v26)
    {
      while (1)
      {
        int v18 = *(char **)v16;
        int v19 = *(std::__shared_weak_count **)(v16 + 8);
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v18
          && (*(unsigned int (**)(char *))(*(void *)&v18[*(void *)(*(void *)v18 - 56)] + 24))(&v18[*(void *)(*(void *)v18 - 56)]) != v15)
        {
          break;
        }
        char v20 = 1;
        if (v19) {
          goto LABEL_16;
        }
LABEL_17:
        if ((v20 & 1) == 0) {
          goto LABEL_25;
        }
        v16 += 16;
        if (v16 == v17) {
          goto LABEL_22;
        }
      }
      char v20 = 0;
      if (!v19) {
        goto LABEL_17;
      }
LABEL_16:
      sub_10004D2C8(v19);
      goto LABEL_17;
    }
LABEL_22:
    unint64_t v21 = sub_1007C5EAC(a1, v15);
    if (isSliceMask(v21))
    {
      uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 872))(v14);
      if (v22) {
        a2 = 1000 * (*(unsigned int (**)(uint64_t, uint64_t, void))(*(void *)v22 + 144))(v22, v15, v24);
      }
    }
LABEL_25:
    uint64_t v28 = (void **)&v25;
    sub_10005CBF0(&v28);
    if (v13) {
      goto LABEL_26;
    }
  }
  else
  {
    std::mutex::unlock(v7);
  }
  return a2;
}

void sub_1007CB7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_10005CBF0(&a14);
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

void sub_1007CB830(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 96);
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: -------------- Collocation: %s ------------------", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 112);
    uint64_t v4 = *(void *)(a1 + 120);
    *(_DWORD *)std::string buf = 134218240;
    *(void *)&buf[4] = v4;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fInactivityTimeoutMsec = %lu, fInactivityCheckpointMsec = %lu", buf, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = sub_1007CB550(a1, *(void *)(a1 + 120), 0);
    uint64_t v7 = sub_1007CB550(a1, *(void *)(a1 + 112), 1u);
    *(_DWORD *)std::string buf = 134218240;
    *(void *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t efficient: inactivityTimeoutMsec = %lu, inactivityCheckpointMsec = %lu", buf, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(_DWORD *)(a1 + 128);
    int v9 = *(_DWORD *)(a1 + 132);
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&buf[4] = v8;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fStatistics(_in=%u, _out=%u)", buf, 0xEu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = asStringBool(*(unsigned char *)(a1 + 144));
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 145));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&buf[4] = v10;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fAsserted = %s,  fAssertionGone = %s", buf, 0x16u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asStringBool(*(void *)(a1 + 104) != 0);
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fInactivityTimer = %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fCachedV4Status = %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fCachedV6Status = %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIPv4NetworkMtu = %u", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fIPv6NetworkMtu = %u", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fAssertions {", buf, 2u);
  }
  uint64_t v17 = *(long long **)(a1 + 152);
  for (i = *(long long **)(a1 + 160); v17 != i; uint64_t v17 = (long long *)((char *)v17 + 24))
  {
    memset(buf, 0, 24);
    if (*((char *)v17 + 23) < 0)
    {
      sub_10004FC84(buf, *(void **)v17, *((void *)v17 + 1));
    }
    else
    {
      long long v19 = *v17;
      *(void *)&buf[16] = *((void *)v17 + 2);
      *(_OWORD *)std::string buf = v19;
    }
    char v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      if ((buf[23] & 0x80u) == 0) {
        unint64_t v21 = buf;
      }
      else {
        unint64_t v21 = *(uint8_t **)buf;
      }
      *(_DWORD *)uint64_t v32 = 136315138;
      *(void *)&v32[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t %s", v32, 0xCu);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t }", buf, 2u);
    uint64_t v22 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fDataContexts {", buf, 2u);
  }
  uint64_t v23 = *(void *)(a1 + 88);
  if (v23)
  {
    memset(buf, 0, 24);
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v23 + 16))(buf);
    unsigned int v24 = *(uint64_t **)buf;
    for (j = *(uint64_t **)&buf[8]; v24 != j; v24 += 2)
    {
      uint64_t v27 = *v24;
      uint64_t v26 = (std::__shared_weak_count *)v24[1];
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v28 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 48))(v27);
        *(_DWORD *)uint64_t v32 = 136315138;
        *(void *)&v32[4] = v29;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t %s", v32, 0xCu);
      }
      if (v26) {
        sub_10004D2C8(v26);
      }
    }
    *(void *)uint64_t v32 = buf;
    sub_10005CBF0((void ***)v32);
  }
  uint64_t v30 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t }", buf, 2u);
  }
  *(void *)std::string buf = 0;
  *(void *)&buf[8] = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 88) + 112))(buf);
  if (*(void *)buf) {
    (*(void (**)(void))(**(void **)buf + 192))(*(void *)buf);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_1007CBF2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007CBF70(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007CBFE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_1002904FC((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007CC004(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007CC03C(uint64_t a1)
{
}

uint64_t sub_1007CC044(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1007CC088(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    sub_100157704(a1, a4);
    sub_1007CC0F8((uint64_t)a1, a2, a3);
  }
}

void sub_1007CC0DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007CC0F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)(v4 + v7), (const CSIPacketAddress *)(a2 + v7));
      v7 += 24;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(void *)(a1 + 8) = v4;
}

void sub_1007CC164(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *sub_1007CC16C(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t *sub_1007CC180(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  uint64_t v5 = (wis::WISServerConnection *)*v3;
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    uint64_t v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    int v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 84))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 84) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_1007CC2E0(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

uint64_t *sub_1007CC330(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  uint64_t v5 = (wis::WISServerConnection *)*v3;
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    uint64_t v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    int v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 40))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 40) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_1007CC490(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

uint64_t *sub_1007CC4E0(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  uint64_t v5 = (wis::WISServerConnection *)*v3;
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    uint64_t v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    int v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 40))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 40) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_1007CC640(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void sub_1007CC690(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1007CC9B0()
{
}

void sub_1007CC9E0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1007CCA64(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  std::mutex::lock((std::mutex *)(v1 + 72));
  (*(void (**)(uint64_t))(*(void *)v1 + 48))(v1);
  sub_1007D17B4(v1);

  std::mutex::unlock((std::mutex *)(v1 + 72));
}

void sub_1007CCAD4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1007CCAE8(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  std::mutex::lock((std::mutex *)(v3 + 72));
  long long v37 = 0u;
  long long v38 = 0u;
  sub_1007CE588(a2, (unsigned __int8 *)&v37);
  if (!(_BYTE)v37)
  {
    uint64_t v13 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N Couldn't find sensors TLV", (uint8_t *)&buf, 2u);
    }
    goto LABEL_37;
  }
  long long buf = 0u;
  long long v36 = 0u;
  sub_1007CE63C(a2, (unsigned __int8 *)&buf);
  if (!(_BYTE)buf)
  {
    uint64_t v14 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string v33 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Couldn't find filtered values TLV", v33, 2u);
    }
    goto LABEL_21;
  }
  *(_OWORD *)std::string v33 = 0u;
  long long v34 = 0u;
  sub_1007CE6F0(a2, v33);
  if (!v33[0])
  {
    uint64_t v17 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v27 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Couldn't find raw value TLV", v27, 2u);
    }
    if (*((void *)&buf + 1)) {
      operator delete(*((void **)&buf + 1));
    }
LABEL_21:
    if (*((void *)&v37 + 1)) {
      operator delete(*((void **)&v37 + 1));
    }
    goto LABEL_37;
  }
  unsigned int v24 = 0;
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v4 = (void *)*((void *)&v37 + 1);
  sub_1007CE7A4(&v24, *((const void **)&v37 + 1), v38, (uint64_t)(v38 - *((void *)&v37 + 1)) >> 2);
  unint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v5 = (void *)*((void *)&buf + 1);
  sub_1007CE7A4(&v21, *((const void **)&buf + 1), v36, (uint64_t)(v36 - *((void *)&buf + 1)) >> 2);
  int v18 = 0;
  long long v19 = 0;
  uint64_t v20 = 0;
  uint64_t v6 = *(void **)&v33[8];
  sub_1007CE7A4(&v18, *(const void **)&v33[8], v34, (uint64_t)(v34 - *(void *)&v33[8]) >> 2);
  uint64_t v7 = (v25 - (unsigned char *)v24) >> 2;
  uint64_t v8 = v22 - (unsigned char *)v21;
  if (v7 == (v22 - (unsigned char *)v21) >> 2 && v7 == (v19 - (unsigned char *)v18) >> 2)
  {
    while (v24 != v25)
    {
      uint64_t v9 = *((int *)v25 - 1);
      v25 -= 4;
      unsigned int v10 = *((_DWORD *)v22 - 1);
      v22 -= 4;
      uint64_t v11 = *((unsigned int *)v19 - 1);
      v19 -= 4;
      if (v9 >= 4)
      {
        __TUAssertTrigger();
        signed int v12 = 0;
      }
      else
      {
        signed int v12 = dword_1014F3020[v9];
      }
      sub_1007D149C(v3, v12, v10, v11);
    }
    char v16 = 1;
  }
  else
  {
    int v15 = *(NSObject **)(v3 + 48);
    char v16 = 0;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v27 = 134218496;
      uint64_t v28 = v7;
      __int16 v29 = 2048;
      uint64_t v30 = v8 >> 2;
      __int16 v31 = 2048;
      uint64_t v32 = (v19 - (unsigned char *)v18) >> 2;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N TLV sizes do not match for sensor %lu, filtered %lu, raw %lu", v27, 0x20u);
      char v16 = 0;
    }
  }
  if (v18)
  {
    long long v19 = v18;
    operator delete(v18);
  }
  if (v21)
  {
    uint64_t v22 = v21;
    operator delete(v21);
  }
  if (v24)
  {
    unint64_t v25 = v24;
    operator delete(v24);
  }
  if (v6) {
    operator delete(v6);
  }
  if (v5) {
    operator delete(v5);
  }
  if (v4) {
    operator delete(v4);
  }
  if ((v16 & 1) == 0) {
LABEL_37:
  }
    (*(void (**)(void, const char *, uint64_t))(**(void **)(v3 + 136) + 16))(*(void *)(v3 + 136), "Processing Temperature Report Failed", 1);

  std::mutex::unlock((std::mutex *)(v3 + 72));
}

void sub_1007CCEB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,void *a24,uint64_t a25,uint64_t a26,char a27,void *a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a28) {
    operator delete(a28);
  }
  __int16 v31 = *(void **)(v29 - 120);
  if (v31) {
    operator delete(v31);
  }
  std::mutex::unlock(v28);
  _Unwind_Resume(a1);
}

void sub_1007CCF68(void *a1)
{
  *a1 = off_101A09E70;
  a1[1] = off_101A09EC0;
  uint64_t v2 = (qmi::Client *)(a1 + 30);
  qmi::Client::stop((qmi::Client *)(a1 + 30));
  qmi::Client::release(v2);
  qmi::Client::~Client(v2);

  sub_1007D13D4((uint64_t)a1);
}

void sub_1007CCFFC(uint64_t a1)
{
}

void sub_1007CD004(void *a1)
{
  sub_1007CCF68(a1);

  operator delete();
}

void sub_1007CD03C(uint64_t a1)
{
  sub_1007CCF68((void *)(a1 - 8));

  operator delete();
}

uint64_t sub_1007CD078(uint64_t a1)
{
  uint64_t v1 = (std::mutex *)(a1 + 72);
  std::mutex::lock((std::mutex *)(a1 + 72));
  uint64_t v3 = capabilities::ct::supportsThermalMonitor(v2);
  std::mutex::unlock(v1);
  return v3;
}

void sub_1007CD0B4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1007CD0C8(capabilities::ct *a1)
{
  if (capabilities::ct::supportsThermalMonitor(a1) && *((void *)a1 + 32))
  {
    *(_OWORD *)std::string __p = 0u;
    long long v13 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x7701u);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_1007CD41C;
    v11[3] = &unk_101A09F18;
    v11[4] = a1;
    uint64_t v2 = (const void **)__p[1];
    if (__p[1] != (void *)v13)
    {
      while (*((unsigned char *)*v2 + 8) != 20)
      {
        if (++v2 == (const void **)v13) {
          goto LABEL_10;
        }
      }
    }
    if (v2 == (const void **)v13) {
LABEL_10:
    }
      operator new();
    if (!v3) {
      __cxa_bad_cast();
    }
    sub_1007CD41C((uint64_t)v11, v3 + 3);
    v6[5] = (char *)a1 + 240;
    uint64_t v7 = QMIServiceMsg::create((QMIServiceMsg *)__p, v4);
    int v8 = 25000;
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_1007CD434;
    v6[3] = &unk_101A09F38;
    v6[4] = a1;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1007CE2A0;
    aBlock[3] = &unk_101A0A090;
    aBlock[4] = v6;
    uint64_t v5 = _Block_copy(aBlock);
    unsigned int v10 = v5;
    if (v7)
    {
      qmi::Client::send();
      uint64_t v5 = v10;
    }
    if (v5) {
      _Block_release(v5);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_1007CD3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  sub_10075CFC0((uint64_t)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007CD41C(uint64_t result, _DWORD *a2)
{
  *a2 = 1000 * *(_DWORD *)(*(void *)(result + 32) + 168);
  return result;
}

void sub_1007CD434(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4))
  {
    uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Setting reporting period failed", v3, 2u);
    }
  }
}

void sub_1007CD4A0(capabilities::ct *a1, int a2)
{
  if (capabilities::ct::supportsThermalMonitor(a1) && *((void *)a1 + 32))
  {
    *(_OWORD *)std::string __p = 0u;
    long long v16 = 0u;
    qmi::MutableMessageBase::MutableMessageBase((qmi::MutableMessageBase *)__p, 0x7702u);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_1007CD7F8;
    v13[3] = &unk_101A09F58;
    int v14 = a2;
    uint64_t v4 = (const void **)__p[1];
    if (__p[1] != (void *)v16)
    {
      while (*((unsigned char *)*v4 + 8) != 17)
      {
        if (++v4 == (const void **)v16) {
          goto LABEL_10;
        }
      }
    }
    if (v4 == (const void **)v16) {
LABEL_10:
    }
      operator new();
    if (!v5) {
      __cxa_bad_cast();
    }
    sub_1007CD7F8((uint64_t)v13, v5 + 3);
    v8[5] = (char *)a1 + 240;
    uint64_t v9 = QMIServiceMsg::create((QMIServiceMsg *)__p, v6);
    int v10 = 25000;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_1007CD854;
    v8[3] = &unk_101A09F78;
    v8[4] = a1;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1007CE484;
    aBlock[3] = &unk_101A0A108;
    aBlock[4] = v8;
    uint64_t v7 = _Block_copy(aBlock);
    uint64_t v12 = v7;
    if (v9)
    {
      qmi::Client::send();
      uint64_t v7 = v12;
    }
    if (v7) {
      _Block_release(v7);
    }
    qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)__p);
  }
}

void sub_1007CD7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  sub_10075CFC0((uint64_t)va);
  qmi::MutableMessageBase::~MutableMessageBase((qmi::MutableMessageBase *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007CD7F8(uint64_t result, int *a2)
{
  uint64_t v3 = *(int *)(result + 32);
  if v3 < 7 && ((0x47u >> v3))
  {
    int v4 = dword_1014F2FF8[v3];
  }
  else
  {
    uint64_t result = __TUAssertTrigger();
    int v4 = 2;
  }
  *a2 = v4;
  return result;
}

void sub_1007CD854(uint64_t a1, qmi::MessageBase *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = (std::mutex *)(v3 + 72);
  std::mutex::lock((std::mutex *)(v3 + 72));
  if (*((_DWORD *)a2 + 1))
  {
    uint64_t v5 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = qmi::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Querying sensors failed, code = %s", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_41;
  }
  long long buf = 0u;
  long long v40 = 0u;
  sub_1007CE588(a2, (unsigned __int8 *)&buf);
  if (!(_BYTE)buf)
  {
    uint64_t v15 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v37) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N Couldn't find sensors TLV", (uint8_t *)&v37, 2u);
    }
    goto LABEL_40;
  }
  long long v37 = 0u;
  long long v38 = 0u;
  sub_1007CE63C(a2, (unsigned __int8 *)&v37);
  if (!(_BYTE)v37)
  {
    uint64_t v16 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v35 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Couldn't find filtered values TLV", v35, 2u);
    }
    goto LABEL_24;
  }
  *(_OWORD *)uint64_t v35 = 0u;
  long long v36 = 0u;
  sub_1007CE6F0(a2, v35);
  if (!v35[0])
  {
    long long v19 = *(NSObject **)(v3 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v29 = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Couldn't find raw value TLV", v29, 2u);
    }
    if (*((void *)&v37 + 1)) {
      operator delete(*((void **)&v37 + 1));
    }
LABEL_24:
    if (*((void *)&buf + 1)) {
      operator delete(*((void **)&buf + 1));
    }
    goto LABEL_40;
  }
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v6 = (void *)*((void *)&buf + 1);
  sub_1007CE7A4(&v26, *((const void **)&buf + 1), v40, (uint64_t)(v40 - *((void *)&buf + 1)) >> 2);
  uint64_t v23 = 0;
  unsigned int v24 = 0;
  uint64_t v25 = 0;
  uint64_t v7 = (void *)*((void *)&v37 + 1);
  sub_1007CE7A4(&v23, *((const void **)&v37 + 1), v38, (uint64_t)(v38 - *((void *)&v37 + 1)) >> 2);
  uint64_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v8 = *(void **)&v35[8];
  sub_1007CE7A4(&v20, *(const void **)&v35[8], v36, (uint64_t)(v36 - *(void *)&v35[8]) >> 2);
  uint64_t v9 = (v27 - (unsigned char *)v26) >> 2;
  uint64_t v10 = v24 - (unsigned char *)v23;
  if (v9 == (v24 - (unsigned char *)v23) >> 2 && v9 == (v21 - (unsigned char *)v20) >> 2)
  {
    while (v26 != v27)
    {
      uint64_t v11 = *((int *)v27 - 1);
      v27 -= 4;
      unsigned int v12 = *((_DWORD *)v24 - 1);
      v24 -= 4;
      uint64_t v13 = *((unsigned int *)v21 - 1);
      v21 -= 4;
      if (v11 >= 4)
      {
        __TUAssertTrigger();
        signed int v14 = 0;
      }
      else
      {
        signed int v14 = dword_1014F3020[v11];
      }
      sub_1007D149C(v3, v14, v12, v13);
    }
    char v18 = 1;
  }
  else
  {
    uint64_t v17 = *(NSObject **)(v3 + 48);
    char v18 = 0;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v29 = 134218496;
      uint64_t v30 = v9;
      __int16 v31 = 2048;
      uint64_t v32 = v10 >> 2;
      __int16 v33 = 2048;
      uint64_t v34 = (v21 - (unsigned char *)v20) >> 2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N TLV sizes do not match for sensor %lu, filtered %lu, raw %lu", v29, 0x20u);
      char v18 = 0;
    }
  }
  if (v20)
  {
    unint64_t v21 = v20;
    operator delete(v20);
  }
  if (v23)
  {
    unsigned int v24 = v23;
    operator delete(v23);
  }
  if (v26)
  {
    uint64_t v27 = v26;
    operator delete(v26);
  }
  if (v8) {
    operator delete(v8);
  }
  if (v7) {
    operator delete(v7);
  }
  if (v6) {
    operator delete(v6);
  }
  if ((v18 & 1) == 0) {
LABEL_40:
  }
    (*(void (**)(void, const char *, uint64_t))(**(void **)(v3 + 136) + 16))(*(void *)(v3 + 136), "Processing Temperature Report Failed", 1);
LABEL_41:
  std::mutex::unlock(v4);
}

void sub_1007CDC6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,void *a24,uint64_t a25,uint64_t a26,char a27,void *a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a28) {
    operator delete(a28);
  }
  __int16 v31 = *(void **)(v29 - 120);
  if (v31) {
    operator delete(v31);
  }
  std::mutex::unlock(v28);
  _Unwind_Resume(a1);
}

void sub_1007CDD2C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007CDD64(uint64_t a1)
{
}

uint64_t sub_1007CDD80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007CDDC4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_1007CDDF0(capabilities::ct *a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v11 = a1;
  unsigned int v12 = v1;
  uint64_t v2 = *v1;
  if (capabilities::ct::supportsThermalMonitor(a1))
  {
    sub_100058DB0(v17, "EURBatteryMeasurementModel:BSP");
    uint64_t v3 = *(NSObject **)(v2 + 32);
    dispatch_object_t v25 = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    sub_100058DB0(__p, "logchan");
    int v4 = *(std::__shared_weak_count **)(v2 + 24);
    if (!v4 || (v5 = *(void *)(v2 + 16), (uint64_t v6 = std::__shared_weak_count::lock(v4)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v7 = v6;
    uint64_t v23 = v5;
    unsigned int v24 = v6;
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    Registry::getServerConnection(&v21, *(Registry **)(v2 + 56));
    qmi::Client::createWithQueueLocal();
    long long v8 = v27;
    long long v27 = 0uLL;
    uint64_t v9 = *(std::__shared_weak_count **)(v2 + 264);
    *(_OWORD *)(v2 + 256) = v8;
    if (v9) {
      sub_10004D2C8(v9);
    }
    qmi::Client::~Client((qmi::Client *)v26);
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v24) {
      std::__shared_weak_count::__release_weak(v24);
    }
    sub_10004D2C8(v7);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    if (v25) {
      dispatch_release(v25);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
    v17[0] = _NSConcreteStackBlock;
    v17[1] = (void *)0x40000000;
    char v18 = sub_1007CCA64;
    long long v19 = &unk_101A09ED8;
    uint64_t v20 = v2;
    qmi::Client::setHandler();
    __p[0] = _NSConcreteStackBlock;
    __p[1] = (void *)0x40000000;
    signed int v14 = sub_1007CCAE8;
    uint64_t v15 = &unk_101A09EF8;
    uint64_t v16 = v2;
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000;
    *(void *)&long long v27 = sub_1007CE0BC;
    *((void *)&v27 + 1) = &unk_101A0A018;
    uint64_t v28 = __p;
    qmi::Client::setIndHandler();
    qmi::Client::start((qmi::Client *)(v2 + 240));
  }
  sub_1000E3958((uint64_t *)&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_1007CE034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a28) {
    sub_10004D2C8(a28);
  }
  if (a30) {
    std::__shared_weak_count::__release_weak(a30);
  }
  sub_10004D2C8(v30);
  if (a16 < 0) {
    operator delete(__p);
  }
  __int16 v33 = *(NSObject **)(v31 - 96);
  if (v33) {
    dispatch_release(v33);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  sub_1000E3958(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1007CE0BC(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::MessageBase::MessageBase((qmi::MessageBase *)v4, __p, v6 - (unsigned char *)__p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x9902u);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x9902u);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_1007CE180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void sub_1007CE1C4()
{
}

uint64_t sub_1007CE1D8()
{
  return sub_10006E100();
}

_DWORD **sub_1007CE1E0(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006E108((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_1007CE23C()
{
}

void sub_1007CE2A0(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p, v6 - (unsigned char *)__p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x7701u);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x7701u);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_1007CE364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void sub_1007CE3A8()
{
}

uint64_t sub_1007CE3BC()
{
  return sub_10006E100();
}

_DWORD **sub_1007CE3C4(uint64_t a1, uint64_t *a2)
{
  char v3 = *(unsigned char *)(a1 + 8);
  int v4 = (_DWORD *)*a2;
  uint64_t v5 = *a2 + 3;
  *a2 = v5;
  uint64_t result = sub_10006E108((_DWORD **)a2, (_DWORD *)(a1 + 12));
  uint64_t v7 = (char *)(*a2 - v5);
  *(unsigned char *)int v4 = v3;
  *(_WORD *)((char *)v4 + 1) = (_WORD)v7;
  return result;
}

void sub_1007CE420()
{
}

void sub_1007CE484(uint64_t a1, QMIServiceMsg *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*((_DWORD *)this + 10) != 1 || *((_WORD *)this + 22) == 3)
  {
    std::string __p = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    QMIServiceMsg::serialize((uint64_t *)&__p, this);
    qmi::ResponseBase::ResponseBase((qmi::ResponseBase *)v4, __p, v6 - (unsigned char *)__p);
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x7702u);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }
  }
  else
  {
    QMIServiceMsg::getNewError(this);
    qmi::MessageBase::MessageBase();
    qmi::MessageBase::validateMsgId((qmi::MessageBase *)v4, 0x7702u);
  }
  (*(void (**)(uint64_t, unsigned char *))(v2 + 16))(v2, v4);
  qmi::MessageBase::~MessageBase((qmi::MessageBase *)v4);
}

void sub_1007CE548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

void sub_1007CE588(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  v9[0] = qmi::MessageBase::findTlvValue(a1);
  v9[1] = v3;
  if (v9[0])
  {
    sub_10006EAE4(v9, v3, (uint64_t)&v7);
    if (*a2)
    {
      int v4 = (void *)*((void *)a2 + 1);
      if (v4)
      {
        *((void *)a2 + 2) = v4;
        operator delete(v4);
        int v5 = *a2;
      }
      else
      {
        int v5 = 1;
      }
      uint64_t v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((void *)a2 + 3) = v8;
    }
    else
    {
      uint64_t v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((void *)a2 + 3) = v8;
      int v5 = 1;
      *a2 = 1;
    }
    if (!v9[0] && v5)
    {
      if (v6)
      {
        *((void *)a2 + 2) = v6;
        operator delete(v6);
      }
      *a2 = 0;
    }
  }
}

void sub_1007CE63C(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  v9[0] = qmi::MessageBase::findTlvValue(a1);
  v9[1] = v3;
  if (v9[0])
  {
    sub_10006EB8C(v9, v3, (uint64_t)&v7);
    if (*a2)
    {
      int v4 = (void *)*((void *)a2 + 1);
      if (v4)
      {
        *((void *)a2 + 2) = v4;
        operator delete(v4);
        int v5 = *a2;
      }
      else
      {
        int v5 = 1;
      }
      uint64_t v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((void *)a2 + 3) = v8;
    }
    else
    {
      uint64_t v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((void *)a2 + 3) = v8;
      int v5 = 1;
      *a2 = 1;
    }
    if (!v9[0] && v5)
    {
      if (v6)
      {
        *((void *)a2 + 2) = v6;
        operator delete(v6);
      }
      *a2 = 0;
    }
  }
}

void sub_1007CE6F0(qmi::MessageBase *a1, unsigned __int8 *a2)
{
  v9[0] = qmi::MessageBase::findTlvValue(a1);
  v9[1] = v3;
  if (v9[0])
  {
    sub_10006EC34(v9, v3, (uint64_t)&v7);
    if (*a2)
    {
      int v4 = (void *)*((void *)a2 + 1);
      if (v4)
      {
        *((void *)a2 + 2) = v4;
        operator delete(v4);
        int v5 = *a2;
      }
      else
      {
        int v5 = 1;
      }
      uint64_t v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((void *)a2 + 3) = v8;
    }
    else
    {
      uint64_t v6 = (void *)v7;
      *(_OWORD *)(a2 + 8) = v7;
      *((void *)a2 + 3) = v8;
      int v5 = 1;
      *a2 = 1;
    }
    if (!v9[0] && v5)
    {
      if (v6)
      {
        *((void *)a2 + 2) = v6;
        operator delete(v6);
      }
      *a2 = 0;
    }
  }
}

void *sub_1007CE7A4(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_10005CCE8(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1007CE804(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007CE820(void ***a1)
{
  *a1 = (void **)off_101A0A138;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1007CE878(void ***a1)
{
  *a1 = (void **)off_101A0A138;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

uint64_t sub_1007CE8E4(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  int v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  char v6 = *(unsigned char *)(a1 + 24);
  if (v6)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 16));
    char v6 = *(unsigned char *)(a1 + 24);
  }
  if ((v6 & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 20));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1007CE978(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        *(unsigned char *)(a1 + 24) |= 1u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 > 0xFFFFFFFFFFFFFFF5 || v23 + 10 > v24)
        {
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v28 = 0;
          if (v24 <= v23) {
            unint64_t v24 = *((void *)this + 1);
          }
          while (1)
          {
            if (v24 == v23)
            {
              LODWORD(v28) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_52;
            }
            unint64_t v37 = v23 + 1;
            char v38 = *(unsigned char *)(v25 + v23);
            *((void *)this + 1) = v37;
            v28 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0) {
              break;
            }
            v35 += 7;
            unint64_t v23 = v37;
            BOOL v14 = v36++ > 8;
            if (v14)
            {
LABEL_46:
              LODWORD(v28) = 0;
              goto LABEL_52;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v28) = 0;
          }
        }
        else
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          while (1)
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
            if (v14) {
              goto LABEL_46;
            }
          }
        }
LABEL_52:
        *(_DWORD *)(a1 + 16) = v28;
      }
      else if (v20 == 2)
      {
        *(unsigned char *)(a1 + 24) |= 2u;
        unint64_t v31 = *((void *)this + 1);
        if (v31 >= *((void *)this + 2))
        {
          BOOL v34 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v32 = v31 + 1;
          int v33 = *(unsigned __int8 *)(*(void *)this + v31);
          *((void *)this + 1) = v32;
          BOOL v34 = v33 != 0;
        }
        *(unsigned char *)(a1 + 20) = v34;
      }
      else
      {
        if (v20 == 1) {
          operator new();
        }
LABEL_25:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_25;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_1007CEC58(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  char v5 = *(unsigned char *)(v3 + 24);
  if ((v5 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 20), 2u);
    char v5 = *(unsigned char *)(v3 + 24);
  }
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(v3 + 16);
    return PB::Writer::writeVarInt(this, v6, 3u);
  }
  return result;
}

uint64_t sub_1007CECD8(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  for (uint64_t i = 48; i != 16; i -= 16)
  {
    int v4 = *(std::__shared_weak_count **)(a1 + i);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  sub_100103DF0(a1, *(void **)(a1 + 8));
  return a1;
}

uint64_t sub_1007CED30(uint64_t a1)
{
  *(void *)a1 = off_101A0A1D0;
  uint64_t v3 = (void **)(a1 + 8);
  sub_1007CEED0(&v3);
  return a1;
}

void sub_1007CED88(uint64_t a1)
{
  *(void *)a1 = off_101A0A1D0;
  uint64_t v1 = (void **)(a1 + 8);
  sub_1007CEED0(&v1);

  operator delete();
}

uint64_t sub_1007CEE00(uint64_t a1)
{
  *(void *)a1 = off_101A0A1D0;
  uint64_t v3 = (void **)(a1 + 8);
  sub_1007CEED0(&v3);
  return a1;
}

void sub_1007CEE58(uint64_t a1)
{
  *(void *)a1 = off_101A0A1D0;
  uint64_t v1 = (void **)(a1 + 8);
  sub_1007CEED0(&v1);

  operator delete();
}

void sub_1007CEED0(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    char v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1007CECD8(v4 - 72);
      while ((void *)v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1007CEF54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_1007CF060;
  v3[3] = &unk_101A0A1E0;
  v3[4] = v1;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_10003E168(&v6, (void *)(v1 + 8));
  unint64_t v2 = *(NSObject **)(v1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1007CFF1C;
  block[3] = &unk_101A0A248;
  block[5] = v6;
  char v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1007CF060(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = v1[130];
  uint64_t v3 = (std::__shared_weak_count *)v1[131];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = v1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v2 + 56);
    if (*(unsigned char *)(v2 + 64)) {
      uint64_t v6 = "true";
    }
    else {
      uint64_t v6 = "false";
    }
    *(_DWORD *)char v18 = 136315394;
    *(void *)&v18[4] = v5;
    *(_WORD *)&v18[12] = 2080;
    *(void *)&v18[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s", v18, 0x16u);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v7 = v1[126];
  uint64_t v8 = (std::__shared_weak_count *)v1[127];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v9 = v1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(void *)(v7 + 56);
    if (*(unsigned char *)(v7 + 64)) {
      unint64_t v11 = "true";
    }
    else {
      unint64_t v11 = "false";
    }
    *(_DWORD *)char v18 = 136315394;
    *(void *)&v18[4] = v10;
    *(_WORD *)&v18[12] = 2080;
    *(void *)&v18[14] = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s", v18, 0x16u);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v12 = v1[128];
  char v13 = (std::__shared_weak_count *)v1[129];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v14 = v1[5];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(v12 + 56);
    if (*(unsigned char *)(v12 + 64)) {
      unsigned int v16 = "true";
    }
    else {
      unsigned int v16 = "false";
    }
    *(_DWORD *)char v18 = 136315394;
    *(void *)&v18[4] = v15;
    *(_WORD *)&v18[12] = 2080;
    *(void *)&v18[14] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s", v18, 0x16u);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  unint64_t v17 = v1[5];
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v18 = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Metric queried", v18, 2u);
  }
  *(void *)char v18 = _NSConcreteStackBlock;
  *(void *)&v18[8] = 0x40000000;
  *(void *)&v18[16] = sub_1007CF4EC;
  unsigned __int8 v19 = &unk_101A0A220;
  unint64_t v20 = v1;
  sub_1007CF2FC((wis::MetricFactory *)v18);
}

void sub_1007CF2FC(wis::MetricFactory *a1)
{
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v2 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8007Fu);
  if (v2)
  {
    uint64_t v3 = (wis::MetricContainer *)v2;
    uint64_t v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    uint64_t v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    wis::MetricContainer::~MetricContainer(v3);
    operator delete();
  }
}

void sub_1007CF468(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1007CF4EC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 112))();
}

void RoamingNetworkHandler::submitOperatorRoamingAwdMetric(RoamingNetworkHandler *this)
{
  uint64_t v2 = *((void *)this + 130);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 131);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(v2 + 56);
    uint64_t v6 = "true";
    if (*(unsigned char *)(v2 + 64)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    if (!*(unsigned char *)(v2 + 65)) {
      uint64_t v6 = "false";
    }
    *(_DWORD *)char v26 = 136315650;
    *(void *)&v26[4] = v5;
    *(_WORD *)&v26[12] = 2080;
    *(void *)&v26[14] = v7;
    *(_WORD *)&v26[22] = 2080;
    unsigned int v27 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s, needs submission: %s", v26, 0x20u);
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v8 = *((void *)this + 126);
  char v9 = (std::__shared_weak_count *)*((void *)this + 127);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *((void *)this + 5);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(v8 + 56);
    uint64_t v12 = "true";
    if (*(unsigned char *)(v8 + 64)) {
      char v13 = "true";
    }
    else {
      char v13 = "false";
    }
    if (!*(unsigned char *)(v8 + 65)) {
      uint64_t v12 = "false";
    }
    *(_DWORD *)char v26 = 136315650;
    *(void *)&v26[4] = v11;
    *(_WORD *)&v26[12] = 2080;
    *(void *)&v26[14] = v13;
    *(_WORD *)&v26[22] = 2080;
    unsigned int v27 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s, needs submission: %s", v26, 0x20u);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v14 = *((void *)this + 128);
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 129);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v16 = *((void *)this + 5);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void *)(v14 + 56);
    char v18 = "true";
    if (*(unsigned char *)(v14 + 64)) {
      unsigned __int8 v19 = "true";
    }
    else {
      unsigned __int8 v19 = "false";
    }
    if (!*(unsigned char *)(v14 + 65)) {
      char v18 = "false";
    }
    *(_DWORD *)char v26 = 136315650;
    *(void *)&v26[4] = v17;
    *(_WORD *)&v26[12] = 2080;
    *(void *)&v26[14] = v19;
    *(_WORD *)&v26[22] = 2080;
    unsigned int v27 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s, needs submission: %s", v26, 0x20u);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v20 = *((void *)this + 126);
  if (*(unsigned char *)(*((void *)this + 130) + 65))
  {
    uint64_t v21 = *((void *)this + 128);
  }
  else
  {
    uint64_t v21 = *((void *)this + 128);
    if (!*(unsigned char *)(v20 + 65) && !*(unsigned char *)(v21 + 65)) {
      return;
    }
  }
  int v22 = *(unsigned __int8 *)(v20 + 64);
  if (*(unsigned char *)(v21 + 64))
  {
    int v23 = v22 | 2;
  }
  else
  {
    if (!v22) {
      return;
    }
    int v23 = 1;
  }
  unint64_t v24 = *((void *)this + 5);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = "3GPP/3GPP2";
    if (v23 == 1) {
      uint64_t v25 = "3GPP";
    }
    if (v23 == 2) {
      uint64_t v25 = "3GPP2";
    }
    *(_DWORD *)char v26 = 136315138;
    *(void *)&v26[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Operator roaming metric is of type: %s", v26, 0xCu);
  }
  *(void *)char v26 = _NSConcreteStackBlock;
  *(void *)&v26[8] = 0x40000000;
  *(void *)&v26[16] = sub_1007CF4EC;
  unsigned int v27 = (const char *)&unk_101A0A220;
  uint64_t v28 = this;
  sub_1007CF2FC((wis::MetricFactory *)v26);
  sub_100B35114(*((void *)this + 130));
  if (v23) {
    sub_100B35114(*((void *)this + 126));
  }
  if ((v23 & 2) != 0) {
    sub_100B35114(*((void *)this + 128));
  }
}

uint64_t RoamingNetworkHandler::fillInMetricInfo(RoamingNetworkHandler *this, awd::metrics::CommCenterOperatorRoaming *a2)
{
  uint64_t v4 = *((void *)this + 130);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 131);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *((void *)this + 5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v7 = *(void *)(v4 + 56);
    uint64_t v8 = "true";
    if (!*(unsigned char *)(v4 + 64)) {
      uint64_t v8 = "false";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v7;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s", (uint8_t *)&__p, 0x16u);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v9 = *((void *)this + 126);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 127);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *((void *)this + 5);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v12 = *(void *)(v9 + 56);
    char v13 = "true";
    if (!*(unsigned char *)(v9 + 64)) {
      char v13 = "false";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v12;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s", (uint8_t *)&__p, 0x16u);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v14 = *((void *)this + 128);
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 129);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v16 = *((void *)this + 5);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v17 = *(void *)(v14 + 56);
    char v18 = "true";
    if (!*(unsigned char *)(v14 + 64)) {
      char v18 = "false";
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v17;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s, valid: %s", (uint8_t *)&__p, 0x16u);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  unsigned __int8 v19 = (const std::string *)*((void *)this + 130);
  if (v19[2].__r_.__value_.__s.__data_[16])
  {
    *((_DWORD *)a2 + 27) |= 2u;
    uint64_t v20 = (std::string *)*((void *)a2 + 2);
    if (v20 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v20, v19 + 3);
    uint64_t v21 = (const std::string *)*((void *)this + 130);
    *((_DWORD *)a2 + 27) |= 4u;
    int v22 = (std::string *)*((void *)a2 + 3);
    if (v22 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v22, v21 + 4);
    int v23 = (const std::string *)*((void *)this + 130);
    *((_DWORD *)a2 + 27) |= 0x20u;
    unint64_t v24 = (std::string *)*((void *)a2 + 10);
    if (v24 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v24, v23 + 5);
    uint64_t v25 = *((void *)this + 126);
    int v26 = *(unsigned __int8 *)(*((void *)this + 128) + 64);
    if (*(unsigned char *)(v25 + 64))
    {
      int v27 = *((_DWORD *)a2 + 11);
      uint64_t v28 = *((int *)a2 + 10);
      if ((int)v28 >= v27)
      {
        if (v27 == *((_DWORD *)a2 + 12))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::metrics::CommCenterOperatorRoaming *)((char *)a2 + 32), v27 + 1);
          int v27 = *((_DWORD *)a2 + 11);
        }
        *((_DWORD *)a2 + 11) = v27 + 1;
        operator new();
      }
      uint64_t v29 = *((void *)a2 + 4);
      *((_DWORD *)a2 + 10) = v28 + 1;
      uint64_t v30 = *(void *)(v29 + 8 * v28);
      MCC::getStringValue((uint64_t *)&__p, (MCC *)(v25 + 72));
      *(_DWORD *)(v30 + 52) |= 1u;
      unint64_t v31 = *(std::string **)(v30 + 8);
      if (v31 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v31, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      MCC::getStringValue((uint64_t *)&__p, (MCC *)(*((void *)this + 126) + 104));
      *(_DWORD *)(v30 + 52) |= 2u;
      unint64_t v32 = *(std::string **)(v30 + 16);
      if (v32 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v32, &__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      uint64_t v33 = *((void *)this + 126);
      int v34 = *(_DWORD *)(v30 + 52);
      *(_DWORD *)(v30 + 32) = *(_DWORD *)(v33 + 164);
      *(_DWORD *)(v30 + 52) = v34 | 0xC;
      char v35 = *(std::string **)(v30 + 24);
      if (v35 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v35, (const std::string *)(v33 + 136));
      BOOL v36 = mapRoamingResultToTriBOOL() == 1;
      *(_DWORD *)(v30 + 52) |= 0x10u;
      *(unsigned char *)(v30 + 36) = v36;
    }
    if (v26)
    {
      int v37 = *((_DWORD *)a2 + 17);
      uint64_t v38 = *((int *)a2 + 16);
      if ((int)v38 >= v37)
      {
        if (v37 == *((_DWORD *)a2 + 18))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((awd::metrics::CommCenterOperatorRoaming *)((char *)a2 + 56), v37 + 1);
          int v37 = *((_DWORD *)a2 + 17);
        }
        *((_DWORD *)a2 + 17) = v37 + 1;
        operator new();
      }
      uint64_t v39 = *((void *)a2 + 7);
      *((_DWORD *)a2 + 16) = v38 + 1;
      uint64_t v40 = *(void *)(v39 + 8 * v38);
      uint64_t v41 = (const std::string *)*((void *)this + 128);
      *(_DWORD *)(v40 + 44) |= 8u;
      unint64_t v42 = *(std::string **)(v40 + 16);
      if (v42 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v42, v41 + 3);
      int v43 = (_DWORD *)*((void *)this + 128);
      int v44 = v43[24];
      int v45 = *(_DWORD *)(v40 + 44);
      *(_DWORD *)(v40 + 44) = v45 | 1;
      *(_DWORD *)(v40 + 8) = v44;
      *(_DWORD *)(v40 + 12) = v43[25];
      int v46 = v43[27];
      *(_DWORD *)(v40 + 44) = v45 | 7;
      *(_DWORD *)(v40 + 24) = v46;
      BOOL v47 = mapRoamingResultToTriBOOL() == 1;
      *(_DWORD *)(v40 + 44) |= 0x10u;
      *(unsigned char *)(v40 + 28) = v47;
    }
  }
  uint64_t result = subscriber::simSlotAsInstance();
  int v49 = *((_DWORD *)a2 + 27);
  *((_DWORD *)a2 + 24) = result;
  int v50 = *((_DWORD *)this + 30);
  *((_DWORD *)a2 + 27) = v49 | 0x180;
  *((_DWORD *)a2 + 23) = v50;
  return result;
}

void sub_1007CFEC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_1007CFF1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1007CFF2C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007CFF48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

const void **sub_1007CFF58@<X0>(const void ***a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  uint64_t result = *a1;
  if (result) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)result, @"TerminalRegistration");
    uint64_t v6 = 0;
    sub_10004EFE4(&v6, &Value);
    *a2 = v6;
    uint64_t v6 = 0;
    return sub_100057D78(&v6);
  }
  return result;
}

void sub_1007CFFD4(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1007CFFE8(const void **a1, unsigned __int8 *a2)
{
  CFDictionaryRef theDict = 0;
  sub_100058198((const void **)&v24, a1);
  sub_1007CFF58(&v24, &theDict);
  sub_100057D78((const void **)&v24);
  if (theDict) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    int v23 = 0;
    *(void *)&long long v26 = CFDictionaryGetValue(theDict, @"DestinationAddress");
    sub_100056248(&v23, (CFTypeRef *)&v26);
    if (v23) {
      uint64_t v4 = sub_1000810B8;
    }
    else {
      uint64_t v4 = 0;
    }
    if (v4)
    {
      long long v26 = 0uLL;
      unint64_t v27 = 0;
      ctu::cf::assign();
      unint64_t v22 = v27;
      *(_OWORD *)__s1 = v26;
      uint64_t v5 = (void *)*((void *)a2 + 1);
      int v6 = (char)a2[23];
      unint64_t v7 = HIBYTE(v27);
      if ((v27 & 0x8000000000000000) == 0) {
        uint64_t v8 = (void *)HIBYTE(v22);
      }
      else {
        uint64_t v8 = __s1[1];
      }
      if (v6 >= 0) {
        uint64_t v5 = (void *)a2[23];
      }
      if (v8 == v5)
      {
        if (v6 >= 0) {
          uint64_t v9 = a2;
        }
        else {
          uint64_t v9 = *(unsigned __int8 **)a2;
        }
        if ((v27 & 0x8000000000000000) != 0)
        {
          unsigned __int8 v19 = __s1[0];
          BOOL v18 = memcmp(__s1[0], v9, *((size_t *)&v26 + 1)) == 0;
          goto LABEL_33;
        }
        if (!v7)
        {
          sub_1000558F4(&v23);
          BOOL v18 = 1;
          goto LABEL_35;
        }
        unint64_t v10 = v7 - 1;
        uint64_t v11 = __s1;
        do
        {
          int v13 = *(unsigned __int8 *)v11;
          uint64_t v11 = (void **)((char *)v11 + 1);
          int v12 = v13;
          int v15 = *v9++;
          int v14 = v15;
          BOOL v17 = v10-- != 0;
          BOOL v18 = v12 == v14;
        }
        while (v12 == v14 && v17);
      }
      else
      {
        BOOL v18 = 0;
      }
      if ((v27 & 0x8000000000000000) == 0)
      {
LABEL_34:
        sub_1000558F4(&v23);
        goto LABEL_35;
      }
      unsigned __int8 v19 = __s1[0];
LABEL_33:
      operator delete(v19);
      goto LABEL_34;
    }
    sub_1000558F4(&v23);
  }
  BOOL v18 = 0;
LABEL_35:
  sub_100057D78((const void **)&theDict);
  return v18;
}

void sub_1007D0184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  unint64_t v7 = va_arg(va1, const void *);
  uint64_t v9 = va_arg(va1, void);
  if (*(char *)(v5 - 17) < 0) {
    operator delete(*(void **)(v5 - 40));
  }
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1007D01C4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1007D0220()
{
}

void *sub_1007D0244(void *a1)
{
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "cb.bom");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_101A0A290;
  a1[4] = BOMCopierNew();
  BOMCopierSetUserData();
  BOMCopierSetFileErrorHandler();
  BOMCopierSetFatalFileErrorHandler();
  return a1;
}

void sub_1007D033C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  CarrierBundleBOMCopierInterface::~CarrierBundleBOMCopierInterface(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D038C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = BOMCopierUserData();
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(v5 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136446466;
      uint64_t v9 = a2;
      __int16 v10 = 1024;
      int v11 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N BOMCopier error when copying %{public}s: %d", (uint8_t *)&v8, 0x12u);
    }
  }
  return 2;
}

void sub_1007D044C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = BOMCopierUserData();
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(v5 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136446466;
      uint64_t v8 = a2;
      __int16 v9 = 1024;
      int v10 = a3;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "BOMCopier fatal error when copying %{public}s: %d", (uint8_t *)&v7, 0x12u);
    }
  }
}

void sub_1007D050C(void *a1)
{
  *a1 = off_101A0A290;
  if (a1[4]) {
    BOMCopierFree();
  }
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  CarrierBundleBOMCopierInterface::~CarrierBundleBOMCopierInterface((CarrierBundleBOMCopierInterface *)a1);
}

void sub_1007D0584(void *a1)
{
  sub_1007D050C(a1);

  operator delete();
}

uint64_t sub_1007D05BC()
{
  *(void *)uint64_t v4 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v1 = *(__CFDictionary **)v4;
    *(void *)uint64_t v4 = Mutable;
    uint64_t v5 = v1;
    sub_10005717C((const void **)&v5);
  }
  sub_10012C97C(*(__CFDictionary **)v4, @"extractPKZip", (uint64_t)kCFBooleanTrue);
  sub_10012C97C(*(__CFDictionary **)v4, @"copyExtendedAttributes", (uint64_t)kCFBooleanTrue);
  sub_10012C97C(*(__CFDictionary **)v4, @"copyResources", (uint64_t)kCFBooleanTrue);
  uint64_t v2 = BOMCopierCopyWithOptions();
  sub_10005717C((const void **)v4);
  return v2;
}

void sub_1007D06B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_1007D06D4()
{
  *(void *)uint64_t v4 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v1 = *(__CFDictionary **)v4;
    *(void *)uint64_t v4 = Mutable;
    uint64_t v5 = v1;
    sub_10005717C((const void **)&v5);
  }
  sub_10012C97C(*(__CFDictionary **)v4, @"createPKZip", (uint64_t)kCFBooleanTrue);
  sub_10012C97C(*(__CFDictionary **)v4, @"copyExtendedAttributes", (uint64_t)kCFBooleanTrue);
  sub_10012C97C(*(__CFDictionary **)v4, @"keepParent", (uint64_t)kCFBooleanFalse);
  sub_10012C97C(*(__CFDictionary **)v4, @"copyResources", (uint64_t)kCFBooleanTrue);
  uint64_t v2 = BOMCopierCopyWithOptions();
  sub_10005717C((const void **)v4);
  return v2;
}

void sub_1007D07EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_1007D0810(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007D0890(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007D08CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007D0904(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1007D0934(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1007D0E18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, int a12, char a13)
{
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1007D0EC4(uint64_t a1)
{
  return a1;
}

void sub_1007D0EF0(uint64_t a1)
{
  operator delete();
}

void *sub_1007D0F3C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A0A3A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1007D0F94(uint64_t a1, void *a2)
{
  *a2 = off_101A0A3A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1007D0FDC(uint64_t a1)
{
}

void sub_1007D0FE4(id *a1)
{
  operator delete(a1);
}

void sub_1007D1020(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  uint64_t v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1007D10E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007D10FC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A0A400)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007D113C()
{
  return &off_101A0A400;
}

uint64_t sub_1007D1148(uint64_t a1, void *a2, void *a3, void *a4)
{
  *(void *)(a1 + 8) = off_1019BCED8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v11, kCtLoggingSystemName, "bat");
  sub_1007D1334((void *)(a1 + 16), "CSIBatteryMeasurementModelPrivate", QOS_CLASS_UTILITY, &v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
  *(void *)a1 = off_101A0A420;
  *(void *)(a1 + 8) = off_101A0A470;
  *(void *)(a1 + 56) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 64) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = 850045863;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = *a3;
  uint64_t v9 = a3[1];
  *(void *)(a1 + 144) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 152) = *a4;
  *(void *)(a1 + 160) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 168) = 0;
  ATCSTimer::ATCSTimer((ATCSTimer *)(a1 + 176));
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = a1 + 216;
  *(unsigned char *)(a1 + 232) = 0;
  return a1;
}

void sub_1007D12D8(_Unwind_Exception *a1)
{
  id v5 = (std::__shared_weak_count *)v1[18];
  if (v5) {
    sub_10004D2C8(v5);
  }
  std::mutex::~mutex(v3);
  uint64_t v6 = (std::__shared_weak_count *)v1[8];
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 6));
  sub_100087E88(v2);
  BatteryMeasurementInterface::~BatteryMeasurementInterface((BatteryMeasurementInterface *)v1);
  _Unwind_Resume(a1);
}

void *sub_1007D1334(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_100104718(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v7, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v7);
  return a1;
}

void sub_1007D139C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a9);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_1007D13D4(uint64_t a1)
{
  *(void *)a1 = off_101A0A420;
  *(void *)(a1 + 8) = off_101A0A470;
  sub_1000346F8(a1 + 208, *(void **)(a1 + 216));
  ATCSTimer::~ATCSTimer((ATCSTimer *)(a1 + 176));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 144);
  if (v2) {
    sub_10004D2C8(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 72));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));

  BatteryMeasurementInterface::~BatteryMeasurementInterface((BatteryMeasurementInterface *)a1);
}

uint64_t sub_1007D149C(uint64_t a1, signed int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 6) {
      uint64_t v9 = "Unknown";
    }
    else {
      uint64_t v9 = off_101A0A540[a2];
    }
    int v18 = 136315906;
    unsigned __int8 v19 = v9;
    __int16 v20 = 1024;
    signed int v21 = a2;
    __int16 v22 = 1024;
    unsigned int v23 = a3;
    __int16 v24 = 1024;
    int v25 = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Updating sensor %s(%u): filtered %u, raw %u", (uint8_t *)&v18, 0x1Eu);
  }
  uint64_t v10 = *(void *)(a1 + 216);
  if (!v10) {
    goto LABEL_16;
  }
  uint64_t v11 = a1 + 216;
  do
  {
    signed int v12 = *(_DWORD *)(v10 + 28);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      int v14 = (uint64_t *)v10;
    }
    else {
      int v14 = (uint64_t *)(v10 + 8);
    }
    if (!v13) {
      uint64_t v11 = v10;
    }
    uint64_t v10 = *v14;
  }
  while (*v14);
  if (v11 != a1 + 216 && *(_DWORD *)(v11 + 28) <= a2)
  {
    *(void *)(v11 + 32) = a3 | (unint64_t)(a4 << 32);
    return 1;
  }
  else
  {
LABEL_16:
    int v15 = *(NSObject **)(a1 + 48);
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v16)
    {
      int v18 = 67109120;
      LODWORD(v19) = a2;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Unrecognized sensor %u", (uint8_t *)&v18, 8u);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1007D1638(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v8 = (std::mutex *)(a1 + 72);
  std::mutex::lock((std::mutex *)(a1 + 72));
  if ((capabilities::ct::supportsThermalMonitor(v9) & 1) == 0) {
    goto LABEL_12;
  }
  uint64_t v12 = *(void *)(a1 + 216);
  uint64_t v11 = a1 + 216;
  uint64_t v10 = v12;
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v13 = v11;
  do
  {
    int v14 = *(_DWORD *)(v10 + 28);
    BOOL v15 = v14 < a2;
    if (v14 >= a2) {
      BOOL v16 = (uint64_t *)v10;
    }
    else {
      BOOL v16 = (uint64_t *)(v10 + 8);
    }
    if (!v15) {
      uint64_t v13 = v10;
    }
    uint64_t v10 = *v16;
  }
  while (*v16);
  if (v13 != v11 && *(_DWORD *)(v13 + 28) <= a2)
  {
    uint64_t v19 = *(void *)(v13 + 32);
    *a3 = v19;
    *a4 = HIDWORD(v19);
    uint64_t v17 = 1;
  }
  else
  {
LABEL_12:
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v8);
  return v17;
}

void sub_1007D16EC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D1700(uint64_t a1, int a2)
{
  uint64_t v4 = capabilities::ct::supportsThermalMonitor((capabilities::ct *)a1);
  if (v4)
  {
    int v5 = a2 & ~(a2 >> 31);
    std::mutex::lock((std::mutex *)(a1 + 72));
    *(_DWORD *)(a1 + 164) = v5;
    *(_DWORD *)(a1 + 168) = v5;
    if (*(unsigned char *)(a1 + 232))
    {
      if (a2 >= 1) {
        sub_1007D17B4(a1);
      }
      (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
    }
    std::mutex::unlock((std::mutex *)(a1 + 72));
  }
  return v4;
}

void sub_1007D17A0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D17B4(uint64_t result)
{
  uint64_t v1 = (void *)result;
  for (uint64_t i = 0; i != 7; ++i)
  {
    if (i != 4 && ((v1[19] >> i) & 1) == 0) {
      uint64_t result = (*(uint64_t (**)(void *, uint64_t))(*v1 + 56))(v1, i);
    }
  }
  return result;
}

void sub_1007D1824(uint64_t a1, int a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 72);
  std::mutex::lock((std::mutex *)(a1 + 72));
  int v5 = 0;
  switch(a2)
  {
    case 0:
    case 1:
      uint64_t v6 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I stopping temperature notification watchdog timer", v7, 2u);
      }
      *(_DWORD *)(a1 + 168) = 0;
      ATCSTimer::cancel((ATCSTimer *)(a1 + 176));
      *(unsigned char *)(a1 + 232) = 0;
      break;
    case 2:
      *(unsigned char *)(a1 + 232) = 1;
      *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 164);
      (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
      if (*(_DWORD *)(a1 + 168)) {
        sub_1007D17B4(a1);
      }
      if ((*(unsigned char *)(a1 + 152) & 0x10) == 0) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, 4);
      }
      break;
    case 3:
      goto LABEL_10;
    case 4:
      sub_1007D17B4(a1);
      int v5 = *(_DWORD *)(a1 + 164);
LABEL_10:
      *(_DWORD *)(a1 + 168) = v5;
      (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
      break;
    default:
      break;
  }
  std::mutex::unlock(v4);
}

void sub_1007D19A4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1007D19CC(uint64_t a1, int a2)
{
}

uint64_t sub_1007D19D4(uint64_t a1, int a2)
{
  uint64_t v4 = capabilities::ct::supportsThermalMonitor((capabilities::ct *)a1);
  if (v4)
  {
    int v5 = (std::mutex *)(a1 + 72);
    std::mutex::lock((std::mutex *)(a1 + 72));
    *(_DWORD *)(a1 + 160) = a2;
    uint64_t v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 67109120;
      v8[1] = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I setting call drop thermal threshold to %d", (uint8_t *)v8, 8u);
    }
    std::mutex::unlock(v5);
  }
  return v4;
}

uint64_t **sub_1007D1AA4(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x28uLL);
    v11[7] = **a4;
    *((void *)v11 + 4) = 0x8000000080000000;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

const void **stewie::dumpToString@<X0>(CFUUIDRef *a1@<X0>, uint64_t a2@<X8>)
{
  CFStringRef v4 = CFUUIDCreateString(kCFAllocatorDefault, *a1);
  long long v5 = 0uLL;
  uint64_t v6 = 0;
  ctu::cf::assign();
  *(_OWORD *)a2 = 0uLL;
  *(void *)(a2 + 16) = v6;
  return sub_1000558F4((const void **)&v4);
}

void sub_1007D1BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a9);
  _Unwind_Resume(a1);
}

void stewie::dumpToString(const void ***a1@<X0>, void *a2@<X8>)
{
  memset(&v25, 0, sizeof(v25));
  sub_100058DB0(&v25, "{ ");
  __int16 v22 = 0;
  std::string::size_type v23 = 0;
  uint64_t v24 = 0;
  sub_100058DB0(&v22, ", ");
  uint64_t v6 = *a1;
  CFStringRef v4 = a1 + 1;
  long long v5 = v6;
  if (v6 != (const void **)v4)
  {
    do
    {
      sub_1002055B4(v5 + 4, (const void **)&v22, __p);
      if ((v21 & 0x80u) == 0) {
        uint64_t v7 = __p;
      }
      else {
        uint64_t v7 = (void **)__p[0];
      }
      if ((v21 & 0x80u) == 0) {
        std::string::size_type v8 = v21;
      }
      else {
        std::string::size_type v8 = (std::string::size_type)__p[1];
      }
      std::string::append(&v25, (const std::string::value_type *)v7, v8);
      if ((char)v21 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v9 = (const void **)v5[1];
      if (v9)
      {
        do
        {
          int v10 = (const void ***)v9;
          uint64_t v9 = (const void **)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (const void ***)v5[2];
          BOOL v11 = *v10 == v5;
          long long v5 = (const void **)v10;
        }
        while (!v11);
      }
      long long v5 = (const void **)v10;
    }
    while (v10 != v4);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = v25.__r_.__value_.__l.__size_;
    if (v25.__r_.__value_.__l.__size_) {
      goto LABEL_20;
    }
LABEL_33:
    size_t v18 = 0;
    goto LABEL_35;
  }
  if (!*((unsigned char *)&v25.__r_.__value_.__s + 23)) {
    goto LABEL_33;
  }
  std::string::size_type size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
LABEL_20:
  std::string::size_type v13 = HIBYTE(v24);
  if (v24 < 0) {
    std::string::size_type v13 = v23;
  }
  if (size <= v13) {
    __assert_rtn("dumpToString", "StewieDumpStateUtils.cpp", 42, "result.size() > kSeparator.size()");
  }
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v14 = &v25;
  }
  else {
    int v14 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v15 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v15 = v25.__r_.__value_.__l.__size_;
  }
  BOOL v16 = (char *)v14 + v15;
  uint64_t v17 = (char *)&v25 + HIBYTE(v25.__r_.__value_.__r.__words[2]);
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v17 = (char *)(v25.__r_.__value_.__r.__words[0] + v25.__r_.__value_.__l.__size_);
  }
  std::string::erase(&v25, &v16[-v13] - (char *)v14, v17 - &v16[-v13]);
  if ((*((unsigned char *)&v25.__r_.__value_.__s + 23) & 0x80) != 0) {
    size_t v18 = v25.__r_.__value_.__l.__size_;
  }
  else {
    size_t v18 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  }
LABEL_35:
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1000C140C((uint64_t)a2, v18 + 2);
  if (*((char *)a2 + 23) < 0) {
    a2 = (void *)*a2;
  }
  if (v18)
  {
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v19 = &v25;
    }
    else {
      uint64_t v19 = (std::string *)v25.__r_.__value_.__r.__words[0];
    }
    memmove(a2, v19, v18);
  }
  strcpy((char *)a2 + v18, " }");
  if (SHIBYTE(v24) < 0) {
    operator delete(v22);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
}

void sub_1007D1E1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007D1E70(NSObject **a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  v16[0] = 0;
  v16[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v16);
  ctu::TextConverter::pushConversion();
  LODWORD(a2) = *(_DWORD *)(a2 + 48);
  std::string::size_type v8 = *a1;
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (a2 == 3)
  {
    if (v9)
    {
      if (a3[23] >= 0) {
        int v10 = a3;
      }
      else {
        int v10 = *(const char **)a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Get Inkey: Requested format is UCS2, coding the string %s in UCS2", buf, 0xCu);
    }
    ctu::TextConverter::pushConversion();
    char v11 = 3;
  }
  else
  {
    if (v9)
    {
      if (a3[23] >= 0) {
        uint64_t v12 = a3;
      }
      else {
        uint64_t v12 = *(const char **)a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Get Inkey: Requested format is GSM-7, sending the string %s in GSM 7 bit", buf, 0xCu);
    }
    ctu::TextConverter::pushConversion();
    char v11 = 2;
  }
  int v13 = a3[23];
  if (v13 >= 0) {
    int v14 = a3;
  }
  else {
    int v14 = *(const char **)a3;
  }
  if (v13 >= 0) {
    unint64_t v15 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    unint64_t v15 = *((void *)a3 + 1);
  }
  ctu::TextConverter::setSource((ctu::TextConverter *)v16, v14, v15);
  ctu::TextConverter::readChars((uint64_t *)buf, (ctu::TextConverter *)v16, 0x7FFFFFFFuLL);
  *(unsigned char *)a4 = v11;
  *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
  *(void *)(a4 + 24) = v18;
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v16);
}

void sub_1007D2030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1007D2050(os_log_t *a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  v20[0] = 0;
  v20[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v20);
  ctu::TextConverter::pushConversion();
  if (*(_DWORD *)(a2 + 48) == 3)
  {
    std::string::size_type v8 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      if (a3[23] >= 0) {
        BOOL v9 = (uint64_t *)a3;
      }
      else {
        BOOL v9 = *(uint64_t **)a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Get Input: Requested format is UCS2, coding the string %s in UCS2", buf, 0xCu);
    }
    ctu::TextConverter::pushConversion();
    char v10 = 3;
  }
  else
  {
    int v11 = *(_DWORD *)(a2 + 52);
    uint64_t v12 = *a1;
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (v11 == 1)
    {
      if (v13)
      {
        int v14 = *(uint64_t **)a3;
        if (a3[23] >= 0) {
          int v14 = (uint64_t *)a3;
        }
        if (*(unsigned char *)(a2 + 72)) {
          unint64_t v15 = "true";
        }
        else {
          unint64_t v15 = "false";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&buf[4] = v14;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v15;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Get Input: Requested format is GSM-7/Packed, coding the string %s in GSM 7 bit, packed by baseband: %s", buf, 0x16u);
      }
      ctu::TextConverter::pushConversion();
      if (!*(unsigned char *)(a2 + 72)) {
        ctu::TextConverter::pushConversion();
      }
      char v10 = 1;
    }
    else
    {
      if (v13)
      {
        if (a3[23] >= 0) {
          BOOL v16 = (uint64_t *)a3;
        }
        else {
          BOOL v16 = *(uint64_t **)a3;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&buf[4] = v16;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Get Input: Requested format is GSM-7/Unpacked, coding the string %s in GSM 8 bit", buf, 0xCu);
      }
      ctu::TextConverter::pushConversion();
      char v10 = 2;
    }
  }
  int v17 = a3[23];
  if (v17 >= 0) {
    uint64_t v18 = a3;
  }
  else {
    uint64_t v18 = *(const char **)a3;
  }
  if (v17 >= 0) {
    unint64_t v19 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    unint64_t v19 = *((void *)a3 + 1);
  }
  ctu::TextConverter::setSource((ctu::TextConverter *)v20, v18, v19);
  ctu::TextConverter::readChars((uint64_t *)buf, (ctu::TextConverter *)v20, 0x7FFFFFFFuLL);
  *(unsigned char *)a4 = v10;
  *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
  *(void *)(a4 + 24) = *(void *)&buf[16];
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v20);
}

void sub_1007D22E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1007D2304(os_log_t *a1@<X0>, uint64_t a2@<X2>, unsigned char *a3@<X8>)
{
  long long v5 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I ProvideLocalInfoLanguage: Coding as GSM 8 bit", v7, 2u);
  }
  *a3 = 2;
  uint64_t v6 = a3 + 8;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    *((void *)v6 + 2) = *(void *)(a2 + 16);
  }
}

void *sub_1007D23A4@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  std::string::size_type v8 = (std::string *)(a4 + 16);
  *(_OWORD *)(a4 + 144) = 0u;
  BOOL v9 = (void *)(a4 + 144);
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a4 + 8));
  void *v9 = 0;
  *(_WORD *)(a4 + 168) = 0;
  *(void *)(a4 + 152) = 0;
  *(void *)(a4 + 160) = 0;
  *(_DWORD *)a4 = a1;
  *(_DWORD *)(a4 + 4) = a2;
  *(void *)(a4 + 8) = *(void *)(a3 + 56);
  std::string::operator=(v8, (const std::string *)(a3 + 64));
  std::string::operator=((std::string *)(a4 + 40), (const std::string *)(a3 + 88));
  *(_DWORD *)(a4 + 64) = *(_DWORD *)(a3 + 112);
  *(unsigned char *)(a4 + 68) = *(unsigned char *)(a3 + 116);
  std::string::operator=((std::string *)(a4 + 72), (const std::string *)(a3 + 120));
  std::string::operator=((std::string *)(a4 + 96), (const std::string *)(a3 + 144));
  char v10 = *(char **)(a3 + 24);
  *(_OWORD *)(a4 + 120) = *(_OWORD *)(a3 + 168);
  *(unsigned char *)(a4 + 136) = *(unsigned char *)(a3 + 184);
  int v11 = *(char *)(a3 + 47);
  if (v11 >= 0) {
    uint64_t v12 = (char *)(a3 + 24);
  }
  else {
    uint64_t v12 = v10;
  }
  if (v11 >= 0) {
    unint64_t v13 = *(unsigned __int8 *)(a3 + 47);
  }
  else {
    unint64_t v13 = *(void *)(a3 + 32);
  }
  uint64_t result = sub_10075526C(v9, v12, &v12[v13], v13);
  *(unsigned char *)(a4 + 168) = *(_DWORD *)(a3 + 48) == 1;
  *(unsigned char *)(a4 + 169) = *(_DWORD *)(a3 + 20) == 1;
  return result;
}

void sub_1007D24C8(_Unwind_Exception *a1)
{
  sub_100094464(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D24DC@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 144) = 0;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a4 + 8));
  *(_DWORD *)(a4 + 144) = 0;
  *(_DWORD *)a4 = a1;
  *(_DWORD *)(a4 + 4) = a2;
  CSIPhoneNumber::CSIPhoneNumber();
  *(void *)(a4 + 8) = v12;
  std::string::size_type v8 = (void **)(a4 + 16);
  if (*(char *)(a4 + 39) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)std::string::size_type v8 = v13;
  *(void *)(a4 + 32) = v14;
  BOOL v9 = (void **)(a4 + 40);
  if (*(char *)(a4 + 63) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)BOOL v9 = v15;
  *(void *)(a4 + 56) = v16;
  *(_DWORD *)(a4 + 64) = v17;
  *(unsigned char *)(a4 + 68) = v18;
  char v10 = (void **)(a4 + 72);
  if (*(char *)(a4 + 95) < 0) {
    operator delete(*v10);
  }
  *(_OWORD *)char v10 = __p;
  *(void *)(a4 + 88) = v20;
  if (*(char *)(a4 + 119) < 0) {
    operator delete(*(void **)(a4 + 96));
  }
  *(_OWORD *)(a4 + 96) = v21;
  *(void *)(a4 + 112) = v22;
  *(_OWORD *)(a4 + 120) = v23;
  *(unsigned char *)(a4 + 136) = v24;
  uint64_t result = sub_1001EC530(a3);
  *(_DWORD *)(a4 + 144) = result;
  return result;
}

void sub_1007D26AC(_Unwind_Exception *a1)
{
  sub_100093EDC(v1);
  _Unwind_Resume(a1);
}

std::string *sub_1007D26C0@<X0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)a3 = a1;
  std::string::operator=((std::string *)(a3 + 8), (const std::string *)(a2 + 24));
  return std::string::operator=((std::string *)(a3 + 32), (const std::string *)(a2 + 104));
}

void sub_1007D2714(_Unwind_Exception *a1)
{
  sub_100087784(v1);
  _Unwind_Resume(a1);
}

void LASDController::submitAWDMetricsForUpdate_sync(uint64_t a1, void *a2)
{
  if ((void *)*a2 != a2 + 1) {
    operator new();
  }
}

void sub_1007D2998(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_1007D2A38(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  int BasebandBootStrategy = capabilities::ct::getBasebandBootStrategy(a1);
  if (BasebandBootStrategy != 1)
  {
    if (BasebandBootStrategy == 2) {
      sub_1013FCDF8(&v12);
    }
    std::string::size_type v8 = (std::__shared_weak_count *)operator new(0x28uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A818;
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)&off_101AAF700;
    v8[1].__shared_owners_ = 0;
    long long v5 = v8;
    BOOL v9 = operator new(0x20uLL);
    v9[1] = 0;
    unint64_t v9[2] = 0;
    void *v9 = off_101A0A868;
    if (!v5)
    {
LABEL_14:
      if (v9) {
        atomic_fetch_add_explicit(v9 + 1, 1uLL, memory_order_relaxed);
      }
      sub_10087A4A4(a2);
    }
LABEL_13:
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_14;
  }
  long long v5 = (std::__shared_weak_count *)operator new(0x70uLL);
  v5->__shared_owners_ = 0;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A778;
  uint64_t v6 = v5 + 1;
  sub_1008DDE44(&v5[1].__vftable, a1);
  uint64_t v7 = (std::__shared_weak_count *)v5[2].__vftable;
  if (v7)
  {
    if (v7->__shared_owners_ != -1) {
      goto LABEL_11;
    }
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v5[1].__shared_weak_owners_ = (uint64_t)v6;
    v5[2].__vftable = (std::__shared_weak_count_vtbl *)v5;
    std::__shared_weak_count::__release_weak(v7);
  }
  else
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v5[1].__shared_weak_owners_ = (uint64_t)v6;
    v5[2].__vftable = (std::__shared_weak_count_vtbl *)v5;
  }
  sub_10004D2C8(v5);
LABEL_11:
  uint64_t v11 = *(void *)a1;
  uint64_t v10 = *((void *)a1 + 1);
  BOOL v9 = operator new(0x30uLL);
  v9[1] = 0;
  unint64_t v9[2] = 0;
  void *v9 = off_101A0A7C8;
  v9[3] = off_101A637F8;
  v9[4] = v11;
  v9[5] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  goto LABEL_13;
}

void sub_1007D2CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007D2D64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A778;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007D2D84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A778;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007D2DD8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1007D2E00(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A7C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007D2E20(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A7C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007D2E74(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1007D2E9C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A818;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007D2EBC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007D2F10(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1007D2F38(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A868;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1007D2F58(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0A868;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007D2FAC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1007D2FD4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_1007D3060(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_101A0A970;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_1007D30FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1007D3118(CTXPCNotificationInterface *this)
{
  *(void *)this = off_101A0A8B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCNotificationInterface::~CTXPCNotificationInterface(this);
}

void sub_1007D3174(CTXPCNotificationInterface *this)
{
  *(void *)this = off_101A0A8B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCNotificationInterface::~CTXPCNotificationInterface(this);

  operator delete();
}

void sub_1007D31E4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007D324C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007D3288(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007D32C0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1007D32F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1007D3338()
{
}

void *sub_1007D334C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A0A970;
  return result;
}

void sub_1007D3384(uint64_t a1, void *a2)
{
  *a2 = off_101A0A970;
}

id sub_1007D33AC(uint64_t a1, id *a2)
{
  return [*a2 dualSimCapabilityDidChange];
}

uint64_t sub_1007D33B4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007D33F4()
{
}

uint64_t sub_1007D3400@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::supportsBIPController(a1);
  *a2 = 0;
  a2[1] = 0;
  if (result) {
    operator new();
  }
  return result;
}

void sub_1007D3718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_1007D3854(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  CFStringRef v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007D3954(void *a1)
{
  uint64_t v2 = a1 + 18;
  if ((rest::operator==() & 1) == 0 && *v2)
  {
    uint64_t v3 = a1[4];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bundle change: %s", (uint8_t *)&v4, 0xCu);
    }
    sub_1007D3A24(a1);
  }
}

void sub_1007D3A24(void *a1)
{
  if (a1[10])
  {
    unsigned int v2 = sub_1007D3DE4((uint64_t)a1, @"BasebandBootDuration", (uint64_t)"Boot Duration");
    if (v2)
    {
      a1[13] = v2;
    }
    else
    {
      int v4 = a1[4];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = a1[13];
        int v9 = 134217984;
        uint64_t v10 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Did not find baseband boot duration key, using default %ld", (uint8_t *)&v9, 0xCu);
      }
    }
    unsigned int v6 = sub_1007D3DE4((uint64_t)a1, @"BasebandBootInterval", (uint64_t)"Boot Interval");
    if (v6)
    {
      a1[14] = v6;
    }
    else
    {
      uint64_t v7 = a1[4];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = a1[14];
        int v9 = 134217984;
        uint64_t v10 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N Did not find baseband boot interval key, using default %ld", (uint8_t *)&v9, 0xCu);
      }
    }
  }
  else
  {
    uint64_t v3 = a1[4];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Missing CarrierSettings!", (uint8_t *)&v9, 2u);
    }
  }
}

void sub_1007D3BA8(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 != a2)
  {
    int v4 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)unsigned int v6 = 136315138;
      *(void *)&v6[4] = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Baseband mode changed to %s", v6, 0xCu);
      int v2 = *(_DWORD *)(a1 + 72);
    }
    if (v2 == 3)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      *(void *)unsigned int v6 = CFDateCreate(kCFAllocatorDefault, Current);
      DevicePersistentSaveValue(@"kDateBasebandLastBootedKey", *(const void **)v6);
      if (*(unsigned char *)(a1 + 124) == 3) {
        sub_1007D3CCC(a1);
      }
      sub_10007CA64((const void **)v6);
    }
  }
}

void sub_1007D3CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void *sub_1007D3CCC(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/assertions/baseband_online");
  ctu::rest::AssertionHandle::create();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 136);
  *(_OWORD *)(a1 + 128) = v4;
  if (v2) {
    sub_10004D2C8(v2);
  }
  __p[0] = off_101A0ADD0;
  __p[1] = (void *)a1;
  uint64_t v7 = __p;
  ctu::rest::AssertionHandle::setHandler_impl();
  return sub_100060644(__p);
}

void sub_1007D3DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

uint64_t sub_1007D3DE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    CFTypeRef cf = 0;
    uint64_t v6 = *(void *)(a1 + 80);
    uint64_t v7 = kCarrier1BundleId;
    uint64_t v8 = operator new(0x10uLL);
    *(void *)&__p[8] = v8 + 2;
    *(void *)&__p[16] = v8 + 2;
    void *v8 = @"BasebandBootOptions";
    v8[1] = a2;
    *(void *)long long __p = v8;
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, unsigned char *, void, void))(*(void *)v6 + 16))(&cf, v6, v7, __p, 0, 0);
    if (*(void *)__p)
    {
      *(void *)&__p[8] = *(void *)__p;
      operator delete(*(void **)__p);
    }
    if (cf) {
      int v9 = sub_100080934;
    }
    else {
      int v9 = 0;
    }
    if (v9)
    {
      CFTypeID v10 = CFGetTypeID(cf);
      if (v10 == CFNumberGetTypeID())
      {
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
        int v11 = valuePtr;
        if (valuePtr > 0)
        {
          uint64_t v12 = valuePtr;
LABEL_19:
          sub_1000577C4(&cf);
          return v12;
        }
        char v18 = *(NSObject **)(a1 + 32);
        uint64_t v12 = 0;
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_19;
        }
        *(_DWORD *)long long __p = 136315394;
        *(void *)&__p[4] = a3;
        *(_WORD *)&__p[12] = 1024;
        *(_DWORD *)&__p[14] = v11;
        long long v15 = "#N Invalid %s key value: %d, dropping it!";
        uint64_t v16 = v18;
        uint32_t v17 = 18;
      }
      else
      {
        uint64_t v14 = *(NSObject **)(a1 + 32);
        uint64_t v12 = 0;
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_19;
        }
        *(_DWORD *)long long __p = 136315138;
        *(void *)&__p[4] = a3;
        long long v15 = "#N %s key is not a number";
        uint64_t v16 = v14;
        uint32_t v17 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, __p, v17);
    }
    uint64_t v12 = 0;
    goto LABEL_19;
  }
  long long v13 = *(NSObject **)(a1 + 32);
  uint64_t v12 = 0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N Invalid %s key", __p, 0xCu);
    return 0;
  }
  return v12;
}

void sub_1007D4034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12)
{
}

void sub_1007D4064(uint64_t *a1, int a2)
{
  if (*((_DWORD *)a1 + 30) != a2)
  {
    uint64_t v3 = a1[4];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Power source changed to %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v4 = a1[12];
    a1[12] = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    if (*((_DWORD *)a1 + 30) != 1)
    {
      Registry::getTimerService(&v15, (Registry *)a1[5]);
      uint64_t v5 = v15;
      sub_100058DB0(v13, "Power source debounce");
      uint64_t v6 = (std::__shared_weak_count *)a1[1];
      if (!v6 || (uint64_t v7 = *a1, (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
        sub_100088B9C();
      }
      int v9 = v8;
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      *(_OWORD *)long long __p = *(_OWORD *)v13;
      uint64_t v19 = v14;
      v13[0] = 0;
      v13[1] = 0;
      uint64_t v14 = 0;
      *(void *)&long long buf = off_101A0AE50;
      *((void *)&buf + 1) = v7;
      long long v21 = v9;
      p_long long buf = &buf;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, void, uint64_t, void, long long *))(*(void *)v5 + 40))(&v17, v5, __p, 0, 30000000, 0, &buf);
      sub_10003B34C(&buf);
      if (SHIBYTE(v19) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v10 = v17;
      uint64_t v17 = 0;
      uint64_t v11 = a1[12];
      a1[12] = v10;
      if (v11)
      {
        (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        uint64_t v12 = v17;
        uint64_t v17 = 0;
        if (v12) {
          (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        }
      }
      if (SHIBYTE(v14) < 0) {
        operator delete(v13[0]);
      }
      if (v16) {
        sub_10004D2C8(v16);
      }
    }
  }
}

void sub_1007D42C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(a1);
}

void sub_1007D431C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 124) != a2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      uint64_t v8 = asString();
      __int16 v9 = 2080;
      uint64_t v10 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband service provisioned state has changed from %s to %s", (uint8_t *)&v7, 0x16u);
    }
    if (*(_DWORD *)(a1 + 72) == 3)
    {
      int v4 = *(unsigned __int8 *)(a1 + 124);
      if ((v4 - 1) < 2 || v4 == 4)
      {
        uint64_t v6 = *(std::__shared_weak_count **)(a1 + 136);
        *(void *)(a1 + 128) = 0;
        *(void *)(a1 + 136) = 0;
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      else if (v4 == 3)
      {
        sub_1007D3CCC(a1);
      }
    }
  }
}

void sub_1007D4434(void *a1)
{
  int v2 = a1[4];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 136315138;
    uint64_t v15 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Baseband mode: %s", (uint8_t *)&v14, 0xCu);
    int v2 = a1[4];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[13];
    int v14 = 134217984;
    uint64_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Boot duration: %ld minutes", (uint8_t *)&v14, 0xCu);
    int v2 = a1[4];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = a1[14];
    int v14 = 134217984;
    uint64_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Boot interval: %ld hours", (uint8_t *)&v14, 0xCu);
    int v2 = a1[4];
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = asString();
    int v14 = 136315138;
    uint64_t v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Baseband service provisioned state: %s", (uint8_t *)&v14, 0xCu);
    int v2 = a1[4];
  }
  uint64_t v6 = a1[16];
  BOOL v7 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (!v7) {
      return;
    }
    uint64_t v8 = "false";
    int v9 = *(_DWORD *)(v6 + 68);
    if (v9 == 2) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    if (!v9) {
      uint64_t v8 = "true";
    }
    int v14 = 136315394;
    uint64_t v15 = (uint64_t)v10;
    __int16 v16 = 2080;
    uint64_t v17 = v8;
    uint64_t v11 = "#I Baseband online assertion: acquired (%s) revoked (%s)";
    uint64_t v12 = v2;
    uint32_t v13 = 22;
  }
  else
  {
    if (!v7) {
      return;
    }
    LOWORD(v14) = 0;
    uint64_t v11 = "#I Baseband online assertion not held";
    uint64_t v12 = v2;
    uint32_t v13 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v14, v13);
}

void sub_1007D4670(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007D46A8(uint64_t a1)
{
}

uint64_t sub_1007D46C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1007D4708(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_100087784((uint64_t)(result + 18));
    int v2 = (std::__shared_weak_count *)v1[17];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = v1[12];
    v1[12] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[11];
    if (v4) {
      sub_10004D2C8(v4);
    }
    uint64_t v5 = (std::__shared_weak_count *)v1[8];
    if (v5) {
      sub_10004D2C8(v5);
    }
    uint64_t v6 = (std::__shared_weak_count *)v1[6];
    if (v6) {
      sub_10004D2C8(v6);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_1007D47C8(ServiceManager::Service *this)
{
  *(void *)this = off_101A0AA50;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1007D4824(ServiceManager::Service *this)
{
  *(void *)this = off_101A0AA50;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1007D4894@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "BIPController");
}

unsigned char *sub_1007D48A4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v2 = operator new(1uLL);
  *a1 = v2;
  *int v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1007D48E4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1007D3854(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1007D3854(v4, 0);
}

uint64_t sub_1007D4968()
{
  return 0;
}

uint64_t sub_1007D4970()
{
  return 1;
}

uint64_t sub_1007D4978()
{
  return 0;
}

void sub_1007D4984(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1007D4A64(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_1007D4B78(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 56));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1007D4BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1007D4C18(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *v1;
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v3 = operator new(0x28uLL);
  *uint64_t v3 = off_101A0AAD0;
  v3[1] = v2 + 144;
  v3[2] = v2;
  v3[3] = sub_1007D3954;
  v3[4] = 0;
  long long v26 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v25);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 40));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v25[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v25);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
LABEL_11:
  uint32_t v13 = *(std::__shared_weak_count **)(v2 + 88);
  *(void *)(v2 + 80) = v12;
  *(void *)(v2 + 88) = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  Registry::createRestModuleOneTimeUseConnection(&v21, *(Registry **)(v2 + 40));
  ctu::RestModule::connect();
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_100058DB0(__p, "/cc/props/baseband_mode");
  int v14 = operator new(0x28uLL);
  void *v14 = off_101A0AB50;
  v14[1] = v2 + 72;
  v14[2] = v2;
  v14[3] = sub_1007D3BA8;
  v14[4] = 0;
  long long v26 = v14;
  ctu::RestModule::observeProperty();
  sub_10003F600(v25);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/power_source");
  uint64_t v15 = operator new(0x28uLL);
  void *v15 = off_101A0ABD0;
  v15[1] = v2 + 120;
  v15[2] = v2;
  v15[3] = sub_1007D4064;
  v15[4] = 0;
  long long v26 = v15;
  ctu::RestModule::observeProperty();
  sub_10003F600(v25);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  __int16 v16 = operator new(0x20uLL);
  void *v16 = off_101A0AC50;
  v16[1] = v2;
  void v16[2] = sub_1007D4434;
  v16[3] = 0;
  long long v26 = v16;
  ctu::RestModule::observeEvent();
  sub_10003F600(v25);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/baseband_service_provisioned_states");
  uint64_t v17 = operator new(0x28uLL);
  *uint64_t v17 = off_101A0ACD0;
  v17[1] = v2 + 124;
  v17[2] = v2;
  v17[3] = sub_1007D431C;
  v17[4] = 0;
  long long v26 = v17;
  ctu::RestModule::observeProperty();
  sub_10003F600(v25);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  sub_100088C88((uint64_t *)&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1007D4FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1007D5054()
{
}

__n128 sub_1007D5068(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0AAD0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007D50BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0AAD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007D50F4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  uint64_t v17 = 0;
  char v18 = 0;
  __int16 v16 = &v17;
  sub_10008AAD8((uint64_t)&v16, a2);
  uint64_t v11 = 0;
  LOWORD(v11) = *(_WORD *)v3;
  uint64_t v4 = *(void *)(v3 + 24);
  *(_OWORD *)uint64_t v12 = *(_OWORD *)(v3 + 8);
  uint64_t v13 = v4;
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 8) = 0;
  long long v5 = *(_OWORD *)(v3 + 32);
  uint64_t v15 = *(void *)(v3 + 48);
  *(_OWORD *)long long __p = v5;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 32) = 0;
  unsigned int v9 = v16;
  v10[0] = v17;
  v10[1] = v18;
  if (v18)
  {
    v17[2] = v10;
    __int16 v16 = &v17;
    uint64_t v17 = 0;
    char v18 = 0;
  }
  else
  {
    unsigned int v9 = v10;
  }
  sub_1007D52CC((std::string *)v3, (uint64_t)&v9);
  sub_100087F94((uint64_t)&v9, v10[0]);
  if (rest::operator!=())
  {
    unint64_t v6 = (void (*)(void *, uint64_t *))a1[3];
    uint64_t v7 = a1[4];
    uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      unint64_t v6 = *(void (**)(void *, uint64_t *))(*v8 + v6);
    }
    v6(v8, &v11);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  sub_100087F94((uint64_t)&v16, v17);
}

void sub_1007D522C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_100087F94((uint64_t)&a10, a11);
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  sub_100087F94(v25 - 56, *(void **)(v25 - 48));
  _Unwind_Resume(a1);
}

uint64_t sub_1007D5280(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007D52C0()
{
}

std::string *sub_1007D52CC(std::string *result, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v2 = a2 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    long long v5 = result;
    uint64_t v6 = v2;
    do
    {
      int v7 = *(_DWORD *)(v3 + 32);
      BOOL v8 = v7 < 1;
      if (v7 >= 1) {
        unsigned int v9 = (uint64_t *)v3;
      }
      else {
        unsigned int v9 = (uint64_t *)(v3 + 8);
      }
      if (!v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }
    while (*v9);
    if (v6 != v2 && *(int *)(v6 + 32) <= 1)
    {
      LOWORD(result->__r_.__value_.__l.__data_) = *(_WORD *)(v6 + 40);
      std::string::operator=((std::string *)&result->__r_.__value_.__r.__words[1], (const std::string *)(v6 + 48));
      return std::string::operator=((std::string *)((char *)v5 + 32), (const std::string *)(v6 + 72));
    }
  }
  return result;
}

void sub_1007D5364()
{
}

__n128 sub_1007D5378(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0AB50;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007D53CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0AB50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007D5404(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1007D54DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007D551C()
{
}

void sub_1007D552C()
{
}

__n128 sub_1007D5540(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0ABD0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007D5594(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0ABD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007D55CC(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1007D56A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007D56E4()
{
}

void sub_1007D56F4()
{
}

__n128 sub_1007D5708(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A0AC50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1007D575C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0AC50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1007D5794(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1007D57BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007D57FC()
{
}

void sub_1007D580C()
{
}

__n128 sub_1007D5820(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0ACD0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007D5874(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0ACD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007D58AC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (unsigned char *)a1[1];
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  char v18 = &v19;
  sub_10031B0B4((uint64_t)&v18, a2);
  uint64_t v4 = *v3;
  uint64_t v5 = v19;
  __int16 v16 = v18;
  v17[0] = v19;
  v17[1] = v20;
  if (v20)
  {
    v19[2] = v17;
    char v18 = &v19;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    if (!v5) {
      goto LABEL_19;
    }
  }
  else
  {
    __int16 v16 = v17;
    if (!v19) {
      goto LABEL_19;
    }
  }
  uint64_t v6 = v17;
  int v7 = v5;
  do
  {
    BOOL v8 = v7;
    unsigned int v9 = v6;
    int v10 = *((_DWORD *)v7 + 7);
    if (v10 >= 1) {
      uint64_t v6 = v7;
    }
    else {
      ++v7;
    }
    int v7 = (void *)*v7;
  }
  while (v7);
  if (v6 != v17)
  {
    uint64_t v11 = (int *)(v10 >= 1 ? v8 : v9);
    if (v11[7] <= 1)
    {
      if (v10 >= 1) {
        uint64_t v12 = v8;
      }
      else {
        uint64_t v12 = v9;
      }
      *uint64_t v3 = *((unsigned char *)v12 + 32);
    }
  }
LABEL_19:
  sub_1000346F8((uint64_t)&v16, v5);
  if (v4 != *v3)
  {
    uint64_t v13 = (void (*)(void *, uint64_t))a1[3];
    uint64_t v14 = a1[4];
    uint64_t v15 = (void *)(a1[2] + (v14 >> 1));
    if (v14) {
      uint64_t v13 = *(void (**)(void *, uint64_t))(*v15 + v13);
    }
    v13(v15, v4);
  }
  sub_1000346F8((uint64_t)&v18, v19);
}

void sub_1007D59D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_1007D59F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007D5A34()
{
}

void sub_1007D5A40(void ***a1)
{
  uint64_t v1 = a1;
  sub_1007D3A24(**a1);
  operator delete();
}

void sub_1007D5A94()
{
}

void *sub_1007D5AC0(void *a1)
{
  *a1 = off_101A0AD50;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1007D5B0C(void *a1)
{
  *a1 = off_101A0AD50;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1007D5B78(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A0AD50;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1007D5BD4(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A0AD50;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007D5C0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1007D5C1C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1007D5C5C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 8);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_1007D5D74(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007D5DB4()
{
}

void sub_1007D5DC0(void **a1)
{
  uint64_t v6 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)**a1;
  uint64_t v3 = v2[4];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Releasing baseband online assertion", buf, 2u);
    uint64_t v2 = (void *)*v1;
  }
  uint64_t v4 = (std::__shared_weak_count *)v2[17];
  v2[16] = 0;
  v2[17] = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[1];
  if (v5) {
    sub_10004D2C8(v5);
  }
  operator delete();
}

void sub_1007D5E78()
{
}

void *sub_1007D5E8C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A0ADD0;
  result[1] = v3;
  return result;
}

uint64_t sub_1007D5ED4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0ADD0;
  a2[1] = v2;
  return result;
}

void sub_1007D5F00(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      uint64_t v4 = "is";
    }
    else {
      uint64_t v4 = "is NOT";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband online assertion %s held", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_1007D5FBC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007D5FFC()
{
}

void *sub_1007D6008(void *a1)
{
  *a1 = off_101A0AE50;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1007D6054(void *a1)
{
  *a1 = off_101A0AE50;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1007D60C0(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A0AE50;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1007D611C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A0AE50;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007D6154(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1007D6164(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1007D61A4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        int v5 = *(std::__shared_weak_count **)(v4 + 8);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_1007D62BC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007D62FC()
{
}

uint64_t *sub_1007D6308(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *v1;
  CFDateRef otherDate = 0;
  DevicePersistentCopyValue((uint64_t *)&buf, @"kDateBasebandLastBootedKey", 0);
  sub_100201EE4(&otherDate, (CFTypeRef *)&buf);
  sub_1000577C4((const void **)&buf);
  if (otherDate) {
    uint64_t v3 = sub_1001908E4;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v5 = CFDateCreate(kCFAllocatorDefault, Current);
    CFDateRef v26 = v5;
    if (v5) {
      uint64_t v6 = sub_1001908E4;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      int v7 = (int)CFDateGetTimeIntervalSinceDate(v5, otherDate) / 3600;
      uint64_t v8 = *(void *)(v2 + 112);
      unsigned int v9 = *(NSObject **)(v2 + 32);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      if (v8 >= v7)
      {
        if (v10)
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I It's only been %ld hours since we last booted, waiting", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        if (v10)
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N It's been %ld hours since we last booted", (uint8_t *)&buf, 0xCu);
        }
        sub_1007D3CCC(v2);
        Registry::getTimerService(&v24, *(Registry **)(v2 + 40));
        uint64_t v11 = v24;
        sub_100058DB0(v22, "Release BIP baseband online assertion");
        uint64_t v12 = *(std::__shared_weak_count **)(v2 + 8);
        if (!v12
          || (uint64_t v13 = *(void *)(v2 + 104), v14 = *(void *)v2, (v15 = std::__shared_weak_count::lock(v12)) == 0))
        {
          sub_100088B9C();
        }
        __int16 v16 = v15;
        atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        *(_OWORD *)long long __p = *(_OWORD *)v22;
        uint64_t v29 = v23;
        v22[0] = 0;
        v22[1] = 0;
        uint64_t v23 = 0;
        *(void *)&long long buf = off_101A0AD50;
        *((void *)&buf + 1) = v14;
        unint64_t v31 = v16;
        p_long long buf = &buf;
        (*(void (**)(uint64_t, void **, void, uint64_t, long long *))(*(void *)v11 + 32))(v11, __p, 0, 60000000 * v13, &buf);
        sub_10003B34C(&buf);
        if (SHIBYTE(v29) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v23) < 0) {
          operator delete(v22[0]);
        }
        if (v25) {
          sub_10004D2C8(v25);
        }
      }
    }
    else
    {
      char v18 = *(NSObject **)(v2 + 32);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get current time!", (uint8_t *)&buf, 2u);
      }
    }
    sub_10007CA64((const void **)&v26);
  }
  else
  {
    uint64_t v17 = *(NSObject **)(v2 + 32);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Did not find persisted last booted key", (uint8_t *)&buf, 2u);
    }
  }
  sub_10007CA64((const void **)&otherDate);
  sub_1000E3958((uint64_t *)&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_1007D6664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, const void *a20,const void *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  sub_10003B34C((void *)(v27 - 96));
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10007CA64(&a20);
  sub_10007CA64(&a21);
  sub_1000E3958(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_1007D6704(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1007D67D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007D681C(uint64_t a1, uint64_t a2)
{
  if (sub_1007D6C28(a1, a2))
  {
    sub_1007D79D0(a1);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 320) + 16))();
  }
}

void sub_1007D68A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007D68BC(void *a1, void *a2, NSObject **a3)
{
  uint64_t v6 = (const char *)kCtLoggingSystemName;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "ent.gba");
  a1[1] = 0;
  a1[2] = 0;
  int v7 = *a3;
  a1[3] = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v10, &v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v10);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v10);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *a1 = off_101A0AED0;
  a1[6] = *a2;
  uint64_t v8 = a2[1];
  a1[7] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, v6, "ent.gba.dbg");
  operator new();
}

void sub_1007D6AC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,char a21)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v22 + 416);
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (*(char *)(v22 + 407) < 0) {
    operator delete(*(void **)(v22 + 384));
  }
  if (*(char *)(v22 + 383) < 0) {
    operator delete(*v24);
  }
  if (*(char *)(v22 + 351) < 0) {
    operator delete(*(void **)(v22 + 328));
  }
  uint64_t v28 = *(const void **)(v22 + 320);
  if (v28) {
    _Block_release(v28);
  }
  if (*(char *)(v22 + 319) < 0) {
    operator delete(*(void **)(v22 + 296));
  }
  sub_1007DC910(v25);
  uint64_t v29 = *(std::__shared_weak_count **)(v22 + 80);
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_100119D1C((ctu::OsLogLogger **)(v22 + 64), 0);
  uint64_t v30 = *(std::__shared_weak_count **)(v22 + 56);
  if (v30) {
    sub_10004D2C8(v30);
  }
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D6C28(uint64_t a1, uint64_t a2)
{
  sub_100058DB0(&buf, "WWW-Authenticate");
  uint64_t v4 = sub_10014C044(a2, (uint64_t)&buf);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  if (a2 + 8 != v4)
  {
    std::string::operator=((std::string *)(a1 + 296), (const std::string *)(v4 + 56));
    CFURLRef anURL = 0;
    CFDateRef v5 = (const std::string *)(a1 + 184);
    if (*(char *)(a1 + 207) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a1 + 184), *(void *)(a1 + 192));
    }
    else
    {
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = *(void *)(a1 + 200);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = __p;
    }
    v88.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __dst;
    }
    v94.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v8 = v88.__r_.__value_.__r.__words[0];
      v88.__r_.__value_.__r.__words[0] = v94.__r_.__value_.__r.__words[0];
      v95.__r_.__value_.__r.__words[0] = v8;
      sub_1000558F4((const void **)&v95.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    URLString[0] = (CFStringRef)v88.__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v88.__r_.__value_.__l.__data_);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    CFURLRef anURL = CFURLCreateWithString(kCFAllocatorDefault, URLString[0], 0);
    sub_1000558F4((const void **)URLString);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (anURL) {
      OsLogContext v9 = sub_1000FCC20;
    }
    else {
      OsLogContext v9 = 0;
    }
    uint64_t v7 = v9 != 0;
    if (!v9)
    {
      uint64_t v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a1 + 207) < 0) {
          CFDateRef v5 = (const std::string *)v5->__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v98 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "#E %s%sfailed to parse naf_url [%s]", (uint8_t *)&buf, 0x20u);
      }
      goto LABEL_211;
    }
    CFStringRef v91 = 0;
    CFStringRef v91 = CFURLCopyHostName(anURL);
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    __dst.__r_.__value_.__r.__words[0] = buf.__r_.__value_.__l.__size_;
    std::string::size_type v10 = buf.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 7);
    char v11 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    uint64_t v12 = (void **)(a1 + 328);
    if (*(char *)(a1 + 351) < 0) {
      operator delete(*v12);
    }
    std::string::size_type v13 = __dst.__r_.__value_.__r.__words[0];
    *(void *)(a1 + 328) = v10;
    *(void *)(a1 + 336) = v13;
    *(void *)(a1 + 343) = *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 7);
    *(unsigned char *)(a1 + 351) = v11;
    CFStringRef v90 = 0;
    CFStringRef v14 = CFURLCopyScheme(anURL);
    CFStringRef v90 = v14;
    if (v14) {
      uint64_t v15 = sub_1000810B8;
    }
    else {
      uint64_t v15 = 0;
    }
    if (v15) {
      LOBYTE(v15) = CFEqual(v14, @"https");
    }
    *(unsigned char *)(a1 + 352) = (_BYTE)v15;
    CFStringRef v89 = 0;
    CFStringRef v89 = CFURLCopyPath(anURL);
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string v88 = buf;
    if (v89) {
      __int16 v16 = sub_1000810B8;
    }
    else {
      __int16 v16 = 0;
    }
    if (v16
      && ((int v17 = SHIBYTE(v88.__r_.__value_.__r.__words[2]),
           (v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        ? (int64_t v18 = HIBYTE(v88.__r_.__value_.__r.__words[2]))
        : (int64_t v18 = v88.__r_.__value_.__l.__size_),
          v18))
    {
      if (*(char *)(a1 + 207) < 0)
      {
        uint64_t v20 = *(char **)(a1 + 184);
        uint64_t v19 = *(void *)(a1 + 192);
      }
      else
      {
        uint64_t v19 = *(unsigned __int8 *)(a1 + 207);
        uint64_t v20 = (char *)(a1 + 184);
      }
      char v23 = *(unsigned char *)(a1 + 351);
      if (v23 >= 0) {
        uint64_t v24 = (char *)(a1 + 328);
      }
      else {
        uint64_t v24 = *(char **)(a1 + 328);
      }
      if (v23 >= 0) {
        int64_t v25 = *(unsigned __int8 *)(a1 + 351);
      }
      else {
        int64_t v25 = *(void *)(a1 + 336);
      }
      if (v25)
      {
        CFDateRef v26 = &v20[v19];
        if (v19 >= v25)
        {
          int v29 = *v24;
          uint64_t v30 = v20;
          do
          {
            uint64_t v31 = v19 - v25;
            if (v31 == -1) {
              break;
            }
            unint64_t v32 = (char *)memchr(v30, v29, v31 + 1);
            if (!v32) {
              break;
            }
            uint64_t v27 = v32;
            if (!memcmp(v32, v24, v25)) {
              goto LABEL_70;
            }
            uint64_t v30 = v27 + 1;
            uint64_t v19 = v26 - (v27 + 1);
          }
          while (v19 >= v25);
          uint64_t v27 = v26;
LABEL_70:
          CFDateRef v5 = (const std::string *)(a1 + 184);
        }
        else
        {
          uint64_t v27 = &v20[v19];
        }
        uint64_t v28 = v27 - v20;
        if (v27 == v26) {
          uint64_t v28 = -1;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      unsigned int v85 = v7;
      std::string::size_type v33 = v28 + v25;
      p_std::string buf = &buf;
      std::string::basic_string(&buf, v5, v33, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__dst);
      int v35 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
      if (v17 >= 0) {
        BOOL v36 = &v88;
      }
      else {
        BOOL v36 = (std::string *)v88.__r_.__value_.__r.__words[0];
      }
      int64_t size = buf.__r_.__value_.__l.__size_;
      uint64_t v38 = (void *)buf.__r_.__value_.__r.__words[0];
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int64_t size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      uint64_t v39 = (char *)p_buf + size;
      if (size >= v18)
      {
        int v51 = v36->__r_.__value_.__s.__data_[0];
        unint64_t v52 = p_buf;
        do
        {
          int64_t v53 = size - v18;
          if (v53 == -1) {
            break;
          }
          char v54 = (char *)memchr(v52, v51, v53 + 1);
          if (!v54) {
            break;
          }
          uint64_t v40 = v54;
          if (!memcmp(v54, v36, v18)) {
            goto LABEL_81;
          }
          unint64_t v52 = (std::string *)(v40 + 1);
          int64_t size = v39 - (v40 + 1);
        }
        while (size >= v18);
      }
      uint64_t v40 = v39;
LABEL_81:
      if (v40 == v39) {
        uint64_t v41 = -1;
      }
      else {
        uint64_t v41 = v40 - (char *)p_buf;
      }
      if (v35 < 0) {
        operator delete(v38);
      }
      std::string::basic_string(&buf, (const std::string *)(a1 + 184), v41 + v33, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__dst);
      uint64_t v7 = v85;
      unint64_t v42 = (void **)(a1 + 360);
      uint64_t v12 = (void **)(a1 + 328);
      if (*(char *)(a1 + 383) < 0) {
        operator delete(*v42);
      }
      *(_OWORD *)unint64_t v42 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(void *)(a1 + 376) = *((void *)&buf.__r_.__value_.__l + 2);
    }
    else
    {
      if (*(char *)(a1 + 383) < 0)
      {
        *(void *)(a1 + 368) = 1;
        uint64_t v21 = *(_WORD **)(a1 + 360);
      }
      else
      {
        uint64_t v21 = (_WORD *)(a1 + 360);
        *(unsigned char *)(a1 + 383) = 1;
      }
      *uint64_t v21 = 47;
    }
    int v43 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 351) < 0) {
        uint64_t v12 = (void **)*v12;
      }
      int v44 = *(unsigned __int8 *)(a1 + 352);
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v98 = (const std::string *)v12;
      __int16 v99 = 1024;
      int v100 = v44;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%snaf_host_: [%s], secured: %d", (uint8_t *)&buf, 0x26u);
      int v43 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      int v45 = (const std::string *)(a1 + 360);
      if (*(char *)(a1 + 383) < 0) {
        int v45 = (const std::string *)v45->__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v98 = v45;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%snaf_uri_ :  [%s]", (uint8_t *)&buf, 0x20u);
      int v43 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      ctu::Http::asString();
      int v46 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      v98 = v46;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%smethod   :  [%s]", (uint8_t *)&buf, 0x20u);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    BOOL v47 = (void **)(a1 + 384);
    if (*(char *)(a1 + 407) < 0)
    {
      unint64_t v49 = *(void *)(a1 + 392);
      int v50 = (void **)(a1 + 384);
      if (v49) {
        goto LABEL_120;
      }
    }
    else if (*(unsigned char *)(a1 + 407))
    {
      *(_OWORD *)URLString = *(_OWORD *)v47;
      uint64_t v48 = *(void *)(a1 + 400);
LABEL_110:
      uint64_t v87 = v48;
LABEL_202:
      if (*(char *)(a1 + 407) < 0) {
        operator delete(*v47);
      }
      *(_OWORD *)BOOL v47 = *(_OWORD *)URLString;
      *(void *)(a1 + 400) = v87;
      uint64_t v82 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 407) < 0) {
          BOOL v47 = (void **)*v47;
        }
        int v83 = *(_DWORD *)(a1 + 216);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v98 = (const std::string *)v47;
        __int16 v99 = 1024;
        int v100 = v83;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I %s%sbsf_host_ = %s, port: %d", (uint8_t *)&buf, 0x26u);
      }
      if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v88.__r_.__value_.__l.__data_);
      }
      sub_1000558F4((const void **)&v89);
      sub_1000558F4((const void **)&v90);
      sub_1000558F4((const void **)&v91);
LABEL_211:
      sub_1000FE824((const void **)&anURL);
      return v7;
    }
    if (!*(unsigned char *)(a1 + 248))
    {
      memset(&v95, 0, sizeof(v95));
      sub_100058DB0(&v95, "bsf.");
      memset(&v94, 0, sizeof(v94));
      if (*(char *)(a1 + 127) < 0)
      {
        v56 = *(char **)(a1 + 104);
        int64_t v55 = *(void *)(a1 + 112);
      }
      else
      {
        int64_t v55 = *(unsigned __int8 *)(a1 + 127);
        v56 = (char *)(a1 + 104);
      }
      if (v55 >= 1)
      {
        int v57 = &v56[v55];
        int v58 = v56;
        do
        {
          int v59 = (char *)memchr(v58, 64, v55);
          if (!v59) {
            break;
          }
          if (*v59 == 64)
          {
            if (v59 != v57 && v59 - v56 != -1)
            {
              memset(&buf, 0, sizeof(buf));
              std::string::basic_string(&buf, (const std::string *)(a1 + 104), v59 - v56 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__dst);
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                char v60 = &buf;
              }
              else {
                char v60 = (std::string *)buf.__r_.__value_.__r.__words[0];
              }
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v61 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              else {
                uint64_t v61 = buf.__r_.__value_.__l.__size_;
              }
              if (v61 >= 15)
              {
                v62 = (char *)v60 + v61;
                uint64_t v63 = v61;
                uint64_t v64 = v60;
                do
                {
                  v65 = (char *)memchr(v64, 51, v63 - 14);
                  if (!v65) {
                    break;
                  }
                  if (*(void *)v65 == 0x7774656E70706733 && *(void *)(v65 + 7) == 0x67726F2E6B726F77)
                  {
                    if (v65 == v62 || v65 - (char *)v60 == -1) {
                      break;
                    }
                    if (!std::string::compare(&buf, 0, 4uLL, "ims."))
                    {
                      std::string::basic_string(&__dst, &buf, 4uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v96);
                      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(buf.__r_.__value_.__l.__data_);
                      }
                      std::string buf = __dst;
                    }
                    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      v67 = &buf;
                    }
                    else {
                      v67 = (std::string *)buf.__r_.__value_.__r.__words[0];
                    }
                    int64_t v68 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                      int64_t v68 = buf.__r_.__value_.__l.__size_;
                    }
                    v69 = (char *)v67 + v68;
                    if (v68 >= 15)
                    {
                      uint64_t v70 = v67;
                      do
                      {
                        v71 = (char *)memchr(v70, 51, v68 - 14);
                        if (!v71) {
                          break;
                        }
                        if (*(void *)v71 == 0x7774656E70706733 && *(void *)(v71 + 7) == 0x67726F2E6B726F77) {
                          goto LABEL_165;
                        }
                        uint64_t v70 = (std::string *)(v71 + 1);
                        int64_t v68 = v69 - (char *)v70;
                      }
                      while (v69 - (char *)v70 > 14);
                    }
                    v71 = v69;
LABEL_165:
                    if (v71 == v69) {
                      std::string::size_type v73 = -1;
                    }
                    else {
                      std::string::size_type v73 = v71 - (char *)v67;
                    }
                    std::string::basic_string(&__dst, &buf, 0, v73, (std::allocator<char> *)&v96);
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_dst = &__dst;
                    }
                    else {
                      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
                    }
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v75 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v75 = __dst.__r_.__value_.__l.__size_;
                    }
                    std::string::append(&v94, (const std::string::value_type *)p_dst, v75);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                    std::string::append(&v94, "pub.", 4uLL);
                    std::string::append(&v94, "3gppnetwork.org", 0xFuLL);
                    goto LABEL_178;
                  }
                  uint64_t v64 = (std::string *)(v65 + 1);
                  uint64_t v63 = v62 - (char *)v64;
                }
                while (v62 - (char *)v64 >= 15);
              }
              std::string::append(&v94, (const std::string::value_type *)v60, v61);
LABEL_178:
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
            break;
          }
          int v58 = v59 + 1;
          int64_t v55 = v57 - (unsigned char *)v58;
        }
        while (v57 - (unsigned char *)v58 >= 1);
      }
      if (*(unsigned char *)(a1 + 208))
      {
        if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v76 = &v94;
        }
        else {
          uint64_t v76 = (std::string *)v94.__r_.__value_.__r.__words[0];
        }
        int64_t v77 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
        if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int64_t v77 = v94.__r_.__value_.__l.__size_;
        }
        if (v77 >= 15)
        {
          uint64_t v78 = (char *)v76 + v77;
          v79 = v76;
          do
          {
            uint64_t v80 = (char *)memchr(v79, 51, v77 - 14);
            if (!v80) {
              break;
            }
            if (*(void *)v80 == 0x7774656E70706733 && *(void *)(v80 + 7) == 0x67726F2E6B726F77)
            {
              if (v80 != v78 && v80 - (char *)v76 != -1) {
                std::string::append(&v95, "ims.", 4uLL);
              }
              break;
            }
            v79 = (std::string *)(v80 + 1);
            int64_t v77 = v78 - (char *)v79;
          }
          while (v78 - (char *)v79 >= 15);
        }
      }
      sub_1002055B4((const void **)&v95.__r_.__value_.__l.__data_, (const void **)&v94.__r_.__value_.__l.__data_, URLString);
      if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v94.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v95.__r_.__value_.__l.__data_);
      }
      goto LABEL_202;
    }
    int v50 = (void **)(a1 + 224);
    if ((*(char *)(a1 + 247) & 0x80000000) == 0)
    {
      *(_OWORD *)URLString = *(_OWORD *)v50;
      uint64_t v48 = *(void *)(a1 + 240);
      goto LABEL_110;
    }
    unint64_t v49 = *(void *)(a1 + 232);
LABEL_120:
    sub_10004FC84(URLString, *v50, v49);
    goto LABEL_202;
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "#E %s%sNo WWW-Authenticate field in header", (uint8_t *)&buf, 0x16u);
  }
  return 0;
}

void sub_1007D7858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,const void *a23,const void *a24,const void *a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,const void *a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (*(char *)(v45 - 153) < 0) {
    operator delete(*(void **)(v45 - 176));
  }
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_1000558F4(&a23);
  sub_1000558F4(&a24);
  sub_1000558F4(&a25);
  sub_1000FE824(&a33);
  _Unwind_Resume(a1);
}

void sub_1007D79D0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sissueAuthRequest", buf, 0x16u);
  }
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 0;
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v35 = 0u;
  sub_10004BD84((uint64_t)&v35);
  long long v56 = 0u;
  memset(v57, 0, sizeof(v57));
  long long v55 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_100EAF54C((uint64_t)buf, *(os_log_t **)(a1 + 64));
  *(void *)std::string __str = "username";
  uint64_t v3 = sub_100A3C118((uint64_t)&buf[16], "username", (uint64_t)&unk_10144E20E, (long long **)__str);
  std::string::operator=((std::string *)(v3 + 40), (const std::string *)(a1 + 104));
  sub_100058DB0(__str, "/");
  std::string::operator=((std::string *)v57, (const std::string *)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  *(void *)std::string __str = "realm";
  uint64_t v4 = sub_100A3C118((uint64_t)&buf[16], "realm", (uint64_t)&unk_10144E20E, (long long **)__str);
  std::string::operator=((std::string *)(v4 + 40), (const std::string *)(a1 + 384));
  sub_100058DB0(__str, "");
  int64_t v53 = "response";
  CFDateRef v5 = sub_100A3C118((uint64_t)&buf[16], "response", (uint64_t)&unk_10144E20E, (long long **)&v53);
  std::string::operator=((std::string *)(v5 + 40), (const std::string *)__str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  memset(__str, 0, sizeof(__str));
  sub_10004DE24((uint64_t)__str);
  sub_100A3AABC((uint64_t)buf, __str, 1);
  sub_10004BC98((uint64_t)&__str[8], &v15);
  if (SHIBYTE(v23) < 0) {
    operator delete(*((void **)&v22 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  sub_1007DCA34((uint64_t)buf);
  *(void *)((char *)&v35
  *(void *)&long long v36 = v6;
  if (SHIBYTE(v41) < 0) {
    operator delete(*((void **)&v40 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  sub_1007D88E0((uint64_t)&v16, (const std::string *)a1, &v15);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  sub_1007D8138(a1, "initial", &v16);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v7 || (v8 = *(void *)(a1 + 8), (OsLogContext v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  std::string::size_type v10 = v9;
  p_shared_weak_owners = &v9->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_1007D8B08;
  v13[3] = &unk_101A0AEE0;
  void v13[4] = a1;
  v13[5] = v8;
  CFStringRef v14 = v10;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  if (!sub_1007D834C(a1, (uint64_t)&v16, (uint64_t)v13))
  {
    uint64_t v12 = *(void *)(a1 + 320);
    memset(buf, 0, 24);
    (*(void (**)(void))(v12 + 16))();
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  std::__shared_weak_count::__release_weak(v10);
  sub_10010C0E0((uint64_t)&v16, v17);
}

void sub_1007D7F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21)
{
  if (SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v21);
  sub_10010C0E0((uint64_t)&a20, (void *)a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D8020(uint64_t a1)
{
  *(void *)a1 = off_101A0AED0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 416);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 407) < 0) {
    operator delete(*(void **)(a1 + 384));
  }
  if (*(char *)(a1 + 383) < 0) {
    operator delete(*(void **)(a1 + 360));
  }
  if (*(char *)(a1 + 351) < 0) {
    operator delete(*(void **)(a1 + 328));
  }
  uint64_t v3 = *(const void **)(a1 + 320);
  if (v3) {
    _Block_release(v3);
  }
  if (*(char *)(a1 + 319) < 0) {
    operator delete(*(void **)(a1 + 296));
  }
  sub_1007DC910(a1 + 88);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 64), 0);
  CFDateRef v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1007D8100(uint64_t a1)
{
  sub_1007D8020(a1);

  operator delete();
}

void sub_1007D8138(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v18 = "";
    __int16 v19 = 2080;
    long long v20 = "";
    __int16 v21 = 2080;
    long long v22 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s--- header '%s'", buf, 0x20u);
  }
  OsLogContext v9 = (void *)*a3;
  uint64_t v7 = a3 + 1;
  uint64_t v8 = v9;
  if (v9 != v7)
  {
    do
    {
      std::string::size_type v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        char v11 = v8 + 4;
        if (*((char *)v8 + 55) < 0) {
          char v11 = (void *)*v11;
        }
        uint64_t v12 = v8 + 7;
        if (*((char *)v8 + 79) < 0) {
          uint64_t v12 = (void *)*v12;
        }
        *(_DWORD *)std::string buf = 136315906;
        uint64_t v18 = "";
        __int16 v19 = 2080;
        long long v20 = "";
        __int16 v21 = 2080;
        long long v22 = v11;
        __int16 v23 = 2080;
        long long v24 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s  %s: %s", buf, 0x2Au);
      }
      std::string::size_type v13 = (void *)v8[1];
      if (v13)
      {
        do
        {
          CFStringRef v14 = v13;
          std::string::size_type v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          CFStringRef v14 = (void *)v8[2];
          BOOL v15 = *v14 == (void)v8;
          uint64_t v8 = v14;
        }
        while (!v15);
      }
      uint64_t v8 = v14;
    }
    while (v14 != v7);
  }
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v18 = "";
    __int16 v19 = 2080;
    long long v20 = "";
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s---;", buf, 0x16u);
  }
}

BOOL sub_1007D834C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDateRef v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________>  Sending GBA Request, trying", buf, 0x16u);
  }
  uint64_t v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004BD84((uint64_t)buf);
  if (*(unsigned char *)(a1 + 220)) {
    uint64_t v6 = "https://";
  }
  else {
    uint64_t v6 = "http://";
  }
  if (*(unsigned char *)(a1 + 220)) {
    uint64_t v7 = 8;
  }
  else {
    uint64_t v7 = 7;
  }
  sub_10004B96C(&buf[16], (uint64_t)v6, v7);
  int v8 = *(char *)(a1 + 407);
  if (v8 >= 0) {
    uint64_t v9 = a1 + 384;
  }
  else {
    uint64_t v9 = *(void *)(a1 + 384);
  }
  if (v8 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 407);
  }
  else {
    uint64_t v10 = *(void *)(a1 + 392);
  }
  sub_10004B96C(&buf[16], v9, v10);
  if (*(_DWORD *)(a1 + 216))
  {
    sub_10004B96C(&buf[16], (uint64_t)":", 1);
    std::ostream::operator<<();
  }
  v26[0] = 0;
  v26[1] = 0;
  uint64_t v27 = 0;
  sub_10004BC98((uint64_t)&buf[24], v26);
  char v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v26;
    if (v27 < 0) {
      uint64_t v12 = (void **)v26[0];
    }
    *(_DWORD *)long long v28 = 136315650;
    *(void *)&v28[4] = "";
    *(_WORD *)&v28[12] = 2080;
    *(void *)&v28[14] = "";
    __int16 v29 = 2080;
    long long v30 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%sbsf url: %s", v28, 0x20u);
  }
  uint64_t v24 = 0;
  long long v25 = 0;
  ctu::Http::HttpRequest::create();
  std::string::size_type v13 = (void *)(a1 + 408);
  long long v14 = *(_OWORD *)v28;
  *(void *)long long v28 = 0;
  *(void *)&v28[8] = 0;
  BOOL v15 = *(std::__shared_weak_count **)(a1 + 416);
  *(_OWORD *)(a1 + 408) = v14;
  if (v15)
  {
    sub_10004D2C8(v15);
    if (*(void *)&v28[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v28[8]);
    }
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v16 = *v13;
  if (*v13)
  {
    (*(void (**)(void, double))(*(void *)v16 + 96))(*v13, 30.0);
    if (*(void *)(a1 + 256)) {
      int v17 = sub_1000810B8;
    }
    else {
      int v17 = 0;
    }
    if (v17)
    {
      (*(void (**)(void))(*(void *)*v13 + 152))();
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 408) + 160))(*(void *)(a1 + 408), a1 + 264);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 408) + 8))(*(void *)(a1 + 408), *(void *)(a1 + 24));
    (*(void (**)(void, uint64_t))(*(void *)*v13 + 16))(*v13, a3);
    uint64_t v18 = *v13;
    __p[1] = 0;
    uint64_t v23 = 0;
    __p[0] = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v18 + 40))(v18, __p);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    __int16 v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v28 = 136315394;
      *(void *)&v28[4] = "";
      *(_WORD *)&v28[12] = 2080;
      *(void *)&v28[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#W %s%sUnable to allocate request", v28, 0x16u);
    }
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[0]);
  }
  *(void *)&uint8_t buf[16] = v20;
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v16 != 0;
}

void sub_1007D887C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10008248C((uint64_t)&a27);
  _Unwind_Resume(a1);
}

void sub_1007D88E0(uint64_t a1, const std::string *a2, const std::string *a3)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_100058DB0(__p, "Host");
  long long v14 = __p;
  uint64_t v6 = sub_10014BECC((uint64_t **)a1, (uint64_t)__p, (uint64_t)&unk_10144E20E, (_OWORD **)&v14);
  std::string::operator=((std::string *)((char *)v6 + 56), a2 + 16);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "User-Agent");
  long long v14 = __p;
  uint64_t v7 = sub_10014BECC((uint64_t **)a1, (uint64_t)__p, (uint64_t)&unk_10144E20E, (_OWORD **)&v14);
  if (*((char *)v7 + 79) < 0)
  {
    *((void *)v7 + 8) = 13;
    int v8 = (char *)*((void *)v7 + 7);
  }
  else
  {
    int v8 = (char *)v7 + 56;
    *((unsigned char *)v7 + 79) = 13;
  }
  strcpy(v8, "3gpp-gba-tmpi");
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "Authorization");
  long long v14 = __p;
  uint64_t v9 = sub_10014BECC((uint64_t **)a1, (uint64_t)__p, (uint64_t)&unk_10144E20E, (_OWORD **)&v14);
  std::string::operator=((std::string *)((char *)v9 + 56), a3);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "Accept");
  long long v14 = __p;
  uint64_t v10 = sub_10014BECC((uint64_t **)a1, (uint64_t)__p, (uint64_t)&unk_10144E20E, (_OWORD **)&v14);
  if (*((char *)v10 + 79) < 0)
  {
    *((void *)v10 + 8) = 3;
    char v11 = (_DWORD *)*((void *)v10 + 7);
  }
  else
  {
    char v11 = (_DWORD *)v10 + 14;
    *((unsigned char *)v10 + 79) = 3;
  }
  *char v11 = 2764586;
  if (v13 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007D8AC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10010C0E0(v15, *(void **)(v15 + 8));
  _Unwind_Resume(a1);
}

void sub_1007D8B08(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[5])
      {
LABEL_50:
        sub_10004D2C8(v7);
        return;
      }
      int v8 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________<  Received GBA Challenge, or timed out", buf, 0x16u);
      }
      if (*a2)
      {
        uint64_t v9 = (ctu::Http *)(*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
        uint64_t v10 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          (*(void (**)(uint8_t *__return_ptr))(*(void *)*a2 + 64))(v37);
          if (v38 >= 0) {
            char v11 = v37;
          }
          else {
            char v11 = *(uint8_t **)v37;
          }
          int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
          (*(void (**)(void))(*(void *)*a2 + 16))();
          ctu::Http::asString();
          if (v30 >= 0) {
            long long v14 = &v29;
          }
          else {
            long long v14 = v29;
          }
          int v26 = (int)v9;
          ctu::Http::asString((uint64_t *)v35, v9, v13);
          int v15 = v12;
          if (v36 >= 0) {
            uint64_t v16 = v35;
          }
          else {
            uint64_t v16 = (void **)v35[0];
          }
          long long v25 = v16;
          int v17 = &v33;
          (*(void (**)(void **__return_ptr))(*(void *)*a2 + 48))(&v33);
          if (v34 < 0) {
            int v17 = v33;
          }
          uint64_t v18 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
          (*(void (**)(void))(*(void *)*a2 + 16))();
          (*(void (**)(void))(*(void *)*a2 + 32))();
          ctu::Http::asString();
          if (v32 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          *(_DWORD *)std::string buf = 136317442;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          long long v40 = v11;
          __int16 v41 = 1024;
          int v42 = v15;
          __int16 v43 = 2080;
          long long v44 = v14;
          __int16 v45 = 1024;
          LODWORD(v9) = v26;
          int v46 = v26;
          __int16 v47 = 2080;
          long long v48 = v25;
          __int16 v49 = 2080;
          long long v50 = v17;
          __int16 v51 = 2048;
          uint64_t v52 = v18;
          __int16 v53 = 2080;
          char v54 = p_p;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sResponse: '%s', Result: %d (%s), Status: '%d' (%s), Response: '%s' ErrorCode: '%ld' (%s)", buf, 0x5Eu);
          if (v32 < 0) {
            operator delete(__p);
          }
          if (v34 < 0) {
            operator delete(v33);
          }
          if (v36 < 0) {
            operator delete(v35[0]);
          }
          if (v30 < 0) {
            operator delete(v29);
          }
          if (v38 < 0) {
            operator delete(*(void **)v37);
          }
        }
        if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))() == 1)
        {
          (*(void (**)(uint8_t *__return_ptr))(*(void *)*a2 + 56))(buf);
          sub_1007D8138(v5, "challenge", buf);
          sub_10010C0E0((uint64_t)buf, *(void **)&buf[8]);
        }
        if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))() == 1 && v9 == 401)
        {
          uint64_t v27 = 0;
          v28[0] = 0;
          v28[1] = 0;
          (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 56))(&v27);
          sub_100058DB0(buf, "WWW-Authenticate");
          uint64_t v20 = (void *)sub_10014C044((uint64_t)&v27, (uint64_t)buf);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          if (v28 != v20)
          {
            sub_100A3B830((uint64_t)(v20 + 7));
            operator new();
          }
          uint64_t v23 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "";
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "#E %s%sNo WWW-Authenticate field in header", buf, 0x16u);
          }
          sub_10010C0E0((uint64_t)&v27, (void *)*v20);
          goto LABEL_48;
        }
        __int16 v21 = *(NSObject **)(v5 + 40);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
LABEL_48:
          uint64_t v24 = *(void *)(v5 + 320);
          memset(buf, 0, sizeof(buf));
          (*(void (**)(void))(v24 + 16))();
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_50;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        long long v22 = "#W %s%sInvalid HTTP reply or code";
      }
      else
      {
        __int16 v21 = *(NSObject **)(v5 + 40);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_48;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "";
        long long v22 = "#I %s%sNo response";
      }
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v22, buf, 0x16u);
      goto LABEL_48;
    }
  }
}

void sub_1007D9894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, std::__shared_weak_count *a12, char a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  sub_1000C937C((uint64_t)&a40);
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v46);
  }
  sub_10004D2C8(v45);
  sub_10004D2C8(v45);
  sub_10004D2C8(v45);
  sub_10010C0E0((uint64_t)&a13, a14);
  sub_10004D2C8(a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1007D9AA4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007D9AC0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1007D9AD0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t sub_1007D9B0C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1007D9B40(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[5])
      {
LABEL_91:
        sub_10004D2C8(v7);
        return;
      }
      int v8 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________<  Received GBA Result, or timed out", (uint8_t *)&buf, 0x16u);
      }
      if (!*a2)
      {
        uint64_t v23 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sNo response", (uint8_t *)&buf, 0x16u);
        }
        goto LABEL_89;
      }
      uint64_t v9 = (ctu::Http *)(*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
      uint64_t v10 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v49 = v7;
        (*(void (**)(std::string *__return_ptr))(*(void *)*a2 + 64))(&__str);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_str = &__str;
        }
        else {
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        int v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
        uint64_t v50 = v5;
        (*(void (**)(void))(*(void *)*a2 + 16))();
        ctu::Http::asString();
        if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v14 = &v63;
        }
        else {
          long long v14 = (std::string *)v63.__r_.__value_.__r.__words[0];
        }
        char v47 = v14;
        int v15 = &v61;
        int v48 = (int)v9;
        ctu::Http::asString((uint64_t *)&v61, v9, v13);
        int v16 = v12;
        if (v62 < 0) {
          int v15 = v61;
        }
        (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 48))(&v59);
        if (v60 >= 0) {
          int v17 = &v59;
        }
        else {
          int v17 = (long long *)v59;
        }
        uint64_t v18 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
        (*(void (**)(void))(*(void *)*a2 + 16))();
        (*(void (**)(void))(*(void *)*a2 + 32))();
        ctu::Http::asString();
        if (v58 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136317442;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        CFIndex v66 = (CFIndex)p_str;
        __int16 v67 = 1024;
        int v68 = v16;
        __int16 v69 = 2080;
        uint64_t v70 = v47;
        __int16 v71 = 1024;
        LODWORD(v9) = v48;
        int v72 = v48;
        __int16 v73 = 2080;
        uint64_t v74 = v15;
        __int16 v75 = 2080;
        uint64_t v76 = v17;
        __int16 v77 = 2048;
        uint64_t v78 = v18;
        __int16 v79 = 2080;
        uint64_t v80 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sResponse: '%s', Result: %d (%s), Status: '%d' (%s), Response: '%s' ErrorCode: '%ld' (%s)", (uint8_t *)&buf, 0x5Eu);
        if (v58 < 0) {
          operator delete(__p);
        }
        uint64_t v7 = v49;
        uint64_t v5 = v50;
        if (v60 < 0) {
          operator delete((void *)v59);
        }
        if (v62 < 0) {
          operator delete(v61);
        }
        if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v63.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
      if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))() == 1)
      {
        (*(void (**)(std::string *__return_ptr))(*(void *)*a2 + 56))(&buf);
        sub_1007D8138(v5, "auth result", &buf);
        sub_10010C0E0((uint64_t)&buf, (void *)buf.__r_.__value_.__l.__size_);
      }
      if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))() != 1 || v9 != 200)
      {
LABEL_89:
        uint64_t v46 = *(void *)(v5 + 320);
        memset(&buf, 0, sizeof(buf));
        (*(void (**)(void))(v46 + 16))();
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        goto LABEL_91;
      }
      uint64_t v20 = (std::__shared_weak_count *)a1[8];
      if (v20) {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(void **__return_ptr))(*(void *)*a2 + 56))(v52);
      (*(void (**)(CFDataRef *__return_ptr))(*(void *)*a2 + 40))(&theData);
      CFDataRef v21 = theData;
      if (theData) {
        CFIndex Length = CFDataGetLength(theData);
      }
      else {
        CFIndex Length = 0;
      }
      uint64_t v24 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
        CFIndex v66 = Length;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%sReceived %zu bytes of data", (uint8_t *)&buf, 0x20u);
      }
      if (!Length)
      {
        int v42 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#W %s%sError with input data", (uint8_t *)&buf, 0x16u);
        }
        goto LABEL_87;
      }
      CFDictionaryRef theDict = 0;
      CFErrorRef err = 0;
      CFDictionaryRef v25 = (const __CFDictionary *)sub_1006EE040((uint64_t)v21, (uint64_t)&err);
      CFDictionaryRef theDict = v25;
      if (err)
      {
        uint64_t v61 = 0;
        uint64_t v61 = (void *)CFErrorCopyDescription(err);
        int v26 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          memset(&__str, 0, sizeof(__str));
          ctu::cf::assign();
          std::string v63 = __str;
          uint64_t v27 = (std::string *)__str.__r_.__value_.__r.__words[0];
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v27 = &v63;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          CFIndex v66 = (CFIndex)v27;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%scopyDictionaryFromXML error: %s", (uint8_t *)&buf, 0x20u);
          if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v63.__r_.__value_.__l.__data_);
          }
        }
        CFRelease(err);
        sub_1000558F4((const void **)&v61);
        CFDictionaryRef v25 = theDict;
      }
      if (v25) {
        long long v28 = sub_100080778;
      }
      else {
        long long v28 = 0;
      }
      if (v28)
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v25, @"BootstrappingInfo");
        char v30 = *(NSObject **)(v5 + 40);
        BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
        if (Value)
        {
          if (v31)
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2112;
            CFIndex v66 = (CFIndex)Value;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s%sDICT: %@", (uint8_t *)&buf, 0x20u);
          }
          CFDictionaryRef v32 = (const __CFDictionary *)CFDictionaryGetValue(Value, @"btid");
          CFDictionaryRef v33 = v32;
          if (v32)
          {
            CFTypeID v34 = CFGetTypeID(v32);
            if (v34 != CFDictionaryGetTypeID()) {
              CFDictionaryRef v33 = 0;
            }
          }
          CFDictionaryRef v35 = (const __CFDictionary *)CFDictionaryGetValue(Value, @"lifetime");
          CFDictionaryRef v36 = v35;
          if (v35)
          {
            CFTypeID v37 = CFGetTypeID(v35);
            if (v37 == CFDictionaryGetTypeID())
            {
              if (v33)
              {
                memset(&v54, 0, sizeof(v54));
                CFDictionaryGetValue(v33, @"text");
                memset(&buf, 0, sizeof(buf));
                ctu::cf::assign();
                std::string v54 = buf;
                memset(&v53, 0, sizeof(v53));
                CFDictionaryGetValue(v36, @"text");
                memset(&buf, 0, sizeof(buf));
                ctu::cf::assign();
                std::string v53 = buf;
                char v38 = *(NSObject **)(v5 + 40);
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  long long v39 = &v54;
                  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    long long v39 = (std::string *)v54.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                  HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                  CFIndex v66 = (CFIndex)v39;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s%sBTID: %s", (uint8_t *)&buf, 0x20u);
                  char v38 = *(NSObject **)(v5 + 40);
                }
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  long long v40 = &v53;
                  if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    long long v40 = (std::string *)v53.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                  WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                  HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                  CFIndex v66 = (CFIndex)v40;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s%sLT:   %s", (uint8_t *)&buf, 0x20u);
                }
                __int16 v41 = (const void *)sub_100A3B830(v5 + 296);
                if (v41) {
                operator new();
                }
              }
            }
          }
          __int16 v43 = *(NSObject **)(v5 + 40);
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_86;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          long long v44 = "#W %s%sNo cfbtid && cfklt in XML reply";
          goto LABEL_82;
        }
        if (v31)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          long long v44 = "#W %s%sNo bootstrap info in XML reply";
          __int16 v45 = v30;
          goto LABEL_85;
        }
      }
      else
      {
        __int16 v43 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          long long v44 = "#W %s%sfailed to parse XML (dict) reply";
LABEL_82:
          __int16 v45 = v43;
LABEL_85:
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v44, (uint8_t *)&buf, 0x16u);
        }
      }
LABEL_86:
      sub_100057D78((const void **)&theDict);
LABEL_87:
      sub_100030068((const void **)&theData);
      sub_10010C0E0((uint64_t)v52, (void *)v52[1]);
      if (v20) {
        sub_10004D2C8(v20);
      }
      goto LABEL_89;
    }
  }
}

void sub_1007DBCC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, const void *a14, __int16 a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,const void *a40)
{
  __cxa_guard_abort(&qword_101B0D960);
  sub_10004D2C8(a10);
  if (__p)
  {
    a22 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a24)
  {
    a25 = (uint64_t)a24;
    operator delete(a24);
  }
  sub_10004D2C8(a10);
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  sub_100057D78(&a40);
  sub_100030068(&a14);
  sub_10010C0E0((uint64_t)&a15, (void *)a16);
  if (v40) {
    sub_10004D2C8(v40);
  }
  sub_10004D2C8(a12);
  _Unwind_Resume(a1);
}

void *sub_1007DC19C(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007DC1D0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1007DC220(uint64_t a1, uint64_t a2, std::string *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D968, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D968))
  {
    sub_100058DB0(qword_101B0D9A0, "3GPP-bootstrapping-uicc@");
    __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B0D9A0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0D968);
  }
  uint64_t v27 = 0;
  long long v28 = 0;
  unint64_t v29 = 0;
  memset(&__p, 0, sizeof(__p));
  std::string::size_type v6 = std::string::find(this, 59, 0);
  if (v6 == -1)
  {
    std::string::size_type v8 = 0;
  }
  else
  {
    std::string::size_type v7 = v6;
    std::string::size_type v8 = 0;
    do
    {
      std::string::basic_string(&__str, this, v8, v7 - v8, (std::allocator<char> *)&v30);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      std::string __p = __str;
      uint64_t v9 = v28;
      if ((unint64_t)v28 >= v29)
      {
        char v11 = (unsigned char *)sub_100048008((uint64_t *)&v27, (long long *)&__p);
      }
      else
      {
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(v28, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else
        {
          long long v10 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *((void *)v28 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
          _OWORD *v9 = v10;
        }
        char v11 = (char *)v9 + 24;
      }
      long long v28 = v11;
      std::string::size_type v8 = v7 + 1;
      std::string::size_type v7 = std::string::find(this, 59, v7 + 1);
    }
    while (v7 != -1);
  }
  std::string::basic_string(&__str, this, v8, ~v8, (std::allocator<char> *)&v30);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = __str;
  int v12 = v28;
  if ((unint64_t)v28 >= v29)
  {
    long long v14 = (unsigned char *)sub_100048008((uint64_t *)&v27, (long long *)&__p);
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(v28, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      long long v13 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v28 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
      *int v12 = v13;
    }
    long long v14 = (char *)v12 + 24;
  }
  long long v28 = v14;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  uint64_t v15 = (uint64_t)v27;
  if (v27 != v14)
  {
    while (1)
    {
      memset(&__str, 0, sizeof(__str));
      if (*(char *)(v15 + 23) < 0)
      {
        sub_10004FC84(&__str, *(void **)v15, *(void *)(v15 + 8));
      }
      else
      {
        long long v16 = *(_OWORD *)v15;
        __str.__r_.__value_.__r.__words[2] = *(void *)(v15 + 16);
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        size_t v18 = __str.__r_.__value_.__l.__size_ >= 0x13 ? 19 : __str.__r_.__value_.__l.__size_;
      }
      else
      {
        size_t v18 = HIBYTE(__str.__r_.__value_.__r.__words[2]) >= 0x13u ? 19 : HIBYTE(__str.__r_.__value_.__r.__words[2]);
        p_str = &__str;
      }
      int v20 = memcmp(p_str, "3GPP-bootstrapping@", v18);
      if (v18 >= 0x13 && v20 == 0) {
        break;
      }
      if (v17 < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      v15 += 24;
      if ((unsigned char *)v15 == v14) {
        goto LABEL_45;
      }
    }
    std::string::operator=((std::string *)a1, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
LABEL_45:
  uint64_t v22 = *(unsigned __int8 *)(a1 + 23);
  if ((v22 & 0x80u) != 0) {
    uint64_t v22 = *(void *)(a1 + 8);
  }
  if (!v22)
  {
    sub_1002055B4((const void **)"3GPP-bootstrapping@", (const void **)(a2 + 328), &__str);
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(std::string *)a1 = __str;
  }
  uint64_t v23 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v24 = this;
    }
    else {
      uint64_t v24 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    LODWORD(__str.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    HIWORD(__str.__r_.__value_.__r.__words[2]) = 2080;
    CFDictionaryRef v32 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sRealm from NAF Response: %s", (uint8_t *)&__str, 0x20u);
    uint64_t v23 = *(NSObject **)(a2 + 40);
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 23) >= 0) {
      CFDictionaryRef v25 = (std::string *)a1;
    }
    else {
      CFDictionaryRef v25 = *(std::string **)a1;
    }
    LODWORD(__str.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    HIWORD(__str.__r_.__value_.__r.__words[2]) = 2080;
    CFDictionaryRef v32 = v25;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sMatching Realm: %s", (uint8_t *)&__str, 0x20u);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
  sub_100047F64((void ***)&__str);
}

void sub_1007DC674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
}

uint64_t sub_1007DC70C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v5;
  }
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  sub_1000302C0((char *)(a1 + 40), *(long long **)(a2 + 40), *(long long **)(a2 + 48), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3));
  sub_1000593FC(a1 + 64, (long long *)(a2 + 64));
  if (*(char *)(a2 + 119) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 96), *(void **)(a2 + 96), *(void *)(a2 + 104));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)(a1 + 96) = v6;
  }
  uint64_t v7 = *(void *)(a2 + 120);
  *(void *)(a1 + 125) = *(void *)(a2 + 125);
  *(void *)(a1 + 120) = v7;
  sub_1000593FC(a1 + 136, (long long *)(a2 + 136));
  sub_100083DA4((const void **)(a1 + 168), (const void **)(a2 + 168));
  std::string::size_type v8 = (unsigned char *)(a1 + 176);
  if (*(char *)(a2 + 199) < 0)
  {
    sub_10004FC84(v8, *(void **)(a2 + 176), *(void *)(a2 + 184));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 176);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *(_OWORD *)std::string::size_type v8 = v9;
  }
  *(_WORD *)(a1 + 200) = *(_WORD *)(a2 + 200);
  return a1;
}

void sub_1007DC86C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4(v7);
  if (*(unsigned char *)(v2 + 160) && *(char *)(v2 + 159) < 0) {
    operator delete(*v6);
  }
  if (*(char *)(v2 + 119) < 0) {
    operator delete(*v5);
  }
  if (*(unsigned char *)(v2 + 88) && *(char *)(v2 + 87) < 0) {
    operator delete(*v4);
  }
  sub_100047F64((void ***)va);
  if (*(char *)(v2 + 39) < 0) {
    operator delete(*v3);
  }
  long long v9 = *(std::__shared_weak_count **)(v2 + 8);
  if (v9) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007DC910(uint64_t a1)
{
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  sub_1000558F4((const void **)(a1 + 168));
  if (*(unsigned char *)(a1 + 160) && *(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v4 = (void **)(a1 + 40);
  sub_100047F64(&v4);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

char *sub_1007DC9C0(char *result, char *a2, char *a3, size_t __sz)
{
  if (__sz)
  {
    long long v6 = result;
    __n128 result = sub_10005C9F8(result, __sz);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      char v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1007DCA18(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007DCA34(uint64_t a1)
{
  *(void *)a1 = off_101A678B0;
  uint64_t v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(void *)(a1 + 304) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 272);
  if (v3)
  {
    *(void *)(a1 + 280) = v3;
    operator delete(v3);
  }
  *(void *)a1 = off_101A650A8;
  long long v5 = (void **)(a1 + 168);
  sub_100047F64(&v5);
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  long long v5 = (void **)(a1 + 88);
  sub_100047F64(&v5);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  *(void *)a1 = off_101A2EB80;
  sub_100343DF4(a1 + 16);
  return a1;
}

char *sub_1007DCB2C(char **a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  long long v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v6 = a5;
  uint64_t v7 = __src;
  long long v10 = a1[1];
  long long v9 = a1[2];
  if (v9 - v10 >= a5)
  {
    uint64_t v17 = v10 - __dst;
    if (v10 - __dst >= a5)
    {
      size_t v18 = &__src[a5];
      int v20 = a1[1];
    }
    else
    {
      size_t v18 = &__src[v17];
      if (&__src[v17] == a4)
      {
        int v20 = a1[1];
      }
      else
      {
        int64_t v19 = __src - __dst;
        int v20 = a1[1];
        CFDataRef v21 = v20;
        do
          *v21++ = (v20++)[v19];
        while (&v20[v19] != a4);
      }
      a1[1] = v20;
      if (v17 < 1) {
        return v5;
      }
    }
    CFDictionaryRef v32 = &__dst[a5];
    CFDictionaryRef v33 = &v20[-a5];
    CFTypeID v34 = v20;
    if (&v20[-a5] < v10)
    {
      uint64_t v35 = &v10[a5] - v20;
      CFTypeID v34 = v20;
      do
      {
        char v36 = *v33++;
        *v34++ = v36;
        --v35;
      }
      while (v35);
    }
    a1[1] = v34;
    if (v20 != v32) {
      memmove(&__dst[a5], __dst, v20 - v32);
    }
    if (v18 != v7) {
      memmove(v5, v7, v18 - v7);
    }
  }
  else
  {
    char v11 = *a1;
    uint64_t v12 = v10 - *a1 + a5;
    if (v12 < 0) {
      sub_10006A748();
    }
    long long v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15) {
      long long v16 = operator new(v15);
    }
    else {
      long long v16 = 0;
    }
    uint64_t v22 = &v13[(void)v16];
    uint64_t v23 = &v13[(void)v16 + v6];
    uint64_t v24 = v22;
    do
    {
      char v25 = *v7++;
      *v24++ = v25;
      --v6;
    }
    while (v6);
    int v26 = *a1;
    if (*a1 == v5)
    {
      long long v28 = v22;
    }
    else
    {
      uint64_t v27 = v5;
      long long v28 = v22;
      do
      {
        char v29 = *--v27;
        *--long long v28 = v29;
      }
      while (v27 != v26);
      long long v10 = a1[1];
    }
    char v30 = (char *)v16 + v15;
    if (v10 != v5) {
      memmove(v23, v5, v10 - v5);
    }
    BOOL v31 = *a1;
    *a1 = v28;
    a1[1] = &v23[v10 - v5];
    a1[2] = v30;
    if (v31) {
      operator delete(v31);
    }
    return v22;
  }
  return v5;
}

void sub_1007DCD24(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007DCDF0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1007DCEC8);
  __cxa_rethrow();
}

void sub_1007DCE18(_Unwind_Exception *a1)
{
}

void sub_1007DCE30(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1007DCE68(uint64_t a1)
{
}

uint64_t sub_1007DCE84(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007DCEC8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1007DCEF8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007DCF30(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1007DCF60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1007DCFA4(void *a1)
{
  *a1 = off_101A0B0C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1007DCFFC(void *a1)
{
  *a1 = off_101A0B0C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1007DD074(void *a1)
{
  uint64_t result = operator new(0x30uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A0B0C0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  result[5] = a1[5];
  return result;
}

void *sub_1007DD0F0(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A0B0C0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  a2[5] = result[5];
  return result;
}

void sub_1007DD148(uint64_t a1)
{
}

void sub_1007DD150(void *a1)
{
  sub_1007DD410((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1007DD18C(void *a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = (void *)a2[1];
  uint64_t v12 = (void **)*a2;
  long long v13 = v4;
  uint64_t v14 = a2[2];
  if (v14)
  {
    int v4[2] = &v13;
    *a2 = v3;
    *uint64_t v3 = 0;
    a2[2] = 0;
  }
  else
  {
    uint64_t v12 = &v13;
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    uint64_t v6 = a1[5];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = a1[1];
      if (v8)
      {
        uint64_t v15 = v6;
        uint64_t v16 = v8;
        long long v9 = (std::__shared_weak_count *)a1[2];
        uint64_t v17 = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        size_t v18 = v12;
        v19[0] = v13;
        v19[1] = v14;
        if (v14)
        {
          v13[2] = v19;
          uint64_t v12 = &v13;
          long long v13 = 0;
          uint64_t v14 = 0;
        }
        else
        {
          size_t v18 = v19;
        }
        uint64_t v10 = a1[4];
        v19[2] = a1[3];
        v19[3] = v10;
        if (v10) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        }
        char v11 = *(std::__shared_weak_count **)(v6 + 16);
        if (v11)
        {
          if (std::__shared_weak_count::lock(v11)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10026CF54((uint64_t)&v12, v13);
}

uint64_t sub_1007DD3C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007DD404()
{
}

void sub_1007DD410(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_1007DD460(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v50 = a1;
  uint64_t v51 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(const std::string **)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!*(void *)(v1 + 8))
      {
LABEL_89:
        sub_10004D2C8(v5);
        goto LABEL_90;
      }
      sub_10026E7F8((uint64_t *)&v52, v1 + 24);
      uint64_t v7 = *(void *)(v1 + 48);
      uint64_t v6 = *(std::__shared_weak_count **)(v1 + 56);
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v8 = v53[0];
      if (!v53[0]) {
        goto LABEL_82;
      }
      long long v9 = (int *)v53;
      uint64_t v10 = (int *)v53[0];
      do
      {
        char v11 = v10;
        uint64_t v12 = v9;
        int v13 = v10[8];
        if (v13 >= 5) {
          long long v9 = v10;
        }
        else {
          v10 += 2;
        }
        uint64_t v10 = *(int **)v10;
      }
      while (v10);
      if (v9 == (int *)v53) {
        goto LABEL_82;
      }
      if (v13 < 5) {
        char v11 = v12;
      }
      if (v11[8] > 5) {
        goto LABEL_82;
      }
      uint64_t v14 = (int *)v53;
      uint64_t v15 = (int *)v53[0];
      do
      {
        uint64_t v16 = v15;
        uint64_t v17 = v14;
        int v18 = v15[8];
        if (v18 >= 6) {
          uint64_t v14 = v15;
        }
        else {
          v15 += 2;
        }
        uint64_t v15 = *(int **)v15;
      }
      while (v15);
      if (v14 == (int *)v53) {
        goto LABEL_82;
      }
      if (v18 < 6) {
        uint64_t v16 = v17;
      }
      if (v16[8] > 6) {
        goto LABEL_82;
      }
      int64_t v19 = (int *)v53;
      do
      {
        int v20 = v8;
        CFDataRef v21 = v19;
        int v22 = *((_DWORD *)v8 + 8);
        uint64_t v23 = v8 + 1;
        if (v22 >= 7)
        {
          uint64_t v23 = v20;
          int64_t v19 = (int *)v20;
        }
        uint64_t v8 = (void *)*v23;
      }
      while (v8);
      if (v19 == (int *)v53 || (v22 >= 7 ? (uint64_t v24 = (int *)v20) : (uint64_t v24 = v21), v24[8] > 7))
      {
LABEL_82:
        int v42 = v3[1].__r_.__value_.__r.__words[2];
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %s%sGBA EAP-AKA failed", buf, 0x16u);
        }
      }
      else
      {
        char v25 = v3[1].__r_.__value_.__r.__words[2];
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%sGBA EAP-AKA succeed", buf, 0x16u);
        }
        std::string v63 = 0;
        uint64_t v64 = 0;
        uint64_t v65 = 0;
        LODWORD(v66.__r_.__value_.__l.__data_) = 5;
        *(void *)std::string buf = &v66;
        int v26 = sub_10008CC40(&v52, (int *)&v66, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
        uint64_t v64 = 0;
        uint64_t v65 = 0;
        std::string v63 = 0;
        sub_10005C928(&v63, v26[5], (uint64_t)v26[6], (char *)v26[6] - (char *)v26[5]);
        char v60 = 0;
        uint64_t v61 = 0;
        uint64_t v62 = 0;
        LODWORD(v66.__r_.__value_.__l.__data_) = 6;
        *(void *)std::string buf = &v66;
        uint64_t v27 = sub_10008CC40(&v52, (int *)&v66, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
        uint64_t v61 = 0;
        uint64_t v62 = 0;
        char v60 = 0;
        sub_10005C928(&v60, v27[5], (uint64_t)v27[6], (char *)v27[6] - (char *)v27[5]);
        int v57 = 0;
        char v58 = 0;
        uint64_t v59 = 0;
        LODWORD(v66.__r_.__value_.__l.__data_) = 7;
        *(void *)std::string buf = &v66;
        long long v28 = sub_10008CC40(&v52, (int *)&v66, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
        char v58 = 0;
        uint64_t v59 = 0;
        int v57 = 0;
        sub_10005C928(&v57, v28[5], (uint64_t)v28[6], (char *)v28[6] - (char *)v28[5]);
        char v29 = v3[1].__r_.__value_.__r.__words[2];
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          ctu::hex();
          if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v46 = &v66;
          }
          else {
            uint64_t v46 = (std::string *)v66.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v46;
          _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "#D %s%sprocessEAPAKAresult, res: %s", buf, 0x20u);
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          char v29 = v3[1].__r_.__value_.__r.__words[2];
        }
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          ctu::hex();
          if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v47 = &v66;
          }
          else {
            char v47 = (std::string *)v66.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v47;
          _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "#D %s%sprocessEAPAKAresult, ck:  %s", buf, 0x20u);
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          char v29 = v3[1].__r_.__value_.__r.__words[2];
        }
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          ctu::hex();
          int v48 = (v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v66
              : (std::string *)v66.__r_.__value_.__r.__words[0];
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&uint8_t buf[24] = v48;
          _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "#D %s%sprocessEAPAKAresult, ik:  %s", buf, 0x20u);
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
        }
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100EB0148((char **)v7, (char **)&v63);
        if ((unint64_t)(v58 - (unsigned char *)v57) >= 0x10)
        {
          *(_OWORD *)(v7 + 254) = *(_OWORD *)v57;
          *(unsigned char *)(v7 + 324) = 1;
        }
        if ((unint64_t)(v61 - (unsigned char *)v60) >= 0x10)
        {
          *(_OWORD *)(v7 + 238) = *(_OWORD *)v60;
          *(unsigned char *)(v7 + 323) = 1;
        }
        sub_100058DB0(buf, "GET");
        sub_100058DB0(&v66, "/");
        sub_100058DB0(&__p, "");
        int v30 = (*(uint64_t (**)(uint64_t, uint8_t *, std::string *, void **))(*(void *)v7 + 128))(v7, buf, &v66, &__p);
        if (SHIBYTE(v56) < 0) {
          operator delete(__p);
        }
        if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v66.__r_.__value_.__l.__data_);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        if (v30)
        {
          uint64_t v88 = 0;
          long long v86 = 0u;
          long long v87 = 0u;
          long long v84 = 0u;
          long long v85 = 0u;
          long long v82 = 0u;
          long long v83 = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          *(_OWORD *)uint64_t v76 = 0u;
          long long v77 = 0u;
          long long v74 = 0u;
          long long v75 = 0u;
          memset(buf, 0, sizeof(buf));
          sub_10004DE24((uint64_t)buf);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v7 + 64))(v7, buf);
          BOOL v31 = v3[1].__r_.__value_.__r.__words[2];
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            sub_10004BC98((uint64_t)&buf[8], &__p);
            CFDictionaryRef v32 = v56 >= 0 ? &__p : (void **)__p;
            LODWORD(v66.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)v66.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
            WORD2(v66.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v66.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
            HIWORD(v66.__r_.__value_.__r.__words[2]) = 2080;
            __int16 v67 = v32;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%sprocessEAPAKAresult, [%s]", (uint8_t *)&v66, 0x20u);
            if (SHIBYTE(v56) < 0) {
              operator delete(__p);
            }
          }
          if (SHIBYTE(v77) < 0) {
            operator delete(v76[1]);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          std::ios::~ios();
          uint64_t v88 = 0;
          long long v86 = 0u;
          long long v87 = 0u;
          long long v84 = 0u;
          long long v85 = 0u;
          long long v82 = 0u;
          long long v83 = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          *(_OWORD *)uint64_t v76 = 0u;
          long long v77 = 0u;
          long long v74 = 0u;
          long long v75 = 0u;
          memset(buf, 0, sizeof(buf));
          sub_10004DE24((uint64_t)buf);
          (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v7 + 56))(v7, buf, 1);
          std::string __p = 0;
          long long v55 = 0;
          uint64_t v56 = 0;
          sub_10004BC98((uint64_t)&buf[8], &v66);
          sub_1007D88E0((uint64_t)&__p, v3, &v66);
          uint64_t v49 = v33;
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          uint64_t v35 = v34;
          sub_1007D8138((uint64_t)v3, "challenge response", &__p);
          char v36 = (std::__shared_weak_count *)v3->__r_.__value_.__r.__words[2];
          if (!v36 || (size = v3->__r_.__value_.__l.__size_, (char v38 = std::__shared_weak_count::lock(v36)) == 0)) {
            sub_100088B9C();
          }
          long long v39 = v38;
          p_shared_weak_owners = &v38->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v38);
          v66.__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
          v66.__r_.__value_.__l.__size_ = 1174405120;
          v66.__r_.__value_.__r.__words[2] = (std::string::size_type)sub_1007D9B40;
          __int16 v67 = (void **)&unk_101A0AF10;
          int v68 = v3;
          std::string::size_type v69 = size;
          uint64_t v70 = v39;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          uint64_t v71 = v7;
          int v72 = v6;
          if (v6) {
            atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          BOOL v41 = sub_1007D834C((uint64_t)v3, (uint64_t)&__p, (uint64_t)&v66);
          if (v72) {
            sub_10004D2C8(v72);
          }
          if (v70) {
            std::__shared_weak_count::__release_weak(v70);
          }
          std::__shared_weak_count::__release_weak(v39);
          sub_10010C0E0((uint64_t)&__p, v55);
          *(void *)std::string buf = v49;
          *(void *)&buf[*(void *)(v49 - 24)] = v35;
          if (SHIBYTE(v77) < 0) {
            operator delete(v76[1]);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          std::ios::~ios();
          if (v6) {
            sub_10004D2C8(v6);
          }
          if (v57)
          {
            char v58 = v57;
            operator delete(v57);
          }
          if (v60)
          {
            uint64_t v61 = v60;
            operator delete(v60);
          }
          if (v63)
          {
            uint64_t v64 = v63;
            operator delete(v63);
          }
          if (v41) {
            goto LABEL_86;
          }
        }
        else
        {
          __int16 v45 = v3[1].__r_.__value_.__r.__words[2];
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&buf[12] = 2080;
            *(void *)&buf[14] = "";
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I %s%sfailed to compile response", buf, 0x16u);
          }
          if (v6) {
            sub_10004D2C8(v6);
          }
          if (v57)
          {
            char v58 = v57;
            operator delete(v57);
          }
          if (v60)
          {
            uint64_t v61 = v60;
            operator delete(v60);
          }
          if (v63)
          {
            uint64_t v64 = v63;
            operator delete(v63);
          }
        }
      }
      std::string::size_type v43 = v3[13].__r_.__value_.__l.__size_;
      memset(buf, 0, 24);
      (*(void (**)(void))(v43 + 16))();
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
LABEL_86:
      if (v6) {
        sub_10004D2C8(v6);
      }
      sub_10026CF54((uint64_t)&v52, v53[0]);
      goto LABEL_89;
    }
  }
LABEL_90:
  sub_1007DE100(&v51);
  return sub_100046B58((uint64_t *)&v50);
}

void sub_1007DDF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,std::__shared_weak_count *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  sub_1000C937C((uint64_t)&a47);
  if (v53) {
    sub_10004D2C8(v53);
  }
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a27)
  {
    a28 = (uint64_t)a27;
    operator delete(a27);
  }
  if (a30)
  {
    a31 = (uint64_t)a30;
    operator delete(a30);
  }
  if (v53) {
    sub_10004D2C8(v53);
  }
  sub_10026CF54((uint64_t)&a13, a16);
  sub_10004D2C8(v52);
  sub_1007DE100(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_1007DE100(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 56);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_10026CF54(v1 + 24, *(void **)(v1 + 32));
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

void sub_1007DE170(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007DE1A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1007DE1D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1007DE21C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 16), *(Registry **)a2);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v5, kCtLoggingSystemName, "cb.bun");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), &v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v5);
  *(_OWORD *)(a1 + 149) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 168) = 0x200000002;
  *(void *)(a1 + 176) = 0;
  return a1;
}

void sub_1007DE2D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  char v11 = *(std::__shared_weak_count **)(v9 + 24);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(v9 + 8);
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007DE310(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(Registry **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    uint64_t v4 = *(Registry **)a1;
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 16), v4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 32), (const ctu::OsLogLogger *)(a2 + 32));
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v6;
  }
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v7;
  }
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 88), *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = v8;
  }
  if (*(char *)(a2 + 135) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 112), *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 112);
    *(void *)(a1 + 128) = *(void *)(a2 + 128);
    *(_OWORD *)(a1 + 112) = v9;
  }
  uint64_t v10 = (unsigned char *)(a1 + 136);
  if (*(char *)(a2 + 159) < 0)
  {
    sub_10004FC84(v10, *(void **)(a2 + 136), *(void *)(a2 + 144));
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 136);
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(_OWORD *)uint64_t v10 = v11;
  }
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(unsigned char *)(a1 + 164) = *(unsigned char *)(a2 + 164);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  *(_DWORD *)(a1 + 172) = *(_DWORD *)(a2 + 172);
  sub_100083DA4((const void **)(a1 + 176), (const void **)(a2 + 176));
  return a1;
}

void sub_1007DE49C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 135) < 0) {
    operator delete(*v6);
  }
  if (*(char *)(v1 + 111) < 0) {
    operator delete(*v5);
  }
  if (*(char *)(v1 + 87) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v3);
  }
  ctu::OsLogLogger::~OsLogLogger(v2);
  long long v8 = *(std::__shared_weak_count **)(v1 + 24);
  if (v8) {
    sub_10004D2C8(v8);
  }
  long long v9 = *(std::__shared_weak_count **)(v1 + 8);
  if (v9) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007DE538(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)(a1 + 40), (const std::string *)(a2 + 40));
  std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 64));
  std::string::operator=((std::string *)(a1 + 88), (const std::string *)(a2 + 88));
  std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 112));
  std::string::operator=((std::string *)(a1 + 136), (const std::string *)(a2 + 136));
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(unsigned char *)(a1 + 164) = *(unsigned char *)(a2 + 164);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  *(_DWORD *)(a1 + 172) = *(_DWORD *)(a2 + 172);
  sub_100083EB8((const void **)(a1 + 176), (const void **)(a2 + 176));
  return a1;
}

uint64_t sub_1007DE5C8(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 176));
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

std::string *sub_1007DE664(uint64_t a1, const std::string *a2, const std::string *a3)
{
  std::string::operator=((std::string *)(a1 + 88), a2);
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 16) + 144))(&v20);
  uint64_t v5 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)uint64_t v5 = v20;
  *(void *)(a1 + 56) = v21;
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 16) + 136))(&v20);
  long long v6 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)long long v6 = v20;
  *(void *)(a1 + 80) = v21;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  long long v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v20 = v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v20);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_13:
  if (*(char *)(a1 + 63) < 0) {
    uint64_t v5 = (void **)*v5;
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v15 + 40))(v15, v5);
  uint64_t v18 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = v17;
  *(void *)&long long v20 = v18;
  sub_1000558F4((const void **)&v20);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  return std::string::operator=((std::string *)(a1 + 112), a3);
}

void sub_1007DE858(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_1007DE874(uint64_t a1, std::string *__str)
{
  if (*(char *)(a1 + 111) < 0)
  {
    *(void *)(a1 + 96) = 0;
    uint64_t v3 = *(unsigned char **)(a1 + 88);
  }
  else
  {
    uint64_t v3 = (unsigned char *)(a1 + 88);
    *(unsigned char *)(a1 + 111) = 0;
  }
  *uint64_t v3 = 0;
  std::string::operator=((std::string *)(a1 + 40), __str);
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 16) + 136))(&v6);
  uint64_t v4 = (void **)(a1 + 64);
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*v4);
  }
  double result = *(double *)&v6;
  *(_OWORD *)uint64_t v4 = v6;
  *(void *)(a1 + 80) = v7;
  return result;
}

void sub_1007DE920(uint64_t a1, os_log_t *a2, int a3, int a4)
{
  v90[0] = 0;
  v90[1] = 0;
  uint64_t v91 = 0;
  uint64_t v110 = 0;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v99 = 0u;
  long long v97 = 0u;
  *(_OWORD *)v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v94 = 0u;
  sub_10004DE24((uint64_t)&v94);
  uint64_t v7 = sub_10004B96C(&v94, (uint64_t)"----------Bundle File----------", 31);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(void *)(*v7 - 24)));
  long long v8 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale((std::locale *)&v111);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v9 = sub_10004B96C(&v94, (uint64_t)"Matched path         : ", 23);
  int v10 = *(char *)(a1 + 63);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 40;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 40);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 48);
  }
  int v13 = sub_10004B96C(v9, v11, v12);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
  uint64_t v14 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale((std::locale *)&v111);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v15 = sub_10004B96C(&v94, (uint64_t)"Resolved path        : ", 23);
  int v16 = *(char *)(a1 + 87);
  if (v16 >= 0) {
    uint64_t v17 = a1 + 64;
  }
  else {
    uint64_t v17 = *(void *)(a1 + 64);
  }
  if (v16 >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    uint64_t v18 = *(void *)(a1 + 72);
  }
  int64_t v19 = sub_10004B96C(v15, v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24)));
  long long v20 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale((std::locale *)&v111);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v21 = sub_10004B96C(&v94, (uint64_t)"Carrier plist        : ", 23);
  int v22 = *(char *)(a1 + 159);
  if (v22 >= 0) {
    uint64_t v23 = a1 + 136;
  }
  else {
    uint64_t v23 = *(void *)(a1 + 136);
  }
  if (v22 >= 0) {
    uint64_t v24 = *(unsigned __int8 *)(a1 + 159);
  }
  else {
    uint64_t v24 = *(void *)(a1 + 144);
  }
  char v25 = sub_10004B96C(v21, v23, v24);
  std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24)));
  int v26 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
  std::locale::~locale((std::locale *)&v111);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v27 = sub_10004B96C(&v94, (uint64_t)"Overridden           : ", 23);
  long long v28 = sub_100DBA340(*(_DWORD *)(a1 + 160));
  size_t v29 = strlen(v28);
  int v30 = sub_10004B96C(v27, (uint64_t)v28, v29);
  std::ios_base::getloc((const std::ios_base *)((char *)v30 + *(void *)(*v30 - 24)));
  BOOL v31 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10);
  std::locale::~locale((std::locale *)&v111);
  std::ostream::put();
  std::ostream::flush();
  CFDictionaryRef v32 = sub_10004B96C(&v94, (uint64_t)"Bundle Tech Type     : ", 23);
  uint64_t v33 = (const char *)asString();
  size_t v34 = strlen(v33);
  uint64_t v35 = sub_10004B96C(v32, (uint64_t)v33, v34);
  std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(*v35 - 24)));
  char v36 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 10);
  std::locale::~locale((std::locale *)&v111);
  std::ostream::put();
  std::ostream::flush();
  if (!a3)
  {
    CFTypeID v37 = sub_10004B96C(&v94, (uint64_t)"Bundle Version          : ", 26);
    long long v111 = 0uLL;
    uint64_t v112 = 0;
    ctu::cf::assign();
    unint64_t v93 = v112;
    *(_OWORD *)std::string __p = v111;
    if (v112 >= 0) {
      char v38 = __p;
    }
    else {
      char v38 = (void **)__p[0];
    }
    if ((v93 & 0x8000000000000000) == 0) {
      long long v39 = (void *)HIBYTE(v93);
    }
    else {
      long long v39 = __p[1];
    }
    long long v40 = sub_10004B96C(v37, (uint64_t)v38, (uint64_t)v39);
    std::ios_base::getloc((const std::ios_base *)((char *)v40 + *(void *)(*v40 - 24)));
    BOOL v41 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10);
    std::locale::~locale((std::locale *)&v111);
    std::ostream::put();
    std::ostream::flush();
    if (SHIBYTE(v93) < 0) {
      operator delete(__p[0]);
    }
    int v42 = sub_10004B96C(&v94, (uint64_t)"Linking Path            : ", 26);
    int v43 = *(char *)(a1 + 111);
    if (v43 >= 0) {
      uint64_t v44 = a1 + 88;
    }
    else {
      uint64_t v44 = *(void *)(a1 + 88);
    }
    if (v43 >= 0) {
      uint64_t v45 = *(unsigned __int8 *)(a1 + 111);
    }
    else {
      uint64_t v45 = *(void *)(a1 + 96);
    }
    uint64_t v46 = sub_10004B96C(v42, v44, v45);
    std::ios_base::getloc((const std::ios_base *)((char *)v46 + *(void *)(*v46 - 24)));
    char v47 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10);
    std::locale::~locale((std::locale *)&v111);
    std::ostream::put();
    std::ostream::flush();
    int v48 = sub_10004B96C(&v94, (uint64_t)"Preferences file        : ", 26);
    int v49 = *(char *)(a1 + 135);
    if (v49 >= 0) {
      uint64_t v50 = a1 + 112;
    }
    else {
      uint64_t v50 = *(void *)(a1 + 112);
    }
    if (v49 >= 0) {
      uint64_t v51 = *(unsigned __int8 *)(a1 + 135);
    }
    else {
      uint64_t v51 = *(void *)(a1 + 120);
    }
    uint64_t v52 = sub_10004B96C(v48, v50, v51);
    std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(void *)(*v52 - 24)));
    std::string v53 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10);
    std::locale::~locale((std::locale *)&v111);
    std::ostream::put();
    std::ostream::flush();
    std::string v54 = sub_10004B96C(&v94, (uint64_t)"Verification Skipped    : ", 26);
    int v55 = *(_DWORD *)(a1 + 168);
    uint64_t v56 = "No";
    if (v55) {
      uint64_t v56 = "Don't know";
    }
    if (v55 == 1) {
      int v57 = "Yes";
    }
    else {
      int v57 = v56;
    }
    size_t v58 = strlen(v57);
    uint64_t v59 = sub_10004B96C(v54, (uint64_t)v57, v58);
    std::ios_base::getloc((const std::ios_base *)((char *)v59 + *(void *)(*v59 - 24)));
    char v60 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v60->__vftable[2].~facet_0)(v60, 10);
    std::locale::~locale((std::locale *)&v111);
    std::ostream::put();
    std::ostream::flush();
    uint64_t v61 = sub_10004B96C(&v94, (uint64_t)"Verification Result     : ", 26);
    int v62 = *(_DWORD *)(a1 + 172);
    std::string v63 = "Failed";
    if (v62) {
      std::string v63 = "Don't know";
    }
    if (v62 == 1) {
      uint64_t v64 = "Success";
    }
    else {
      uint64_t v64 = v63;
    }
    size_t v65 = strlen(v64);
    std::string v66 = sub_10004B96C(v61, (uint64_t)v64, v65);
    std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24)));
    __int16 v67 = std::locale::use_facet((const std::locale *)&v111, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10);
    std::locale::~locale((std::locale *)&v111);
    std::ostream::put();
    std::ostream::flush();
  }
  sub_10004B96C(&v94, (uint64_t)"----------Bundle File----------", 31);
  sub_10004BC98((uint64_t)&v94 + 8, v90);
  if (SHIBYTE(v99) < 0) {
    operator delete(v98[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  long long v94 = 0uLL;
  *(void *)&long long v95 = 0;
  ctu::tokenize();
  std::string::size_type v69 = (char *)*((void *)&v94 + 1);
  for (uint64_t i = (char *)v94; i != v69; i += 24)
  {
    if (a4)
    {
      uint64_t v70 = i[23];
      if (i[23] < 0)
      {
        uint64_t v71 = *(char **)i;
        uint64_t v72 = *((void *)i + 1);
      }
      else
      {
        uint64_t v71 = i;
        uint64_t v72 = i[23];
      }
      if (v72 >= 12)
      {
        __int16 v73 = &v71[v72];
        long long v74 = v71;
        do
        {
          long long v75 = (char *)memchr(v74, 77, v72 - 11);
          if (!v75) {
            break;
          }
          if (*(void *)v75 == 0x206465686374614DLL && *((_DWORD *)v75 + 2) == 1752457584)
          {
            if (v75 == v73 || v75 - v71 == -1) {
              break;
            }
LABEL_83:
            os_log_t v83 = *a2;
            if (!os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_92;
            }
            long long v84 = i;
            if ((v70 & 0x80) != 0) {
              long long v84 = *(char **)i;
            }
            LODWORD(v111) = 136315138;
            *(void *)((char *)&v111 + 4) = v84;
            long long v85 = v83;
            long long v86 = "#I %s";
            goto LABEL_91;
          }
          long long v74 = v75 + 1;
          uint64_t v72 = v73 - (unsigned char *)v74;
        }
        while (v73 - (unsigned char *)v74 >= 12);
      }
      if ((v70 & 0x80) != 0)
      {
        long long v77 = *(char **)i;
        uint64_t v78 = *((void *)i + 1);
      }
      else
      {
        long long v77 = i;
        uint64_t v78 = v70;
      }
      if (v78 >= 13)
      {
        long long v79 = &v77[v78];
        long long v80 = v77;
        do
        {
          long long v81 = (char *)memchr(v80, 67, v78 - 12);
          if (!v81) {
            break;
          }
          if (*(void *)v81 == 0x2072656972726143 && *(void *)(v81 + 5) == 0x7473696C70207265)
          {
            if (v81 == v79 || v81 - v77 == -1) {
              break;
            }
            goto LABEL_83;
          }
          long long v80 = v81 + 1;
          uint64_t v78 = v79 - (unsigned char *)v80;
        }
        while (v79 - (unsigned char *)v80 >= 13);
      }
      os_log_t v87 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v88 = i;
        if ((v70 & 0x80) != 0) {
          uint64_t v88 = *(char **)i;
        }
        LODWORD(v111) = 136446210;
        *(void *)((char *)&v111 + 4) = v88;
        long long v85 = v87;
        long long v86 = "#I %{public}s";
LABEL_91:
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, v86, (uint8_t *)&v111, 0xCu);
      }
    }
LABEL_92:
    ;
  }
  *(void *)&long long v111 = &v94;
  sub_100047F64((void ***)&v111);
  if (SHIBYTE(v91) < 0) {
    operator delete(v90[0]);
  }
}

void sub_1007DF534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27)
{
  if (*(char *)(v27 - 105) < 0) {
    operator delete(*(void **)(v27 - 128));
  }
  sub_1000C937C((uint64_t)&a27);
  _Unwind_Resume(a1);
}

double sub_1007DF5E4@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*(char *)(a1 + 63) < 0)
  {
    if (!*(void *)(a1 + 48)) {
      return result;
    }
  }
  else if (!*(unsigned char *)(a1 + 63))
  {
    return result;
  }
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 16) + 120))(&v4);
  double result = *(double *)&v4;
  *(_OWORD *)a2 = v4;
  a2[2] = v5;
  return result;
}

void sub_1007DF670(uint64_t a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = (void *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    uint64_t v14 = (void *)*v14;
  }
  *a2 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 40))(v12, v14);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1007DF794(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007DF7B0(uint64_t a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = (void *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    uint64_t v14 = (void *)*v14;
  }
  *a2 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 24))(v12, v14);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1007DF8D4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007DF8F0(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
  {
    if (*(void *)(a1 + 48)) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!*(unsigned char *)(a1 + 63)) {
    return 0;
  }
LABEL_3:
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v12 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 16) + 120))(v11);
  if (SHIBYTE(v12) < 0)
  {
    sub_10004FC84(v8, v11[0], (unint64_t)v11[1]);
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)v11;
    uint64_t v9 = v12;
  }
  if (SHIBYTE(v9) < 0)
  {
    sub_10004FC84(__p, v8[0], (unint64_t)v8[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v8;
    uint64_t v15 = v9;
  }
  CFStringRef v13 = 0;
  if (SHIBYTE(v15) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    uint64_t v17 = v15;
  }
  CFStringRef v18 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v3 = v13;
    CFStringRef v13 = v18;
    CFStringRef v19 = v3;
    sub_1000558F4((const void **)&v19);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(*(void **)buf);
  }
  CFStringRef v4 = v13;
  CFStringRef v10 = v13;
  CFStringRef v13 = 0;
  sub_1000558F4((const void **)&v13);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[0]);
  }
  v20.length = CFStringGetLength(@"Unknown.bundle");
  v20.location = 0;
  int v5 = CFStringFindWithOptions(@"Unknown.bundle", v4, v20, 9uLL, 0);
  BOOL v2 = v5 != 0;
  if (v5)
  {
    unint64_t v6 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Detected Unknown bundle", buf, 2u);
    }
  }
  sub_1000558F4((const void **)&v10);
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  return v2;
}

void sub_1007DFB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007DFB84(uint64_t a1)
{
  CFTypeRef cf1 = 0;
  sub_1007DF7B0(a1, &cf1);
  if (cf1) {
    BOOL v2 = sub_1000810B8;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2 && CFEqual(cf1, @"com.apple.Unknown"))
  {
    uint64_t v3 = 1;
  }
  else
  {
    CFStringRef v4 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "The bundle identifer for this Unknown bundle is not correct. Looks like the bundle is compromised. Fail verification of this bundle.", v6, 2u);
    }
    uint64_t v3 = 0;
  }
  sub_1000558F4(&cf1);
  return v3;
}

void sub_1007DFC40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1007DFC54(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
  {
    if (*(void *)(a1 + 48))
    {
LABEL_3:
      __s1 = 0;
      size_t __n = 0;
      uint64_t v20 = 0;
      (*(void (**)(void **__return_ptr))(**(void **)(a1 + 16) + 120))(&__s1);
      sub_1000292E0((uint64_t)__p);
      char v1 = HIBYTE(v20);
      if (v20 >= 0) {
        size_t v2 = HIBYTE(v20);
      }
      else {
        size_t v2 = __n;
      }
      unint64_t v3 = v17;
      int v4 = (char)v17;
      if ((v17 & 0x80u) != 0) {
        unint64_t v3 = (unint64_t)__p[1];
      }
      if (v2 != v3)
      {
        BOOL v14 = 0;
        if (((char)v17 & 0x80000000) == 0) {
          goto LABEL_27;
        }
        goto LABEL_30;
      }
      if ((v17 & 0x80u) == 0) {
        int v5 = __p;
      }
      else {
        int v5 = (void **)__p[0];
      }
      if (SHIBYTE(v20) < 0)
      {
        BOOL v14 = memcmp(__s1, v5, __n) == 0;
      }
      else
      {
        if (!HIBYTE(v20))
        {
          BOOL v14 = 1;
          if (((char)v17 & 0x80000000) == 0)
          {
LABEL_27:
            if ((v1 & 0x80) == 0) {
              return v14;
            }
LABEL_31:
            operator delete(__s1);
            return v14;
          }
LABEL_30:
          operator delete(__p[0]);
          if ((v20 & 0x8000000000000000) == 0) {
            return v14;
          }
          goto LABEL_31;
        }
        uint64_t v6 = HIBYTE(v20) - 1;
        p_s1 = &__s1;
        do
        {
          int v9 = *(unsigned __int8 *)p_s1;
          p_s1 = (void **)((char *)p_s1 + 1);
          int v8 = v9;
          int v11 = *(unsigned __int8 *)v5;
          int v5 = (void **)((char *)v5 + 1);
          int v10 = v11;
          BOOL v13 = v6-- != 0;
          BOOL v14 = v8 == v10;
        }
        while (v8 == v10 && v13);
      }
      if ((v4 & 0x80000000) == 0) {
        goto LABEL_27;
      }
      goto LABEL_30;
    }
  }
  else if (*(unsigned char *)(a1 + 63))
  {
    goto LABEL_3;
  }
  return 0;
}

void sub_1007DFDA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007DFDC4(uint64_t a1)
{
  CFTypeRef cf1 = 0;
  sub_1007DF7B0(a1, &cf1);
  if (cf1) {
    size_t v2 = sub_1000810B8;
  }
  else {
    size_t v2 = 0;
  }
  if (v2 && CFEqual(cf1, @"com.apple.Default"))
  {
    uint64_t v3 = 1;
  }
  else
  {
    int v4 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "The bundle identifer for default bundle is not correct. Looks like the bundle is compromised. Fail verification of this bundle.", v6, 2u);
    }
    uint64_t v3 = 0;
  }
  sub_1000558F4(&cf1);
  return v3;
}

void sub_1007DFE80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1007DFE94(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0)
  {
    if (*(void *)(a1 + 72)) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!*(unsigned char *)(a1 + 87)) {
    return 0;
  }
LABEL_3:
  __s1 = 0;
  size_t __n = 0;
  uint64_t v28 = 0;
  uint64_t v2 = a1 + 16;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 16) + 128))(&__s1);
  std::string __p = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)v2 + 136))(&__p);
  char v3 = HIBYTE(v28);
  if (v28 >= 0) {
    size_t v4 = HIBYTE(v28);
  }
  else {
    size_t v4 = __n;
  }
  uint64_t v5 = HIBYTE(v25);
  int v6 = SHIBYTE(v25);
  if (v25 < 0) {
    uint64_t v5 = v24;
  }
  if (v4 == v5)
  {
    if (v25 >= 0) {
      p_p = (unsigned __int8 *)&__p;
    }
    else {
      p_p = (unsigned __int8 *)__p;
    }
    if (v28 < 0)
    {
      BOOL v16 = memcmp(__s1, p_p, __n) == 0;
    }
    else if (HIBYTE(v28))
    {
      uint64_t v8 = HIBYTE(v28) - 1;
      p_s1 = &__s1;
      do
      {
        int v11 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        int v10 = v11;
        int v13 = *p_p++;
        int v12 = v13;
        BOOL v15 = v8-- != 0;
        BOOL v16 = v10 == v12;
      }
      while (v10 == v12 && v15);
    }
    else
    {
      BOOL v16 = 1;
    }
  }
  else
  {
    BOOL v16 = 0;
  }
  unsigned __int8 v17 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v18 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      CFStringRef v18 = (void *)*v18;
    }
    CFStringRef v19 = " not";
    if (v16) {
      CFStringRef v19 = "";
    }
    *(_DWORD *)std::string buf = 136315906;
    int v30 = v18;
    uint64_t v20 = &__p;
    if (v6 < 0) {
      uint64_t v20 = __p;
    }
    __int16 v31 = 2080;
    CFDictionaryRef v32 = v19;
    uint64_t v21 = &__s1;
    if (v3 < 0) {
      uint64_t v21 = __s1;
    }
    __int16 v33 = 2080;
    size_t v34 = v20;
    __int16 v35 = 2080;
    char v36 = v21;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s is%s within %s, its parentDir is %s", buf, 0x2Au);
    LOBYTE(v6) = HIBYTE(v25);
  }
  if ((v6 & 0x80) != 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(__s1);
  }
  return v16;
}

void sub_1007E00F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007E011C(uint64_t a1, const std::string *a2, std::string *a3)
{
  uint64_t v5 = (void *)(a1 + 88);
  std::string::operator=((std::string *)(a1 + 88), a2);
  std::string::operator=((std::string *)(a1 + 112), a3);
  uint64_t v99 = 0;
  long long v100 = 0;
  Registry::getMobileHelper(&v99, *(Registry **)a1);
  uint64_t v6 = v99;
  if (!v99) {
    goto LABEL_175;
  }
  uint64_t v7 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v5;
    if (*(char *)(a1 + 111) < 0) {
      uint64_t v8 = (void *)*v5;
    }
    int v9 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      int v9 = (void *)*v9;
    }
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Establishing bundle %{public}s. Symlink points to %s", buf, 0x16u);
    uint64_t v6 = v99;
  }
  int v10 = (void *)(a1 + 40);
  int v11 = (void *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    int v11 = (void *)*v10;
  }
  int v12 = v5;
  if (*(char *)(a1 + 111) < 0) {
    int v12 = (void *)*v5;
  }
  if (((*(uint64_t (**)(uint64_t, void *, void *, void))(*(void *)v6 + 128))(v6, v11, v12, 0) & 1) == 0)
  {
    uint64_t v21 = *(NSObject **)(a1 + 32);
    uint64_t v6 = 0;
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_175;
    }
    int v22 = v5;
    if (*(char *)(a1 + 111) < 0) {
      int v22 = (void *)*v5;
    }
    if (*(char *)(a1 + 63) < 0) {
      int v10 = (void *)*v10;
    }
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 16) + 144))(__p);
    if (v102 >= 0) {
      uint64_t v23 = __p;
    }
    else {
      uint64_t v23 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136446722;
    *(void *)&uint8_t buf[4] = v22;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v10;
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v104 = v23;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N %{public}s does not link to %s, instead it links to %s", buf, 0x20u);
    if ((SHIBYTE(v102) & 0x80000000) == 0) {
      goto LABEL_167;
    }
    uint64_t v24 = __p[0];
LABEL_166:
    operator delete(v24);
LABEL_167:
    uint64_t v6 = 0;
    goto LABEL_175;
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  uint64_t v102 = *(void *)&buf[16];
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) == 0) {
    BOOL v14 = a3;
  }
  else {
    BOOL v14 = (std::string *)a3->__r_.__value_.__r.__words[0];
  }
  int v15 = SHIBYTE(v102);
  BOOL v16 = __p[0];
  if (v102 >= 0) {
    unsigned __int8 v17 = __p;
  }
  else {
    unsigned __int8 v17 = (void **)__p[0];
  }
  if (v102 >= 0) {
    int64_t v18 = HIBYTE(v102);
  }
  else {
    int64_t v18 = (int64_t)__p[1];
  }
  if (!v18)
  {
    uint64_t v25 = 0;
    if ((SHIBYTE(v102) & 0x80000000) == 0) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  if ((size & 0x80u) != 0) {
    uint64_t size = a3->__r_.__value_.__l.__size_;
  }
  CFStringRef v19 = (char *)v14 + size;
  if (size >= v18)
  {
    int v26 = *(char *)v17;
    uint64_t v27 = v14;
    do
    {
      uint64_t v28 = size - v18;
      if (v28 == -1) {
        break;
      }
      size_t v29 = (char *)memchr(v27, v26, v28 + 1);
      if (!v29) {
        break;
      }
      uint64_t v20 = v29;
      if (!memcmp(v29, v17, v18)) {
        goto LABEL_45;
      }
      uint64_t v27 = (std::string *)(v20 + 1);
      uint64_t size = v19 - (v20 + 1);
    }
    while (size >= v18);
    uint64_t v20 = v19;
LABEL_45:
    int v10 = (void *)(a1 + 40);
  }
  else
  {
    uint64_t v20 = (char *)v14 + size;
  }
  if (v20 == v19) {
    uint64_t v25 = -1;
  }
  else {
    uint64_t v25 = v20 - (char *)v14;
  }
  if (v15 < 0) {
LABEL_50:
  }
    operator delete(v16);
LABEL_51:
  if (v25 != -1) {
    goto LABEL_129;
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  uint64_t v102 = *(void *)&buf[16];
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v30 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if ((v30 & 0x80u) == 0) {
    __int16 v31 = a3;
  }
  else {
    __int16 v31 = (std::string *)a3->__r_.__value_.__r.__words[0];
  }
  int v32 = SHIBYTE(v102);
  __int16 v33 = __p[0];
  if (v102 >= 0) {
    size_t v34 = __p;
  }
  else {
    size_t v34 = (void **)__p[0];
  }
  if (v102 >= 0) {
    int64_t v35 = HIBYTE(v102);
  }
  else {
    int64_t v35 = (int64_t)__p[1];
  }
  if (v35)
  {
    if ((v30 & 0x80u) != 0) {
      uint64_t v30 = a3->__r_.__value_.__l.__size_;
    }
    char v36 = (char *)v31 + v30;
    if (v30 >= v35)
    {
      long long v95 = v10;
      int v39 = *(char *)v34;
      long long v40 = v31;
      do
      {
        uint64_t v41 = v30 - v35;
        if (v41 == -1) {
          break;
        }
        int v42 = (char *)memchr(v40, v39, v41 + 1);
        if (!v42) {
          break;
        }
        CFTypeID v37 = v42;
        if (!memcmp(v42, v34, v35)) {
          goto LABEL_74;
        }
        long long v40 = (std::string *)(v37 + 1);
        uint64_t v30 = v36 - (v37 + 1);
      }
      while (v30 >= v35);
      CFTypeID v37 = v36;
LABEL_74:
      int v10 = v95;
    }
    else
    {
      CFTypeID v37 = (char *)v31 + v30;
    }
    if (v37 == v36) {
      uint64_t v38 = -1;
    }
    else {
      uint64_t v38 = v37 - (char *)v31;
    }
    if ((v32 & 0x80000000) == 0) {
      goto LABEL_80;
    }
  }
  else
  {
    uint64_t v38 = 0;
    if ((SHIBYTE(v102) & 0x80000000) == 0) {
      goto LABEL_80;
    }
  }
  operator delete(v33);
LABEL_80:
  if (v38 == -1)
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v102 = *(void *)&buf[16];
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v43 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    if ((v43 & 0x80u) == 0) {
      uint64_t v44 = a3;
    }
    else {
      uint64_t v44 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }
    int v45 = SHIBYTE(v102);
    uint64_t v46 = __p[0];
    if (v102 >= 0) {
      char v47 = __p;
    }
    else {
      char v47 = (void **)__p[0];
    }
    if (v102 >= 0) {
      int64_t v48 = HIBYTE(v102);
    }
    else {
      int64_t v48 = (int64_t)__p[1];
    }
    if (v48)
    {
      if ((v43 & 0x80u) != 0) {
        uint64_t v43 = a3->__r_.__value_.__l.__size_;
      }
      int v49 = (char *)v44 + v43;
      if (v43 >= v48)
      {
        long long v96 = v10;
        int v52 = *(char *)v47;
        std::string v53 = v44;
        do
        {
          uint64_t v54 = v43 - v48;
          if (v54 == -1) {
            break;
          }
          int v55 = (char *)memchr(v53, v52, v54 + 1);
          if (!v55) {
            break;
          }
          uint64_t v50 = v55;
          if (!memcmp(v55, v47, v48)) {
            goto LABEL_102;
          }
          std::string v53 = (std::string *)(v50 + 1);
          uint64_t v43 = v49 - (v50 + 1);
        }
        while (v43 >= v48);
        uint64_t v50 = v49;
LABEL_102:
        int v10 = v96;
      }
      else
      {
        uint64_t v50 = (char *)v44 + v43;
      }
      if (v50 == v49) {
        uint64_t v51 = -1;
      }
      else {
        uint64_t v51 = v50 - (char *)v44;
      }
    }
    else
    {
      uint64_t v51 = 0;
    }
    if (v45 < 0) {
      operator delete(v46);
    }
    if (v51 == -1)
    {
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v102 = *(void *)&buf[16];
      uint64_t v56 = sub_1007E0D5C(a3, (char *)__p);
      if (SHIBYTE(v102) < 0) {
        operator delete(__p[0]);
      }
      if (v56 == -1)
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v102 = *(void *)&buf[16];
        uint64_t v57 = sub_1007E0D5C(a3, (char *)__p);
        if (SHIBYTE(v102) < 0) {
          operator delete(__p[0]);
        }
        if (v57 == -1)
        {
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v102 = *(void *)&buf[16];
          uint64_t v58 = sub_1007E0D5C(a3, (char *)__p);
          if (SHIBYTE(v102) < 0) {
            operator delete(__p[0]);
          }
          if (v58 == -1)
          {
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            *(_OWORD *)std::string __p = *(_OWORD *)buf;
            uint64_t v102 = *(void *)&buf[16];
            uint64_t v59 = sub_1007E0D5C(a3, (char *)__p);
            if (SHIBYTE(v102) < 0) {
              operator delete(__p[0]);
            }
            if (v59 == -1)
            {
              memset(buf, 0, sizeof(buf));
              ctu::cf::assign();
              *(_OWORD *)std::string __p = *(_OWORD *)buf;
              uint64_t v102 = *(void *)&buf[16];
              uint64_t v60 = sub_1007E0D5C(a3, (char *)__p);
              if (SHIBYTE(v102) < 0) {
                operator delete(__p[0]);
              }
              if (v60 == -1)
              {
                memset(buf, 0, sizeof(buf));
                ctu::cf::assign();
                *(_OWORD *)std::string __p = *(_OWORD *)buf;
                uint64_t v102 = *(void *)&buf[16];
                uint64_t v61 = sub_1007E0D5C(a3, (char *)__p);
                if (SHIBYTE(v102) < 0) {
                  operator delete(__p[0]);
                }
                if (v61 == -1)
                {
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  *(_OWORD *)std::string __p = *(_OWORD *)buf;
                  uint64_t v102 = *(void *)&buf[16];
                  sub_1007E0D5C(a3, (char *)__p);
                  if (SHIBYTE(v102) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_129:
  int v62 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
  {
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v63 = a3;
    }
    else {
      std::string v63 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }
    uint64_t v64 = (void *)(a1 + 136);
    if (*(char *)(a1 + 159) < 0) {
      uint64_t v64 = (void *)*v64;
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v102 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long v97 = *(_OWORD *)__p;
    uint64_t v98 = v102;
    size_t v65 = (void **)__p[0];
    if (v102 >= 0) {
      size_t v65 = v97;
    }
    *(_DWORD *)std::string buf = 136446722;
    *(void *)&uint8_t buf[4] = v63;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v64;
    *(_WORD *)&unsigned char buf[22] = 2082;
    long long v104 = v65;
    _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I Establishing pref %{public}s. Symlink points to %s with domain: %{public}s", buf, 0x20u);
    if (SHIBYTE(v98) < 0) {
      operator delete(v97[0]);
    }
  }
  std::string v66 = (void *)(a1 + 136);
  __int16 v67 = (void *)(a1 + 136);
  if (*(char *)(a1 + 159) < 0) {
    __int16 v67 = (void *)*v66;
  }
  uint64_t v68 = v99;
  int v69 = SHIBYTE(a3->__r_.__value_.__r.__words[2]);
  uint64_t v70 = (char *)a3->__r_.__value_.__r.__words[0];
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  if (v69 >= 0) {
    uint64_t v71 = (char *)a3;
  }
  else {
    uint64_t v71 = v70;
  }
  *(_OWORD *)std::string __p = *(_OWORD *)buf;
  uint64_t v102 = *(void *)&buf[16];
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v72 = __p;
  }
  else {
    uint64_t v72 = *(void ***)buf;
  }
  char v73 = (*(uint64_t (**)(uint64_t, void *, char *, void **))(*(void *)v68 + 128))(v68, v67, v71, v72);
  char v74 = v73;
  if ((SHIBYTE(v102) & 0x80000000) == 0)
  {
    if (v73) {
      goto LABEL_149;
    }
    goto LABEL_156;
  }
  operator delete(__p[0]);
  if ((v74 & 1) == 0)
  {
LABEL_156:
    long long v86 = *(NSObject **)(a1 + 32);
    uint64_t v6 = 0;
    if (!os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_175;
    }
    if (*(char *)(a1 + 159) < 0) {
      std::string v66 = (void *)*v66;
    }
    int v87 = SHIBYTE(a3->__r_.__value_.__r.__words[2]);
    uint64_t v88 = (char *)a3->__r_.__value_.__r.__words[0];
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v102 = 0;
    ctu::cf::assign();
    if (v87 >= 0) {
      CFStringRef v89 = a3;
    }
    else {
      CFStringRef v89 = (std::string *)v88;
    }
    *(_OWORD *)long long v97 = *(_OWORD *)__p;
    uint64_t v98 = v102;
    CFStringRef v90 = v97;
    if (v102 < 0) {
      CFStringRef v90 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v66;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v89;
    *(_WORD *)&unsigned char buf[22] = 2082;
    long long v104 = v90;
    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#N Problem linking preference file %s: to %{public}s. Domain: %{public}s", buf, 0x20u);
    if ((SHIBYTE(v98) & 0x80000000) == 0) {
      goto LABEL_167;
    }
    uint64_t v24 = v97[0];
    goto LABEL_166;
  }
LABEL_149:
  uint64_t v75 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  *(void *)std::string buf = v75;
  sub_1000558F4((const void **)buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  long long v77 = ServiceMap;
  if (v78 < 0)
  {
    long long v79 = (unsigned __int8 *)(v78 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v80 = 5381;
    do
    {
      uint64_t v78 = v80;
      unsigned int v81 = *v79++;
      uint64_t v80 = (33 * v80) ^ v81;
    }
    while (v81);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v78;
  long long v82 = sub_10004D37C(&v77[1].__m_.__sig, (unint64_t *)buf);
  if (!v82)
  {
    uint64_t v84 = 0;
    goto LABEL_169;
  }
  uint64_t v84 = v82[3];
  os_log_t v83 = (std::__shared_weak_count *)v82[4];
  if (!v83)
  {
LABEL_169:
    std::mutex::unlock(v77);
    os_log_t v83 = 0;
    char v85 = 1;
    goto LABEL_170;
  }
  atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v77);
  atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v83);
  char v85 = 0;
LABEL_170:
  if (*(char *)(a1 + 63) < 0) {
    int v10 = (void *)*v10;
  }
  uint64_t v91 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v84 + 40))(v84, v10);
  uint64_t v92 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = v91;
  *(void *)std::string buf = v92;
  sub_1000558F4((const void **)buf);
  if ((v85 & 1) == 0) {
    sub_10004D2C8(v83);
  }
  uint64_t v6 = 1;
LABEL_175:
  unint64_t v93 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I Dump state of the bundle being linked", buf, 2u);
  }
  sub_1007DE920(a1, (os_log_t *)(a1 + 32), 0, 1);
  if (v100) {
    sub_10004D2C8(v100);
  }
  return v6;
}

void sub_1007E0C90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007E0D5C(void *__s, char *a2)
{
  uint64_t v2 = __s;
  if (*((char *)__s + 23) < 0)
  {
    uint64_t v2 = (void *)*__s;
    uint64_t v3 = __s[1];
  }
  else
  {
    uint64_t v3 = *((unsigned __int8 *)__s + 23);
  }
  int v4 = a2[23];
  if (v4 >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *(char **)a2;
  }
  if (v4 >= 0) {
    int64_t v6 = a2[23];
  }
  else {
    int64_t v6 = *((void *)a2 + 1);
  }
  if (!v6) {
    return 0;
  }
  uint64_t v7 = (char *)v2 + v3;
  if (v3 >= v6)
  {
    int v10 = *v5;
    int v11 = v2;
    do
    {
      uint64_t v12 = v3 - v6;
      if (v12 == -1) {
        break;
      }
      int v13 = (char *)memchr(v11, v10, v12 + 1);
      if (!v13) {
        break;
      }
      uint64_t v8 = v13;
      if (!memcmp(v13, v5, v6)) {
        goto LABEL_13;
      }
      int v11 = v8 + 1;
      uint64_t v3 = v7 - (v8 + 1);
    }
    while (v3 >= v6);
  }
  uint64_t v8 = v7;
LABEL_13:
  if (v8 == v7) {
    return -1;
  }
  else {
    return v8 - (char *)v2;
  }
}

BOOL sub_1007E0E28(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = 0;
  __int16 v31 = 0;
  Registry::getMobileHelper(&v30, *(Registry **)a1);
  if (!v30)
  {
    LOBYTE(v4) = *(unsigned char *)(a1 + 111);
    if ((v4 & 0x80) == 0) {
      goto LABEL_5;
    }
    goto LABEL_7;
  }
  int v4 = *(char *)(a1 + 111);
  if (v4 < 0)
  {
    if (!*(void *)(a1 + 96))
    {
LABEL_4:
      if ((v4 & 0x80) == 0)
      {
LABEL_5:
        uint64_t v5 = v4;
LABEL_8:
        BOOL v6 = v5 == 0;
        goto LABEL_71;
      }
LABEL_7:
      uint64_t v5 = *(void *)(a1 + 96);
      goto LABEL_8;
    }
  }
  else if (!*(unsigned char *)(a1 + 111))
  {
    goto LABEL_4;
  }
  uint64_t v7 = (const char *)(a1 + 88);
  uint64_t v8 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = (char *)(a1 + 88);
    if (v4 < 0) {
      int v9 = *(char **)v7;
    }
    int v10 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      int v10 = (void *)*v10;
    }
    buf.st_dev = 136446466;
    *(void *)&buf.st_mode = v9;
    WORD2(buf.st_ino) = 2080;
    *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Removing bundle %{public}s. Symlink is %s", (uint8_t *)&buf, 0x16u);
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 16) + 208))(*(void *)(a1 + 16), a1 + 88))
  {
    int v11 = (char *)(a1 + 88);
    if (*(char *)(a1 + 111) < 0) {
      int v11 = *(char **)v7;
    }
    uint64_t v12 = v30;
    sub_100058DB0(&buf, v11);
    int v13 = (*(uint64_t (**)(uint64_t, stat *, uint64_t))(*(void *)v12 + 120))(v12, &buf, a2);
    int v14 = v13;
    if (SHIBYTE(buf.st_gid) < 0)
    {
      operator delete(*(void **)&buf.st_dev);
      if (!v14)
      {
LABEL_56:
        BOOL v6 = 0;
        goto LABEL_71;
      }
    }
    else if (!v13)
    {
      goto LABEL_56;
    }
  }
  else
  {
    int v15 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v16 = (char *)(a1 + 88);
      if (*(char *)(a1 + 111) < 0) {
        BOOL v16 = *(char **)v7;
      }
      buf.st_dev = 136446210;
      *(void *)&buf.st_mode = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Bundle %{public}s does not exist, nothing to delete", (uint8_t *)&buf, 0xCu);
    }
  }
  unsigned __int8 v17 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int64_t v18 = (void *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      int64_t v18 = (void *)*v18;
    }
    CFStringRef v19 = (void *)(a1 + 136);
    if (*(char *)(a1 + 159) < 0) {
      CFStringRef v19 = (void *)*v19;
    }
    buf.st_dev = 136446466;
    *(void *)&buf.st_mode = v18;
    WORD2(buf.st_ino) = 2080;
    *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = (__darwin_ino64_t)v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Removing pref file %{public}s. Symlink is %s", (uint8_t *)&buf, 0x16u);
  }
  uint64_t v20 = (const char *)(a1 + 112);
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 16) + 208))(*(void *)(a1 + 16), a1 + 112))
  {
    uint64_t v21 = (char *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      uint64_t v21 = *(char **)v20;
    }
    uint64_t v22 = v30;
    sub_100058DB0(&buf, v21);
    int v23 = (*(uint64_t (**)(uint64_t, stat *, uint64_t))(*(void *)v22 + 120))(v22, &buf, a2);
    if (SHIBYTE(buf.st_gid) < 0) {
      operator delete(*(void **)&buf.st_dev);
    }
  }
  else
  {
    uint64_t v24 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = (char *)(a1 + 112);
      if (*(char *)(a1 + 135) < 0) {
        uint64_t v25 = *(char **)v20;
      }
      buf.st_dev = 136446210;
      *(void *)&buf.st_mode = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Pref file %{public}s does not exist, nothing to delete", (uint8_t *)&buf, 0xCu);
    }
    int v23 = 1;
  }
  memset(&buf, 0, sizeof(buf));
  if (*(char *)(a1 + 111) < 0) {
    uint64_t v7 = *(const char **)v7;
  }
  if (!lstat(v7, &buf)) {
    goto LABEL_56;
  }
  if (*(char *)(a1 + 135) < 0) {
    uint64_t v20 = *(const char **)v20;
  }
  int v26 = lstat(v20, &buf) ? v23 : 0;
  if (v26 != 1) {
    goto LABEL_56;
  }
  uint64_t v27 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v32 = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Resetting bundle object", v32, 2u);
  }
  if (*(char *)(a1 + 63) < 0)
  {
    **(unsigned char **)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 40) = 0;
    *(unsigned char *)(a1 + 63) = 0;
  }
  if (*(char *)(a1 + 87) < 0)
  {
    **(unsigned char **)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 64) = 0;
    *(unsigned char *)(a1 + 87) = 0;
  }
  if (*(char *)(a1 + 111) < 0)
  {
    **(unsigned char **)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 88) = 0;
    *(unsigned char *)(a1 + 111) = 0;
  }
  if (*(char *)(a1 + 135) < 0)
  {
    **(unsigned char **)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 112) = 0;
    *(unsigned char *)(a1 + 135) = 0;
  }
  if (*(char *)(a1 + 159) < 0)
  {
    **(unsigned char **)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 136) = 0;
    *(unsigned char *)(a1 + 159) = 0;
  }
  *(_DWORD *)(a1 + 160) = 0;
  uint64_t v28 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  *(void *)int v32 = v28;
  sub_1000558F4((const void **)v32);
  *(void *)(a1 + 168) = 0x200000002;
  BOOL v6 = 1;
LABEL_71:
  if (v31) {
    sub_10004D2C8(v31);
  }
  return v6;
}

void sub_1007E132C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007E1374(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    buf.st_dev = 136446210;
    *(void *)&buf.st_mode = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Attempting to remove the bundle %{public}s from the system", (uint8_t *)&buf, 0xCu);
  }
  memset(&buf, 0, 24);
  BOOL v4 = sub_1007E0E28(a1, (uint64_t)&buf);
  BOOL v5 = v4;
  if ((SHIBYTE(buf.st_gid) & 0x80000000) == 0)
  {
    if (v4) {
      goto LABEL_7;
    }
    return 0;
  }
  operator delete(*(void **)&buf.st_dev);
  if (!v5) {
    return 0;
  }
LABEL_7:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v7 = (void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v52 = 0;
  uint64_t v8 = (const void **)(a1 + 64);
  (*(void (**)(void **__return_ptr))(*(void *)v6 + 128))(__p);
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  Registry::getMobileHelper(&v49, *(Registry **)a1);
  memset(&buf, 0, sizeof(buf));
  if (!v49)
  {
LABEL_10:
    if (*(char *)(a1 + 63) < 0)
    {
      **(unsigned char **)(a1 + 40) = 0;
      *(void *)(a1 + 48) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 40) = 0;
      *(unsigned char *)(a1 + 63) = 0;
    }
    if (*(char *)(a1 + 87) < 0)
    {
      **(unsigned char **)(a1 + 64) = 0;
      *(void *)(a1 + 72) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 64) = 0;
      *(unsigned char *)(a1 + 87) = 0;
    }
    uint64_t v9 = 1;
    goto LABEL_19;
  }
  uint64_t v46 = (uint64_t)&v46;
  char v47 = &v46;
  uint64_t v48 = 0;
  if ((*(uint64_t (**)(void, void **, uint64_t *, uint64_t))(*(void *)*v7 + 96))(*v7, __p, &v46, 1))
  {
LABEL_9:
    sub_1001257B0(&v46);
    goto LABEL_10;
  }
  for (uint64_t i = v47; i != &v46; uint64_t i = (uint64_t *)i[1])
  {
    uint64_t v12 = (char *)(i + 2);
    uint64_t v13 = *(unsigned __int8 *)(a1 + 87);
    if ((v13 & 0x80u) == 0) {
      uint64_t v14 = *(unsigned __int8 *)(a1 + 87);
    }
    else {
      uint64_t v14 = *(void *)(a1 + 72);
    }
    uint64_t v15 = *((unsigned __int8 *)i + 39);
    int v16 = (char)v15;
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = i[3];
    }
    if (v14 == v15)
    {
      if (v16 >= 0) {
        unsigned __int8 v17 = (const char *)(i + 2);
      }
      else {
        unsigned __int8 v17 = *(const char **)v12;
      }
      if ((v13 & 0x80) != 0)
      {
        if (!memcmp(*v8, v17, *(void *)(a1 + 72))) {
          continue;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 87)) {
          continue;
        }
        int64_t v18 = (unsigned __int8 *)(a1 + 64);
        while (*v18 == *(unsigned __int8 *)v17)
        {
          ++v18;
          ++v17;
          if (!--v13) {
            goto LABEL_78;
          }
        }
      }
    }
    (*(void (**)(long long *__return_ptr))(*(void *)*v7 + 136))(&v53);
    uint64_t v19 = *(unsigned __int8 *)(a1 + 87);
    if ((v19 & 0x80u) == 0) {
      uint64_t v20 = *(unsigned __int8 *)(a1 + 87);
    }
    else {
      uint64_t v20 = *(void *)(a1 + 72);
    }
    uint64_t v21 = v54;
    int v22 = (char)v54;
    if ((v54 & 0x80u) != 0) {
      uint64_t v21 = *((void *)&v53 + 1);
    }
    if (v20 == v21)
    {
      if ((v54 & 0x80u) == 0) {
        int v23 = (unsigned __int8 *)&v53;
      }
      else {
        int v23 = (unsigned __int8 *)v53;
      }
      if ((v19 & 0x80) != 0)
      {
        BOOL v32 = memcmp(*v8, v23, *(void *)(a1 + 72)) == 0;
        if (v22 < 0) {
          goto LABEL_62;
        }
      }
      else if (*(unsigned char *)(a1 + 87))
      {
        uint64_t v24 = v19 - 1;
        uint64_t v25 = (unsigned __int8 *)(a1 + 64);
        do
        {
          int v27 = *v25++;
          int v26 = v27;
          int v29 = *v23++;
          int v28 = v29;
          BOOL v31 = v24-- != 0;
          BOOL v32 = v26 == v28;
        }
        while (v26 == v28 && v31);
        if ((char)v54 < 0)
        {
LABEL_62:
          operator delete((void *)v53);
          if (!v32) {
            continue;
          }
          goto LABEL_63;
        }
      }
      else
      {
        BOOL v32 = 1;
        if ((char)v54 < 0) {
          goto LABEL_62;
        }
      }
    }
    else
    {
      BOOL v32 = 0;
      if ((char)v54 < 0) {
        goto LABEL_62;
      }
    }
    if (!v32) {
      continue;
    }
LABEL_63:
    __int16 v33 = (const char *)(i + 2);
    if (*((char *)i + 39) < 0) {
      __int16 v33 = *(const char **)v12;
    }
    if (lstat(v33, &buf) || (buf.st_mode & 0xA000) == 0)
    {
      int v42 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)i + 39) < 0) {
          uint64_t v12 = *(char **)v12;
        }
        LODWORD(v53) = 136446210;
        *(void *)((char *)&v53 + 4) = v12;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I %{public}s was either not a symlink or invalid, not removing", (uint8_t *)&v53, 0xCu);
      }
LABEL_105:
      sub_1001257B0(&v46);
      goto LABEL_106;
    }
    size_t v34 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      int64_t v35 = (const char *)(i + 2);
      if (*((char *)i + 39) < 0) {
        int64_t v35 = *(const char **)v12;
      }
      LODWORD(v53) = 136315138;
      *(void *)((char *)&v53 + 4) = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Deleting Symlink %s", (uint8_t *)&v53, 0xCu);
    }
    uint64_t v36 = v49;
    if (*((char *)i + 39) < 0) {
      uint64_t v12 = *(char **)v12;
    }
    sub_100058DB0(&v53, v12);
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    int v37 = (*(uint64_t (**)(uint64_t, long long *, void **))(*(void *)v36 + 120))(v36, &v53, &v43);
    if (SHIBYTE(v45) < 0) {
      operator delete(v43);
    }
    if ((char)v54 < 0) {
      operator delete((void *)v53);
    }
    if (!v37) {
      goto LABEL_105;
    }
LABEL_78:
    ;
  }
  uint64_t v38 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    int v39 = (const void *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      int v39 = *v8;
    }
    LODWORD(v53) = 136446210;
    *(void *)((char *)&v53 + 4) = v39;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Deleting Bundle %{public}s", (uint8_t *)&v53, 0xCu);
  }
  if (*(char *)(a1 + 87) < 0)
  {
    if (!*(void *)(a1 + 72)) {
      goto LABEL_9;
    }
  }
  else if (!*(unsigned char *)(a1 + 87))
  {
    goto LABEL_9;
  }
  if (!sub_1007E1A2C(&v49, a1 + 64, (void *)(a1 + 16))) {
    goto LABEL_105;
  }
  if (*(char *)(a1 + 87) < 0) {
    uint64_t v8 = (const void **)*v8;
  }
  uint64_t v40 = v49;
  sub_100058DB0(&v53, (char *)v8);
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  char v41 = (*(uint64_t (**)(uint64_t, long long *, void **))(*(void *)v40 + 120))(v40, &v53, &v43);
  if (SHIBYTE(v45) < 0) {
    operator delete(v43);
  }
  if ((char)v54 < 0) {
    operator delete((void *)v53);
  }
  sub_1001257B0(&v46);
  if (v41) {
    goto LABEL_10;
  }
LABEL_106:
  uint64_t v9 = 0;
LABEL_19:
  if (v50) {
    sub_10004D2C8(v50);
  }
  if (SHIBYTE(v52) < 0) {
    operator delete(__p[0]);
  }
  return v9;
}

void sub_1007E1998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  sub_1001257B0(&a18);
  if (a22) {
    sub_10004D2C8(a22);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007E1A2C(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v17 = (uint64_t)&v17;
  int64_t v18 = &v17;
  uint64_t v19 = 0;
  memset(&v16, 0, sizeof(v16));
  if (!(*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t))(*(void *)*a3 + 96))(*a3, a2, &v17, 1))
  {
    for (uint64_t i = v18; i != &v17; uint64_t i = (uint64_t *)i[1])
    {
      uint64_t v8 = (char *)(i + 2);
      uint64_t v9 = (const char *)(i + 2);
      if (*((char *)i + 39) < 0) {
        uint64_t v9 = *(const char **)v8;
      }
      if (!stat(v9, &v16))
      {
        if ((v16.st_mode & 0x4000) != 0 && (sub_1007E1A2C(a1, i + 2, a3) & 1) == 0) {
          goto LABEL_19;
        }
        if (*((char *)i + 39) < 0) {
          uint64_t v8 = *(char **)v8;
        }
        uint64_t v10 = *a1;
        sub_100058DB0(v14, v8);
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v13 = 0;
        char v11 = (*(uint64_t (**)(uint64_t, void **, void **))(*(void *)v10 + 120))(v10, v14, __p);
        if (SHIBYTE(v13) < 0) {
          operator delete(__p[0]);
        }
        if (v15 < 0) {
          operator delete(v14[0]);
        }
        if ((v11 & 1) == 0)
        {
LABEL_19:
          uint64_t v5 = 0;
          goto LABEL_3;
        }
      }
    }
  }
  uint64_t v5 = 1;
LABEL_3:
  sub_1001257B0(&v17);
  return v5;
}

void sub_1007E1BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_1001257B0((void *)(v20 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_1007E1BF4(uint64_t a1)
{
  sub_1003F2A04();
  if (sub_1005B6DE8())
  {
    uint64_t v2 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Skipping Carrier Bundle Verification", (uint8_t *)&buf, 2u);
    }
    uint64_t v3 = 1;
    *(_DWORD *)(a1 + 168) = 1;
    return v3;
  }
  *(_DWORD *)(a1 + 168) = 0;
  BOOL v4 = sub_1007DF8F0(a1);
  BOOL v5 = sub_1007DFC54(a1);
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(a1 + 32);
    int v7 = 0;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    LOWORD(buf) = 0;
    uint64_t v8 = "#I Default bundle, not validating the SIMs";
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&buf, 2u);
    int v7 = 0;
    goto LABEL_12;
  }
  if (*(_DWORD *)(a1 + 160))
  {
    uint64_t v6 = *(NSObject **)(a1 + 32);
    int v7 = 0;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    LOWORD(buf) = 0;
    uint64_t v8 = "#I Overlay active, not validating the SIMs";
    goto LABEL_11;
  }
  int v7 = !v4;
  int v28 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = "true";
    if (v4) {
      int v29 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Validating the SIMs: %s", (uint8_t *)&buf, 0xCu);
  }
LABEL_12:
  CFDictionaryRef v38 = 0;
  uint64_t v9 = (char *)(a1 + 136);
  (*(void (**)(const __CFDictionary **__return_ptr))(**(void **)(a1 + 16) + 152))(&v38);
  if (v38) {
    uint64_t v10 = sub_100080778;
  }
  else {
    uint64_t v10 = 0;
  }
  if (!v10)
  {
    char v11 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = (char *)(a1 + 136);
      if (*(char *)(a1 + 159) < 0) {
        uint64_t v12 = *(char **)v9;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I There was an error getting bundle data at %s", (uint8_t *)&buf, 0xCu);
    }
  }
  uint64_t v13 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Verifying using new signatures", (uint8_t *)&buf, 2u);
    uint64_t v13 = *(NSObject **)(a1 + 32);
  }
  memset(v42, 0, sizeof(v42));
  long long buf = 0u;
  os_signpost_id_t v14 = os_signpost_id_generate(v13);
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v15 = *(NSObject **)(a1 + 32);
    if (os_signpost_enabled(v15))
    {
      stat v16 = (void *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0) {
        stat v16 = (void *)*v16;
      }
      *(_DWORD *)uint64_t v43 = 136315138;
      *(void *)&v43[4] = v16;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_BEGIN, v14, "VerifyCarrierBundle", "path=%{signpost.description:attribute}s", v43, 0xCu);
    }
  }
  *(void *)uint64_t v43 = off_101A0B1B8;
  char v47 = v43;
  *(void *)&long long buf = v14;
  *((void *)&buf + 1) = os_retain(v13);
  sub_1000336E8((uint64_t)v42, (uint64_t)v43);
  sub_100033A10(v43);
  uint64_t v36 = 0;
  int v37 = 0;
  sub_100058DB0(&__p, "verify carrier bundles");
  long long v39 = buf;
  sub_1000336E8((uint64_t)&v40, (uint64_t)v42);
  long long buf = 0uLL;
  sub_100033AF4(v42);
  Registry::createXpcJetsamAssertion();
  sub_1000339DC((uint64_t *)&v39);
  if (v35 < 0) {
    operator delete(__p);
  }
  uint64_t v3 = sub_1006396EC((CBSignUtilityLogger *)(a1 + 40), v38, v7);
  if (v4)
  {
    int v17 = sub_1007DFB84(a1);
    if ((v5 & v17 & 1) == 0) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  if (v5)
  {
LABEL_33:
    int v17 = sub_1007DFDC4(a1);
LABEL_34:
    uint64_t v3 = v17 & v3;
  }
  int64_t v18 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = a1 + 136;
    if (*(char *)(a1 + 159) < 0) {
      uint64_t v19 = *(void *)v9;
    }
    uint64_t v20 = "OFF";
    if (v7) {
      uint64_t v20 = "ON";
    }
    *(_DWORD *)uint64_t v43 = 136446722;
    *(void *)&v43[4] = v20;
    __int16 v44 = 2080;
    uint64_t v45 = (const char *)v19;
    if (v3) {
      uint64_t v21 = "true";
    }
    else {
      uint64_t v21 = "false";
    }
    __int16 v46 = 2080;
    char v47 = v21;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Validity of the bundle with SIM verification %{public}s: %s is %s", v43, 0x20u);
  }
  *(_DWORD *)(a1 + 172) = v3;
  if ((v3 & 1) == 0)
  {
    uint64_t v32 = 0;
    __int16 v33 = 0;
    Registry::getMobileHelper(&v32, *(Registry **)a1);
    uint64_t v22 = v32;
    if (v32)
    {
      int v23 = (char *)(a1 + 136);
      if (*(char *)(a1 + 159) < 0) {
        int v23 = *(char **)v9;
      }
      sub_100058DB0(v43, v23);
      v30[0] = 0;
      v30[1] = 0;
      uint64_t v31 = 0;
      int v24 = (*(uint64_t (**)(uint64_t, unsigned char *, void **))(*(void *)v22 + 120))(v22, v43, v30);
      if (SHIBYTE(v31) < 0) {
        operator delete(v30[0]);
      }
      if (SHIBYTE(v46) < 0) {
        operator delete(*(void **)v43);
      }
      uint64_t v25 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 159) < 0) {
          uint64_t v9 = *(char **)v9;
        }
        int v26 = "failed";
        if (v24) {
          int v26 = "succeeded";
        }
        *(_DWORD *)uint64_t v43 = 136315394;
        *(void *)&v43[4] = v9;
        __int16 v44 = 2082;
        uint64_t v45 = v26;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Deletion of overridden file at path: %s resulted in %{public}s", v43, 0x16u);
      }
    }
    if (v33) {
      sub_10004D2C8(v33);
    }
  }
  if (v37) {
    sub_10004D2C8(v37);
  }
  sub_1000339DC((uint64_t *)&buf);
  sub_100057D78((const void **)&v38);
  return v3;
}

void sub_1007E2208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::__shared_weak_count *a25,const void *a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v35 - 105) < 0) {
    operator delete(*(void **)(v35 - 128));
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a25) {
    sub_10004D2C8(a25);
  }
  sub_1000339DC(&a35);
  sub_100057D78(&a26);
  _Unwind_Resume(a1);
}

uint64_t sub_1007E22B0(os_log_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I ---> Bundle Comparison", buf, 2u);
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a3 + 16) + 88))(*(void *)(a3 + 16), a3 + 88)
    && (*(unsigned int (**)(void, uint64_t))(**(void **)(a3 + 16) + 88))(*(void *)(a3 + 16), a3 + 40))
  {
    int v9 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a3 + 16) + 88))(*(void *)(a3 + 16), a3 + 64);
  }
  else
  {
    int v9 = 0;
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a3 + 16) + 144))(buf);
  uint64_t v10 = buf[23];
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v11 = buf[23];
  }
  else {
    uint64_t v11 = *(void *)&buf[8];
  }
  uint64_t v12 = *(unsigned __int8 *)(a3 + 63);
  int v13 = (char)v12;
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(a3 + 48);
  }
  if (v11 != v12) {
    goto LABEL_22;
  }
  if (v13 >= 0) {
    os_signpost_id_t v14 = (unsigned __int8 *)(a3 + 40);
  }
  else {
    os_signpost_id_t v14 = *(unsigned __int8 **)(a3 + 40);
  }
  if (((char)buf[23] & 0x80000000) == 0)
  {
    if (buf[23])
    {
      char v15 = buf;
      while (*v15 == *v14)
      {
        ++v15;
        ++v14;
        if (!--v10) {
          goto LABEL_26;
        }
      }
LABEL_22:
      BOOL v16 = 0;
      if ((buf[23] & 0x80) == 0) {
        goto LABEL_53;
      }
LABEL_51:
      int v17 = *(void **)buf;
      goto LABEL_52;
    }
LABEL_26:
    (*(void (**)(void **__return_ptr))(**(void **)(a3 + 16) + 136))(__s1);
    if (v82 >= 0) {
      int64_t v18 = (void *)HIBYTE(v82);
    }
    else {
      int64_t v18 = __s1[1];
    }
    uint64_t v19 = (void *)*(unsigned __int8 *)(a3 + 87);
    int v20 = (char)v19;
    if ((char)v19 < 0) {
      uint64_t v19 = *(void **)(a3 + 72);
    }
    if (v18 == v19)
    {
      if (v20 >= 0) {
        uint64_t v21 = (unsigned __int8 *)(a3 + 64);
      }
      else {
        uint64_t v21 = *(unsigned __int8 **)(a3 + 64);
      }
      if (v82 < 0)
      {
        uint64_t v30 = __s1[0];
        BOOL v16 = memcmp(__s1[0], v21, (size_t)__s1[1]) == 0;
LABEL_48:
        operator delete(v30);
        goto LABEL_50;
      }
      if (!HIBYTE(v82))
      {
        BOOL v16 = 1;
LABEL_50:
        if ((buf[23] & 0x80) == 0) {
          goto LABEL_53;
        }
        goto LABEL_51;
      }
      uint64_t v22 = HIBYTE(v82) - 1;
      int v23 = __s1;
      do
      {
        int v25 = *(unsigned __int8 *)v23;
        int v23 = (void **)((char *)v23 + 1);
        int v24 = v25;
        int v27 = *v21++;
        int v26 = v27;
        BOOL v29 = v22-- != 0;
        BOOL v16 = v24 == v26;
      }
      while (v24 == v26 && v29);
    }
    else
    {
      BOOL v16 = 0;
    }
    if ((v82 & 0x8000000000000000) == 0) {
      goto LABEL_50;
    }
    uint64_t v30 = __s1[0];
    goto LABEL_48;
  }
  int v17 = *(void **)buf;
  if (!memcmp(*(const void **)buf, v14, *(size_t *)&buf[8])) {
    goto LABEL_26;
  }
  BOOL v16 = 0;
LABEL_52:
  operator delete(v17);
LABEL_53:
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a3 + 16) + 88))(*(void *)(a3 + 16), a3 + 112))
  {
    uint64_t v31 = *(void *)(a3 + 16);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v31 + 144))(buf, v31, a3 + 112);
    int v32 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v31 + 88))(v31, buf);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    int v32 = 0;
  }
  __int16 v33 = *(NSObject **)(a3 + 32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    size_t v34 = "false";
    if (v9) {
      uint64_t v35 = "true";
    }
    else {
      uint64_t v35 = "false";
    }
    if (v16) {
      uint64_t v36 = "true";
    }
    else {
      uint64_t v36 = "false";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v35;
    *(_WORD *)&buf[12] = 2080;
    *(void *)&buf[14] = v36;
    if (v32) {
      size_t v34 = "true";
    }
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v88 = v34;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Links exist: Bundle links present: %s, Bundle links match: %s, Bundle preferences link present: %s", buf, 0x20u);
  }
  sub_1007DFC54(a3);
  if (v9 & v16 & v32)
  {
    sub_1007DF7B0(a3, __s1);
    *(void *)long long buf = 0;
    CFTypeRef cf1 = __s1[0];
    __s1[0] = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)__s1);
    sub_1007DF7B0(a4, __s1);
    *(void *)long long buf = 0;
    CFTypeRef cf2 = __s1[0];
    __s1[0] = 0;
    sub_1000558F4((const void **)buf);
    sub_1000558F4((const void **)__s1);
    if (cf1) {
      int v37 = sub_1000810B8;
    }
    else {
      int v37 = 0;
    }
    if (v37 && (cf2 ? (CFDictionaryRef v38 = sub_1000810B8) : (CFDictionaryRef v38 = 0), v38))
    {
      int v39 = CFEqual(cf1, cf2);
      uint64_t v40 = *a1;
      BOOL v41 = os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT);
      if (v39)
      {
        if (v41)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Same Bundle IDs", buf, 2u);
        }
        uint64_t v80 = 0;
        sub_100083DA4((const void **)&v80, (const void **)(a3 + 176));
        long long v79 = 0;
        sub_1007DF670(a4, &v79);
        if (v80) {
          int v42 = sub_1000810B8;
        }
        else {
          int v42 = 0;
        }
        if (v42)
        {
          uint64_t v43 = v79 ? sub_1000810B8 : 0;
          if (v43 && _CompareBundleVersionStrings(v80, v79) == -1)
          {
            sub_1000558F4((const void **)&v79);
            sub_1000558F4((const void **)&v80);
            goto LABEL_147;
          }
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v44 = *a2;
        uint64_t v45 = (_OWORD *)(a3 + 136);
        if (*(char *)(a3 + 159) < 0)
        {
          sub_10004FC84(__s1, *(void **)(a3 + 136), *(void *)(a3 + 144));
        }
        else
        {
          *(_OWORD *)__s1 = *v45;
          uint64_t v82 = *(void *)(a3 + 152);
        }
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v44 + 120))(buf, v44, __s1);
        if (SHIBYTE(v82) < 0) {
          operator delete(__s1[0]);
        }
        __s1[0] = 0;
        __s1[1] = 0;
        uint64_t v82 = 0;
        uint64_t v51 = *a2;
        uint64_t v52 = (_OWORD *)(a4 + 136);
        if (*(char *)(a4 + 159) < 0)
        {
          sub_10004FC84(__p, *(void **)(a4 + 136), *(void *)(a4 + 144));
        }
        else
        {
          *(_OWORD *)std::string __p = *v52;
          uint64_t v78 = *(void *)(a4 + 152);
        }
        (*(void (**)(void **__return_ptr, uint64_t, void **))(*(void *)v51 + 120))(__s1, v51, __p);
        if (SHIBYTE(v78) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v53 = buf[23];
        if ((buf[23] & 0x80u) == 0) {
          unsigned __int8 v54 = (void *)buf[23];
        }
        else {
          unsigned __int8 v54 = *(void **)&buf[8];
        }
        int v55 = (void *)HIBYTE(v82);
        char v56 = HIBYTE(v82);
        if (v82 < 0) {
          int v55 = __s1[1];
        }
        if (v54 != v55) {
          goto LABEL_123;
        }
        if (v82 >= 0) {
          uint64_t v57 = __s1;
        }
        else {
          uint64_t v57 = (void **)__s1[0];
        }
        if ((buf[23] & 0x80) != 0)
        {
          if (memcmp(*(const void **)buf, v57, *(size_t *)&buf[8]))
          {
LABEL_123:
            uint64_t v59 = *a1;
            if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(a3 + 159) < 0)
              {
                sub_10004FC84(__p, *(void **)(a3 + 136), *(void *)(a3 + 144));
              }
              else
              {
                *(_OWORD *)std::string __p = *v45;
                uint64_t v78 = *(void *)(a3 + 152);
              }
              if (v78 >= 0) {
                uint64_t v61 = __p;
              }
              else {
                uint64_t v61 = (void **)__p[0];
              }
              if (*(char *)(a4 + 159) < 0)
              {
                sub_10004FC84(__dst, *(void **)(a4 + 136), *(void *)(a4 + 144));
              }
              else
              {
                *(_OWORD *)std::string __dst = *v52;
                uint64_t v76 = *(void *)(a4 + 152);
              }
              int v62 = __dst;
              if (v76 < 0) {
                int v62 = (void **)__dst[0];
              }
              *(_DWORD *)os_log_t v83 = 136315394;
              uint64_t v84 = v61;
              __int16 v85 = 2080;
              long long v86 = v62;
              _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I Carrier path file names (%s, %s) are not matching, checking further", v83, 0x16u);
              if (SHIBYTE(v76) < 0) {
                operator delete(__dst[0]);
              }
              if (SHIBYTE(v78) < 0) {
                operator delete(__p[0]);
              }
            }
            BOOL v60 = sub_100DBB64C(a1, (std::string::size_type)buf, (std::string::size_type)__s1);
            char v56 = HIBYTE(v82);
LABEL_142:
            if (v56 < 0) {
              operator delete(__s1[0]);
            }
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            sub_1000558F4((const void **)&v79);
            sub_1000558F4((const void **)&v80);
            if (!v60)
            {
              int v65 = *(_DWORD *)(a3 + 160);
              int v66 = *(_DWORD *)(a4 + 160);
              if ((v66 ^ v65) == 2) {
                uint64_t v47 = 4;
              }
              else {
                uint64_t v47 = 1;
              }
              __int16 v67 = *a1;
              if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v68 = asString();
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v68;
                _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I Same bundles, but carrier file comparison result: %s", buf, 0xCu);
              }
              if (v65 != v66) {
                goto LABEL_184;
              }
              if (*(char *)(a3 + 159) < 0)
              {
                sub_10004FC84(buf, *(void **)(a3 + 136), *(void *)(a3 + 144));
              }
              else
              {
                *(_OWORD *)long long buf = *v45;
                *(void *)&uint8_t buf[16] = *(void *)(a3 + 152);
              }
              if (*(char *)(a4 + 159) < 0)
              {
                sub_10004FC84(__s1, *(void **)(a4 + 136), *(void *)(a4 + 144));
              }
              else
              {
                *(_OWORD *)__s1 = *v52;
                uint64_t v82 = *(void *)(a4 + 152);
              }
              BOOL v69 = sub_100DBAE00(a1, (uint64_t *)buf, (uint64_t *)__s1);
              if (SHIBYTE(v82) < 0) {
                operator delete(__s1[0]);
              }
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              if (v69)
              {
                std::string v63 = *a1;
                if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_150;
                }
                *(_WORD *)long long buf = 0;
                uint64_t v64 = "#I Newer MVNO Overlay key. Considering as Bundle Update";
              }
              else
              {
                if (*(char *)(a3 + 159) < 0)
                {
                  sub_10004FC84(buf, *(void **)(a3 + 136), *(void *)(a3 + 144));
                }
                else
                {
                  *(_OWORD *)long long buf = *v45;
                  *(void *)&uint8_t buf[16] = *(void *)(a3 + 152);
                }
                if (*(char *)(a4 + 159) < 0)
                {
                  sub_10004FC84(__s1, *(void **)(a4 + 136), *(void *)(a4 + 144));
                }
                else
                {
                  *(_OWORD *)__s1 = *v52;
                  uint64_t v82 = *(void *)(a4 + 152);
                }
                BOOL v70 = sub_100DBAB5C();
                if (SHIBYTE(v82) < 0) {
                  operator delete(__s1[0]);
                }
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
                if (!v70)
                {
                  uint64_t v47 = 0;
                  goto LABEL_184;
                }
                std::string v63 = *a1;
                if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_150;
                }
                *(_WORD *)long long buf = 0;
                uint64_t v64 = "#I Newer GSMA Overlay key. Considering as Bundle Update";
              }
              goto LABEL_149;
            }
LABEL_147:
            std::string v63 = *a1;
            if (!os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
            {
LABEL_150:
              uint64_t v47 = 1;
              goto LABEL_184;
            }
            *(_WORD *)long long buf = 0;
            uint64_t v64 = "#I Newer Bundle Version. Bundle Update";
LABEL_149:
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, v64, buf, 2u);
            goto LABEL_150;
          }
        }
        else if (buf[23])
        {
          uint64_t v58 = buf;
          while (*v58 == *(unsigned __int8 *)v57)
          {
            ++v58;
            uint64_t v57 = (void **)((char *)v57 + 1);
            if (!--v53) {
              goto LABEL_126;
            }
          }
          goto LABEL_123;
        }
LABEL_126:
        BOOL v60 = 0;
        goto LABEL_142;
      }
      if (v41)
      {
        *(_WORD *)long long buf = 0;
        uint64_t v49 = "#I Different Bundle IDs. Carrier Change";
        uint64_t v47 = 2;
        uint64_t v50 = v40;
        goto LABEL_95;
      }
    }
    else
    {
      os_log_t v48 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v49 = "#I No Bundle ID. Carrier Change";
        uint64_t v47 = 2;
        uint64_t v50 = v48;
LABEL_95:
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v49, buf, 2u);
LABEL_184:
        sub_1000558F4(&cf2);
        sub_1000558F4(&cf1);
        goto LABEL_185;
      }
    }
    uint64_t v47 = 2;
    goto LABEL_184;
  }
  __int16 v46 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Original Bundle Links Do Not Exist. Treat as Carrier Change", buf, 2u);
  }
  uint64_t v47 = 3;
LABEL_185:
  uint64_t v71 = *a1;
  if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I <--- Bundle Comparison", buf, 2u);
  }
  return v47;
}

void sub_1007E2E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (*(char *)(v32 - 121) < 0) {
    operator delete(*(void **)(v32 - 144));
  }
  sub_1000558F4((const void **)&a9);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

BOOL sub_1007E2F64(uint64_t a1)
{
  CFTypeRef cf1 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v17);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
LABEL_9:
  uint64_t v12 = (void *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    uint64_t v12 = (void *)*v12;
  }
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void *))(*(void *)v10 + 64))(&cf1, v10, v12);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (cf1) {
    int v13 = sub_1000810B8;
  }
  else {
    int v13 = 0;
  }
  BOOL v14 = v13 && CFEqual(cf1, @"Trial");
  sub_1000558F4(&cf1);
  return v14;
}

void sub_1007E30C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_1007E30F8()
{
}

void *sub_1007E310C()
{
  double result = operator new(0x10uLL);
  *double result = off_101A0B1B8;
  return result;
}

void sub_1007E3144(uint64_t a1, void *a2)
{
  *a2 = off_101A0B1B8;
}

void sub_1007E316C(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)BOOL v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "VerifyCarrierBundle", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_1007E31E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007E3224()
{
}

uint64_t sub_1007E3230(uint64_t a1)
{
  *(void *)a1 = off_101A0B238;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1007E3280(uint64_t a1)
{
  *(void *)a1 = off_101A0B238;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

BOOL sub_1007E32F0(std::string *a1, char *__s)
{
  unint64_t v4 = strchr(__s, 32);
  if (v4)
  {
    if (!strncmp(__s, "add", 3uLL))
    {
      char v5 = 0x80;
    }
    else if (!strncmp(__s, "remove", 6uLL))
    {
      char v5 = -127;
    }
    else
    {
      if (strncmp(__s, "filter", 6uLL))
      {
LABEL_9:
        sub_10003ED78(a1 + 1, v4 + 1);
        return v4 != 0;
      }
      char v5 = -126;
    }
    a1->__r_.__value_.__s.__data_[17] = v5;
    goto LABEL_9;
  }
  return v4 != 0;
}

uint64_t sub_1007E33A4(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  if (!sub_100FECA8C(a2, &v7)) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(a2 + 20);
  if (v4 >= *(_DWORD *)(a2 + 16)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a2 + 8);
  *(_DWORD *)(a2 + 20) = v4 + 1;
  *(unsigned char *)(a1 + 17) = *(unsigned char *)(v5 + v4);

  return sub_100FECBF4(a2, (std::string *)(a1 + 24), (unsigned int *)(a1 + 20), 0);
}

uint64_t sub_1007E3438(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  LODWORD(__p[0]) = *(_DWORD *)a2;
  uint64_t v10 = 0;
  __p[1] = 0;
  long long v9 = 0uLL;
  std::string::push_back((std::string *)&__p[1], *(unsigned char *)(a1 + 17));
  sub_10078E7E0((uint64_t)__p, a1 + 24, *(_DWORD *)(a1 + 20));
  if (v9 >= 0) {
    unsigned int v4 = HIBYTE(v9);
  }
  else {
    unsigned int v4 = v9;
  }
  sub_10078E718(a2, v4);
  if (v9 >= 0) {
    uint64_t v5 = (const std::string::value_type *)&__p[1];
  }
  else {
    uint64_t v5 = (const std::string::value_type *)__p[1];
  }
  if (v9 >= 0) {
    std::string::size_type v6 = HIBYTE(v9);
  }
  else {
    std::string::size_type v6 = v9;
  }
  std::string::append((std::string *)(a2 + 8), v5, v6);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  return 1;
}

void sub_1007E34FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007E351C()
{
}

void sub_1007E3598()
{
}

void sub_1007E35BC()
{
}

void sub_1007E365C()
{
}

uint64_t sub_1007E3680(uint64_t a1, std::string *this)
{
  int v2 = *(unsigned __int8 *)(a1 + 17);
  if (v2 == 130)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      this->__r_.__value_.__l.__size_ = 7;
      unsigned int v4 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    else
    {
      *((unsigned char *)&this->__r_.__value_.__s + 23) = 7;
      unsigned int v4 = this;
    }
    *(_DWORD *)((char *)v4->__r_.__value_.__r.__words + 3) = 544367988;
    int v7 = 1953261926;
    goto LABEL_17;
  }
  if (v2 == 129)
  {
    if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    {
      this->__r_.__value_.__l.__size_ = 7;
      unsigned int v4 = (std::string *)this->__r_.__value_.__r.__words[0];
    }
    else
    {
      *((unsigned char *)&this->__r_.__value_.__s + 23) = 7;
      unsigned int v4 = this;
    }
    *(_DWORD *)((char *)v4->__r_.__value_.__r.__words + 3) = 543520367;
    int v7 = 1869440370;
LABEL_17:
    LODWORD(v4->__r_.__value_.__l.__data_) = v7;
    std::string::size_type v6 = &v4->__r_.__value_.__s.__data_[7];
    goto LABEL_18;
  }
  if (v2 != 128) {
    return 0;
  }
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    this->__r_.__value_.__l.__size_ = 4;
    os_signpost_id_t v3 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = 4;
    os_signpost_id_t v3 = this;
  }
  LODWORD(v3->__r_.__value_.__l.__data_) = 543450209;
  std::string::size_type v6 = &v3->__r_.__value_.__s.__data_[4];
LABEL_18:
  *std::string::size_type v6 = 0;
  uint64_t v10 = *(const std::string::value_type **)(a1 + 24);
  uint64_t v8 = a1 + 24;
  long long v9 = v10;
  if (*(char *)(v8 + 23) < 0)
  {
    std::string::size_type v11 = *(void *)(v8 + 8);
  }
  else
  {
    long long v9 = (const std::string::value_type *)v8;
    std::string::size_type v11 = *(unsigned __int8 *)(v8 + 23);
  }
  std::string::append(this, v9, v11);
  return 1;
}

const char *sub_1007E3794()
{
  return "mmflags";
}

uint64_t sub_1007E37A0(unsigned int *a1, uint64_t a2, int a3)
{
  unsigned int v3 = a1[2];
  if (v3 < 2) {
    return 3;
  }
  uint64_t v5 = (char *)(*(void *)a1 + 1);
  unsigned __int8 v6 = **(unsigned char **)a1;
  unsigned int v7 = v3 - 1;
  unint64_t v8 = v6 & 0x1F;
  if ((v6 & 0x1F) == 0x1F)
  {
    unint64_t v8 = 0;
    uint64_t result = 3;
    while (v7 >= 2)
    {
      unint64_t v9 = v8;
      if (v8 >> 57) {
        break;
      }
      char v10 = *v5++;
      --v7;
      unint64_t v8 = v10 & 0x7F | (v8 << 7);
      if ((v10 & 0x80) == 0)
      {
        if (v9 >> 54) {
          return 3;
        }
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    *(void *)a2 = v8 | ((unint64_t)(v6 & 0xE0) << 56);
    std::string::size_type v11 = (unsigned __int8 *)(v5 + 1);
    unsigned int v12 = *v5;
    unsigned int v13 = v7 - 1;
    if (*v5 < 0)
    {
      unsigned int v15 = v12 & 0x7F;
      if (v15 > 4) {
        return 3;
      }
      BOOL v16 = v13 >= v15;
      unsigned int v17 = v13 - v15;
      if (!v16 && a3 == 0) {
        return 3;
      }
      unsigned int v12 = 0;
      if (v15)
      {
        uint64_t v19 = v15 - 1;
        do
        {
          int v20 = *v11++;
          unsigned int v12 = v20 | (v12 << 8);
          --v15;
        }
        while (v15);
        std::string::size_type v11 = (unsigned __int8 *)&v5[v19 + 2];
        if (v12 > v17 && (a3 & 1) == 0) {
          return 3;
        }
      }
    }
    else if (v13 < v12 && a3 == 0)
    {
      return 3;
    }
    uint64_t result = 0;
    *(void *)(a2 + 8) = v11;
    *(_DWORD *)(a2 + 16) = v12;
  }
  return result;
}

uint64_t sub_1007E388C(unsigned int *a1, unint64_t *a2, void *a3)
{
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t result = sub_1007E37A0(a1, (uint64_t)&v8, 0);
  if (!result)
  {
    unint64_t v6 = v8;
    *a2 = v8;
    if (v6 >> 1 == 0x1000000000000008)
    {
      uint64_t result = 0;
      uint64_t v7 = v9 + v10;
      *a3 = v9;
      a3[1] = v7;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t sub_1007E3904(unint64_t *a1, uint64_t a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v7[0] = *a1;
  v7[1] = (v3 - v2);
  uint64_t result = sub_1007E37A0((unsigned int *)v7, a2, 0);
  if (!result) {
    *a1 = *(void *)(a2 + 8) + *(unsigned int *)(a2 + 16);
  }
  return result;
}

uint64_t sub_1007E3970(uint64_t a1, unsigned int a2, uint64_t a3, char *a4, unsigned int a5)
{
  if (a5) {
    bzero(a4, a5);
  }
  unint64_t v9 = *(void *)a1 + *(unsigned int *)(a1 + 8);
  v23[0] = *(void *)a1;
  v23[1] = v9;
  if (!a2) {
    return 0;
  }
  unsigned int v10 = 0;
  while (1)
  {
    uint64_t v21 = 0;
    long long v22 = 0uLL;
    unint64_t v11 = v23[0];
    uint64_t result = sub_1007E3904(v23, (uint64_t)&v21);
    if (result) {
      break;
    }
    if (v10 >= a2) {
      return 2;
    }
    unint64_t v13 = v10;
    BOOL v14 = (_WORD *)(a3 + 16 + 24 * v10);
    while (1)
    {
      __int16 v15 = *v14;
      if ((*v14 & 2) != 0 || v21 == *((void *)v14 - 1)) {
        break;
      }
      ++v13;
      uint64_t result = 2;
      if (v13 < a2)
      {
        v14 += 12;
        if (v15) {
          continue;
        }
      }
      return result;
    }
    if ((v15 & 4) == 0)
    {
      BOOL v16 = &a4[*((unsigned int *)v14 - 4)];
      *(_OWORD *)BOOL v16 = v22;
      if ((v15 & 8) != 0)
      {
        *(void *)BOOL v16 = v11;
        *((_DWORD *)v16 + 2) += v22 - v11;
      }
    }
    unsigned int v10 = (unsigned __int16)v13 + 1;
    if (v10 == a2 || v10 >= a2) {
      return 0;
    }
  }
  if (result != 1) {
    return result;
  }
  if (v10 >= a2) {
    return 0;
  }
  unsigned int v17 = (__int16 *)(a3 + 24 * v10 + 16);
  uint64_t v18 = v10 + 1;
  while (1)
  {
    __int16 v19 = *v17;
    v17 += 12;
    if ((v19 & 1) == 0) {
      break;
    }
    uint64_t result = 0;
    if (a2 == (unsigned __int16)v18++) {
      return result;
    }
  }
  return 5;
}

uint64_t sub_1007E3AFC(uint64_t a1, int a2, uint64_t a3, long long *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, "lazuli.svr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v12, &v14);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)&v12);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  v13[0] = off_101999E18;
  v13[1] = sub_1007E3E38;
  v13[3] = v13;
  *(void *)(a1 + 8) = 0;
  if ((capabilities::ct::supportsGemini(v8) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 8)) {
    operator new();
  }
  sub_10008863C(v13);
  *(_DWORD *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = *(void *)a3;
  uint64_t v9 = *(void *)(a3 + 8);
  *(void *)(a1 + 32) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    *(void *)(a1 + 56) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 40) = v10;
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 64), *(Registry **)a3);
  return a1;
}

void sub_1007E3D38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_1007E3E38(int a1)
{
  char v1 = "lazuli.svr.file.??";
  if (a1 == 2) {
    char v1 = "lazuli.svr.file.2";
  }
  if (a1 == 1) {
    return "lazuli.svr.file.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_1007E3E64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v16 = Mutable;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v13, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v13 = *(_OWORD *)a2;
    uint64_t v14 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v14) < 0)
  {
    sub_10004FC84(buf, v13[0], (unint64_t)v13[1]);
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)v13;
    uint64_t v23 = v14;
  }
  unsigned int v17 = 0;
  if (SHIBYTE(v23) < 0)
  {
    sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v19 = v23;
  }
  int v20 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v7 = v17;
    unsigned int v17 = v20;
    uint64_t v21 = v7;
    sub_1000558F4(&v21);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v8 = v17;
  __int16 v15 = v17;
  unsigned int v17 = 0;
  sub_1000558F4(&v17);
  if (SHIBYTE(v23) < 0) {
    operator delete(*(void **)buf);
  }
  CFDictionarySetValue(Mutable, @"Server", v8);
  sub_1000558F4(&v15);
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v19 = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v19 = *(void *)(a3 + 16);
  }
  ctu::path_join_impl();
  uint64_t v9 = (*(uint64_t (**)(void, void **, CFMutableDictionaryRef))(**(void **)(a1 + 64) + 184))(*(void *)(a1 + 64), __p, v16);
  if ((v9 & 1) == 0)
  {
    long long v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v11 = __p;
      if (v19 < 0) {
        unint64_t v11 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Failed to store server name to file: %{public}s", buf, 0xCu);
    }
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  sub_10005717C((const void **)&v16);
  return v9;
}

void sub_1007E4130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_1007E41C4(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v66 = (uint64_t)&v66;
  __int16 v67 = &v66;
  uint64_t v68 = 0;
  unint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  uint64_t v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      unint64_t v8 = (const void *)a2;
    }
    else {
      unint64_t v8 = *(const void **)a2;
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 32);
    uint64_t v64 = *(Registry **)(a1 + 24);
    int v65 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100565060(&v64, (char *)(a1 + 40), (uint64_t)&__dst);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = p_dst;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Attempting to find server: [%{public}s] in %{public}s", buf, 0x16u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v65) {
      sub_10004D2C8(v65);
    }
  }
  unint64_t v11 = (void *)(a1 + 40);
  if ((*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64), a1 + 40, &v66, 1))
  {
    uint64_t v12 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 63) < 0) {
        unint64_t v11 = (void *)*v11;
      }
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Failed to read contents of: %{public}s", (uint8_t *)&__dst, 0xCu);
    }
    a3->__r_.__value_.__s.__data_[0] = 0;
    a3[1].__r_.__value_.__s.__data_[0] = 0;
    goto LABEL_118;
  }
  uint64_t v52 = a3;
  uint64_t v53 = v6;
  uint64_t v61 = 0;
  int v62 = 0;
  unint64_t v63 = 0;
  for (uint64_t i = v67; i != &v66; uint64_t i = (uint64_t *)i[1])
  {
    ctu::basename();
    uint64_t v14 = v62;
    if ((unint64_t)v62 >= v63)
    {
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)v62 - (char *)v61) >> 3);
      unint64_t v17 = v16 + 1;
      if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_1000D8578();
      }
      if (0x5555555555555556 * ((uint64_t)(v63 - (void)v61) >> 3) > v17) {
        unint64_t v17 = 0x5555555555555556 * ((uint64_t)(v63 - (void)v61) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v63 - (void)v61) >> 3) >= 0x555555555555555) {
        unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v18 = v17;
      }
      *(void *)&long long v79 = &v63;
      if (v18) {
        uint64_t v19 = (char *)sub_10004812C((uint64_t)&v63, v18);
      }
      else {
        uint64_t v19 = 0;
      }
      std::string::size_type v20 = (std::string::size_type)&v19[24 * v16];
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
      __dst.__r_.__value_.__l.__size_ = v20;
      uint64_t v78 = &v19[24 * v18];
      long long v21 = *(_OWORD *)buf;
      *(void *)(v20 + 16) = *(void *)&buf[16];
      *(_OWORD *)std::string::size_type v20 = v21;
      memset(buf, 0, 24);
      __dst.__r_.__value_.__r.__words[2] = v20 + 24;
      sub_100048204((uint64_t *)&v61, &__dst);
      long long v22 = v62;
      sub_100048174((uint64_t)&__dst);
      int v62 = v22;
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      long long v15 = *(_OWORD *)buf;
      v62->__r_.__value_.__r.__words[2] = *(void *)&buf[16];
      *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v15;
      int v62 = v14 + 1;
    }
  }
  uint64_t v23 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_100062B40(v61, v62, ", ", 2uLL, &__dst);
    int v24 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__dst
        : (std::string *)__dst.__r_.__value_.__r.__words[0];
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Available files/dirs: %{public}s", buf, 0xCu);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v58 = (uint64_t *)&v58;
  uint64_t v59 = (void **)&v58;
  unint64_t v60 = 0;
  int v25 = v67;
  if (v67 == &v66)
  {
LABEL_82:
    memset(&__dst, 0, sizeof(__dst));
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 40), *(void *)(a1 + 48));
      int v37 = v52;
    }
    else
    {
      int v37 = v52;
      std::string __dst = *(std::string *)(a1 + 40);
    }
    ctu::path_join_impl();
    if ((*(uint64_t (**)(void, std::string *))(**(void **)(a1 + 64) + 88))(*(void *)(a1 + 64), &__dst))
    {
      CFDictionaryRef v38 = *v53;
      if (os_log_type_enabled(*v53, OS_LOG_TYPE_ERROR))
      {
        int v39 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v39 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v39;
        uint64_t v40 = "Server folder exists: %{public}s";
LABEL_124:
        _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, v40, buf, 0xCu);
      }
    }
    else
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v41 = &__dst;
      }
      else {
        BOOL v41 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      int v42 = (*(uint64_t (**)(void, std::string *, uint64_t, uint64_t))(**(void **)(a1 + 64) + 72))(*(void *)(a1 + 64), v41, 511, 1);
      CFDictionaryRef v38 = *v53;
      BOOL v43 = os_log_type_enabled(*v53, OS_LOG_TYPE_ERROR);
      if (v42)
      {
        if (!v43) {
          goto LABEL_111;
        }
        uint64_t v44 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v44 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v44;
        uint64_t v45 = "Folder could not be created: %{public}s";
        __int16 v46 = v38;
        uint32_t v47 = 12;
        goto LABEL_120;
      }
      if (v43)
      {
        uint64_t v51 = &__dst;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v51 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v51;
        uint64_t v40 = "Server folder created: %{public}s";
        goto LABEL_124;
      }
    }
    if (sub_1007E3E64(a1, a2, (uint64_t)&__dst))
    {
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(v37, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        *int v37 = __dst;
      }
      char v50 = 1;
LABEL_114:
      v37[1].__r_.__value_.__s.__data_[0] = v50;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        os_log_t v48 = (void *)__dst.__r_.__value_.__r.__words[0];
LABEL_116:
        operator delete(v48);
      }
      goto LABEL_117;
    }
    os_log_t v49 = *v53;
    if (!os_log_type_enabled(*v53, OS_LOG_TYPE_ERROR))
    {
LABEL_111:
      char v50 = 0;
      v37->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_114;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v45 = "Could not store server name to folder";
    __int16 v46 = v49;
    uint32_t v47 = 2;
LABEL_120:
    _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v45, buf, v47);
    goto LABEL_111;
  }
  while (1)
  {
    memset(buf, 0, 24);
    if (*((char *)v25 + 39) < 0)
    {
      sub_10004FC84(buf, (void *)v25[2], v25[3]);
    }
    else
    {
      *(_OWORD *)long long buf = *((_OWORD *)v25 + 1);
      *(void *)&uint8_t buf[16] = v25[4];
    }
    int v26 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
    if ((*(unsigned int (**)(void, uint8_t *))(**(void **)(a1 + 64) + 224))(*(void *)(a1 + 64), v26)) {
      break;
    }
LABEL_77:
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    int v25 = (uint64_t *)v25[1];
    if (v25 == &v66)
    {
      if (v60)
      {
        sub_1007E8AEC(v59, &v58, v60);
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v71 = 0u;
        memset(buf, 0, sizeof(buf));
        long long v56 = 0u;
        long long v57 = 0u;
        *(_OWORD *)std::string __p = 0u;
        long long v55 = 0u;
        sub_10056D028((std::locale *)__p, "_(\\d+)", 0);
      }
      goto LABEL_82;
    }
  }
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v55 = 0;
  if ((char)buf[23] < 0)
  {
    sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    *(void *)&long long v55 = *(void *)&buf[16];
  }
  ctu::path_join_impl();
  if (((*(uint64_t (**)(void, void **))(**(void **)(a1 + 64) + 88))(*(void *)(a1 + 64), __p) & 1) == 0)
  {
    *(_OWORD *)&v52->__r_.__value_.__l.__data_ = *(_OWORD *)buf;
    v52->__r_.__value_.__r.__words[2] = *(void *)&buf[16];
    memset(buf, 0, 24);
    v52[1].__r_.__value_.__s.__data_[0] = 1;
    goto LABEL_102;
  }
  CFDictionaryRef theDict = 0;
  (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 64) + 152))(&theDict);
  if (theDict) {
    int v27 = sub_100080778;
  }
  else {
    int v27 = 0;
  }
  if (!v27)
  {
LABEL_75:
    sub_100057D78((const void **)&theDict);
    uint64_t v35 = sub_1007E8A70((uint64_t)&v58, 0, 0, (uint64_t)buf);
    uint64_t v36 = v58;
    *uint64_t v35 = (uint64_t)v58;
    v35[1] = (uint64_t)&v58;
    v36[1] = (uint64_t)v35;
    uint64_t v58 = v35;
    ++v60;
    if (SBYTE7(v55) < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_77;
  }
  CFDictionaryGetValue(theDict, @"Server");
  memset(&__dst, 0, sizeof(__dst));
  ctu::cf::assign();
  std::string v76 = __dst;
  uint64_t v28 = *(unsigned __int8 *)(a2 + 23);
  if ((v28 & 0x80u) == 0) {
    uint64_t v29 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v29 = *(void *)(a2 + 8);
  }
  std::string::size_type size = HIBYTE(v76.__r_.__value_.__r.__words[2]);
  int v31 = SHIBYTE(v76.__r_.__value_.__r.__words[2]);
  if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v76.__r_.__value_.__l.__size_;
  }
  if (v29 != size) {
    goto LABEL_73;
  }
  uint64_t v32 = (void *)v76.__r_.__value_.__r.__words[0];
  if ((v76.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    __int16 v33 = &v76;
  }
  else {
    __int16 v33 = (std::string *)v76.__r_.__value_.__r.__words[0];
  }
  if ((v28 & 0x80) == 0)
  {
    if (!*(unsigned char *)(a2 + 23)) {
      goto LABEL_84;
    }
    size_t v34 = (unsigned __int8 *)a2;
    while (*v34 == v33->__r_.__value_.__s.__data_[0])
    {
      ++v34;
      __int16 v33 = (std::string *)((char *)v33 + 1);
      if (!--v28) {
        goto LABEL_84;
      }
    }
    goto LABEL_73;
  }
  if (memcmp(*(const void **)a2, v33, *(void *)(a2 + 8)))
  {
LABEL_73:
    if (v31 < 0) {
      operator delete(v76.__r_.__value_.__l.__data_);
    }
    goto LABEL_75;
  }
LABEL_84:
  *(_OWORD *)&v52->__r_.__value_.__l.__data_ = *(_OWORD *)buf;
  v52->__r_.__value_.__r.__words[2] = *(void *)&buf[16];
  memset(buf, 0, 24);
  v52[1].__r_.__value_.__s.__data_[0] = 1;
  if (v31 < 0) {
    operator delete(v32);
  }
  sub_100057D78((const void **)&theDict);
LABEL_102:
  if (SBYTE7(v55) < 0) {
    operator delete(__p[0]);
  }
  if ((char)buf[23] < 0)
  {
    os_log_t v48 = *(void **)buf;
    goto LABEL_116;
  }
LABEL_117:
  sub_1001257B0(&v58);
  *(void *)long long buf = &v61;
  sub_100047F64((void ***)buf);
LABEL_118:
  sub_1001257B0(&v66);
}

void sub_1007E4FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, unsigned char *a11, os_log_t *a12, std::locale a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a2)
  {
    if (*(char *)(v48 - 201) < 0) {
      operator delete(*(void **)(v48 - 224));
    }
    __cxa_begin_catch(exception_object);
    char v50 = *a12;
    if (os_log_type_enabled(*a12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)(v48 - 256) = 136446210;
      _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Failed to convert to string: %{public}s", (uint8_t *)(v48 - 256), 0xCu);
    }
    *a11 = 0;
    a11[24] = 0;
    __cxa_end_catch();
    JUMPOUT(0x1007E4DA8);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007E5208(std::string *a1, uint64_t a2, const void **a3)
{
  uint64_t v35 = (uint64_t)&v35;
  uint64_t v36 = &v35;
  uint64_t v37 = 0;
  unint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a2 + 8) + 16))(*(void *)(a2 + 8), *(unsigned int *)(a2 + 16));
  uint64_t v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v8 = a3;
    }
    else {
      unint64_t v8 = (void *)*a3;
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a2 + 32);
    __int16 v33 = *(Registry **)(a2 + 24);
    size_t v34 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100565060(&v33, (char *)(a2 + 40), (uint64_t)v39);
    if (v40 >= 0) {
      long long v10 = v39;
    }
    else {
      long long v10 = *(uint8_t **)v39;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Attempting to find server: %{public}s in %{public}s", (uint8_t *)&buf, 0x16u);
    if (SHIBYTE(v40) < 0) {
      operator delete(*(void **)v39);
    }
    if (v34) {
      sub_10004D2C8(v34);
    }
  }
  unint64_t v11 = (void *)(a2 + 40);
  if ((*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t))(**(void **)(a2 + 64) + 96))(*(void *)(a2 + 64), a2 + 40, &v35, 1))
  {
    uint64_t v12 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 63) < 0) {
        unint64_t v11 = (void *)*v11;
      }
      *(_DWORD *)int v39 = 136446210;
      *(void *)&v39[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Failed to read contents of: %{public}s", v39, 0xCu);
    }
    a1->__r_.__value_.__s.__data_[0] = 0;
    a1[1].__r_.__value_.__s.__data_[0] = 0;
    goto LABEL_20;
  }
  memset(&buf, 0, sizeof(buf));
  unint64_t v13 = v36;
  if (v36 == &v35)
  {
    char v24 = 0;
    goto LABEL_74;
  }
  do
  {
    memset(&__str, 0, sizeof(__str));
    if (*((char *)v13 + 39) < 0) {
      sub_10004FC84(&__str, (void *)v13[2], v13[3]);
    }
    else {
      std::string __str = *(std::string *)(v13 + 2);
    }
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if (((*(uint64_t (**)(void, std::string *))(**(void **)(a2 + 64) + 224))(*(void *)(a2 + 64), p_str) & 1) == 0)
    {
      int v15 = 8;
      goto LABEL_62;
    }
    memset(&__dst, 0, sizeof(__dst));
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = __str;
    }
    ctu::path_join_impl();
    if (((*(uint64_t (**)(void, std::string *))(**(void **)(a2 + 64) + 88))(*(void *)(a2 + 64), &__dst) & 1) == 0)
    {
      int v15 = 8;
      goto LABEL_60;
    }
    CFDictionaryRef theDict = 0;
    (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a2 + 64) + 152))(&theDict);
    if (theDict) {
      unint64_t v16 = sub_100080778;
    }
    else {
      unint64_t v16 = 0;
    }
    if (!v16)
    {
LABEL_58:
      int v15 = 0;
      goto LABEL_59;
    }
    CFDictionaryGetValue(theDict, @"Server");
    memset(v39, 0, sizeof(v39));
    uint64_t v40 = 0;
    ctu::cf::assign();
    uint64_t v29 = v40;
    *(_OWORD *)std::string __p = *(_OWORD *)v39;
    uint64_t v17 = *((unsigned __int8 *)a3 + 23);
    if ((v17 & 0x80u) == 0) {
      unint64_t v18 = (void *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      unint64_t v18 = (void *)a3[1];
    }
    uint64_t v19 = (void *)HIBYTE(v29);
    int v20 = SHIBYTE(v29);
    if (v29 < 0) {
      uint64_t v19 = __p[1];
    }
    if (v18 != v19) {
      goto LABEL_55;
    }
    if (v29 >= 0) {
      long long v21 = __p;
    }
    else {
      long long v21 = (void **)__p[0];
    }
    if ((v17 & 0x80) != 0)
    {
      if (memcmp(*a3, v21, (size_t)a3[1])) {
        goto LABEL_55;
      }
    }
    else if (*((unsigned char *)a3 + 23))
    {
      long long v22 = a3;
      while (*(unsigned __int8 *)v22 == *(unsigned __int8 *)v21)
      {
        long long v22 = (const void **)((char *)v22 + 1);
        long long v21 = (void **)((char *)v21 + 1);
        if (!--v17) {
          goto LABEL_67;
        }
      }
LABEL_55:
      char v23 = 0;
      int v15 = 0;
      if ((v20 & 0x80000000) == 0) {
        goto LABEL_57;
      }
LABEL_56:
      operator delete(__p[0]);
      goto LABEL_57;
    }
LABEL_67:
    std::string::operator=(&buf, &__str);
    int v15 = 6;
    char v23 = 1;
    if (v20 < 0) {
      goto LABEL_56;
    }
LABEL_57:
    if ((v23 & 1) == 0) {
      goto LABEL_58;
    }
LABEL_59:
    sub_100057D78((const void **)&theDict);
LABEL_60:
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
LABEL_62:
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    if (v15 == 6) {
      break;
    }
    unint64_t v13 = (uint64_t *)v13[1];
  }
  while (v13 != &v35);
  char v24 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = buf.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    *a1 = buf;
    a1[1].__r_.__value_.__s.__data_[0] = 1;
    goto LABEL_20;
  }
LABEL_74:
  int v26 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a3 + 23) >= 0) {
      int v27 = a3;
    }
    else {
      int v27 = (void *)*a3;
    }
    *(_DWORD *)int v39 = 136446210;
    *(void *)&v39[4] = v27;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to find server folder for: %{public}s", v39, 0xCu);
    char v24 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  }
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[1].__r_.__value_.__s.__data_[0] = 0;
  if (v24 < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
LABEL_20:
  sub_1001257B0(&v35);
}

void sub_1007E5770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (v39 < 0) {
    operator delete(v38);
  }
  sub_100057D78(&a14);
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  sub_1001257B0(&a30);
  _Unwind_Resume(a1);
}

BOOL sub_1007E5828(uint64_t a1, const void **a2)
{
  unsigned int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  *(_OWORD *)int v15 = 0u;
  long long v16 = 0u;
  sub_1007E5208((std::string *)v15, a1, a2);
  if (BYTE8(v16))
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v14 = 0;
    int v5 = SBYTE7(v16);
    if (SBYTE7(v16) < 0)
    {
      sub_10004FC84(__p, v15[0], (unint64_t)v15[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v15;
      uint64_t v14 = v16;
    }
    uint64_t v7 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v8 = __p;
      if (v14 < 0) {
        unint64_t v8 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136446210;
      unint64_t v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Removing: %{public}s", buf, 0xCu);
    }
    uint64_t v9 = (*(uint64_t (**)(void, void **))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), __p);
    BOOL v6 = v9 == 0;
    if (v9)
    {
      long long v10 = *v4;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v11 = __p;
        if (v14 < 0) {
          unint64_t v11 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        unint64_t v18 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Failed to erase: %{public}s", buf, 0xCu);
      }
    }
    if (SHIBYTE(v14) < 0)
    {
      operator delete(__p[0]);
      if ((v5 & 0x80000000) == 0) {
        return v6;
      }
    }
    else if ((v5 & 0x80000000) == 0)
    {
      return v6;
    }
    operator delete(v15[0]);
    return v6;
  }
  return 0;
}

void sub_1007E5A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_1007E5A68(uint64_t a1, const void **a2, char *a3)
{
  BOOL v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  *(_OWORD *)long long v21 = 0u;
  long long v22 = 0u;
  sub_1007E5208((std::string *)v21, a1, a2);
  if (!BYTE8(v22)) {
    return;
  }
  v19[0] = 0;
  v19[1] = 0;
  int v20 = 0;
  int v7 = SBYTE7(v22);
  if (SBYTE7(v22) < 0)
  {
    sub_10004FC84(v19, v21[0], (unint64_t)v21[1]);
  }
  else
  {
    *(_OWORD *)uint64_t v19 = *(_OWORD *)v21;
    int v20 = (void *)v22;
  }
  uint64_t v8 = *(void *)(a1 + 64);
  memset(__p, 0, sizeof(__p));
  if (SHIBYTE(v20) < 0)
  {
    sub_10004FC84(__p, v19[0], (unint64_t)v19[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v19;
    __p[2] = v20;
  }
  ctu::path_join_impl();
  int v9 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v8 + 88))(v8, __p);
  int v10 = v9;
  if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
  {
    if (!v9) {
      goto LABEL_32;
    }
LABEL_12:
    unint64_t v11 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      if (a3[23] >= 0) {
        uint64_t v12 = a3;
      }
      else {
        uint64_t v12 = *(char **)a3;
      }
      unint64_t v13 = v19;
      if (SHIBYTE(v20) < 0) {
        unint64_t v13 = (void **)v19[0];
      }
      LODWORD(__p[0]) = 136446466;
      *(void **)((char *)__p + 4) = v12;
      WORD2(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 6) = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Removing %{public}s from: %{public}s", (uint8_t *)__p, 0x16u);
    }
    uint64_t v14 = *(void *)(a1 + 64);
    memset(__p, 0, sizeof(__p));
    if (SHIBYTE(v20) < 0)
    {
      sub_10004FC84(__p, v19[0], (unint64_t)v19[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v19;
      __p[2] = v20;
    }
    ctu::path_join_impl();
    uint64_t v15 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v14 + 112))(v14, __p);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    if (v15)
    {
      long long v16 = *v6;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (a3[23] >= 0) {
          uint64_t v17 = a3;
        }
        else {
          uint64_t v17 = *(char **)a3;
        }
        unint64_t v18 = v19;
        if (SHIBYTE(v20) < 0) {
          unint64_t v18 = (void **)v19[0];
        }
        LODWORD(__p[0]) = 136446466;
        *(void **)((char *)__p + 4) = v17;
        WORD2(__p[1]) = 2082;
        *(void **)((char *)&__p[1] + 6) = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Failed to erase %{public}s from: %{public}s", (uint8_t *)__p, 0x16u);
      }
    }
    goto LABEL_32;
  }
  operator delete(__p[0]);
  if (v10) {
    goto LABEL_12;
  }
LABEL_32:
  if ((SHIBYTE(v20) & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_36:
    operator delete(v21[0]);
    return;
  }
  operator delete(v19[0]);
  if (v7 < 0) {
    goto LABEL_36;
  }
}

void sub_1007E5DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v25 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007E5E08(uint64_t a1, uint64_t a2, char *a3)
{
  v38[0] = 0;
  v38[1] = 0;
  uint64_t v39 = 0;
  if (a3[23] >= 0) {
    BOOL v6 = a3;
  }
  else {
    BOOL v6 = *(char **)a3;
  }
  sub_1000493DC(&v37, v6);
  ctu::basename();
  int v7 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a2 + 8) + 16))(*(void *)(a2 + 8), *(unsigned int *)(a2 + 16));
  if (((*(uint64_t (**)(void, char *))(**(void **)(a2 + 64) + 88))(*(void *)(a2 + 64), a3) & 1) == 0)
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 1192) = 0;
    goto LABEL_39;
  }
  CFDataRef theData = 0;
  (*(void (**)(CFDataRef *__return_ptr))(**(void **)(a2 + 64) + 168))(&theData);
  if (theData) {
    uint64_t v8 = sub_10008324C;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8)
  {
    uint64_t v15 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      long long v16 = v38;
      if (v39 < 0) {
        long long v16 = (void **)v38[0];
      }
      *(_DWORD *)uint64_t v44 = 136446210;
      *(void *)&v44[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Failed to read existing XML: %{public}s", v44, 0xCu);
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 1192) = 0;
    goto LABEL_38;
  }
  std::string __p = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
  size_t Length = CFDataGetLength(theData);
  sub_1000D95C8(&__p, BytePtr, Length);
  uint64_t v11 = HIBYTE(v35);
  if (v35 < 0) {
    uint64_t v11 = v34;
  }
  if (!v11)
  {
    uint64_t v17 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v18 = v38;
      if (v39 < 0) {
        unint64_t v18 = (void **)v38[0];
      }
      *(_DWORD *)uint64_t v44 = 136315138;
      *(void *)&v44[4] = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Failed to parse XML: %s", v44, 0xCu);
    }
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 1192) = 0;
    goto LABEL_36;
  }
  bzero(v44, 0x4B0uLL);
  sub_1012F8EDC((Registry **)(a2 + 24), v7, (uint64_t *)&__p, (uint64_t)v44);
  if (v67)
  {
    double v32 = 0.0;
    int v12 = (*(uint64_t (**)(void, char *, double *))(**(void **)(a2 + 64) + 240))(*(void *)(a2 + 64), a3, &v32);
    if (!v12)
    {
      uint64_t v21 = (uint64_t)v32;
      uint64_t v66 = (uint64_t)v32;
      long long v22 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        char v23 = v38;
        if (v39 < 0) {
          char v23 = (void **)v38[0];
        }
        *(_DWORD *)std::string buf = 136446466;
        BOOL v41 = v23;
        __int16 v42 = 2048;
        uint64_t v43 = v21;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I XML read: [%{public}s, created: %ld]", buf, 0x16u);
      }
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 1192) = 0;
      if (v67)
      {
        *(unsigned char *)a1 = 0;
        *(unsigned char *)(a1 + 32) = 0;
        if (v46)
        {
          *(void *)a1 = *(void *)v44;
          *(_OWORD *)(a1 + 8) = *(_OWORD *)&v44[8];
          *(void *)(a1 + 24) = v45;
          *(_OWORD *)&v44[8] = 0uLL;
          uint64_t v45 = 0;
          *(unsigned char *)(a1 + 32) = 1;
        }
        *(_OWORD *)(a1 + 40) = v47;
        *(void *)(a1 + 56) = v48;
        *(unsigned char *)(a1 + 64) = 0;
        *(unsigned char *)(a1 + 112) = 0;
        if (v54)
        {
          int v25 = v49;
          uint64_t v24 = v50;
          *(void *)(a1 + 72) = v50;
          uint64_t v26 = a1 + 72;
          *(void *)(a1 + 64) = v25;
          uint64_t v27 = v51;
          *(void *)(a1 + 80) = v51;
          if (v27)
          {
            *(void *)(v24 + 16) = v26;
            os_log_t v49 = &v50;
            uint64_t v50 = 0;
            uint64_t v51 = 0;
          }
          else
          {
            *(void *)(a1 + 64) = v26;
          }
          *(_OWORD *)(a1 + 88) = v52;
          *(void *)(a1 + 104) = v53;
          uint64_t v53 = 0;
          long long v52 = 0uLL;
          *(unsigned char *)(a1 + 112) = 1;
        }
        *(unsigned char *)(a1 + 120) = 0;
        *(unsigned char *)(a1 + 648) = 0;
        if (v56)
        {
          sub_1007E8600(a1 + 120, v55);
          *(unsigned char *)(a1 + 648) = 1;
        }
        *(unsigned char *)(a1 + 656) = 0;
        *(unsigned char *)(a1 + 712) = 0;
        if (v61)
        {
          *(_OWORD *)(a1 + 656) = v57[0];
          *(_OWORD *)(a1 + 667) = *(_OWORD *)((char *)v57 + 11);
          *(void *)(a1 + 688) = v58;
          uint64_t v28 = a1 + 696;
          uint64_t v29 = v59;
          *(void *)(a1 + 696) = v59;
          uint64_t v30 = v60;
          *(void *)(a1 + 704) = v60;
          if (v30)
          {
            *(void *)(v29 + 16) = v28;
            uint64_t v58 = &v59;
            uint64_t v59 = 0;
            uint64_t v60 = 0;
          }
          else
          {
            *(void *)(a1 + 688) = v28;
          }
          *(unsigned char *)(a1 + 712) = 1;
        }
        *(unsigned char *)(a1 + 720) = 0;
        *(unsigned char *)(a1 + 1136) = 0;
        if (v62[416])
        {
          sub_1007E8870(a1 + 720, (uint64_t)v62);
          *(unsigned char *)(a1 + 1136) = 1;
        }
        *(void *)(a1 + 1176) = v65;
        long long v31 = v64;
        *(_OWORD *)(a1 + 1144) = v63;
        *(_OWORD *)(a1 + 1160) = v31;
        *(void *)(a1 + 1184) = v66;
        *(unsigned char *)(a1 + 1192) = 1;
      }
      goto LABEL_35;
    }
    unint64_t v13 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = v38;
      if (v39 < 0) {
        uint64_t v14 = (void **)v38[0];
      }
      *(_DWORD *)std::string buf = 136446466;
      BOOL v41 = v14;
      __int16 v42 = 1024;
      LODWORD(v43) = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Invalid timestamp: %{public}s [%d]", buf, 0x12u);
    }
  }
  else
  {
    uint64_t v19 = *v7;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = v38;
      if (v39 < 0) {
        int v20 = (void **)v38[0];
      }
      *(_DWORD *)std::string buf = 136446210;
      BOOL v41 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Removing invalid XML: %{public}s", buf, 0xCu);
    }
    (*(void (**)(void, char *))(**(void **)(a2 + 64) + 112))(*(void *)(a2 + 64), a3);
  }
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 1192) = 0;
LABEL_35:
  sub_10020F460((uint64_t)v44);
LABEL_36:
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
LABEL_38:
  sub_100030068((const void **)&theData);
LABEL_39:
  if (SHIBYTE(v39) < 0) {
    operator delete(v38[0]);
  }
}

void sub_1007E6424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100030068(&a16);
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(a1);
}

void sub_1007E6488(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v15 = *(void *)(a2 + 16);
  }
  ctu::path_join_impl();
  int v5 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 64) + 88))(*(void *)(a1 + 64), __p))
  {
    CFDictionaryRef theDict = 0;
    (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 64) + 152))(&theDict);
    if (theDict) {
      BOOL v6 = sub_100080778;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      CFDictionaryGetValue(theDict, @"Server");
      ctu::cf::assign();
      uint64_t v11 = *v5;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = __p;
        if (v15 < 0) {
          int v12 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v17 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Missing keys in server information: %{public}s", buf, 0xCu);
      }
      *a3 = 0;
      a3[24] = 0;
    }
    else
    {
      int v9 = *v5;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = __p;
        if (v15 < 0) {
          int v10 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136446210;
        uint64_t v17 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Missing server information: %{public}s", buf, 0xCu);
      }
      *a3 = 0;
      a3[24] = 0;
    }
    sub_100057D78((const void **)&theDict);
  }
  else
  {
    int v7 = *v5;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = __p;
      if (v15 < 0) {
        uint64_t v8 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136446210;
      uint64_t v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I File not found: %{public}s", buf, 0xCu);
    }
    *a3 = 0;
    a3[24] = 0;
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007E67C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  operator delete(v23);
  sub_100057D78(&a17);
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1007E6820(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v6 = (int *)(a1 + 16);
  int v7 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  uint64_t v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(std::__shared_weak_count **)(a1 + 32);
    BOOL v41 = *(Registry **)(a1 + 24);
    __int16 v42 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100565060(&v41, (char *)a2, (uint64_t)__p);
    if (v55 >= 0) {
      int v10 = __p;
    }
    else {
      int v10 = *(unsigned char **)__p;
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Preparing collection from directory: %{public}s", buf, 0xCu);
    if (v55 < 0) {
      operator delete(*(void **)__p);
    }
    if (v42) {
      sub_10004D2C8(v42);
    }
  }
  *(_OWORD *)uint64_t v39 = 0u;
  long long v40 = 0u;
  sub_1007E6488(a1, a2, v39);
  if (BYTE8(v40))
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v38 = 0;
    if (SBYTE7(v40) < 0)
    {
      sub_10004FC84(__dst, v39[0], (unint64_t)v39[1]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v39;
      uint64_t v38 = v40;
    }
    bzero(__p, 0x4B0uLL);
    long long v36 = 0uLL;
    sub_10020F9FC(v6, (uint64_t *)(a1 + 24), (long long *)__dst, &v36);
    bzero(buf, 0x4B0uLL);
    memset(v44, 0, 24);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v44, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
      *(void *)&v44[16] = *(void *)(a2 + 16);
    }
    ctu::path_join_impl();
    sub_1007E5E08((uint64_t)buf, a1, (char *)v44);
    if ((char)v44[23] < 0) {
      operator delete(*(void **)v44);
    }
    if (!v53) {
      goto LABEL_31;
    }
    int v12 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v44 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Found Access control XML", v44, 2u);
    }
    if (v51[48])
    {
      if (v50)
      {
        sub_10020FE24((void *)(a1 + 24), (uint64_t)v51, &v49, v44);
        long long v13 = *(_OWORD *)v44;
        *(void *)uint64_t v44 = 0;
        *(void *)&v44[8] = 0;
        uint64_t v14 = *(std::__shared_weak_count **)(v36 + 144);
        *(_OWORD *)(v36 + 136) = v13;
        if (v14)
        {
          sub_10004D2C8(v14);
          if (*(void *)&v44[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v44[8]);
          }
        }
        *(void *)(*(void *)(v36 + 136) + 24) = v52;
LABEL_31:
        sub_10020F460((uint64_t)buf);
        bzero(buf, 0x4B0uLL);
        memset(v44, 0, 24);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v44, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
          *(void *)&v44[16] = *(void *)(a2 + 16);
        }
        ctu::path_join_impl();
        sub_1007E5E08((uint64_t)buf, a1, (char *)v44);
        if ((char)v44[23] < 0) {
          operator delete(*(void **)v44);
        }
        if (v53)
        {
          uint64_t v17 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v44 = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Found full config XML", v44, 2u);
            if (!v53) {
              sub_10016C840();
            }
          }
          sub_100210744((void *)(a1 + 24), (uint64_t)buf, v44);
          long long v18 = *(_OWORD *)v44;
          *(void *)uint64_t v44 = 0;
          *(void *)&v44[8] = 0;
          uint64_t v19 = *(std::__shared_weak_count **)(v36 + 112);
          *(_OWORD *)(v36 + 104) = v18;
          if (v19)
          {
            sub_10004D2C8(v19);
            if (*(void *)&v44[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v44[8]);
            }
          }
          *(void *)(*(void *)(v36 + 104) + 24) = v52;
        }
        sub_10020F460((uint64_t)buf);
        bzero(buf, 0x4B0uLL);
        memset(v44, 0, 24);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v44, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
          *(void *)&v44[16] = *(void *)(a2 + 16);
        }
        ctu::path_join_impl();
        sub_1007E5E08((uint64_t)buf, a1, (char *)v44);
        if ((char)v44[23] < 0) {
          operator delete(*(void **)v44);
        }
        if (v53)
        {
          long long v45 = 0u;
          memset(v44, 0, sizeof(v44));
          if (!v48) {
            sub_10016C840();
          }
          *(void *)uint64_t v44 = *(void *)buf;
          if (SHIBYTE(v47) < 0)
          {
            sub_10004FC84(&v44[8], *(void **)&buf[8], *(unint64_t *)&buf[16]);
          }
          else
          {
            *(_OWORD *)&v44[8] = *(_OWORD *)&buf[8];
            *(void *)&unsigned char v44[24] = v47;
          }
          if (!v50) {
            sub_10016C840();
          }
          long long v45 = v49;
          int v20 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v43 = 134218240;
            *(void *)&v43[4] = v45;
            *(_WORD *)&unsigned char v43[12] = 2048;
            *(void *)&v43[14] = *((void *)&v45 + 1);
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Found full config-refresh XML: [version: %ld, validity: %ld]", v43, 0x16u);
          }
          sub_100210574((void *)(a1 + 24), (uint64_t)v44, v43);
          long long v21 = *(_OWORD *)v43;
          *(void *)uint64_t v43 = 0;
          *(void *)&v43[8] = 0;
          long long v22 = *(std::__shared_weak_count **)(v36 + 128);
          *(_OWORD *)(v36 + 120) = v21;
          if (v22)
          {
            sub_10004D2C8(v22);
            if (*(void *)&v43[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v43[8]);
            }
          }
          *(void *)(*(void *)(v36 + 120) + 24) = v52;
          if ((char)v44[31] < 0) {
            operator delete(*(void **)&v44[8]);
          }
        }
        sub_10020F460((uint64_t)buf);
        bzero(buf, 0x4B0uLL);
        memset(v44, 0, 24);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v44, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
          *(void *)&v44[16] = *(void *)(a2 + 16);
        }
        ctu::path_join_impl();
        sub_1007E5E08((uint64_t)buf, a1, (char *)v44);
        if ((char)v44[23] < 0) {
          operator delete(*(void **)v44);
        }
        if (v53)
        {
          long long v23 = v49;
          *(_OWORD *)uint64_t v43 = v49;
          uint64_t v24 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v44 = 134218240;
            *(void *)&v44[4] = v23;
            *(_WORD *)&v44[12] = 2048;
            *(void *)&v44[14] = *((void *)&v23 + 1);
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Found User-interaction required XML (-2): [version: %ld, validity: %ld]", v44, 0x16u);
          }
          sub_1002101D4((void *)(a1 + 24), v43, v44);
          long long v25 = *(_OWORD *)v44;
          *(void *)uint64_t v44 = 0;
          *(void *)&v44[8] = 0;
          uint64_t v26 = *(std::__shared_weak_count **)(v36 + 96);
          *(_OWORD *)(v36 + 88) = v25;
          if (v26)
          {
            sub_10004D2C8(v26);
            if (*(void *)&v44[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v44[8]);
            }
          }
          *(void *)(*(void *)(v36 + 88) + 24) = v52;
        }
        sub_10020F460((uint64_t)buf);
        bzero(buf, 0x4B0uLL);
        memset(v44, 0, 24);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v44, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
          *(void *)&v44[16] = *(void *)(a2 + 16);
        }
        ctu::path_join_impl();
        sub_1007E5E08((uint64_t)buf, a1, (char *)v44);
        if ((char)v44[23] < 0) {
          operator delete(*(void **)v44);
        }
        if (v53)
        {
          long long v27 = v49;
          *(_OWORD *)uint64_t v43 = v49;
          uint64_t v28 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v44 = 134218240;
            *(void *)&v44[4] = v27;
            *(_WORD *)&v44[12] = 2048;
            *(void *)&v44[14] = *((void *)&v27 + 1);
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Found Unauthorized XML (0): [version: %ld, validity: %ld]", v44, 0x16u);
          }
          sub_100210004((void *)(a1 + 24), v43, v44);
          long long v29 = *(_OWORD *)v44;
          *(void *)uint64_t v44 = 0;
          *(void *)&v44[8] = 0;
          uint64_t v30 = *(std::__shared_weak_count **)(v36 + 80);
          *(_OWORD *)(v36 + 72) = v29;
          if (v30)
          {
            sub_10004D2C8(v30);
            if (*(void *)&v44[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v44[8]);
            }
          }
          *(void *)(*(void *)(v36 + 72) + 24) = v52;
        }
        sub_10020F460((uint64_t)buf);
        bzero(buf, 0x4B0uLL);
        memset(v44, 0, 24);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v44, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
          *(void *)&v44[16] = *(void *)(a2 + 16);
        }
        ctu::path_join_impl();
        sub_1007E5E08((uint64_t)buf, a1, (char *)v44);
        if ((char)v44[23] < 0) {
          operator delete(*(void **)v44);
        }
        if (v53)
        {
          long long v31 = v49;
          *(_OWORD *)uint64_t v43 = v49;
          double v32 = *v7;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v44 = 134218240;
            *(void *)&v44[4] = v31;
            *(_WORD *)&v44[12] = 2048;
            *(void *)&v44[14] = *((void *)&v31 + 1);
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Found User-interaction required XML (-2): [version: %ld, validity: %ld]", v44, 0x16u);
          }
          sub_1002103A4((void *)(a1 + 24), v43, v44);
          long long v33 = *(_OWORD *)v44;
          *(void *)uint64_t v44 = 0;
          *(void *)&v44[8] = 0;
          uint64_t v34 = *(std::__shared_weak_count **)(v36 + 160);
          *(_OWORD *)(v36 + 152) = v33;
          if (v34)
          {
            sub_10004D2C8(v34);
            if (*(void *)&v44[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v44[8]);
            }
          }
          *(void *)(*(void *)(v36 + 152) + 24) = v52;
        }
        sub_10020F460((uint64_t)buf);
        *(_OWORD *)a3 = v36;
LABEL_103:
        sub_10020F460((uint64_t)__p);
        if (SHIBYTE(v38) < 0) {
          operator delete(__dst[0]);
        }
        goto LABEL_105;
      }
      uint64_t v15 = *v7;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
LABEL_55:
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        sub_10020F460((uint64_t)buf);
        if (*((void *)&v36 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v36 + 1));
        }
        goto LABEL_103;
      }
      *(_WORD *)uint64_t v44 = 0;
      long long v16 = "Invalid version for Access control XML";
    }
    else
    {
      uint64_t v15 = *v7;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_55;
      }
      *(_WORD *)uint64_t v44 = 0;
      long long v16 = "Invalid Access control XML";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v16, v44, 2u);
    goto LABEL_55;
  }
  uint64_t v11 = *v7;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v35 = (void *)a2;
    }
    else {
      uint64_t v35 = *(void **)a2;
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v35;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to read XML from directory: %s", __p, 0xCu);
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
LABEL_105:
  if (BYTE8(v40))
  {
    if (SBYTE7(v40) < 0) {
      operator delete(v39[0]);
    }
  }
}

void sub_1007E7258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10020F460((uint64_t)&STACK[0x570]);
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a24)
  {
    if (a23 < 0) {
      operator delete(a18);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1007E7354()
{
}

void sub_1007E735C()
{
}

uint64_t sub_1007E7364(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)long long v25 = 0u;
  long long v26 = 0u;
  sub_1007E41C4(a1, a2, (std::string *)v25);
  if (BYTE8(v26))
  {
    CFDataRef v24 = 0;
    int v6 = *(char *)(a3 + 23);
    if (v6 >= 0) {
      int v7 = (const UInt8 *)a3;
    }
    else {
      int v7 = *(const UInt8 **)a3;
    }
    if (v6 >= 0) {
      CFIndex v8 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      CFIndex v8 = *(void *)(a3 + 8);
    }
    CFDataRef v24 = CFDataCreate(0, v7, v8);
    memset(__dst, 0, sizeof(__dst));
    uint64_t v36 = 0;
    if (!BYTE8(v26)) {
      sub_10016C840();
    }
    if (SBYTE7(v26) < 0)
    {
      sub_10004FC84(__dst, v25[0], (unint64_t)v25[1]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v25;
      uint64_t v36 = v26;
    }
    ctu::path_join_impl();
    char v11 = (*(uint64_t (**)(void, uint8_t *, CFDataRef))(**(void **)(a1 + 64) + 200))(*(void *)(a1 + 64), __dst, v24);
    int v12 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 16);
    if (v11)
    {
      long long v13 = *(NSObject **)v12();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = *(void *)a2;
        }
        uint64_t v15 = *(std::__shared_weak_count **)(a1 + 32);
        long long v22 = *(Registry **)(a1 + 24);
        long long v23 = v15;
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100565060(&v22, (char *)__dst, (uint64_t)__p);
        if (v30 >= 0) {
          long long v16 = __p;
        }
        else {
          long long v16 = *(unsigned char **)__p;
        }
        *(_DWORD *)std::string buf = 136446466;
        uint64_t v32 = v14;
        __int16 v33 = 2082;
        uint64_t v34 = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I XML stored for [%{public}s] : %{public}s", buf, 0x16u);
        if (v30 < 0) {
          operator delete(*(void **)__p);
        }
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      if (!BYTE8(v26)) {
        sub_10016C840();
      }
      uint64_t v10 = sub_1007E3E64(a1, a2, (uint64_t)v25);
    }
    else
    {
      uint64_t v17 = *(NSObject **)v12();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        if (!BYTE8(v26)) {
          sub_10016C840();
        }
        int v20 = v25;
        if (SBYTE7(v26) < 0) {
          int v20 = (void **)v25[0];
        }
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v21 = a2;
        }
        else {
          uint64_t v21 = *(void *)a2;
        }
        *(_DWORD *)std::string __p = 136446466;
        *(void *)&__p[4] = v20;
        __int16 v28 = 2082;
        uint64_t v29 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to store to folder: [%{public}s] for server: [%{public}s]", __p, 0x16u);
      }
      uint64_t v10 = 0;
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)__dst);
    }
    sub_100030068((const void **)&v24);
  }
  else
  {
    int v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v19 = a2;
      }
      else {
        uint64_t v19 = *(void *)a2;
      }
      *(_DWORD *)std::string __dst = 136446210;
      *(void *)&__dst[4] = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to find folder for server: [%{public}s]", __dst, 0xCu);
    }
    uint64_t v10 = 0;
  }
  if (BYTE8(v26) && SBYTE7(v26) < 0) {
    operator delete(v25[0]);
  }
  return v10;
}

void sub_1007E771C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (*(char *)(v19 - 57) < 0) {
    operator delete(*(void **)(v19 - 80));
  }
  sub_100030068(&a12);
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1007E7798(uint64_t a1, const char *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v32 = 0;
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
    uint64_t v32 = *(void *)(a1 + 56);
  }
  ctu::path_join_impl();
  CFMutableDictionaryRef v30 = 0;
  CFDictionaryRef theDict = 0;
  (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 64) + 152))(&theDict);
  CFDictionaryRef v4 = theDict;
  if (theDict) {
    int v5 = sub_100080778;
  }
  else {
    int v5 = 0;
  }
  if (v5)
  {
    if (a2[23] >= 0) {
      int v6 = a2;
    }
    else {
      int v6 = *(const char **)a2;
    }
    ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, v6);
    int v7 = (unsigned int *)CFDictionaryGetValue(v4, *(const void **)key);
    CFIndex v8 = v7;
    LODWORD(value) = 0;
    if (v7)
    {
      CFTypeID v9 = CFGetTypeID(v7);
      if (v9 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&value, v8, v10);
      }
    }
    int v11 = (int)value;
    ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)key);
    unsigned int v12 = v11 + 1;
    if ((v11 + 1) >= 5)
    {
      long long v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (a2[23] >= 0) {
          uint64_t v14 = a2;
        }
        else {
          uint64_t v14 = *(const char **)a2;
        }
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Forbidden-rety-count has reached maximum for: %{public}s", key, 0xCu);
      }
      unsigned int v12 = 5;
    }
    CFAllocatorRef v15 = kCFAllocatorDefault;
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    CFMutableDictionaryRef v17 = v30;
    CFMutableDictionaryRef v30 = MutableCopy;
    *(void *)key = v17;
    sub_10005717C((const void **)key);
  }
  else
  {
    CFAllocatorRef v15 = kCFAllocatorDefault;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v19 = v30;
      CFMutableDictionaryRef v30 = Mutable;
      *(void *)key = v19;
      sub_10005717C((const void **)key);
    }
    unsigned int v12 = 1;
  }
  sub_100057D78((const void **)&theDict);
  CFDictionaryRef theDict = 0;
  *(void *)key = v12;
  CFDictionaryRef v20 = CFNumberCreate(v15, kCFNumberLongLongType, key);
  if (v20)
  {
    CFDictionaryRef v21 = theDict;
    CFDictionaryRef theDict = v20;
    *(void *)key = v21;
    sub_1000570E8((const void **)key);
  }
  value = theDict;
  CFDictionaryRef theDict = 0;
  sub_1000570E8((const void **)&theDict);
  long long v22 = v30;
  if (a2[23] >= 0) {
    long long v23 = a2;
  }
  else {
    long long v23 = *(const char **)a2;
  }
  ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, v23);
  CFDictionarySetValue(v22, *(const void **)key, value);
  ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)key);
  CFDataRef v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      long long v25 = a2;
    }
    else {
      long long v25 = *(const char **)a2;
    }
    *(_DWORD *)key = 136446466;
    *(void *)&key[4] = v25;
    __int16 v35 = 1024;
    LODWORD(v36) = v12;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Storing forbidden-rety-count for: %{public}s as: %u", key, 0x12u);
  }
  if (((*(uint64_t (**)(void, void **, CFMutableDictionaryRef))(**(void **)(a1 + 64) + 184))(*(void *)(a1 + 64), __p, v30) & 1) == 0)
  {
    long long v26 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      long long v27 = __p;
      if (v32 < 0) {
        long long v27 = (void **)__p[0];
      }
      if (a2[23] >= 0) {
        __int16 v28 = a2;
      }
      else {
        __int16 v28 = *(const char **)a2;
      }
      *(_DWORD *)key = 136446466;
      *(void *)&key[4] = v27;
      __int16 v35 = 2082;
      uint64_t v36 = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Failed to store forbidden count to folder %{public}s for server: [%{public}s]", key, 0x16u);
    }
  }
  sub_1000570E8((const void **)&value);
  sub_10005717C((const void **)&v30);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007E7C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, __int16 a18, char a19, char a20)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1007E7CA0(uint64_t a1, uint64_t a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
    uint64_t v15 = *(void *)(a1 + 56);
  }
  ctu::path_join_impl();
  CFDictionaryRef v13 = 0;
  (*(void (**)(const __CFDictionary **__return_ptr))(**(void **)(a1 + 64) + 152))(&v13);
  CFDictionaryRef v4 = v13;
  if (v13) {
    int v5 = sub_100080778;
  }
  else {
    int v5 = 0;
  }
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0) {
      int v6 = (const char *)a2;
    }
    else {
      int v6 = *(const char **)a2;
    }
    ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&key, v6);
    CFDictionaryRef Value = CFDictionaryGetValue(v4, key);
    BOOL v8 = (BOOL)Value;
    unsigned int v16 = 0;
    if (Value)
    {
      CFTypeID v9 = CFGetTypeID(Value);
      if (v9 == CFNumberGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v16, (unsigned int *)v8, v10);
        BOOL v8 = v16 > 4;
      }
      else
      {
        BOOL v8 = 0;
      }
    }
    ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&key);
  }
  else
  {
    BOOL v8 = 0;
  }
  sub_100057D78((const void **)&v13);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return v8;
}

void sub_1007E7DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007E7E38(uint64_t a1, uint64_t *a2)
{
  uint64_t v38 = (uint64_t)&v38;
  uint64_t v39 = &v38;
  uint64_t v40 = 0;
  CFDictionaryRef v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16));
  int v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v6 = a2;
    }
    else {
      int v6 = (uint64_t *)*a2;
    }
    int v7 = *(std::__shared_weak_count **)(a1 + 32);
    uint64_t v36 = *(Registry **)(a1 + 24);
    uint64_t v37 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100565060(&v36, (char *)(a1 + 40), (uint64_t)&__dst);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = p_dst;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Attempting to find %{public}s in: %{public}s", buf, 0x16u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v37) {
      sub_10004D2C8(v37);
    }
  }
  CFTypeID v9 = (void *)(a1 + 40);
  if ((*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64), a1 + 40, &v38, 1))
  {
    CFNumberRef v10 = *v4;
    uint64_t v11 = 0;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 63) < 0) {
        CFTypeID v9 = (void *)*v9;
      }
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Failed to read contents of: %{public}s", (uint8_t *)&__dst, 0xCu);
      uint64_t v11 = 0;
    }
  }
  else
  {
    long long v31 = v4;
    memset(buf, 0, 24);
    for (uint64_t i = v39; i != &v38; uint64_t i = (uint64_t *)i[1])
    {
      ctu::basename();
      CFDictionaryRef v13 = *(_OWORD **)&buf[8];
      if (*(void *)&buf[8] >= *(void *)&buf[16])
      {
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
        unint64_t v16 = v15 + 1;
        if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_1000D8578();
        }
        if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v16) {
          unint64_t v16 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v16;
        }
        uint64_t v47 = &buf[16];
        if (v17) {
          long long v18 = (char *)sub_10004812C((uint64_t)&buf[16], v17);
        }
        else {
          long long v18 = 0;
        }
        std::string::size_type v19 = (std::string::size_type)&v18[24 * v15];
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
        __dst.__r_.__value_.__l.__size_ = v19;
        char v46 = &v18[24 * v17];
        long long v20 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v19 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)std::string::size_type v19 = v20;
        memset(&__p, 0, sizeof(__p));
        __dst.__r_.__value_.__r.__words[2] = v19 + 24;
        sub_100048204((uint64_t *)buf, &__dst);
        uint64_t v21 = *(void *)&buf[8];
        sub_100048174((uint64_t)&__dst);
        *(void *)&buf[8] = v21;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        long long v14 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(*(void *)&buf[8] + 16) = *((void *)&__p.__r_.__value_.__l + 2);
        *CFDictionaryRef v13 = v14;
        *(void *)&buf[8] = (char *)v13 + 24;
      }
    }
    long long v22 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100062B40(*(std::string **)buf, *(std::string **)&buf[8], ", ", 2uLL, &__dst);
      long long v23 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__dst
          : (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Available files/dirs: %{public}s", (uint8_t *)&__p, 0xCu);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    CFDataRef v24 = v39;
    if (v39 == &v38)
    {
LABEL_72:
      uint64_t v11 = 0;
    }
    else
    {
      while (1)
      {
        memset(&__dst, 0, sizeof(__dst));
        if (*((char *)v24 + 39) < 0) {
          sub_10004FC84(&__dst, (void *)v24[2], v24[3]);
        }
        else {
          std::string __dst = *(std::string *)(v24 + 2);
        }
        long long v25 = (__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__dst
            : (std::string *)__dst.__r_.__value_.__r.__words[0];
        if ((*(uint64_t (**)(void, std::string *))(**(void **)(a1 + 64) + 224))(*(void *)(a1 + 64), v25))
        {
          memset(&__p, 0, sizeof(__p));
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = __dst;
          }
          ctu::path_join_impl();
          if ((*(unsigned int (**)(void, std::string *))(**(void **)(a1 + 64) + 88))(*(void *)(a1 + 64), &__p))
          {
            long long v27 = *v31;
            if (os_log_type_enabled(*v31, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v28 = *(std::__shared_weak_count **)(a1 + 32);
              uint64_t v32 = *(Registry **)(a1 + 24);
              __int16 v33 = v28;
              if (v28) {
                atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_100565060(&v32, (char *)&__p, (uint64_t)v34);
              if (v35 >= 0) {
                uint64_t v29 = v34;
              }
              else {
                uint64_t v29 = (void **)v34[0];
              }
              *(_DWORD *)BOOL v41 = 136446210;
              __int16 v42 = v29;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Server was provisioned: %{public}s", v41, 0xCu);
              if (v35 < 0) {
                operator delete(v34[0]);
              }
              if (v33) {
                sub_10004D2C8(v33);
              }
            }
            int v26 = 1;
          }
          else
          {
            int v26 = 0;
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          int v26 = 12;
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (v26 != 12 && v26) {
          break;
        }
        CFDataRef v24 = (uint64_t *)v24[1];
        if (v24 == &v38) {
          goto LABEL_72;
        }
      }
      uint64_t v11 = 1;
    }
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
    sub_100047F64((void ***)&__dst);
  }
  sub_1001257B0(&v38);
  return v11;
}

void sub_1007E8450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,char a32)
{
  std::string __p = &a32;
  sub_100047F64((void ***)&__p);
  sub_1001257B0(&a20);
  _Unwind_Resume(a1);
}

uint64_t sub_1007E8510(uint64_t a1)
{
  sub_100058DB0(__p, "Config_refresh.xml");
  uint64_t v2 = sub_1007E7E38(a1, (uint64_t *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_1007E856C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007E8588(uint64_t a1)
{
  sub_100058DB0(__p, "Config.xml");
  uint64_t v2 = sub_1007E7E38(a1, (uint64_t *)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_1007E85E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1007E8600(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  if (*((unsigned char *)a2 + 48))
  {
    long long v3 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v3;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  *(void *)(a1 + 56) = *((void *)a2 + 7);
  CFDictionaryRef v4 = a2 + 4;
  uint64_t v5 = *((void *)a2 + 8);
  *(void *)(a1 + 64) = v5;
  uint64_t v6 = a1 + 64;
  uint64_t v7 = *((void *)a2 + 9);
  *(void *)(a1 + 72) = v7;
  if (v7)
  {
    *(void *)(v5 + 16) = v6;
    *((void *)a2 + 7) = v4;
    void *v4 = 0;
    *((void *)a2 + 9) = 0;
  }
  else
  {
    *(void *)(a1 + 56) = v6;
  }
  *(void *)(a1 + 80) = *((void *)a2 + 10);
  BOOL v8 = (void *)a2 + 11;
  uint64_t v9 = *((void *)a2 + 11);
  *(void *)(a1 + 88) = v9;
  uint64_t v10 = a1 + 88;
  uint64_t v11 = *((void *)a2 + 12);
  *(void *)(a1 + 96) = v11;
  if (v11)
  {
    *(void *)(v9 + 16) = v10;
    *((void *)a2 + 10) = v8;
    void *v8 = 0;
    *((void *)a2 + 12) = 0;
  }
  else
  {
    *(void *)(a1 + 80) = v10;
  }
  long long v12 = *(long long *)((char *)a2 + 104);
  *(void *)(a1 + 120) = *((void *)a2 + 15);
  *(_OWORD *)(a1 + 104) = v12;
  *((void *)a2 + 14) = 0;
  *((void *)a2 + 15) = 0;
  *((void *)a2 + 13) = 0;
  long long v13 = a2[8];
  *(void *)(a1 + 144) = *((void *)a2 + 18);
  *(_OWORD *)(a1 + 128) = v13;
  *((void *)a2 + 17) = 0;
  *((void *)a2 + 18) = 0;
  *((void *)a2 + 16) = 0;
  long long v14 = *(long long *)((char *)a2 + 152);
  *(void *)(a1 + 168) = *((void *)a2 + 21);
  *(_OWORD *)(a1 + 152) = v14;
  long long v15 = a2[11];
  *(void *)(a1 + 192) = *((void *)a2 + 24);
  *(_OWORD *)(a1 + 176) = v15;
  *((void *)a2 + 22) = 0;
  *((void *)a2 + 23) = 0;
  *((void *)a2 + 24) = 0;
  long long v16 = *(long long *)((char *)a2 + 200);
  *(void *)(a1 + 216) = *((void *)a2 + 27);
  *(_OWORD *)(a1 + 200) = v16;
  *((void *)a2 + 25) = 0;
  *((void *)a2 + 26) = 0;
  *((void *)a2 + 27) = 0;
  long long v17 = a2[14];
  *(void *)(a1 + 240) = *((void *)a2 + 30);
  *(_OWORD *)(a1 + 224) = v17;
  *((void *)a2 + 28) = 0;
  *((void *)a2 + 29) = 0;
  *((void *)a2 + 30) = 0;
  long long v18 = *(long long *)((char *)a2 + 248);
  *(void *)(a1 + 264) = *((void *)a2 + 33);
  *(_OWORD *)(a1 + 248) = v18;
  *((void *)a2 + 31) = 0;
  *((void *)a2 + 32) = 0;
  *((void *)a2 + 33) = 0;
  long long v19 = a2[17];
  *(void *)(a1 + 288) = *((void *)a2 + 36);
  *(_OWORD *)(a1 + 272) = v19;
  *((void *)a2 + 34) = 0;
  *((void *)a2 + 35) = 0;
  *((void *)a2 + 36) = 0;
  long long v20 = *(long long *)((char *)a2 + 296);
  *(void *)(a1 + 312) = *((void *)a2 + 39);
  *(_OWORD *)(a1 + 296) = v20;
  *((void *)a2 + 37) = 0;
  *((void *)a2 + 38) = 0;
  *((void *)a2 + 39) = 0;
  long long v21 = a2[20];
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  *(_OWORD *)(a1 + 320) = v21;
  *((void *)a2 + 40) = 0;
  *((void *)a2 + 41) = 0;
  *((void *)a2 + 42) = 0;
  long long v22 = *(long long *)((char *)a2 + 344);
  *(void *)(a1 + 360) = *((void *)a2 + 45);
  *(_OWORD *)(a1 + 344) = v22;
  *((void *)a2 + 43) = 0;
  *((void *)a2 + 44) = 0;
  *((void *)a2 + 45) = 0;
  long long v23 = a2[23];
  *(void *)(a1 + 384) = *((void *)a2 + 48);
  *(_OWORD *)(a1 + 368) = v23;
  *((void *)a2 + 46) = 0;
  *((void *)a2 + 47) = 0;
  *((void *)a2 + 48) = 0;
  long long v24 = *(long long *)((char *)a2 + 392);
  *(void *)(a1 + 408) = *((void *)a2 + 51);
  *(_OWORD *)(a1 + 392) = v24;
  *((void *)a2 + 49) = 0;
  *((void *)a2 + 50) = 0;
  *((void *)a2 + 51) = 0;
  long long v25 = a2[26];
  *(void *)(a1 + 432) = *((void *)a2 + 54);
  *(_OWORD *)(a1 + 416) = v25;
  *((void *)a2 + 52) = 0;
  *((void *)a2 + 53) = 0;
  *((void *)a2 + 54) = 0;
  long long v26 = *(long long *)((char *)a2 + 440);
  *(void *)(a1 + 456) = *((void *)a2 + 57);
  *(_OWORD *)(a1 + 440) = v26;
  *((void *)a2 + 55) = 0;
  *((void *)a2 + 56) = 0;
  *((void *)a2 + 57) = 0;
  long long v27 = a2[29];
  *(void *)(a1 + 480) = *((void *)a2 + 60);
  *(_OWORD *)(a1 + 464) = v27;
  *((void *)a2 + 58) = 0;
  *((void *)a2 + 59) = 0;
  *((void *)a2 + 60) = 0;
  __n128 result = *(__n128 *)((char *)a2 + 488);
  long long v29 = *(long long *)((char *)a2 + 504);
  *(_WORD *)(a1 + 520) = *((_WORD *)a2 + 260);
  *(__n128 *)(a1 + 488) = result;
  *(_OWORD *)(a1 + 504) = v29;
  return result;
}

__n128 sub_1007E8870(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(__n128 *)a1 = result;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  if (*(unsigned char *)(a2 + 112))
  {
    long long v3 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v3;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 24) = 0;
    long long v4 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v4;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 48) = 0;
    __n128 result = *(__n128 *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(__n128 *)(a1 + 72) = result;
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 72) = 0;
    uint64_t v5 = *(void *)(a2 + 96);
    *(_WORD *)(a1 + 104) = *(_WORD *)(a2 + 104);
    *(void *)(a1 + 96) = v5;
    *(unsigned char *)(a1 + 112) = 1;
  }
  *(unsigned char *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 256) = 0;
  if (*(unsigned char *)(a2 + 256))
  {
    long long v6 = *(_OWORD *)(a2 + 120);
    *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v6;
    long long v7 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)(a1 + 144) = v7;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 144) = 0;
    long long v8 = *(_OWORD *)(a2 + 168);
    *(void *)(a1 + 184) = *(void *)(a2 + 184);
    *(_OWORD *)(a1 + 168) = v8;
    *(void *)(a2 + 176) = 0;
    *(void *)(a2 + 184) = 0;
    *(void *)(a2 + 168) = 0;
    long long v9 = *(_OWORD *)(a2 + 192);
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    *(_OWORD *)(a1 + 192) = v9;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 200) = 0;
    *(void *)(a2 + 208) = 0;
    long long v10 = *(_OWORD *)(a2 + 216);
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    *(_OWORD *)(a1 + 216) = v10;
    *(void *)(a2 + 216) = 0;
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 232) = 0;
    __n128 result = *(__n128 *)(a2 + 240);
    *(__n128 *)(a1 + 240) = result;
    *(unsigned char *)(a1 + 256) = 1;
  }
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 360) = 0;
  if (*(unsigned char *)(a2 + 360))
  {
    long long v11 = *(_OWORD *)(a2 + 264);
    long long v12 = *(_OWORD *)(a2 + 280);
    *(_WORD *)(a1 + 296) = *(_WORD *)(a2 + 296);
    *(_OWORD *)(a1 + 264) = v11;
    *(_OWORD *)(a1 + 280) = v12;
    __n128 result = *(__n128 *)(a2 + 304);
    *(void *)(a1 + 320) = *(void *)(a2 + 320);
    *(__n128 *)(a1 + 304) = result;
    *(void *)(a2 + 312) = 0;
    *(void *)(a2 + 320) = 0;
    *(void *)(a2 + 304) = 0;
    *(unsigned char *)(a1 + 328) = 0;
    *(unsigned char *)(a1 + 352) = 0;
    if (*(unsigned char *)(a2 + 352))
    {
      __n128 result = *(__n128 *)(a2 + 328);
      *(void *)(a1 + 344) = *(void *)(a2 + 344);
      *(__n128 *)(a1 + 328) = result;
      *(void *)(a2 + 336) = 0;
      *(void *)(a2 + 344) = 0;
      *(void *)(a2 + 328) = 0;
      *(unsigned char *)(a1 + 352) = 1;
    }
    *(unsigned char *)(a1 + 360) = 1;
  }
  *(unsigned char *)(a1 + 368) = 0;
  *(unsigned char *)(a1 + 408) = 0;
  if (*(unsigned char *)(a2 + 408))
  {
    long long v13 = *(_OWORD *)(a2 + 368);
    *(void *)(a1 + 384) = *(void *)(a2 + 384);
    *(_OWORD *)(a1 + 368) = v13;
    *(void *)(a2 + 376) = 0;
    *(void *)(a2 + 384) = 0;
    *(void *)(a2 + 368) = 0;
    __n128 result = *(__n128 *)(a2 + 392);
    *(__n128 *)(a1 + 392) = result;
    *(unsigned char *)(a1 + 408) = 1;
  }
  return result;
}

void sub_1007E8A54()
{
}

uint64_t sub_1007E8A68(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_1007E8A70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v7 = operator new(0x28uLL);
  *long long v7 = a2;
  v7[1] = a3;
  long long v8 = v7 + 2;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long v8 = *(_OWORD *)a4;
    v7[4] = *(void *)(a4 + 16);
  }
  return v7;
}

void sub_1007E8AD8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1007E8AEC(void **a1, uint64_t **a2, unint64_t a3)
{
  long long v3 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      uint64_t v5 = *a2;
      if ((int)(sub_100046FE8(*a2 + 2, a1 + 2) << 24) >= 1)
      {
        uint64_t v6 = *v5;
        *(void *)(v6 + 8) = v5[1];
        *(void *)v5[1] = v6;
        long long v7 = *v3;
        v7[1] = v5;
        uint64_t *v5 = (uint64_t)v7;
        *long long v3 = v5;
        v5[1] = (uint64_t)v3;
        return v5;
      }
    }
    else
    {
      unint64_t v9 = a3 >> 1;
      unint64_t v10 = (a3 >> 1) + 1;
      long long v11 = a1;
      do
      {
        long long v11 = (void **)v11[1];
        --v10;
      }
      while (v10 > 1);
      uint64_t v12 = sub_1007E8AEC(a1, v11, a3 >> 1);
      long long v3 = (void **)sub_1007E8AEC(v11, a2, a3 - v9);
      if ((int)(sub_100046FE8(v3 + 2, (void **)(v12 + 16)) << 24) < 1)
      {
        long long v14 = *(void ***)(v12 + 8);
        uint64_t i = v3;
        long long v3 = (void **)v12;
      }
      else
      {
        for (uint64_t i = (void **)v3[1]; i != (void **)a2; uint64_t i = (void **)i[1])
        {
          if ((int)(sub_100046FE8(i + 2, (void **)(v12 + 16)) << 24) < 1) {
            goto LABEL_14;
          }
        }
        uint64_t i = (void **)a2;
LABEL_14:
        long long v15 = (void **)*i;
        long long v16 = *v3;
        v16[1] = *((void *)*i + 1);
        *v15[1] = v16;
        long long v17 = *(void **)v12;
        long long v14 = *(void ***)(v12 + 8);
        v17[1] = v3;
        *long long v3 = v17;
        *(void *)uint64_t v12 = v15;
        v15[1] = (void *)v12;
      }
      if (v14 != i && i != (void **)a2)
      {
        long long v18 = i;
        do
        {
          if ((int)(sub_100046FE8(i + 2, v14 + 2) << 24) < 1)
          {
            long long v14 = (void **)v14[1];
          }
          else
          {
            for (j = (void **)i[1]; j != (void **)a2; j = (void **)j[1])
            {
              if ((int)(sub_100046FE8(j + 2, v14 + 2) << 24) < 1) {
                goto LABEL_24;
              }
            }
            j = (void **)a2;
LABEL_24:
            long long v20 = (void **)*j;
            long long v21 = *i;
            v21[1] = *((void *)*j + 1);
            *v20[1] = v21;
            if (v18 == i) {
              long long v18 = j;
            }
            long long v23 = *v14;
            long long v22 = (void **)v14[1];
            v23[1] = i;
            uint64_t *i = v23;
            const char *v14 = v20;
            v20[1] = v14;
            long long v14 = v22;
            uint64_t i = j;
          }
        }
        while (v14 != v18 && i != (void **)a2);
      }
    }
  }
  return (uint64_t *)v3;
}

uint64_t sub_1007E8D04(unsigned __int8 **a1, _DWORD *a2)
{
  long long v3 = *a1;
  long long v2 = a1[1];
  if (*a1 == v2) {
    return 0;
  }
  int v5 = *v3;
  if (v5 == 45 || v5 == 43) {
    *a1 = ++v3;
  }
  v7[0] = 0;
  int v8 = 1;
  unint64_t v9 = a2;
  unint64_t v10 = v3;
  long long v11 = v2;
  uint64_t result = sub_1007E8D8C((uint64_t)v7);
  if (v5 == 45) {
    *a2 = -*a2;
  }
  return result;
}

uint64_t sub_1007E8D8C(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v2 - 1;
  long long v3 = *(_DWORD **)(a1 + 8);
  *long long v3 = 0;
  if (*(void *)(a1 + 16) <= (unint64_t)(v2 - 1))
  {
    int v4 = *(unsigned __int8 *)(v2 - 1);
    if ((v4 - 58) < 0xFFFFFFF6) {
      return 0;
    }
    *long long v3 = v4 - 48;
    *(void *)(a1 + 24) = v2 - 2;
    v30.__locale_ = 0;
    std::locale::locale(&v30);
    uint64_t v6 = std::locale::classic();
    if (std::locale::operator==(&v30, v6))
    {
      uint64_t v1 = sub_1007E903C(a1);
LABEL_45:
      std::locale::~locale(&v30);
      return v1;
    }
    long long v7 = std::locale::use_facet(&v30, &std::numpunct<char>::id);
    ((void (*)(void **__return_ptr))v7->__vftable[1].__on_zero_shared)(&__p);
    if ((char)v29 < 0)
    {
      uint64_t v8 = v28;
      if (!v28) {
        goto LABEL_42;
      }
      p_p = (char *)__p;
    }
    else
    {
      uint64_t v8 = v29;
      if (!v29) {
        goto LABEL_42;
      }
      p_p = (char *)&__p;
    }
    if (*p_p >= 1)
    {
      char v10 = ((uint64_t (*)(const std::locale::facet *))v7->__vftable[1].~facet_0)(v7);
      long long v11 = *(unsigned char **)(a1 + 16);
      uint64_t v12 = *(unsigned char **)(a1 + 24);
      if (v12 >= v11)
      {
        unsigned __int8 v13 = 0;
        long long v14 = __p;
        if ((v29 & 0x80u) == 0) {
          long long v14 = &__p;
        }
        char v15 = *v14 - 1;
        do
        {
          if (v15)
          {
            unsigned int v16 = *(_DWORD *)(a1 + 4);
            if (*(unsigned char *)a1) {
              BOOL v17 = 1;
            }
            else {
              BOOL v17 = v16 > 0x19999999;
            }
            char v18 = v17;
            *(unsigned char *)a1 = v18;
            unsigned int v19 = 10 * v16;
            *(_DWORD *)(a1 + 4) = 10 * v16;
            int v20 = (char)*v12;
            if ((*v12 - 58) < 0xF6u) {
              goto LABEL_47;
            }
            unsigned int v21 = v20 - 48;
            int v22 = (v20 - 48) * v19;
            if (v21)
            {
              if (v18) {
                goto LABEL_47;
              }
              if (((v21 * (unint64_t)v19) & 0xFFFFFFFF00000000) != 0) {
                goto LABEL_47;
              }
              long long v23 = *(_DWORD **)(a1 + 8);
              int v24 = *v23;
              if (__CFADD__(v22, *v23)) {
                goto LABEL_47;
              }
            }
            else
            {
              long long v23 = *(_DWORD **)(a1 + 8);
              int v24 = *v23;
            }
            *long long v23 = v24 + v22;
            --v15;
          }
          else
          {
            if (*v12 != v10) {
              goto LABEL_42;
            }
            if (v12 == v11)
            {
LABEL_47:
              uint64_t v1 = 0;
              goto LABEL_43;
            }
            if (v8 - 1 > (unint64_t)v13) {
              ++v13;
            }
            if ((v29 & 0x80u) == 0) {
              long long v25 = &__p;
            }
            else {
              long long v25 = __p;
            }
            char v15 = v25[v13];
          }
          *(void *)(a1 + 24) = --v12;
        }
        while (v12 >= v11);
      }
      uint64_t v1 = 1;
      goto LABEL_43;
    }
LABEL_42:
    uint64_t v1 = sub_1007E903C(a1);
LABEL_43:
    if ((char)v29 < 0) {
      operator delete(__p);
    }
    goto LABEL_45;
  }
  return v1;
}

void sub_1007E9008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::locale::~locale(&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_1007E903C(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(unsigned char **)(a1 + 24);
  if ((unint64_t)v2 < v1) {
    return 1;
  }
  char v4 = *(unsigned char *)a1 != 0;
  while (1)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 4);
    v4 |= v5 > 0x19999999;
    *(unsigned char *)a1 = v4 & 1;
    unsigned int v6 = 10 * v5;
    *(_DWORD *)(a1 + 4) = 10 * v5;
    int v7 = (char)*v2;
    if ((*v2 - 58) < 0xF6u) {
      break;
    }
    unsigned int v8 = v7 - 48;
    int v9 = (v7 - 48) * v6;
    if (v8)
    {
      if (v4) {
        return 0;
      }
      if (((v8 * (unint64_t)v6) & 0xFFFFFFFF00000000) != 0) {
        return 0;
      }
      char v10 = *(_DWORD **)(a1 + 8);
      int v11 = *v10;
      if (__CFADD__(v9, *v10)) {
        return 0;
      }
    }
    else
    {
      char v10 = *(_DWORD **)(a1 + 8);
      int v11 = *v10;
    }
    *char v10 = v11 + v9;
    *(void *)(a1 + 24) = --v2;
    if ((unint64_t)v2 < v1) {
      return 1;
    }
  }
  return 0;
}

void sub_1007E90F8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_1007E9184(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B440;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E9230(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E924C(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B4C0;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E92F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9310(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v10 = a2;
  int v6 = *(void ***)(a1 + 8);
  int v7 = operator new(0x20uLL);
  *int v7 = off_101A0B540;
  v7[1] = a3;
  void v7[2] = a4;
  v7[3] = &v10;
  v11[3] = v7;
  sub_100043ED0((uint64_t)v11, *v6);
  return sub_100043E48(v11);
}

void sub_1007E93CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

const void **sub_1007E93E8(uint64_t a1, void *a2, ctu **a3, ctu **a4)
{
  int v14 = (int)a2;
  unsigned __int8 v13 = 0;
  ctu::xpc_to_cf((uint64_t *)&v12, *a3, a2);
  sub_10004EFE4(&v13, &v12);
  sub_1000577C4(&v12);
  uint64_t v12 = 0;
  ctu::xpc_to_cf((uint64_t *)&v11, *a4, v6);
  sub_10004EFE4(&v12, &v11);
  sub_1000577C4(&v11);
  int v7 = *(void ***)(a1 + 8);
  unsigned int v16 = 0;
  unsigned int v8 = operator new(0x20uLL);
  void *v8 = off_101A0B5C0;
  v8[1] = &v14;
  _DWORD v8[2] = &v13;
  v8[3] = &v12;
  unsigned int v16 = v8;
  sub_100043ED0((uint64_t)v15, *v7);
  sub_100043E48(v15);
  sub_100057D78(&v12);
  return sub_100057D78(&v13);
}

void sub_1007E9500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  char v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v6 = va_arg(va2, const void *);
  uint64_t v8 = va_arg(va2, void);
  sub_100043E48((uint64_t *)va2);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void *sub_1007E955C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v10 = a2;
  int v6 = *(void ***)(a1 + 8);
  int v7 = operator new(0x20uLL);
  *int v7 = off_101A0B640;
  v7[1] = a3;
  void v7[2] = a4;
  v7[3] = &v10;
  v11[3] = v7;
  sub_100043ED0((uint64_t)v11, *v6);
  return sub_100043E48(v11);
}

void sub_1007E9618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9634(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B6C0;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E96DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E96F8(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B740;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E97A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E97BC(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B7C0;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E9868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9884(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B840;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E992C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9948(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  long long v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A0B8C0;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1007E99F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9A0C(uint64_t a1, int a2, char a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  int v14 = a2;
  char v13 = a3;
  uint64_t v11 = a5;
  uint64_t v12 = a4;
  uint64_t v10 = a6;
  int v6 = *(void ***)(a1 + 8);
  int v7 = operator new(0x30uLL);
  *int v7 = off_101A0B940;
  v7[1] = &v14;
  void v7[2] = &v13;
  v7[3] = &v12;
  char v7[4] = &v11;
  v7[5] = &v10;
  void v15[3] = v7;
  sub_100043ED0((uint64_t)v15, *v6);
  return sub_100043E48(v15);
}

void sub_1007E9AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9B00(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v15 = a3;
  int v16 = a2;
  int v13 = a5;
  int v14 = a4;
  int v11 = a7;
  int v12 = a6;
  int v7 = *(void ***)(a1 + 8);
  uint64_t v8 = operator new(0x38uLL);
  void *v8 = off_101A0B9C0;
  v8[1] = &v15;
  _DWORD v8[2] = &v14;
  v8[3] = &v13;
  void v8[4] = &v12;
  v8[5] = &v11;
  void v8[6] = &v16;
  v17[3] = v8;
  sub_100043ED0((uint64_t)v17, *v7);
  return sub_100043E48(v17);
}

void sub_1007E9BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9BEC(uint64_t a1, int a2, char a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  int v14 = a2;
  char v13 = a3;
  uint64_t v11 = a5;
  uint64_t v12 = a4;
  uint64_t v10 = a6;
  int v6 = *(void ***)(a1 + 8);
  int v7 = operator new(0x30uLL);
  *int v7 = off_101A0BA40;
  v7[1] = &v14;
  void v7[2] = &v13;
  v7[3] = &v12;
  char v7[4] = &v11;
  v7[5] = &v10;
  void v15[3] = v7;
  sub_100043ED0((uint64_t)v15, *v6);
  return sub_100043E48(v15);
}

void sub_1007E9CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9CE0(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  int v12 = a2;
  uint64_t v10 = a4;
  uint64_t v11 = a3;
  uint64_t v9 = a5;
  unsigned int v5 = *(void ***)(a1 + 8);
  int v6 = operator new(0x28uLL);
  *int v6 = off_101A0BAC0;
  v6[1] = &v12;
  v6[2] = &v11;
  v6[3] = &v10;
  v6[4] = &v9;
  v13[3] = v6;
  sub_100043ED0((uint64_t)v13, *v5);
  return sub_100043E48(v13);
}

void sub_1007E9DB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9DCC(uint64_t a1, int a2, int a3, char a4, char a5, char a6)
{
  int v13 = a3;
  int v14 = a2;
  char v12 = a4;
  char v11 = a5;
  char v10 = a6;
  int v6 = *(void ***)(a1 + 8);
  int v7 = operator new(0x30uLL);
  *int v7 = off_101A0BB40;
  v7[1] = &v10;
  void v7[2] = &v11;
  v7[3] = &v12;
  char v7[4] = &v13;
  v7[5] = &v14;
  void v15[3] = v7;
  sub_100043ED0((uint64_t)v15, *v6);
  return sub_100043E48(v15);
}

void sub_1007E9E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1007E9EB4(uint64_t a1, int a2, uint64_t a3)
{
  int v10 = a2;
  unsigned int v5 = *(void ***)(a1 + 8);
  v12[0] = off_101A0BBC0;
  v12[1] = a3;
  v12[2] = &v10;
  v12[3] = v12;
  sub_100043ED0((uint64_t)v12, *v5);
  sub_100043E48(v12);
  int v7 = *(void ***)(a1 + 8);
  v11[0] = off_101A0BC40;
  v11[1] = a3;
  v11[2] = &v10;
  v11[3] = v11;
  sub_100043ED0((uint64_t)v11, *v7);
  return sub_100043E48(v11);
}

void sub_1007E9FB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48(va);
  _Unwind_Resume(a1);
}

void sub_1007E9FE0(uint64_t a1, int a2, uint64_t a3)
{
  char v4 = *(void ***)(a1 + 8);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  int v10 = a2;
  char v12 = 0;
  unsigned int v5 = (char *)operator new(0x28uLL);
  *(void *)unsigned int v5 = off_101A0BCC0;
  int v6 = v5 + 8;
  if (SHIBYTE(v9) < 0)
  {
    sub_10004FC84(v6, __p[0], (unint64_t)__p[1]);
    a2 = v10;
  }
  else
  {
    *(_OWORD *)int v6 = *(_OWORD *)__p;
    *((void *)v5 + 3) = v9;
  }
  *((_DWORD *)v5 + 8) = a2;
  char v12 = v5;
  sub_100043ED0((uint64_t)v11, *v4);
  sub_100043E48(v11);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007EA0FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  operator delete(v17);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1007EA140(CTXPCSMSNotificationInterface *this)
{
  *(void *)this = off_101A0B308;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCSMSNotificationInterface::~CTXPCSMSNotificationInterface(this);
}

void sub_1007EA19C(CTXPCSMSNotificationInterface *this)
{
  *(void *)this = off_101A0B308;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCSMSNotificationInterface::~CTXPCSMSNotificationInterface(this);

  operator delete();
}

void sub_1007EA20C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1007EA274(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 144))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007EA2B0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1007EA2E8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  return result;
}

uint64_t sub_1007EA318(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1007EA360()
{
}

__n128 sub_1007EA374(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B440;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EA3C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B440;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EA3F0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 smsReadyStateChanged:v3 info:**(unsigned __int8 **)(a1 + 16)];
}

void sub_1007EA46C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EA48C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EA4CC()
{
}

void sub_1007EA4DC()
{
}

__n128 sub_1007EA4F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B4C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EA53C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B4C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EA56C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 smsConditionsChanged:v3 changeMask:**(unsigned int **)(a1 + 16)];
}

void sub_1007EA5E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EA608(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EA648()
{
}

void sub_1007EA658()
{
}

__n128 sub_1007EA66C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A0B540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1007EA6C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EA6F8(uint64_t a1, id *a2)
{
  id v8 = *a2;
  long long v3 = *(uint64_t **)(a1 + 8);
  if (*((char *)v3 + 23) < 0) {
    long long v3 = (uint64_t *)*v3;
  }
  id v4 = +[NSString stringWithUTF8String:v3];
  unsigned int v5 = *(uint64_t **)(a1 + 16);
  if (*((char *)v5 + 23) < 0) {
    unsigned int v5 = (uint64_t *)*v5;
  }
  int v6 = +[NSString stringWithUTF8String:v5];
  int v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 24)];
  [v8 smsMessageClass0Received:v7 body:v4 address:v6];
}

void sub_1007EA7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v13 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1007EA804(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EA844()
{
}

void sub_1007EA854()
{
}

__n128 sub_1007EA868(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A0B5C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1007EA8BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B5C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EA8F4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 smsMessageCellBroadcastReceived:v3 notificationDict:**(void **)(a1 + 16) additionalDict:**(void **)(a1 + 24)];
}

void sub_1007EA974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EA994(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EA9D4()
{
}

void sub_1007EA9E4()
{
}

__n128 sub_1007EA9F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A0B640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1007EAA4C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EAA84(uint64_t a1, id *a2)
{
  id v8 = *a2;
  long long v3 = *(uint64_t **)(a1 + 8);
  if (*((char *)v3 + 23) < 0) {
    long long v3 = (uint64_t *)*v3;
  }
  id v4 = +[NSString stringWithUTF8String:v3];
  unsigned int v5 = *(uint64_t **)(a1 + 16);
  if (*((char *)v5 + 23) < 0) {
    unsigned int v5 = (uint64_t *)*v5;
  }
  int v6 = +[NSString stringWithUTF8String:v5];
  int v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 24)];
  [v8 smsMessageTestMessageReceived:v7 body:v4 address:v6];
}

void sub_1007EAB54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v13 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1007EAB90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EABD0()
{
}

void sub_1007EABE0()
{
}

__n128 sub_1007EABF4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B6C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EAC40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B6C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EAC70(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 smsMessageReceived:v3 msgID:**(unsigned int **)(a1 + 16)];
}

void sub_1007EACEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EAD0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EAD4C()
{
}

void sub_1007EAD5C()
{
}

__n128 sub_1007EAD70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EADBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EADEC(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 mmsMessageReceived:v3 msgID:**(unsigned int **)(a1 + 16)];
}

void sub_1007EAE68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EAE88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EAEC8()
{
}

void sub_1007EAED8()
{
}

__n128 sub_1007EAEEC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B7C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EAF38(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B7C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EAF68(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 mmsConfigurationChangedNotification:v3 changed:**(unsigned __int8 **)(a1 + 16)];
}

void sub_1007EAFE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EB004(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EB044()
{
}

void sub_1007EB054()
{
}

__n128 sub_1007EB068(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EB0B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EB0E4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 smsMessageReceivedDeferred:v3 msgID:**(unsigned int **)(a1 + 16)];
}

void sub_1007EB160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EB180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EB1C0()
{
}

void sub_1007EB1D0()
{
}

__n128 sub_1007EB1E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0B8C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EB230(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B8C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EB260(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 mmsMessageReceivedDeferred:v3 msgID:**(unsigned int **)(a1 + 16)];
}

void sub_1007EB2DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EB2FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EB33C()
{
}

void sub_1007EB34C()
{
}

__n128 sub_1007EB360(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A0B940;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_1007EB3BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B940;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EB3FC(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 postSMSMessageSent:v3 success:**(unsigned __int8 **)(a1 + 16) messageID:**(void **)(a1 + 24) err1:**(void **)(a1 + 32) err2:**(void **)(a1 + 40)];
}

void sub_1007EB488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EB4A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EB4E8()
{
}

void sub_1007EB4F8()
{
}

__n128 sub_1007EB50C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = off_101A0B9C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 sub_1007EB568(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0B9C0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EB5A8(unsigned int **a1, id *a2)
{
  id v10 = *a2;
  uint64_t v3 = *a1[1];
  id v4 = objc_opt_new();
  unsigned int v5 = v4;
  if (*a1[2] < 4) {
    objc_msgSend(v4, "setStatusType:");
  }
  int v6 = +[NSNumber numberWithInt:*a1[3]];
  [v5 setRecommendedRetryDelayInSeconds:v6];

  int v7 = +[NSNumber numberWithInt:*a1[4]];
  [v5 setError1:v7];

  id v8 = +[NSNumber numberWithInt:*a1[5]];
  [v5 setError2:v8];

  uint64_t v9 = +[CTXPCPlaceholder simSlot:*a1[6]];
  [v10 smsSent:v9 messageID:v3 info:v5];
}

void sub_1007EB6E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EB724(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EB764()
{
}

void sub_1007EB774()
{
}

__n128 sub_1007EB788(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A0BA40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_1007EB7E4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0BA40;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EB824(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 postMMSMessageSent:v3 success:**(unsigned __int8 **)(a1 + 16) messageID:**(void **)(a1 + 24) err1:**(void **)(a1 + 32) err2:**(void **)(a1 + 40)];
}

void sub_1007EB8B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EB8D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EB910()
{
}

void sub_1007EB920()
{
}

__n128 sub_1007EB934(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0BAC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1007EB988(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0BAC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EB9C0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  long long v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 postMessageProgressNotification:v3 messageID:**(void **)(a1 + 16) totalBytesSent:**(void **)(a1 + 24) dataLength:**(void **)(a1 + 32)];
}

void sub_1007EBA48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EBA68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EBAA8()
{
}

void sub_1007EBAB8()
{
}

__n128 sub_1007EBACC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A0BB40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_1007EBB28(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0BB40;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EBB68(uint64_t a1, id *a2)
{
  id v6 = *a2;
  long long v3 = objc_opt_new();
  [v3 setActivationForMms:**(unsigned __int8 **)(a1 + 8)];
  [v3 setIsDataAttached:**(unsigned __int8 **)(a1 + 16)];
  [v3 setDataActive:**(unsigned __int8 **)(a1 + 24)];
  id v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 32)];
  [v3 setPdpContextId:v4];

  unsigned int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 40)];
  [v6 postMmsDataActivationFailed:v5 failureNotification:v3];
}

void sub_1007EBC54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  char v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1007EBC90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EBCD0()
{
}

void sub_1007EBCE0()
{
}

__n128 sub_1007EBCF4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0BBC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EBD40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0BBC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EBD70(uint64_t a1, id *a2)
{
  id v6 = *a2;
  long long v3 = *(uint64_t **)(a1 + 8);
  if (*((char *)v3 + 23) < 0) {
    long long v3 = (uint64_t *)*v3;
  }
  id v4 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v3, +[NSString defaultCStringEncoding]);
  unsigned int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 postSUPLInitNotification:v5 body:v4];
}

void sub_1007EBE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EBE58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EBE98()
{
}

void sub_1007EBEA8()
{
}

__n128 sub_1007EBEBC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A0BC40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1007EBF08(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0BC40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1007EBF38(uint64_t a1, id *a2)
{
  id v7 = *a2;
  long long v3 = *(uint64_t **)(a1 + 8);
  if (*((char *)v3 + 23) < 0)
  {
    long long v3 = (uint64_t *)*v3;
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8);
  }
  else
  {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  unsigned int v5 = +[NSData dataWithBytes:v3 length:v4];
  id v6 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v7 postSUPLInitNotification:v6 data:v5];
}

void sub_1007EBFE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  char v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1007EC010(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EC050()
{
}

uint64_t sub_1007EC05C(uint64_t a1)
{
  *(void *)a1 = off_101A0BCC0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1007EC0AC(uint64_t a1)
{
  *(void *)a1 = off_101A0BCC0;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

char *sub_1007EC11C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0BCC0;
  long long v3 = v2 + 8;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_10004FC84(v3, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)long long v3 = *(_OWORD *)(a1 + 8);
    *((void *)v2 + 3) = *(void *)(a1 + 24);
  }
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
  return v2;
}

void sub_1007EC198(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_1007EC1AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0BCC0;
  __n128 result = (unsigned char *)(a2 + 8);
  if (*(char *)(a1 + 31) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a1 + 8);
    *(void *)(a2 + 24) = *(void *)(a1 + 24);
    *(_OWORD *)__n128 result = v5;
  }
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

void sub_1007EC220(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

void sub_1007EC234(void **__p)
{
  if (*((char *)__p + 31) < 0) {
    operator delete(__p[1]);
  }

  operator delete(__p);
}

void sub_1007EC278(uint64_t a1, id *a2)
{
  id v9 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(char *)(a1 + 31);
  NSStringEncoding v5 = +[NSString defaultCStringEncoding];
  if (v4 >= 0) {
    uint64_t v6 = a1 + 8;
  }
  else {
    uint64_t v6 = v3;
  }
  id v7 = +[NSString stringWithCString:v6 encoding:v5];
  id v8 = +[CTXPCPlaceholder simSlot:*(unsigned int *)(a1 + 32)];
  [v9 postSmscAddressAvailable:v8 smsc:v7];
}

void sub_1007EC338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  char v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1007EC368(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1007EC3A8()
{
}

void sub_1007EC3B4(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v14 = ServiceMap;
  if ((v15 & 0x8000000000000000) != 0)
  {
    int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      unint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v15;
  unsigned int v19 = sub_10004D37C(&v14[1].__m_.__sig, &v23);
  if (!v19)
  {
    uint64_t v20 = 0;
LABEL_9:
    std::mutex::unlock(v14);
    unsigned int v21 = 0;
    char v22 = 1;
    if (!v20) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v20 = v19[3];
  unsigned int v21 = (std::__shared_weak_count *)v19[4];
  if (!v21) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  char v22 = 0;
  if (v20) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, a2, a3, a4, a5, a6);
LABEL_11:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (!v20) {
    *a7 = 0;
  }
}

void sub_1007EC508(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007EC524(Registry **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  int v14 = operator new(8uLL);
  std::string __p = v14;
  void *v14 = a4;
  int v16 = v14 + 1;
  uint64_t v17 = v14 + 1;
  sub_1007EC3B4(a1, a2, a3, (uint64_t)&__p, a5, a6, a7);
  if (__p)
  {
    int v16 = __p;
    operator delete(__p);
  }
}

void sub_1007EC5C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007EC5DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = getuid();
  uint64_t v7 = getgid();
  id v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 24);

  return v8(a1, a2, a3, v6, v7);
}

uint64_t sub_1007EC65C(uint64_t a1, const char *a2, uint64_t a3, uid_t a4, gid_t a5)
{
  return sub_1007EC674(a2, a3, a4, a5, 0);
}

uint64_t sub_1007EC674(const char *a1, uint64_t a2, uid_t a3, gid_t a4, int a5)
{
  memset(&v25, 0, sizeof(v25));
  uint64_t v10 = stat(a1, &v25);
  if ((v10 & 0x80000000) == 0)
  {
    id v11 = [objc_alloc((Class)NSMutableString) initWithUTF8String:a1];
    id v12 = [objc_alloc((Class)NSMutableString) initWithUTF8String:a2];
    int v13 = +[NSFileManager defaultManager];
    char v24 = 0;
    if (![v13 fileExistsAtPath:v12 isDirectory:&v24])
    {
      if (a5)
      {
        unint64_t v23 = 0;
        unsigned __int8 v17 = [v13 copyItemAtPath:v11 toPath:v12 error:&v23];
        unsigned int v18 = v23;
      }
      else
      {
        chown(a1, a3, a4);
        char v22 = 0;
        unsigned __int8 v17 = [v13 moveItemAtPath:v11 toPath:v12 error:&v22];
        unsigned int v18 = v22;
      }
      id v19 = v18;
      uint64_t v20 = v19;
      if ((v17 & 1) == 0)
      {
        if (v19) {
          uint64_t v10 = (uint64_t)[v19 code];
        }
        else {
          uint64_t v10 = 5;
        }
      }

      goto LABEL_25;
    }
    if (v24)
    {
      bzero(__dst, 0x400uLL);
      strlcpy(__dst, a1, 0x400uLL);
      int v14 = +[NSString stringWithUTF8String:basename(__dst)];
      [v12 appendFormat:@"/%@", v14];

      unsigned int v15 = [v13 fileExistsAtPath:v12 isDirectory:&v24];
      if (v24) {
        unsigned int v16 = 0;
      }
      else {
        unsigned int v16 = v15;
      }
      if (v16 == 1) {
        [v13 removeItemAtPath:v12 error:0];
      }
      if ((a5 & 1) == 0) {
        chown(a1, a3, a4);
      }
    }
    else
    {
      if ((v25.st_mode & 0x4000) != 0)
      {
        uint64_t v10 = 17;
        goto LABEL_25;
      }
      [v13 removeItemAtPath:v12 error:0];
      if ((a5 & 1) == 0) {
        chown(a1, a3, a4);
      }
    }
    sub_1007EF000(v13, v11, v12, a5);
LABEL_25:
  }
  return v10;
}

void sub_1007EC91C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EC968(uint64_t a1, const char *a2, uint64_t a3)
{
  uid_t v5 = getuid();
  gid_t v6 = getgid();

  return sub_1007EC674(a2, a3, v5, v6, 1);
}

uint64_t sub_1007EC9C4(uint64_t a1, const void **a2, const void **a3, uint64_t a4)
{
  uint64_t v37 = &off_101A0BD40;
  if ((sub_1007ECCD4(a1, (uint64_t *)a3) & 1) != 0
    || (*((char *)a3 + 23) >= 0 ? (uint64_t v8 = (uint64_t)a3) : (uint64_t v8 = (uint64_t)*a3),
        !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, v8, 493, 1)))
  {
    if (*((char *)a2 + 23) >= 0) {
      size_t v10 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v10 = (size_t)a2[1];
    }
    memset(&v34, 0, sizeof(v34));
    id v11 = &v34;
    sub_1000C140C((uint64_t)&v34, v10 + 1);
    if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      id v11 = (std::string *)v34.__r_.__value_.__r.__words[0];
    }
    if (v10)
    {
      if (*((char *)a2 + 23) >= 0) {
        id v12 = a2;
      }
      else {
        id v12 = *a2;
      }
      memmove(v11, v12, v10);
    }
    *(_WORD *)((char *)&v11->__r_.__value_.__l.__data_ + v10) = 47;
    int v13 = *(char *)(a4 + 23);
    if (v13 >= 0) {
      int v14 = (const std::string::value_type *)a4;
    }
    else {
      int v14 = *(const std::string::value_type **)a4;
    }
    if (v13 >= 0) {
      std::string::size_type v15 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      std::string::size_type v15 = *(void *)(a4 + 8);
    }
    unsigned int v16 = std::string::append(&v34, v14, v15);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    int64_t v36 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)char v35 = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (v36 >= 0) {
      unsigned int v18 = v35;
    }
    else {
      unsigned int v18 = (void **)v35[0];
    }
    if (*((char *)a3 + 23) >= 0) {
      size_t v19 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      size_t v19 = (size_t)a3[1];
    }
    memset(&v31, 0, sizeof(v31));
    uint64_t v20 = &v31;
    sub_1000C140C((uint64_t)&v31, v19 + 1);
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v20 = (std::string *)v31.__r_.__value_.__r.__words[0];
    }
    if (v19)
    {
      if (*((char *)a3 + 23) >= 0) {
        unsigned int v21 = a3;
      }
      else {
        unsigned int v21 = *a3;
      }
      memmove(v20, v21, v19);
    }
    *(_WORD *)((char *)&v20->__r_.__value_.__l.__data_ + v19) = 47;
    int v22 = *(char *)(a4 + 23);
    if (v22 >= 0) {
      unint64_t v23 = (const std::string::value_type *)a4;
    }
    else {
      unint64_t v23 = *(const std::string::value_type **)a4;
    }
    if (v22 >= 0) {
      std::string::size_type v24 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      std::string::size_type v24 = *(void *)(a4 + 8);
    }
    stat v25 = std::string::append(&v31, v23, v24);
    long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    int64_t v33 = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    if (v33 >= 0) {
      long long v27 = __p;
    }
    else {
      long long v27 = (void **)__p[0];
    }
    uid_t v28 = getuid();
    gid_t v29 = getgid();
    uint64_t v9 = sub_1007EC674((const char *)v18, (uint64_t)v27, v28, v29, 1);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(v35[0]);
    }
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v34.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v9 = 0xFFFFFFFFLL;
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v37);
  return v9;
}

void sub_1007ECC5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)(v33 - 64));
  _Unwind_Resume(a1);
}

id sub_1007ECCD4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = +[NSFileManager defaultManager];
  if (*((char *)a2 + 23) >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = (uint64_t *)*a2;
  }
  uid_t v5 = +[NSString stringWithUTF8String:v4];
  id v6 = [v3 fileExistsAtPath:v5];

  return v6;
}

void sub_1007ECD50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007ECD70(int a1, char *a2, unsigned int a3, char a4)
{
  if (a4)
  {
    id v6 = objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v7 = +[NSNumber numberWithUnsignedLong:a3];
    [v6 setValue:v7 forKey:NSFilePosixPermissions];

    uint64_t v8 = sub_1007ECE44((uint64_t)a2, v6);
    return v8;
  }
  else
  {
    return chmod(a2, a3);
  }
}

void sub_1007ECE24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007ECE44(uint64_t a1, void *a2)
{
  id v21 = a2;
  int v22 = +[NSFileManager defaultManager];
  uint64_t v3 = +[NSString stringWithUTF8String:a1];
  char v26 = 0;
  if ([v22 fileExistsAtPath:v3 isDirectory:&v26])
  {
    if (v26)
    {
      uint64_t v20 = [v22 subpathsOfDirectoryAtPath:v3 error:0];
      int v4 = [v20 objectEnumerator];
      uint64_t v5 = 0;
      id v6 = 0;
      for (uint64_t i = 0; ; uint64_t i = (void *)v8)
      {
        uint64_t v8 = [v4 nextObject];

        if (!v8) {
          break;
        }
        uint64_t v9 = +[NSString stringWithFormat:@"%@/%@", v3, v8];
        id v25 = v6;
        unsigned __int8 v10 = [v22 setAttributes:v21 ofItemAtPath:v9 error:&v25];
        id v11 = v25;

        if (v11) {
          char v12 = v10;
        }
        else {
          char v12 = 1;
        }
        if ((v12 & 1) == 0) {
          uint64_t v5 = (uint64_t)[v11 code];
        }

        id v6 = v11;
      }
      id v24 = v6;
      unsigned __int8 v13 = [v22 setAttributes:v21 ofItemAtPath:v3 error:&v24];
      id v14 = v24;

      if (v14) {
        char v15 = v13;
      }
      else {
        char v15 = 1;
      }
      if ((v15 & 1) == 0) {
        uint64_t v5 = (uint64_t)[v14 code];
      }
    }
    else
    {
      id v23 = 0;
      unsigned __int8 v16 = [v22 setAttributes:v21 ofItemAtPath:v3 error:&v23];
      id v17 = v23;
      id v14 = v17;
      if (v17) {
        char v18 = v16;
      }
      else {
        char v18 = 1;
      }
      if (v18) {
        uint64_t v5 = 0;
      }
      else {
        uint64_t v5 = (uint64_t)[v17 code];
      }
    }
  }
  else
  {
    uint64_t v5 = 5;
  }

  return v5;
}

void sub_1007ED05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007ED0E0(int a1, char *a2, uid_t a3, gid_t a4, char a5)
{
  if (a5)
  {
    id v8 = objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v9 = +[NSNumber numberWithUnsignedLong:a3];
    [v8 setValue:v9 forKey:NSFileOwnerAccountID];

    unsigned __int8 v10 = +[NSNumber numberWithUnsignedLong:a4];
    [v8 setValue:v10 forKey:NSFileGroupOwnerAccountID];

    uint64_t v11 = sub_1007ECE44((uint64_t)a2, v8);
    return v11;
  }
  else
  {
    return chown(a2, a3, a4);
  }
}

void sub_1007ED1D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007ED204(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_100058DB0(v12, "");
  sub_100058DB0(__p, "");
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void **, void **, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, v12, __p, a4);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (v13 < 0) {
    operator delete(v12[0]);
  }
  return v8;
}

void sub_1007ED2CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

id sub_1007ED300(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  char v11 = +[NSFileManager defaultManager];
  id v12 = objc_alloc_init((Class)NSMutableDictionary);
  char v13 = +[NSNumber numberWithUnsignedLong:a3];
  [v12 setValue:v13 forKey:NSFilePosixPermissions];

  if (*((char *)a4 + 23) < 0)
  {
    if (!a4[1]) {
      goto LABEL_7;
    }
    a4 = (uint64_t *)*a4;
    goto LABEL_6;
  }
  if (*((unsigned char *)a4 + 23))
  {
LABEL_6:
    id v14 = +[NSString stringWithUTF8String:a4];
    [v12 setValue:v14 forKey:NSFileOwnerAccountName];
  }
LABEL_7:
  if (*((char *)a5 + 23) < 0)
  {
    if (!a5[1]) {
      goto LABEL_13;
    }
    a5 = (uint64_t *)*a5;
    goto LABEL_12;
  }
  if (*((unsigned char *)a5 + 23))
  {
LABEL_12:
    char v15 = +[NSString stringWithUTF8String:a5];
    [v12 setValue:v15 forKey:NSFileGroupOwnerAccountName];
  }
LABEL_13:
  unsigned __int8 v16 = +[NSString stringWithUTF8String:a2];
  id v22 = 0;
  unsigned __int8 v17 = [v11 createDirectoryAtPath:v16 withIntermediateDirectories:a6 attributes:v12 error:&v22];
  id v18 = v22;

  if (v18) {
    char v19 = v17;
  }
  else {
    char v19 = 1;
  }
  if (v19) {
    id v20 = 0;
  }
  else {
    id v20 = [v18 code];
  }

  return v20;
}

void sub_1007ED4BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1007ED50C@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  bzero(__dst, 0x400uLL);
  if (*(char *)(a1 + 23) >= 0) {
    int v4 = (const char *)a1;
  }
  else {
    int v4 = *(const char **)a1;
  }
  strlcpy(__dst, v4, 0x400uLL);
  uint64_t v5 = basename(__dst);
  return sub_100058DB0(a2, v5);
}

void *sub_1007ED5A8@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  bzero(__dst, 0x400uLL);
  if (*(char *)(a1 + 23) >= 0) {
    int v4 = (const char *)a1;
  }
  else {
    int v4 = *(const char **)a1;
  }
  strlcpy(__dst, v4, 0x400uLL);
  uint64_t v5 = dirname(__dst);
  return sub_100058DB0(a2, v5);
}

std::string *sub_1007ED644@<X0>(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  bzero(__s, 0x400uLL);
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  sub_100058DB0(a2, "");
  if (*(char *)(a1 + 23) >= 0) {
    int v4 = (const char *)a1;
  }
  else {
    int v4 = *(const char **)a1;
  }
  __n128 result = (std::string *)realpath_DARWIN_EXTSN(v4, __s);
  if (result) {
    return sub_10003ED78(a2, __s);
  }
  return result;
}

void sub_1007ED6F0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

ssize_t sub_1007ED70C@<X0>(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  bzero(__s, 0x400uLL);
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  if (*(char *)(a1 + 23) >= 0) {
    int v4 = (const char *)a1;
  }
  else {
    int v4 = *(const char **)a1;
  }
  ssize_t result = readlink(v4, __s, 0x3FFuLL);
  if (result != -1)
  {
    __s[result] = 0;
    return (ssize_t)sub_10003ED78(a2, __s);
  }
  return result;
}

void sub_1007ED7B8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007ED7D4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = +[NSFileManager defaultManager];
  if (*((char *)a2 + 23) >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = (uint64_t *)*a2;
  }
  uint64_t v5 = +[NSString stringWithUTF8String:v4];
  id v9 = 0;
  [v3 removeItemAtPath:v5 error:&v9];
  id v6 = v9;

  if (v6) {
    uint64_t v7 = (int)[v6 code];
  }
  else {
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1007ED888(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007ED8B0(uint64_t a1, char *a2, void *a3, int a4)
{
  id v6 = +[NSFileManager defaultManager];
  if (a2[23] >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(char **)a2;
  }
  uint64_t v8 = +[NSString stringWithUTF8String:v7];
  id v36 = 0;
  char v26 = [v6 contentsOfDirectoryAtPath:v8 error:&v36];
  id v25 = v36;

  if (v26)
  {
    sub_1001257B0(a3);
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    id v9 = v26;
    id v10 = [v9 countByEnumeratingWithState:&v32 objects:v38 count:16];
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)v33;
      for (uint64_t i = *(void *)v33; ; uint64_t i = *(void *)v33)
      {
        if (i != v12) {
          objc_enumerationMutation(v9);
        }
        id v14 = *(void **)(*((void *)&v32 + 1) + 8 * v11);
        memset(&__p, 0, sizeof(__p));
        if (a4)
        {
          sub_10060C178((const void **)a2, 47, &v30);
          sub_100058DB0(v28, (char *)[v14 UTF8String]);
          if ((v29 & 0x80u) == 0) {
            char v15 = v28;
          }
          else {
            char v15 = (void **)v28[0];
          }
          if ((v29 & 0x80u) == 0) {
            std::string::size_type v16 = v29;
          }
          else {
            std::string::size_type v16 = (std::string::size_type)v28[1];
          }
          unsigned __int8 v17 = std::string::append(&v30, (const std::string::value_type *)v15, v16);
          std::string::size_type v18 = v17->__r_.__value_.__r.__words[0];
          v37[0] = v17->__r_.__value_.__l.__size_;
          *(void *)((char *)v37 + 7) = *(std::string::size_type *)((char *)&v17->__r_.__value_.__r.__words[1] + 7);
          char v19 = HIBYTE(v17->__r_.__value_.__r.__words[2]);
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          __p.__r_.__value_.__r.__words[0] = v18;
          __p.__r_.__value_.__l.__size_ = v37[0];
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v37 + 7);
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = v19;
          if ((char)v29 < 0) {
            operator delete(v28[0]);
          }
          if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v30.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          sub_10003ED78(&__p, (char *)[v14 UTF8String]);
        }
        id v20 = sub_1007E8A70((uint64_t)a3, 0, 0, (uint64_t)&__p);
        *id v20 = a3;
        id v21 = (void *)a3[1];
        v20[1] = v21;
        *id v21 = v20;
        uint64_t v22 = a3[2] + 1;
        a3[1] = v20;
        a3[2] = v22;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (++v11 >= (unint64_t)v10)
        {
          id v10 = [v9 countByEnumeratingWithState:&v32 objects:v38 count:16];
          if (!v10) {
            break;
          }
          uint64_t v11 = 0;
        }
      }
    }
  }
  if (v25) {
    uint64_t v23 = (int)[v25 code];
  }
  else {
    uint64_t v23 = 0;
  }

  return v23;
}

void sub_1007EDB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EDC20(uint64_t a1, const void **a2, const void **a3, const void **a4)
{
  uint64_t v29 = (uint64_t)&v29;
  std::string v30 = &v29;
  uint64_t v31 = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, const void **, uint64_t *, void))(*(void *)a1 + 96))(a1, a3, &v29, 0);
  if (!v8)
  {
    id v10 = v30;
    if (v30 == &v29)
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      do
      {
        __dst[0] = 0;
        __dst[1] = 0;
        uint64_t v28 = 0;
        if (*((char *)v10 + 39) < 0)
        {
          sub_10004FC84(__dst, (void *)v10[2], v10[3]);
        }
        else
        {
          *(_OWORD *)std::string __dst = *((_OWORD *)v10 + 1);
          uint64_t v28 = v10[4];
        }
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v26 = 0;
        v23[0] = 0;
        v23[1] = 0;
        uint64_t v24 = 0;
        int v11 = *((char *)a2 + 23);
        if (v11 >= 0) {
          unint64_t v12 = *((unsigned __int8 *)a2 + 23);
        }
        else {
          unint64_t v12 = (unint64_t)a2[1];
        }
        if (SHIBYTE(v28) < 0)
        {
          if (v12 == -1) {
LABEL_49:
          }
            sub_1000C14D8();
          id v14 = (void **)__dst[0];
          if (__dst[1] >= (void *)v12) {
            size_t v13 = v12;
          }
          else {
            size_t v13 = (size_t)__dst[1];
          }
        }
        else
        {
          if (v12 == -1) {
            goto LABEL_49;
          }
          if (HIBYTE(v28) >= v12) {
            size_t v13 = v12;
          }
          else {
            size_t v13 = HIBYTE(v28);
          }
          id v14 = __dst;
        }
        if (v11 >= 0) {
          char v15 = a2;
        }
        else {
          char v15 = *a2;
        }
        if (!memcmp(v14, v15, v13) && v13 == v12)
        {
          sub_1002055B4(a3, (const void **)__dst, &v21);
          if (SHIBYTE(v26) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)std::string __p = v21;
          uint64_t v26 = v22;
          sub_1002055B4(a4, (const void **)__dst, &v21);
          if (SHIBYTE(v24) < 0) {
            operator delete(v23[0]);
          }
          *(_OWORD *)uint64_t v23 = v21;
          uint64_t v24 = v22;
          if (v26 >= 0) {
            std::string::size_type v18 = __p;
          }
          else {
            std::string::size_type v18 = (void **)__p[0];
          }
          if (v24 >= 0) {
            char v19 = v23;
          }
          else {
            char v19 = (void **)v23[0];
          }
          int v20 = (*(uint64_t (**)(uint64_t, void **, void **))(*(void *)a1 + 16))(a1, v18, v19);
          BOOL v17 = v20 == 0;
          uint64_t v8 = v20;
          if (SHIBYTE(v24) < 0) {
            operator delete(v23[0]);
          }
        }
        else
        {
          BOOL v17 = 1;
        }
        if (SHIBYTE(v26) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v28) < 0) {
          operator delete(__dst[0]);
        }
        if (!v17) {
          break;
        }
        id v10 = (uint64_t *)v10[1];
      }
      while (v10 != &v29);
    }
  }
  sub_1001257B0(&v29);
  return v8;
}

void sub_1007EDEA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_1001257B0((void *)(v32 - 104));
  _Unwind_Resume(a1);
}

uint64_t sub_1007EDEFC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, const CFAllocatorRef, uint64_t))(*(void *)a1 + 160))(a1, kCFAllocatorDefault, a2);
}

const void **sub_1007EDF30@<X0>(CFAllocatorRef allocator@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    id v6 = (const UInt8 *)a2;
  }
  else {
    id v6 = *(const UInt8 **)a2;
  }
  if (v5 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a2 + 8);
  }
  CFURLRef v8 = CFURLCreateFromFileSystemRepresentation(allocator, v6, v7, 0);
  CFURLRef v12 = v8;
  if (v8) {
    id v9 = sub_1000FCC20;
  }
  else {
    id v9 = 0;
  }
  if (v9)
  {
    sub_1007EDFF8((const void **)allocator, v8, &v11);
    sub_10004EFE4(a3, &v11);
    sub_1000577C4(&v11);
  }
  else
  {
    *a3 = 0;
  }
  return sub_1000FE824((const void **)&v12);
}

void sub_1007EDFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_1007EDFF8@<X0>(const void **cf@<X0>, const __CFURL *a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)cf;
    long long v9 = 0u;
    long long v10 = 0u;
    sub_1007EE770(&v9, (const __CFAllocator *)cf, a2);
    if ((void)v9 == *((void *)&v9 + 1))
    {
      *a3 = 0;
    }
    else
    {
      CFDataRef v5 = CFDataCreateWithBytesNoCopy(v4, (const UInt8 *)v9, *((void *)&v9 + 1) - v9, kCFAllocatorNull);
      CFDataRef v8 = v5;
      if (v5) {
        id v6 = sub_10008324C;
      }
      else {
        id v6 = 0;
      }
      if (v6) {
        CFPropertyListRef v7 = CFPropertyListCreateWithData(v4, v5, 0, 0, 0);
      }
      else {
        CFPropertyListRef v7 = 0;
      }
      *a3 = v7;
      sub_100030068((const void **)&v8);
    }
    sub_1007EF3DC((uint64_t)&v9);
    return sub_100711E24((const void **)&v10 + 1);
  }
  else
  {
    *a3 = 0;
  }
  return cf;
}

void sub_1007EE0D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  sub_100030068((const void **)va);
  sub_1007EF3DC((uint64_t)va1);
  sub_100711E24((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_1007EE104(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, const CFAllocatorRef, uint64_t))(*(void *)a1 + 176))(a1, kCFAllocatorDefault, a2);
}

const void **sub_1007EE138@<X0>(CFAllocatorRef allocator@<X1>, uint64_t a2@<X2>, CFDataRef *a3@<X8>)
{
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    id v6 = (const UInt8 *)a2;
  }
  else {
    id v6 = *(const UInt8 **)a2;
  }
  if (v5 >= 0) {
    CFIndex v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    CFIndex v7 = *(void *)(a2 + 8);
  }
  CFURLRef v8 = CFURLCreateFromFileSystemRepresentation(allocator, v6, v7, 0);
  CFURLRef v11 = v8;
  if (v8)
  {
    long long v12 = 0u;
    long long v13 = 0u;
    sub_1007EE770(&v12, allocator, v8);
    if ((void)v12 == *((void *)&v12 + 1)) {
      CFDataRef v9 = 0;
    }
    else {
      CFDataRef v9 = CFDataCreate(allocator, (const UInt8 *)v12, *((void *)&v12 + 1) - v12);
    }
    *a3 = v9;
    sub_1007EF3DC((uint64_t)&v12);
    sub_100711E24((const void **)&v13 + 1);
  }
  else
  {
    *a3 = 0;
  }
  return sub_1000FE824((const void **)&v11);
}

void sub_1007EE1F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  sub_1007EF3DC((uint64_t)va1);
  sub_100711E24((const void **)va2);
  sub_1000FE824((const void **)va);
  _Unwind_Resume(a1);
}

id sub_1007EE220(uint64_t a1, uint64_t *a2, void *a3)
{
  id v3 = a3;
  if (a3)
  {
    if (*((char *)a2 + 23) >= 0) {
      CFAllocatorRef v4 = a2;
    }
    else {
      CFAllocatorRef v4 = (uint64_t *)*a2;
    }
    uint64_t v5 = +[NSString stringWithUTF8String:v4];
    id v3 = [v3 writeToFile:v5 atomically:1];
  }
  return v3;
}

void sub_1007EE284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1007EE294(uint64_t a1, uint64_t *a2, BOOL a3, const void **a4)
{
  BOOL v4 = a3;
  if (a3)
  {
    if (*((char *)a2 + 23) >= 0) {
      id v6 = a2;
    }
    else {
      id v6 = (uint64_t *)*a2;
    }
    uint64_t v7 = +[NSString stringWithUTF8String:v6];
    id v8 = [objc_alloc((Class)NSOutputStream) initToFileAtPath:v7 append:0];
    [v8 open];
    id v12 = 0;
    NSInteger v9 = +[NSPropertyListSerialization writePropertyList:v4 toStream:v8 format:200 options:0 error:&v12];
    id v10 = v12;
    BOOL v4 = v9 != 0;
    if (v10) {
      sub_1007EE3A8(a4, v10);
    }
    [v8 close];
  }
  return v4;
}

void sub_1007EE380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **sub_1007EE3A8(const void **a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  BOOL v4 = *a1;
  *a1 = cf;
  id v6 = v4;
  sub_100127D74(&v6);
  return a1;
}

id sub_1007EE3FC(uint64_t a1, uint64_t *a2, void *a3)
{
  id v3 = a3;
  if (a3)
  {
    if (*((char *)a2 + 23) >= 0) {
      BOOL v4 = a2;
    }
    else {
      BOOL v4 = (uint64_t *)*a2;
    }
    uint64_t v5 = +[NSString stringWithUTF8String:v4];
    id v3 = [v3 writeToFile:v5 atomically:1];
  }
  return v3;
}

void sub_1007EE460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1007EE470(uint64_t a1, uint64_t a2)
{
  memset(&v4, 0, sizeof(v4));
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v2 = (const char *)a2;
  }
  else {
    uint64_t v2 = *(const char **)a2;
  }
  return !lstat(v2, &v4) && (v4.st_mode & 0xF000) == 0xA000;
}

uint64_t sub_1007EE4DC(int a1, const char *a2, char *a3)
{
  uint64_t result = symlink(a3, a2);
  if (result) {
    return *__error();
  }
  return result;
}

BOOL sub_1007EE504(int a1, char *__filename)
{
  uint64_t v2 = fopen(__filename, "w");
  id v3 = v2;
  if (v2) {
    fclose(v2);
  }
  return v3 != 0;
}

uint64_t sub_1007EE548(uint64_t a1, uint64_t a2)
{
  id v3 = +[NSFileManager defaultManager];
  unsigned __int8 v7 = 0;
  id v4 = [objc_alloc((Class)NSMutableString) initWithUTF8String:a2];
  [v3 fileExistsAtPath:v4 isDirectory:&v7];
  uint64_t v5 = v7;

  return v5;
}

void sub_1007EE5C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EE5E4(uint64_t a1, char *a2, uint64_t a3)
{
  memset(&v17, 0, sizeof(v17));
  uint64_t v6 = stat(a2, &v17);
  if ((v6 & 0x80000000) == 0)
  {
    id v7 = [objc_alloc((Class)NSMutableString) initWithUTF8String:a2];
    id v8 = [objc_alloc((Class)NSMutableString) initWithUTF8String:a3];
    NSInteger v9 = +[NSFileManager defaultManager];
    uint64_t v10 = getuid();
    uint64_t v11 = getgid();
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a2, v10, v11, 1);
    id v16 = 0;
    unsigned __int8 v12 = [v9 moveItemAtPath:v7 toPath:v8 error:&v16];
    id v13 = v16;
    id v14 = v13;
    if ((v12 & 1) == 0)
    {
      if (v13) {
        uint64_t v6 = (uint64_t)[v13 code];
      }
      else {
        uint64_t v6 = 5;
      }
    }
  }
  return v6;
}

void sub_1007EE744(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **sub_1007EE770(void *a1, const __CFAllocator *cf, const __CFURL *a3)
{
  CFAllocatorRef v25 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFAllocatorRef v24 = v25;
    CFRetain(v25);
  }
  else
  {
    CFAllocatorRef v24 = 0;
  }
  CFNumberRef v23 = 0;
  uint64_t v22 = 0;
  *(void *)&long long v17 = 0;
  *((void *)&v17 + 1) = &v23;
  error[0] = 0;
  error[1] = (CFErrorRef)&v22;
  int v6 = CFURLCopyResourcePropertyForKey(a3, kCFURLFileSizeKey, &v17, error);
  sub_100128064((const void **)error);
  sub_1007EF43C((const void **)&v17);
  if (v6 && (error[0] = 0, CFNumberGetValue(v23, kCFNumberSInt64Type, error)) && (uint64_t)error[0] > 0)
  {
    id v7 = CFReadStreamCreateWithFile(cf, a3);
    CFReadStreamRef stream = v7;
    if (v7) {
      id v8 = sub_1007EEA34;
    }
    else {
      id v8 = 0;
    }
    if (v8 && CFReadStreamOpen(v7))
    {
      size_t v9 = (size_t)error[0];
      long long v17 = 0uLL;
      CFAllocatorRef v10 = v24;
      std::string::size_type v18 = 0;
      CFTypeRef cfa = v24;
      if (v24) {
        CFRetain(v24);
      }
      if (v9)
      {
        if ((v9 & 0x8000000000000000) != 0) {
          sub_10006A748();
        }
        uint64_t v11 = (char *)CFAllocatorAllocate(v10, v9, 0);
        unsigned __int8 v12 = &v11[v9];
        *(void *)&long long v17 = v11;
        std::string::size_type v18 = &v11[v9];
        bzero(v11, v9);
        *((void *)&v17 + 1) = v12;
        id v13 = (UInt8 *)v17;
      }
      else
      {
        unsigned __int8 v12 = 0;
        id v13 = 0;
      }
      CFIndex v14 = CFReadStreamRead(stream, v13, v12 - (char *)v13);
      CFReadStreamClose(stream);
      char v15 = a1 + 3;
      if (v14 == *((void *)&v17 + 1) - (void)v17)
      {
        *a1 = 0;
        a1[1] = 0;
        a1[2] = 0;
        sub_1007EF3A4(v15, cfa);
        *(_OWORD *)a1 = v17;
        a1[2] = v18;
        std::string::size_type v18 = 0;
        long long v17 = 0uLL;
      }
      else
      {
        *a1 = 0;
        a1[1] = 0;
        a1[2] = 0;
        sub_1007EF3A4(v15, v24);
      }
      sub_1007EF3DC((uint64_t)&v17);
      sub_100711E24(&cfa);
    }
    else
    {
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      sub_1007EF3A4(a1 + 3, v24);
    }
    sub_1007EF408((const void **)&stream);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    sub_1007EF3A4(a1 + 3, v24);
  }
  sub_100127D74(&v22);
  sub_1000570E8((const void **)&v23);
  sub_100711E24((const void **)&v24);
  return sub_100711E24((const void **)&v25);
}

void sub_1007EE9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  size_t v9 = va_arg(va1, const void *);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  sub_100711E24(v6);
  sub_1007EF408((const void **)va);
  sub_100127D74((const void **)va1);
  sub_1000570E8((const void **)(v7 - 56));
  sub_100711E24((const void **)(v7 - 48));
  sub_100711E24((const void **)(v7 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_1007EEA34(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1007EEA3C(uint64_t a1, uint64_t *a2, void *a3)
{
  if (*((char *)a2 + 23) >= 0) {
    id v4 = a2;
  }
  else {
    id v4 = (uint64_t *)*a2;
  }
  uint64_t v5 = +[NSString stringWithCString:v4 encoding:4];
  if (v5)
  {
    int v6 = +[NSFileManager defaultManager];
    id v14 = 0;
    uint64_t v7 = [v6 attributesOfItemAtPath:v5 error:&v14];
    id v8 = v14;
    size_t v9 = v8;
    if (v8)
    {
      uint64_t v10 = (uint64_t)[v8 code];
    }
    else
    {
      uint64_t v11 = [v7 fileModificationDate];
      [v11 timeIntervalSince1970];
      *a3 = v12;

      uint64_t v10 = 0;
    }
  }
  else
  {
    uint64_t v10 = 0xFFFFFFFFLL;
  }

  return v10;
}

void sub_1007EEB28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1007EEB64(uint64_t *a1@<X1>, const void **a2@<X2>, void *a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = (uint64_t *)*a1;
  }
  int v6 = +[NSString stringWithCString:v5 encoding:4];
  uint64_t v7 = +[NSFileManager defaultManager];
  id v10 = 0;
  id v8 = [v7 attributesOfItemAtPath:v6 error:&v10];
  id v9 = v10;
  if (v9) {
    sub_1007EE3A8(a2, v9);
  }
  if (v8)
  {
    *a3 = v8;
    CFRetain(v8);
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1007EEC3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1007EEC58(uint64_t a1, char *a2, void *a3, int a4)
{
  int v6 = +[NSFileManager defaultManager];
  if (a2[23] >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(char **)a2;
  }
  id v8 = +[NSString stringWithUTF8String:v7];
  id v36 = 0;
  uint64_t v26 = [v6 subpathsOfDirectoryAtPath:v8 error:&v36];
  id v25 = v36;

  if (v26)
  {
    sub_1001257B0(a3);
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    id v9 = v26;
    id v10 = [v9 countByEnumeratingWithState:&v32 objects:v38 count:16];
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)v33;
      for (uint64_t i = *(void *)v33; ; uint64_t i = *(void *)v33)
      {
        if (i != v12) {
          objc_enumerationMutation(v9);
        }
        id v14 = *(void **)(*((void *)&v32 + 1) + 8 * v11);
        memset(&__p, 0, sizeof(__p));
        if (a4)
        {
          sub_10060C178((const void **)a2, 47, &v30);
          sub_100058DB0(v28, (char *)[v14 UTF8String]);
          if ((v29 & 0x80u) == 0) {
            char v15 = v28;
          }
          else {
            char v15 = (void **)v28[0];
          }
          if ((v29 & 0x80u) == 0) {
            std::string::size_type v16 = v29;
          }
          else {
            std::string::size_type v16 = (std::string::size_type)v28[1];
          }
          long long v17 = std::string::append(&v30, (const std::string::value_type *)v15, v16);
          std::string::size_type v18 = v17->__r_.__value_.__r.__words[0];
          v37[0] = v17->__r_.__value_.__l.__size_;
          *(void *)((char *)v37 + 7) = *(std::string::size_type *)((char *)&v17->__r_.__value_.__r.__words[1] + 7);
          char v19 = HIBYTE(v17->__r_.__value_.__r.__words[2]);
          v17->__r_.__value_.__l.__size_ = 0;
          v17->__r_.__value_.__r.__words[2] = 0;
          v17->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          __p.__r_.__value_.__r.__words[0] = v18;
          __p.__r_.__value_.__l.__size_ = v37[0];
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v37 + 7);
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = v19;
          if ((char)v29 < 0) {
            operator delete(v28[0]);
          }
          if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v30.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          sub_10003ED78(&__p, (char *)[v14 UTF8String]);
        }
        int v20 = sub_1007E8A70((uint64_t)a3, 0, 0, (uint64_t)&__p);
        *int v20 = a3;
        long long v21 = (void *)a3[1];
        v20[1] = v21;
        *long long v21 = v20;
        uint64_t v22 = a3[2] + 1;
        a3[1] = v20;
        a3[2] = v22;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (++v11 >= (unint64_t)v10)
        {
          id v10 = [v9 countByEnumeratingWithState:&v32 objects:v38 count:16];
          if (!v10) {
            break;
          }
          uint64_t v11 = 0;
        }
      }
    }
  }
  if (v25) {
    uint64_t v23 = (int)[v25 code];
  }
  else {
    uint64_t v23 = 0;
  }

  return v23;
}

void sub_1007EEF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  _Unwind_Resume(a1);
}

void sub_1007EEFC8(FileSystemInterface *a1)
{
  FileSystemInterface::~FileSystemInterface(a1);

  operator delete();
}

void sub_1007EF000(void *a1, void *a2, void *a3, int a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  long long v33 = v9;
  id v34 = v8;
  int v32 = a4;
  if (a4)
  {
    uint64_t v38 = 0;
    unsigned __int8 v10 = [v7 copyItemAtPath:v8 toPath:v9 error:&v38];
  }
  else
  {
    unsigned __int8 v10 = [v7 moveItemAtPath:v8 toPath:v9 error:0];
  }
  if ((v10 & 1) == 0)
  {
    char v37 = 0;
    unsigned __int8 v11 = [v7 fileExistsAtPath:v8 isDirectory:&v37];
    unsigned __int8 v12 = v37 ? 0 : v11;
    if ((v12 & 1) == 0)
    {
      std::string v30 = [v7 subpathsOfDirectoryAtPath:v8 error:0];
      uint64_t v31 = [v30 objectEnumerator];
      unsigned int v13 = 0;
      for (uint64_t i = 0; ; uint64_t i = (void *)v15)
      {
        uint64_t v15 = [v31 nextObject];

        if (!v15)
        {
          rmdir((const char *)[v8 UTF8String]);

          goto LABEL_30;
        }
        std::string::size_type v16 = +[NSString stringWithFormat:@"%@/%@", v8, v15];
        long long v17 = +[NSString stringWithFormat:@"%@/%@", v33, v15];
        unsigned int v18 = [v7 fileExistsAtPath:v17 isDirectory:&v37];
        if (v37) {
          unsigned int v19 = 0;
        }
        else {
          unsigned int v19 = v18;
        }
        if (v19 == 1)
        {
          unsigned int v20 = [v7 fileExistsAtPath:v16 isDirectory:&v37];
          unsigned int v21 = v37 ? 0 : v20;
          if (v21 == 1) {
            [v7 removeItemAtPath:v17 error:0];
          }
        }
        id v22 = v17;
        bzero(__dst, 0x400uLL);
        id v23 = v22;
        strlcpy(__dst, (const char *)[v23 UTF8String], 0x400uLL);
        CFAllocatorRef v24 = +[NSString stringWithUTF8String:dirname(__dst)];

        [v7 createDirectoryAtPath:v24 withIntermediateDirectories:1 attributes:0 error:0];
        if (v32)
        {
          uint64_t v36 = 0;
          id v25 = (id *)&v36;
          unsigned __int8 v26 = [v7 copyItemAtPath:v16 toPath:v23 error:&v36];
        }
        else
        {
          uint64_t v35 = 0;
          id v25 = (id *)&v35;
          unsigned __int8 v26 = [v7 moveItemAtPath:v16 toPath:v23 error:&v35];
        }
        unsigned __int8 v27 = v26;
        id v28 = *v25;
        unsigned __int8 v29 = v28;
        if (v27) {
          goto LABEL_27;
        }
        id v8 = v34;
        if (v28)
        {
          if (!v13) {
            break;
          }
        }
LABEL_28:
      }
      unsigned int v13 = [v28 code];
LABEL_27:
      id v8 = v34;
      goto LABEL_28;
    }
  }
LABEL_30:
}

void sub_1007EF30C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void *sub_1007EF3A4(void *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf) {
    CFRetain(cf);
  }
  return a1;
}

void sub_1007EF3DC(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v1;
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 24), v1);
  }
}

const void **sub_1007EF408(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_1007EF43C(const void **a1)
{
  uint64_t v2 = (const void **)a1[1];
  if (*a1)
  {
    id v3 = *v2;
    *uint64_t v2 = *a1;
    int v6 = v3;
  }
  else
  {
    id v4 = *v2;
    *uint64_t v2 = 0;
    int v6 = v4;
  }
  sub_1000570E8(&v6);
  return a1;
}

void sub_1007EF494(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    __TUAssertTrigger();
  }
  [(objc_class *)off_101B0A860() donateWithEventIdentifier:a1 bundleIdentifier:a2 completionHandler:&stru_101A0BE60];
}

void sub_1007EF514(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1007EF524(CTBMDiscoverabilitySignalStreamInterface *a1)
{
  CTBMDiscoverabilitySignalStreamInterface::~CTBMDiscoverabilitySignalStreamInterface(a1);

  operator delete();
}

Class sub_1007EF55C()
{
  if (qword_101B0D9C8 != -1) {
    dispatch_once(&qword_101B0D9C8, &stru_101A0BEC0);
  }
  Class result = objc_getClass("TipEventProxy");
  qword_101B0D9C0 = (uint64_t)result;
  off_101B0A860 = (uint64_t (*)(void))sub_1007EF5C0;
  return result;
}

id sub_1007EF5C0()
{
  return (id)qword_101B0D9C0;
}

void sub_1007EF5CC(id a1)
{
  qword_101B0D9B8 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/TipKitServices.framework/TipKitServices", 2);
}

void sub_1007EF6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1007EF990(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1007EFA04(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v5 = (id)v4;
  (*(void (**)(uint64_t, uint64_t))(v3 + 16))(v3, a2);
  if (!a2)
  {
  }
}

void sub_1007EFAB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (!v10) {

  }
  _Unwind_Resume(exception_object);
}

void sub_1007EFE54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1007EFF78(uint64_t a1)
{
  return a1;
}

void sub_1007EFFA4(uint64_t a1)
{
  operator delete();
}

void *sub_1007EFFF0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A0BF18;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

void sub_1007F0048(id *a1)
{
  operator delete(a1);
}

uint64_t sub_1007F0084(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A0BF88)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007F00C4()
{
  return &off_101A0BF88;
}

uint64_t sub_1007F00D0(uint64_t a1)
{
  return a1;
}

void sub_1007F00FC(uint64_t a1)
{
  operator delete();
}

uint64_t sub_1007F0148()
{
  return 0;
}

id sub_1007F0150(uint64_t a1, void *a2)
{
  *a2 = off_101A0BFA8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1007F0198(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_1007F01A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_1007F01BC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A0C018)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1007F01FC()
{
  return &off_101A0C018;
}

void *sub_1007F0208(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_1007F028C(uint64_t a1)
{
  sub_100C62700(a1, "kPostponementGetStatus", (unint64_t)sub_1007F0344, 5u);
  sub_100C62700(a1, "kPostponementSetTicket", (unint64_t)sub_1007F053C, 5u);
  sub_100C62700(a1, "kPostponementLockTicket", (unint64_t)sub_1007F091C, 5u);

  return sub_100C62700(a1, "kPostponementUnlockTicket", (unint64_t)sub_1007F0B38, 5u);
}

void sub_1007F0344(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  id v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v18[0] = v8;
  unsigned __int8 v12 = sub_10004D37C(&v7[1].__m_.__sig, v18);
  if (!v12)
  {
    std::mutex::unlock(v7);
    return;
  }
  uint64_t v14 = v12[3];
  unsigned int v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
    std::mutex::unlock(v7);
    if (!v14) {
      return;
    }
LABEL_10:
    unsigned int v21 = 0;
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v14 + 16))(&v21, v14);
    if (v21) {
      uint64_t v15 = sub_100080778;
    }
    else {
      uint64_t v15 = 0;
    }
    if (!v15)
    {
LABEL_19:
      sub_100057D78(&v21);
      if (!v13) {
        return;
      }
      goto LABEL_20;
    }
    std::string::size_type v16 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_object_t v17 = v16;
    if (v16)
    {
      xpc_object_t v19 = v16;
    }
    else
    {
      xpc_object_t v17 = xpc_null_create();
      xpc_object_t v19 = v17;
      if (!v17)
      {
        xpc_object_t v17 = 0;
        xpc_object_t v19 = xpc_null_create();
        goto LABEL_18;
      }
    }
    xpc_retain(v17);
LABEL_18:
    v18[0] = *a5;
    v18[1] = (unint64_t)"kPostponementInfoDictionary";
    sub_100035E70((uint64_t)v18, &v19, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v19);
    xpc_object_t v19 = 0;
    xpc_release(v17);
    goto LABEL_19;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  if (v14) {
    goto LABEL_10;
  }
LABEL_20:
  sub_10004D2C8(v13);
}

void sub_1007F050C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100057D78((const void **)va);
  if (v6) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

const void **sub_1007F053C(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void *a5)
{
  sub_1007F0D54();
  unint64_t v8 = qword_101B0D9D8;
  if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Setting postponement ticket", buf, 2u);
  }
  CFTypeRef cf = 0;
  xpc_dictionary_get_value(*a4, "kPostponementTicket");
  *(void *)std::string buf = _CFXPCCreateCFObjectFromXPCObject();
  sub_100084068(&cf, (CFTypeRef *)buf);
  if (cf) {
    id v9 = sub_100080778;
  }
  else {
    id v9 = 0;
  }
  if (!v9)
  {
    sub_1007F0D54();
    unsigned int v21 = qword_101B0D9D8;
    if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_ERROR))
    {
      sub_100C663EC(a4, (uint64_t)buf);
      id v22 = v31 >= 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)long long v33 = 136315138;
      id v34 = v22;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Missing postponement ticket in request from client %s", v33, 0xCu);
      if (v31 < 0) {
        operator delete(*(void **)buf);
      }
    }
    return sub_100057D78(&cf);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v11 = ServiceMap;
  if (v12 < 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v12;
  std::string::size_type v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (!v16)
  {
    uint64_t v18 = 0;
LABEL_26:
    std::mutex::unlock(v11);
    xpc_object_t v17 = 0;
    char v19 = 1;
    if (!v18)
    {
LABEL_13:
      sub_1007F0D54();
      unsigned int v20 = qword_101B0D9D8;
      if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Cannot set ticket without an ActivationInterface!", buf, 2u);
      }
      xpc_object_t v24 = xpc_BOOL_create(0);
      if (!v24) {
        xpc_object_t v24 = xpc_null_create();
      }
      *(void *)std::string buf = *a5;
      std::string v30 = "kPostponementTicketSet";
      sub_100035E70((uint64_t)buf, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      if (v19) {
        return sub_100057D78(&cf);
      }
LABEL_32:
      sub_10004D2C8(v17);
      return sub_100057D78(&cf);
    }
    goto LABEL_27;
  }
  uint64_t v18 = v16[3];
  xpc_object_t v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_26;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (!v18) {
    goto LABEL_13;
  }
LABEL_27:
  CFTypeRef v28 = cf;
  if (cf) {
    CFRetain(cf);
  }
  (*(void (**)(uint64_t, CFTypeRef *))(*(void *)v18 + 32))(v18, &v28);
  sub_100057D78(&v28);
  xpc_object_t v26 = xpc_BOOL_create(1);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  *(void *)std::string buf = *a5;
  std::string v30 = "kPostponementTicketSet";
  sub_100035E70((uint64_t)buf, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if ((v19 & 1) == 0) {
    goto LABEL_32;
  }
  return sub_100057D78(&cf);
}

void sub_1007F089C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F091C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  sub_1007F0D54();
  id v7 = qword_101B0D9D8;
  if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Locking postponement ticket", (uint8_t *)v19, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v19[0] = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, v19);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_9:
    sub_1007F0D54();
    uint64_t v18 = qword_101B0D9D8;
    if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Cannot lock ticket without an Activation service!", (uint8_t *)v19, 2u);
    }
    goto LABEL_16;
  }
LABEL_13:
  (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
  xpc_object_t v20 = xpc_BOOL_create(1);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  v19[0] = *a5;
  v19[1] = (unint64_t)"kPostponementTicketLocked";
  sub_100035E70((uint64_t)v19, &v20, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
LABEL_16:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1007F0B0C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F0B38(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  sub_1007F0D54();
  id v7 = qword_101B0D9D8;
  if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Unlocking postponement ticket", (uint8_t *)v19, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  id v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  v19[0] = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, v19);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_9;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_9:
    sub_1007F0D54();
    uint64_t v18 = qword_101B0D9D8;
    if (os_log_type_enabled((os_log_t)qword_101B0D9D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Cannot unlock ticket without an Activation service!", (uint8_t *)v19, 2u);
    }
    goto LABEL_16;
  }
LABEL_13:
  (*(void (**)(uint64_t))(*(void *)v16 + 48))(v16);
  xpc_object_t v20 = xpc_BOOL_create(0);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  v19[0] = *a5;
  v19[1] = (unint64_t)"kPostponementTicketLocked";
  sub_100035E70((uint64_t)v19, &v20, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
LABEL_16:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1007F0D28(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F0D54()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D9E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D9E0))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D9D8, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B0D9E0);
  }
}

void sub_1007F0DD8(_Unwind_Exception *a1)
{
}

uint64_t sub_1007F0DF0()
{
  return sub_100C624B8((uint64_t)&unk_101B0D9D0, (uint64_t)sub_1007F028C);
}

uint64_t *sub_1007F0E1C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  v46[0] = 0;
  v46[1] = 524524;
  if (sub_10017B48C()) {
    operator new();
  }
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  int v43 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  id v7 = ServiceMap;
  if (v8 < 0)
  {
    id v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_11:
  if ((*((char *)a2 + 23) & 0x80000000) == 0)
  {
    if (*((unsigned char *)a2 + 23)) {
      goto LABEL_13;
    }
LABEL_21:
    uint64_t v18 = (const char *)kCtLoggingSystemName;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.awd");
    id v23 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    *(_WORD *)std::string buf = 0;
    xpc_object_t v24 = "Bootstrap iccid of slot 1 is empty!";
    id v25 = v23;
    uint32_t v26 = 2;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, v24, buf, v26);
    goto LABEL_28;
  }
  if (!a2[1]) {
    goto LABEL_21;
  }
LABEL_13:
  if (((*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, int *))(*(void *)v14 + 64))(v14, a2, &v45, &v44, &v43) & 1) == 0)
  {
    uint64_t v18 = (const char *)kCtLoggingSystemName;
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.awd");
    xpc_object_t v27 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO)) {
      goto LABEL_28;
    }
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = a2;
    xpc_object_t v24 = "Invalid subscriber ID: %s";
    id v25 = v27;
    uint32_t v26 = 12;
    goto LABEL_27;
  }
  uint64_t v17 = v44;
  uint64_t v16 = v45;
  uint64_t v18 = (const char *)kCtLoggingSystemName;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.awd");
  uint64_t v19 = v16 - v17;
  xpc_object_t v20 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v19;
    __int16 v48 = 2048;
    uint64_t v49 = v44;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "Bootstrap(%s) data usage queried. domestic: %lld, roaming: %lld", buf, 0x20u);
  }
  uint64_t v21 = v46[0];
  if (v46[0])
  {
    uint64_t v22 = v44;
    *(_DWORD *)(v46[0] + 52) |= 6u;
    *(void *)(v21 + 16) = v19;
    *(void *)(v21 + 24) = v22;
  }
LABEL_28:
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  int v40 = 0;
  if ((*((char *)a3 + 23) & 0x80000000) == 0)
  {
    if (*((unsigned char *)a3 + 23)) {
      goto LABEL_30;
    }
LABEL_38:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v18, "cp.awd");
    id v34 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_INFO)) {
      goto LABEL_45;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v35 = "Bootstrap iccid of slot 2 is empty!";
    uint64_t v36 = v34;
    uint32_t v37 = 2;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, v35, buf, v37);
    goto LABEL_45;
  }
  if (!a3[1]) {
    goto LABEL_38;
  }
LABEL_30:
  if (((*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *, int *))(*(void *)v14 + 64))(v14, a3, &v42, &v41, &v40) & 1) == 0)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v18, "cp.awd");
    uint64_t v38 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
      goto LABEL_45;
    }
    if (*((char *)a3 + 23) < 0) {
      a3 = (uint64_t *)*a3;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = a3;
    uint64_t v35 = "Invalid subscriber ID: %s";
    uint64_t v36 = v38;
    uint32_t v37 = 12;
    goto LABEL_44;
  }
  uint64_t v29 = v41;
  uint64_t v28 = v42;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v18, "cp.awd");
  uint64_t v30 = v28 - v29;
  char v31 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
  {
    if (*((char *)a3 + 23) < 0) {
      a3 = (uint64_t *)*a3;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = a3;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v30;
    __int16 v48 = 2048;
    uint64_t v49 = v41;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "Bootstrap(%s) data usage queried. domestic: %lld, roaming: %lld", buf, 0x20u);
  }
  uint64_t v32 = v46[0];
  if (v46[0])
  {
    uint64_t v33 = v41;
    *(_DWORD *)(v46[0] + 52) |= 0x18u;
    *(void *)(v32 + 32) = v30;
    *(void *)(v32 + 40) = v33;
  }
LABEL_45:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  return sub_1007F7564(v46);
}

void sub_1007F1370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v7);
  }
  sub_1007F7564((uint64_t *)va);
  _Unwind_Resume(a1);
}

const void **sub_1007F1418(int a1, int a2, UInt8 *bytes)
{
  uint64_t v3 = bytes;
  if ((char)bytes[23] < 0)
  {
    uint64_t v3 = *(const UInt8 **)bytes;
    CFIndex v4 = *((void *)bytes + 1);
  }
  else
  {
    CFIndex v4 = bytes[23];
  }
  CFDataRef v5 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v3, v4, kCFAllocatorNull);
  CFDataRef v11 = v5;
  std::string __p = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  CFDataRef v7 = v5;
  if (v5) {
    CFRetain(v5);
  }
  CodingUtility::SHA1();
  sub_100030068((const void **)&v7);
  VinylSlotIdToInt();
  sub_10017E810();
  if (SHIBYTE(v10) < 0) {
    operator delete(__p);
  }
  return sub_100030068((const void **)&v11);
}

void sub_1007F14E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_100030068(&a10);
  sub_100030068((const void **)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_1007F1514(capabilities::ct *a1)
{
  if (capabilities::ct::supportsRemoteCellularPlan(a1)) {
    sub_10017B514();
  }
}

void sub_1007F159C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFIndex v4 = v3;
      uint64_t v5 = *(void *)(v1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007F161C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007F1630(uint64_t a1)
{
  char v2 = (capabilities::ct *)capabilities::ct::supportsSequoia((capabilities::ct *)a1);
  if (v2)
  {
    object[1] = (dispatch_object_t)_NSConcreteStackBlock;
    object[2] = (dispatch_object_t)0x40000000;
    object[3] = (dispatch_object_t)sub_1007F1A10;
    object[4] = (dispatch_object_t)&unk_101A0C188;
    object[5] = (dispatch_object_t)a1;
    sub_10017B514();
  }
  if (capabilities::ct::supportedVinylSlotCount(v2))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (v3)
    {
      CFIndex v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(a1 + 8);
        if (v6)
        {
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
          char v8 = ServiceMap;
          if ((v9 & 0x8000000000000000) != 0)
          {
            uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v11 = 5381;
            do
            {
              unint64_t v9 = v11;
              unsigned int v12 = *v10++;
              uint64_t v11 = (33 * v11) ^ v12;
            }
            while (v12);
          }
          std::mutex::lock(ServiceMap);
          v24[0] = v9;
          unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, v24);
          if (v13)
          {
            uint64_t v15 = v13[3];
            uint64_t v14 = (std::__shared_weak_count *)v13[4];
            if (v14)
            {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v8);
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v14);
              if (!v15)
              {
LABEL_39:
                sub_10004D2C8(v14);
                goto LABEL_40;
              }
LABEL_16:
              unint64_t v17 = *(void *)(a1 + 8);
              uint64_t v16 = *(std::__shared_weak_count **)(a1 + 16);
              if (v16) {
                atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              }
              (*(void (**)(dispatch_object_t *__return_ptr, uint64_t))(*(void *)v6 + 24))(object, v6);
              v21[0] = _NSConcreteStackBlock;
              v21[1] = 1174405120;
              v21[2] = sub_1007F1AA4;
              v21[3] = &unk_101A0C1A8;
              v21[4] = v6;
              uint64_t v22 = v5;
              atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
              if (object[0])
              {
                uint64_t v18 = _Block_copy(v21);
                uint64_t v19 = v18;
                dispatch_object_t v27 = object[0];
                object[0] = 0;
                v24[0] = (unint64_t)_NSConcreteStackBlock;
                v24[1] = 1174405120;
                v24[2] = (unint64_t)sub_1007F7714;
                v24[3] = (unint64_t)&unk_101A0C210;
                v24[4] = v17;
                id v25 = v16;
                if (v16) {
                  atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                }
                if (v18) {
                  xpc_object_t v20 = _Block_copy(v18);
                }
                else {
                  xpc_object_t v20 = 0;
                }
                aBlock = v20;
                (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, unint64_t *))(*(void *)v15 + 40))(v15, "commCenterCellularPlanProfilesStatus", 1, &v27, v24);
                if (v27) {
                  dispatch_release(v27);
                }
                if (aBlock) {
                  _Block_release(aBlock);
                }
                if (v25) {
                  std::__shared_weak_count::__release_weak(v25);
                }
                if (v19) {
                  _Block_release(v19);
                }
                if (object[0]) {
                  dispatch_release(object[0]);
                }
              }
              if (v16) {
                std::__shared_weak_count::__release_weak(v16);
              }
              if (v22) {
                sub_10004D2C8(v22);
              }
              if (!v14) {
                goto LABEL_40;
              }
              goto LABEL_39;
            }
            std::mutex::unlock(v8);
            if (v15) {
              goto LABEL_16;
            }
          }
          else
          {
            std::mutex::unlock(v8);
          }
        }
LABEL_40:
        sub_10004D2C8(v5);
      }
    }
  }
}

void sub_1007F196C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, dispatch_object_t object, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a26) {
    std::__shared_weak_count::__release_weak(a26);
  }
  uint64_t v33 = *(NSObject **)(v31 - 104);
  if (v33) {
    dispatch_release(v33);
  }
  if (v30) {
    _Block_release(v30);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (object)
  {
    dispatch_release(object);
    if (!v29)
    {
LABEL_13:
      if (!v28)
      {
LABEL_18:
        sub_10004D2C8(v27);
        _Unwind_Resume(a1);
      }
LABEL_17:
      sub_10004D2C8(v28);
      goto LABEL_18;
    }
  }
  else if (!v29)
  {
    goto LABEL_13;
  }
  std::__shared_weak_count::__release_weak(v29);
  if (!v28) {
    goto LABEL_18;
  }
  goto LABEL_17;
}

void sub_1007F1A10(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFIndex v4 = v3;
      uint64_t v5 = *(void (****)(void))(v1 + 8);
      if (v5) {
        (**v5)(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1007F1A90(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007F1AA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))();
}

uint64_t sub_1007F1ACC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007F1AE8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1007F1AF8(Registry **a1, BOOL *a2, uint64_t *a3, uint64_t *a4)
{
  char v53 = _NSConcreteStackBlock;
  uint64_t v54 = 0x40000000;
  char v55 = sub_1007F2224;
  char v56 = &unk_101A0C1D8;
  long long v57 = a3;
  uint64_t v58 = a4;
  uint64_t v59 = a2;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)a1);
  uint64_t v9 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800D5u);
  *(void *)std::string buf = v9;
  if (v9)
  {
    uint64_t v10 = (wis::MetricContainer *)v9;
    uint64_t v11 = sub_10001C8F4(8);
    uint64_t v13 = *v11;
    unsigned int v12 = (std::__shared_weak_count *)v11[1];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v13) {
      operator new();
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
    wis::MetricContainer::~MetricContainer(v10);
    operator delete();
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[3]);
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    unint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v16;
  xpc_object_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
  if (v20)
  {
    uint64_t v22 = v20[3];
    uint64_t v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      if (!v22) {
        goto LABEL_15;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v15);
  uint64_t v21 = 0;
  char v23 = 1;
  if (!v22)
  {
LABEL_15:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.awd");
    xpc_object_t v24 = v44;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Telephony Analytics Interface is not found, skipping metric submission.", buf, 2u);
      if (v23) {
        return;
      }
      goto LABEL_54;
    }
LABEL_53:
    if (v23) {
      return;
    }
    goto LABEL_54;
  }
LABEL_20:
  memset(&v52, 0, sizeof(v52));
  memset(&v51, 0, sizeof(v51));
  memset(&v50, 0, sizeof(v50));
  __int16 v48 = "+";
  uint64_t v49 = "_";
  *(void *)std::string buf = &v52;
  uint64_t v44 = &v49;
  uint64_t v45 = &v51;
  char v46 = &v50;
  uint64_t v47 = &v48;
  sub_1007F24B8((std::string **)buf, a3);
  std::string::append(&v52, "/", 1uLL);
  std::string::append(&v51, "/", 1uLL);
  std::string::append(&v50, "/", 1uLL);
  sub_1007F24B8((std::string **)buf, a4);
  xpc_object_t v42 = 0;
  xpc_object_t v25 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v26 = v25;
  if (v25)
  {
    xpc_object_t v42 = v25;
  }
  else
  {
    xpc_object_t v26 = xpc_null_create();
    xpc_object_t v42 = v26;
    if (!v26)
    {
      xpc_object_t v27 = xpc_null_create();
      xpc_object_t v26 = 0;
      goto LABEL_27;
    }
  }
  if (xpc_get_type(v26) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v26);
    goto LABEL_28;
  }
  xpc_object_t v27 = xpc_null_create();
LABEL_27:
  xpc_object_t v42 = v27;
LABEL_28:
  xpc_release(v26);
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v28 = &v52;
  }
  else {
    uint64_t v28 = (std::string *)v52.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v40 = xpc_string_create((const char *)v28);
  if (!v40) {
    xpc_object_t v40 = xpc_null_create();
  }
  uint64_t v38 = &v42;
  uint64_t v39 = "profiles_from_to";
  sub_100035E70((uint64_t)&v38, &v40, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v40);
  xpc_object_t v40 = 0;
  if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v29 = &v51;
  }
  else {
    uint64_t v29 = (std::string *)v51.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v36 = xpc_string_create((const char *)v29);
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  uint64_t v38 = &v42;
  uint64_t v39 = "profiles_from_to_sim_type";
  sub_100035E70((uint64_t)&v38, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v30 = &v50;
  }
  else {
    uint64_t v30 = (std::string *)v50.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v34 = xpc_string_create((const char *)v30);
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  uint64_t v38 = &v42;
  uint64_t v39 = "profiles_from_to_is_bootstrap";
  sub_100035E70((uint64_t)&v38, &v34, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_object_t v32 = xpc_BOOL_create(*a2);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  uint64_t v38 = &v42;
  uint64_t v39 = "is_buddy_flow";
  sub_100035E70((uint64_t)&v38, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v31 = v42;
  xpc_object_t v32 = 0;
  if (v42) {
    xpc_retain(v42);
  }
  else {
    xpc_object_t v31 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v22 + 16))(v22, "commCenterCellularPlanProfileSwitch", &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v42);
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_53;
  }
  operator delete(v52.__r_.__value_.__l.__data_);
  if (v23) {
    return;
  }
LABEL_54:
  sub_10004D2C8(v21);
}

void sub_1007F20E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if ((v41 & 1) == 0) {
    sub_10004D2C8(v40);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007F2224(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  CFIndex v4 = *(const std::string ***)(result + 32);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (*v4 != v6)
  {
    while (1)
    {
      int v7 = *(_DWORD *)(a2 + 44);
      uint64_t v8 = *(int *)(a2 + 40);
      if ((int)v8 >= v7)
      {
        if (v7 == *(_DWORD *)(a2 + 48))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 32), v7 + 1);
          int v7 = *(_DWORD *)(a2 + 44);
        }
        *(_DWORD *)(a2 + 44) = v7 + 1;
        sub_1007F74A8();
      }
      uint64_t v9 = *(void *)(a2 + 32);
      *(_DWORD *)(a2 + 40) = v8 + 1;
      uint64_t v10 = *(void *)(v9 + 8 * v8);
      *(_DWORD *)(v10 + 48) |= 0x20u;
      uint64_t v11 = *(std::string **)(v10 + 32);
      if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v11, v5);
      std::string::value_type v13 = v5[1].__r_.__value_.__s.__data_[0];
      *(_DWORD *)(v10 + 48) |= 4u;
      *(unsigned char *)(v10 + 24) = v13;
      uint64_t v14 = (awd::metrics *)(v5[1].__r_.__value_.__s.__data_[1] ? 2 : 1);
      id result = awd::metrics::CommCenterCellularSimType_IsValid(v14, v12);
      if ((result & 1) == 0) {
        break;
      }
      *(_DWORD *)(v10 + 48) |= 0x40u;
      *(_DWORD *)(v10 + 40) = v14;
      uint64_t v5 = (const std::string *)((char *)v5 + 32);
      if (v5 == v6) {
        goto LABEL_14;
      }
    }
LABEL_28:
    __assert_rtn("set_sim_type", "CCMetricsCP.pb.h", 4900, "::awd::metrics::CommCenterCellularSimType_IsValid(value)");
  }
LABEL_14:
  uint64_t v15 = *(const std::string ***)(v3 + 40);
  uint64_t v16 = *v15;
  unint64_t v17 = v15[1];
  if (*v15 != v17)
  {
    do
    {
      int v18 = *(_DWORD *)(a2 + 68);
      uint64_t v19 = *(int *)(a2 + 64);
      if ((int)v19 >= v18)
      {
        if (v18 == *(_DWORD *)(a2 + 72))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 56), v18 + 1);
          int v18 = *(_DWORD *)(a2 + 68);
        }
        *(_DWORD *)(a2 + 68) = v18 + 1;
        sub_1007F74A8();
      }
      uint64_t v20 = *(void *)(a2 + 56);
      *(_DWORD *)(a2 + 64) = v19 + 1;
      uint64_t v21 = *(void *)(v20 + 8 * v19);
      *(_DWORD *)(v21 + 48) |= 0x20u;
      uint64_t v22 = *(std::string **)(v21 + 32);
      if (v22 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v22, v16);
      std::string::value_type v24 = v16[1].__r_.__value_.__s.__data_[0];
      *(_DWORD *)(v21 + 48) |= 4u;
      *(unsigned char *)(v21 + 24) = v24;
      xpc_object_t v25 = (awd::metrics *)(v16[1].__r_.__value_.__s.__data_[1] ? 2 : 1);
      id result = awd::metrics::CommCenterCellularSimType_IsValid(v25, v23);
      if ((result & 1) == 0) {
        goto LABEL_28;
      }
      *(_DWORD *)(v21 + 48) |= 0x40u;
      *(_DWORD *)(v21 + 40) = v25;
      uint64_t v16 = (const std::string *)((char *)v16 + 32);
    }
    while (v16 != v17);
  }
  char v26 = **(unsigned char **)(v3 + 48);
  *(_DWORD *)(a2 + 88) |= 0x20u;
  *(unsigned char *)(a2 + 80) = v26;
  return result;
}

void sub_1007F24B8(std::string **a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      long long __dst = 0u;
      long long v37 = 0u;
      int v7 = (long long *)(v2 + v5);
      if (*(char *)(v2 + v5 + 23) < 0)
      {
        sub_10004FC84(&__dst, *(void **)v7, *((void *)v7 + 1));
      }
      else
      {
        long long v8 = *v7;
        *(void *)&long long v37 = *((void *)v7 + 2);
        long long __dst = v8;
      }
      int v9 = *(unsigned __int8 *)(v2 + v5 + 24);
      WORD4(v37) = *(_WORD *)(v2 + v5 + 24);
      v34[0] = 0;
      v34[1] = 0;
      uint64_t v35 = 0;
      if (SBYTE7(v37) < 0)
      {
        sub_10004FC84(v34, (void *)__dst, *((unint64_t *)&__dst + 1));
        int v9 = BYTE8(v37);
      }
      else
      {
        *(_OWORD *)xpc_object_t v34 = __dst;
        uint64_t v35 = v37;
      }
      xpc_object_t v31 = 0;
      std::string::size_type v32 = 0;
      uint64_t v33 = 0;
      if (v9) {
        uint64_t v10 = "true";
      }
      else {
        uint64_t v10 = "false";
      }
      sub_100058DB0(&v31, v10);
      uint64_t v28 = 0;
      std::string::size_type v29 = 0;
      uint64_t v30 = 0;
      if (BYTE9(v37)) {
        uint64_t v11 = "ESIM";
      }
      else {
        uint64_t v11 = "PSIM";
      }
      sub_100058DB0(&v28, v11);
      if (v35 >= 0) {
        size_t v12 = HIBYTE(v35);
      }
      else {
        size_t v12 = (size_t)v34[1];
      }
      memset(&v25, 0, sizeof(v25));
      sub_1000C140C((uint64_t)&v25, v12 + 1);
      if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::value_type v13 = &v25;
      }
      else {
        std::string::value_type v13 = (std::string *)v25.__r_.__value_.__r.__words[0];
      }
      if (v12)
      {
        if (v35 >= 0) {
          uint64_t v14 = v34;
        }
        else {
          uint64_t v14 = (void **)v34[0];
        }
        memmove(v13, v14, v12);
      }
      *(_WORD *)((char *)&v13->__r_.__value_.__l.__data_ + v12) = 95;
      if (v30 >= 0) {
        uint64_t v15 = (const std::string::value_type *)&v28;
      }
      else {
        uint64_t v15 = (const std::string::value_type *)v28;
      }
      if (v30 >= 0) {
        std::string::size_type v16 = HIBYTE(v30);
      }
      else {
        std::string::size_type v16 = v29;
      }
      unint64_t v17 = std::string::append(&v25, v15, v16);
      long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
      int64_t v27 = v17->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v18;
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      if (v27 >= 0) {
        uint64_t v19 = __p;
      }
      else {
        uint64_t v19 = (void **)__p[0];
      }
      if (v27 >= 0) {
        std::string::size_type v20 = HIBYTE(v27);
      }
      else {
        std::string::size_type v20 = (std::string::size_type)__p[1];
      }
      std::string::append(*a1, (const std::string::value_type *)v19, v20);
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v25.__r_.__value_.__l.__data_);
      }
      if (v30 >= 0) {
        uint64_t v21 = (const std::string::value_type *)&v28;
      }
      else {
        uint64_t v21 = (const std::string::value_type *)v28;
      }
      if (v30 >= 0) {
        std::string::size_type v22 = HIBYTE(v30);
      }
      else {
        std::string::size_type v22 = v29;
      }
      std::string::append(a1[2], v21, v22);
      if (v33 >= 0) {
        int v23 = (const std::string::value_type *)&v31;
      }
      else {
        int v23 = (const std::string::value_type *)v31;
      }
      if (v33 >= 0) {
        std::string::size_type v24 = HIBYTE(v33);
      }
      else {
        std::string::size_type v24 = v32;
      }
      std::string::append(a1[3], v23, v24);
      if (v6 != ((a2[1] - *a2) >> 5) - 1)
      {
        std::string::append(*a1, "+", 1uLL);
        std::string::append(a1[2], "+", 1uLL);
        std::string::append(a1[3], "+", 1uLL);
      }
      if (SHIBYTE(v30) < 0) {
        operator delete(v28);
      }
      if (SHIBYTE(v33) < 0) {
        operator delete(v31);
      }
      if (SHIBYTE(v35) < 0) {
        operator delete(v34[0]);
      }
      if (SBYTE7(v37) < 0) {
        operator delete((void *)__dst);
      }
      ++v6;
      uint64_t v2 = *a2;
      v5 += 32;
    }
    while (v6 < (a2[1] - *a2) >> 5);
  }
}

void sub_1007F27C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F285C(uint64_t a1, BOOL a2, BOOL a3, BOOL a4, BOOL a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    size_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  std::string::size_type v29 = (xpc_object_t *)v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v29);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_9:
    std::mutex::unlock(v10);
    std::string::size_type v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_30;
    }
    goto LABEL_10;
  }
  uint64_t v17 = v15[3];
  std::string::size_type v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17) {
    goto LABEL_30;
  }
LABEL_10:
  xpc_object_t v33 = 0;
  xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v20 = v19;
  if (v19)
  {
    xpc_object_t v33 = v19;
  }
  else
  {
    xpc_object_t v20 = xpc_null_create();
    xpc_object_t v33 = v20;
    if (!v20)
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v20 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v21 = xpc_null_create();
LABEL_17:
    xpc_object_t v33 = v21;
    goto LABEL_18;
  }
  xpc_retain(v20);
LABEL_18:
  xpc_release(v20);
  xpc_object_t v31 = xpc_BOOL_create(a3);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  std::string::size_type v29 = &v33;
  uint64_t v30 = "is_bootstrap_active";
  sub_100035E70((uint64_t)&v29, &v31, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_object_t v27 = xpc_BOOL_create(a4);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  std::string::size_type v29 = &v33;
  uint64_t v30 = "has_wifi";
  sub_100035E70((uint64_t)&v29, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v25 = xpc_BOOL_create(a5);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  std::string::size_type v29 = &v33;
  uint64_t v30 = "has_internet";
  sub_100035E70((uint64_t)&v29, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_BOOL_create(a2);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  std::string::size_type v29 = &v33;
  uint64_t v30 = "is_renewal";
  sub_100035E70((uint64_t)&v29, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v22 = v33;
  xpc_object_t v23 = 0;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "commCenterCellularPlanPurchaseComplete", &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v33);
LABEL_30:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_1007F2B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(a20);
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007F2C04()
{
  return sub_10017DFB0((wis::MetricFactory *)0x8010D);
}

uint64_t sub_1007F2C80(uint64_t a1, int a2)
{
  VinylSlotIdToInt();
  if (a2) {
    uint64_t v3 = 524497;
  }
  else {
    uint64_t v3 = 524498;
  }
  return sub_10017DD90((wis::MetricFactory *)v3);
}

void sub_1007F2D98(uint64_t a1, int a2, BOOL a3, BOOL a4, BOOL a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    size_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&__p);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_9:
    std::mutex::unlock(v10);
    std::string::size_type v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_35;
    }
    goto LABEL_10;
  }
  uint64_t v17 = v15[3];
  std::string::size_type v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17) {
    goto LABEL_35;
  }
LABEL_10:
  xpc_object_t v36 = 0;
  xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v20 = v19;
  if (v19)
  {
    xpc_object_t v36 = v19;
  }
  else
  {
    xpc_object_t v20 = xpc_null_create();
    xpc_object_t v36 = v20;
    if (!v20)
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v20 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v21 = xpc_null_create();
LABEL_17:
    xpc_object_t v36 = v21;
    goto LABEL_18;
  }
  xpc_retain(v20);
LABEL_18:
  xpc_release(v20);
  sub_100180F7C(a2, &__p);
  if (v33 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  xpc_object_t object = xpc_string_create(p_p);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  v30[0] = &v36;
  v30[1] = "failure";
  sub_100035E70((uint64_t)v30, &object, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (v33 < 0) {
    operator delete(__p);
  }
  xpc_object_t v28 = xpc_BOOL_create(a4);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  std::string __p = &v36;
  std::string::size_type v32 = "has_wifi";
  sub_100035E70((uint64_t)&__p, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_object_t v26 = xpc_BOOL_create(a5);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  std::string __p = &v36;
  std::string::size_type v32 = "has_internet";
  sub_100035E70((uint64_t)&__p, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_object_t v24 = xpc_BOOL_create(a3);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  std::string __p = &v36;
  std::string::size_type v32 = "is_bootstrap_active";
  sub_100035E70((uint64_t)&__p, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v23 = v36;
  xpc_object_t v24 = 0;
  if (v36) {
    xpc_retain(v36);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "commCenterCellularPlanFailure", &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v36);
LABEL_35:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_1007F30F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 88));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void sub_1007F3174(uint64_t a1, BOOL a2, BOOL a3, BOOL a4)
{
}

void sub_1007F3188(uint64_t a1, BOOL a2, BOOL a3, BOOL a4)
{
}

uint64_t sub_1007F319C()
{
  return sub_10017E1B0((wis::MetricFactory *)0x800FE);
}

void sub_1007F3214(uint64_t a1, uint64_t a2, int a3, int a4, char a5, char a6)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  if ((a3 - 1) >= 3) {
    int v10 = 0;
  }
  else {
    int v10 = a3;
  }
  if (a4 == 2) {
    int v11 = 3;
  }
  else {
    int v11 = 2 * (a4 == 1);
  }
  sub_10017E3C0((long long *)__p, v10, v11, a5, a6);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007F32C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F32DC(uint64_t a1, char a2)
{
  sub_100058DB0(__p, "");
  sub_10017E3C0((long long *)__p, 1, 0, a2, 0);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007F333C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F3358(uint64_t a1, int a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  char v4 = ServiceMap;
  if (v5 < 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    int v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_29;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  int v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11) {
    goto LABEL_29;
  }
LABEL_10:
  xpc_object_t v23 = 0;
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v14 = v13;
  if (v13)
  {
    xpc_object_t v23 = v13;
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
    xpc_object_t v23 = v14;
    if (!v14)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v15 = xpc_null_create();
LABEL_17:
    xpc_object_t v23 = v15;
    goto LABEL_18;
  }
  xpc_retain(v14);
LABEL_18:
  xpc_release(v14);
  sub_100180F7C(a2, __p);
  if (v20 >= 0) {
    std::string::size_type v16 = __p;
  }
  else {
    std::string::size_type v16 = (void **)__p[0];
  }
  xpc_object_t v21 = xpc_string_create((const char *)v16);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  v18[0] = &v23;
  v18[1] = "failure";
  sub_100035E70((uint64_t)v18, &v21, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v17 = v23;
  if (v23) {
    xpc_retain(v23);
  }
  else {
    xpc_object_t v17 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v11 + 16))(v11, "commCenterCellularPlanFailure", &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v23);
LABEL_29:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1007F35A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 56));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void sub_1007F35FC(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  unsigned int v8 = ServiceMap;
  if (v9 < 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    xpc_object_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_49;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  xpc_object_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15) {
    goto LABEL_49;
  }
LABEL_10:
  xpc_object_t v35 = 0;
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v18 = v17;
  if (v17)
  {
    xpc_object_t v35 = v17;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v35 = v18;
    if (!v18)
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v18);
    goto LABEL_18;
  }
  xpc_object_t v19 = xpc_null_create();
LABEL_17:
  xpc_object_t v35 = v19;
LABEL_18:
  xpc_release(v18);
  if ((*((char *)a2 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a2 + 23)) {
      goto LABEL_26;
    }
LABEL_23:
    xpc_object_t object = xpc_string_create((const char *)a2);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    __p[0] = &v35;
    __p[1] = "carrier_name";
    sub_100035E70((uint64_t)__p, &object, &v34);
    xpc_release(v34);
    xpc_object_t v34 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
    goto LABEL_26;
  }
  if (a2[1])
  {
    a2 = (uint64_t *)*a2;
    goto LABEL_23;
  }
LABEL_26:
  if ((a3 - 1) > 2) {
    char v20 = "kWebsheetFlow";
  }
  else {
    char v20 = off_101A0C240[a3 - 1];
  }
  sub_100058DB0(__p, v20);
  if (v30 >= 0) {
    xpc_object_t v21 = __p;
  }
  else {
    xpc_object_t v21 = (void **)__p[0];
  }
  xpc_object_t v31 = xpc_string_create((const char *)v21);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  xpc_object_t v27 = &v35;
  xpc_object_t v28 = "flow_type";
  sub_100035E70((uint64_t)&v27, &v31, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v22 = 2 * (a4 == 1);
  if (a4 == 2) {
    uint64_t v22 = 3;
  }
  sub_100058DB0(__p, off_101A0C270[v22]);
  if (v30 >= 0) {
    xpc_object_t v23 = __p;
  }
  else {
    xpc_object_t v23 = (void **)__p[0];
  }
  xpc_object_t v25 = xpc_string_create((const char *)v23);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_object_t v27 = &v35;
  xpc_object_t v28 = "plan_type";
  sub_100035E70((uint64_t)&v27, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v24 = v35;
  if (v35) {
    xpc_retain(v35);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterRemoteCellularPlanSignUpCallBackReceived", &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v35);
LABEL_49:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1007F3990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 72));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

void sub_1007F39FC(uint64_t a1, uint64_t a2, int a3, int a4, BOOL a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  int v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&__p);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_9:
    std::mutex::unlock(v10);
    char v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_47;
    }
    goto LABEL_10;
  }
  uint64_t v17 = v15[3];
  char v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17) {
    goto LABEL_47;
  }
LABEL_10:
  xpc_object_t v41 = 0;
  xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v20 = v19;
  if (v19)
  {
    xpc_object_t v41 = v19;
  }
  else
  {
    xpc_object_t v20 = xpc_null_create();
    xpc_object_t v41 = v20;
    if (!v20)
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v20 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v21 = xpc_null_create();
LABEL_17:
    xpc_object_t v41 = v21;
    goto LABEL_18;
  }
  xpc_retain(v20);
LABEL_18:
  xpc_release(v20);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v22 = (const char *)a2;
  }
  else {
    uint64_t v22 = *(const char **)a2;
  }
  xpc_object_t object = xpc_string_create(v22);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  std::string __p = &v41;
  xpc_object_t v35 = "carrier_name";
  sub_100035E70((uint64_t)&__p, &object, &v40);
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v23 = 2 * (a3 == 1);
  if (a3 == 2) {
    uint64_t v23 = 3;
  }
  sub_100058DB0(&__p, off_101A0C270[v23]);
  if (v36 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  xpc_object_t v37 = xpc_string_create(p_p);
  if (!v37) {
    xpc_object_t v37 = xpc_null_create();
  }
  xpc_object_t v32 = &v41;
  char v33 = "plan_type";
  sub_100035E70((uint64_t)&v32, &v37, &v38);
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_release(v37);
  xpc_object_t v37 = 0;
  if (v36 < 0) {
    operator delete(__p);
  }
  uint64_t v25 = 2 * (a4 == 7);
  if (a4 == 6) {
    uint64_t v25 = 1;
  }
  sub_100058DB0(&__p, off_101A0C258[v25]);
  if (v36 >= 0) {
    xpc_object_t v26 = (const char *)&__p;
  }
  else {
    xpc_object_t v26 = (const char *)__p;
  }
  xpc_object_t v30 = xpc_string_create(v26);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  xpc_object_t v32 = &v41;
  char v33 = "prev_status";
  sub_100035E70((uint64_t)&v32, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  if (v36 < 0) {
    operator delete(__p);
  }
  xpc_object_t v28 = xpc_BOOL_create(a5);
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  std::string __p = &v41;
  xpc_object_t v35 = "did_released";
  sub_100035E70((uint64_t)&__p, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v27 = v41;
  xpc_object_t v28 = 0;
  if (v41) {
    xpc_retain(v41);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "commCenterCellularPlanPendingProfileReleased", &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v41);
LABEL_47:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_1007F3DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 88));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_1007F3E50()
{
  v4[0] = 0;
  v4[1] = 524552;
  if (sub_10017B48C()) {
    operator new();
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v2, kCtLoggingSystemName, "cp.awd");
  v0 = v3;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v2);
  if (os_log_type_enabled(v0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "CommCenterRemoteCellularPlanProfilesStatus metric is not collectable", v2, 2u);
  }
  return sub_1007F7840(v4);
}

void sub_1007F419C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1007F7840((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1007F4230(uint64_t a1, char a2, uint64_t *a3, BOOL a4, unsigned int a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  int v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v30 = (xpc_object_t *)v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v30);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_9:
    std::mutex::unlock(v10);
    char v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_39;
    }
    goto LABEL_10;
  }
  uint64_t v17 = v15[3];
  char v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17) {
    goto LABEL_39;
  }
LABEL_10:
  xpc_object_t v34 = 0;
  xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v20 = v19;
  if (v19)
  {
    xpc_object_t v34 = v19;
  }
  else
  {
    xpc_object_t v20 = xpc_null_create();
    xpc_object_t v34 = v20;
    if (!v20)
    {
      xpc_object_t v21 = xpc_null_create();
      xpc_object_t v20 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v20);
    goto LABEL_18;
  }
  xpc_object_t v21 = xpc_null_create();
LABEL_17:
  xpc_object_t v34 = v21;
LABEL_18:
  xpc_release(v20);
  if ((a2 - 2) > 3u) {
    int64_t v22 = 1;
  }
  else {
    int64_t v22 = qword_1014F61B8[(char)(a2 - 2)];
  }
  xpc_object_t v32 = xpc_int64_create(v22);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  xpc_object_t v30 = &v34;
  xpc_object_t v31 = "subscription_status";
  sub_100035E70((uint64_t)&v30, &v32, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  if ((*((char *)a3 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a3 + 23)) {
      goto LABEL_31;
    }
LABEL_28:
    xpc_object_t v28 = xpc_string_create((const char *)a3);
    if (!v28) {
      xpc_object_t v28 = xpc_null_create();
    }
    xpc_object_t v30 = &v34;
    xpc_object_t v31 = "carrier_name";
    sub_100035E70((uint64_t)&v30, &v28, &v29);
    xpc_release(v29);
    xpc_object_t v29 = 0;
    xpc_release(v28);
    xpc_object_t v28 = 0;
    goto LABEL_31;
  }
  if (a3[1])
  {
    a3 = (uint64_t *)*a3;
    goto LABEL_28;
  }
LABEL_31:
  xpc_object_t v26 = xpc_BOOL_create(a4);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  xpc_object_t v30 = &v34;
  xpc_object_t v31 = "esim_modification_allowed";
  sub_100035E70((uint64_t)&v30, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_object_t v24 = xpc_int64_create(a5);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  xpc_object_t v30 = &v34;
  xpc_object_t v31 = "device_subtype";
  sub_100035E70((uint64_t)&v30, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v23 = v34;
  xpc_object_t v24 = 0;
  if (v34) {
    xpc_retain(v34);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "commCenterCellularPlanProfilesStatus", &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v34);
LABEL_39:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_1007F45AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(a20);
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007F4618()
{
  return sub_10017EF48();
}

void sub_1007F4704(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a2 + 24) >= 8u) {
    int v3 = 1;
  }
  else {
    int v3 = *(unsigned __int8 *)(a2 + 24);
  }
  if (*(unsigned char *)(a2 + 25) == 2) {
    int v4 = 2;
  }
  else {
    int v4 = 1;
  }
  if (*(unsigned char *)(a2 + 25)) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  int v21 = v5;
  int v22 = v3;
  int v6 = *(unsigned __int8 *)(a2 + 27);
  int v7 = *(unsigned __int8 *)(a2 + 28);
  int v8 = *(unsigned __int8 *)(a2 + 29);
  int v9 = *(unsigned __int8 *)(a2 + 30);
  int v10 = *(unsigned __int8 *)(a2 + 31);
  uint64_t v19 = *(void *)(a2 + 40);
  uint64_t v20 = *(void *)(a2 + 32);
  uint64_t v18 = *(unsigned __int16 *)(a2 + 80);
  if (*(unsigned __int8 *)(a2 + 82) - 1 < 5) {
    int v11 = (*(unsigned char *)(a2 + 82) - 1) + 1;
  }
  else {
    int v11 = 0;
  }
  int v16 = *(unsigned __int8 *)(a2 + 26);
  int v17 = v11;
  sub_1000593FC((uint64_t)&v29, (long long *)(a2 + 48));
  if (*(unsigned __int8 *)(a2 + 83) - 1 < 3) {
    int v12 = (*(unsigned char *)(a2 + 83) - 1) + 1;
  }
  else {
    int v12 = 0;
  }
  int v13 = *(unsigned __int8 *)(a2 + 84);
  int v14 = *(unsigned __int8 *)(a2 + 85);
  int v15 = *(_DWORD *)(a2 + 88);
  sub_1000593FC((uint64_t)v26, (long long *)(a2 + 96));
  sub_1000593FC((uint64_t)__p, (long long *)(a2 + 128));
  sub_10017F4A4(a2, v22, v21, v16 != 0, v6 != 0, v7 != 0, v8 != 0, v9 != 0, v10 != 0, v20, v19, v18, SHIDWORD(v18), v17, &v29, v12, v13 != 0, v14 != 0, v15,
    (long long *)v26,
    (long long *)__p);
  if (v25 && v24 < 0) {
    operator delete(__p[0]);
  }
  if (v28 && v27 < 0) {
    operator delete(v26[0]);
  }
  if (v31)
  {
    if (v30 < 0) {
      operator delete((void *)v29);
    }
  }
}

void sub_1007F48D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  if (a30 && a29 < 0) {
    operator delete(__p);
  }
  if (a37 && a36 < 0) {
    operator delete(a31);
  }
  if (*(unsigned char *)(v37 - 96))
  {
    if (*(char *)(v37 - 97) < 0) {
      operator delete(*(void **)(v37 - 120));
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007F4934()
{
  return sub_100180344();
}

void sub_1007F4940(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)xpc_object_t v23 = 0u;
  long long v24 = 0u;
  if (*(unsigned char *)(a2 + 65))
  {
    int v3 = (char *)sub_1008A1E44(*(unsigned __int8 *)(a2 + 64));
    sub_100058DB0(&v21, v3);
    *(_OWORD *)xpc_object_t v23 = v21;
    *(void *)&long long v24 = v22;
    BYTE8(v24) = 1;
  }
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  if (*(unsigned char *)(a2 + 61)) {
    BOOL v5 = *(unsigned char *)(a2 + 60) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v6 = !v5;
  if (*(unsigned char *)(a2 + 63)) {
    BOOL v7 = *(unsigned char *)(a2 + 62) == 0;
  }
  else {
    BOOL v7 = 1;
  }
  char v8 = !v7;
  sub_1000593FC((uint64_t)v18, (long long *)v23);
  int v9 = *(unsigned __int8 *)(a2 + 56);
  int v10 = *(unsigned __int8 *)(a2 + 57);
  int v11 = *(unsigned __int8 *)(a2 + 58);
  int v12 = *(unsigned __int8 *)(a2 + 59);
  int v13 = *(unsigned __int8 *)(a2 + 66);
  sub_1000593FC((uint64_t)__p, (long long *)(a2 + 72));
  if ((v13 - 1) < 3) {
    int v14 = (v13 - 1) + 1;
  }
  else {
    int v14 = 0;
  }
  sub_10017FCC8(a2, (long long *)v18, a2 + 32, v9 != 0, v10 != 0, v11 != 0, v12 != 0, v6, v8, v4 | ((unint64_t)(v4 != 0) << 32), v14, (long long *)__p);
  if (v17 && v16 < 0) {
    operator delete(__p[0]);
  }
  if (v20 && v19 < 0) {
    operator delete(v18[0]);
  }
  if (BYTE8(v24))
  {
    if (SBYTE7(v24) < 0) {
      operator delete(v23[0]);
    }
  }
}

void sub_1007F4AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  if (a37)
  {
    if (a36 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007F4B30()
{
  return sub_100180670();
}

void sub_1007F4B5C(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    char v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  char v27 = (xpc_object_t *)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v27);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    int v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  int v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11) {
    goto LABEL_34;
  }
LABEL_10:
  xpc_object_t v31 = 0;
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v14 = v13;
  if (v13)
  {
    xpc_object_t v31 = v13;
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
    xpc_object_t v31 = v14;
    if (!v14)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v15 = xpc_null_create();
LABEL_17:
    xpc_object_t v31 = v15;
    goto LABEL_18;
  }
  xpc_retain(v14);
LABEL_18:
  xpc_release(v14);
  xpc_object_t v29 = xpc_BOOL_create(*(unsigned char *)a2);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  char v27 = &v31;
  char v28 = "in_buddy";
  sub_100035E70((uint64_t)&v27, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_object_t v25 = xpc_int64_create(*(unsigned int *)(a2 + 4));
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  char v27 = &v31;
  char v28 = "transferable_plans";
  sub_100035E70((uint64_t)&v27, &v25, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_int64_create(*(unsigned int *)(a2 + 8));
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  char v27 = &v31;
  char v28 = "selected_transferable_plans";
  sub_100035E70((uint64_t)&v27, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_object_t v21 = xpc_int64_create(*(unsigned int *)(a2 + 12));
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  char v27 = &v31;
  char v28 = "als_plans";
  sub_100035E70((uint64_t)&v27, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_object_t v19 = xpc_int64_create(*(unsigned int *)(a2 + 16));
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  char v27 = &v31;
  char v28 = "selected_als_plans";
  sub_100035E70((uint64_t)&v27, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_object_t v17 = xpc_int64_create(*(unsigned int *)(a2 + 20));
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  char v27 = &v31;
  char v28 = "oda_plans";
  sub_100035E70((uint64_t)&v27, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v17);
  xpc_object_t v16 = v31;
  xpc_object_t v17 = 0;
  if (v31) {
    xpc_retain(v31);
  }
  else {
    xpc_object_t v16 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v11 + 16))(v11, "commCenterCellularPlanSimSetupUsage", &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v31);
LABEL_34:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1007F4F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v11 - 56));
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1007F4FA8(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  char v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v29 = (xpc_object_t *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v29);
  if (!v11)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    char v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  char v12 = (std::__shared_weak_count *)v11[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v13) {
    goto LABEL_34;
  }
LABEL_10:
  xpc_object_t v33 = 0;
  xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v16 = v15;
  if (v15)
  {
    xpc_object_t v33 = v15;
  }
  else
  {
    xpc_object_t v16 = xpc_null_create();
    xpc_object_t v33 = v16;
    if (!v16)
    {
      xpc_object_t v17 = xpc_null_create();
      xpc_object_t v16 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v16) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v17 = xpc_null_create();
LABEL_17:
    xpc_object_t v33 = v17;
    goto LABEL_18;
  }
  xpc_retain(v16);
LABEL_18:
  xpc_release(v16);
  xpc_object_t v31 = xpc_int64_create(*a2);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  xpc_object_t v29 = &v33;
  xpc_object_t v30 = "upload_reasons";
  sub_100035E70((uint64_t)&v29, &v31, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_object_t v27 = xpc_int64_create(a2[1]);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  xpc_object_t v29 = &v33;
  xpc_object_t v30 = "upload_type";
  sub_100035E70((uint64_t)&v29, &v27, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v25 = xpc_BOOL_create(*((unsigned char *)a2 + 8));
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_object_t v29 = &v33;
  xpc_object_t v30 = "result";
  sub_100035E70((uint64_t)&v29, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_BOOL_create(*((unsigned char *)a2 + 9));
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  xpc_object_t v29 = &v33;
  xpc_object_t v30 = "isBlocklisting";
  sub_100035E70((uint64_t)&v29, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_object_t v21 = xpc_int64_create(a3);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_object_t v29 = &v33;
  xpc_object_t v30 = "upload_count";
  sub_100035E70((uint64_t)&v29, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_object_t v19 = xpc_int64_create(a2[3]);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_object_t v29 = &v33;
  xpc_object_t v30 = "error_code";
  sub_100035E70((uint64_t)&v29, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v18 = v33;
  xpc_object_t v19 = 0;
  if (v33) {
    xpc_retain(v33);
  }
  else {
    xpc_object_t v18 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v13 + 16))(v13, "commCenterCellularPlanCloudUploadDetails", &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v33);
LABEL_34:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_1007F5370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v11 - 72));
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1007F5400(uint64_t a1, uint64_t a2, int a3, int a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  unsigned int v8 = ServiceMap;
  if (v9 < 0)
  {
    char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_46;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  char v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15) {
    goto LABEL_46;
  }
LABEL_10:
  xpc_object_t v36 = 0;
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v18 = v17;
  if (v17)
  {
    xpc_object_t v36 = v17;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v36 = v18;
    if (!v18)
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v19 = xpc_null_create();
LABEL_17:
    xpc_object_t v36 = v19;
    goto LABEL_18;
  }
  xpc_retain(v18);
LABEL_18:
  xpc_release(v18);
  if (*(char *)(a2 + 23) >= 0) {
    xpc_object_t v20 = (const char *)a2;
  }
  else {
    xpc_object_t v20 = *(const char **)a2;
  }
  xpc_object_t object = xpc_string_create(v20);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  __p[0] = &v36;
  __p[1] = "carrier_name";
  sub_100035E70((uint64_t)__p, &object, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v21 = 2 * (a3 == 1);
  if (a3 == 2) {
    uint64_t v21 = 3;
  }
  sub_100058DB0(__p, off_101A0C270[v21]);
  if (v31 >= 0) {
    xpc_object_t v22 = __p;
  }
  else {
    xpc_object_t v22 = (void **)__p[0];
  }
  xpc_object_t v32 = xpc_string_create((const char *)v22);
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  char v28 = &v36;
  xpc_object_t v29 = "plan_type";
  sub_100035E70((uint64_t)&v28, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  if ((a4 - 1) > 2) {
    xpc_object_t v23 = "kUnknownNotification";
  }
  else {
    xpc_object_t v23 = off_101A0C290[(char)(a4 - 1)];
  }
  sub_100058DB0(__p, v23);
  if (v31 >= 0) {
    xpc_object_t v24 = __p;
  }
  else {
    xpc_object_t v24 = (void **)__p[0];
  }
  xpc_object_t v26 = xpc_string_create((const char *)v24);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  char v28 = &v36;
  xpc_object_t v29 = "notification_type";
  sub_100035E70((uint64_t)&v28, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v25 = v36;
  if (v36) {
    xpc_retain(v36);
  }
  else {
    xpc_object_t v25 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterCellularPlanCarrierPushNotification", &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v36);
LABEL_46:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1007F577C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 72));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007F57F4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v3;
  unint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v15);
  if (v7)
  {
    uint64_t v9 = v7[3];
    unsigned int v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  unsigned int v8 = 0;
  char v10 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v9 + 248))(__p, v9);
  unint64_t v11 = v14;
  if ((v14 & 0x80u) != 0) {
    unint64_t v11 = (unint64_t)__p[1];
  }
  if (v11 == 6)
  {
    if (((char)v14 & 0x80000000) == 0) {
      goto LABEL_16;
    }
  }
  else if (((char)v14 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(__p[0]);
LABEL_16:
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  return sub_10017EB54();
}

void sub_1007F5A18(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F5A34(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  unsigned __int8 v14 = ServiceMap;
  if ((v15 & 0x8000000000000000) != 0)
  {
    char v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      unint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v37 = (xpc_object_t *)v15;
  xpc_object_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&v37);
  if (!v19)
  {
    uint64_t v21 = 0;
LABEL_9:
    std::mutex::unlock(v14);
    xpc_object_t v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_64;
    }
    goto LABEL_10;
  }
  uint64_t v21 = v19[3];
  xpc_object_t v20 = (std::__shared_weak_count *)v19[4];
  if (!v20) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v14);
  atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v20);
  char v22 = 0;
  if (!v21) {
    goto LABEL_64;
  }
LABEL_10:
  xpc_object_t v41 = 0;
  xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v24 = v23;
  if (v23)
  {
    xpc_object_t v41 = v23;
  }
  else
  {
    xpc_object_t v24 = xpc_null_create();
    xpc_object_t v41 = v24;
    if (!v24)
    {
      xpc_object_t v25 = xpc_null_create();
      xpc_object_t v24 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v24) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v24);
    goto LABEL_18;
  }
  xpc_object_t v25 = xpc_null_create();
LABEL_17:
  xpc_object_t v41 = v25;
LABEL_18:
  xpc_release(v24);
  if (*((char *)a2 + 23) < 0)
  {
    if (!a2[1]) {
      goto LABEL_26;
    }
    a2 = (uint64_t *)*a2;
  }
  else if (!*((unsigned char *)a2 + 23))
  {
    goto LABEL_26;
  }
  xpc_object_t object = xpc_string_create((const char *)a2);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v37 = &v41;
  xpc_object_t v38 = "action";
  sub_100035E70((uint64_t)&v37, &object, &v40);
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
LABEL_26:
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1]) {
      goto LABEL_34;
    }
    a3 = (uint64_t *)*a3;
  }
  else if (!*((unsigned char *)a3 + 23))
  {
    goto LABEL_34;
  }
  xpc_object_t v35 = xpc_string_create((const char *)a3);
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  uint64_t v37 = &v41;
  xpc_object_t v38 = "carrier_name";
  sub_100035E70((uint64_t)&v37, &v35, &v36);
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_release(v35);
  xpc_object_t v35 = 0;
LABEL_34:
  xpc_object_t v33 = xpc_uint64_create(a4);
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  uint64_t v37 = &v41;
  xpc_object_t v38 = "daysSinceNotification";
  sub_100035E70((uint64_t)&v37, &v33, &v34);
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_release(v33);
  xpc_object_t v33 = 0;
  if (*((char *)a5 + 23) < 0)
  {
    if (!a5[1]) {
      goto LABEL_44;
    }
    a5 = (uint64_t *)*a5;
  }
  else if (!*((unsigned char *)a5 + 23))
  {
    goto LABEL_44;
  }
  xpc_object_t v31 = xpc_string_create((const char *)a5);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  uint64_t v37 = &v41;
  xpc_object_t v38 = "eventResult";
  sub_100035E70((uint64_t)&v37, &v31, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
LABEL_44:
  if (*((char *)a6 + 23) < 0)
  {
    if (!a6[1]) {
      goto LABEL_52;
    }
    a6 = (uint64_t *)*a6;
  }
  else if (!*((unsigned char *)a6 + 23))
  {
    goto LABEL_52;
  }
  xpc_object_t v29 = xpc_string_create((const char *)a6);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  uint64_t v37 = &v41;
  xpc_object_t v38 = "eventType";
  sub_100035E70((uint64_t)&v37, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
LABEL_52:
  if ((*((char *)a7 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a7 + 23)) {
      goto LABEL_60;
    }
LABEL_57:
    xpc_object_t v27 = xpc_string_create((const char *)a7);
    if (!v27) {
      xpc_object_t v27 = xpc_null_create();
    }
    uint64_t v37 = &v41;
    xpc_object_t v38 = "notificationResult";
    sub_100035E70((uint64_t)&v37, &v27, &v28);
    xpc_release(v28);
    xpc_object_t v28 = 0;
    xpc_release(v27);
    xpc_object_t v27 = 0;
    goto LABEL_60;
  }
  if (a7[1])
  {
    a7 = (uint64_t *)*a7;
    goto LABEL_57;
  }
LABEL_60:
  xpc_object_t v26 = v41;
  if (v41) {
    xpc_retain(v41);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v21 + 16))(v21, "commCenterCellularPlanInstallReplace", &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v41);
LABEL_64:
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v20);
  }
}

void sub_1007F5EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v11 - 88));
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1007F5F3C(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a2 + 24);
  double v32 = *(double *)(a2 + 96);
  if (*(unsigned char *)(a2 + 24))
  {
    double v4 = *(double *)(a2 + 104) - *(double *)(a2 + 96);
    if (v4 >= 0.0) {
      unint64_t v5 = (unint64_t)v4;
    }
    else {
      LOBYTE(v5) = -1;
    }
    if (v4 >= 0.0) {
      unint64_t v6 = (unint64_t)v4 & 0xFFFFFFFFFFFFFF00;
    }
    else {
      unint64_t v6 = -256;
    }
  }
  else
  {
    LOBYTE(v5) = 0;
    unint64_t v6 = 0;
  }
  double v7 = *(double *)(a2 + 32);
  double v8 = *(double *)(a2 + 40);
  double v10 = *(double *)(a2 + 48);
  double v9 = *(double *)(a2 + 56);
  double v12 = *(double *)(a2 + 64);
  double v11 = *(double *)(a2 + 72);
  double v13 = *(double *)(a2 + 88);
  double v31 = *(double *)(a2 + 80);
  int v14 = *(unsigned __int8 *)(a2 + 26);
  double v15 = *(double *)(a2 + 112);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  uint64_t v17 = ServiceMap;
  if ((v18 & 0x8000000000000000) != 0)
  {
    xpc_object_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      unint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v54 = (xpc_object_t *)v18;
  char v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v54);
  if (!v22)
  {
    uint64_t v24 = 0;
LABEL_17:
    std::mutex::unlock(v17);
    xpc_object_t v23 = 0;
    char v25 = 1;
    if (!v24) {
      goto LABEL_67;
    }
    goto LABEL_18;
  }
  uint64_t v24 = v22[3];
  xpc_object_t v23 = (std::__shared_weak_count *)v22[4];
  if (!v23) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v17);
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  char v25 = 0;
  if (!v24) {
    goto LABEL_67;
  }
LABEL_18:
  v58[0] = 0;
  xpc_object_t v26 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v27 = v26;
  if (v26)
  {
    v58[0] = v26;
  }
  else
  {
    xpc_object_t v27 = xpc_null_create();
    v58[0] = v27;
    if (!v27)
    {
      xpc_object_t v28 = xpc_null_create();
      xpc_object_t v27 = 0;
      goto LABEL_25;
    }
  }
  if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v27);
    goto LABEL_26;
  }
  xpc_object_t v28 = xpc_null_create();
LABEL_25:
  v58[0] = v28;
LABEL_26:
  xpc_release(v27);
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    xpc_object_t v29 = (const char *)a2;
    if (!*(unsigned char *)(a2 + 23)) {
      goto LABEL_34;
    }
LABEL_31:
    xpc_object_t v56 = xpc_string_create(v29);
    if (!v56) {
      xpc_object_t v56 = xpc_null_create();
    }
    uint64_t v54 = v58;
    char v55 = "carrier_name";
    sub_100035E70((uint64_t)&v54, &v56, &v57);
    xpc_release(v57);
    xpc_object_t v57 = 0;
    xpc_release(v56);
    xpc_object_t v56 = 0;
    goto LABEL_34;
  }
  if (*(void *)(a2 + 8))
  {
    xpc_object_t v29 = *(const char **)a2;
    goto LABEL_31;
  }
LABEL_34:
  xpc_object_t v52 = xpc_BOOL_create(*(unsigned char *)(a2 + 24));
  if (!v52) {
    xpc_object_t v52 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "is_enabled";
  sub_100035E70((uint64_t)&v54, &v52, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v52);
  xpc_object_t v52 = 0;
  if (*(unsigned __int8 *)(a2 + 27) >= 8u) {
    int64_t v30 = 1;
  }
  else {
    int64_t v30 = *(unsigned __int8 *)(a2 + 27);
  }
  xpc_object_t v50 = xpc_int64_create(v30);
  if (!v50) {
    xpc_object_t v50 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "transfer_type";
  sub_100035E70((uint64_t)&v54, &v50, &v51);
  xpc_release(v51);
  xpc_object_t v51 = 0;
  xpc_release(v50);
  xpc_object_t v50 = 0;
  xpc_object_t v48 = xpc_uint64_create((unint64_t)(v8 - v7));
  if (!v48) {
    xpc_object_t v48 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "ta_duration";
  sub_100035E70((uint64_t)&v54, &v48, &v49);
  xpc_release(v49);
  xpc_object_t v49 = 0;
  xpc_release(v48);
  xpc_object_t v48 = 0;
  xpc_object_t v46 = xpc_uint64_create((unint64_t)(v9 - v10));
  if (!v46) {
    xpc_object_t v46 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "ta_via_webservice_duration";
  sub_100035E70((uint64_t)&v54, &v46, &v47);
  xpc_release(v47);
  xpc_object_t v47 = 0;
  xpc_release(v46);
  xpc_object_t v46 = 0;
  xpc_object_t v44 = xpc_uint64_create((unint64_t)(v11 - v12));
  if (!v44) {
    xpc_object_t v44 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "tss_duration";
  sub_100035E70((uint64_t)&v54, &v44, &v45);
  xpc_release(v45);
  xpc_object_t v45 = 0;
  xpc_release(v44);
  xpc_object_t v44 = 0;
  xpc_object_t v42 = xpc_BOOL_create(*(unsigned char *)(a2 + 26));
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "used_discover_service";
  sub_100035E70((uint64_t)&v54, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  if (v14)
  {
    xpc_object_t v40 = xpc_uint64_create((unint64_t)(v13 - v31));
    if (!v40) {
      xpc_object_t v40 = xpc_null_create();
    }
    uint64_t v54 = v58;
    char v55 = "als_duration";
    sub_100035E70((uint64_t)&v54, &v40, &v41);
    xpc_release(v41);
    xpc_object_t v41 = 0;
    xpc_release(v40);
    xpc_object_t v40 = 0;
  }
  if (v15 != 0.0)
  {
    xpc_object_t v38 = xpc_uint64_create((unint64_t)(v13 - v15));
    if (!v38) {
      xpc_object_t v38 = xpc_null_create();
    }
    uint64_t v54 = v58;
    char v55 = "websheet_duration";
    sub_100035E70((uint64_t)&v54, &v38, &v39);
    xpc_release(v39);
    xpc_object_t v39 = 0;
    xpc_release(v38);
    xpc_object_t v38 = 0;
  }
  xpc_object_t v36 = xpc_uint64_create((unint64_t)(v32 - v13));
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  uint64_t v54 = v58;
  char v55 = "fetch_duration";
  sub_100035E70((uint64_t)&v54, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  if (v3)
  {
    xpc_object_t v34 = xpc_uint64_create(v6 | v5);
    if (!v34) {
      xpc_object_t v34 = xpc_null_create();
    }
    uint64_t v54 = v58;
    char v55 = "service_up_duration";
    sub_100035E70((uint64_t)&v54, &v34, &v35);
    xpc_release(v35);
    xpc_object_t v35 = 0;
    xpc_release(v34);
    xpc_object_t v34 = 0;
  }
  xpc_object_t v33 = v58[0];
  if (v58[0]) {
    xpc_retain(v58[0]);
  }
  else {
    xpc_object_t v33 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v24 + 16))(v24, "commCenterCellularPlanTransferDurations", &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v58[0]);
LABEL_67:
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
}

void sub_1007F65B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v14 - 160));
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007F6650()
{
  return sub_100180AAC();
}

void sub_1007F6658(uint64_t a1, uint64_t a2, BOOL a3, uint64_t a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  double v8 = ServiceMap;
  if (v9 < 0)
  {
    double v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v27 = (xpc_object_t *)v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v27);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    uint64_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15) {
    goto LABEL_34;
  }
LABEL_10:
  xpc_object_t v31 = 0;
  xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v18 = v17;
  if (v17)
  {
    xpc_object_t v31 = v17;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
    xpc_object_t v31 = v18;
    if (!v18)
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v19 = xpc_null_create();
LABEL_17:
    xpc_object_t v31 = v19;
    goto LABEL_18;
  }
  xpc_retain(v18);
LABEL_18:
  xpc_release(v18);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v20 = (const char *)a2;
  }
  else {
    uint64_t v20 = *(const char **)a2;
  }
  xpc_object_t v29 = xpc_string_create(v20);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "InstallType";
  sub_100035E70((uint64_t)&v27, &v29, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_object_t v25 = xpc_BOOL_create(a3);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "ReceiptSent";
  sub_100035E70((uint64_t)&v27, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (*(char *)(a4 + 23) >= 0) {
    unsigned int v21 = (const char *)a4;
  }
  else {
    unsigned int v21 = *(const char **)a4;
  }
  xpc_object_t v23 = xpc_string_create(v21);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "Reason";
  sub_100035E70((uint64_t)&v27, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v22 = v31;
  xpc_object_t v23 = 0;
  if (v31) {
    xpc_retain(v31);
  }
  else {
    xpc_object_t v22 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "commCenterCellularPlanInstallReceipt", &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v31);
LABEL_34:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1007F6940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18)
{
  xpc_release(object);
  xpc_release(a18);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_1007F69AC(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  double v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v17[0] = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, v17);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    double v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_24;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  double v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11) {
    goto LABEL_24;
  }
LABEL_10:
  xpc_object_t v20 = 0;
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v14 = v13;
  if (v13)
  {
    xpc_object_t v20 = v13;
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
    xpc_object_t v20 = v14;
    if (!v14)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v15 = xpc_null_create();
LABEL_17:
    xpc_object_t v20 = v15;
    goto LABEL_18;
  }
  xpc_retain(v14);
LABEL_18:
  xpc_release(v14);
  xpc_object_t v18 = xpc_uint64_create(a2);
  if (!v18) {
    xpc_object_t v18 = xpc_null_create();
  }
  v17[0] = (unint64_t)&v20;
  v17[1] = (unint64_t)"ManateeAccessDurationSeconds";
  sub_100035E70((uint64_t)v17, &v18, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_object_t v16 = v20;
  if (v20) {
    xpc_retain(v20);
  }
  else {
    xpc_object_t v16 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v11 + 16))(v11, "commCenterCellularPlanManateeAccessDuration", &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v20);
LABEL_24:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1007F6BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14)
{
  xpc_release(object);
  xpc_release(a14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

void sub_1007F6C1C(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  double v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v27 = (xpc_object_t *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v27);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    double v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_38;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  double v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11) {
    goto LABEL_38;
  }
LABEL_10:
  xpc_object_t v31 = 0;
  xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v14 = v13;
  if (v13)
  {
    xpc_object_t v31 = v13;
  }
  else
  {
    xpc_object_t v14 = xpc_null_create();
    xpc_object_t v31 = v14;
    if (!v14)
    {
      xpc_object_t v15 = xpc_null_create();
      xpc_object_t v14 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v15 = xpc_null_create();
LABEL_17:
    xpc_object_t v31 = v15;
    goto LABEL_18;
  }
  xpc_retain(v14);
LABEL_18:
  xpc_release(v14);
  if (*(unsigned char *)a2) {
    xpc_object_t v16 = "Buddy";
  }
  else {
    xpc_object_t v16 = "Postbuddy";
  }
  xpc_object_t v29 = xpc_string_create(v16);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "buddyState";
  sub_100035E70((uint64_t)&v27, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (*(char *)(a2 + 31) >= 0) {
    xpc_object_t v17 = (const char *)(a2 + 8);
  }
  else {
    xpc_object_t v17 = *(const char **)(a2 + 8);
  }
  xpc_object_t v25 = xpc_string_create(v17);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "carrierName";
  sub_100035E70((uint64_t)&v27, &v25, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_object_t v23 = xpc_int64_create(*(unsigned int *)(a2 + 32));
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "setupType";
  sub_100035E70((uint64_t)&v27, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_object_t v21 = xpc_int64_create(*(unsigned int *)(a2 + 36));
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "setupResult";
  sub_100035E70((uint64_t)&v27, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_object_t v19 = xpc_int64_create(*(unsigned int *)(a2 + 40));
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_object_t v27 = &v31;
  xpc_object_t v28 = "setupDuration";
  sub_100035E70((uint64_t)&v27, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v18 = v31;
  xpc_object_t v19 = 0;
  if (v31) {
    xpc_retain(v31);
  }
  else {
    xpc_object_t v18 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v11 + 16))(v11, "commCenterCellularPlanSetupTime", &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v31);
LABEL_38:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1007F6FAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v11 - 56));
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1007F7030(uint64_t a1, BOOL a2, const char *a3, const char *a4, const char *a5, const char *a6)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 24));
  char v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    xpc_object_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v33 = (xpc_object_t *)v13;
  xpc_object_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v33);
  if (!v17)
  {
    uint64_t v19 = 0;
LABEL_9:
    std::mutex::unlock(v12);
    xpc_object_t v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_40;
    }
    goto LABEL_10;
  }
  uint64_t v19 = v17[3];
  xpc_object_t v18 = (std::__shared_weak_count *)v17[4];
  if (!v18) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
  if (!v19) {
    goto LABEL_40;
  }
LABEL_10:
  xpc_object_t v37 = 0;
  xpc_object_t v21 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v22 = v21;
  if (v21)
  {
    xpc_object_t v37 = v21;
  }
  else
  {
    xpc_object_t v22 = xpc_null_create();
    xpc_object_t v37 = v22;
    if (!v22)
    {
      xpc_object_t v23 = xpc_null_create();
      xpc_object_t v22 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v22) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v23 = xpc_null_create();
LABEL_17:
    xpc_object_t v37 = v23;
    goto LABEL_18;
  }
  xpc_retain(v22);
LABEL_18:
  xpc_release(v22);
  xpc_object_t v35 = xpc_BOOL_create(a2);
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  xpc_object_t v33 = &v37;
  xpc_object_t v34 = "dynamicBootstrap";
  sub_100035E70((uint64_t)&v33, &v35, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v35);
  xpc_object_t v35 = 0;
  if (a3[23] < 0) {
    a3 = *(const char **)a3;
  }
  xpc_object_t v31 = xpc_string_create(a3);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  xpc_object_t v33 = &v37;
  xpc_object_t v34 = "registrationStatus";
  sub_100035E70((uint64_t)&v33, &v31, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (a4[23] < 0) {
    a4 = *(const char **)a4;
  }
  xpc_object_t v29 = xpc_string_create(a4);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  xpc_object_t v33 = &v37;
  xpc_object_t v34 = "roamingStatus";
  sub_100035E70((uint64_t)&v33, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (a5[23] < 0) {
    a5 = *(const char **)a5;
  }
  xpc_object_t v27 = xpc_string_create(a5);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  xpc_object_t v33 = &v37;
  xpc_object_t v34 = "internetStatus";
  sub_100035E70((uint64_t)&v33, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (a6[23] < 0) {
    a6 = *(const char **)a6;
  }
  xpc_object_t v25 = xpc_string_create(a6);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_object_t v33 = &v37;
  xpc_object_t v34 = "buddyState";
  sub_100035E70((uint64_t)&v33, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v24 = v37;
  xpc_object_t v25 = 0;
  if (v37) {
    xpc_retain(v37);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v19 + 16))(v19, "commCenterBootstrapAssertion", &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v37);
LABEL_40:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_1007F73E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v11 - 88));
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1007F7470(void *a1)
{
  sub_1007F750C(a1);

  operator delete();
}

void sub_1007F74A8()
{
}

void sub_1007F74E8()
{
}

void *sub_1007F750C(void *a1)
{
  *a1 = off_101A0C038;
  char v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t *sub_1007F7564(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  int v3 = sub_10001C8F4(8);
  unint64_t v5 = (wis::WISServerConnection *)*v3;
  double v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    uint64_t v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    unsigned int v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 52))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 52) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_1007F76C4(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void sub_1007F7714(void *a1, uint64_t a2)
{
  int v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    unint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1007F778C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1007F77A0(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  id result = (void *)a2[6];
  if (result) {
    id result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_1007F77EC(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_1007F7840(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  unint64_t v5 = (wis::WISServerConnection *)*v3;
  double v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    uint64_t v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    unsigned int v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 52))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 52) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_1007F79A0(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void sub_1007F79F0(wis::MetricFactory *a1, uint64_t a2, char a3)
{
  uint64_t v9 = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000;
  uint64_t v11 = sub_1007F7C14;
  uint64_t v12 = &unk_101A0C2A8;
  char v15 = a3;
  unint64_t v13 = a1;
  uint64_t v14 = a2;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v4 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8007Eu);
  if (v4)
  {
    unint64_t v5 = (wis::MetricContainer *)v4;
    unint64_t v6 = sub_10001C8F4(8);
    uint64_t v8 = *v6;
    uint64_t v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v8) {
      operator new();
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
    wis::MetricContainer::~MetricContainer(v5);
    operator delete();
  }
}

void sub_1007F7B74(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_1007F7C14(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 48)) {
    int v4 = 1;
  }
  else {
    int v4 = 2;
  }
  unint64_t v5 = *(NSObject **)(*(void *)(a1 + 32) + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v6 = *(uint64_t **)(a1 + 40);
    if (*((char *)v6 + 23) < 0) {
      unint64_t v6 = (uint64_t *)*v6;
    }
    int v10 = 136315394;
    uint64_t v11 = v6;
    __int16 v12 = 1024;
    int v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Submitting cellular data blocked metric for bundle: %s ,with user response was: %d", (uint8_t *)&v10, 0x12u);
  }
  uint64_t v7 = *(const std::string **)(a1 + 40);
  *(_DWORD *)(a2 + 32) |= 2u;
  uint64_t v8 = *(std::string **)(a2 + 16);
  if (v8 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  id result = std::string::operator=(v8, v7);
  *(_DWORD *)(a2 + 32) |= 4u;
  *(_DWORD *)(a2 + 24) = v4;
  return result;
}

const void **sub_1007F7D50@<X0>(const __CFDictionary **a1@<X8>)
{
  CFDictionaryRef v2 = CFPreferencesCopyMultiple(0, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFDictionaryRef theDict = v2;
  if (v2) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFIndex Count = CFDictionaryGetCount(v2);
    keys = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    sub_10019E8F0(&keys, Count);
    values = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    sub_10004EE3C(&values, Count);
    CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, Count, theDict);
    unint64_t v5 = (CFStringRef *)keys;
    unint64_t v6 = v14;
    if (keys != v14)
    {
      do
      {
        CFStringRef v7 = *v5;
        if (!CFStringHasPrefix(*v5, @"phone.services.")
          && !CFStringHasPrefix(v7, @"assignments.")
          && !CFStringHasPrefix(v7, @"dev.")
          && !CFStringHasPrefix(v7, @"device."))
        {
          CFDictionaryRemoveValue(MutableCopy, v7);
        }
        ++v5;
      }
      while (v5 != (CFStringRef *)v6);
    }
    sub_10004EFE4(a1, (CFTypeRef *)&MutableCopy);
    sub_10005717C((const void **)&MutableCopy);
    if (values)
    {
      uint64_t v11 = values;
      operator delete(values);
    }
    if (keys)
    {
      uint64_t v14 = keys;
      operator delete(keys);
    }
  }
  else
  {
    *a1 = v2;
    CFDictionaryRef theDict = 0;
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_1007F7EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }
  sub_100057D78(&a16);
  _Unwind_Resume(a1);
}

const void **sub_1007F7F5C(uint64_t a1)
{
  CFDictionaryRef v2 = CFPreferencesCopyMultiple(0, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFDictionaryRef theDict = v2;
  if (v2) {
    uint64_t v3 = sub_100080778;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFIndex Count = CFDictionaryGetCount(v2);
    unint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315650;
      xpc_object_t v25 = "";
      __int16 v26 = 2080;
      xpc_object_t v27 = "";
      __int16 v28 = 2048;
      CFIndex v29 = Count;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sLocal store has %ld records", buf, 0x20u);
    }
    if (Count)
    {
      keys = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      sub_10019E8F0(&keys, Count);
      values = 0;
      unsigned int v16 = 0;
      uint64_t v17 = 0;
      sub_10004EE3C(&values, Count);
      CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, Count, theDict);
      unint64_t v6 = keys;
      for (uint64_t i = v19; v6 != i; ++v6)
      {
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          long long v22 = 0uLL;
          uint64_t v23 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v22;
          uint64_t v13 = v23;
          uint64_t v9 = (void **)v22;
          if (v23 >= 0) {
            uint64_t v9 = __p;
          }
          *(_DWORD *)std::string buf = 136315650;
          xpc_object_t v25 = "";
          __int16 v26 = 2080;
          xpc_object_t v27 = "";
          __int16 v28 = 2080;
          CFIndex v29 = (CFIndex)v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s  %s", buf, 0x20u);
          if (SHIBYTE(v13) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      sub_10005717C((const void **)&MutableCopy);
      if (values)
      {
        unsigned int v16 = values;
        operator delete(values);
      }
      if (keys)
      {
        uint64_t v19 = keys;
        operator delete(keys);
      }
    }
  }
  else
  {
    int v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      xpc_object_t v25 = "";
      __int16 v26 = 2080;
      xpc_object_t v27 = "";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sLocal store does not exist", buf, 0x16u);
    }
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_1007F823C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,const void *a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  sub_100057D78(&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1007F82A8(BOOL a1, char a2)
{
  if (a2) {
    return 1;
  }
  BOOL v6 = a1;
  uint64_t v3 = sub_100365D74();
  sub_100058DB0(__p, "Thumper.settings.IDS");
  sub_1002260B0(v3, __p, &v6);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_1007F8320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007F833C(uint64_t a1, void *a2, int a3, NSObject **a4, char *a5)
{
  uint64_t v9 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, a5);
  sub_1007F8444(v9, a4, &v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *(void *)a1 = off_101A0C2D8;
  *(void *)(a1 + 48) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 56) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 72) = a1 + 80;
  *(_DWORD *)(a1 + 96) = a3;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 178) = 0u;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 224) = 0;
  return a1;
}

void sub_1007F8430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1007F8444(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  char v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1007F84AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1007F84D0(uint64_t a1)
{
  *(void *)a1 = off_101A0C2D8;
  CFDictionaryRef v2 = *(std::__shared_weak_count **)(a1 + 216);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 200));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 184);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 160);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  CFStringRef v7 = *(std::__shared_weak_count **)(a1 + 136);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 120);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_1000558F4((const void **)(a1 + 104));
  sub_1008071BC(a1 + 72, *(void **)(a1 + 80));
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 56);
  if (v9) {
    sub_10004D2C8(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1007F85F4(void *a1)
{
  sub_10003E168(&v25, a1 + 1);
  uint64_t v3 = v25;
  CFDictionaryRef v2 = v26;
  if (v26)
  {
    atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  if ((sub_1007F89C4((uint64_t)a1) & 1) == 0)
  {
    uint64_t v4 = a1[3];
    xpc_object_t v24 = v4;
    if (v4) {
      dispatch_retain(v4);
    }
    uint64_t v17 = _NSConcreteStackBlock;
    uint64_t v18 = 1174405120;
    uint64_t v19 = sub_1007F8AC8;
    uint64_t v20 = &unk_101A0C348;
    xpc_object_t v21 = a1;
    uint64_t v22 = v3;
    uint64_t v23 = v2;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100C05CFC();
  }
  uint64_t v5 = a1[19];
  uint64_t v6 = a1[3];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 1174405120;
  v15[2] = sub_1007F9854;
  void v15[3] = &unk_101A0C378;
  void v15[4] = a1;
  v15[5] = v3;
  unsigned int v16 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v5 + 16))(v5, v6, v15);
  uint64_t v7 = a1[18];
  uint64_t v8 = a1[3];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_1007F98DC;
  v13[3] = &unk_101A0C3A8;
  void v13[4] = a1;
  v13[5] = v3;
  uint64_t v14 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v7 + 64))(v7, v8, v13);
  uint64_t v9 = a1[21];
  uint64_t v10 = a1[3];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 1174405120;
  v11[2] = sub_1007F9BCC;
  void v11[3] = &unk_101A0C3D8;
  void v11[4] = a1;
  void v11[5] = v3;
  OsLogContext v12 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v9 + 64))(v9, v10, v11);
  sub_1007F9F60((uint64_t)a1);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1007F8914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30)
{
  uint64_t v34 = *(void *)(v32 - 96);
  *(void *)(v32 - 96) = 0;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 24))(v34);
  }
  xpc_object_t v35 = *(std::__shared_weak_count **)(v32 - 112);
  if (v35) {
    std::__shared_weak_count::__release_weak(v35);
  }
  if (v31) {
    dispatch_release(v31);
  }
  if (v30) {
    std::__shared_weak_count::__release_weak(v30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007F89C4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  CFDictionaryRef v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    uint64_t v9 = (GestaltUtilityInterface *)v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  uint64_t isWatch = GestaltUtilityInterface::isWatch(v9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  return isWatch;
}

void sub_1007F8AAC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007F8AC8(void *a1, int a2, uint64_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[5])
      {
        v47[0] = 0;
        v47[1] = 0;
        uint64_t v48 = 0;
        uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
        if ((v10 & 0x80u) != 0) {
          uint64_t v10 = *(void *)(a3 + 8);
        }
        if (v10) {
          sub_100639AD0((const void **)a3);
        }
        else {
          sub_100058DB0(v47, "");
        }
        uint64_t v11 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          OsLogContext v12 = "signed-in";
          if (a2 == 1) {
            OsLogContext v12 = "signed-out";
          }
          if (a2 == 2) {
            OsLogContext v12 = "accounts daemon ready";
          }
          unint64_t v13 = *(void ***)a3;
          BOOL v14 = *(char *)(a3 + 23) < 0;
          uint64_t v15 = (void **)v47[0];
          *(_DWORD *)std::string buf = 136316162;
          if (!v14) {
            unint64_t v13 = (void **)a3;
          }
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "";
          if (v48 >= 0) {
            uint64_t v15 = v47;
          }
          *(_WORD *)&unsigned char buf[22] = 2080;
          char v55 = (void *)v12;
          __int16 v56 = 2080;
          xpc_object_t v57 = v13;
          __int16 v58 = 2080;
          uint64_t v59 = v15;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%siCloud status event '%s' with name '%s' %s", buf, 0x34u);
        }
        switch(a2)
        {
          case 2:
            *(unsigned char *)(v7 + 192) = 1;
            xpc_object_t v44 = 0;
            sub_1003A9CA0(buf);
            __p[0] = (void *)sub_1003A9B04(*(uint64_t *)buf, @"last.known.icloud.id", 0);
            sub_100225AE0(&v44, (CFTypeRef *)__p);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            *(_OWORD *)xpc_object_t v42 = *(_OWORD *)buf;
            uint64_t v43 = *(void *)&buf[16];
            uint64_t v17 = *(NSObject **)(v7 + 40);
            int v18 = SHIBYTE(v48);
            if (v48 >= 0) {
              uint64_t v19 = (void *)HIBYTE(v48);
            }
            else {
              uint64_t v19 = v47[1];
            }
            if (os_log_type_enabled(*(os_log_t *)(v7 + 40), OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v20 = (void **)v47[0];
              xpc_object_t v21 = "not ";
              if (v19) {
                xpc_object_t v21 = "";
              }
              if (v18 >= 0) {
                uint64_t v20 = v47;
              }
              *(_DWORD *)std::string buf = 136316162;
              *(void *)&uint8_t buf[4] = "";
              uint64_t v22 = v42;
              if (v43 < 0) {
                uint64_t v22 = (void **)v42[0];
              }
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = "";
              *(_WORD *)&unsigned char buf[22] = 2080;
              char v55 = (void *)v21;
              __int16 v56 = 2080;
              xpc_object_t v57 = v20;
              __int16 v58 = 2080;
              uint64_t v59 = v22;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%siCloud status: %ssigned, ID '%s', last known ID '%s'", buf, 0x34u);
            }
            if (v19)
            {
              if (!sub_1007F9398((unsigned __int8 *)v47))
              {
                uint64_t v23 = (void *)HIBYTE(v43);
                int v24 = SHIBYTE(v43);
                if (v43 < 0) {
                  uint64_t v23 = v42[1];
                }
                if (v23)
                {
                  uint64_t v25 = *(NSObject **)(v7 + 40);
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                  {
                    __int16 v26 = (void **)v42[0];
                    if (v24 >= 0) {
                      __int16 v26 = v42;
                    }
                    xpc_object_t v27 = v47;
                    if (v48 < 0) {
                      xpc_object_t v27 = (void **)v47[0];
                    }
                    *(_DWORD *)std::string buf = 136315906;
                    *(void *)&uint8_t buf[4] = "";
                    *(_WORD *)&buf[12] = 2080;
                    *(void *)&buf[14] = "";
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    char v55 = v26;
                    __int16 v56 = 2080;
                    xpc_object_t v57 = v27;
                    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%siCloud ID was changed from %s to %s while offline?!?! Execute Sign-out procedures...", buf, 0x2Au);
                  }
                  sub_1007F95D0(v7);
                }
                sub_1003A9CA0(&v40);
                uint64_t v28 = v40;
                if (SHIBYTE(v48) < 0)
                {
                  sub_10004FC84(v37, v47[0], (unint64_t)v47[1]);
                }
                else
                {
                  *(_OWORD *)xpc_object_t v37 = *(_OWORD *)v47;
                  uint64_t v38 = v48;
                }
                if (SHIBYTE(v38) < 0)
                {
                  sub_10004FC84(__p, v37[0], (unint64_t)v37[1]);
                }
                else
                {
                  *(_OWORD *)std::string __p = *(_OWORD *)v37;
                  uint64_t v51 = v38;
                }
                xpc_object_t v49 = 0;
                if (SHIBYTE(v51) < 0)
                {
                  sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
                }
                else
                {
                  *(_OWORD *)std::string buf = *(_OWORD *)__p;
                  *(void *)&uint8_t buf[16] = v51;
                }
                xpc_object_t v52 = 0;
                if (ctu::cf::convert_copy())
                {
                  xpc_object_t v35 = v49;
                  xpc_object_t v49 = v52;
                  char v53 = v35;
                  sub_1000558F4(&v53);
                }
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
                xpc_object_t v39 = v49;
                xpc_object_t v49 = 0;
                sub_1000558F4(&v49);
                if (SHIBYTE(v51) < 0) {
                  operator delete(__p[0]);
                }
                sub_1003A9C3C(v28, @"last.known.icloud.id", v39);
                sub_1000558F4(&v39);
                if (SHIBYTE(v38) < 0) {
                  operator delete(v37[0]);
                }
                if (v41) {
                  sub_10004D2C8(v41);
                }
              }
              *(unsigned char *)(v7 + 193) = 1;
              uint64_t v36 = *(void *)(v7 + 144);
              if (v36) {
                (*(void (**)(uint64_t))(*(void *)v36 + 72))(v36);
              }
            }
            else
            {
              if (v44) {
                xpc_object_t v30 = sub_1000810B8;
              }
              else {
                xpc_object_t v30 = 0;
              }
              if (v30)
              {
                xpc_object_t v31 = *(NSObject **)(v7 + 40);
                if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v32 = v42;
                  if (v43 < 0) {
                    uint64_t v32 = (void **)v42[0];
                  }
                  *(_DWORD *)std::string buf = 136315650;
                  *(void *)&uint8_t buf[4] = "";
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = "";
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  char v55 = v32;
                  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%siCloud ID %s is gone. Cleanup if needed...", buf, 0x20u);
                }
                sub_1007F95D0(v7);
              }
            }
            if (SHIBYTE(v43) < 0) {
              operator delete(v42[0]);
            }
            sub_1000558F4(&v44);
            break;
          case 1:
            *(unsigned char *)(v7 + 193) = 0;
            sub_1007F95D0(v7);
            break;
          case 0:
            *(unsigned char *)(v7 + 193) = 1;
            if (sub_1007F9398((unsigned __int8 *)v47))
            {
              uint64_t v16 = *(void *)(v7 + 144);
              if (v16) {
                (*(void (**)(uint64_t))(*(void *)v16 + 72))(v16);
              }
            }
            else
            {
              sub_1003A9CA0(v42);
              CFIndex v29 = v42[0];
              if (SHIBYTE(v48) < 0)
              {
                sub_10004FC84(__dst, v47[0], (unint64_t)v47[1]);
              }
              else
              {
                *(_OWORD *)long long __dst = *(_OWORD *)v47;
                uint64_t v46 = v48;
              }
              if (SHIBYTE(v46) < 0)
              {
                sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)__dst;
                uint64_t v51 = v46;
              }
              xpc_object_t v52 = 0;
              if (SHIBYTE(v51) < 0)
              {
                sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
              }
              else
              {
                *(_OWORD *)std::string buf = *(_OWORD *)__p;
                *(void *)&uint8_t buf[16] = v51;
              }
              char v53 = 0;
              if (ctu::cf::convert_copy())
              {
                uint64_t v33 = (uint64_t)v52;
                xpc_object_t v52 = v53;
                uint64_t v40 = v33;
                sub_1000558F4((const void **)&v40);
              }
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              uint64_t v34 = v52;
              xpc_object_t v49 = v52;
              xpc_object_t v52 = 0;
              sub_1000558F4(&v52);
              if (SHIBYTE(v51) < 0) {
                operator delete(__p[0]);
              }
              sub_1003A9C3C((uint64_t)v29, @"last.known.icloud.id", v34);
              sub_1000558F4(&v49);
              if (SHIBYTE(v46) < 0) {
                operator delete(__dst[0]);
              }
              if (v42[1]) {
                sub_10004D2C8((std::__shared_weak_count *)v42[1]);
              }
            }
            break;
        }
        sub_1007F96BC((void *)v7);
        if (SHIBYTE(v48) < 0) {
          operator delete(v47[0]);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1007F9230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,const void *a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  sub_1000558F4(&a38);
  if (a44 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_1000558F4(&a24);
  if (a37 < 0) {
    operator delete(a32);
  }
  sub_10004D2C8(v44);
  _Unwind_Resume(a1);
}

BOOL sub_1007F9398(unsigned __int8 *a1)
{
  int v24 = 0;
  sub_1003A9CA0(__p);
  v22[0] = (void *)sub_1003A9B04((uint64_t)__p[0], @"last.known.icloud.id", 0);
  sub_100225AE0(&v24, (CFTypeRef *)v22);
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v26 = 0;
  ctu::cf::assign();
  uint64_t v23 = v26;
  *(_OWORD *)uint64_t v22 = *(_OWORD *)__p;
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    unint64_t v3 = (void *)a1[23];
  }
  else {
    unint64_t v3 = (void *)*((void *)a1 + 1);
  }
  uint64_t v4 = (void *)HIBYTE(v23);
  char v5 = HIBYTE(v23);
  if (v23 < 0) {
    uint64_t v4 = v22[1];
  }
  if (v3 != v4) {
    goto LABEL_19;
  }
  if (v23 >= 0) {
    unsigned int v6 = v22;
  }
  else {
    unsigned int v6 = (void **)v22[0];
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, v6, *((void *)a1 + 1))) {
      goto LABEL_19;
    }
LABEL_39:
    BOOL v20 = 1;
    if (v5 < 0) {
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  if (!a1[23]) {
    goto LABEL_39;
  }
  uint64_t v7 = a1;
  while (*v7 == *(unsigned __int8 *)v6)
  {
    ++v7;
    unsigned int v6 = (void **)((char *)v6 + 1);
    if (!--v2) {
      goto LABEL_39;
    }
  }
LABEL_19:
  sub_100639AD0((const void **)v22);
  uint64_t v8 = a1[23];
  if ((v8 & 0x80u) == 0) {
    uint64_t v9 = (void *)a1[23];
  }
  else {
    uint64_t v9 = (void *)*((void *)a1 + 1);
  }
  uint64_t v10 = (void *)HIBYTE(v26);
  int v11 = SHIBYTE(v26);
  if (v26 < 0) {
    uint64_t v10 = __p[1];
  }
  if (v9 != v10)
  {
    BOOL v20 = 0;
    if ((SHIBYTE(v26) & 0x80000000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  if (v26 >= 0) {
    OsLogContext v12 = __p;
  }
  else {
    OsLogContext v12 = (void **)__p[0];
  }
  if ((v8 & 0x80) != 0)
  {
    BOOL v20 = memcmp(*(const void **)a1, v12, *((void *)a1 + 1)) == 0;
    goto LABEL_42;
  }
  if (a1[23])
  {
    uint64_t v13 = v8 - 1;
    do
    {
      int v15 = *a1++;
      int v14 = v15;
      int v17 = *(unsigned __int8 *)v12;
      OsLogContext v12 = (void **)((char *)v12 + 1);
      int v16 = v17;
      BOOL v19 = v13-- != 0;
      BOOL v20 = v14 == v16;
    }
    while (v14 == v16 && v19);
LABEL_42:
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  BOOL v20 = 1;
  if (SHIBYTE(v26) < 0) {
LABEL_43:
  }
    operator delete(__p[0]);
LABEL_44:
  if (v23 < 0) {
LABEL_45:
  }
    operator delete(v22[0]);
LABEL_46:
  sub_1000558F4(&v24);
  return v20;
}

void sub_1007F9580(_Unwind_Exception *a1, void *a2, uint64_t a3, int a4, __int16 a5, char a6, char a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if (a7 < 0) {
    operator delete(a2);
  }
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1007F95D0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  unint64_t v3 = (void *)(a1 + 80);
  if (v2 != (void *)(a1 + 80))
  {
    do
    {
      uint64_t v4 = (std::__shared_weak_count *)v2[6];
      if (v4)
      {
        char v5 = std::__shared_weak_count::lock(v4);
        if (v5)
        {
          unsigned int v6 = v5;
          uint64_t v7 = v2[5];
          if (v7) {
            (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
          }
          sub_10004D2C8(v6);
        }
      }
      uint64_t v8 = (void *)v2[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v2[2];
          BOOL v10 = *v9 == (void)v2;
          uint64_t v2 = v9;
        }
        while (!v10);
      }
      uint64_t v2 = v9;
    }
    while (v9 != v3);
  }
  sub_1007FA5A4(a1);

  sub_1007F9F60(a1);
}

void sub_1007F96A8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007F96BC(void *a1)
{
  if ((*(unsigned int (**)(void *))(*a1 + 16))(a1))
  {
    (*(void (**)(void *, uint64_t))(*a1 + 88))(a1, 1);
    uint64_t v2 = (void *)a1[9];
    unint64_t v3 = a1 + 10;
    if (v2 != a1 + 10)
    {
      do
      {
        uint64_t v4 = (std::__shared_weak_count *)v2[6];
        if (v4)
        {
          char v5 = std::__shared_weak_count::lock(v4);
          if (v5)
          {
            unsigned int v6 = v5;
            uint64_t v7 = v2[5];
            if (v7) {
              (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
            }
            sub_10004D2C8(v6);
          }
        }
        uint64_t v8 = (void *)v2[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v2[2];
            BOOL v10 = *v9 == (void)v2;
            uint64_t v2 = v9;
          }
          while (!v10);
        }
        uint64_t v2 = v9;
      }
      while (v9 != v3);
    }
  }
}

void sub_1007F97C8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007F97DC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007F97F8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_1007F9808(void *a1, uint64_t *a2)
{
  sub_10080721C((uint64_t *)&v6, a2);
  unint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v6;
  *(void *)&long long v6 = *a1;
  *((void *)&v6 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1007F9854(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    unint64_t v3 = (void *)a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (a1[5]) {
        sub_1007F96BC(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1007F98C8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007F98DC(void *a1, const void *a2, const __CFArray *a3, int a4)
{
  char v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v9 = a1[4];
    BOOL v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      int v11 = v10;
      if (a1[5])
      {
        if (a3) {
          CFIndex Count = CFArrayGetCount(a3);
        }
        else {
          CFIndex Count = 0;
        }
        uint64_t v13 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(v9 + 144) + 88))(*(void *)(v9 + 144));
          int v15 = ". FULL SYNC";
          *(_DWORD *)std::string buf = 136316162;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&buf[12] = 2080;
          if (a4) {
            int v15 = "";
          }
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2048;
          int v24 = (void *)Count;
          *(_WORD *)uint64_t v25 = 2080;
          *(void *)&v25[2] = v14;
          *(_WORD *)&v25[10] = 2080;
          *(void *)&v25[12] = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sReceived %zu record(s) via %s%s", buf, 0x34u);
        }
        if (a4) {
          a3 = 0;
        }
        xpc_object_t v21 = a2;
        if (a2) {
          CFRetain(a2);
        }
        CFArrayRef v20 = a3;
        if (a3) {
          CFRetain(a3);
        }
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 1174405120;
        unint64_t v17[2] = sub_1007FB210;
        v17[3] = &unk_101A0C468;
        void v17[4] = v9;
        CFArrayRef v18 = a3;
        if (a3) {
          CFRetain(a3);
        }
        BOOL v19 = a2;
        if (a2) {
          CFRetain(a2);
        }
        long long v22 = 0uLL;
        sub_10003E168(&v22, (void *)(v9 + 8));
        int v16 = *(NSObject **)(v9 + 24);
        *(void *)std::string buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 1174405120;
        *(void *)&uint8_t buf[16] = sub_10080734C;
        int v24 = &unk_101A0C648;
        *(_OWORD *)&v25[8] = v22;
        if (*((void *)&v22 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v22 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v25 = v17;
        dispatch_async(v16, buf);
        if (*(void *)&v25[16]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v25[16]);
        }
        if (*((void *)&v22 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v22 + 1));
        }
        sub_100057D78(&v19);
        sub_100044D00((const void **)&v18);
        sub_100044D00((const void **)&v20);
        sub_100057D78(&v21);
      }
      sub_10004D2C8(v11);
    }
  }
}

void sub_1007F9B90(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1007F9BCC(void *a1, const __CFDictionary *a2, const __CFArray *a3)
{
  long long v4 = (std::__shared_weak_count *)a1[6];
  if (!v4) {
    return;
  }
  uint64_t v7 = (void *)a1[4];
  uint64_t v8 = std::__shared_weak_count::lock(v4);
  if (!v8) {
    return;
  }
  uint64_t v9 = v8;
  if (a1[5] && a2 && a3 && CFArrayGetCount(a3))
  {
    v33.length = CFArrayGetCount(a3);
    v33.location = 0;
    if (CFArrayContainsValue(a3, v33, @"message."))
    {
      CFDictionaryRef Value = CFDictionaryGetValue(a2, @"message.");
      int v11 = Value;
      if (Value)
      {
        CFTypeID v12 = CFGetTypeID(Value);
        if (v12 == CFDictionaryGetTypeID())
        {
          CFTypeID v13 = CFGetTypeID(v11);
          if (v13 != CFDictionaryGetTypeID()) {
            int v11 = 0;
          }
          uint64_t v14 = CFDictionaryGetValue((CFDictionaryRef)v11, @"cmd");
          int v15 = v14;
          if (v14 && (CFTypeID v16 = CFGetTypeID(v14), v16 == CFStringGetTypeID()))
          {
            int v17 = CFDictionaryGetValue((CFDictionaryRef)v11, @"sender");
            CFArrayRef v18 = v17;
            if (v17)
            {
              CFTypeID v19 = CFGetTypeID(v17);
              if (v19 != CFStringGetTypeID()) {
                CFArrayRef v18 = 0;
              }
            }
            CFArrayRef v20 = CFDictionaryGetValue((CFDictionaryRef)v11, @"value");
            (*(void (**)(void *, const void *, const void *, const void *, const void *))(*v7 + 104))(v7, v15, v18, v20, v11);
          }
          else
          {
            uint64_t v26 = v7[5];
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)xpc_object_t v27 = 136315394;
              *(void *)&uint8_t v27[4] = "";
              *(_WORD *)&v27[12] = 2080;
              *(void *)&v27[14] = "";
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "#E %s%sMessage cmd is invalid or of wrong type: ", v27, 0x16u);
            }
            *(void *)xpc_object_t v27 = off_101A0C8A8;
            *(void *)&v27[8] = v7;
            CFArrayRef v29 = (const __CFArray *)v27;
            logger::CFTypeRefLogger();
            sub_10012C330(v27);
          }
          goto LABEL_27;
        }
      }
      xpc_object_t v21 = v7[5];
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)xpc_object_t v27 = 136315650;
        *(void *)&uint8_t v27[4] = "";
        *(_WORD *)&v27[12] = 2080;
        *(void *)&v27[14] = "";
        __int16 v28 = 2112;
        CFArrayRef v29 = (const __CFArray *)v11;
        long long v22 = "#I %s%sMessage is invalid or of wrong type: %@";
        uint64_t v23 = v21;
        uint32_t v24 = 32;
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, v27, v24);
      }
    }
    else
    {
      uint64_t v25 = v7[5];
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)xpc_object_t v27 = 136315906;
        *(void *)&uint8_t v27[4] = "";
        *(_WORD *)&v27[12] = 2080;
        *(void *)&v27[14] = "";
        __int16 v28 = 2112;
        CFArrayRef v29 = a3;
        __int16 v30 = 2112;
        CFDictionaryRef v31 = a2;
        long long v22 = "#I %s%sUnknown message received. changes: %@, dict: %@";
        uint64_t v23 = v25;
        uint32_t v24 = 42;
        goto LABEL_23;
      }
    }
  }
LABEL_27:

  sub_10004D2C8(v9);
}

void sub_1007F9F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10012C330(&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_1007F9F60(uint64_t a1)
{
  xpc_object_t v47 = 0;
  uint64_t v48 = 0;
  sub_100800ED0(&v47, a1);
  xpc_object_t v44 = 0;
  long long __dst = 0;
  unint64_t v46 = 0;
  uint64_t v2 = v47;
  sub_100807108((uint64_t *)&v44, (unint64_t)v47[20]);
  unint64_t v3 = v2[18];
  long long v4 = v2 + 19;
  if (v3 != (uint64_t *)(v2 + 19))
  {
    unint64_t v5 = (unint64_t)__dst;
    do
    {
      long long v6 = (long long *)(v3 + 4);
      if (v5 >= v46)
      {
        unint64_t v5 = sub_100048008((uint64_t *)&v44, v6);
      }
      else
      {
        if (*((char *)v3 + 55) < 0)
        {
          sub_10004FC84((unsigned char *)v5, (void *)v3[4], v3[5]);
        }
        else
        {
          long long v7 = *v6;
          *(void *)(v5 + 16) = v3[6];
          *(_OWORD *)unint64_t v5 = v7;
        }
        v5 += 24;
      }
      long long __dst = (void *)v5;
      uint64_t v8 = (uint64_t *)v3[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (uint64_t *)v3[2];
          BOOL v10 = *v9 == (void)v3;
          unint64_t v3 = v9;
        }
        while (!v10);
      }
      unint64_t v3 = v9;
    }
    while (v9 != (uint64_t *)v4);
  }
  if (*(_DWORD *)(a1 + 96)) {
    goto LABEL_64;
  }
  memset(buf, 0, sizeof(buf));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  CFTypeID v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v13;
  int v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)__p);
  if (!v17)
  {
    uint64_t v19 = 0;
    goto LABEL_23;
  }
  uint64_t v19 = v17[3];
  CFArrayRef v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
LABEL_23:
    std::mutex::unlock(v12);
    CFArrayRef v18 = 0;
    char v20 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
LABEL_24:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v19 + 192))(buf, v19);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  xpc_object_t v21 = *(uint8_t **)buf;
  if (*(uint8_t **)buf != &buf[8])
  {
    while (1)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v43 = 0;
      sub_100639AD0((const void **)v21 + 4);
      uint64_t v23 = v44;
      long long v22 = (char *)__dst;
      if (v44 != __dst) {
        break;
      }
LABEL_47:
      if (v23 == v22) {
        goto LABEL_48;
      }
LABEL_55:
      if (SHIBYTE(v43) < 0) {
        operator delete(__p[0]);
      }
      CFDictionaryRef v31 = (uint8_t *)*((void *)v21 + 1);
      if (v31)
      {
        do
        {
          uint64_t v32 = v31;
          CFDictionaryRef v31 = *(uint8_t **)v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          uint64_t v32 = (uint8_t *)*((void *)v21 + 2);
          BOOL v10 = *(void *)v32 == (void)v21;
          xpc_object_t v21 = v32;
        }
        while (!v10);
      }
      xpc_object_t v21 = v32;
      if (v32 == &buf[8]) {
        goto LABEL_63;
      }
    }
    if (v43 >= 0) {
      uint32_t v24 = (void *)HIBYTE(v43);
    }
    else {
      uint32_t v24 = __p[1];
    }
    if (v43 >= 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = (void **)__p[0];
    }
    do
    {
      uint64_t v26 = v23[23];
      if ((v26 & 0x80u) == 0) {
        unint64_t v27 = v23[23];
      }
      else {
        unint64_t v27 = *((void *)v23 + 1);
      }
      if ((void *)v27 == v24)
      {
        if ((v26 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v23, v25, *((void *)v23 + 1))) {
            goto LABEL_47;
          }
        }
        else
        {
          if (!v23[23]) {
            goto LABEL_47;
          }
          uint64_t v28 = 0;
          while (v23[v28] == *((unsigned char *)v25 + v28))
          {
            if (v26 == ++v28) {
              goto LABEL_47;
            }
          }
        }
      }
      v23 += 24;
    }
    while (v23 != v22);
LABEL_48:
    if ((unint64_t)v22 >= v46)
    {
      __int16 v30 = (void *)sub_100048008((uint64_t *)&v44, (long long *)__p);
    }
    else
    {
      if (SHIBYTE(v43) < 0)
      {
        sub_10004FC84(v22, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v29 = *(_OWORD *)__p;
        *((void *)v22 + 2) = v43;
        *(_OWORD *)long long v22 = v29;
      }
      __int16 v30 = v22 + 24;
    }
    long long __dst = v30;
    goto LABEL_55;
  }
LABEL_63:
  sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
LABEL_64:
  (*(void (**)(void, char **))(**(void **)(a1 + 152) + 72))(*(void *)(a1 + 152), &v44);
  CFRange v33 = v47;
  uint64_t v34 = v47[12];
  for (uint64_t i = v47[13]; v34 != i; v34 += 3)
  {
    uint64_t v36 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = (uint64_t)v34;
      if (*((char *)v34 + 23) < 0) {
        uint64_t v37 = *v34;
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v50 = v37;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%sremoving unencryptable account record for %s", buf, 0x20u);
    }
    sub_1007FE5B8(a1, 1u, 0, 0, (long long *)v34, *(_DWORD *)(a1 + 96) == 0, 0);
    sub_1007FE5B8(a1, 0, 0, 0, (long long *)v34, *(_DWORD *)(a1 + 96) == 0, 0);
  }
  uint64_t v38 = v33[15];
  for (j = v33[16]; v38 != j; v38 += 3)
  {
    uint64_t v40 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = (uint64_t)v38;
      if (*((char *)v38 + 23) < 0) {
        uint64_t v41 = *v38;
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      uint64_t v50 = v41;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sremoving outdated account record for %s", buf, 0x20u);
    }
    sub_1007FE5B8(a1, 1u, 0, 0, (long long *)v38, *(_DWORD *)(a1 + 96) == 0, 0);
    sub_1007FE5B8(a1, 0, 0, 0, (long long *)v38, *(_DWORD *)(a1 + 96) == 0, 0);
  }
  *(void *)std::string buf = &v44;
  sub_100047F64((void ***)buf);
  if (v48) {
    sub_10004D2C8(v48);
  }
}

void sub_1007FA4FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,char *a22,uint64_t a23)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  a22 = &a17;
  sub_100047F64((void ***)&a22);
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(a1);
}

const void **sub_1007FA5A4(uint64_t a1)
{
  CFDictionaryRef v2 = CFPreferencesCopyMultiple(0, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFDictionaryRef theDict = v2;
  if (v2) {
    unint64_t v3 = sub_100080778;
  }
  else {
    unint64_t v3 = 0;
  }
  if (v3)
  {
    CFIndex Count = CFDictionaryGetCount(v2);
    if (Count)
    {
      keys = 0;
      int v17 = 0;
      uint64_t v18 = 0;
      sub_10019E8F0(&keys, Count);
      values = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      sub_10004EE3C(&values, Count);
      CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
      unint64_t v5 = keys;
      for (uint64_t i = v17; v5 != i; ++v5)
      {
        CFStringRef v7 = (const __CFString *)*v5;
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          long long v20 = 0uLL;
          uint64_t v21 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v20;
          uint64_t v12 = v21;
          uint64_t v9 = (void **)v20;
          if (v21 >= 0) {
            uint64_t v9 = __p;
          }
          *(_DWORD *)std::string buf = 136315650;
          char v23 = "";
          __int16 v24 = 2080;
          uint64_t v25 = "";
          __int16 v26 = 2080;
          unint64_t v27 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sremove %s from local storage", buf, 0x20u);
          if (SHIBYTE(v12) < 0) {
            operator delete(__p[0]);
          }
        }
        sub_1007FF448(a1, v7, 0, 0, 0, 1);
      }
      if (values)
      {
        uint64_t v14 = values;
        operator delete(values);
      }
      if (keys)
      {
        int v17 = keys;
        operator delete(keys);
      }
    }
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_1007FA7C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,const void *a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  sub_100057D78(&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1007FA824(void *a1)
{
  if (a1[13]) {
    CFDictionaryRef v2 = sub_1000810B8;
  }
  else {
    CFDictionaryRef v2 = 0;
  }
  if (!v2 && (byte_101B0D9E8 & 1) == 0)
  {
    unint64_t v3 = a1[5];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sdevice id not yet known - request", buf, 0x16u);
    }
    byte_101B0D9E8 = 1;
    sub_10003E168(buf, a1 + 1);
    uint64_t v5 = *(void *)buf;
    long long v4 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v4);
    }
    long long v6 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    CFStringRef v7 = dispatch_queue_create("ThumperExchange IDS initialization queue", v6);
    uint64_t v8 = v7;
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    block[2] = sub_1007FA9F0;
    block[3] = &unk_101A0C438;
    block[4] = a1;
    block[5] = v5;
    int v11 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_async(v7, block);
    if (v11) {
      std::__shared_weak_count::__release_weak(v11);
    }
    if (v8) {
      dispatch_release(v8);
    }
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1[13];
}

const void **sub_1007FA9F0(void *a1)
{
  uint64_t v2 = a1[4];
  unint64_t v3 = (const void *)IDSCopyLocalDeviceUniqueID();
  int v11 = v3;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120;
  _DWORD v8[2] = sub_1007FAB58;
  v8[3] = &unk_101A0C408;
  uint64_t v5 = a1[5];
  long long v4 = (std::__shared_weak_count *)a1[6];
  void v8[4] = v2;
  v8[5] = v5;
  uint64_t v9 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v10 = v3;
  if (v3) {
    CFRetain(v3);
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_10003E168(&v14, (void *)(v2 + 8));
  long long v6 = *(NSObject **)(v2 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10080734C;
  block[3] = &unk_101A0C648;
  block[5] = v14;
  uint64_t v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v8;
  dispatch_async(v6, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_1000558F4(&v10);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  return sub_1000558F4(&v11);
}

void sub_1007FAB58(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v7 = a1[7];
        long long v6 = (const void **)(a1 + 7);
        if (v7) {
          uint64_t v8 = sub_1000810B8;
        }
        else {
          uint64_t v8 = 0;
        }
        if (v8)
        {
          uint64_t v9 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            long long v12 = 0uLL;
            uint64_t v13 = 0;
            ctu::cf::assign();
            *(_OWORD *)std::string __p = 0uLL;
            uint64_t v11 = 0;
            *(_DWORD *)std::string buf = 136315650;
            uint64_t v15 = "";
            __int16 v16 = 2080;
            int v17 = "";
            __int16 v18 = 2080;
            uint64_t v19 = __p;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sdevice ID ready: %s", buf, 0x20u);
            if (SHIBYTE(v11) < 0) {
              operator delete(__p[0]);
            }
          }
          sub_100083EB8((const void **)(v3 + 104), v6);
          (*(void (**)(uint64_t))(*(void *)v3 + 80))(v3);
        }
        else
        {
          byte_101B0D9E8 = 0;
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1007FACF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

const void **sub_1007FAD1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_100083DA4((const void **)(a1 + 56), (const void **)(a2 + 56));
}

void sub_1007FAD40(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_1007FAD8C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1007FADA8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_1007FADB8(uint64_t a1)
{
  uint64_t result = sub_1007FA824((void *)a1);
  if (result) {
    return (sub_1007F89C4(a1) & 1) != 0 || *(unsigned char *)(a1 + 192) != 0;
  }
  return result;
}

void sub_1007FAE00(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
    BOOL v10 = (v9 & 0x80u) != 0;
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a3 + 8);
    }
    if (v10) {
      uint64_t v11 = *(const char **)a3;
    }
    else {
      uint64_t v11 = (const char *)a3;
    }
    if (v9) {
      long long v12 = v11;
    }
    else {
      long long v12 = "<invalid>";
    }
    int v21 = 136315906;
    long long v22 = "";
    __int16 v23 = 2080;
    __int16 v24 = "";
    __int16 v25 = 1024;
    int v26 = a2;
    __int16 v27 = 2080;
    uint64_t v28 = v12;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sAdding observer [%d] %s", (uint8_t *)&v21, 0x26u);
  }
  uint64_t v14 = *a4;
  uint64_t v13 = (std::__shared_weak_count *)a4[1];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  __int16 v16 = (void *)(a1 + 80);
  uint64_t v15 = *(void *)(a1 + 80);
  if (v15)
  {
    while (1)
    {
      while (1)
      {
        int v17 = (void *)v15;
        int v18 = *(_DWORD *)(v15 + 32);
        if (v18 <= a2) {
          break;
        }
        uint64_t v15 = *v17;
        __int16 v16 = v17;
        if (!*v17) {
          goto LABEL_21;
        }
      }
      if (v18 >= a2) {
        break;
      }
      uint64_t v15 = v17[1];
      if (!v15)
      {
        __int16 v16 = v17 + 1;
        goto LABEL_21;
      }
    }
    if (v13) {
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  else
  {
    int v17 = (void *)(a1 + 80);
LABEL_21:
    uint64_t v19 = operator new(0x38uLL);
    v19[8] = a2;
    *((void *)v19 + 5) = v14;
    *((void *)v19 + 6) = v13;
    *(void *)uint64_t v19 = 0;
    *((void *)v19 + 1) = 0;
    *((void *)v19 + 2) = v17;
    void *v16 = v19;
    uint64_t v20 = **(void **)(a1 + 72);
    if (v20)
    {
      *(void *)(a1 + 72) = v20;
      uint64_t v19 = (_DWORD *)*v16;
    }
    sub_100046C90(*(uint64_t **)(a1 + 80), (uint64_t *)v19);
    ++*(void *)(a1 + 88);
  }
}

void sub_1007FAFB8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007FAFD0(void *a1, int a2, uint64_t a3)
{
  long long v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(unsigned __int8 *)(a3 + 23);
    BOOL v8 = (v7 & 0x80u) != 0;
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a3 + 8);
    }
    if (v8) {
      uint64_t v9 = *(const char **)a3;
    }
    else {
      uint64_t v9 = (const char *)a3;
    }
    if (v7) {
      BOOL v10 = v9;
    }
    else {
      BOOL v10 = "<invalid>";
    }
    int v27 = 136315906;
    uint64_t v28 = "";
    __int16 v29 = 2080;
    __int16 v30 = "";
    __int16 v31 = 1024;
    int v32 = a2;
    __int16 v33 = 2080;
    uint64_t v34 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sRemoving observer [%d] %s", (uint8_t *)&v27, 0x26u);
  }
  uint64_t v11 = (uint64_t *)a1[10];
  if (v11)
  {
    long long v12 = a1 + 10;
    uint64_t v13 = a1[10];
    do
    {
      int v14 = *(_DWORD *)(v13 + 32);
      BOOL v15 = v14 < a2;
      if (v14 >= a2) {
        __int16 v16 = (uint64_t *)v13;
      }
      else {
        __int16 v16 = (uint64_t *)(v13 + 8);
      }
      if (!v15) {
        long long v12 = (void *)v13;
      }
      uint64_t v13 = *v16;
    }
    while (*v16);
    if (v12 != a1 + 10 && *((_DWORD *)v12 + 8) <= a2)
    {
      int v17 = (void *)v12[1];
      if (v17)
      {
        do
        {
          int v18 = v17;
          int v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        uint64_t v19 = v12;
        do
        {
          int v18 = (void *)v19[2];
          BOOL v20 = *v18 == (void)v19;
          uint64_t v19 = v18;
        }
        while (!v20);
      }
      if ((void *)a1[9] == v12) {
        a1[9] = v18;
      }
      --a1[11];
      sub_10005EE6C(v11, v12);
      int v21 = (std::__shared_weak_count *)v12[6];
      if (v21) {
        std::__shared_weak_count::__release_weak(v21);
      }
      operator delete(v12);
      long long v22 = a1[5];
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = *(unsigned __int8 *)(a3 + 23);
        BOOL v24 = (v23 & 0x80u) != 0;
        if ((v23 & 0x80u) != 0) {
          uint64_t v23 = *(void *)(a3 + 8);
        }
        if (v24) {
          __int16 v25 = *(const char **)a3;
        }
        else {
          __int16 v25 = (const char *)a3;
        }
        if (v23) {
          int v26 = v25;
        }
        else {
          int v26 = "<invalid>";
        }
        int v27 = 136315906;
        uint64_t v28 = "";
        __int16 v29 = 2080;
        __int16 v30 = "";
        __int16 v31 = 1024;
        int v32 = a2;
        __int16 v33 = 2080;
        uint64_t v34 = v26;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sRemoved observer [%d] %s", (uint8_t *)&v27, 0x26u);
      }
    }
  }
}

const void **sub_1007FB210(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (*(void *)(a1 + 40)) {
    uint64_t v3 = sub_100083F10;
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = v2[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    __int16 v28 = 2080;
    __int16 v29 = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sstart processing iCloud data", buf, 0x16u);
  }
  uint64_t v5 = (void *)v2[9];
  if (v5 != v2 + 10)
  {
    do
    {
      long long v6 = (std::__shared_weak_count *)v5[6];
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        if (v7)
        {
          BOOL v8 = v7;
          uint64_t v9 = v5[5];
          if (v9) {
            (*(void (**)(uint64_t))(*(void *)v9 + 48))(v9);
          }
          sub_10004D2C8(v8);
        }
      }
      BOOL v10 = (void *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          BOOL v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v5[2];
          BOOL v12 = *v11 == (void)v5;
          uint64_t v5 = v11;
        }
        while (!v12);
      }
      uint64_t v5 = v11;
    }
    while (v11 != v2 + 10);
  }
  if (v3)
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 40)) >= 1)
    {
      CFIndex v13 = 0;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v13);
        if (ValueAtIndex)
        {
          CFStringRef v15 = ValueAtIndex;
          CFTypeID v16 = CFGetTypeID(ValueAtIndex);
          if (v16 == CFStringGetTypeID())
          {
            CFDictionaryRef v17 = *(const __CFDictionary **)(a1 + 48);
            if (v17) {
              int v18 = sub_100080778;
            }
            else {
              int v18 = 0;
            }
            if (v18) {
              CFDictionaryRef Value = CFDictionaryGetValue(v17, v15);
            }
            else {
              CFDictionaryRef Value = 0;
            }
            sub_1007FB600((uint64_t)v2, v15, Value);
          }
        }
        ++v13;
      }
      while (v13 < CFArrayGetCount(*(CFArrayRef *)(a1 + 40)));
    }
    BOOL v20 = *(uint64_t (**)(void *, void))(*v2 + 96);
    return (const void **)v20(v2, 0);
  }
  else
  {
    CFMutableArrayRef theArray = 0;
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      CFMutableArrayRef v23 = theArray;
      CFMutableArrayRef theArray = Mutable;
      *(void *)std::string buf = v23;
      sub_1000440D4((const void **)buf);
    }
    CFDictionaryRef v24 = *(const __CFDictionary **)(a1 + 48);
    if (v24) {
      __int16 v25 = sub_100080778;
    }
    else {
      __int16 v25 = 0;
    }
    if (v25)
    {
      CFDictionaryGetCount(v24);
      operator new[]();
    }
    (*(void (**)(void *, CFMutableArrayRef))(*v2 + 96))(v2, theArray);
    return sub_1000440D4((const void **)&theArray);
  }
}

void sub_1007FB5CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000440D4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1007FB600(uint64_t a1, CFStringRef theString, const void *a3)
{
  if (CFStringHasPrefix(theString, @"phone.services."))
  {
    v68[0] = 0;
    v68[1] = 0;
    CFStringRef v69 = 0;
    sub_1007FCC64(@"phone.services.", v68);
    if (SHIBYTE(v69) < 0)
    {
      if (v68[1])
      {
        uint64_t v67 = 0;
        *(_OWORD *)uint64_t v65 = 0u;
        long long v66 = 0u;
LABEL_11:
        sub_1007FCD94(theString, a1, a3, (uint64_t)v65);
        if (LOBYTE(v65[0]))
        {
          sub_1007FD634(a1, theString, v67, *((uint64_t *)&v66 + 1), (uint64_t)a3, (uint64_t)v65[1]);
          sub_1003A9CA0(buf);
          sub_1003A9C3C(*(uint64_t *)buf, theString, a3);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          long long v6 = *(void **)(a1 + 72);
          *(void *)std::string buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 1174405120;
          *(void *)&uint8_t buf[16] = sub_1007FDECC;
          *(void *)&uint8_t buf[24] = &unk_101A0C498;
          if (SHIBYTE(v69) < 0)
          {
            sub_10004FC84(&v77, v68[0], (unint64_t)v68[1]);
          }
          else
          {
            long long v77 = *(_OWORD *)v68;
            CFStringRef v78 = v69;
          }
          BOOL v10 = (void *)(a1 + 80);
          if (v6 != (void *)(a1 + 80))
          {
            while (1)
            {
              LODWORD(theString2[0]) = *((_DWORD *)v6 + 8);
              uint64_t v11 = v6[6];
              theString2[1] = *((CFStringRef *)v6 + 5);
              theString2[2] = (CFStringRef)v11;
              if (v11) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
              }
              char v12 = (*(uint64_t (**)(uint8_t *, CFStringRef *))&buf[16])(buf, theString2);
              if (theString2[2]) {
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)theString2[2]);
              }
              if (v12) {
                break;
              }
              CFIndex v13 = (void *)v6[1];
              if (v13)
              {
                do
                {
                  int v14 = v13;
                  CFIndex v13 = (void *)*v13;
                }
                while (v13);
              }
              else
              {
                do
                {
                  int v14 = (void *)v6[2];
                  BOOL v15 = *v14 == (void)v6;
                  long long v6 = v14;
                }
                while (!v15);
              }
              long long v6 = v14;
              if (v14 == v10) {
                goto LABEL_47;
              }
            }
          }
          if (v6 == v10)
          {
LABEL_47:
            uint64_t v19 = *(NSObject **)(a1 + 40);
            CFTypeID v16 = (std::__shared_weak_count *)os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
            if (v16)
            {
              long long v70 = 0uLL;
              uint64_t v71 = 0;
              ctu::cf::assign();
              *(_OWORD *)std::string __p = v70;
              uint64_t v64 = v71;
              BOOL v20 = (void **)v68[0];
              int v21 = (void **)v70;
              if (v71 >= 0) {
                int v21 = __p;
              }
              if (SHIBYTE(v69) >= 0) {
                BOOL v20 = v68;
              }
              LODWORD(theString2[0]) = 136315906;
              *(CFStringRef *)((char *)theString2 + 4) = (CFStringRef)"";
              WORD2(theString2[1]) = 2080;
              *(CFStringRef *)((char *)&theString2[1] + 6) = (CFStringRef)"";
              HIWORD(theString2[2]) = 2080;
              long long v73 = v21;
              __int16 v74 = 2080;
              long long v75 = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s%s: personality %s not mine - don't react", (uint8_t *)theString2, 0x2Au);
              if (SHIBYTE(v64) < 0) {
                operator delete(__p[0]);
              }
            }
          }
          else
          {
            CFTypeID v16 = (std::__shared_weak_count *)v6[6];
            if (v16)
            {
              CFTypeID v16 = std::__shared_weak_count::lock(v16);
              if (v16)
              {
                CFDictionaryRef v17 = v16;
                uint64_t v18 = v6[5];
                if (v18)
                {
                  (*(void (**)(uint64_t, uint64_t, CFStringRef, void, void))(*(void *)v18 + 64))(v18, 1, theString, *((void *)&v66 + 1), v66);
                  sub_10004D2C8(v17);
                  goto LABEL_143;
                }
                sub_10004D2C8(v17);
              }
            }
          }
          if (!capabilities::ct::supportsThumperService((capabilities::ct *)v16))
          {
LABEL_143:
            if (SHIBYTE(v78) < 0) {
              operator delete((void *)v77);
            }
            goto LABEL_145;
          }
          memset(theString2, 0, sizeof(theString2));
          if (SHIBYTE(v69) < 0)
          {
            sub_10004FC84(theString2, v68[0], (unint64_t)v68[1]);
          }
          else
          {
            *(_OWORD *)theString2 = *(_OWORD *)v68;
            theString2[2] = v69;
          }
          long long v70 = 0uLL;
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
          xpc_object_t v44 = ServiceMap;
          if (v45 < 0)
          {
            unint64_t v46 = (unsigned __int8 *)(v45 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v47 = 5381;
            do
            {
              uint64_t v45 = v47;
              unsigned int v48 = *v46++;
              uint64_t v47 = (33 * v47) ^ v48;
            }
            while (v48);
          }
          std::mutex::lock(ServiceMap);
          __p[0] = (void *)v45;
          xpc_object_t v49 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)__p);
          if (v49)
          {
            uint64_t v51 = v49[3];
            uint64_t v50 = (std::__shared_weak_count *)v49[4];
            if (v50)
            {
              atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v44);
              atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v50);
              char v52 = 0;
              goto LABEL_126;
            }
          }
          else
          {
            uint64_t v51 = 0;
          }
          std::mutex::unlock(v44);
          uint64_t v50 = 0;
          char v52 = 1;
LABEL_126:
          (*(void (**)(long long *__return_ptr, uint64_t, CFStringRef *))(*(void *)v51 + 128))(&v70, v51, theString2);
          if ((v52 & 1) == 0) {
            sub_10004D2C8(v50);
          }
          if (!(void)v70) {
            goto LABEL_139;
          }
          char v53 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
          uint64_t v54 = v53;
          if (v55 < 0)
          {
            __int16 v56 = (unsigned __int8 *)(v55 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v57 = 5381;
            do
            {
              uint64_t v55 = v57;
              unsigned int v58 = *v56++;
              uint64_t v57 = (33 * v57) ^ v58;
            }
            while (v58);
          }
          std::mutex::lock(v53);
          __p[0] = (void *)v55;
          uint64_t v59 = sub_10004D37C(&v54[1].__m_.__sig, (unint64_t *)__p);
          if (v59)
          {
            uint64_t v61 = v59[3];
            uint64_t v60 = (std::__shared_weak_count *)v59[4];
            if (v60)
            {
              atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v54);
              atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v60);
              char v62 = 0;
              goto LABEL_137;
            }
          }
          else
          {
            uint64_t v61 = 0;
          }
          std::mutex::unlock(v54);
          uint64_t v60 = 0;
          char v62 = 1;
LABEL_137:
          (*(void (**)(uint64_t, CFStringRef *, void, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v61 + 16))(v61, theString2, kCFPSReprovisioningRequired, kCFBooleanTrue, kPhoneServicesWalletDomain, 0, 1, 0);
          if ((v62 & 1) == 0) {
            sub_10004D2C8(v60);
          }
LABEL_139:
          if (*((void *)&v70 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v70 + 1));
          }
          if (SHIBYTE(theString2[2]) < 0) {
            operator delete((void *)theString2[0]);
          }
          goto LABEL_143;
        }
LABEL_20:
        sub_1007FDA04(a1, theString, v67, *((uint64_t *)&v66 + 1), (uint64_t)a3);
LABEL_145:
        sub_100057D78((const void **)&v66 + 1);
        sub_100057D78((const void **)&v66);
        sub_1000577C4((const void **)&v65[1]);
LABEL_146:
        if (SHIBYTE(v69) < 0) {
          operator delete(v68[0]);
        }
        return;
      }
    }
    else if (HIBYTE(v69))
    {
      uint64_t v67 = 0;
      *(_OWORD *)uint64_t v65 = 0u;
      long long v66 = 0u;
      goto LABEL_11;
    }
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_146;
    }
    memset(theString2, 0, sizeof(theString2));
    ctu::cf::assign();
    *(_OWORD *)uint64_t v65 = *(_OWORD *)theString2;
    *(CFStringRef *)&long long v66 = theString2[2];
    BOOL v8 = v65;
    if (SHIBYTE(theString2[2]) < 0) {
      BOOL v8 = (CFStringRef *)theString2[0];
    }
LABEL_64:
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sinvalid key name %s", buf, 0x20u);
    if (SBYTE7(v66) < 0) {
      operator delete((void *)v65[0]);
    }
    goto LABEL_146;
  }
  if (CFStringHasPrefix(theString, @"assignments."))
  {
    v68[0] = 0;
    v68[1] = 0;
    CFStringRef v69 = 0;
    sub_1007FCC64(@"assignments.", v68);
    if (SHIBYTE(v69) < 0)
    {
      if (v68[1])
      {
        uint64_t v67 = 0;
        *(_OWORD *)uint64_t v65 = 0u;
        long long v66 = 0u;
LABEL_56:
        sub_1007FCD94(theString, a1, a3, (uint64_t)v65);
        if (LOBYTE(v65[0]))
        {
          sub_1007FD634(a1, theString, v67, *((uint64_t *)&v66 + 1), (uint64_t)a3, (uint64_t)v65[1]);
          sub_1003A9CA0(buf);
          sub_1003A9C3C(*(uint64_t *)buf, theString, a3);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          long long v22 = *(void **)(a1 + 72);
          *(void *)std::string buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 1174405120;
          *(void *)&uint8_t buf[16] = sub_1007FE054;
          *(void *)&uint8_t buf[24] = &unk_101A0C4C8;
          if (SHIBYTE(v69) < 0)
          {
            sub_10004FC84(&v77, v68[0], (unint64_t)v68[1]);
          }
          else
          {
            long long v77 = *(_OWORD *)v68;
            CFStringRef v78 = v69;
          }
          CFMutableArrayRef v23 = (void *)(a1 + 80);
          if (v22 == (void *)(a1 + 80)) {
            goto LABEL_88;
          }
          while (1)
          {
            LODWORD(theString2[0]) = *((_DWORD *)v22 + 8);
            uint64_t v24 = v22[6];
            theString2[1] = *((CFStringRef *)v22 + 5);
            theString2[2] = (CFStringRef)v24;
            if (v24) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 16), 1uLL, memory_order_relaxed);
            }
            char v25 = (*(uint64_t (**)(uint8_t *, CFStringRef *))&buf[16])(buf, theString2);
            if (theString2[2]) {
              std::__shared_weak_count::__release_weak((std::__shared_weak_count *)theString2[2]);
            }
            if (v25) {
              break;
            }
            int v26 = (void *)v22[1];
            if (v26)
            {
              do
              {
                int v27 = v26;
                int v26 = (void *)*v26;
              }
              while (v26);
            }
            else
            {
              do
              {
                int v27 = (void *)v22[2];
                BOOL v15 = *v27 == (void)v22;
                long long v22 = v27;
              }
              while (!v15);
            }
            long long v22 = v27;
            if (v27 == v23) {
              goto LABEL_88;
            }
          }
          if (v22 == v23)
          {
LABEL_88:
            int v32 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              long long v70 = 0uLL;
              uint64_t v71 = 0;
              ctu::cf::assign();
              *(_OWORD *)std::string __p = v70;
              uint64_t v64 = v71;
              __int16 v33 = (void **)v68[0];
              uint64_t v34 = __p;
              if (v71 < 0) {
                uint64_t v34 = (void **)v70;
              }
              if (SHIBYTE(v69) >= 0) {
                __int16 v33 = v68;
              }
              LODWORD(theString2[0]) = 136315906;
              *(CFStringRef *)((char *)theString2 + 4) = (CFStringRef)"";
              WORD2(theString2[1]) = 2080;
              *(CFStringRef *)((char *)&theString2[1] + 6) = (CFStringRef)"";
              HIWORD(theString2[2]) = 2080;
              long long v73 = v34;
              __int16 v74 = 2080;
              long long v75 = v33;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%s%s: personality %s not mine - don't react", (uint8_t *)theString2, 0x2Au);
              if (SHIBYTE(v64) < 0) {
                operator delete(__p[0]);
              }
            }
          }
          else
          {
            __int16 v28 = (std::__shared_weak_count *)v22[6];
            if (v28)
            {
              __int16 v29 = std::__shared_weak_count::lock(v28);
              if (v29)
              {
                __int16 v30 = v29;
                uint64_t v31 = v22[5];
                if (v31) {
                  (*(void (**)(uint64_t, uint64_t, CFStringRef, void, void))(*(void *)v31 + 80))(v31, 1, theString, *((void *)&v66 + 1), v66);
                }
                sub_10004D2C8(v30);
              }
            }
          }
          if (SHIBYTE(v78) < 0) {
            operator delete((void *)v77);
          }
          goto LABEL_145;
        }
        goto LABEL_20;
      }
    }
    else if (HIBYTE(v69))
    {
      uint64_t v67 = 0;
      *(_OWORD *)uint64_t v65 = 0u;
      long long v66 = 0u;
      goto LABEL_56;
    }
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_146;
    }
    memset(theString2, 0, sizeof(theString2));
    ctu::cf::assign();
    *(_OWORD *)uint64_t v65 = *(_OWORD *)theString2;
    *(CFStringRef *)&long long v66 = theString2[2];
    BOOL v8 = v65;
    if (SHIBYTE(theString2[2]) < 0) {
      BOOL v8 = (CFStringRef *)theString2[0];
    }
    goto LABEL_64;
  }
  if (CFStringHasPrefix(theString, @"dev.") || CFStringHasPrefix(theString, @"device."))
  {
    *(void *)&long long v77 = 0;
    memset(buf, 0, sizeof(buf));
    sub_1007FCD94(theString, a1, a3, (uint64_t)buf);
    if (buf[0])
    {
      sub_1007FD634(a1, theString, v77, *(uint64_t *)&buf[24], (uint64_t)a3, *(uint64_t *)&buf[8]);
      sub_1003A9CA0(theString2);
      sub_1003A9C3C((uint64_t)theString2[0], theString, a3);
      if (theString2[1]) {
        sub_10004D2C8((std::__shared_weak_count *)theString2[1]);
      }
      theString2[0] = 0;
      sub_1007FD308((void *)a1, 0, (const void **)theString2);
      v65[0] = 0;
      sub_1007FD430((void *)a1, 0, (const void **)v65);
      if (CFStringCompare(theString, theString2[0], 0)) {
        BOOL v9 = CFEqual(theString, v65[0]);
      }
      else {
        BOOL v9 = 1;
      }
      xpc_object_t v35 = *(void **)(a1 + 72);
      uint64_t v36 = (void *)(a1 + 80);
      if (v35 != v36)
      {
        do
        {
          uint64_t v37 = (std::__shared_weak_count *)v35[6];
          if (v37)
          {
            uint64_t v38 = std::__shared_weak_count::lock(v37);
            if (v38)
            {
              xpc_object_t v39 = v38;
              uint64_t v40 = v35[5];
              if (v40) {
                (*(void (**)(uint64_t, BOOL, CFStringRef, void, void))(*(void *)v40 + 72))(v40, v9, theString, *(void *)&buf[24], *(void *)&buf[16]);
              }
              sub_10004D2C8(v39);
            }
          }
          uint64_t v41 = (void *)v35[1];
          if (v41)
          {
            do
            {
              xpc_object_t v42 = v41;
              uint64_t v41 = (void *)*v41;
            }
            while (v41);
          }
          else
          {
            do
            {
              xpc_object_t v42 = (void *)v35[2];
              BOOL v15 = *v42 == (void)v35;
              xpc_object_t v35 = v42;
            }
            while (!v15);
          }
          xpc_object_t v35 = v42;
        }
        while (v42 != v36);
      }
      sub_1000558F4((const void **)v65);
      sub_1000558F4((const void **)theString2);
    }
    else
    {
      sub_1007FDA04(a1, theString, v77, *(uint64_t *)&buf[24], (uint64_t)a3);
    }
    sub_100057D78((const void **)&buf[24]);
    sub_100057D78((const void **)&buf[16]);
    sub_1000577C4((const void **)&buf[8]);
  }
}

void sub_1007FC234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  sub_10004D2C8(v36);
  if (*(char *)(v37 - 89) < 0) {
    operator delete(*(void **)(v37 - 112));
  }
  sub_1007FE018(&a13);
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

const void **sub_1007FC3D4(uint64_t a1, uint64_t a2)
{
  sub_100062740((const void **)(a1 + 40), (const void **)(a2 + 40));

  return sub_100058198((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_1007FC41C(uint64_t a1)
{
  uint64_t v1 = (const void **)(a1 + 40);
  sub_100057D78((const void **)(a1 + 48));

  return sub_100044D00(v1);
}

uint64_t sub_1007FC458(uint64_t a1, CFDictionaryRef theDict, long long *a3, void *a4, int a5)
{
  CFDictionaryGetValue(theDict, @"ver");
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0u;
  uint64_t v18 = 0;
  *a4 = 0;
  sub_1000593FC((uint64_t)v14, a3);
  int v9 = sub_1007FC8C0(a1, (uint64_t)v14);
  if (v16 && v15 < 0) {
    operator delete(v14[0]);
  }
  BOOL v10 = *(NSObject **)(a1 + 40);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v11)
  {
    *(_DWORD *)std::string buf = 136316674;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    CFIndex v13 = "expected exact";
    if (!a5) {
      CFIndex v13 = "local";
    }
    *(_WORD *)&unsigned char buf[22] = 2080;
    BOOL v20 = v13;
    __int16 v21 = 1024;
    int v22 = v9;
    __int16 v23 = 1024;
    int v24 = 8;
    __int16 v25 = 1024;
    int v26 = 0;
    __int16 v27 = 1024;
    int v28 = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sSchema version mismatch, %s: %u.%u, cloud has: %u.%u", buf, 0x38u);
    return 0;
  }
  return result;
}

void sub_1007FC7F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,std::bad_cast a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1007FC524);
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007FC8C0(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 24)) {
    return 2;
  }
  uint64_t v2 = *(void **)(a1 + 72);
  uint64_t v3 = (void *)(a1 + 80);
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 1174405120;
  int v26 = sub_1007FE440;
  __int16 v27 = &unk_101A0C4F8;
  sub_1000593FC((uint64_t)&__p, (long long *)a2);
  if (v2 != v3)
  {
    while (1)
    {
      int v31 = *((_DWORD *)v2 + 8);
      long long v4 = (std::__shared_weak_count *)v2[6];
      uint64_t v32 = v2[5];
      __int16 v33 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v5 = v26((uint64_t)v25, (uint64_t)&v31);
      if (v33) {
        std::__shared_weak_count::__release_weak(v33);
      }
      if (v5) {
        break;
      }
      long long v6 = (void *)v2[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          long long v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v2[2];
          BOOL v8 = *v7 == (void)v2;
          uint64_t v2 = v7;
        }
        while (!v8);
      }
      uint64_t v2 = v7;
      if (v7 == v3) {
        goto LABEL_20;
      }
    }
  }
  if (v2 != v3 && (v9 = (std::__shared_weak_count *)v2[6]) != 0 && (BOOL v10 = std::__shared_weak_count::lock(v9)) != 0)
  {
    BOOL v11 = v10;
    uint64_t v12 = v2[5];
    if (v12)
    {
      uint64_t v13 = (*(uint64_t (**)(void))(*(void *)v12 + 104))(v2[5]);
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 112))(v12);
      LOBYTE(v12) = v14;
      int v15 = BYTE4(v13);
      int v16 = v13 & 0xFFFFFF00;
      int v17 = v14 & 0xFFFFFF00;
      int v18 = BYTE4(v14);
    }
    else
    {
      int v15 = 0;
      int v17 = 0;
      int v18 = 0;
      LOBYTE(v13) = 0;
      int v16 = 0;
    }
    sub_10004D2C8(v11);
  }
  else
  {
LABEL_20:
    int v15 = 0;
    int v17 = 0;
    LOBYTE(v12) = 0;
    int v18 = 0;
    LOBYTE(v13) = 0;
    int v16 = 0;
  }
  if (v30 && v29 < 0) {
    operator delete(__p);
  }
  unsigned int v19 = v16 & 0xFFFFFF00 | v13;
  if (v19 <= 2) {
    int v20 = 2;
  }
  else {
    int v20 = v19;
  }
  if (v15) {
    unsigned int v21 = v20;
  }
  else {
    unsigned int v21 = 2;
  }
  unsigned int v22 = v17 & 0xFFFFFF00 | v12;
  if (v21 <= v22) {
    unsigned int v23 = v22;
  }
  else {
    unsigned int v23 = v21;
  }
  if (v18) {
    return v23;
  }
  else {
    return v21;
  }
}

void sub_1007FCAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  sub_10004D2C8(v23);
  if (a20)
  {
    if (a19 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1007FCB38(uint64_t a1, const __CFDictionary *a2, long long *a3, int a4)
{
  sub_1000593FC((uint64_t)__p, a3);
  uint64_t v7 = sub_1007FC458(a1, a2, (long long *)__p, &v12, a4);
  if (v11 && v10 < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_1007FCBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a16)
  {
    if (a15 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_1007FCBD8@<D0>(CFStringRef theString@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  CFStringRef v4 = @"phone.services.";
  if (CFStringHasPrefix(theString, @"phone.services.")
    || (CFStringRef v4 = @"assignments.", CFStringHasPrefix(theString, @"assignments.")))
  {
    sub_1007FCC64(v4, &v6);
    double result = *(double *)&v6;
    *(_OWORD *)a2 = v6;
    a2[2] = v7;
  }
  return result;
}

void sub_1007FCC64(CFStringRef theString@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

void sub_1007FCD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1007FCD94@<X0>(CFStringRef theString@<X1>, uint64_t a2@<X0>, const void *a3@<X2>, uint64_t a4@<X8>)
{
  CFDictionaryRef theDict = 0;
  CFDictionaryRef v36 = 0;
  int HasPrefix = CFStringHasPrefix(theString, @"dev.");
  CFTypeRef cf = 0;
  sub_1003A9CA0(&theString2);
  int v9 = sub_1003A9B04((uint64_t)theString2, theString, 0);
  CFTypeRef cf = v9;
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (v9) {
    char v10 = sub_100080934;
  }
  else {
    char v10 = 0;
  }
  if (!v10)
  {
    if (!a3)
    {
LABEL_23:
      BOOL v12 = 1;
      goto LABEL_24;
    }
    if (HasPrefix == 1)
    {
      CFTypeRef v30 = a3;
      CFRetain(a3);
    }
    else
    {
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 152) + 64))(&v30);
    }
    sub_10004EFE4(&v31, &v30);
    CFStringRef theString2 = (CFStringRef)theDict;
    CFDictionaryRef theDict = v31;
LABEL_22:
    CFDictionaryRef v31 = 0;
    sub_100057D78((const void **)&theString2);
    sub_100057D78((const void **)&v31);
    sub_1000577C4(&v30);
    goto LABEL_23;
  }
  if (!a3 || (CFTypeID v11 = CFGetTypeID(a3), v11 == CFStringGetTypeID()))
  {
    if (HasPrefix == 1)
    {
      CFTypeRef v30 = cf;
      if (cf) {
        CFRetain(cf);
      }
    }
    else
    {
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 152) + 64))(&v30);
    }
    sub_10004EFE4(&v31, &v30);
    CFStringRef theString2 = (CFStringRef)v36;
    CFDictionaryRef v36 = v31;
    goto LABEL_22;
  }
  if (HasPrefix == 1)
  {
    CFTypeRef v30 = cf;
    if (cf) {
      CFRetain(cf);
    }
  }
  else
  {
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 152) + 64))(&v30);
  }
  sub_10004EFE4(&v31, &v30);
  CFStringRef v18 = (const __CFString *)v36;
  CFDictionaryRef v36 = v31;
  CFDictionaryRef v31 = 0;
  CFStringRef theString2 = v18;
  sub_100057D78((const void **)&theString2);
  sub_100057D78((const void **)&v31);
  sub_1000577C4(&v30);
  if (HasPrefix == 1)
  {
    CFTypeRef v30 = a3;
    CFRetain(a3);
  }
  else
  {
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 152) + 64))(&v30);
  }
  sub_10004EFE4(&v31, &v30);
  CFStringRef v19 = (const __CFString *)theDict;
  CFDictionaryRef theDict = v31;
  CFDictionaryRef v31 = 0;
  CFStringRef theString2 = v19;
  sub_100057D78((const void **)&theString2);
  sub_100057D78((const void **)&v31);
  sub_1000577C4(&v30);
  if (CFEqual(cf, a3)) {
    goto LABEL_36;
  }
  if (*(_DWORD *)(a2 + 96) != 1) {
    goto LABEL_23;
  }
  sub_1007FD308((void *)a2, 0, (const void **)&theString2);
  CFComparisonResult v20 = CFStringCompare(theString, theString2, 0);
  sub_1000558F4((const void **)&theString2);
  if (v20 == kCFCompareEqualTo) {
    goto LABEL_36;
  }
  sub_1007FD430((void *)a2, 0, (const void **)&theString2);
  CFComparisonResult v21 = CFStringCompare(theString, theString2, 0);
  sub_1000558F4((const void **)&theString2);
  if (v21) {
    goto LABEL_23;
  }
  if (!(v36 ? sub_100080778 : 0)) {
    goto LABEL_23;
  }
  if (theDict) {
    unsigned int v23 = sub_100080778;
  }
  else {
    unsigned int v23 = 0;
  }
  BOOL v12 = v23 == 0;
  if (v23 && HasPrefix != 1)
  {
    if (!CFDictionaryGetValue(theDict, @"hardware"))
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"account");
      CFStringRef v25 = Value;
      if (Value)
      {
        CFTypeID v26 = CFGetTypeID(Value);
        if (v26 != CFStringGetTypeID()) {
          CFStringRef v25 = 0;
        }
      }
      CFStringRef v27 = (const __CFString *)CFDictionaryGetValue(v36, @"account");
      CFStringRef v28 = v27;
      if (!v27) {
        goto LABEL_23;
      }
      CFTypeID v29 = CFGetTypeID(v27);
      if (v29 != CFStringGetTypeID() || !v25 || CFStringCompare(v25, v28, 0)) {
        goto LABEL_23;
      }
    }
LABEL_36:
    BOOL v12 = 0;
  }
LABEL_24:
  if (theDict) {
    uint64_t v13 = sub_100080778;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13)
  {
    uint64_t v14 = (unsigned int *)CFDictionaryGetValue(theDict, @"ts");
    LODWORD(theString2) = 0;
    ctu::cf::assign((ctu::cf *)&theString2, v14, v15);
    int v16 = (int)theString2;
  }
  else
  {
    int v16 = 0;
  }
  *(unsigned char *)a4 = v12;
  sub_1000584C8((const void **)(a4 + 8), &cf);
  sub_100058198((const void **)(a4 + 16), (const void **)&v36);
  sub_100058198((const void **)(a4 + 24), (const void **)&theDict);
  *(_DWORD *)(a4 + 32) = v16;
  sub_1000577C4(&cf);
  sub_100057D78((const void **)&theDict);
  return sub_100057D78((const void **)&v36);
}

void sub_1007FD264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va2, a6);
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v9 = va_arg(va2, const void *);
  sub_1000577C4((const void **)va);
  sub_100057D78((const void **)va1);
  sub_100057D78((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_1007FD308@<X0>(void *a1@<X0>, uint64_t a2@<X1>, const void **a3@<X8>)
{
  *a3 = 0;
  if (a2) {
    goto LABEL_4;
  }
  if (sub_1007FA824(a1))
  {
    a2 = sub_1007FA824(a1);
LABEL_4:
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%@", @"dev.", a2);
    uint64_t v7 = *a3;
    *a3 = v6;
    CFNumberRef v15 = v7;
    BOOL v8 = &v15;
    return sub_1000558F4(v8);
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&v14, (const __CFString **)"device-id-is-not-yet-given", (const char *)0x8000100, kCFAllocatorDefault, v5))
  {
    char v10 = v13;
    uint64_t v13 = v14;
    CFNumberRef v15 = v10;
    sub_1000558F4(&v15);
  }
  CFTypeID v11 = v13;
  BOOL v12 = v13;
  uint64_t v13 = 0;
  sub_1000558F4(&v13);
  if (&v12 != a3)
  {
    CFNumberRef v15 = *a3;
    *a3 = v11;
    BOOL v12 = 0;
    sub_1000558F4(&v15);
  }
  BOOL v8 = &v12;
  return sub_1000558F4(v8);
}

void sub_1007FD408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000558F4((const void **)va);
  sub_1000558F4(v4);
  _Unwind_Resume(a1);
}

const void **sub_1007FD430@<X0>(void *a1@<X0>, uint64_t a2@<X1>, const void **a3@<X8>)
{
  *a3 = 0;
  if (a2) {
    goto LABEL_4;
  }
  if (sub_1007FA824(a1))
  {
    a2 = sub_1007FA824(a1);
LABEL_4:
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%@", @"device.", a2);
    uint64_t v7 = *a3;
    *a3 = v6;
    CFNumberRef v15 = v7;
    BOOL v8 = &v15;
    return sub_1000558F4(v8);
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  if (ctu::cf::convert_copy((ctu::cf *)&v14, (const __CFString **)"device-id-is-not-yet-given", (const char *)0x8000100, kCFAllocatorDefault, v5))
  {
    char v10 = v13;
    uint64_t v13 = v14;
    CFNumberRef v15 = v10;
    sub_1000558F4(&v15);
  }
  CFTypeID v11 = v13;
  BOOL v12 = v13;
  uint64_t v13 = 0;
  sub_1000558F4(&v13);
  if (&v12 != a3)
  {
    CFNumberRef v15 = *a3;
    *a3 = v11;
    BOOL v12 = 0;
    sub_1000558F4(&v15);
  }
  BOOL v8 = &v12;
  return sub_1000558F4(v8);
}

void sub_1007FD530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000558F4((const void **)va);
  sub_1000558F4(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_1007FD558(uint64_t a1, const __CFString *a2)
{
  if (*(_DWORD *)(a1 + 96) != 1) {
    return 1;
  }
  sub_1007FD308((void *)a1, 0, (const void **)&theString2);
  if (CFEqual(a2, theString2))
  {
    sub_1000558F4((const void **)&theString2);
    return 1;
  }
  sub_1007FD430((void *)a1, 0, (const void **)&v6);
  CFComparisonResult v4 = CFStringCompare(a2, v6, 0);
  sub_1000558F4((const void **)&v6);
  sub_1000558F4((const void **)&theString2);
  if (v4 == kCFCompareEqualTo) {
    return 1;
  }
  uint64_t result = CFStringHasPrefix(a2, @"message.");
  if (result) {
    return 1;
  }
  return result;
}

void sub_1007FD60C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_1007FD634(uint64_t a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4)
  {
    char v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v11 = sub_1007FD974(a2);
      *(void *)&uint8_t buf[8] = 0;
      *(void *)&uint8_t buf[16] = 0;
      ctu::cf::assign();
      BOOL v12 = "update";
      *(_OWORD *)std::string __p = 0u;
      if (!a6) {
        BOOL v12 = "new";
      }
      uint64_t v23 = *(void *)&buf[16];
      uint64_t v13 = __p;
      if ((buf[23] & 0x80u) != 0) {
        uint64_t v13 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136316418;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      CFStringRef v25 = (void *)v12;
      __int16 v26 = 1024;
      *(_DWORD *)CFStringRef v27 = v11;
      *(_WORD *)&uint8_t v27[4] = 1024;
      *(_DWORD *)&v27[6] = a3;
      __int16 v28 = 2080;
      CFTypeID v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s<<<<<<<  recv %s [%c-%u] : %s", buf, 0x36u);
      if (SHIBYTE(v23) < 0) {
        operator delete(__p[0]);
      }
    }
    *(void *)std::string buf = off_101A0C688;
    *(void *)&uint8_t buf[8] = a1;
    CFStringRef v25 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
  }
  else
  {
    CFNumberRef v15 = *(NSObject **)(a1 + 40);
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (a5)
    {
      if (!v16) {
        return;
      }
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      int v17 = "update";
      if (!a6) {
        int v17 = "new";
      }
      *(_OWORD *)std::string __p = *(_OWORD *)buf;
      uint64_t v23 = *(void *)&buf[16];
      CFStringRef v18 = __p;
      if ((buf[23] & 0x80u) != 0) {
        CFStringRef v18 = *(void ***)buf;
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      CFStringRef v25 = (void *)v17;
      __int16 v26 = 2080;
      *(void *)CFStringRef v27 = v18;
      CFStringRef v19 = "#I %s%s<<<<<<<  recv %s %s but cannot decrypt";
      CFComparisonResult v20 = v15;
      uint32_t v21 = 42;
    }
    else
    {
      if (!v16) {
        return;
      }
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v23 = 0;
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      CFStringRef v25 = __p;
      CFStringRef v19 = "#I %s%s<<<<<<<  recv update to remove %s";
      CFComparisonResult v20 = v15;
      uint32_t v21 = 32;
    }
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1007FD940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1007FD974(const __CFString *a1)
{
  if (CFStringHasPrefix(a1, @"phone.services.")) {
    return 67;
  }
  if (CFStringHasPrefix(a1, @"assignments.")) {
    return 65;
  }
  if (CFStringHasPrefix(a1, @"dev.")) {
    return 68;
  }
  if (CFStringHasPrefix(a1, @"device.")) {
    return 100;
  }
  return 63;
}

void sub_1007FDA04(uint64_t a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    unsigned __int8 v8 = sub_1007FD974(a2);
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v16 = 0;
    int buf = 136316162;
    buf_4 = "";
    __int16 buf_12 = 2080;
    buf_14 = "";
    __int16 v21 = 1024;
    *(_DWORD *)unsigned int v22 = v8;
    *(_WORD *)&v22[4] = 1024;
    *(_DWORD *)&v22[6] = a3;
    __int16 v23 = 2080;
    int v24 = __p;
    int v9 = "#I %s%s<<<<<<<  ignored update [%c-%u] : %s";
    char v10 = v7;
    uint32_t v11 = 44;
  }
  else
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (a5)
    {
      if (!v14) {
        return;
      }
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v16 = 0;
      int buf = 136315650;
      buf_4 = "";
      __int16 buf_12 = 2080;
      buf_14 = "";
      __int16 v21 = 2080;
      *(void *)unsigned int v22 = __p;
      int v9 = "#I %s%s<<<<<<<  ignored update %s (cannot decrypt)";
    }
    else
    {
      if (!v14) {
        return;
      }
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v16 = 0;
      int buf = 136315650;
      buf_4 = "";
      __int16 buf_12 = 2080;
      buf_14 = "";
      __int16 v21 = 2080;
      *(void *)unsigned int v22 = __p;
      int v9 = "#I %s%s<<<<<<<  ignored update to remove %s";
    }
    char v10 = v13;
    uint32_t v11 = 32;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&buf, v11);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1007FDC58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007FDC80(uint64_t a1, const __CFString *a2, int a3, uint64_t a4)
{
  unsigned __int8 v8 = *(NSObject **)(a1 + 40);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (a4)
  {
    if (v9)
    {
      unsigned __int8 v10 = sub_1007FD974(a2);
      ctu::cf::assign();
      *(_OWORD *)std::string __p = 0u;
      uint64_t v12 = 0;
      *(_DWORD *)int buf = 136316162;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      __int16 v14 = 1024;
      *(_DWORD *)CFNumberRef v15 = v10;
      *(_WORD *)&void v15[4] = 1024;
      *(_DWORD *)&void v15[6] = a3;
      __int16 v16 = 2080;
      int v17 = __p;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s>>>>>>> send update [%c-%u] : %s", buf, 0x2Cu);
      if (SHIBYTE(v12) < 0) {
        operator delete(__p[0]);
      }
    }
    *(void *)int buf = off_101A0C708;
    *(void *)&uint8_t buf[8] = a1;
    *(void *)CFNumberRef v15 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
  }
  else if (v9)
  {
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v12 = 0;
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    __int16 v14 = 2080;
    *(void *)CFNumberRef v15 = __p;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%s>>>>>>> send update to remove %s", buf, 0x20u);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1007FDE9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1007FDECC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  if (v3)
  {
    CFAllocatorRef v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      uint64_t v7 = *(void *)(a2 + 8);
      if (v7)
      {
        (*(void (**)(void **__return_ptr))(*(void *)v7 + 16))(&__s1);
        if ((v28 & 0x80u) == 0) {
          size_t v8 = v28;
        }
        else {
          size_t v8 = __n;
        }
        uint64_t v9 = *(unsigned __int8 *)(a1 + 55);
        int v10 = (char)v9;
        if ((v9 & 0x80u) != 0) {
          uint64_t v9 = *(void *)(a1 + 40);
        }
        if (v8 == v9)
        {
          uint64_t v13 = *(unsigned __int8 **)(a1 + 32);
          uint64_t v12 = (unsigned __int8 *)(a1 + 32);
          uint32_t v11 = v13;
          if (v10 >= 0) {
            __int16 v14 = v12;
          }
          else {
            __int16 v14 = v11;
          }
          if ((v28 & 0x80) != 0)
          {
            int v24 = __s1;
            BOOL v23 = memcmp(__s1, v14, __n) == 0;
            goto LABEL_28;
          }
          if (!v28)
          {
            BOOL v23 = 1;
            goto LABEL_30;
          }
          uint64_t v15 = v28 - 1;
          p_s1 = &__s1;
          do
          {
            int v18 = *(unsigned __int8 *)p_s1;
            p_s1 = (void **)((char *)p_s1 + 1);
            int v17 = v18;
            int v20 = *v14++;
            int v19 = v20;
            BOOL v22 = v15-- != 0;
            BOOL v23 = v17 == v19;
          }
          while (v17 == v19 && v22);
        }
        else
        {
          BOOL v23 = 0;
        }
        if ((v28 & 0x80) != 0)
        {
          int v24 = __s1;
LABEL_28:
          operator delete(v24);
        }
      }
      else
      {
        BOOL v23 = 0;
      }
LABEL_30:
      sub_10004D2C8(v6);
      return v23;
    }
  }
  return 0;
}

void sub_1007FE004(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_1007FE018(const void **a1)
{
  return a1;
}

BOOL sub_1007FE054(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  if (v3)
  {
    CFAllocatorRef v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      uint64_t v7 = *(void *)(a2 + 8);
      if (v7)
      {
        (*(void (**)(void **__return_ptr))(*(void *)v7 + 16))(&__s1);
        if ((v28 & 0x80u) == 0) {
          size_t v8 = v28;
        }
        else {
          size_t v8 = __n;
        }
        uint64_t v9 = *(unsigned __int8 *)(a1 + 55);
        int v10 = (char)v9;
        if ((v9 & 0x80u) != 0) {
          uint64_t v9 = *(void *)(a1 + 40);
        }
        if (v8 == v9)
        {
          uint64_t v13 = *(unsigned __int8 **)(a1 + 32);
          uint64_t v12 = (unsigned __int8 *)(a1 + 32);
          uint32_t v11 = v13;
          if (v10 >= 0) {
            __int16 v14 = v12;
          }
          else {
            __int16 v14 = v11;
          }
          if ((v28 & 0x80) != 0)
          {
            int v24 = __s1;
            BOOL v23 = memcmp(__s1, v14, __n) == 0;
            goto LABEL_28;
          }
          if (!v28)
          {
            BOOL v23 = 1;
            goto LABEL_30;
          }
          uint64_t v15 = v28 - 1;
          p_s1 = &__s1;
          do
          {
            int v18 = *(unsigned __int8 *)p_s1;
            p_s1 = (void **)((char *)p_s1 + 1);
            int v17 = v18;
            int v20 = *v14++;
            int v19 = v20;
            BOOL v22 = v15-- != 0;
            BOOL v23 = v17 == v19;
          }
          while (v17 == v19 && v22);
        }
        else
        {
          BOOL v23 = 0;
        }
        if ((v28 & 0x80) != 0)
        {
          int v24 = __s1;
LABEL_28:
          operator delete(v24);
        }
      }
      else
      {
        BOOL v23 = 0;
      }
LABEL_30:
      sub_10004D2C8(v6);
      return v23;
    }
  }
  return 0;
}

void sub_1007FE18C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007FE1A0(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(*(void *)a1 + 40))(&v13);
  sub_10004EFE4(&v14, &v13);
  uint64_t v2 = (const void **)(a1 + 200);
  if ((const void **)(a1 + 200) != &v14)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = v14;
    __int16 v14 = 0;
    uint64_t v15 = v3;
    sub_100057D78(&v15);
  }
  sub_100057D78(&v14);
  sub_10005717C(&v13);
  CFComparisonResult v4 = *(void **)(a1 + 72);
  if (v4 != (void *)(a1 + 80))
  {
    do
    {
      CFAllocatorRef v5 = (std::__shared_weak_count *)v4[6];
      if (v5)
      {
        CFStringRef v6 = std::__shared_weak_count::lock(v5);
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = v4[5];
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 56))(v8);
          }
          sub_10004D2C8(v7);
        }
      }
      uint64_t v9 = (void *)v4[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v4[2];
          BOOL v11 = *v10 == (void)v4;
          CFComparisonResult v4 = v10;
        }
        while (!v11);
      }
      CFComparisonResult v4 = v10;
    }
    while (v10 != (void *)(a1 + 80));
  }
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 88))(a1, 0);
}

void sub_1007FE2F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1007FE31C@<X0>(CFDictionaryRef theDict@<X1>, const void **result@<X0>, long long *a3@<X2>, __CFDictionary **a4@<X8>)
{
  *a4 = 0;
  if (theDict)
  {
    uint64_t v5 = (uint64_t)result;
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    *a4 = MutableCopy;
    CFStringRef v13 = 0;
    sub_10005717C((const void **)&v13);
    sub_1000593FC((uint64_t)__p, a3);
    uint64_t v8 = sub_1007FC8C0(v5, (uint64_t)__p);
    CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"%u.%u", v8, 8);
    CFStringRef v13 = v9;
    if (v12)
    {
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }
    CFDictionarySetValue(MutableCopy, @"ver", v9);
    return sub_1000558F4((const void **)&v13);
  }
  return result;
}

void sub_1007FE3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  sub_1000558F4((const void **)(v19 - 40));
  sub_10005717C(v18);
  _Unwind_Resume(a1);
}

BOOL sub_1007FE440(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      uint64_t v7 = *(void *)(a2 + 8);
      if (v7)
      {
        (*(void (**)(void **__return_ptr))(*(void *)v7 + 16))(&__s1);
        if (!*(unsigned char *)(a1 + 56)) {
          goto LABEL_24;
        }
        if ((v24 & 0x80u) == 0) {
          size_t v8 = v24;
        }
        else {
          size_t v8 = __n;
        }
        uint64_t v9 = *(unsigned __int8 *)(a1 + 55);
        int v10 = (char)v9;
        if ((v9 & 0x80u) != 0) {
          uint64_t v9 = *(void *)(a1 + 40);
        }
        if (v8 == v9)
        {
          if (v10 >= 0) {
            char v11 = (unsigned __int8 *)(a1 + 32);
          }
          else {
            char v11 = *(unsigned __int8 **)(a1 + 32);
          }
          if ((v24 & 0x80) != 0)
          {
            BOOL v20 = memcmp(__s1, v11, __n) == 0;
LABEL_29:
            operator delete(__s1);
            goto LABEL_30;
          }
          if (!v24)
          {
            BOOL v20 = 1;
            goto LABEL_30;
          }
          uint64_t v12 = v24 - 1;
          p_s1 = &__s1;
          do
          {
            int v15 = *(unsigned __int8 *)p_s1;
            p_s1 = (void **)((char *)p_s1 + 1);
            int v14 = v15;
            int v17 = *v11++;
            int v16 = v17;
            BOOL v19 = v12-- != 0;
            BOOL v20 = v14 == v16;
          }
          while (v14 == v16 && v19);
        }
        else
        {
LABEL_24:
          BOOL v20 = 0;
        }
        if ((v24 & 0x80) != 0) {
          goto LABEL_29;
        }
      }
      else
      {
        BOOL v20 = 0;
      }
LABEL_30:
      sub_10004D2C8(v6);
      return v20;
    }
  }
  return 0;
}

void sub_1007FE57C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1007FE590(uint64_t a1, uint64_t a2)
{
  return sub_1000593FC(a1 + 32, (long long *)(a2 + 32));
}

void sub_1007FE59C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
  }
}

const void **sub_1007FE5B8(uint64_t a1, unsigned int a2, CFDictionaryRef theDict, unsigned int a4, long long *a5, int a6, int a7)
{
  std::string v76 = 0;
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    *(_OWORD *)std::string __p = *a5;
    uint64_t v74 = *((void *)a5 + 2);
  }
  char v75 = 1;
  sub_1007FE31C(theDict, (const void **)a1, (long long *)__p, &v76);
  if (v75 && SHIBYTE(v74) < 0) {
    operator delete(__p[0]);
  }
  value = 0;
  CFStringRef v72 = 0;
  if (a2 < 2)
  {
    sub_1007FF388((const void **)&v81, (void *)a1, a2, (uint64_t *)a5);
    *(void *)&long long valuePtr = v72;
    CFStringRef v72 = (CFStringRef)v81;
    *(void *)&long long v81 = 0;
    sub_1000558F4((const void **)&valuePtr);
    sub_1000558F4((const void **)&v81);
    int v14 = v76;
    if (v76) {
      int v15 = sub_1000C06D0;
    }
    else {
      int v15 = 0;
    }
    if (v15)
    {
      *(void *)&long long v81 = 0;
      *(void *)&long long valuePtr = a4;
      CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
      if (v16)
      {
        uint64_t v17 = v81;
        *(void *)&long long v81 = v16;
        *(void *)&long long valuePtr = v17;
        sub_1000570E8((const void **)&valuePtr);
      }
      int v18 = (const void *)v81;
      *(void *)&long long v79 = v81;
      *(void *)&long long v81 = 0;
      sub_1000570E8((const void **)&v81);
      CFDictionarySetValue(v14, @"ts", v18);
      sub_1000570E8((const void **)&v79);
      (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 152) + 56))(&v81);
      *(void *)&long long valuePtr = value;
      value = (void *)v81;
      *(void *)&long long v81 = 0;
      sub_1000577C4((const void **)&valuePtr);
      sub_1000577C4((const void **)&v81);
    }
    sub_1007FF448(a1, v72, a4, value, a6, a7);
    goto LABEL_122;
  }
  if (a2 != 2) {
    goto LABEL_122;
  }
  sub_1007FD308((void *)a1, 0, (const void **)&v81);
  *(void *)&long long valuePtr = v72;
  CFStringRef v72 = (CFStringRef)v81;
  *(void *)&long long v81 = 0;
  sub_1000558F4((const void **)&valuePtr);
  sub_1000558F4((const void **)&v81);
  CFDictionaryRef theDicta = 0;
  sub_1003A9CA0(&valuePtr);
  *(void *)&long long v81 = sub_1003A9B04(valuePtr, v72, 0);
  sub_100084068(&theDicta, (CFTypeRef *)&v81);
  if (*((void *)&valuePtr + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&valuePtr + 1));
  }
  CFDictionaryRef v69 = 0;
  if (theDicta) {
    BOOL v19 = sub_100080778;
  }
  else {
    BOOL v19 = 0;
  }
  if (v19)
  {
    CFDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDicta);
LABEL_25:
    CFDictionaryRef v21 = v69;
    CFDictionaryRef v69 = MutableCopy;
    *(void *)&long long valuePtr = v21;
    sub_10005717C((const void **)&valuePtr);
    goto LABEL_26;
  }
  CFDictionaryRef MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (MutableCopy) {
    goto LABEL_25;
  }
LABEL_26:
  CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(v69, @"accounts");
  CFDictionaryRef v23 = v22;
  if (v22 && (CFTypeID v24 = CFGetTypeID(v22), v24 == CFDictionaryGetTypeID()))
  {
    CFTypeRef cf = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(0, 0, v23);
  }
  else
  {
    CFTypeRef cf = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable) {
      goto LABEL_31;
    }
  }
  CFTypeRef v26 = cf;
  CFTypeRef cf = Mutable;
  *(void *)&long long valuePtr = v26;
  sub_10005717C((const void **)&valuePtr);
LABEL_31:
  if (v76) {
    CFStringRef v27 = sub_1000C06D0;
  }
  else {
    CFStringRef v27 = 0;
  }
  if (v27)
  {
    (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 152) + 56))(&v81);
    *(void *)&long long valuePtr = value;
    value = (void *)v81;
    *(void *)&long long v81 = 0;
    sub_1000577C4((const void **)&valuePtr);
    sub_1000577C4((const void **)&v81);
    unsigned __int8 v28 = (__CFDictionary *)cf;
    if (*((char *)a5 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)a5, *((void *)a5 + 1));
    }
    else
    {
      long long __dst = *a5;
      uint64_t v66 = *((void *)a5 + 2);
    }
    if (SHIBYTE(v66) < 0)
    {
      sub_10004FC84(&v81, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v81 = __dst;
      uint64_t v82 = v66;
    }
    long long v77 = 0;
    if (SHIBYTE(v82) < 0)
    {
      sub_10004FC84(&valuePtr, (void *)v81, *((unint64_t *)&v81 + 1));
    }
    else
    {
      long long valuePtr = v81;
      uint64_t v84 = v82;
    }
    CFStringRef v78 = 0;
    CFAllocatorRef v30 = kCFAllocatorDefault;
    if (ctu::cf::convert_copy())
    {
      CFDictionaryRef v31 = v77;
      long long v77 = v78;
      *(void *)&long long v79 = v31;
      sub_1000558F4((const void **)&v79);
    }
    if (SHIBYTE(v84) < 0) {
      operator delete((void *)valuePtr);
    }
    key = v77;
    long long v77 = 0;
    sub_1000558F4((const void **)&v77);
    if (SHIBYTE(v82) < 0) {
      operator delete((void *)v81);
    }
    CFDictionarySetValue(v28, key, value);
    sub_1000558F4((const void **)&key);
    if ((SHIBYTE(v66) & 0x80000000) == 0) {
      goto LABEL_70;
    }
    uint64_t v32 = (void *)__dst;
  }
  else
  {
    CFTypeID v29 = (__CFDictionary *)cf;
    if (*((char *)a5 + 23) < 0)
    {
      sub_10004FC84(v63, *(void **)a5, *((void *)a5 + 1));
    }
    else
    {
      *(_OWORD *)long long v63 = *a5;
      uint64_t v64 = *((void *)a5 + 2);
    }
    if (SHIBYTE(v64) < 0)
    {
      sub_10004FC84(&v81, v63[0], (unint64_t)v63[1]);
    }
    else
    {
      long long v81 = *(_OWORD *)v63;
      uint64_t v82 = v64;
    }
    long long v77 = 0;
    if (SHIBYTE(v82) < 0)
    {
      sub_10004FC84(&valuePtr, (void *)v81, *((unint64_t *)&v81 + 1));
    }
    else
    {
      long long valuePtr = v81;
      uint64_t v84 = v82;
    }
    CFStringRef v78 = 0;
    CFAllocatorRef v30 = kCFAllocatorDefault;
    if (ctu::cf::convert_copy())
    {
      __int16 v33 = v77;
      long long v77 = v78;
      *(void *)&long long v79 = v33;
      sub_1000558F4((const void **)&v79);
    }
    if (SHIBYTE(v84) < 0) {
      operator delete((void *)valuePtr);
    }
    key = v77;
    long long v77 = 0;
    sub_1000558F4((const void **)&v77);
    if (SHIBYTE(v82) < 0) {
      operator delete((void *)v81);
    }
    CFDictionaryRemoveValue(v29, key);
    sub_1000558F4((const void **)&key);
    if ((SHIBYTE(v64) & 0x80000000) == 0) {
      goto LABEL_70;
    }
    uint64_t v32 = v63[0];
  }
  operator delete(v32);
LABEL_70:
  CFDictionaryRef v61 = (CFDictionaryRef)cf;
  if (cf) {
    CFRetain(cf);
  }
  if (*(void *)(a1 + 208))
  {
    CFIndex Count = CFDictionaryGetCount(v61);
    if (Count)
    {
      long long v81 = 0uLL;
      uint64_t v82 = 0;
      sub_10019E8F0(&v81, Count);
      CFDictionaryGetKeysAndValues(v61, (const void **)v81, 0);
      CFDictionaryRef v36 = (const void **)*((void *)&v81 + 1);
      xpc_object_t v35 = (const void **)v81;
      if ((void)v81 != *((void *)&v81 + 1))
      {
        do
        {
          uint64_t v37 = *(void *)(a1 + 208);
          long long valuePtr = 0uLL;
          uint64_t v84 = 0;
          ctu::cf::assign();
          long long v79 = valuePtr;
          uint64_t v80 = v84;
          uint64_t v38 = sub_100046F68(v37 + 144, (void **)&v79);
          if (SHIBYTE(v80) < 0) {
            operator delete((void *)v79);
          }
          if ((void **)(*(void *)(a1 + 208) + 152) == v38) {
            CFDictionaryRemoveValue(v61, *v35);
          }
          ++v35;
        }
        while (v35 != v36);
        xpc_object_t v35 = (const void **)v81;
      }
      if (v35)
      {
        *((void *)&v81 + 1) = v35;
        operator delete(v35);
      }
    }
  }
  CFDictionaryRef v39 = v61;
  CFDictionaryRef v61 = 0;
  CFDictionaryRef v62 = v39;
  sub_10005717C((const void **)&v62);
  sub_10005717C((const void **)&v61);
  if (CFDictionaryGetCount((CFDictionaryRef)cf))
  {
    CFDictionarySetValue(v69, @"accounts", cf);
  }
  else
  {
    CFDictionaryRef v40 = v69;
    CFDictionaryRef v69 = 0;
    *(void *)&long long valuePtr = v40;
    sub_10005717C((const void **)&valuePtr);
  }
  uint64_t v41 = v69;
  if (v69) {
    xpc_object_t v42 = sub_1000C06D0;
  }
  else {
    xpc_object_t v42 = 0;
  }
  if (v42)
  {
    *(void *)&long long v81 = 0;
    *(void *)&long long valuePtr = a4;
    CFNumberRef v43 = CFNumberCreate(v30, kCFNumberLongLongType, &valuePtr);
    if (v43)
    {
      uint64_t v44 = v81;
      *(void *)&long long v81 = v43;
      *(void *)&long long valuePtr = v44;
      sub_1000570E8((const void **)&valuePtr);
    }
    *(void *)&long long v79 = v81;
    *(void *)&long long v81 = 0;
    sub_1000570E8((const void **)&v81);
    CFDictionarySetValue(v41, @"ts", (const void *)v79);
    sub_1000570E8((const void **)&v79);
    uint64_t v41 = v69;
  }
  sub_1007FF448(a1, v72, a4, v41, a6, 0);
  sub_10005717C(&cf);
  sub_10005717C((const void **)&v69);
  sub_100057D78((const void **)&theDicta);
  uint64_t v45 = *(void *)(a1 + 208);
  if (v45)
  {
    unint64_t v46 = sub_100046F68(v45 + 144, (void **)a5);
    if ((void **)(*(void *)(a1 + 208) + 152) != v46)
    {
      sub_1007FD430((void *)a1, 0, (const void **)&v81);
      *(void *)&long long valuePtr = v72;
      CFStringRef v72 = (CFStringRef)v81;
      *(void *)&long long v81 = 0;
      sub_1000558F4((const void **)&valuePtr);
      sub_1000558F4((const void **)&v81);
      uint64_t v47 = value;
      value = 0;
      *(void *)&long long valuePtr = v47;
      sub_1000577C4((const void **)&valuePtr);
      if (*((_DWORD *)v46[7] + 19) > 6u)
      {
        sub_1003A9CA0(&valuePtr);
        char v53 = sub_1003A9B04(valuePtr, v72, 1);
        CFStringRef v78 = 0;
        *(void *)&long long v79 = v53;
        *(void *)&long long v81 = 0;
        sub_100084068(&v81, (CFTypeRef *)&v79);
        if ((void)v81) {
          uint64_t v54 = sub_100080778;
        }
        else {
          uint64_t v54 = 0;
        }
        if (v54) {
          sub_100058140((const void **)&v78, (const void **)&v81);
        }
        sub_100057D78((const void **)&v81);
        CFDictionaryRef v55 = (const __CFDictionary *)v78;
        long long v77 = v78;
        CFStringRef v78 = 0;
        sub_100057D78((const void **)&v78);
        if (*((void *)&valuePtr + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&valuePtr + 1));
        }
        if (v55) {
          __int16 v56 = sub_100080778;
        }
        else {
          __int16 v56 = 0;
        }
        if (v56)
        {
          uint64_t v57 = CFDictionaryGetValue(v55, @"account");
          if (v57)
          {
            CFTypeID v58 = CFGetTypeID(v57);
            if (v58 == CFStringGetTypeID())
            {
              long long valuePtr = 0uLL;
              uint64_t v84 = 0;
              ctu::cf::assign();
              long long v81 = valuePtr;
              uint64_t v82 = v84;
              BOOL v59 = sub_10001D294((unsigned __int8 *)a5, (unsigned __int8 *)&v81);
              if (SHIBYTE(v82) < 0) {
                operator delete((void *)v81);
              }
              if (v59) {
                sub_1007FF448(a1, v72, 0, 0, 1, 1);
              }
            }
          }
        }
        sub_100057D78((const void **)&v77);
      }
      else
      {
        unsigned int v48 = v76;
        if (v76) {
          xpc_object_t v49 = sub_1000C06D0;
        }
        else {
          xpc_object_t v49 = 0;
        }
        if (v49)
        {
          *(void *)&long long v81 = 0;
          *(void *)&long long valuePtr = a4;
          CFNumberRef v50 = CFNumberCreate(v30, kCFNumberLongLongType, &valuePtr);
          if (v50)
          {
            uint64_t v51 = v81;
            *(void *)&long long v81 = v50;
            *(void *)&long long valuePtr = v51;
            sub_1000570E8((const void **)&valuePtr);
          }
          char v52 = (const void *)v81;
          *(void *)&long long v79 = v81;
          *(void *)&long long v81 = 0;
          sub_1000570E8((const void **)&v81);
          CFDictionarySetValue(v48, @"ts", v52);
          sub_1000570E8((const void **)&v79);
          (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 152) + 56))(&v81);
          *(void *)&long long valuePtr = value;
          value = (void *)v81;
          *(void *)&long long v81 = 0;
          sub_1000577C4((const void **)&valuePtr);
          sub_1000577C4((const void **)&v81);
        }
        sub_1007FF448(a1, v72, a4, value, a6, a7);
      }
    }
  }
LABEL_122:
  if (!*(unsigned char *)(a1 + 224))
  {
    *(unsigned char *)(a1 + 224) = 1;
    long long valuePtr = 0uLL;
    sub_10003E168(&valuePtr, (void *)(a1 + 8));
    operator new();
  }
  sub_1000577C4((const void **)&value);
  sub_1000558F4((const void **)&v72);
  return sub_10005717C((const void **)&v76);
}

void sub_1007FF134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,int a38,const void *a39,const void *a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,char a47,uint64_t a48,const void *a49,const void *a50,__int16 a51,char a52,char a53)
{
  if (*(char *)(v53 - 89) < 0) {
    operator delete(*(void **)(v53 - 112));
  }
  sub_100057D78(&a50);
  sub_1000577C4(&a39);
  sub_1000558F4(&a40);
  sub_10005717C(&a49);
  _Unwind_Resume(a1);
}

CFStringRef sub_1007FF388(const void **a1, void *a2, int a3, uint64_t *a4)
{
  if (a3 == 2)
  {
    uint64_t v7 = sub_1007FA824(a2);
    return (CFStringRef)sub_1007FD308(a2, v7, a1);
  }
  else
  {
    if (a3 == 1) {
      CFStringRef v5 = @"assignments.";
    }
    else {
      CFStringRef v5 = @"phone.services.";
    }
    if (*((char *)a4 + 23) >= 0) {
      uint64_t v9 = a4;
    }
    else {
      uint64_t v9 = (uint64_t *)*a4;
    }
    CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", v5, v9);
    *a1 = result;
  }
  return result;
}

void sub_1007FF448(uint64_t a1, const __CFString *a2, int a3, const void *a4, int a5, int a6)
{
  sub_1003A9CA0(&v13);
  sub_1003A9C3C(v13, a2, a4);
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a5)
  {
    sub_1007FDC80(a1, a2, a3, (uint64_t)a4);
    (*(void (**)(void, const __CFString *, const void *))(**(void **)(a1 + 144) + 16))(*(void *)(a1 + 144), a2, a4);
    if (a6)
    {
      uint64_t v12 = *(void (**)(void))(**(void **)(a1 + 144) + 24);
      v12();
    }
  }
}

void sub_1007FF550(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007FF568(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 152);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 160);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 56))(v2);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1007FF5E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1007FF600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = *(void *)(a1 + 152);
  CFStringRef v6 = *(std::__shared_weak_count **)(a1 + 160);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((char *)a4 + 23) < 0) {
    a4 = (uint64_t *)*a4;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v5 + 64))(v5, a2, a3, a4);
  if (v6)
  {
    sub_10004D2C8(v6);
  }
}

void sub_1007FF690(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1007FF6A8(const void **result, CFDictionaryRef theDict)
{
  uint64_t v2 = result;
  if (theDict)
  {
    CFStringRef Value = (unsigned int *)CFDictionaryGetValue(theDict, @"ts");
    int v7 = 0;
    ctu::cf::assign((ctu::cf *)&v7, Value, v5);
    int v6 = v7;
    CFTypeRef cf = CFDictionaryCreateMutableCopy(0, 0, theDict);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)cf, @"ts");
    int v7 = v6;
    CFTypeRef v8 = cf;
    if (cf) {
      CFRetain(cf);
    }
    *(_DWORD *)uint64_t v2 = v6;
    sub_10004EFE4(v2 + 1, &v8);
    sub_10005717C(&v8);
    return sub_10005717C(&cf);
  }
  else
  {
    *(_DWORD *)CFStringRef result = 0;
    result[1] = 0;
  }
  return result;
}

void sub_1007FF778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C(v4);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1007FF79C(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v17 = 0;
  if (a2 == 1)
  {
    sub_1003A9CA0(buf);
    uint64_t v8 = *(void *)buf;
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = (uint64_t *)*a3;
    }
    CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"assignments.", v9);
    int v7 = sub_1003A9B04(v8, v16, 0);
LABEL_11:
    int v10 = v17;
    uint64_t v17 = v7;
    int v18 = v10;
    sub_1000577C4(&v18);
    sub_1000558F4((const void **)&v16);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    goto LABEL_14;
  }
  if (!a2)
  {
    sub_1003A9CA0(buf);
    uint64_t v5 = *(void *)buf;
    if (*((char *)a3 + 23) >= 0) {
      int v6 = a3;
    }
    else {
      int v6 = (uint64_t *)*a3;
    }
    CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"phone.services.", v6);
    int v7 = sub_1003A9B04(v5, v16, 0);
    goto LABEL_11;
  }
  char v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    int v15 = "???";
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    if (a2 == 2) {
      int v15 = "CloudBlockType::kDeviceInfo";
    }
    __int16 v20 = 2080;
    CFDictionaryRef v21 = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "#E %s%sdoesCloudBlockExist is not supported for '%s'", buf, 0x20u);
  }
LABEL_14:
  if (v17) {
    uint64_t v12 = sub_100080934;
  }
  else {
    uint64_t v12 = 0;
  }
  BOOL v13 = v12 != 0;
  sub_1000577C4(&v17);
  return v13;
}

void sub_1007FF998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_1000577C4(&a13);
  _Unwind_Resume(a1);
}

CFStringRef sub_1007FF9DC@<X0>(uint64_t *a1@<X1>, CFStringRef *a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = (uint64_t *)*a1;
  }
  CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"phone.services.", v3);
  *a2 = result;
  return result;
}

CFStringRef sub_1007FFA40@<X0>(uint64_t *a1@<X1>, CFStringRef *a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = (uint64_t *)*a1;
  }
  CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"assignments.", v3);
  *a2 = result;
  return result;
}

void sub_1007FFAA4(void *a1@<X0>, int a2@<W1>, void **a3@<X2>, uint64_t a4@<X3>, const void **a5@<X8>)
{
  if (a2 != 2)
  {
    if (a2 == 1)
    {
      sub_1003A9CA0(buf);
      uint64_t v19 = *(void *)buf;
      if (*((char *)a3 + 23) >= 0) {
        __int16 v20 = a3;
      }
      else {
        __int16 v20 = *a3;
      }
      uint64_t v71 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"assignments.", v20);
      CFStringRef v75 = 0;
      v69[0] = (void *)sub_1003A9B04(v19, v71, 1);
      __p[0] = 0;
      sub_100084068(__p, (CFTypeRef *)v69);
      if (__p[0]) {
        CFDictionaryRef v21 = sub_100080778;
      }
      else {
        CFDictionaryRef v21 = 0;
      }
      if (v21) {
        sub_100058140((const void **)&v75, (const void **)__p);
      }
      goto LABEL_31;
    }
    if (!a2)
    {
      sub_1003A9CA0(buf);
      uint64_t v7 = *(void *)buf;
      if (*((char *)a3 + 23) >= 0) {
        uint64_t v8 = a3;
      }
      else {
        uint64_t v8 = *a3;
      }
      uint64_t v71 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", @"phone.services.", v8);
      CFStringRef v75 = 0;
      v69[0] = (void *)sub_1003A9B04(v7, v71, 1);
      __p[0] = 0;
      sub_100084068(__p, (CFTypeRef *)v69);
      if (__p[0]) {
        uint64_t v9 = sub_100080778;
      }
      else {
        uint64_t v9 = 0;
      }
      if (v9) {
        sub_100058140((const void **)&v75, (const void **)__p);
      }
LABEL_31:
      sub_100057D78((const void **)__p);
      CFDictionaryRef v22 = (const __CFDictionary *)v75;
      CFStringRef v74 = v75;
      CFStringRef v75 = 0;
      sub_100057D78((const void **)&v75);
      sub_1007FF6A8(a5, v22);
      sub_100057D78((const void **)&v74);
      sub_1000558F4((const void **)&v71);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      return;
    }
LABEL_126:
    *(_DWORD *)int buf = 0;
    __p[0] = 0;
    *(_DWORD *)a5 = 0;
    a5[1] = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_100057D78((const void **)&buf[8]);
    sub_100057D78((const void **)__p);
    return;
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  *(_OWORD *)CFDictionaryRef v69 = 0u;
  uint64_t v70 = 0;
  CFDictionaryRef theDict = 0;
  sub_1003A9CA0(buf);
  uint64_t v12 = *(void *)buf;
  sub_1007FD308(a1, a4, (const void **)&v75);
  __p[0] = (void *)sub_1003A9B04(v12, v75, 0);
  sub_100084068(&theDict, (CFTypeRef *)__p);
  sub_1000558F4((const void **)&v75);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (theDict) {
    BOOL v13 = sub_100080778;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    CFStringRef Value = CFDictionaryGetValue(theDict, @"ts");
    CFStringRef v16 = Value;
    if (Value)
    {
      CFTypeID v17 = CFGetTypeID(Value);
      int v18 = v17 == CFNumberGetTypeID() ? (unsigned int *)v16 : 0;
    }
    else
    {
      int v18 = 0;
    }
    *(_DWORD *)int buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v18, v15);
    int v23 = *(_DWORD *)buf;
    CFDictionaryRef v24 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"accounts");
    CFDictionaryRef v25 = v24;
    if (v24)
    {
      CFTypeID v26 = CFGetTypeID(v24);
      if (v26 == CFDictionaryGetTypeID())
      {
        if (*((char *)a3 + 23) < 0)
        {
          sub_10004FC84(__dst, *a3, (unint64_t)a3[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)a3;
          uint64_t v66 = a3[2];
        }
        if (SHIBYTE(v66) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)__dst;
          long long v73 = v66;
        }
        uint64_t v71 = 0;
        if (SHIBYTE(v73) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)int buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v73;
        }
        CFStringRef v74 = 0;
        if (ctu::cf::convert_copy())
        {
          CFStringRef v27 = v71;
          uint64_t v71 = (__CFString *)v74;
          CFStringRef v75 = v27;
          sub_1000558F4((const void **)&v75);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        key = v71;
        uint64_t v71 = 0;
        sub_1000558F4((const void **)&v71);
        if (SHIBYTE(v73) < 0) {
          operator delete(__p[0]);
        }
        unsigned __int8 v28 = CFDictionaryGetValue(v25, key);
        sub_1000558F4((const void **)&key);
        if (SHIBYTE(v66) < 0) {
          operator delete(__dst[0]);
        }
        if (v28)
        {
          CFTypeID v29 = a1[5];
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            if (*((char *)a3 + 23) >= 0) {
              CFAllocatorRef v30 = a3;
            }
            else {
              CFAllocatorRef v30 = (void **)*a3;
            }
            CFDictionaryRef v31 = v69;
            if (v70 < 0) {
              CFDictionaryRef v31 = (void **)v69[0];
            }
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "";
            *(_WORD *)&unsigned char buf[22] = 2080;
            long long v77 = v30;
            __int16 v78 = 2080;
            long long v79 = v31;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%sfound account %s in section 'D' of device %s", buf, 0x2Au);
          }
          CFStringRef v74 = 0;
          sub_1007FD308(a1, a4, (const void **)&v71);
          sub_1007FF600((uint64_t)a1, (uint64_t)v71, (uint64_t)v28, (uint64_t *)a3);
          __p[0] = (void *)cf;
          if (cf) {
            CFRetain(cf);
          }
          CFStringRef v75 = 0;
          *(void *)int buf = 0;
          sub_10004EFE4(buf, (CFTypeRef *)__p);
          if (*(void *)buf) {
            uint64_t v32 = sub_100080778;
          }
          else {
            uint64_t v32 = 0;
          }
          if (v32) {
            sub_100058140((const void **)&v75, (const void **)buf);
          }
          sub_100057D78((const void **)buf);
          CFStringRef v74 = v75;
          CFStringRef v75 = 0;
          sub_100057D78((const void **)&v75);
          sub_1000577C4((const void **)__p);
          sub_1000577C4(&cf);
          sub_1000558F4((const void **)&v71);
          if (v74) {
            __int16 v33 = sub_100080778;
          }
          else {
            __int16 v33 = 0;
          }
          if (v33)
          {
            *(_DWORD *)a5 = v23;
            sub_100058198(a5 + 1, (const void **)&v74);
            sub_100057D78((const void **)&v74);
LABEL_121:
            int v61 = 0;
            goto LABEL_123;
          }
          uint64_t v34 = a1[5];
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            if (*((char *)a3 + 23) >= 0) {
              CFDictionaryRef v62 = a3;
            }
            else {
              CFDictionaryRef v62 = (void **)*a3;
            }
            long long v63 = v69;
            if (v70 < 0) {
              long long v63 = (void **)v69[0];
            }
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "";
            *(_WORD *)&unsigned char buf[22] = 2080;
            long long v77 = v62;
            __int16 v78 = 2080;
            long long v79 = v63;
            _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "#E %s%sunable to decrypt account %s in section 'D' of device %s", buf, 0x2Au);
          }
          sub_100057D78((const void **)&v74);
        }
      }
    }
  }
  sub_1003A9CA0(buf);
  uint64_t v35 = *(void *)buf;
  sub_1007FD430(a1, a4, (const void **)&v74);
  CFStringRef v75 = (CFStringRef)sub_1003A9B04(v35, v74, 1);
  __p[0] = 0;
  sub_100084068(__p, (CFTypeRef *)&v75);
  CFDictionaryRef v36 = theDict;
  CFDictionaryRef theDict = (CFDictionaryRef)__p[0];
  __p[0] = v36;
  sub_100057D78((const void **)__p);
  sub_1000558F4((const void **)&v74);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (theDict) {
    uint64_t v37 = sub_100080778;
  }
  else {
    uint64_t v37 = 0;
  }
  if (v37)
  {
    uint64_t v38 = CFDictionaryGetValue(theDict, @"account");
    if (v38)
    {
      CFTypeID v39 = CFGetTypeID(v38);
      if (v39 == CFStringGetTypeID())
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        long long v73 = *(void **)&buf[16];
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v40 = *((unsigned __int8 *)a3 + 23);
        if ((v40 & 0x80u) == 0) {
          uint64_t v41 = (void *)*((unsigned __int8 *)a3 + 23);
        }
        else {
          uint64_t v41 = a3[1];
        }
        xpc_object_t v42 = (void *)HIBYTE(v73);
        int v43 = SHIBYTE(v73);
        if (SHIBYTE(v73) < 0) {
          xpc_object_t v42 = __p[1];
        }
        if (v41 == v42)
        {
          if (SHIBYTE(v73) >= 0) {
            uint64_t v44 = __p;
          }
          else {
            uint64_t v44 = (void **)__p[0];
          }
          if ((v40 & 0x80) != 0)
          {
            BOOL v53 = memcmp(*a3, v44, (size_t)a3[1]) == 0;
          }
          else if (*((unsigned char *)a3 + 23))
          {
            uint64_t v45 = v40 - 1;
            unint64_t v46 = a3;
            do
            {
              int v48 = *(unsigned __int8 *)v46;
              unint64_t v46 = (void **)((char *)v46 + 1);
              int v47 = v48;
              int v50 = *(unsigned __int8 *)v44;
              uint64_t v44 = (void **)((char *)v44 + 1);
              int v49 = v50;
              BOOL v52 = v45-- != 0;
              BOOL v53 = v47 == v49;
            }
            while (v47 == v49 && v52);
          }
          else
          {
            BOOL v53 = 1;
          }
        }
        else
        {
          BOOL v53 = 0;
        }
        if (v43 < 0) {
          operator delete(__p[0]);
        }
        if (v53)
        {
          uint64_t v54 = a1[5];
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            CFDictionaryRef v55 = v69;
            if (v70 < 0) {
              CFDictionaryRef v55 = (void **)v69[0];
            }
            if (*((char *)a3 + 23) >= 0) {
              __int16 v56 = a3;
            }
            else {
              __int16 v56 = (void **)*a3;
            }
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "";
            *(_WORD *)&unsigned char buf[22] = 2080;
            long long v77 = v55;
            __int16 v78 = 2080;
            long long v79 = v56;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I %s%sfound legacy 'd' for device %s account %s", buf, 0x2Au);
          }
          sub_1003A9CA0(buf);
          uint64_t v57 = *(void *)buf;
          sub_1007FD430(a1, a4, (const void **)&key);
          CFStringRef v58 = (const __CFString *)sub_1003A9B04(v57, (CFStringRef)key, 1);
          CFStringRef v74 = 0;
          CFStringRef v75 = v58;
          __p[0] = 0;
          sub_100084068(__p, (CFTypeRef *)&v75);
          if (__p[0]) {
            BOOL v59 = sub_100080778;
          }
          else {
            BOOL v59 = 0;
          }
          if (v59) {
            sub_100058140((const void **)&v74, (const void **)__p);
          }
          sub_100057D78((const void **)__p);
          CFDictionaryRef v60 = (const __CFDictionary *)v74;
          uint64_t v71 = (__CFString *)v74;
          CFStringRef v74 = 0;
          sub_100057D78((const void **)&v74);
          sub_1007FF6A8(a5, v60);
          sub_100057D78((const void **)&v71);
          sub_1000558F4((const void **)&key);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          goto LABEL_121;
        }
      }
    }
  }
  int v61 = 1;
LABEL_123:
  sub_100057D78((const void **)&theDict);
  if (SHIBYTE(v70) < 0) {
    operator delete(v69[0]);
  }
  if (v61) {
    goto LABEL_126;
  }
}

void sub_100800448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,char a39,int a40,__int16 a41,char a42,char a43)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100800620@<X0>(CFStringRef theString@<X4>, void *a2@<X0>, unsigned int a3@<W1>, uint64_t a4@<X2>, uint64_t a5@<X3>, const __CFDictionary *a6@<X5>, const void **a7@<X8>)
{
  if (!a6) {
    goto LABEL_78;
  }
  if (a3 < 2)
  {
    sub_1007FF388((const void **)theString2, a2, a3, (uint64_t *)a4);
    CFComparisonResult v12 = CFStringCompare(theString, theString2[0], 0);
    sub_1000558F4((const void **)theString2);
    if (v12 == kCFCompareEqualTo) {
      return sub_1007FF6A8(a7, a6);
    }
    goto LABEL_78;
  }
  if (a3 != 2) {
    goto LABEL_78;
  }
  if (a5)
  {
    sub_1007FD430(a2, a5, (const void **)theString2);
    CFComparisonResult v15 = CFStringCompare(theString, theString2[0], 0);
    sub_1000558F4((const void **)theString2);
    if (v15)
    {
      sub_1007FD308(a2, a5, (const void **)theString2);
      CFComparisonResult v16 = CFStringCompare(theString, theString2[0], 0);
      sub_1000558F4((const void **)theString2);
      if (v16 == kCFCompareEqualTo) {
        goto LABEL_16;
      }
LABEL_78:
      LODWORD(theString2[0]) = 0;
      __p[0] = 0;
      *(_DWORD *)a7 = 0;
      a7[1] = 0;
      theString2[1] = 0;
      sub_100057D78((const void **)&theString2[1]);
      xpc_object_t v42 = (const void **)__p;
      return sub_100057D78(v42);
    }
LABEL_11:
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a6, @"account");
    CFStringRef v18 = Value;
    if (Value)
    {
      CFTypeID v19 = CFGetTypeID(Value);
      if (v19 == CFStringGetTypeID())
      {
        if (*(char *)(a4 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)a4;
          CFStringRef v54 = *(const __CFString **)(a4 + 16);
        }
        if (SHIBYTE(v54) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)__dst;
          CFStringRef v58 = v54;
        }
        __int16 v56 = 0;
        if (SHIBYTE(v58) < 0)
        {
          sub_10004FC84(theString2, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)CFStringRef theString2 = *(_OWORD *)__p;
          theString2[2] = v58;
        }
        BOOL v59 = 0;
        if (ctu::cf::convert_copy())
        {
          CFTypeID v29 = v56;
          __int16 v56 = v59;
          v48[0] = v29;
          sub_1000558F4((const void **)v48);
        }
        if (SHIBYTE(theString2[2]) < 0) {
          operator delete((void *)theString2[0]);
        }
        CFStringRef v30 = v56;
        key = v56;
        __int16 v56 = 0;
        sub_1000558F4((const void **)&v56);
        if (SHIBYTE(v58) < 0) {
          operator delete(__p[0]);
        }
        CFComparisonResult v31 = CFStringCompare(v18, v30, 0);
        sub_1000558F4((const void **)&key);
        if (SHIBYTE(v54) < 0) {
          operator delete(__dst[0]);
        }
        if (v31 == kCFCompareEqualTo) {
          return sub_1007FF6A8(a7, a6);
        }
      }
    }
    goto LABEL_78;
  }
  if (CFStringHasPrefix(theString, @"device.")) {
    goto LABEL_11;
  }
  if (!CFStringHasPrefix(theString, @"dev.")) {
    goto LABEL_78;
  }
LABEL_16:
  __int16 v20 = (unsigned int *)CFDictionaryGetValue(a6, @"ts");
  CFDictionaryRef v22 = v20;
  if (v20)
  {
    CFTypeID v23 = CFGetTypeID(v20);
    if (v23 == CFNumberGetTypeID()) {
      CFDictionaryRef v24 = v22;
    }
    else {
      CFDictionaryRef v24 = 0;
    }
  }
  else
  {
    CFDictionaryRef v24 = 0;
  }
  LODWORD(theString2[0]) = 0;
  ctu::cf::assign((ctu::cf *)theString2, v24, v21);
  int v25 = (int)theString2[0];
  CFDictionaryRef v26 = (const __CFDictionary *)CFDictionaryGetValue(a6, @"accounts");
  CFDictionaryRef v27 = v26;
  if (!v26) {
    goto LABEL_78;
  }
  CFTypeID v28 = CFGetTypeID(v26);
  if (v28 != CFDictionaryGetTypeID()) {
    goto LABEL_78;
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v51, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v51 = *(_OWORD *)a4;
    CFStringRef v52 = *(const __CFString **)(a4 + 16);
  }
  if (SHIBYTE(v52) < 0)
  {
    sub_10004FC84(__p, v51[0], (unint64_t)v51[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v51;
    CFStringRef v58 = v52;
  }
  __int16 v56 = 0;
  if (SHIBYTE(v58) < 0)
  {
    sub_10004FC84(theString2, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)CFStringRef theString2 = *(_OWORD *)__p;
    theString2[2] = v58;
  }
  BOOL v59 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v32 = v56;
    __int16 v56 = v59;
    v48[0] = v32;
    sub_1000558F4((const void **)v48);
  }
  if (SHIBYTE(theString2[2]) < 0) {
    operator delete((void *)theString2[0]);
  }
  key = v56;
  __int16 v56 = 0;
  sub_1000558F4((const void **)&v56);
  if (SHIBYTE(v58) < 0) {
    operator delete(__p[0]);
  }
  __int16 v33 = CFDictionaryGetValue(v27, key);
  sub_1000558F4((const void **)&key);
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
  if (!v33) {
    goto LABEL_78;
  }
  uint64_t v34 = a2[5];
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    int v35 = *(char *)(a4 + 23);
    uint64_t v36 = *(void *)a4;
    memset(theString2, 0, sizeof(theString2));
    ctu::cf::assign();
    if (v35 >= 0) {
      uint64_t v37 = a4;
    }
    else {
      uint64_t v37 = v36;
    }
    *(_OWORD *)std::string __p = *(_OWORD *)theString2;
    CFStringRef v58 = theString2[2];
    CFStringRef v38 = (CFStringRef)__p;
    if (SHIBYTE(theString2[2]) < 0) {
      CFStringRef v38 = theString2[0];
    }
    LODWORD(theString2[0]) = 136315906;
    *(CFStringRef *)((char *)theString2 + 4) = (CFStringRef)"";
    WORD2(theString2[1]) = 2080;
    *(CFStringRef *)((char *)&theString2[1] + 6) = (CFStringRef)"";
    HIWORD(theString2[2]) = 2080;
    uint64_t v61 = v37;
    __int16 v62 = 2080;
    CFStringRef v63 = v38;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I %s%sfound account %s in section 'D' %s", (uint8_t *)theString2, 0x2Au);
    if (SHIBYTE(v58) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1007FF600((uint64_t)a2, (uint64_t)theString, (uint64_t)v33, (uint64_t *)a4);
  sub_1000584C8((const void **)__p, &v50);
  v48[0] = 0;
  theString2[0] = 0;
  sub_10004EFE4(theString2, (CFTypeRef *)__p);
  if (theString2[0]) {
    CFTypeID v39 = sub_100080778;
  }
  else {
    CFTypeID v39 = 0;
  }
  if (v39) {
    sub_100058140((const void **)v48, (const void **)theString2);
  }
  sub_100057D78((const void **)theString2);
  uint64_t v40 = v48[0];
  BOOL v59 = (__CFString *)v48[0];
  v48[0] = 0;
  sub_100057D78((const void **)v48);
  sub_1000577C4((const void **)__p);
  sub_1000577C4(&v50);
  if (v40) {
    uint64_t v41 = sub_100080778;
  }
  else {
    uint64_t v41 = 0;
  }
  if (!v41)
  {
    int v43 = a2[5];
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      int v44 = *(char *)(a4 + 23);
      uint64_t v45 = *(void *)a4;
      __p[0] = 0;
      __p[1] = 0;
      CFStringRef v58 = 0;
      ctu::cf::assign();
      if (v44 >= 0) {
        uint64_t v46 = a4;
      }
      else {
        uint64_t v46 = v45;
      }
      *(_OWORD *)int v48 = *(_OWORD *)__p;
      CFStringRef v49 = v58;
      int v47 = v48;
      if (SHIBYTE(v58) < 0) {
        int v47 = (void **)__p[0];
      }
      LODWORD(theString2[0]) = 136315906;
      *(CFStringRef *)((char *)theString2 + 4) = (CFStringRef)"";
      WORD2(theString2[1]) = 2080;
      *(CFStringRef *)((char *)&theString2[1] + 6) = (CFStringRef)"";
      HIWORD(theString2[2]) = 2080;
      uint64_t v61 = v46;
      __int16 v62 = 2080;
      CFStringRef v63 = (CFStringRef)v47;
      _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "#E %s%sunable to decrypt account %s in section 'D' %s", (uint8_t *)theString2, 0x2Au);
      if (SHIBYTE(v49) < 0) {
        operator delete(v48[0]);
      }
    }
    sub_100057D78((const void **)&v59);
    goto LABEL_78;
  }
  *(_DWORD *)a7 = v25;
  sub_100058198(a7 + 1, (const void **)&v59);
  xpc_object_t v42 = (const void **)&v59;
  return sub_100057D78(v42);
}

void sub_100800CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,const void *a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a38);
  _Unwind_Resume(a1);
}

CFStringRef sub_100800E2C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, CFStringRef *a3@<X8>)
{
  if (*((char *)a2 + 23) >= 0) {
    CFComparisonResult v4 = a2;
  }
  else {
    CFComparisonResult v4 = (uint64_t *)*a2;
  }
  CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@%s", a1, v4);
  *a3 = result;
  return result;
}

const void **sub_100800E8C(const void **a1)
{
  sub_1000558F4(a1 + 2);
  sub_100062778(a1 + 1);

  return sub_1000558F4(a1);
}

const void **sub_100800ED0(uint64_t ***a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  CFComparisonResult v4 = (char *)operator new(0xC0uLL);
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *(void *)CFComparisonResult v4 = off_101A0C7D8;
  *((void *)v4 + 4) = 0;
  uint64_t v5 = (void **)(v4 + 32);
  *((void *)v4 + 3) = v4 + 32;
  *((void *)v4 + 7) = 0;
  *((void *)v4 + 6) = v4 + 56;
  v208 = a1;
  v209 = (uint64_t **)(v4 + 48);
  *((void *)v4 + 5) = 0;
  *((void *)v4 + 8) = 0;
  *((void *)v4 + 22) = 0;
  int v6 = v4 + 176;
  *((void *)v4 + 23) = 0;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_OWORD *)(v4 + 136) = 0u;
  *(_OWORD *)(v4 + 152) = 0u;
  *((void *)v4 + 21) = v4 + 176;
  v204 = (void ***)(v4 + 24);
  *a1 = (uint64_t **)(v4 + 24);
  a1[1] = (uint64_t **)v4;
  CFDictionaryRef v7 = CFPreferencesCopyMultiple(0, @"com.apple.commcenter.callservices", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFDictionaryRef theDict = v7;
  if (v7) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8) {
    goto LABEL_311;
  }
  CFIndex Count = CFDictionaryGetCount(v7);
  keys = 0;
  v214 = 0;
  uint64_t v215 = 0;
  sub_10019E8F0(&keys, Count);
  values = 0;
  v211 = 0;
  uint64_t v212 = 0;
  CFIndex v206 = Count;
  sub_10004EE3C(&values, Count);
  CFDictionaryGetKeysAndValues(theDict, (const void **)keys, (const void **)values);
  v201 = v4 + 176;
  v202 = (void **)(v4 + 32);
  v203 = v4;
  int v10 = (uint64_t **)(v4 + 24);
  CFIndex v11 = Count;
  if (Count)
  {
    uint64_t v12 = 0;
    while (1)
    {
      CFStringRef v13 = (const __CFString *)keys[v12];
      int v14 = values[v12];
      if (!CFStringHasPrefix(v13, @"phone.services."))
      {
        if (CFStringHasPrefix(v13, @"dev."))
        {
          std::string::size_type Length = CFStringGetLength(@"dev.");
          memset(&__str, 0, sizeof(__str));
          memset(&v234, 0, sizeof(v234));
          ctu::cf::assign();
          std::string __str = v234;
          std::string::size_type size = v234.__r_.__value_.__l.__size_;
          char v18 = HIBYTE(v234.__r_.__value_.__r.__words[2]);
          if ((v234.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v234.__r_.__value_.__r.__words[2]);
          }
          if (size > Length) {
            goto LABEL_41;
          }
          goto LABEL_44;
        }
        if (CFStringHasPrefix(v13, @"device."))
        {
          std::string::size_type Length = CFStringGetLength(@"device.");
          memset(&__str, 0, sizeof(__str));
          memset(&v234, 0, sizeof(v234));
          ctu::cf::assign();
          std::string __str = v234;
          std::string::size_type v23 = v234.__r_.__value_.__l.__size_;
          char v18 = HIBYTE(v234.__r_.__value_.__r.__words[2]);
          if ((v234.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v23 = HIBYTE(v234.__r_.__value_.__r.__words[2]);
          }
          if (v23 > Length)
          {
LABEL_41:
            std::string::basic_string(&v234, &__str, Length, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v233);
            sub_1000EA6A0(v209, (void **)&v234.__r_.__value_.__l.__data_, (uint64_t)&v234);
            if (SHIBYTE(v234.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v234.__r_.__value_.__l.__data_);
            }
            char v18 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          }
LABEL_44:
          if (v18 < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          goto LABEL_88;
        }
        goto LABEL_88;
      }
      memset(&__dst, 0, sizeof(__dst));
      sub_1007FCC64(@"phone.services.", &__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        if (v14) {
          BOOL v19 = __dst.__r_.__value_.__l.__size_ == 0;
        }
        else {
          BOOL v19 = 1;
        }
        if (v19) {
          goto LABEL_84;
        }
        v217.__r_.__value_.__r.__words[0] = 0;
      }
      else
      {
        if (v14) {
          BOOL v15 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]) == 0;
        }
        else {
          BOOL v15 = 1;
        }
        if (v15) {
          goto LABEL_84;
        }
        v217.__r_.__value_.__r.__words[0] = 0;
      }
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 152) + 64))(&cf);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
      if (cf) {
        CFRetain(cf);
      }
      v233.__r_.__value_.__r.__words[0] = 0;
      v234.__r_.__value_.__r.__words[0] = 0;
      sub_10004EFE4(&v234, (CFTypeRef *)&__str.__r_.__value_.__l.__data_);
      if (v234.__r_.__value_.__r.__words[0]) {
        __int16 v20 = sub_100080778;
      }
      else {
        __int16 v20 = 0;
      }
      if (v20) {
        sub_100058140((const void **)&v233.__r_.__value_.__l.__data_, (const void **)&v234.__r_.__value_.__l.__data_);
      }
      sub_100057D78((const void **)&v234.__r_.__value_.__l.__data_);
      v217.__r_.__value_.__r.__words[0] = v233.__r_.__value_.__r.__words[0];
      v233.__r_.__value_.__r.__words[0] = 0;
      sub_100057D78((const void **)&v233.__r_.__value_.__l.__data_);
      sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
      sub_1000577C4(&cf);
      if (v217.__r_.__value_.__r.__words[0]) {
        CFNumberRef v21 = sub_100080778;
      }
      else {
        CFNumberRef v21 = 0;
      }
      if (v21)
      {
        std::string::size_type v218 = 0;
        CFDictionaryRef v219 = 0;
        sub_1007FF6A8((const void **)&v218, (CFDictionaryRef)v217.__r_.__value_.__l.__data_);
        v221 = 0;
        CFDictionaryRef v22 = v219;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__str, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string __str = __dst;
        }
        char v231 = 1;
        char v29 = sub_1007FC458(a2, v22, (long long *)&__str, &v221, 0);
        if (v231 && SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if (v29)
        {
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v219, @"primaryDeviceId");
          CFStringRef v31 = Value;
          if (Value && (CFTypeID v32 = CFGetTypeID(Value), v32 == CFStringGetTypeID()))
          {
            __int16 v33 = (char *)operator new(0x88uLL);
            *((void *)v33 + 1) = 0;
            *((void *)v33 + 2) = 0;
            *(void *)__int16 v33 = off_101A0C788;
            *(_OWORD *)(v33 + 24) = 0u;
            uint64_t v34 = v33 + 24;
            *(_OWORD *)(v33 + 104) = 0u;
            *(_OWORD *)(v33 + 40) = 0u;
            *(_OWORD *)(v33 + 56) = 0u;
            *(_OWORD *)(v33 + 72) = 0u;
            *(_OWORD *)(v33 + 88) = 0u;
            *(_OWORD *)(v33 + 120) = 0u;
            *((void *)v33 + 14) = v33 + 120;
            v234.__r_.__value_.__r.__words[0] = (std::string::size_type)v31;
            sub_100013168((const void **)v33 + 3, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
            int v35 = CFDictionaryGetValue(v219, @"phoneNumber");
            std::string::size_type v36 = (std::string::size_type)v35;
            if (v35)
            {
              CFTypeID v37 = CFGetTypeID(v35);
              if (v37 == CFStringGetTypeID()) {
                std::string::size_type v38 = v36;
              }
              else {
                std::string::size_type v38 = 0;
              }
            }
            else
            {
              std::string::size_type v38 = 0;
            }
            v234.__r_.__value_.__r.__words[0] = v38;
            sub_100013168((const void **)v33 + 5, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
            BOOL v59 = CFDictionaryGetValue(v219, @"carrierMCC");
            std::string::size_type v60 = (std::string::size_type)v59;
            if (v59)
            {
              CFTypeID v61 = CFGetTypeID(v59);
              if (v61 == CFStringGetTypeID()) {
                std::string::size_type v62 = v60;
              }
              else {
                std::string::size_type v62 = 0;
              }
            }
            else
            {
              std::string::size_type v62 = 0;
            }
            v234.__r_.__value_.__r.__words[0] = v62;
            sub_100013168((const void **)v33 + 9, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
            CFStringRef v63 = CFDictionaryGetValue(v219, @"carrierIsoMCC");
            std::string::size_type v64 = (std::string::size_type)v63;
            if (v63)
            {
              CFTypeID v65 = CFGetTypeID(v63);
              if (v65 == CFStringGetTypeID()) {
                std::string::size_type v66 = v64;
              }
              else {
                std::string::size_type v66 = 0;
              }
            }
            else
            {
              std::string::size_type v66 = 0;
            }
            v234.__r_.__value_.__r.__words[0] = v66;
            sub_100013168((const void **)v33 + 10, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
            *((void *)v33 + 12) = v221;
            uint64_t v67 = CFDictionaryGetValue(v219, @"labelID");
            std::string::size_type v68 = (std::string::size_type)v67;
            if (v67)
            {
              CFTypeID v69 = CFGetTypeID(v67);
              if (v69 == CFStringGetTypeID())
              {
                v234.__r_.__value_.__r.__words[0] = v68;
                sub_100013168((const void **)v33 + 6, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
              }
            }
            CFArrayRef v70 = (const __CFArray *)CFDictionaryGetValue(v219, @"cfgSlots");
            CFArrayRef v71 = v70;
            if (v70 && (CFTypeID v72 = CFGetTypeID(v70), v72 == CFArrayGetTypeID()))
            {
              int data = CFArrayGetCount(v71);
            }
            else
            {
              CFStringRef v74 = (int *)CFDictionaryGetValue(v219, @"maxDeviceNumber");
              CFStringRef v75 = v74;
              LODWORD(v234.__r_.__value_.__l.__data_) = 5;
              if (v74)
              {
                CFTypeID v76 = CFGetTypeID(v74);
                if (v76 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&v234, v75, v77);
                }
              }
              int data = (int)v234.__r_.__value_.__l.__data_;
            }
            *((_DWORD *)v33 + 14) = data;
            __int16 v78 = (unint64_t *)CFDictionaryGetValue(v219, @"ts");
            long long v79 = v78;
            if (v78)
            {
              CFTypeID v80 = CFGetTypeID(v78);
              if (v80 == CFNumberGetTypeID())
              {
                v234.__r_.__value_.__r.__words[0] = 0;
                ctu::cf::assign((ctu::cf *)&v234, v79, v81);
                *((void *)v33 + 11) = v234.__r_.__value_.__r.__words[0];
              }
            }
            if (sub_1007FA824((void *)a2))
            {
              CFStringRef v82 = (const __CFString *)sub_1007FA824((void *)a2);
              if (CFEqual(v82, v31))
              {
                os_log_t v83 = *(NSObject **)(a2 + 40);
                BOOL v84 = os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT);
                __int16 v85 = (uint64_t *)*v208;
                if (v84)
                {
                  unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * ((v85[10] - v85[9]) >> 3);
                  p_dst = &__dst;
                  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
                  }
                  LODWORD(v234.__r_.__value_.__l.__data_) = 136315906;
                  *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                  WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                  HIWORD(v234.__r_.__value_.__r.__words[2]) = 2048;
                  v235 = (_OWORD *)v86;
                  __int16 v236 = 2080;
                  v237 = p_dst;
                  _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "#I %s%sSee my own account %zu : %s", (uint8_t *)&v234, 0x2Au);
                }
                unint64_t v88 = v85[10];
                if (v88 >= v85[11])
                {
                  uint64_t v90 = sub_100048008(v85 + 9, (long long *)&__dst);
                }
                else
                {
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                  {
                    sub_10004FC84((unsigned char *)v85[10], __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                  }
                  else
                  {
                    long long v89 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
                    *(void *)(v88 + 16) = *((void *)&__dst.__r_.__value_.__l + 2);
                    *(_OWORD *)unint64_t v88 = v89;
                  }
                  uint64_t v90 = v88 + 24;
                  v85[10] = v88 + 24;
                }
                v85[10] = v90;
              }
            }
          }
          else
          {
            uint64_t v41 = *(NSObject **)(a2 + 40);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              memset(&v233, 0, sizeof(v233));
              ctu::cf::assign();
              std::string __p = v233;
              p_p = (std::string *)v233.__r_.__value_.__r.__words[0];
              if ((v233.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_p = &__p;
              }
              LODWORD(v234.__r_.__value_.__l.__data_) = 136315650;
              *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
              WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
              HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
              v235 = p_p;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%s%s: primary device ID is missing in config - probably old format - skipped", (uint8_t *)&v234, 0x20u);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
            }
            int v43 = *v208;
            int v44 = (*v208)[16];
            if (v44 >= (*v208)[17])
            {
              uint64_t v47 = sub_100048008((uint64_t *)v43 + 15, (long long *)&__dst);
            }
            else
            {
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              {
                sub_10004FC84((*v208)[16], __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
              }
              else
              {
                long long v45 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
                v44[2] = __dst.__r_.__value_.__r.__words[2];
                *(_OWORD *)int v44 = v45;
              }
              uint64_t v47 = (uint64_t)(v44 + 3);
              v43[16] = v44 + 3;
            }
            uint64_t v34 = 0;
            __int16 v33 = 0;
            v43[16] = (uint64_t *)v47;
          }
        }
        else
        {
          CFTypeID v39 = *(NSObject **)(a2 + 40);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            memset(&v233, 0, sizeof(v233));
            ctu::cf::assign();
            std::string __p = v233;
            uint64_t v40 = &__p;
            if ((v233.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v40 = (std::string *)v233.__r_.__value_.__r.__words[0];
            }
            LODWORD(v234.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
            WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
            HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
            v235 = v40;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s%s: schema version mismatch - account skipped", (uint8_t *)&v234, 0x20u);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          uint64_t v34 = 0;
          __int16 v33 = 0;
        }
        sub_100057D78((const void **)&v219);
        sub_100057D78((const void **)&v217.__r_.__value_.__l.__data_);
        if (v34)
        {
          int v48 = *v208;
          int v50 = *v208 + 19;
          CFStringRef v49 = *v50;
          uint64_t v51 = v50;
          CFStringRef v52 = v50;
          if (!*v50) {
            goto LABEL_106;
          }
          uint64_t v51 = *v208 + 19;
          while (1)
          {
            while (1)
            {
              CFStringRef v52 = (uint64_t **)v49;
              BOOL v53 = v49 + 4;
              if ((sub_100046FE8(&__dst, (void **)v49 + 4) & 0x80) == 0) {
                break;
              }
              CFStringRef v49 = *v52;
              uint64_t v51 = v52;
              if (!*v52) {
                goto LABEL_106;
              }
            }
            if ((sub_100046FE8(v53, (void **)&__dst.__r_.__value_.__l.__data_) & 0x80) == 0) {
              break;
            }
            uint64_t v51 = v52 + 1;
            CFStringRef v49 = v52[1];
            if (!v49) {
              goto LABEL_106;
            }
          }
          std::string::size_type v54 = (std::string::size_type)*v51;
          if (!*v51)
          {
LABEL_106:
            v234.__r_.__value_.__r.__words[2] = 0;
            CFDictionaryRef v55 = (uint64_t *)operator new(0x48uLL);
            v234.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
            v234.__r_.__value_.__l.__size_ = (std::string::size_type)v50;
            v234.__r_.__value_.__s.__data_[16] = 0;
            __int16 v56 = v55 + 4;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            {
              sub_10004FC84(v56, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else
            {
              *(_OWORD *)__int16 v56 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
              v55[6] = __dst.__r_.__value_.__r.__words[2];
            }
            v55[7] = 0;
            v55[8] = 0;
            v234.__r_.__value_.__s.__data_[16] = 1;
            *CFDictionaryRef v55 = 0;
            v55[1] = 0;
            v55[2] = (uint64_t)v52;
            *uint64_t v51 = v55;
            uint64_t v57 = (uint64_t *)*v48[18];
            if (v57)
            {
              v48[18] = v57;
              CFDictionaryRef v55 = *v51;
            }
            sub_100046C90(v48[19], v55);
            v48[20] = (uint64_t *)((char *)v48[20] + 1);
            std::string::size_type v54 = v234.__r_.__value_.__r.__words[0];
            v234.__r_.__value_.__r.__words[0] = 0;
            sub_1001FEBC4((uint64_t)&v234);
          }
          if (v33) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)v33 + 1, 1uLL, memory_order_relaxed);
          }
          CFStringRef v58 = *(std::__shared_weak_count **)(v54 + 64);
          *(void *)(v54 + 56) = v34;
          *(void *)(v54 + 64) = v33;
          CFIndex v11 = v206;
          if (v58) {
            sub_10004D2C8(v58);
          }
        }
        goto LABEL_85;
      }
      CFDictionaryRef v24 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        memset(&__str, 0, sizeof(__str));
        ctu::cf::assign();
        std::string v233 = __str;
        int v25 = &v233;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          int v25 = (std::string *)v233.__r_.__value_.__r.__words[0];
        }
        LODWORD(v234.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
        v235 = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%s%s: unencryptable config - skipped", (uint8_t *)&v234, 0x20u);
        if (SHIBYTE(v233.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v233.__r_.__value_.__l.__data_);
        }
      }
      CFDictionaryRef v26 = *v208;
      CFDictionaryRef v27 = (*v208)[13];
      if (v27 >= (*v208)[14])
      {
        uint64_t v46 = sub_100048008((uint64_t *)v26 + 12, (long long *)&__dst);
      }
      else
      {
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84((*v208)[13], __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else
        {
          long long v28 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          v27[2] = __dst.__r_.__value_.__r.__words[2];
          *(_OWORD *)CFDictionaryRef v27 = v28;
        }
        uint64_t v46 = (uint64_t)(v27 + 3);
        v26[13] = v27 + 3;
      }
      v26[13] = (uint64_t *)v46;
      sub_100057D78((const void **)&v217.__r_.__value_.__l.__data_);
LABEL_84:
      __int16 v33 = 0;
LABEL_85:
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (!v33) {
          goto LABEL_88;
        }
LABEL_87:
        sub_10004D2C8((std::__shared_weak_count *)v33);
        goto LABEL_88;
      }
      if (v33) {
        goto LABEL_87;
      }
LABEL_88:
      if (++v12 == v11)
      {
        int v10 = *v208;
        break;
      }
    }
  }
  uint64_t v91 = (uint64_t **)v10[18];
  v207 = v10 + 19;
  if (v91 == v10 + 19) {
    goto LABEL_307;
  }
  CFDictionaryRef v205 = theDict;
  CFAllocatorRef v92 = kCFAllocatorDefault;
  while (1)
  {
    unint64_t v93 = v91 + 4;
    CFStringRef theString2 = 0;
    if (*((char *)v91 + 55) < 0)
    {
      sub_10004FC84(&__dst, v91[4], (unint64_t)v91[5]);
    }
    else
    {
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *v93;
      __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v91[6];
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v233, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string v233 = __dst;
    }
    v217.__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v233.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v234, v233.__r_.__value_.__l.__data_, v233.__r_.__value_.__l.__size_);
    }
    else {
      std::string v234 = v233;
    }
    std::string::size_type v218 = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v94 = v217.__r_.__value_.__r.__words[0];
      v217.__r_.__value_.__r.__words[0] = v218;
      __p.__r_.__value_.__r.__words[0] = v94;
      sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v234.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v234.__r_.__value_.__l.__data_);
    }
    CFStringRef theString2 = (CFStringRef)v217.__r_.__value_.__r.__words[0];
    v217.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v217.__r_.__value_.__l.__data_);
    if (SHIBYTE(v233.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v233.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    v227 = 0;
    long long v95 = (char *)(v91 + 4);
    if (*((char *)v91 + 55) < 0) {
      long long v95 = *(char **)v93;
    }
    sub_100058DB0(&v234, v95);
    if ((v234.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v96 = &v234;
    }
    else {
      long long v96 = (std::string *)v234.__r_.__value_.__r.__words[0];
    }
    long long v97 = (void *)CFStringCreateWithFormat(v92, 0, @"%@%s", @"assignments.", v96);
    v227 = v97;
    if (SHIBYTE(v234.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v234.__r_.__value_.__l.__data_);
      long long v97 = v227;
    }
    if (!CFDictionaryGetValue(v205, v97))
    {
      long long v101 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v91 + 55) < 0) {
          unint64_t v93 = *(_OWORD **)v93;
        }
        LODWORD(v234.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
        v235 = v93;
        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "#W %s%sNo assignment section for account %s", (uint8_t *)&v234, 0x20u);
      }
      goto LABEL_293;
    }
    CFDictionaryRef v226 = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 152) + 64))(&v225);
    v233.__r_.__value_.__r.__words[0] = (std::string::size_type)v225;
    if (v225) {
      CFRetain(v225);
    }
    __p.__r_.__value_.__r.__words[0] = 0;
    v234.__r_.__value_.__r.__words[0] = 0;
    sub_10004EFE4(&v234, (CFTypeRef *)&v233.__r_.__value_.__l.__data_);
    if (v234.__r_.__value_.__r.__words[0]) {
      uint64_t v98 = sub_100080778;
    }
    else {
      uint64_t v98 = 0;
    }
    if (v98) {
      sub_100058140((const void **)&__p.__r_.__value_.__l.__data_, (const void **)&v234.__r_.__value_.__l.__data_);
    }
    sub_100057D78((const void **)&v234.__r_.__value_.__l.__data_);
    CFDictionaryRef v226 = (CFDictionaryRef)__p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = 0;
    sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
    sub_1000577C4((const void **)&v233.__r_.__value_.__l.__data_);
    sub_1000577C4(&v225);
    if (v226) {
      uint64_t v99 = sub_100080778;
    }
    else {
      uint64_t v99 = 0;
    }
    if (!v99)
    {
      uint64_t v102 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
      {
        memset(&v233, 0, sizeof(v233));
        ctu::cf::assign();
        std::string __p = v233;
        long long v103 = (std::string *)v233.__r_.__value_.__r.__words[0];
        if ((v233.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v103 = &__p;
        }
        LODWORD(v234.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
        v235 = v103;
        _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#W %s%sUnable to decrypt %s", (uint8_t *)&v234, 0x20u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      goto LABEL_292;
    }
    CFTypeRef cf = 0;
    CFDictionaryRef v224 = 0;
    sub_1007FF6A8(&cf, v226);
    CFDictionaryRef v100 = v224;
    if (*((char *)v91 + 55) < 0)
    {
      sub_10004FC84(&__str, v91[4], (unint64_t)v91[5]);
    }
    else
    {
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *v93;
      __str.__r_.__value_.__r.__words[2] = (std::string::size_type)v91[6];
    }
    char v231 = 1;
    char v104 = sub_1007FCB38(a2, v100, (long long *)&__str, 0);
    if (v231 && SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    if ((v104 & 1) == 0) {
      break;
    }
    CFDictionaryRef v105 = v224;
    if (*(_DWORD *)(a2 + 96) == 1)
    {
      CFArrayRef v106 = (const __CFArray *)CFDictionaryGetValue(v224, @"whiteList");
      CFArrayRef v107 = v106;
      if (!v106) {
        goto LABEL_219;
      }
      CFTypeID v108 = CFGetTypeID(v106);
      if (v108 != CFArrayGetTypeID()) {
        goto LABEL_219;
      }
      CFIndex v109 = CFArrayGetCount(v107);
      if (v109)
      {
        CFIndex v110 = 0;
        while (1)
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v107, v110);
          CFStringRef v112 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v113 = CFGetTypeID(ValueAtIndex);
            if (v113 == CFStringGetTypeID())
            {
              if (sub_1007FA824((void *)a2))
              {
                CFStringRef v114 = (const __CFString *)sub_1007FA824((void *)a2);
                if (CFEqual(v112, v114)) {
                  break;
                }
              }
            }
          }
          if (v109 == ++v110) {
            goto LABEL_217;
          }
        }
LABEL_219:
        char v115 = 1;
      }
      else
      {
LABEL_217:
        char v115 = 0;
      }
      CFArrayRef v116 = (const __CFArray *)CFDictionaryGetValue(v105, @"blackList");
      CFArrayRef v117 = v116;
      if (v116)
      {
        CFTypeID v118 = CFGetTypeID(v116);
        if (v118 == CFArrayGetTypeID())
        {
          CFIndex v119 = CFArrayGetCount(v117);
          if (v119)
          {
            CFIndex v120 = 0;
            while (1)
            {
              CFStringRef v121 = (const __CFString *)CFArrayGetValueAtIndex(v117, v120);
              CFStringRef v122 = v121;
              if (v121)
              {
                CFTypeID v123 = CFGetTypeID(v121);
                if (v123 == CFStringGetTypeID())
                {
                  if (sub_1007FA824((void *)a2))
                  {
                    CFStringRef v124 = (const __CFString *)sub_1007FA824((void *)a2);
                    if (CFEqual(v122, v124)) {
                      break;
                    }
                  }
                }
              }
              if (v119 == ++v120) {
                goto LABEL_229;
              }
            }
            char v115 = 0;
          }
        }
      }
LABEL_229:
      CFDictionaryRef v105 = v224;
      goto LABEL_230;
    }
    char v115 = 1;
LABEL_230:
    *((unsigned char *)v91[7] + 80) = v115 ^ 1;
    v125 = (int *)CFDictionaryGetValue(v105, @"foreignDevicesCount");
    v126 = v125;
    LODWORD(v234.__r_.__value_.__l.__data_) = 0;
    if (v125)
    {
      CFTypeID v127 = CFGetTypeID(v125);
      if (v127 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&v234, v126, v128);
      }
    }
    *((_DWORD *)v91[7] + 10) = v234.__r_.__value_.__l.__data_;
    CFDictionaryRef v129 = (const __CFDictionary *)CFDictionaryGetValue(v224, @"assignments");
    CFDictionaryRef v130 = v129;
    if (v129)
    {
      CFIndex v131 = CFDictionaryGetCount(v129);
      *((_DWORD *)v91[7] + 9) = v131;
      memset(&v233, 0, sizeof(v233));
      sub_10019E8F0(&v233, v131);
      memset(&__p, 0, sizeof(__p));
      sub_10004EE3C(&__p, v131);
      CFDictionaryGetKeysAndValues(v130, (const void **)v233.__r_.__value_.__l.__data_, (const void **)__p.__r_.__value_.__l.__data_);
      if (v131)
      {
        for (uint64_t i = 0; i != v131; ++i)
        {
          CFStringRef v133 = *(const __CFString **)(__p.__r_.__value_.__r.__words[0] + 8 * i);
          if (v133)
          {
            std::string::size_type v134 = *(void *)(v233.__r_.__value_.__r.__words[0] + 8 * i);
            CFTypeID v135 = CFGetTypeID(*(CFTypeRef *)(__p.__r_.__value_.__r.__words[0] + 8 * i));
            if (v135 == CFStringGetTypeID())
            {
              v221 = 0;
              CFDictionaryRef v222 = 0;
              sub_1007FFAA4((void *)a2, 2, (void **)v91 + 4, (uint64_t)v133, &v221);
              if (v222) {
                v136 = sub_100080778;
              }
              else {
                v136 = 0;
              }
              if (v136)
              {
                CFStringRef v137 = (const __CFString *)CFDictionaryGetValue(v222, @"account");
                CFStringRef v138 = v137;
                if (v137
                  && (CFTypeID v139 = CFGetTypeID(v137), v139 == CFStringGetTypeID())
                  && CFStringCompare(v138, theString2, 0))
                {
                  CFDictionaryRef v140 = v222;
                  CFDictionaryRef v222 = 0;
                  v234.__r_.__value_.__r.__words[0] = (std::string::size_type)v140;
                  sub_100057D78((const void **)&v234.__r_.__value_.__l.__data_);
                }
                else
                {
                  std::string::size_type v218 = 0;
                  CFDictionaryRef v219 = 0;
                  v220 = 0;
                  v234.__r_.__value_.__r.__words[0] = v134;
                  sub_100013168((const void **)&v218, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
                  CFBooleanRef v141 = (const __CFBoolean *)CFDictionaryGetValue(v222, @"enable");
                  CFBooleanRef v142 = kCFBooleanTrue;
                  if (v141) {
                    CFBooleanRef v142 = v141;
                  }
                  v217.__r_.__value_.__r.__words[0] = (std::string::size_type)v142;
                  v234.__r_.__value_.__r.__words[0] = 0;
                  v143 = (const void **)sub_1000057AC(&v234, (CFTypeRef *)&v217.__r_.__value_.__l.__data_);
                  CFDictionaryRef v144 = v219;
                  CFDictionaryRef v219 = (CFDictionaryRef)v234.__r_.__value_.__r.__words[0];
                  v234.__r_.__value_.__r.__words[0] = (std::string::size_type)v144;
                  sub_100062778(v143);
                  v145 = CFDictionaryGetValue(v222, @"hardware");
                  std::string::size_type v146 = (std::string::size_type)v145;
                  if (v145)
                  {
                    CFTypeID v147 = CFGetTypeID(v145);
                    if (v147 == CFStringGetTypeID())
                    {
                      v234.__r_.__value_.__r.__words[0] = v146;
                      sub_100013168(&v220, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
                    }
                  }
                  memset(&v217, 0, sizeof(v217));
                  memset(&v234, 0, sizeof(v234));
                  ctu::cf::assign();
                  std::string v217 = v234;
                  v148 = (uint64_t **)(v91[7] + 11);
                  v234.__r_.__value_.__r.__words[0] = (std::string::size_type)&v217;
                  v149 = (const void **)sub_100807834(v148, (void **)&v217.__r_.__value_.__l.__data_, (long long **)&v234);
                  sub_100083EB8(v149 + 7, (const void **)&v218);
                  sub_1005AED68(v149 + 8, (const void **)&v219);
                  sub_100083EB8(v149 + 9, &v220);
                  v150 = *(NSObject **)(a2 + 40);
                  if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
                  {
                    v151 = &v217;
                    if ((v217.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                      v151 = (std::string *)v217.__r_.__value_.__r.__words[0];
                    }
                    v152 = (std::string *)(v91 + 4);
                    if (*((char *)v91 + 55) < 0) {
                      v152 = *(std::string **)v93;
                    }
                    LODWORD(v234.__r_.__value_.__l.__data_) = 136315906;
                    *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                    WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
                    *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                    HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
                    v235 = v151;
                    __int16 v236 = 2080;
                    v237 = v152;
                    _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I %s%sdev:%s belongs to account:%s. Acknowledged.", (uint8_t *)&v234, 0x2Au);
                  }
                  v153 = (uint64_t *)*v208;
                  sub_100046BAC(*v208, (void **)&v217.__r_.__value_.__l.__data_, (uint64_t)&v217);
                  if (sub_1007FA824((void *)a2))
                  {
                    CFStringRef v154 = (const __CFString *)sub_1007FA824((void *)a2);
                    if (CFEqual(v154, v133))
                    {
                      v155 = v153 + 6;
                      unint64_t v156 = v153[7];
                      if (v156 >= v153[8])
                      {
                        uint64_t v157 = sub_100048008(v155, (long long *)v91 + 2);
                      }
                      else
                      {
                        sub_1000D87F8(v155, (long long *)v91 + 2);
                        uint64_t v157 = v156 + 24;
                      }
                      v153[7] = v157;
                    }
                  }
                  if (SHIBYTE(v217.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v217.__r_.__value_.__l.__data_);
                  }
                  sub_1000558F4(&v220);
                  sub_100062778((const void **)&v219);
                  sub_1000558F4((const void **)&v218);
                }
              }
              if (v222) {
                v158 = sub_100080778;
              }
              else {
                v158 = 0;
              }
              if (!v158)
              {
                std::string::size_type v218 = 0;
                CFDictionaryRef v219 = 0;
                v220 = 0;
                v234.__r_.__value_.__r.__words[0] = v134;
                sub_100013168((const void **)&v218, (CFTypeRef *)&v234.__r_.__value_.__l.__data_);
                memset(&v217, 0, sizeof(v217));
                memset(&v234, 0, sizeof(v234));
                ctu::cf::assign();
                std::string v217 = v234;
                v159 = (uint64_t **)(v91[7] + 11);
                v234.__r_.__value_.__r.__words[0] = (std::string::size_type)&v217;
                v160 = (const void **)sub_100807834(v159, (void **)&v217.__r_.__value_.__l.__data_, (long long **)&v234);
                sub_100083EB8(v160 + 7, (const void **)&v218);
                sub_1005AED68(v160 + 8, (const void **)&v219);
                sub_100083EB8(v160 + 9, &v220);
                v161 = *(NSObject **)(a2 + 40);
                if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
                {
                  v162 = &v217;
                  if ((v217.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    v162 = (std::string *)v217.__r_.__value_.__r.__words[0];
                  }
                  v163 = (std::string *)(v91 + 4);
                  if (*((char *)v91 + 55) < 0) {
                    v163 = *(std::string **)v93;
                  }
                  LODWORD(v234.__r_.__value_.__l.__data_) = 136315906;
                  *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                  WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                  HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
                  v235 = v162;
                  __int16 v236 = 2080;
                  v237 = v163;
                  _os_log_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_DEFAULT, "#I %s%sdev:%s belongs to account:%s", (uint8_t *)&v234, 0x2Au);
                }
                v164 = *v208;
                sub_100046BAC(*v208, (void **)&v217.__r_.__value_.__l.__data_, (uint64_t)&v217);
                if (sub_1007FA824((void *)a2))
                {
                  CFStringRef v165 = (const __CFString *)sub_1007FA824((void *)a2);
                  if (CFEqual(v165, v133))
                  {
                    v166 = (uint64_t *)(v164 + 6);
                    v167 = v164[7];
                    if (v167 >= v164[8])
                    {
                      uint64_t v168 = sub_100048008(v166, (long long *)v91 + 2);
                    }
                    else
                    {
                      sub_1000D87F8(v166, (long long *)v91 + 2);
                      uint64_t v168 = (uint64_t)(v167 + 3);
                    }
                    v164[7] = (uint64_t *)v168;
                  }
                }
                if (SHIBYTE(v217.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v217.__r_.__value_.__l.__data_);
                }
                sub_1000558F4(&v220);
                sub_100062778((const void **)&v219);
                sub_1000558F4((const void **)&v218);
              }
              sub_100057D78((const void **)&v222);
            }
          }
        }
      }
      if (__p.__r_.__value_.__r.__words[0])
      {
        __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v233.__r_.__value_.__r.__words[0])
      {
        v233.__r_.__value_.__l.__size_ = v233.__r_.__value_.__r.__words[0];
        operator delete(v233.__r_.__value_.__l.__data_);
      }
    }
    sub_100057D78((const void **)&v224);
LABEL_292:
    sub_100057D78((const void **)&v226);
LABEL_293:
    sub_1000558F4((const void **)&v227);
    sub_1000558F4((const void **)&theString2);
    v169 = v91[1];
    if (v169)
    {
      do
      {
        v170 = (uint64_t **)v169;
        v169 = (uint64_t *)*v169;
      }
      while (v169);
    }
    else
    {
      do
      {
        v170 = (uint64_t **)v91[2];
        BOOL v15 = *v170 == (uint64_t *)v91;
        uint64_t v91 = v170;
      }
      while (!v15);
    }
    uint64_t v91 = v170;
    CFAllocatorRef v92 = kCFAllocatorDefault;
    if (v170 == v207) {
      goto LABEL_307;
    }
  }
  v171 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT))
  {
    memset(&v233, 0, sizeof(v233));
    ctu::cf::assign();
    std::string __p = v233;
    v172 = &__p;
    if ((v233.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      v172 = (std::string *)v233.__r_.__value_.__r.__words[0];
    }
    LODWORD(v234.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v234.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
    WORD2(v234.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v234.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
    HIWORD(v234.__r_.__value_.__r.__words[2]) = 2080;
    v235 = v172;
    _os_log_impl((void *)&_mh_execute_header, v171, OS_LOG_TYPE_DEFAULT, "#I %s%s%s: schema version mismatch - assignment record skipped", (uint8_t *)&v234, 0x20u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  sub_100057D78((const void **)&v224);
  sub_100057D78((const void **)&v226);
  sub_1000558F4((const void **)&v227);
  sub_1000558F4((const void **)&theString2);
LABEL_307:
  if (values)
  {
    v211 = values;
    operator delete(values);
  }
  uint64_t v5 = v202;
  CFComparisonResult v4 = v203;
  int v6 = v201;
  if (keys)
  {
    v214 = keys;
    operator delete(keys);
  }
LABEL_311:
  v173 = (void *)*((void *)v4 + 21);
  if (v173 != v6)
  {
    while (2)
    {
      CFStringRef v174 = *(const __CFString **)v173[7];
      if (!sub_1007FA824((void *)a2))
      {
        LOWORD(v179) = 0;
        goto LABEL_326;
      }
      CFStringRef v175 = (const __CFString *)sub_1007FA824((void *)a2);
      v176 = (capabilities::ct *)CFStringCompare(v174, v175, 0);
      if (v176)
      {
        if (*(_DWORD *)(a2 + 96))
        {
          char v177 = capabilities::ct::supportsThumperSourcing(v176);
          char v178 = sub_1007F89C4(a2);
          if (sub_1007F82A8(v177, v178))
          {
            v179 = *(void **)(a2 + 112);
            if (v179)
            {
              uint64_t v180 = v179[1];
              if (*v179 != v180)
              {
                uint64_t v181 = *v179 + 24;
                do
                {
                  CFComparisonResult v182 = CFStringCompare(*(CFStringRef *)(v181 - 24), v174, 0);
                  LOWORD(v179) = v182 == kCFCompareEqualTo;
                  if (v182) {
                    BOOL v183 = v181 == v180;
                  }
                  else {
                    BOOL v183 = 1;
                  }
                  v181 += 24;
                }
                while (!v183);
                goto LABEL_342;
              }
LABEL_359:
              LOWORD(v179) = 0;
              goto LABEL_342;
            }
LABEL_326:
            LOWORD(v184) = 0;
          }
          else
          {
            v179 = *(void **)(a2 + 128);
            if (!v179) {
              goto LABEL_326;
            }
            uint64_t v193 = v179[1];
            if (*v179 == v193) {
              goto LABEL_359;
            }
            uint64_t v194 = *v179 + 24;
            do
            {
              CFComparisonResult v195 = CFStringCompare(*(CFStringRef *)(v194 - 24), v174, 0);
              LOWORD(v179) = v195 == kCFCompareEqualTo;
              if (v195) {
                BOOL v196 = v194 == v193;
              }
              else {
                BOOL v196 = 1;
              }
              v194 += 24;
            }
            while (!v196);
LABEL_342:
            LOWORD(v184) = 1;
          }
LABEL_343:
          *(_WORD *)(v173[7] + 8) = (unsigned __int16)v179 | ((_WORD)v184 << 8);
          v191 = (void *)v173[1];
          if (v191)
          {
            do
            {
              v192 = v191;
              v191 = (void *)*v191;
            }
            while (v191);
          }
          else
          {
            do
            {
              v192 = (void *)v173[2];
              BOOL v15 = *v192 == (void)v173;
              v173 = v192;
            }
            while (!v15);
          }
          v173 = v192;
          if (v192 == v6) {
            goto LABEL_363;
          }
          continue;
        }
        v184 = *(CFStringRef ***)(a2 + 112);
        if (!v184)
        {
          LOWORD(v179) = 0;
          goto LABEL_343;
        }
        v179 = *(void **)(a2 + 128);
        if (!v179) {
          goto LABEL_326;
        }
        v185 = *v184;
        v186 = v184[1];
        if (*v184 == v186)
        {
LABEL_333:
          uint64_t v187 = v179[1];
          if (*v179 == v187)
          {
            LOWORD(v179) = 0;
          }
          else
          {
            uint64_t v188 = *v179 + 24;
            do
            {
              CFComparisonResult v189 = CFStringCompare(*(CFStringRef *)(v188 - 24), v174, 0);
              LOWORD(v179) = v189 == kCFCompareEqualTo;
              if (v189) {
                BOOL v190 = v188 == v187;
              }
              else {
                BOOL v190 = 1;
              }
              v188 += 24;
            }
            while (!v190);
          }
          LOWORD(v184) = (_WORD)v179;
          goto LABEL_343;
        }
        while (CFStringCompare(*v185, v174, 0))
        {
          v185 += 3;
          if (v185 == v186)
          {
            v179 = *(void **)(a2 + 128);
            goto LABEL_333;
          }
        }
      }
      break;
    }
    LOWORD(v179) = 1;
    goto LABEL_342;
  }
LABEL_363:
  v197 = *v204;
  if (*v204 != v5)
  {
    do
    {
      sub_1000E9358(*v208 + 3, v197 + 4);
      v198 = (void **)v197[1];
      if (v198)
      {
        do
        {
          v199 = v198;
          v198 = (void **)*v198;
        }
        while (v198);
      }
      else
      {
        do
        {
          v199 = (void **)v197[2];
          BOOL v15 = *v199 == v197;
          v197 = v199;
        }
        while (!v15);
      }
      v197 = v199;
    }
    while (v199 != v5);
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100802B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,const void **a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,const void *a46,const void *a47)
{
  *(void *)(v48 + 80) = v47;
  sub_100057D78(a36);
  sub_100057D78(&a47);
  if (*(char *)(v50 - 201) < 0) {
    operator delete(*(void **)(v50 - 224));
  }
  if (v49) {
    sub_10004D2C8(v49);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a43) {
    operator delete(a43);
  }
  sub_100057D78(&a46);
  sub_10004D2C8(a13);
  _Unwind_Resume(a1);
}

void sub_100802FA4(uint64_t a1@<X0>, __CFDictionary **a2@<X8>)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    v184 = 0;
    v185 = 0;
    sub_100800ED0(&v184, a1);
    sub_1008049B4(a1, &v184);
    *a2 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v5 = Mutable;
    if (Mutable)
    {
      *a2 = Mutable;
      *(void *)int buf = 0;
      sub_10005717C((const void **)buf);
    }
    BOOL v183 = 0;
    CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v153 = v5;
    uint64_t v155 = a1;
    CFDictionaryRef v144 = a2;
    if (v6)
    {
      CFDictionaryRef v7 = v183;
      BOOL v183 = v6;
      *(void *)int buf = v7;
      sub_1000440D4((const void **)buf);
    }
    uint64_t v8 = v184[18];
    key = v184;
    unint64_t v156 = v184 + 19;
    if (v8 != (uint64_t *)(v184 + 19))
    {
      uint64_t v9 = (const void *)kPSAccountId;
      int v10 = (const void *)kPSDeviceId;
      CFIndex v11 = (const void *)kPSMdn;
      uint64_t v12 = (const void *)kPSStatus;
      CFStringRef v13 = (const void *)kPSDeviceHardware;
      do
      {
        CFMutableArrayRef v182 = 0;
        if (*((char *)v8 + 55) < 0)
        {
          sub_10004FC84(__p, (void *)v8[4], v8[5]);
        }
        else
        {
          *(_OWORD *)std::string __p = *((_OWORD *)v8 + 2);
          uint64_t v181 = v8[6];
        }
        if (SHIBYTE(v181) < 0)
        {
          sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          long long __dst = *(_OWORD *)__p;
          uint64_t v188 = v181;
        }
        v186 = 0;
        if (SHIBYTE(v188) < 0)
        {
          sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          *(_OWORD *)int buf = __dst;
          *(void *)&uint8_t buf[16] = v188;
        }
        CFComparisonResult v189 = 0;
        if (ctu::cf::convert_copy())
        {
          int v14 = v186;
          v186 = v189;
          BOOL v190 = v14;
          sub_1000558F4(&v190);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        CFMutableArrayRef v182 = (CFMutableArrayRef)v186;
        v186 = 0;
        sub_1000558F4((const void **)&v186);
        if (SHIBYTE(v188) < 0) {
          operator delete((void *)__dst);
        }
        if (SHIBYTE(v181) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v15 = v8[7];
        CFComparisonResult v16 = *(void **)(v15 + 88);
        CFTypeID v17 = (void *)(v15 + 96);
        if (v16 != (void *)(v15 + 96))
        {
          do
          {
            CFMutableDictionaryRef theDict = 0;
            char v18 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v18)
            {
              CFMutableDictionaryRef v19 = theDict;
              CFMutableDictionaryRef theDict = v18;
              *(void *)int buf = v19;
              sub_10005717C((const void **)buf);
            }
            CFDictionaryAddValue(theDict, v9, v182);
            __int16 v20 = theDict;
            if (*((char *)v16 + 55) < 0)
            {
              sub_10004FC84(v176, (void *)v16[4], v16[5]);
            }
            else
            {
              *(_OWORD *)v176 = *((_OWORD *)v16 + 2);
              uint64_t v177 = v16[6];
            }
            if (SHIBYTE(v177) < 0)
            {
              sub_10004FC84(&__dst, v176[0], (unint64_t)v176[1]);
            }
            else
            {
              long long __dst = *(_OWORD *)v176;
              uint64_t v188 = v177;
            }
            v186 = 0;
            if (SHIBYTE(v188) < 0)
            {
              sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
            }
            else
            {
              *(_OWORD *)int buf = __dst;
              *(void *)&uint8_t buf[16] = v188;
            }
            CFComparisonResult v189 = 0;
            if (ctu::cf::convert_copy())
            {
              CFNumberRef v21 = v186;
              v186 = v189;
              BOOL v190 = v21;
              sub_1000558F4(&v190);
            }
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            value = v186;
            v186 = 0;
            sub_1000558F4((const void **)&v186);
            if (SHIBYTE(v188) < 0) {
              operator delete((void *)__dst);
            }
            CFDictionaryAddValue(v20, v10, value);
            sub_1000558F4((const void **)&value);
            if (SHIBYTE(v177) < 0) {
              operator delete(v176[0]);
            }
            CFDictionaryRef v22 = *(const void **)(v8[7] + 16);
            if (v22) {
              std::string::size_type v23 = sub_1000810B8;
            }
            else {
              std::string::size_type v23 = 0;
            }
            if (v23) {
              CFDictionaryAddValue(theDict, v11, v22);
            }
            CFDictionaryRef v24 = (const void *)v16[8];
            if (v24) {
              int v25 = sub_100084B4C;
            }
            else {
              int v25 = 0;
            }
            if (v25) {
              CFDictionaryAddValue(theDict, v12, v24);
            }
            CFDictionaryRef v26 = (const void *)v16[9];
            if (v26) {
              CFDictionaryRef v27 = sub_1000810B8;
            }
            else {
              CFDictionaryRef v27 = 0;
            }
            if (v27) {
              CFDictionaryAddValue(theDict, v13, v26);
            }
            CFArrayAppendValue(v183, theDict);
            sub_10005717C((const void **)&theDict);
            long long v28 = (void *)v16[1];
            if (v28)
            {
              do
              {
                char v29 = v28;
                long long v28 = (void *)*v28;
              }
              while (v28);
            }
            else
            {
              do
              {
                char v29 = (void *)v16[2];
                BOOL v30 = *v29 == (void)v16;
                CFComparisonResult v16 = v29;
              }
              while (!v30);
            }
            CFComparisonResult v16 = v29;
          }
          while (v29 != v17);
        }
        sub_1000558F4((const void **)&v182);
        CFStringRef v31 = (uint64_t *)v8[1];
        if (v31)
        {
          do
          {
            CFTypeID v32 = v31;
            CFStringRef v31 = (uint64_t *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            CFTypeID v32 = (uint64_t *)v8[2];
            BOOL v30 = *v32 == (void)v8;
            uint64_t v8 = v32;
          }
          while (!v30);
        }
        uint64_t v8 = v32;
      }
      while (v32 != (uint64_t *)v156);
    }
    __int16 v33 = v153;
    CFStringRef v154 = (void *)kPSDeviceList;
    uint64_t v34 = v144;
    CFDictionaryAddValue(v153, kPSDeviceList, v183);
    uint64_t v35 = v155;
    sub_1000440D4((const void **)&v183);
    BOOL v183 = 0;
    CFMutableArrayRef v36 = CFArrayCreateMutable(0, (CFIndex)key[20], &kCFTypeArrayCallBacks);
    BOOL v183 = v36;
    CFTypeID v37 = key[18];
    if (v37 != (uint64_t *)v156)
    {
      keya = (void *)kPSAccountId;
      v150 = (void *)kPSPrimaryDeviceId;
      v149 = (void *)kPSAccountFreeSlots;
      v148 = (void *)kPSMdn;
      std::string::size_type v146 = (void *)kPSIsoMcc;
      CFTypeID v147 = (void *)kPSMcc;
      v145 = (void *)kPSLabelID;
      std::string::size_type v38 = (const void *)kPSDeviceId;
      CFTypeID v39 = (const void *)kPSStatus;
      uint64_t v40 = (const void *)kPSDeviceHardware;
      while (1)
      {
        uint64_t v41 = v37 + 4;
        if (*(unsigned char *)(v37[7] + 80))
        {
          xpc_object_t v42 = *(NSObject **)(v35 + 40);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            if (*((char *)v37 + 55) < 0) {
              uint64_t v41 = (void *)*v41;
            }
            *(_DWORD *)int buf = 136315650;
            *(void *)&uint8_t buf[4] = "";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "";
            *(_WORD *)&unsigned char buf[22] = 2080;
            v192 = v41;
            int v43 = v42;
            int v44 = "#I %s%saccount %s is by invitation only";
            uint32_t v45 = 32;
            goto LABEL_79;
          }
          goto LABEL_192;
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v35 + 48));
        uint64_t v47 = ServiceMap;
        if (v48 < 0)
        {
          CFStringRef v49 = (unsigned __int8 *)(v48 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v50 = 5381;
          do
          {
            uint64_t v48 = v50;
            unsigned int v51 = *v49++;
            uint64_t v50 = (33 * v50) ^ v51;
          }
          while (v51);
        }
        std::mutex::lock(ServiceMap);
        *(void *)int buf = v48;
        CFStringRef v52 = sub_10004D37C(&v47[1].__m_.__sig, (unint64_t *)buf);
        if (v52)
        {
          BOOL v53 = (GestaltUtilityInterface *)v52[3];
          std::string::size_type v54 = (std::__shared_weak_count *)v52[4];
          if (v54)
          {
            atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v47);
            atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v54);
            char v55 = 0;
            goto LABEL_88;
          }
        }
        else
        {
          BOOL v53 = 0;
        }
        std::mutex::unlock(v47);
        std::string::size_type v54 = 0;
        char v55 = 1;
LABEL_88:
        int isWatch = GestaltUtilityInterface::isWatch(v53);
        if ((v55 & 1) == 0) {
          sub_10004D2C8(v54);
        }
        if (!isWatch)
        {
LABEL_112:
          CFMutableArrayRef v182 = 0;
          if (*((char *)v37 + 55) < 0)
          {
            sub_10004FC84(v174, (void *)v37[4], v37[5]);
          }
          else
          {
            *(_OWORD *)CFStringRef v174 = *(_OWORD *)v41;
            uint64_t v175 = v37[6];
          }
          if (SHIBYTE(v175) < 0)
          {
            sub_10004FC84(&__dst, v174[0], (unint64_t)v174[1]);
          }
          else
          {
            long long __dst = *(_OWORD *)v174;
            uint64_t v188 = v175;
          }
          uint64_t v35 = v155;
          v186 = 0;
          if (SHIBYTE(v188) < 0)
          {
            sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
          }
          else
          {
            *(_OWORD *)int buf = __dst;
            *(void *)&uint8_t buf[16] = v188;
          }
          CFComparisonResult v189 = 0;
          if (ctu::cf::convert_copy())
          {
            CFTypeID v65 = v186;
            v186 = v189;
            BOOL v190 = v65;
            sub_1000558F4(&v190);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          CFMutableArrayRef v182 = (CFMutableArrayRef)v186;
          v186 = 0;
          sub_1000558F4((const void **)&v186);
          if (SHIBYTE(v188) < 0) {
            operator delete((void *)__dst);
          }
          if (SHIBYTE(v175) < 0) {
            operator delete(v174[0]);
          }
          CFMutableDictionaryRef theDict = 0;
          std::string::size_type v66 = (_DWORD *)v37[7];
          LODWORD(v66) = (v66[8] - (v66[9] + v66[10])) & ~((v66[8] - (v66[9] + v66[10])) >> 31);
          *(void *)&long long __dst = 0;
          *(_DWORD *)int buf = v66;
          CFNumberRef v67 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
          if (v67)
          {
            uint64_t v68 = __dst;
            *(void *)&long long __dst = v67;
            *(void *)int buf = v68;
            sub_1000570E8((const void **)buf);
          }
          CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)__dst;
          *(void *)&long long __dst = 0;
          sub_1000570E8((const void **)&__dst);
          value = 0;
          CFMutableDictionaryRef v69 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v69)
          {
            CFArrayRef v70 = value;
            value = v69;
            *(void *)int buf = v70;
            sub_10005717C((const void **)buf);
          }
          CFDictionaryAddValue((CFMutableDictionaryRef)value, keya, v182);
          CFDictionaryAddValue((CFMutableDictionaryRef)value, v150, *(const void **)v37[7]);
          CFDictionaryAddValue((CFMutableDictionaryRef)value, v149, theDict);
          CFArrayRef v71 = (void *)v37[7];
          CFTypeID v72 = (const void *)v71[2];
          if (v72) {
            long long v73 = sub_1000810B8;
          }
          else {
            long long v73 = 0;
          }
          if (v73)
          {
            CFDictionaryAddValue((CFMutableDictionaryRef)value, v148, v72);
            CFArrayRef v71 = (void *)v37[7];
          }
          CFStringRef v74 = (const void *)v71[6];
          if (v74) {
            CFStringRef v75 = sub_1000810B8;
          }
          else {
            CFStringRef v75 = 0;
          }
          if (v75)
          {
            CFDictionaryAddValue((CFMutableDictionaryRef)value, v147, v74);
            CFArrayRef v71 = (void *)v37[7];
          }
          CFTypeID v76 = (const void *)v71[7];
          if (v76) {
            CFNumberRef v77 = sub_1000810B8;
          }
          else {
            CFNumberRef v77 = 0;
          }
          if (v77)
          {
            CFDictionaryAddValue((CFMutableDictionaryRef)value, v146, v76);
            CFArrayRef v71 = (void *)v37[7];
          }
          __int16 v78 = (const void *)v71[3];
          if (v78) {
            long long v79 = sub_1000810B8;
          }
          else {
            long long v79 = 0;
          }
          if (v79) {
            CFDictionaryAddValue((CFMutableDictionaryRef)value, v145, v78);
          }
          v173 = 0;
          CFMutableArrayRef v80 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (v80)
          {
            CFNumberRef v81 = v173;
            v173 = v80;
            *(void *)int buf = v81;
            sub_1000440D4((const void **)buf);
          }
          uint64_t v82 = v37[7];
          os_log_t v83 = *(void **)(v82 + 88);
          BOOL v84 = (void *)(v82 + 96);
          if (v83 != (void *)(v82 + 96))
          {
            do
            {
              CFMutableDictionaryRef v172 = 0;
              __int16 v85 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (v85)
              {
                CFMutableDictionaryRef v86 = v172;
                CFMutableDictionaryRef v172 = v85;
                *(void *)int buf = v86;
                sub_10005717C((const void **)buf);
              }
              int v87 = v172;
              if (*((char *)v83 + 55) < 0)
              {
                sub_10004FC84(v169, (void *)v83[4], v83[5]);
              }
              else
              {
                *(_OWORD *)v169 = *((_OWORD *)v83 + 2);
                uint64_t v170 = v83[6];
              }
              if (SHIBYTE(v170) < 0)
              {
                sub_10004FC84(&__dst, v169[0], (unint64_t)v169[1]);
              }
              else
              {
                long long __dst = *(_OWORD *)v169;
                uint64_t v188 = v170;
              }
              v186 = 0;
              if (SHIBYTE(v188) < 0)
              {
                sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
              }
              else
              {
                *(_OWORD *)int buf = __dst;
                *(void *)&uint8_t buf[16] = v188;
              }
              CFComparisonResult v189 = 0;
              if (ctu::cf::convert_copy())
              {
                unint64_t v88 = v186;
                v186 = v189;
                BOOL v190 = v88;
                sub_1000558F4(&v190);
              }
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              v171 = v186;
              v186 = 0;
              sub_1000558F4((const void **)&v186);
              if (SHIBYTE(v188) < 0) {
                operator delete((void *)__dst);
              }
              CFDictionaryAddValue(v87, v38, v171);
              sub_1000558F4((const void **)&v171);
              if (SHIBYTE(v170) < 0) {
                operator delete(v169[0]);
              }
              long long v89 = (const void *)v83[8];
              if (v89) {
                uint64_t v90 = sub_100084B4C;
              }
              else {
                uint64_t v90 = 0;
              }
              if (v90) {
                CFDictionaryAddValue(v172, v39, v89);
              }
              uint64_t v91 = (const void *)v83[9];
              if (v91) {
                CFAllocatorRef v92 = sub_1000810B8;
              }
              else {
                CFAllocatorRef v92 = 0;
              }
              if (v92) {
                CFDictionaryAddValue(v172, v40, v91);
              }
              CFArrayAppendValue((CFMutableArrayRef)v173, v172);
              sub_10005717C((const void **)&v172);
              unint64_t v93 = (void *)v83[1];
              if (v93)
              {
                do
                {
                  std::string::size_type v94 = v93;
                  unint64_t v93 = (void *)*v93;
                }
                while (v93);
              }
              else
              {
                do
                {
                  std::string::size_type v94 = (void *)v83[2];
                  BOOL v30 = *v94 == (void)v83;
                  os_log_t v83 = v94;
                }
                while (!v30);
              }
              os_log_t v83 = v94;
            }
            while (v94 != v84);
          }
          CFDictionaryAddValue((CFMutableDictionaryRef)value, v154, v173);
          CFArrayAppendValue(v183, value);
          sub_1000440D4((const void **)&v173);
          sub_10005717C((const void **)&value);
          sub_1000570E8((const void **)&theDict);
          sub_1000558F4((const void **)&v182);
          goto LABEL_192;
        }
        uint64_t v57 = v184[6];
        CFStringRef v58 = v184[7];
        if (v57 == v58)
        {
LABEL_111:
          if (v57 != v58) {
            goto LABEL_112;
          }
        }
        else
        {
          int v59 = *((char *)v37 + 55);
          if (v59 >= 0) {
            uint64_t v60 = *((unsigned __int8 *)v37 + 55);
          }
          else {
            uint64_t v60 = v37[5];
          }
          do
          {
            uint64_t v61 = *((unsigned __int8 *)v57 + 23);
            if ((v61 & 0x80u) == 0) {
              uint64_t v62 = *((unsigned __int8 *)v57 + 23);
            }
            else {
              uint64_t v62 = v57[1];
            }
            if (v62 == v60)
            {
              if (v59 >= 0) {
                CFStringRef v63 = v37 + 4;
              }
              else {
                CFStringRef v63 = (void *)*v41;
              }
              if ((v61 & 0x80) != 0)
              {
                if (!memcmp((const void *)*v57, v63, v57[1])) {
                  goto LABEL_111;
                }
              }
              else
              {
                if (!*((unsigned char *)v57 + 23)) {
                  goto LABEL_111;
                }
                uint64_t v64 = 0;
                while (*((unsigned __int8 *)v57 + v64) == *((unsigned __int8 *)v63 + v64))
                {
                  if (v61 == ++v64) {
                    goto LABEL_111;
                  }
                }
              }
            }
            v57 += 3;
          }
          while (v57 != v58);
        }
        uint64_t v35 = v155;
        long long v97 = *(NSObject **)(v155 + 40);
        if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          int v43 = v97;
          int v44 = "#I %s%sDo not show foreign accounts in cloud compilation for watch";
          uint32_t v45 = 22;
LABEL_79:
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v44, buf, v45);
        }
LABEL_192:
        long long v95 = (uint64_t *)v37[1];
        if (v95)
        {
          do
          {
            long long v96 = (uint64_t **)v95;
            long long v95 = (uint64_t *)*v95;
          }
          while (v95);
        }
        else
        {
          do
          {
            long long v96 = (uint64_t **)v37[2];
            BOOL v30 = *v96 == v37;
            CFTypeID v37 = (uint64_t *)v96;
          }
          while (!v30);
        }
        CFTypeID v37 = (uint64_t *)v96;
        if (v96 == v156)
        {
          uint64_t v34 = v144;
          __int16 v33 = *v144;
          CFMutableArrayRef v36 = v183;
          break;
        }
      }
    }
    CFDictionaryAddValue(v33, kPSAccountList, v36);
    uint64_t v99 = (const void **)capabilities::ct::supportsThumperSourcing(v98);
    if (v99)
    {
      CFMutableArrayRef v182 = 0;
      CFDictionaryRef v100 = v184;
      CFMutableArrayRef v101 = CFArrayCreateMutable(0, 0xAAAAAAAAAAAAAAABLL * (v100[10] - v100[9]), &kCFTypeArrayCallBacks);
      CFMutableArrayRef v182 = v101;
      uint64_t v102 = v100[9];
      long long v103 = v100[10];
      if (v102 != v103)
      {
        char v104 = (void *)(v155 + 80);
        do
        {
          CFDictionaryRef v105 = *(void **)(v155 + 72);
          v165[0] = _NSConcreteStackBlock;
          v165[1] = 0x40000000;
          v166 = sub_100805A3C;
          v167 = &unk_101A0C528;
          uint64_t v168 = v102;
          if (v105 != v104)
          {
            while (1)
            {
              *(_DWORD *)int buf = *((_DWORD *)v105 + 8);
              uint64_t v106 = v105[6];
              *(void *)&uint8_t buf[8] = v105[5];
              *(void *)&uint8_t buf[16] = v106;
              if (v106) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v106 + 16), 1uLL, memory_order_relaxed);
              }
              char v107 = ((uint64_t (*)(void *, uint8_t *, CFMutableArrayRef))v166)(v165, buf, v101);
              if (*(void *)&buf[16]) {
                std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[16]);
              }
              if (v107) {
                break;
              }
              CFTypeID v108 = (void *)v105[1];
              if (v108)
              {
                do
                {
                  CFIndex v109 = v108;
                  CFTypeID v108 = (void *)*v108;
                }
                while (v108);
              }
              else
              {
                do
                {
                  CFIndex v109 = (void *)v105[2];
                  BOOL v30 = *v109 == (void)v105;
                  CFDictionaryRef v105 = v109;
                }
                while (!v30);
              }
              CFDictionaryRef v105 = v109;
              if (v109 == v104) {
                goto LABEL_236;
              }
            }
            if (v105 != v104)
            {
              CFIndex v110 = v182;
              if (*((char *)v102 + 23) < 0)
              {
                sub_10004FC84(v163, (void *)*v102, v102[1]);
              }
              else
              {
                long long v111 = *(_OWORD *)v102;
                uint64_t v164 = v102[2];
                *(_OWORD *)v163 = v111;
              }
              if (SHIBYTE(v164) < 0)
              {
                sub_10004FC84(&__dst, v163[0], (unint64_t)v163[1]);
              }
              else
              {
                long long __dst = *(_OWORD *)v163;
                uint64_t v188 = v164;
              }
              v186 = 0;
              if (SHIBYTE(v188) < 0)
              {
                sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
              }
              else
              {
                *(_OWORD *)int buf = __dst;
                *(void *)&uint8_t buf[16] = v188;
              }
              CFComparisonResult v189 = 0;
              if (ctu::cf::convert_copy())
              {
                CFStringRef v112 = v186;
                v186 = v189;
                BOOL v190 = v112;
                sub_1000558F4(&v190);
              }
              if ((char)buf[23] < 0) {
                operator delete(*(void **)buf);
              }
              CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v186;
              v186 = 0;
              sub_1000558F4((const void **)&v186);
              if (SHIBYTE(v188) < 0) {
                operator delete((void *)__dst);
              }
              CFArrayAppendValue(v110, theDict);
              sub_1000558F4((const void **)&theDict);
              if (SHIBYTE(v164) < 0) {
                operator delete(v163[0]);
              }
            }
          }
LABEL_236:
          v102 += 3;
        }
        while (v102 != v103);
        CFMutableArrayRef v101 = v182;
        uint64_t v34 = v144;
      }
      CFDictionaryAddValue(v33, kPSOwnAccounts, v101);
      CFTypeID v113 = v100[9];
      uint64_t v35 = v155;
      if (v100[10] != v113)
      {
        if (*((char *)v113 + 23) < 0)
        {
          sub_10004FC84(v161, (void *)*v113, v113[1]);
        }
        else
        {
          long long v114 = *(_OWORD *)v113;
          uint64_t v162 = v113[2];
          *(_OWORD *)v161 = v114;
        }
        if (SHIBYTE(v162) < 0)
        {
          sub_10004FC84(&__dst, v161[0], (unint64_t)v161[1]);
        }
        else
        {
          long long __dst = *(_OWORD *)v161;
          uint64_t v188 = v162;
        }
        v186 = 0;
        if (SHIBYTE(v188) < 0)
        {
          sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          *(_OWORD *)int buf = __dst;
          *(void *)&uint8_t buf[16] = v188;
        }
        CFComparisonResult v189 = 0;
        if (ctu::cf::convert_copy())
        {
          char v115 = v186;
          v186 = v189;
          BOOL v190 = v115;
          sub_1000558F4(&v190);
        }
        CFArrayRef v116 = (const void *)kPSAccountId;
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v186;
        v186 = 0;
        sub_1000558F4((const void **)&v186);
        if (SHIBYTE(v188) < 0) {
          operator delete((void *)__dst);
        }
        CFDictionaryAddValue(v33, v116, theDict);
        sub_1000558F4((const void **)&theDict);
        if (SHIBYTE(v162) < 0) {
          operator delete(v161[0]);
        }
      }
      uint64_t v99 = sub_1000440D4((const void **)&v182);
    }
    if (capabilities::ct::supportsThumperService((capabilities::ct *)v99))
    {
      CFMutableArrayRef v182 = 0;
      CFArrayRef v117 = v184;
      CFMutableArrayRef v118 = CFArrayCreateMutable(0, 0xAAAAAAAAAAAAAAABLL * (v117[7] - v117[6]), &kCFTypeArrayCallBacks);
      CFMutableArrayRef v182 = v118;
      CFIndex v119 = v117[6];
      CFIndex v120 = v117[7];
      if (v119 != v120)
      {
        do
        {
          CFStringRef v121 = v182;
          if (*((char *)v119 + 23) < 0)
          {
            sub_10004FC84(v159, (void *)*v119, v119[1]);
          }
          else
          {
            long long v122 = *(_OWORD *)v119;
            uint64_t v160 = v119[2];
            *(_OWORD *)v159 = v122;
          }
          if (SHIBYTE(v160) < 0)
          {
            sub_10004FC84(&__dst, v159[0], (unint64_t)v159[1]);
          }
          else
          {
            long long __dst = *(_OWORD *)v159;
            uint64_t v188 = v160;
          }
          v186 = 0;
          if (SHIBYTE(v188) < 0)
          {
            sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
          }
          else
          {
            *(_OWORD *)int buf = __dst;
            *(void *)&uint8_t buf[16] = v188;
          }
          CFComparisonResult v189 = 0;
          if (ctu::cf::convert_copy())
          {
            CFTypeID v123 = v186;
            v186 = v189;
            BOOL v190 = v123;
            sub_1000558F4(&v190);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v186;
          v186 = 0;
          sub_1000558F4((const void **)&v186);
          if (SHIBYTE(v188) < 0) {
            operator delete((void *)__dst);
          }
          CFArrayAppendValue(v121, theDict);
          sub_1000558F4((const void **)&theDict);
          if (SHIBYTE(v160) < 0) {
            operator delete(v159[0]);
          }
          v119 += 3;
        }
        while (v119 != v120);
        CFMutableArrayRef v118 = v182;
      }
      CFStringRef v124 = *v34;
      CFDictionaryAddValue(*v34, kPSPairedAccounts, v118);
      if (v117[7] != v117[6])
      {
        CFMutableDictionaryRef theDict = 0;
        getAssociatedID(&theDict);
        if (theDict) {
          v125 = sub_1000810B8;
        }
        else {
          v125 = 0;
        }
        if (v125)
        {
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          uint64_t v188 = *(void *)&buf[16];
          long long __dst = *(_OWORD *)buf;
          v126 = v117[6];
          CFTypeID v127 = v117[7];
          uint64_t v128 = HIBYTE(*(void *)&buf[16]);
          if (v126 != v127)
          {
            if ((buf[23] & 0x80u) == 0) {
              uint64_t v129 = HIBYTE(*(void *)&buf[16]);
            }
            else {
              uint64_t v129 = *((void *)&__dst + 1);
            }
            if ((buf[23] & 0x80u) == 0) {
              p_dst = &__dst;
            }
            else {
              p_dst = (long long *)__dst;
            }
            CFIndex v131 = (const void *)kPSAccountId;
            while (1)
            {
              uint64_t v132 = *((unsigned __int8 *)v126 + 23);
              if ((v132 & 0x80u) == 0) {
                uint64_t v133 = *((unsigned __int8 *)v126 + 23);
              }
              else {
                uint64_t v133 = v126[1];
              }
              if (v133 != v129) {
                goto LABEL_303;
              }
              if ((v132 & 0x80) == 0) {
                break;
              }
              if (!memcmp((const void *)*v126, p_dst, v126[1])) {
                goto LABEL_302;
              }
LABEL_303:
              v126 += 3;
              if (v126 == v127) {
                goto LABEL_304;
              }
            }
            if (*((unsigned char *)v126 + 23))
            {
              uint64_t v134 = 0;
              while (*((unsigned __int8 *)v126 + v134) == *((unsigned __int8 *)p_dst + v134))
              {
                if (v132 == ++v134) {
                  goto LABEL_302;
                }
              }
              goto LABEL_303;
            }
LABEL_302:
            CFDictionaryAddValue(v124, v131, theDict);
            goto LABEL_303;
          }
LABEL_304:
          if ((v128 & 0x80) != 0) {
            operator delete((void *)__dst);
          }
          uint64_t v34 = v144;
          uint64_t v35 = v155;
        }
        else
        {
          CFTypeID v135 = v117[6];
          if (*((char *)v135 + 23) < 0)
          {
            sub_10004FC84(v157, (void *)*v135, v135[1]);
          }
          else
          {
            long long v136 = *(_OWORD *)v135;
            uint64_t v158 = v135[2];
            *(_OWORD *)uint64_t v157 = v136;
          }
          if (SHIBYTE(v158) < 0)
          {
            sub_10004FC84(&__dst, v157[0], (unint64_t)v157[1]);
          }
          else
          {
            long long __dst = *(_OWORD *)v157;
            uint64_t v188 = v158;
          }
          v186 = 0;
          if (SHIBYTE(v188) < 0)
          {
            sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
          }
          else
          {
            *(_OWORD *)int buf = __dst;
            *(void *)&uint8_t buf[16] = v188;
          }
          CFComparisonResult v189 = 0;
          if (ctu::cf::convert_copy())
          {
            CFStringRef v137 = v186;
            v186 = v189;
            BOOL v190 = v137;
            sub_1000558F4(&v190);
          }
          CFStringRef v138 = (const void *)kPSAccountId;
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          value = v186;
          v186 = 0;
          sub_1000558F4((const void **)&v186);
          if (SHIBYTE(v188) < 0) {
            operator delete((void *)__dst);
          }
          CFDictionaryAddValue(v124, v138, value);
          sub_1000558F4((const void **)&value);
          if (SHIBYTE(v158) < 0) {
            operator delete(v157[0]);
          }
        }
        sub_1000558F4((const void **)&theDict);
      }
      sub_1000440D4((const void **)&v182);
    }
    if (sub_1007FA824((void *)v35))
    {
      CFTypeID v139 = *v34;
      CFDictionaryRef v140 = (const void *)sub_1007FA824((void *)v35);
      CFDictionaryAddValue(v139, kPSDeviceId, v140);
    }
    CFBooleanRef v141 = v184;
    CFBooleanRef v142 = v185;
    if (v185) {
      atomic_fetch_add_explicit(&v185->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v143 = *(std::__shared_weak_count **)(v35 + 216);
    *(void *)(v35 + 208) = v141;
    *(void *)(v35 + 216) = v142;
    if (v143) {
      sub_10004D2C8(v143);
    }
    sub_1000440D4((const void **)&v183);
    if (v142) {
      sub_10004D2C8(v142);
    }
  }
  else
  {
    *a2 = 0;
  }
}

void sub_100804568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void **a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,const void *a63)
{
  sub_1000558F4((const void **)(v63 - 216));
  if (*(char *)(v63 - 185) < 0) {
    operator delete(*(void **)(v63 - 208));
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a63);
  sub_1000440D4((const void **)(v63 - 248));
  sub_1000440D4((const void **)(v63 - 240));
  sub_10005717C(a11);
  CFTypeID v65 = *(std::__shared_weak_count **)(v63 - 224);
  if (v65) {
    sub_10004D2C8(v65);
  }
  _Unwind_Resume(a1);
}

void sub_1008049B4(uint64_t a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  CFComparisonResult v4 = (void *)*a2;
  uint64_t v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4[10] - v4[9]) >> 3);
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2048;
      *(void *)uint64_t v91 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%s|  %zu own account(s)", buf, 0x20u);
      CFComparisonResult v4 = (void *)*v2;
    }
    uint64_t v8 = (uint64_t *)v4[9];
    uint64_t v9 = (uint64_t *)v4[10];
    CFTypeID v72 = (void **)v2;
    if (v8 != v9)
    {
      do
      {
        int v10 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v11 = v8;
          if (*((char *)v8 + 23) < 0) {
            CFIndex v11 = (uint64_t *)*v8;
          }
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)uint64_t v91 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s|    %s", buf, 0x20u);
        }
        v8 += 3;
      }
      while (v8 != v9);
      uint64_t v2 = v72;
      CFComparisonResult v4 = *v72;
    }
    uint64_t v12 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4[7] - v4[6]) >> 3);
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2048;
      *(void *)uint64_t v91 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s|  %zu paired account(s)", buf, 0x20u);
      CFComparisonResult v4 = (void *)*v2;
    }
    int v14 = (uint64_t *)v4[6];
    uint64_t v15 = (uint64_t *)v4[7];
    if (v14 != v15)
    {
      do
      {
        CFComparisonResult v16 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          CFTypeID v17 = v14;
          if (*((char *)v14 + 23) < 0) {
            CFTypeID v17 = (uint64_t *)*v14;
          }
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)uint64_t v91 = v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s|    %s", buf, 0x20u);
        }
        v14 += 3;
      }
      while (v14 != v15);
      uint64_t v2 = v72;
      CFComparisonResult v4 = *v72;
    }
    char v18 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = v4[20];
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2048;
      *(void *)uint64_t v91 = v19;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%s|  detected %zu account(s) in iCloud", buf, 0x20u);
      CFComparisonResult v4 = (void *)*v2;
    }
    __int16 v20 = (void *)v4[18];
    long long v73 = v4 + 19;
    if (v20 != v4 + 19)
    {
      uint64_t v74 = v3;
      do
      {
        CFNumberRef v21 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          CFDictionaryRef v22 = v20 + 4;
          if (*((char *)v20 + 55) < 0) {
            CFDictionaryRef v22 = (void *)*v22;
          }
          long long v88 = 0uLL;
          uint64_t v89 = 0;
          ctu::cf::assign();
          long long v86 = v88;
          uint64_t v87 = v89;
          if (v89 >= 0) {
            std::string::size_type v23 = &v86;
          }
          else {
            std::string::size_type v23 = (long long *)v86;
          }
          long long v88 = 0uLL;
          uint64_t v89 = 0;
          ctu::cf::assign();
          *(_OWORD *)BOOL v84 = v88;
          uint64_t v85 = v89;
          if (v89 >= 0) {
            CFDictionaryRef v24 = v84;
          }
          else {
            CFDictionaryRef v24 = (void **)v84[0];
          }
          long long v88 = 0uLL;
          uint64_t v89 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v88;
          uint64_t v83 = v89;
          uint64_t v25 = v20[7];
          int v27 = *(_DWORD *)(v25 + 72);
          int v26 = *(_DWORD *)(v25 + 76);
          if (v89 >= 0) {
            long long v28 = __p;
          }
          else {
            long long v28 = (void **)__p[0];
          }
          if (*(unsigned char *)(v25 + 9)) {
            char v29 = (const char *)asStringBool(*(unsigned char *)(v25 + 8));
          }
          else {
            char v29 = "unknown";
          }
          *(_DWORD *)int buf = 136317186;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)uint64_t v91 = v22;
          *(_WORD *)&v91[8] = 2080;
          CFAllocatorRef v92 = v23;
          __int16 v93 = 2080;
          std::string::size_type v94 = v24;
          __int16 v95 = 2080;
          long long v96 = v28;
          __int16 v97 = 1024;
          int v98 = v27;
          __int16 v99 = 1024;
          int v100 = v26;
          __int16 v101 = 2080;
          uint64_t v102 = v29;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|  > %s: mdn:%s mcc:%s iso:%s schema:%u.%u trusted:%s", buf, 0x54u);
          if (SHIBYTE(v83) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v3 = v74;
          if (SHIBYTE(v85) < 0) {
            operator delete(v84[0]);
          }
          if (SHIBYTE(v87) < 0) {
            operator delete((void *)v86);
          }
          CFNumberRef v21 = *(NSObject **)(v74 + 40);
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          long long v88 = *(_OWORD *)buf;
          uint64_t v89 = *(void *)&buf[16];
          BOOL v30 = *(long long **)buf;
          if ((buf[23] & 0x80u) == 0) {
            BOOL v30 = &v88;
          }
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)uint64_t v91 = v30;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|      primary: %s", buf, 0x20u);
          if (SHIBYTE(v89) < 0) {
            operator delete((void *)v88);
          }
          CFNumberRef v21 = *(NSObject **)(v3 + 40);
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, sizeof(buf));
          ctu::cf::assign();
          long long v88 = *(_OWORD *)buf;
          uint64_t v89 = *(void *)&buf[16];
          CFStringRef v31 = *(long long **)buf;
          if ((buf[23] & 0x80u) == 0) {
            CFStringRef v31 = &v88;
          }
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)uint64_t v91 = v31;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|      labelId: %s", buf, 0x20u);
          if (SHIBYTE(v89) < 0) {
            operator delete((void *)v88);
          }
          CFNumberRef v21 = *(NSObject **)(v3 + 40);
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v32 = v20[7];
          int v33 = *(_DWORD *)(v32 + 32);
          LODWORD(v32) = *(_DWORD *)(v32 + 36);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)uint64_t v91 = v33;
          *(_WORD *)&v91[4] = 1024;
          *(_DWORD *)&v91[6] = v32;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|      slots: %d (used: %d)", buf, 0x22u);
          CFNumberRef v21 = *(NSObject **)(v3 + 40);
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          int v34 = *(_DWORD *)(v20[7] + 40);
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)uint64_t v91 = v34;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|      foreign devices: %d", buf, 0x1Cu);
          CFNumberRef v21 = *(NSObject **)(v3 + 40);
        }
        uint64_t v35 = v20[7];
        if (*(unsigned char *)(v35 + 80) && os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|      account hidden for device", buf, 0x16u);
          CFNumberRef v21 = *(NSObject **)(v3 + 40);
          uint64_t v35 = v20[7];
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v36 = *(void *)(v35 + 104);
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2048;
          *(void *)uint64_t v91 = v36;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s|      associated devices: %zu", buf, 0x20u);
          uint64_t v35 = v20[7];
        }
        CFTypeID v37 = *(void **)(v35 + 88);
        std::string::size_type v38 = (void *)(v35 + 96);
        if (v37 != (void *)(v35 + 96))
        {
          do
          {
            CFTypeID v39 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
            {
              long long v88 = 0uLL;
              uint64_t v89 = 0;
              ctu::cf::assign();
              uint64_t v40 = (long long *)(v37 + 4);
              long long v86 = v88;
              uint64_t v87 = v89;
              if (v89 >= 0) {
                uint64_t v41 = &v86;
              }
              else {
                uint64_t v41 = (long long *)v86;
              }
              if (*((char *)v37 + 55) < 0) {
                uint64_t v40 = *(long long **)v40;
              }
              if (v37[9]) {
                xpc_object_t v42 = sub_1000810B8;
              }
              else {
                xpc_object_t v42 = 0;
              }
              if (v42)
              {
                long long v88 = 0uLL;
                uint64_t v89 = 0;
                ctu::cf::assign();
                *(_OWORD *)CFMutableArrayRef v80 = v88;
                uint64_t v81 = v89;
                if (v89 >= 0) {
                  int v43 = v80;
                }
                else {
                  int v43 = (void **)v80[0];
                }
              }
              else
              {
                int v43 = (void **)"unknown";
              }
              CFBooleanRef v44 = (const __CFBoolean *)v37[8];
              if (v44) {
                uint32_t v45 = sub_100084B4C;
              }
              else {
                uint32_t v45 = 0;
              }
              if (v45)
              {
                int Value = CFBooleanGetValue(v44);
                uint64_t v47 = "on";
                if (!Value) {
                  uint64_t v47 = "off";
                }
              }
              else
              {
                uint64_t v47 = "unknown";
              }
              *(_DWORD *)int buf = 136316418;
              *(void *)&uint8_t buf[4] = "";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "";
              *(_WORD *)&unsigned char buf[22] = 2080;
              *(void *)uint64_t v91 = v41;
              *(_WORD *)&v91[8] = 2080;
              CFAllocatorRef v92 = v40;
              __int16 v93 = 2080;
              std::string::size_type v94 = v43;
              __int16 v95 = 2080;
              long long v96 = (void *)v47;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I %s%s|        %s %s, hw:%s, status:%s", buf, 0x3Eu);
              uint64_t v3 = v74;
              if (v42 && SHIBYTE(v81) < 0) {
                operator delete(v80[0]);
              }
              if (SHIBYTE(v87) < 0) {
                operator delete((void *)v86);
              }
            }
            uint64_t v48 = (void *)v37[1];
            if (v48)
            {
              do
              {
                CFStringRef v49 = v48;
                uint64_t v48 = (void *)*v48;
              }
              while (v48);
            }
            else
            {
              do
              {
                CFStringRef v49 = (void *)v37[2];
                BOOL v50 = *v49 == (void)v37;
                CFTypeID v37 = v49;
              }
              while (!v50);
            }
            CFTypeID v37 = v49;
          }
          while (v49 != v38);
        }
        unsigned int v51 = (void *)v20[1];
        if (v51)
        {
          do
          {
            CFStringRef v52 = v51;
            unsigned int v51 = (void *)*v51;
          }
          while (v51);
        }
        else
        {
          do
          {
            CFStringRef v52 = (void *)v20[2];
            BOOL v50 = *v52 == (void)v20;
            __int16 v20 = v52;
          }
          while (!v50);
        }
        __int16 v20 = v52;
      }
      while (v52 != v73);
      CFComparisonResult v4 = *v72;
    }
    BOOL v53 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v54 = v4[5];
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2048;
      *(void *)uint64_t v91 = v54;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I %s%s|  %zu orphan dev records found", buf, 0x20u);
      CFComparisonResult v4 = *v72;
    }
    char v55 = (void *)v4[3];
    if (v55 != v4 + 4)
    {
      do
      {
        __int16 v56 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v57 = v55 + 4;
          if (*((char *)v55 + 55) < 0) {
            uint64_t v57 = (void *)*v57;
          }
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)uint64_t v91 = v57;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I %s%s|    %s", buf, 0x20u);
        }
        CFStringRef v58 = (void *)v55[1];
        if (v58)
        {
          do
          {
            int v59 = v58;
            CFStringRef v58 = (void *)*v58;
          }
          while (v58);
        }
        else
        {
          do
          {
            int v59 = (void *)v55[2];
            BOOL v50 = *v59 == (void)v55;
            char v55 = v59;
          }
          while (!v50);
        }
        char v55 = v59;
      }
      while (v59 != v4 + 4);
    }
    uint64_t v60 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I %s%s| DEV SECTIONS:", buf, 0x16u);
    }
    uint64_t v61 = *v72;
    uint64_t v62 = (uint64_t)(*v72 + 1);
    uint64_t v63 = (void *)**v72;
    if (v63 != (void *)v62)
    {
      do
      {
        if (*((char *)v63 + 55) < 0)
        {
          sub_10004FC84(__dst, (void *)v63[4], v63[5]);
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v63 + 2);
          uint64_t v78 = v63[6];
        }
        if (SHIBYTE(v78) < 0)
        {
          sub_10004FC84(&v88, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          long long v88 = *(_OWORD *)__dst;
          uint64_t v89 = v78;
        }
        __p[0] = 0;
        if (SHIBYTE(v89) < 0)
        {
          sub_10004FC84(buf, (void *)v88, *((unint64_t *)&v88 + 1));
        }
        else
        {
          *(_OWORD *)int buf = v88;
          *(void *)&uint8_t buf[16] = v89;
        }
        v84[0] = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v64 = __p[0];
          __p[0] = v84[0];
          *(void *)&long long v86 = v64;
          sub_1000558F4((const void **)&v86);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        long long v79 = __p[0];
        __p[0] = 0;
        sub_1000558F4((const void **)__p);
        if (SHIBYTE(v89) < 0) {
          operator delete((void *)v88);
        }
        sub_100805DD0(v3, (uint64_t)v79);
        sub_1000558F4((const void **)&v79);
        if (SHIBYTE(v78) < 0) {
          operator delete(__dst[0]);
        }
        CFTypeID v65 = (void *)v63[1];
        if (v65)
        {
          do
          {
            std::string::size_type v66 = v65;
            CFTypeID v65 = (void *)*v65;
          }
          while (v65);
        }
        else
        {
          do
          {
            std::string::size_type v66 = (void *)v63[2];
            BOOL v50 = *v66 == (void)v63;
            uint64_t v63 = v66;
          }
          while (!v50);
        }
        uint64_t v63 = v66;
      }
      while (v66 != (void *)v62);
      uint64_t v61 = *v72;
    }
    CFNumberRef v67 = (void *)v61[3];
    uint64_t v68 = v61 + 4;
    if (v67 != v61 + 4)
    {
      do
      {
        if (*((char *)v67 + 55) < 0)
        {
          sub_10004FC84(v75, (void *)v67[4], v67[5]);
        }
        else
        {
          *(_OWORD *)CFStringRef v75 = *((_OWORD *)v67 + 2);
          uint64_t v76 = v67[6];
        }
        if (SHIBYTE(v76) < 0)
        {
          sub_10004FC84(&v88, v75[0], (unint64_t)v75[1]);
        }
        else
        {
          long long v88 = *(_OWORD *)v75;
          uint64_t v89 = v76;
        }
        __p[0] = 0;
        if (SHIBYTE(v89) < 0)
        {
          sub_10004FC84(buf, (void *)v88, *((unint64_t *)&v88 + 1));
        }
        else
        {
          *(_OWORD *)int buf = v88;
          *(void *)&uint8_t buf[16] = v89;
        }
        v84[0] = 0;
        if (ctu::cf::convert_copy())
        {
          CFMutableDictionaryRef v69 = __p[0];
          __p[0] = v84[0];
          *(void *)&long long v86 = v69;
          sub_1000558F4((const void **)&v86);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        long long v79 = __p[0];
        __p[0] = 0;
        sub_1000558F4((const void **)__p);
        if (SHIBYTE(v89) < 0) {
          operator delete((void *)v88);
        }
        sub_100805DD0(v3, (uint64_t)v79);
        sub_1000558F4((const void **)&v79);
        if (SHIBYTE(v76) < 0) {
          operator delete(v75[0]);
        }
        CFArrayRef v70 = (void *)v67[1];
        if (v70)
        {
          do
          {
            CFArrayRef v71 = v70;
            CFArrayRef v70 = (void *)*v70;
          }
          while (v70);
        }
        else
        {
          do
          {
            CFArrayRef v71 = (void *)v67[2];
            BOOL v50 = *v71 == (void)v67;
            CFNumberRef v67 = v71;
          }
          while (!v50);
        }
        CFNumberRef v67 = v71;
      }
      while (v71 != v68);
    }
  }
  else if (v6)
  {
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sCloud analysis not ready yet", buf, 0x16u);
  }
}

void sub_1008058C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  if (*(char *)(v61 - 233) < 0) {
    operator delete(*(void **)(v61 - 256));
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100805A3C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = *(void *)(a2 + 8);
      if (v7)
      {
        (*(void (**)(void **__return_ptr))(*(void *)v7 + 16))(&__s1);
        uint64_t v8 = *(unsigned __int8 ***)(a1 + 32);
        if ((v26 & 0x80u) == 0) {
          size_t v9 = v26;
        }
        else {
          size_t v9 = __n;
        }
        int v10 = (unsigned __int8 *)*((unsigned __int8 *)v8 + 23);
        int v11 = (char)v10;
        if ((char)v10 < 0) {
          int v10 = v8[1];
        }
        if ((unsigned __int8 *)v9 == v10)
        {
          if (v11 >= 0) {
            uint64_t v12 = *(unsigned __int8 **)(a1 + 32);
          }
          else {
            uint64_t v12 = *v8;
          }
          if ((v26 & 0x80) != 0)
          {
            CFDictionaryRef v22 = __s1;
            BOOL v21 = memcmp(__s1, v12, __n) == 0;
            goto LABEL_28;
          }
          if (!v26)
          {
            BOOL v21 = 1;
            goto LABEL_30;
          }
          uint64_t v13 = v26 - 1;
          p_s1 = &__s1;
          do
          {
            int v16 = *(unsigned __int8 *)p_s1;
            p_s1 = (void **)((char *)p_s1 + 1);
            int v15 = v16;
            int v18 = *v12++;
            int v17 = v18;
            BOOL v20 = v13-- != 0;
            BOOL v21 = v15 == v17;
          }
          while (v15 == v17 && v20);
        }
        else
        {
          BOOL v21 = 0;
        }
        if ((v26 & 0x80) != 0)
        {
          CFDictionaryRef v22 = __s1;
LABEL_28:
          operator delete(v22);
        }
      }
      else
      {
        BOOL v21 = 0;
      }
LABEL_30:
      sub_10004D2C8(v6);
      return v21;
    }
  }
  return 0;
}

void sub_100805B78(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100805B8C(void *a1)
{
  uint64_t v2 = a1[18];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  sub_1007FA5A4((uint64_t)a1);
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*a1 + 88);

  return v3(a1, 1);
}

uint64_t sub_100805C1C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 96);
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    CFComparisonResult v4 = "Secondary";
    if (!v3) {
      CFComparisonResult v4 = "Primary";
    }
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v9 = *(void *)&buf[16];
    uint64_t v5 = __p;
    if ((buf[23] & 0x80u) != 0) {
      uint64_t v5 = *(void ***)buf;
    }
    *(_DWORD *)int buf = 136315906;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 2080;
    int v11 = v4;
    __int16 v12 = 2080;
    uint64_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fDevType: %s, fDeviceId: %s", buf, 0x2Au);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1008049B4(a1, (void *)(a1 + 208));
  uint64_t v6 = *(void *)(a1 + 144);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 80))(v6);
  }
  uint64_t result = *(void *)(a1 + 152);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
  }
  return result;
}

void sub_100805DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100805DD0(uint64_t a1, uint64_t a2)
{
  CFStringRef key = 0;
  sub_1007FD308((void *)a1, a2, (const void **)&key);
  CFDictionaryRef theDict = 0;
  sub_1003A9CA0(buf);
  *(void *)&long long v34 = sub_1003A9B04(*(uint64_t *)buf, key, 0);
  sub_100084068(&theDict, (CFTypeRef *)&v34);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  CFDictionaryRef v4 = theDict;
  if (theDict) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      long long v34 = 0uLL;
      uint64_t v35 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v34;
      uint64_t v31 = v35;
      uint64_t v7 = (void **)v34;
      if (v35 >= 0) {
        uint64_t v7 = __p;
      }
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      __int16 v37 = 2080;
      std::string::size_type v38 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%smodern %s {", buf, 0x20u);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
      CFDictionaryRef v4 = theDict;
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v4, @"accounts");
    CFDictionaryRef v9 = Value;
    if (Value)
    {
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFDictionaryGetTypeID())
      {
        int v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          long long v34 = 0uLL;
          uint64_t v35 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v34;
          uint64_t v31 = v35;
          __int16 v12 = (void **)v34;
          if (v35 >= 0) {
            __int16 v12 = __p;
          }
          *(_DWORD *)int buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          __int16 v37 = 2080;
          std::string::size_type v38 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s\t\"%s\":", buf, 0x20u);
          if (SHIBYTE(v31) < 0) {
            operator delete(__p[0]);
          }
        }
        CFIndex Count = CFDictionaryGetCount(v9);
        if (Count)
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v31 = 0;
          sub_10019E8F0(__p, Count);
          CFDictionaryGetKeysAndValues(v9, (const void **)__p[0], 0);
          int v14 = (char *)__p[0];
          int v15 = (char *)__p[1];
          if (__p[0] != __p[1])
          {
            do
            {
              int v16 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
              {
                long long v34 = 0uLL;
                uint64_t v35 = 0;
                ctu::cf::assign();
                *(_OWORD *)long long v28 = v34;
                uint64_t v29 = v35;
                int v17 = (void **)v34;
                if (v35 >= 0) {
                  int v17 = v28;
                }
                *(_DWORD *)int buf = 136315650;
                *(void *)&uint8_t buf[4] = "";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = "";
                __int16 v37 = 2080;
                std::string::size_type v38 = v17;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%s\t\t%s", buf, 0x20u);
                if (SHIBYTE(v29) < 0) {
                  operator delete(v28[0]);
                }
              }
              v14 += 8;
            }
            while (v14 != v15);
            int v14 = (char *)__p[0];
          }
          if (v14)
          {
            __p[1] = v14;
            operator delete(v14);
          }
        }
      }
    }
    int v18 = (unsigned int *)CFDictionaryGetValue(theDict, @"ts");
    *(_DWORD *)int buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v18, v19);
    int v20 = *(_DWORD *)buf;
    BOOL v21 = *(NSObject **)(a1 + 40);
    if (*(_DWORD *)buf && os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      long long v34 = 0uLL;
      uint64_t v35 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v34;
      uint64_t v31 = v35;
      CFDictionaryRef v22 = (void **)v34;
      if (v35 >= 0) {
        CFDictionaryRef v22 = __p;
      }
      *(_DWORD *)int buf = 136315906;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      __int16 v37 = 2080;
      std::string::size_type v38 = v22;
      __int16 v39 = 1024;
      int v40 = v20;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s\t\"%s\": %u", buf, 0x26u);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
      BOOL v21 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s}", buf, 0x16u);
    }
  }
  sub_1007FD430((void *)a1, a2, (const void **)&v34);
  *(void *)int buf = key;
  CFStringRef key = (CFStringRef)v34;
  *(void *)&long long v34 = 0;
  sub_1000558F4((const void **)buf);
  sub_1000558F4((const void **)&v34);
  sub_1003A9CA0(buf);
  __p[0] = (void *)sub_1003A9B04(*(uint64_t *)buf, key, 1);
  *(void *)&long long v34 = 0;
  sub_100084068(&v34, (CFTypeRef *)__p);
  CFDictionaryRef v23 = theDict;
  CFDictionaryRef theDict = (CFDictionaryRef)v34;
  *(void *)&long long v34 = v23;
  sub_100057D78((const void **)&v34);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (theDict) {
    CFDictionaryRef v24 = sub_100080778;
  }
  else {
    CFDictionaryRef v24 = 0;
  }
  if (v24)
  {
    uint64_t v25 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      long long v34 = 0uLL;
      uint64_t v35 = 0;
      ctu::cf::assign();
      *(_OWORD *)std::string __p = v34;
      uint64_t v31 = v35;
      unsigned __int8 v26 = __p;
      if (v35 < 0) {
        unsigned __int8 v26 = (void **)v34;
      }
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      __int16 v37 = 2080;
      std::string::size_type v38 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%slegacy %s", buf, 0x20u);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[0]);
      }
    }
    *(void *)int buf = off_101A0C828;
    *(void *)&uint8_t buf[8] = a1;
    std::string::size_type v38 = (void **)buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
  }
  sub_100057D78((const void **)&theDict);
  return sub_1000558F4((const void **)&key);
}

void sub_100806434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a18);
  sub_1000558F4(&a19);
  _Unwind_Resume(a1);
}

void sub_1008064D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    sub_10004D2C8(a24);
  }
  JUMPOUT(0x1008064BCLL);
}

void sub_1008064E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    sub_10004D2C8(a24);
  }
  JUMPOUT(0x1008064C4);
}

void sub_1008064FC(void *a1)
{
  uint64_t v2 = (void *)a1[9];
  int v3 = a1 + 10;
  if (v2 != a1 + 10)
  {
    do
    {
      CFDictionaryRef v4 = (std::__shared_weak_count *)v2[6];
      if (v4)
      {
        uint64_t v5 = std::__shared_weak_count::lock(v4);
        if (v5)
        {
          uint64_t v6 = v5;
          uint64_t v7 = v2[5];
          if (v7) {
            (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
          }
          sub_10004D2C8(v6);
        }
      }
      uint64_t v8 = (void *)v2[1];
      if (v8)
      {
        do
        {
          CFDictionaryRef v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          CFDictionaryRef v9 = (void *)v2[2];
          BOOL v10 = *v9 == (void)v2;
          uint64_t v2 = v9;
        }
        while (!v10);
      }
      uint64_t v2 = v9;
    }
    while (v9 != v3);
  }

  sub_1007F96BC(a1);
}

void sub_1008065C8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008065DC(uint64_t a1, int a2)
{
  CFDictionaryRef v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)int buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "#D %s%shumperExchange::onCloudContentChanged", buf, 0x16u);
    if (!a2) {
      goto LABEL_6;
    }
  }
  else if (!a2)
  {
    goto LABEL_6;
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 40))(__dst, a1);
  sub_10004EFE4(__p, (CFTypeRef *)__dst);
  uint64_t v5 = (void *)(a1 + 200);
  if ((void **)(a1 + 200) != __p)
  {
    *(void *)int buf = *v5;
    void *v5 = __p[0];
    __p[0] = 0;
    sub_100057D78((const void **)buf);
  }
  sub_100057D78((const void **)__p);
  sub_10005717C((const void **)__dst);
LABEL_6:
  if (*(void *)(a1 + 200)) {
    uint64_t v6 = (uint64_t *)sub_100080778;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%scompiled cloud info:", buf, 0x16u);
    }
    *(void *)int buf = off_101A0C928;
    *(void *)&uint8_t buf[8] = a1;
    long long v96 = buf;
    logger::CFTypeRefLogger();
    uint64_t v8 = (capabilities::ct *)sub_10012C330(buf);
    if (capabilities::ct::supportsThumperService(v8))
    {
      uint64_t v6 = *(uint64_t **)(a1 + 208);
      if (v6)
      {
        std::string::size_type v94 = 0;
        getAssociatedID(&v94);
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v9 = *(void *)&buf[16];
        uint64_t v93 = *(void *)&buf[16];
        uint64_t v10 = *(void *)(a1 + 208);
        int v11 = *(long long **)(v10 + 48);
        __int16 v12 = *(long long **)(v10 + 56);
        if (v11 == v12) {
          goto LABEL_40;
        }
        if (v93 >= 0) {
          uint64_t v13 = (void *)HIBYTE(v93);
        }
        else {
          uint64_t v13 = __p[1];
        }
        if (v93 >= 0) {
          int v14 = __p;
        }
        else {
          int v14 = (void **)__p[0];
        }
        while (v94 ? sub_1000810B8 : 0)
        {
          uint64_t v9 = *((unsigned __int8 *)v11 + 23);
          if ((v9 & 0x80u) == 0) {
            int v16 = (void *)*((unsigned __int8 *)v11 + 23);
          }
          else {
            int v16 = (void *)*((void *)v11 + 1);
          }
          if (v16 != v13) {
            goto LABEL_39;
          }
          if ((v9 & 0x80) == 0)
          {
            if (*((unsigned char *)v11 + 23))
            {
              uint64_t v17 = 0;
              while (*((unsigned __int8 *)v11 + v17) == *((unsigned __int8 *)v14 + v17))
              {
                if (v9 == ++v17) {
                  goto LABEL_36;
                }
              }
              goto LABEL_39;
            }
            break;
          }
          if (!memcmp(*(const void **)v11, v14, *((void *)v11 + 1))) {
            break;
          }
LABEL_39:
          int v11 = (long long *)((char *)v11 + 24);
          if (v11 == v12) {
            goto LABEL_40;
          }
        }
LABEL_36:
        int v18 = sub_100046F68(v10 + 144, (void **)v11);
        uint64_t v10 = *(void *)(a1 + 208);
        uint64_t v9 = v10 + 152;
        if ((void **)(v10 + 152) == v18) {
          goto LABEL_39;
        }
        uint64_t v9 = (uint64_t)v18[7];
        if (!*(unsigned char *)(v9 + 9)) {
          goto LABEL_39;
        }
        uint64_t v9 = *(unsigned __int8 *)(v9 + 8);
        if (!v9) {
          goto LABEL_39;
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v9, *(Registry **)(a1 + 48));
        uint64_t v76 = ServiceMap;
        if (v77 < 0)
        {
          uint64_t v78 = (unsigned __int8 *)(v77 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v79 = 5381;
          do
          {
            uint64_t v77 = v79;
            unsigned int v80 = *v78++;
            uint64_t v79 = (33 * v79) ^ v80;
          }
          while (v80);
        }
        std::mutex::lock(ServiceMap);
        *(void *)int buf = v77;
        uint64_t v81 = sub_10004D37C(&v76[1].__m_.__sig, (unint64_t *)buf);
        if (v81)
        {
          uint64_t v83 = v81[3];
          uint64_t v82 = (std::__shared_weak_count *)v81[4];
          if (v82)
          {
            atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v76);
            atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v82);
            char v84 = 0;
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v83 = 0;
        }
        std::mutex::unlock(v76);
        uint64_t v82 = 0;
        char v84 = 1;
LABEL_130:
        if (*((char *)v11 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)v11, *((void *)v11 + 1));
        }
        else
        {
          long long v85 = *v11;
          uint64_t v91 = *((void *)v11 + 2);
          *(_OWORD *)long long __dst = v85;
        }
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)long long v88 = *(_OWORD *)buf;
        uint64_t v89 = *(void *)&buf[16];
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)long long v86 = *(_OWORD *)buf;
        uint64_t v87 = *(void *)&buf[16];
        (*(void (**)(uint64_t, void **, void **, void **))(*(void *)v83 + 48))(v83, __dst, v88, v86);
        if (SHIBYTE(v87) < 0) {
          operator delete(v86[0]);
        }
        if (SHIBYTE(v89) < 0) {
          operator delete(v88[0]);
        }
        uint64_t v9 = SHIBYTE(v91);
        if ((v9 & 0x80000000) != 0) {
          operator delete(__dst[0]);
        }
        if ((v84 & 1) == 0) {
          sub_10004D2C8(v82);
        }
LABEL_40:
        __dst[0] = 0;
        __dst[1] = 0;
        uint64_t v91 = 0;
        CFNumberRef v19 = (std::mutex *)Registry::getServiceMap((uint64_t *)v9, *(Registry **)(a1 + 48));
        int v20 = v19;
        if (v21 < 0)
        {
          CFDictionaryRef v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v23 = 5381;
          do
          {
            uint64_t v21 = v23;
            unsigned int v24 = *v22++;
            uint64_t v23 = (33 * v23) ^ v24;
          }
          while (v24);
        }
        std::mutex::lock(v19);
        *(void *)int buf = v21;
        uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
        if (v25)
        {
          uint64_t v27 = v25[3];
          unsigned __int8 v26 = (std::__shared_weak_count *)v25[4];
          if (v26)
          {
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v20);
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v26);
            char v28 = 0;
            goto LABEL_48;
          }
        }
        else
        {
          uint64_t v27 = 0;
        }
        std::mutex::unlock(v20);
        unsigned __int8 v26 = 0;
        char v28 = 1;
LABEL_48:
        (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v27 + 80))(__dst, v27, 0);
        if ((v28 & 1) == 0) {
          sub_10004D2C8(v26);
        }
        uint64_t v29 = (uint64_t *)__dst[0];
        BOOL v30 = (uint64_t *)__dst[1];
        if (__dst[0] != __dst[1])
        {
          uint64_t v31 = (uint64_t *)&byte_10144BF80[128];
          do
          {
            v88[0] = 0;
            v88[1] = 0;
            uint64_t v32 = (std::mutex *)Registry::getServiceMap(v31, *(Registry **)(a1 + 48));
            int v33 = v32;
            uint64_t v35 = v34;
            if (v34 < 0)
            {
              uint64_t v36 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v37 = 5381;
              do
              {
                uint64_t v35 = v37;
                unsigned int v38 = *v36++;
                uint64_t v37 = (33 * v37) ^ v38;
              }
              while (v38);
            }
            std::mutex::lock(v32);
            *(void *)int buf = v35;
            __int16 v39 = sub_10004D37C(&v33[1].__m_.__sig, (unint64_t *)buf);
            if (v39)
            {
              uint64_t v41 = v39[3];
              int v40 = (std::__shared_weak_count *)v39[4];
              if (v40)
              {
                atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v33);
                atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v40);
                char v42 = 0;
                goto LABEL_60;
              }
            }
            else
            {
              uint64_t v41 = 0;
            }
            std::mutex::unlock(v33);
            int v40 = 0;
            char v42 = 1;
LABEL_60:
            (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(*(void *)v41 + 128))(v88, v41, v29);
            if ((v42 & 1) == 0) {
              sub_10004D2C8(v40);
            }
            uint64_t v31 = (uint64_t *)v88[0];
            if (!v88[0]) {
              goto LABEL_103;
            }
            uint64_t v31 = (uint64_t *)*((unsigned __int8 *)v88[0] + 49);
            if (v31 != 1) {
              goto LABEL_103;
            }
            uint64_t v31 = *(uint64_t **)(a1 + 208);
            int v43 = (const void **)v31[6];
            uint64_t v44 = v31[7];
            if (v43 != (const void **)v44)
            {
              uint32_t v45 = (uint64_t *)*((unsigned __int8 *)v29 + 23);
              size_t v46 = v29[1];
              if ((char)v45 >= 0) {
                uint64_t v47 = *((unsigned __int8 *)v29 + 23);
              }
              else {
                uint64_t v47 = v29[1];
              }
              do
              {
                uint64_t v48 = (const void *)*((unsigned __int8 *)v43 + 23);
                uint64_t v31 = (uint64_t *)(char)v48;
                if ((int)v31 < 0) {
                  uint64_t v48 = v43[1];
                }
                if ((const void *)v47 == v48)
                {
                  if ((int)v31 >= 0) {
                    CFStringRef v49 = v43;
                  }
                  else {
                    CFStringRef v49 = *v43;
                  }
                  if ((v45 & 0x80) != 0)
                  {
                    if (!memcmp((const void *)*v29, v49, v46)) {
                      goto LABEL_83;
                    }
                  }
                  else
                  {
                    if (!v45) {
                      goto LABEL_83;
                    }
                    uint64_t v31 = 0;
                    while (*((unsigned __int8 *)v31 + (void)v29) == *((unsigned __int8 *)v31 + (void)v49))
                    {
                      uint64_t v31 = (uint64_t *)((char *)v31 + 1);
                      if (v45 == v31) {
                        goto LABEL_83;
                      }
                    }
                  }
                }
                v43 += 3;
              }
              while (v43 != (const void **)v44);
LABEL_84:
              BOOL v50 = (std::mutex *)Registry::getServiceMap(v31, *(Registry **)(a1 + 48));
              unsigned int v51 = v50;
              if (v34 < 0)
              {
                CFStringRef v52 = (unsigned __int8 *)(v34 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v53 = 5381;
                do
                {
                  uint64_t v34 = v53;
                  unsigned int v54 = *v52++;
                  uint64_t v53 = (33 * v53) ^ v54;
                }
                while (v54);
              }
              std::mutex::lock(v50);
              *(void *)int buf = v34;
              char v55 = sub_10004D37C(&v51[1].__m_.__sig, (unint64_t *)buf);
              if (v55)
              {
                uint64_t v57 = v55[3];
                __int16 v56 = (std::__shared_weak_count *)v55[4];
                if (v56)
                {
                  atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v51);
                  atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v56);
                  char v58 = 0;
LABEL_92:
                  (*(void (**)(uint64_t, uint64_t *))(*(void *)v57 + 136))(v57, v29);
                  if ((v58 & 1) == 0) {
                    sub_10004D2C8(v56);
                  }
                  sub_1008ABC1C(v29);
                  int v59 = *(NSObject **)(a1 + 40);
                  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v60 = *((unsigned __int8 *)v29 + 23);
                    BOOL v61 = (v60 & 0x80u) != 0;
                    if ((v60 & 0x80u) != 0) {
                      uint64_t v60 = v29[1];
                    }
                    if (v61) {
                      uint64_t v62 = (const char *)*v29;
                    }
                    else {
                      uint64_t v62 = (const char *)v29;
                    }
                    BOOL v63 = v60 == 0;
                    uint64_t v64 = "<invalid>";
                    if (!v63) {
                      uint64_t v64 = v62;
                    }
                    *(_DWORD *)int buf = 136315650;
                    *(void *)&uint8_t buf[4] = "";
                    *(_WORD *)&unsigned char buf[12] = 2080;
                    *(void *)&buf[14] = "";
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    long long v96 = (uint8_t *)v64;
                    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I %s%sremove wallet for historically used cloud personality %s", buf, 0x20u);
                  }
                  goto LABEL_103;
                }
              }
              else
              {
                uint64_t v57 = 0;
              }
              std::mutex::unlock(v51);
              __int16 v56 = 0;
              char v58 = 1;
              goto LABEL_92;
            }
LABEL_83:
            if (v43 == (const void **)v44) {
              goto LABEL_84;
            }
LABEL_103:
            if (v88[1]) {
              sub_10004D2C8((std::__shared_weak_count *)v88[1]);
            }
            v29 += 3;
          }
          while (v29 != v30);
        }
        *(void *)int buf = __dst;
        sub_100047F64((void ***)buf);
        if (SHIBYTE(v93) < 0) {
          operator delete(__p[0]);
        }
        sub_1000558F4(&v94);
      }
    }
  }
  CFTypeID v65 = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 48));
  std::string::size_type v66 = v65;
  if (v67 < 0)
  {
    uint64_t v68 = (unsigned __int8 *)(v67 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v69 = 5381;
    do
    {
      uint64_t v67 = v69;
      unsigned int v70 = *v68++;
      uint64_t v69 = (33 * v69) ^ v70;
    }
    while (v70);
  }
  std::mutex::lock(v65);
  *(void *)int buf = v67;
  CFArrayRef v71 = sub_10004D37C(&v66[1].__m_.__sig, (unint64_t *)buf);
  if (v71)
  {
    uint64_t v73 = v71[3];
    CFTypeID v72 = (std::__shared_weak_count *)v71[4];
    if (v72)
    {
      atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v66);
      atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v72);
      char v74 = 0;
      goto LABEL_117;
    }
  }
  else
  {
    uint64_t v73 = 0;
  }
  std::mutex::unlock(v66);
  CFTypeID v72 = 0;
  char v74 = 1;
LABEL_117:
  (*(void (**)(uint64_t))(*(void *)v73 + 32))(v73);
  if ((v74 & 1) == 0) {
    sub_10004D2C8(v72);
  }
}

void sub_100806F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,const void *a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v44);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  sub_1000558F4(&a38);
  _Unwind_Resume(a1);
}

uint64_t sub_100807108(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      sub_1000D8578();
    }
    uint64_t v5 = a1[1] - *a1;
    char v7[4] = result;
    v7[0] = sub_10004812C(result, a2);
    v7[1] = v7[0] + v5;
    void v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 24 * v6;
    sub_100048204(a1, v7);
    return sub_100048174((uint64_t)v7);
  }
  return result;
}

void sub_1008071A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100048174((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1008071BC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1008071BC(a1, *a2);
    sub_1008071BC(a1, a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[6];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(a2);
  }
}

uint64_t *sub_10080721C(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *uint64_t result = *a2;
  if (v2) {
    operator new();
  }
  result[1] = 0;
  *a2 = 0;
  return result;
}

void sub_1008072A0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008072D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_100807308(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

uint64_t sub_10080734C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100807360()
{
}

void *sub_100807374(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0C688;
  result[1] = v3;
  return result;
}

uint64_t sub_1008073BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0C688;
  a2[1] = v2;
  return result;
}

void sub_1008073E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1008074B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008074F4()
{
}

void sub_100807504()
{
}

void *sub_100807518(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0C708;
  result[1] = v3;
  return result;
}

uint64_t sub_100807560(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0C708;
  a2[1] = v2;
  return result;
}

void sub_10080758C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100807658(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100807698()
{
}

void sub_1008076A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0C788;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1008076C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0C788;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_100807718(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 24);
  sub_10080777C(*(void **)(a1 + 120));
  sub_1000558F4((const void **)(a1 + 80));
  sub_1000558F4((const void **)(a1 + 72));
  sub_1000558F4((const void **)(a1 + 48));
  sub_1000558F4((const void **)(a1 + 40));

  return sub_1000558F4(v2);
}

void sub_10080777C(void *a1)
{
  if (a1)
  {
    sub_10080777C(*a1);
    sub_10080777C(a1[1]);
    sub_1008077D0((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1008077D0(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 24);
  sub_1000558F4((const void **)(a1 + 40));
  sub_100062778((const void **)(a1 + 32));
  sub_1000558F4(v2);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t *sub_100807834(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  __int16 v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  __int16 v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      uint64_t v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      int v5 = *v8;
      __int16 v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    __int16 v7 = v8 + 1;
    int v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  int v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    __int16 v12 = *a3;
    uint64_t v19 = 0;
    uint64_t v13 = (uint64_t *)operator new(0x50uLL);
    v18[0] = v13;
    v18[1] = v6;
    int v14 = v13 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      void v13[6] = *((void *)v12 + 2);
      *(_OWORD *)int v14 = v15;
    }
    v13[8] = 0;
    v13[9] = 0;
    v13[7] = 0;
    LOBYTE(v19) = 1;
    *uint64_t v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v8;
    *__int16 v7 = v13;
    int v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    int v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    sub_100807998((uint64_t)v18);
  }
  return v11;
}

void sub_100807984(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100807998((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100807998(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1008077D0((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_1008079F0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0C7D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100807A10(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0C7D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100807A64(uint64_t a1)
{
  uint64_t v2 = a1 + 24;
  sub_1001FEC70(*(void **)(a1 + 176));
  uint64_t v3 = (void **)(a1 + 144);
  sub_100047F64(&v3);
  uint64_t v3 = (void **)(a1 + 120);
  sub_100047F64(&v3);
  uint64_t v3 = (void **)(a1 + 96);
  sub_100047F64(&v3);
  uint64_t v3 = (void **)(a1 + 72);
  sub_100047F64(&v3);
  sub_10005CD2C(a1 + 48, *(char **)(a1 + 56));
  sub_10005CD2C(v2, *(char **)(a1 + 32));
}

void sub_100807AF8()
{
}

void *sub_100807B0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0C828;
  result[1] = v3;
  return result;
}

uint64_t sub_100807B54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0C828;
  a2[1] = v2;
  return result;
}

void sub_100807B80(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100807C4C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100807C8C()
{
}

void sub_100807C9C()
{
}

void *sub_100807CB0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0C8A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100807CF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0C8A8;
  a2[1] = v2;
  return result;
}

void sub_100807D24(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "#E %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100807DF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100807E34()
{
}

void sub_100807E44()
{
}

void *sub_100807E58(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0C928;
  result[1] = v3;
  return result;
}

uint64_t sub_100807EA0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0C928;
  a2[1] = v2;
  return result;
}

void sub_100807ECC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100807F98(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100807FD8()
{
}

void sub_100807FE4(void **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = (unsigned char *)**a1;
  v1[224] = 0;
  (*(void (**)(unsigned char *, uint64_t))(*(void *)v1 + 88))(v1, 1);
  operator delete();
}

void sub_100808060()
{
}

void sub_1008080F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100808190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100808230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1008082D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1008082F8(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::supportsP2P(a1)) {
    goto LABEL_13;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    __int16 v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v33.var0 = (char *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v33);
  if (v10)
  {
    __int16 v12 = (GestaltUtilityInterface *)v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_10;
    }
  }
  else
  {
    __int16 v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
LABEL_10:
  char isWatch = GestaltUtilityInterface::isWatch(v12);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if ((isWatch & 1) == 0)
  {
    *a2 = 0;
    a2[1] = 0;
    return;
  }
LABEL_13:
  *a2 = 0;
  a2[1] = 0;
  int v14 = (char *)operator new(0xB8uLL);
  *((void *)v14 + 1) = 0;
  *(void *)int v14 = off_101A0CA78;
  long long v15 = v14 + 24;
  *((void *)v14 + 2) = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v33, kCtLoggingSystemName, "paireddev");
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v17 = dispatch_queue_create_with_target_V2("PairedDeviceMonitor", initially_inactive, 0);
  dispatch_set_qos_class_floor(v17, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v17);
  *((void *)v14 + 4) = 0;
  *((void *)v14 + 5) = 0;
  *((void *)v14 + 6) = v17;
  if (v17)
  {
    dispatch_retain(v17);
    *((void *)v14 + 7) = 0;
    dispatch_release(v17);
  }
  else
  {
    *((void *)v14 + 7) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)__p, &v33);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v14 + 64), (const ctu::OsLogLogger *)__p);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)__p);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v33);
  *((void *)v14 + 9) = 0;
  int v18 = (void **)(v14 + 72);
  *((void *)v14 + 3) = off_101A0C9A8;
  int v20 = *(Registry **)a1;
  uint64_t v19 = *((void *)a1 + 1);
  *((void *)v14 + 10) = 0;
  *((void *)v14 + 11) = v20;
  *((void *)v14 + 12) = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(__p, "PairedDeviceMonitor");
  uint64_t v21 = *((void *)v14 + 6);
  BOOL v30 = v21;
  if (v21) {
    dispatch_retain(v21);
  }
  CFDictionaryRef v22 = *((void *)v14 + 7);
  xpc_object_t object = v22;
  if (v22) {
    dispatch_retain(v22);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v30) {
    dispatch_release(v30);
  }
  if (v32 < 0) {
    operator delete(__p[0]);
  }
  *((void *)v14 + 18) = 0;
  v14[152] = 0;
  v14[176] = 0;
  id v23 = [objc_alloc((Class)IDSService) initWithService:@"com.apple.private.alloy.ct.commcenter.p2w.settings"];
  unsigned int v24 = *v18;
  *int v18 = v23;

  uint64_t v25 = [IdsDeviceObserver alloc];
  v33.var0 = (char *)off_101A0CB48;
  v33.var1.fRef = (os_log_s *)(v14 + 24);
  uint64_t v34 = &v33;
  unsigned __int8 v26 = [(IdsDeviceObserver *)v25 initWithCallback:&v33];
  uint64_t v27 = (void *)*((void *)v14 + 10);
  *((void *)v14 + 10) = v26;

  sub_10003B34C(&v33);
  *a2 = v15;
  a2[1] = v14;
  char v28 = (std::__shared_weak_count *)*((void *)v14 + 5);
  if (!v28)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 2, 1uLL, memory_order_relaxed);
    *((void *)v14 + 4) = v15;
    *((void *)v14 + 5) = v14;
    goto LABEL_32;
  }
  if (v28->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 2, 1uLL, memory_order_relaxed);
    *((void *)v14 + 4) = v15;
    *((void *)v14 + 5) = v14;
    std::__shared_weak_count::__release_weak(v28);
LABEL_32:
    sub_10004D2C8((std::__shared_weak_count *)v14);
  }
  v33.var0 = 0;
  v33.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&v33, *(Registry **)a1);
  if (v33.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (v33.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v33.var1.fRef);
  }
}

void sub_100808758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, std::__shared_weak_count *a18)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_1008088B8(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

id sub_1008089B8(uint64_t a1)
{
  return *(id *)(a1 + 48);
}

void sub_1008089C0(uint64_t a1)
{
  size_t v46 = [*(id *)(a1 + 48) linkedDevicesWithRelationship:3];
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 134217984;
    *(void *)&uint8_t buf[4] = [v46 count];
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %lu linked devices", buf, 0xCu);
  }
  char v55 = 0;
  __int16 v56 = 0;
  unint64_t v57 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  id obj = v46;
  id v2 = [obj countByEnumeratingWithState:&v51 objects:v60 count:16];
  if (v2)
  {
    uint64_t v50 = *(void *)v52;
    uint64_t v48 = NRDevicePropertyGreenTeaDevice;
    do
    {
      for (uint64_t i = 0; i != v2; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v52 != v50) {
          objc_enumerationMutation(obj);
        }
        uint64_t v4 = *(void **)(*((void *)&v51 + 1) + 8 * i);
        int v5 = [v4 uniqueIDOverride];
        if (v5)
        {
          uint64_t v6 = +[NRPairedDeviceRegistry sharedInstance];
          __int16 v7 = [v6 deviceForIDSDevice:v4];

          uint64_t v8 = [v7 valueForProperty:v48];
          unsigned int v9 = [v8 BOOLValue];

          uint64_t v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            id v11 = [v5 UTF8String];
            unsigned int v12 = [v4 isConnected];
            unsigned __int8 v13 = [v4 relationship];
            int v14 = "false";
            if (v12) {
              long long v15 = "true";
            }
            else {
              long long v15 = "false";
            }
            *(_DWORD *)int buf = 136315906;
            *(void *)&uint8_t buf[4] = v11;
            if ((v13 & 2) != 0) {
              int v16 = "true";
            }
            else {
              int v16 = "false";
            }
            *(_WORD *)&unsigned char buf[12] = 2080;
            if (v9) {
              int v14 = "true";
            }
            *(void *)&buf[14] = v15;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v16;
            LOWORD(v59) = 2080;
            *(void *)((char *)&v59 + 2) = v14;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I paired device %s, connected %s, tinker %s, green tea %s", buf, 0x2Au);
          }
          sub_100058DB0(buf, (char *)[v5 UTF8String]);
          uint8_t buf[24] = [v4 isConnected];
          buf[25] = ([v4 relationship] & 2) != 0;
          buf[26] = v9;
          uint64_t v17 = v56;
          if ((unint64_t)v56 >= v57)
          {
            int64_t v21 = ((char *)v56 - (char *)v55) >> 5;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 59) {
              sub_10006A748();
            }
            uint64_t v23 = v57 - (void)v55;
            if ((uint64_t)(v57 - (void)v55) >> 4 > v22) {
              unint64_t v22 = v23 >> 4;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v24 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24) {
              unint64_t v24 = (unint64_t)sub_1000509C0(v24);
            }
            else {
              uint64_t v25 = 0;
            }
            unint64_t v26 = v24 + 32 * v21;
            long long v27 = *(_OWORD *)buf;
            *(void *)(v26 + 16) = *(void *)&buf[16];
            *(_OWORD *)unint64_t v26 = v27;
            memset(buf, 0, 24);
            __int16 v28 = *(_WORD *)&buf[24];
            *(unsigned char *)(v26 + 26) = buf[26];
            *(_WORD *)(v26 + 24) = v28;
            int v20 = (long long *)(v26 + 32);
            uint64_t v29 = v55;
            BOOL v30 = (long long *)v56;
            if (v56 == v55)
            {
              char v55 = (std::string *)v26;
              __int16 v56 = (std::string *)(v26 + 32);
              unint64_t v57 = v24 + 32 * v25;
            }
            else
            {
              do
              {
                long long v31 = *(v30 - 2);
                *(void *)(v26 - 16) = *((void *)v30 - 2);
                *(_OWORD *)(v26 - 32) = v31;
                *((void *)v30 - 3) = 0;
                *((void *)v30 - 2) = 0;
                *((void *)v30 - 4) = 0;
                __int16 v32 = *((_WORD *)v30 - 4);
                *(unsigned char *)(v26 - 6) = *((unsigned char *)v30 - 6);
                *(_WORD *)(v26 - 8) = v32;
                v26 -= 32;
                v30 -= 2;
              }
              while (v30 != (long long *)v29);
              BOOL v30 = (long long *)v55;
              OsLogContext v33 = v56;
              char v55 = (std::string *)v26;
              __int16 v56 = (std::string *)v20;
              unint64_t v57 = v24 + 32 * v25;
              while (v33 != (std::string *)v30)
              {
                if (v33[-1].__r_.__value_.__s.__data_[15] < 0) {
                  operator delete((void *)v33[-2].__r_.__value_.__r.__words[2]);
                }
                OsLogContext v33 = (std::string *)((char *)v33 - 32);
              }
            }
            if (v30) {
              operator delete(v30);
            }
          }
          else
          {
            long long v18 = *(_OWORD *)buf;
            v56->__r_.__value_.__r.__words[2] = *(void *)&buf[16];
            *(_OWORD *)&v17->__r_.__value_.__l.__data_ = v18;
            memset(buf, 0, 24);
            std::string::value_type v19 = buf[26];
            LOWORD(v17[1].__r_.__value_.__l.__data_) = *(_WORD *)&buf[24];
            v17[1].__r_.__value_.__s.__data_[2] = v19;
            int v20 = (long long *)&v17[1].__r_.__value_.__r.__words[1];
          }
          __int16 v56 = (std::string *)v20;
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
      }
      id v2 = [obj countByEnumeratingWithState:&v51 objects:v60 count:16];
    }
    while (v2);
  }

  *(_OWORD *)&uint8_t buf[16] = 0u;
  long long v59 = 0u;
  *(void *)int buf = 1;
  *(void *)&uint8_t buf[8] = a1 + 96;
  if (*(unsigned char *)(a1 + 152))
  {
    *(void *)&uint8_t buf[16] = 0;
    *(void *)&uint8_t buf[24] = 0;
    *(void *)&long long v59 = 0;
    sub_100809318(&buf[16], *(long long **)(a1 + 128), *(long long **)(a1 + 136), (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 5);
    BYTE8(v59) = 1;
    uint64_t v35 = (long long *)v55;
    uint64_t v34 = (long long *)v56;
    int64_t v36 = (char *)v56 - (char *)v55;
    unint64_t v37 = ((char *)v56 - (char *)v55) >> 5;
    if (v37 > (uint64_t)(v59 - *(void *)&buf[16]) >> 5)
    {
      sub_1002B2B70((uint64_t *)&buf[16]);
      if (v36 < 0) {
        goto LABEL_67;
      }
      unint64_t v38 = (uint64_t)(v59 - *(void *)&buf[16]) >> 4;
      if (v38 <= v37) {
        unint64_t v38 = v37;
      }
      unint64_t v39 = (void)v59 - *(void *)&buf[16] >= 0x7FFFFFFFFFFFFFE0uLL ? 0x7FFFFFFFFFFFFFFLL : v38;
      if (v39 >> 59) {
LABEL_67:
      }
        sub_10006A748();
      *(void *)&uint8_t buf[16] = sub_1000509C0(v39);
      *(void *)&uint8_t buf[24] = *(void *)&buf[16];
      *(void *)&long long v59 = *(void *)&buf[16] + 32 * v40;
      uint64_t v41 = sub_1008091E0((uint64_t)&v59, v35, v34, *(void **)&buf[16]);
      goto LABEL_58;
    }
    unint64_t v42 = (uint64_t)(*(void *)&buf[24] - *(void *)&buf[16]) >> 5;
    if (v42 < v37)
    {
      int v43 = (std::string *)((char *)v55 + 32 * v42);
      sub_1008092B0(v55, v43, *(std::string **)&buf[16]);
      uint64_t v41 = sub_1008091E0((uint64_t)&v59, (long long *)v43, v34, *(void **)&buf[24]);
LABEL_58:
      *(void *)&uint8_t buf[24] = v41;
      goto LABEL_65;
    }
    uint64_t v44 = sub_1008092B0(v55, v56, *(std::string **)&buf[16]);
    for (j = *(std::string **)&buf[24]; j != v44; j = (std::string *)((char *)j - 32))
    {
      if (j[-1].__r_.__value_.__s.__data_[15] < 0) {
        operator delete((void *)j[-2].__r_.__value_.__r.__words[2]);
      }
    }
    *(void *)&uint8_t buf[24] = v44;
  }
  else
  {
    *(void *)&uint8_t buf[16] = 0;
    *(void *)&uint8_t buf[24] = 0;
    *(void *)&long long v59 = 0;
    sub_100809318(&buf[16], (long long *)v55, (long long *)v56, ((char *)v56 - (char *)v55) >> 5);
    BYTE8(v59) = 1;
  }
LABEL_65:
  sub_100809EC8((uint64_t)buf);
  *(void *)int buf = &v55;
  sub_1000D82FC((void ***)buf);
}

void sub_100808FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,char a37)
{
  std::string __p = &a25;
  sub_1000D82FC((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_10080909C(uint64_t a1)
{
  sub_1008093A0(a1);

  operator delete();
}

void *sub_1008090D4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v3 = (void **)(a1 + 32);
    sub_1000D82FC(&v3);
  }
  return sub_10080911C((void *)a1);
}

void *sub_10080911C(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

char *sub_1008091A0(void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_1000509C0(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *sub_1008091E0(uint64_t a1, long long *a2, long long *a3, void *__dst)
{
  uint64_t v4 = __dst;
  unsigned __int8 v13 = __dst;
  int v14 = __dst;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  uint64_t v12 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_10004FC84(v4, *(void **)v6, *((void *)v6 + 1));
        uint64_t v8 = v14;
      }
      else
      {
        long long v7 = *v6;
        uint64_t v4[2] = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v4 = v7;
        uint64_t v8 = v4;
      }
      __int16 v9 = *((_WORD *)v6 + 12);
      *((unsigned char *)v4 + 26) = *((unsigned char *)v6 + 26);
      *((_WORD *)v4 + 12) = v9;
      v6 += 2;
      uint64_t v4 = v8 + 4;
      int v14 = v8 + 4;
    }
    while (v6 != a3);
  }
  LOBYTE(v12) = 1;
  sub_10016DE78((uint64_t)v11);
  return v4;
}

void sub_10080929C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

std::string *sub_1008092B0(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    int v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      std::string::value_type v6 = v5[1].__r_.__value_.__s.__data_[2];
      LOWORD(this[1].__r_.__value_.__l.__data_) = v5[1].__r_.__value_.__l.__data_;
      this[1].__r_.__value_.__s.__data_[2] = v6;
      this = (std::string *)((char *)this + 32);
      int v5 = (std::string *)((char *)v5 + 32);
    }
    while (v5 != a2);
  }
  return this;
}

void *sub_100809318(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    std::string::value_type v6 = result;
    sub_1008091A0(result, a4);
    uint64_t result = sub_1008091E0((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100809380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1000D82FC(&a9);
  _Unwind_Resume(a1);
}

void sub_1008093A0(uint64_t a1)
{
  *(void *)a1 = off_101A0C9A8;
  sub_1008090D4(a1 + 96);
  id v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  IDSServiceWrapper::~IDSServiceWrapper((IDSServiceWrapper *)a1);
}

void sub_100809430(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0CA78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100809450(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0CA78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008094A4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1008094CC(ServiceManager::Service *this)
{
  *(void *)this = off_101A0CAC8;
  id v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100809528(ServiceManager::Service *this)
{
  *(void *)this = off_101A0CAC8;
  id v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100809598@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PairedDeviceMonitor");
}

unsigned char *sub_1008095A8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  id v2 = operator new(1uLL);
  *a1 = v2;
  *id v2 = 1;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1008095E8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1008088B8(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1008088B8(v4, 0);
}

uint64_t sub_10080966C()
{
  return 0;
}

uint64_t sub_100809674()
{
  return 1;
}

uint64_t sub_10080967C()
{
  return 0;
}

void sub_100809688(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100809768(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100809880()
{
}

void *sub_100809894(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0CB48;
  result[1] = v3;
  return result;
}

uint64_t sub_1008098DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0CB48;
  a2[1] = v2;
  return result;
}

void sub_100809908(uint64_t a1)
{
}

uint64_t sub_100809910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100809950()
{
}

uint64_t *sub_10080995C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void **)v1;
  Registry::createRestModuleOneTimeUseConnection(&v9, *(Registry **)(*(void *)v1 + 64));
  ctu::RestModule::connect();
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v3 = v2 + 12;
  v11[0] = off_101A0CBC8;
  v11[1] = v2 + 10;
  uint64_t v12 = v11;
  if (v11 != v2 + 12)
  {
    uint64_t v4 = (void *)v2[15];
    if (v4 == v3)
    {
      v13[1] = v2 + 10;
      v13[2] = 0;
      uint64_t v12 = 0;
      v13[0] = off_101A0CBC8;
      (*(void (**)(void *, void *))(*v3 + 24))(v2 + 12, v11);
      (*(void (**)(void))(*(void *)v2[15] + 32))(v2[15]);
      v2[15] = 0;
      uint64_t v12 = v11;
      (*(void (**)(void *, void *))(v13[0] + 24))(v13, v2 + 12);
      (*(void (**)(void *))(v13[0] + 32))(v13);
    }
    else
    {
      v2[12] = off_101A0CBC8;
      v2[13] = v2 + 10;
      uint64_t v12 = v4;
    }
    v2[15] = v3;
  }
  sub_10080911C(v11);
  uint64_t v5 = v2[15];
  if (v5) {
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v2 + 16);
  }
  sub_100088C88(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100809B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100809BB4()
{
}

void *sub_100809BC8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0CBC8;
  result[1] = v3;
  return result;
}

uint64_t sub_100809C10(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0CBC8;
  a2[1] = v2;
  return result;
}

void sub_100809C3C(uint64_t a1, uint64_t a2)
{
  xpc_object_t v5 = 0;
  if (*(unsigned char *)(a2 + 24)) {
    rest::write_rest_value();
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/paired_device");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100809CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100809D3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100809D7C()
{
}

void sub_100809D88(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I paired device monitor is starting", buf, 2u);
  }
  [*(id *)(v1 + 48) addDelegate:*(void *)(v1 + 56) queue:*(void *)(v1 + 24)];
  sub_1008089C0(v1);
  operator delete();
}

void sub_100809E30()
{
}

uint64_t *sub_100809E5C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  objc_msgSend(*(id *)(*(void *)v1 + 48), "removeDelegate:", *(void *)(*(void *)v1 + 56), a1, v1);
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 80));
  sub_100088C88(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100809EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100809EC8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    int v3 = *(unsigned __int8 *)(v2 + 56);
    int v4 = *(unsigned __int8 *)(a1 + 40);
    if (*(unsigned char *)(v2 + 56)) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5)
    {
      if ((v3 != 0) == (v4 != 0)) {
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v7 = *(void *)(v2 + 32);
      uint64_t v6 = *(void *)(v2 + 40);
      uint64_t v8 = *(unsigned __int8 ***)(a1 + 16);
      if (v6 - v7 == *(void *)(a1 + 24) - (void)v8)
      {
        if (v7 == v6) {
          goto LABEL_40;
        }
        while (1)
        {
          uint64_t v9 = *(unsigned __int8 *)(v7 + 23);
          if ((v9 & 0x80u) == 0) {
            uint64_t v10 = (unsigned __int8 *)*(unsigned __int8 *)(v7 + 23);
          }
          else {
            uint64_t v10 = *(unsigned __int8 **)(v7 + 8);
          }
          id v11 = (unsigned __int8 *)*((unsigned __int8 *)v8 + 23);
          int v12 = (char)v11;
          if ((char)v11 < 0) {
            id v11 = v8[1];
          }
          if (v10 != v11) {
            break;
          }
          if (v12 >= 0) {
            unsigned __int8 v13 = (unsigned __int8 *)v8;
          }
          else {
            unsigned __int8 v13 = *v8;
          }
          if ((v9 & 0x80) != 0)
          {
            if (memcmp(*(const void **)v7, v13, *(void *)(v7 + 8))) {
              break;
            }
          }
          else if (*(unsigned char *)(v7 + 23))
          {
            uint64_t v14 = 0;
            while (*(unsigned __int8 *)(v7 + v14) == v13[v14])
            {
              if (v9 == ++v14) {
                goto LABEL_27;
              }
            }
            break;
          }
LABEL_27:
          if (*(unsigned __int8 *)(v7 + 24) != *((unsigned __int8 *)v8 + 24)
            || *(unsigned __int8 *)(v7 + 25) != *((unsigned __int8 *)v8 + 25))
          {
            break;
          }
          int v15 = *(unsigned __int8 *)(v7 + 26);
          int v16 = *((unsigned __int8 *)v8 + 26);
          if (v15 == v16)
          {
            v7 += 32;
            v8 += 4;
            if (v7 != v6) {
              continue;
            }
          }
          if (v15 == v16) {
            goto LABEL_40;
          }
          break;
        }
      }
    }
    uint64_t v17 = (void *)(a1 + 16);
    if (v3 == v4)
    {
      if (v3)
      {
        sub_1002B2B70((uint64_t *)(v2 + 32));
        *(_OWORD *)(v2 + 32) = *(_OWORD *)(a1 + 16);
        *(void *)(v2 + 48) = *(void *)(a1 + 32);
        *uint64_t v17 = 0;
        *(void *)(a1 + 24) = 0;
        *(void *)(a1 + 32) = 0;
      }
    }
    else if (v3)
    {
      int v20 = (void **)(v2 + 32);
      sub_1000D82FC(&v20);
      *(unsigned char *)(v2 + 56) = 0;
    }
    else
    {
      *(void *)(v2 + 32) = 0;
      *(void *)(v2 + 40) = 0;
      *(void *)(v2 + 48) = 0;
      *(_OWORD *)(v2 + 32) = *(_OWORD *)(a1 + 16);
      *(void *)(v2 + 48) = *(void *)(a1 + 32);
      *uint64_t v17 = 0;
      *(void *)(a1 + 24) = 0;
      *(void *)(a1 + 32) = 0;
      *(unsigned char *)(v2 + 56) = 1;
    }
    uint64_t v18 = *(void *)(v2 + 24);
    if (v18) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 48))(v18, v2 + 32);
    }
  }
LABEL_40:
  if (*(unsigned char *)(a1 + 40))
  {
    int v20 = (void **)(a1 + 16);
    sub_1000D82FC(&v20);
  }
  return a1;
}

void sub_10080A0E8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10080A40C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_10080A594(void *a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, a1);
  operator new();
}

uint64_t sub_10080A688(uint64_t a1)
{
  unsigned __int16 v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 32))(*(void *)(a1 + 72));
  if (v2 <= 0xFFu)
  {
    *(_DWORD *)(a1 + 144) = 0;
    uint64_t v5 = a1 + 144;
    uint64_t result = *(void *)(v5 - 8);
    if (!result) {
      return result;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v5);
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 144);
  if ((_BYTE)v2) {
    int v4 = 2;
  }
  else {
    int v4 = 1;
  }
  *(_DWORD *)(a1 + 144) = v4;
  uint64_t v7 = *(void *)(a1 + 136);
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, a1 + 144);
    int v4 = *(_DWORD *)(a1 + 144);
  }
  if (v3 == v4) {
    return 0;
  }
  uint64_t v8 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315394;
    uint64_t v10 = asString();
    __int16 v11 = 2080;
    uint64_t v12 = asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N User airplane mode preference changing from %s to %s", (uint8_t *)&v9, 0x16u);
  }
  return 1;
}

uint64_t sub_10080A820(void *a1, int a2)
{
  uint64_t v4 = a1[11];
  uint64_t v5 = a1[4];
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6) {
      goto LABEL_11;
    }
    uint64_t v7 = "false";
    if (a2) {
      uint64_t v7 = "true";
    }
    int v8 = *(_DWORD *)(v4 + 68);
    *(_DWORD *)int buf = 136315650;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8 == 2;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v8 == 0;
    int v9 = "#I AirplaneMode status: %s (held: acquired=%d, revoked=%d)";
    uint64_t v10 = v5;
    uint32_t v11 = 24;
  }
  else
  {
    if (!v6) {
      goto LABEL_11;
    }
    uint64_t v12 = "false";
    if (a2) {
      uint64_t v12 = "true";
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    int v9 = "#I AirplaneMode status: %s (not held)";
    uint64_t v10 = v5;
    uint32_t v11 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
LABEL_11:
  if (a2)
  {
    if (!a1[11])
    {
      sub_100058DB0(buf, "/cc/assertions/airplane_mode");
      ctu::rest::AssertionHandle::create();
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      unsigned __int8 v13 = (std::__shared_weak_count *)a1[12];
      *(_OWORD *)(a1 + 11) = v16;
      if (v13) {
        sub_10004D2C8(v13);
      }
      *(void *)int buf = off_101A0CEC8;
      *(void *)&uint8_t buf[8] = a1;
      uint64_t v18 = buf;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(buf);
    }
  }
  else
  {
    uint64_t v14 = (std::__shared_weak_count *)a1[12];
    a1[11] = 0;
    a1[12] = 0;
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  *(void *)int buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_100ED07E0;
  uint64_t v18 = &unk_101A697A0;
  char v19 = a2;
  return sub_100ED0600((wis::MetricFactory *)0x80014);
}

void sub_10080AA68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_10080AA9C(uint64_t a1)
{
  unsigned __int16 v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 136315138;
    uint64_t v14 = printers::asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Restricted power mode: %s", (uint8_t *)&v13, 0xCu);
    unsigned __int16 v2 = *(NSObject **)(a1 + 32);
  }
  uint64_t v3 = *(void *)(a1 + 88);
  BOOL v4 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v4) {
      goto LABEL_14;
    }
    uint64_t v5 = "false";
    int v6 = *(_DWORD *)(v3 + 68);
    if (v6 == 2) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    if (!v6) {
      uint64_t v5 = "true";
    }
    int v13 = 136315394;
    uint64_t v14 = (uint64_t)v7;
    __int16 v15 = 2080;
    long long v16 = v5;
    int v8 = "#I Assertion granted (%s) revoked (%s)";
    int v9 = v2;
    uint32_t v10 = 22;
  }
  else
  {
    if (!v4) {
      goto LABEL_14;
    }
    LOWORD(v13) = 0;
    int v8 = "#I Assertion not held";
    int v9 = v2;
    uint32_t v10 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v13, v10);
LABEL_14:
  uint32_t v11 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asString();
    int v13 = 136315138;
    uint64_t v14 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Airplane mode user preference: %s", (uint8_t *)&v13, 0xCu);
  }
}

void *sub_10080AC40(void *a1)
{
  unsigned __int16 v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10080ACC8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10080AD00(uint64_t a1)
{
}

uint64_t sub_10080AD1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_10080AD60(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    sub_10080AC40(result + 14);
    unsigned __int16 v2 = (std::__shared_weak_count *)v1[12];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[10];
    if (v3) {
      sub_10004D2C8(v3);
    }
    BOOL v4 = (std::__shared_weak_count *)v1[8];
    if (v4) {
      sub_10004D2C8(v4);
    }
    uint64_t v5 = (std::__shared_weak_count *)v1[6];
    if (v5) {
      sub_10004D2C8(v5);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_10080ADF0(ServiceManager::Service *this)
{
  *(void *)this = off_101A0CCB8;
  unsigned __int16 v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10080AE4C(ServiceManager::Service *this)
{
  *(void *)this = off_101A0CCB8;
  unsigned __int16 v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10080AEBC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SCSettings");
}

unsigned char *sub_10080AECC@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unsigned __int16 v2 = operator new(1uLL);
  *a1 = v2;
  *unsigned __int16 v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10080AF0C(uint64_t a1, dispatch_object_t *a2)
{
  unsigned __int16 v2 = *(void **)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10080A594(v2, v3);
  }
  BOOL v4 = *(void **)(a1 + 8);

  sub_10080A594(v4, 0);
}

uint64_t sub_10080AF90()
{
  return 0;
}

uint64_t sub_10080AF98()
{
  return 1;
}

uint64_t sub_10080AFA0()
{
  return 0;
}

void sub_10080AFAC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_10080B088(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void **)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

uint64_t *sub_10080B198(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 56));
  (*(void (**)(void))(**(void **)(v2 + 72) + 24))(*(void *)(v2 + 72));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10080B244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10080B260(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_10003E168(buf, (void *)v2);
  uint64_t v5 = *(void *)buf;
  BOOL v4 = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v4);
  }
  uint64_t v6 = *(void *)(v2 + 72);
  uint64_t v7 = *(NSObject **)(v2 + 16);
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = operator new(0x20uLL);
  void *v8 = off_101A0CD38;
  v8[1] = v2;
  _DWORD v8[2] = v5;
  v8[3] = v4;
  v19[3] = v8;
  (*(void (**)(uint64_t, dispatch_object_t *, void *))(*(void *)v6 + 16))(v6, &object, v19);
  sub_10003B34C(v19);
  if (object) {
    dispatch_release(object);
  }
  Registry::createRestModuleOneTimeUseConnection(&v14, *(Registry **)(v2 + 40));
  ctu::RestModule::connect();
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  int v9 = (uint8_t *)operator new(0x20uLL);
  *(void *)int v9 = off_101A0CDB8;
  *((void *)v9 + 1) = v2;
  *((void *)v9 + 2) = sub_10080AA9C;
  *((void *)v9 + 3) = 0;
  unint64_t v22 = v9;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v18 < 0) {
    operator delete(__p);
  }
  *(void *)int buf = off_101A0CE38;
  int64_t v21 = (std::__shared_weak_count *)(v2 + 56);
  unint64_t v22 = buf;
  sub_10080BCD4(buf, (void *)(v2 + 112));
  sub_10080AC40(buf);
  uint64_t v10 = *(void *)(v2 + 136);
  if (v10) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v2 + 144);
  }
  sub_100ED03D0((void *)v2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_100088C88(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_10080B4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  sub_10003F600(&a24);
  if (a19 < 0) {
    operator delete(__p);
  }
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_10080B598(void *a1)
{
  *a1 = off_101A0CD38;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10080B5E4(void *a1)
{
  *a1 = off_101A0CD38;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10080B650(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A0CD38;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10080B6B4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A0CD38;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10080B6F4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10080B704(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10080B744(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (!v2) {
    return;
  }
  uint64_t v3 = a1[1];
  BOOL v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return;
  }
  uint64_t v5 = v4;
  if (a1[2])
  {
    int v6 = sub_10080A688(v3);
    unsigned int v7 = (*(unsigned __int16 (**)(void))(**(void **)(v3 + 72) + 40))(*(void *)(v3 + 72));
    if (v7 <= 0x100) {
      unsigned __int8 v8 = 0;
    }
    else {
      unsigned __int8 v8 = v7;
    }
    int v9 = v7 > 0xFF;
    unsigned int v10 = v8 | (v9 << 8);
    uint32_t v11 = (_WORD *)(v3 + 104);
    __int16 v16 = v8 | (unsigned __int16)((_WORD)v9 << 8);
    if (v10 < 0x100 || *(unsigned char *)(v3 + 105) && *(unsigned __int8 *)(v3 + 104) == v8)
    {
      if (!v6) {
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v12 = *(NSObject **)(v3 + 32);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136315650;
        char v18 = "Low Power";
        __int16 v19 = 2080;
        uint64_t v20 = printers::asString();
        __int16 v21 = 2080;
        uint64_t v22 = printers::asString();
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N %s mode is changing from %s to %s", buf, 0x20u);
        LOWORD(v10) = v16;
      }
      *uint32_t v11 = v10;
    }
    int v13 = *(_DWORD *)(v3 + 144);
    if (v13 == 2)
    {
      BOOL v14 = 1;
    }
    else if (*(unsigned char *)(v3 + 105))
    {
      BOOL v14 = *(unsigned char *)v11 != 0;
    }
    else
    {
      if (v13 != 1)
      {
        __int16 v15 = *(NSObject **)(v3 + 32);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not determine if airplane mode is enabled or not!", buf, 2u);
        }
        goto LABEL_23;
      }
      BOOL v14 = 0;
    }
    sub_10080A820((void *)v3, v14);
  }
LABEL_23:

  sub_10004D2C8(v5);
}

void sub_10080B98C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10080B9A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080B9E0()
{
}

void sub_10080B9F0()
{
}

__n128 sub_10080BA04(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A0CDB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10080BA58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0CDB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10080BA90(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10080BAB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080BAF8()
{
}

void sub_10080BB08()
{
}

void *sub_10080BB1C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A0CE38;
  result[1] = v3;
  return result;
}

uint64_t sub_10080BB64(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0CE38;
  a2[1] = v2;
  return result;
}

void sub_10080BB90(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/airplane_mode_user_preference");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_10080BC44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10080BC88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080BCC8()
{
}

void *sub_10080BCD4(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_10080BF3C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10080BF48(uint64_t **a1)
{
  unsigned int v7 = a1;
  uint64_t v1 = **a1;
  int v2 = *(NSObject **)(v1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  unsigned int v3 = (*(unsigned __int16 (**)(void))(**(void **)(v1 + 72) + 40))(*(void *)(v1 + 72));
  if (v3 <= 0x100) {
    unsigned __int8 v4 = 0;
  }
  else {
    unsigned __int8 v4 = v3;
  }
  *(_WORD *)(v1 + 104) = v4 | ((v3 > 0xFF) << 8);
  sub_10080A688(v1);
  int v5 = *(_DWORD *)(v1 + 144);
  if (v5 == 2)
  {
    BOOL v6 = 1;
  }
  else if (*(unsigned char *)(v1 + 105))
  {
    BOOL v6 = *(unsigned char *)(v1 + 104) != 0;
  }
  else
  {
    if (v5 != 1) {
      goto LABEL_13;
    }
    BOOL v6 = 0;
  }
  sub_10080A820((void *)v1, v6);
LABEL_13:
  operator delete();
}

void sub_10080C070()
{
}

void sub_10080C0A0()
{
}

void *sub_10080C0B4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A0CEC8;
  result[1] = v3;
  return result;
}

uint64_t sub_10080C0FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0CEC8;
  a2[1] = v2;
  return result;
}

void sub_10080C128(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      unsigned __int8 v4 = "is";
    }
    else {
      unsigned __int8 v4 = "is NOT";
    }
    int v5 = 136315138;
    BOOL v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Airplane mode assertion %s granted", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_10080C1E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10080C224()
{
}

void sub_10080C230(Registry **a1@<X0>, os_log_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  char v8 = ServiceMap;
  if (v9 < 0)
  {
    unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_11:
    std::mutex::unlock(v8);
    BOOL v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v15 = v13[3];
  BOOL v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15)
  {
LABEL_7:
    uint64_t v17 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to parse client attestation XML - client factory not present", buf, 2u);
    }
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 32) = 0;
    goto LABEL_31;
  }
LABEL_12:
  int v18 = *((char *)a3 + 23);
  if (v18 >= 0) {
    __int16 v19 = a3;
  }
  else {
    __int16 v19 = (uint64_t *)*a3;
  }
  if (v18 >= 0) {
    uint64_t v20 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v20 = a3[1];
  }
  __int16 v21 = +[NSData nonOwningDataWithBytes:v19 length:v20];
  uint64_t v22 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Decoding client attestation XML document using BlastDoor", buf, 2u);
  }
  unint64_t v42 = 0;
  v43[0] = 0;
  uint64_t v41 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v15 + 16))(&v41, v15);
  long long v39 = 0u;
  long long v40 = 0u;
  *(void *)int buf = 0;
  *(void *)&uint8_t buf[8] = v43;
  (*(void (**)(long long *__return_ptr))(*(void *)v41 + 48))(&v39);
  sub_100128064((const void **)buf);
  uint64_t v23 = v43[0];
  if (v43[0]) {
    unint64_t v24 = sub_10039195C;
  }
  else {
    unint64_t v24 = 0;
  }
  if (v24)
  {
    uint64_t v25 = *a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_DWORD *)int buf = 138412290;
    *(void *)&uint8_t buf[4] = v23;
    int64_t v36 = "Failed to unpack client attestation: %@";
    unint64_t v37 = v25;
    uint32_t v38 = 12;
LABEL_56:
    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v36, buf, v38);
    goto LABEL_25;
  }
  if (!BYTE8(v40))
  {
    uint64_t v35 = *a2;
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_WORD *)int buf = 0;
    int64_t v36 = "Client attestation unpacking succeeded, but there was no payload";
    unint64_t v37 = v35;
    uint32_t v38 = 2;
    goto LABEL_56;
  }
  uint64_t v27 = *((void *)&v39 + 1);
  uint64_t v26 = v39;
  if ((void)v39 != *((void *)&v39 + 1))
  {
    while (1)
    {
      __int16 v28 = (const char *)[@"apple-appattest" UTF8String];
      uint64_t v29 = v28;
      int v30 = *(char *)(v26 + 31);
      size_t v31 = v30 >= 0 ? *(unsigned __int8 *)(v26 + 31) : *(void *)(v26 + 16);
      if (v31 == strlen(v28))
      {
        __int16 v32 = v30 >= 0 ? (const void *)(v26 + 8) : *(const void **)(v26 + 8);
        if (!memcmp(v32, v29, v31)) {
          break;
        }
      }
      v26 += 56;
      if (v26 == v27)
      {
        uint64_t v26 = v27;
        break;
      }
    }
    if (v26 != *((void *)&v39 + 1))
    {
      uint64_t v33 = *(void *)(v26 + 32);
      uint64_t v34 = *(void *)(v26 + 40);
      if (v33 != v34)
      {
        while (!*(unsigned char *)(v33 + 24))
        {
          v33 += 32;
          if (v33 == v34) {
            goto LABEL_25;
          }
        }
      }
      if (v33 != v34)
      {
        *(void *)int buf = *(void *)v26;
        *(_OWORD *)&uint8_t buf[8] = 0uLL;
        uint64_t v45 = 0;
        sub_10005C928(&buf[8], *(const void **)v33, *(void *)(v33 + 8), *(void *)(v33 + 8) - *(void *)v33);
        *(void *)a4 = *(void *)buf;
        *(_OWORD *)(a4 + 8) = *(_OWORD *)&buf[8];
        *(void *)(a4 + 24) = v45;
        *(unsigned char *)(a4 + 32) = 1;
        goto LABEL_26;
      }
    }
  }
LABEL_25:
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 32) = 0;
LABEL_26:
  if (BYTE8(v40))
  {
    *(void *)int buf = &v39;
    sub_10080CC38((void ***)buf);
  }
  if (v42) {
    sub_10004D2C8(v42);
  }
  sub_100127D74(v43);

LABEL_31:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_10080C65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, std::__shared_weak_count *a14, const void *a15, void **a16)
{
  if (a12)
  {
    a16 = (void **)&a9;
    sub_10080CC38(&a16);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100127D74(&a15);

  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10080C6FC@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  memset(v23, 0, sizeof(v23));
  long long v22 = 0u;
  sub_10004BD84((uint64_t)&v22);
  sub_100058DB0(__p, "--boundary");
  sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  std::string::size_type v21 = 0;
  std::to_string(&v18, *a1);
  unsigned __int8 v4 = std::string::insert(&v18, 0, "Content-Disposition: form-data; name=\"client_authenticity_result_", 0x41uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  BOOL v6 = std::string::append(&v19, "\"", 1uLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  std::string::size_type v21 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  sub_1010E716C((uint64_t)&v22, (uint64_t)__p);
  sub_100058DB0(&v19, "Content-Type: text/plain");
  sub_1010E716C((uint64_t)&v22, (uint64_t)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  sub_10004B96C(v23, (uint64_t)"\r\n", 2);
  sub_100058DB0(&v19, "{");
  sub_1010E716C((uint64_t)&v22, (uint64_t)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  std::operator+<char>();
  char v8 = std::string::append(&v18, "\",", 2uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  sub_1010E716C((uint64_t)&v22, (uint64_t)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  std::operator+<char>();
  unsigned int v10 = std::string::append(&v18, "\"", 1uLL);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  sub_1010E716C((uint64_t)&v22, (uint64_t)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  sub_100058DB0(&v19, "}");
  sub_1010E716C((uint64_t)&v22, (uint64_t)&v19);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  sub_100058DB0(&v18, "--boundary");
  unsigned int v12 = std::string::append(&v18, "--", 2uLL);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v19.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v14 = &v19;
  }
  else {
    BOOL v14 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v19.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v19.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v23, (uint64_t)v14, size);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  sub_10004BC98((uint64_t)v23 + 8, a2);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  *(void *)((char *)&v23[-1]
  *(void *)&v23[0] = v16;
  if (SHIBYTE(v25) < 0) {
    operator delete(*((void **)&v24 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10080CB64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_10008248C((uint64_t)&a30);
  _Unwind_Resume(a1);
}

void sub_10080CC38(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned __int8 v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = *((void *)v4 - 3);
        if (v6)
        {
          uint64_t v7 = *((void *)v4 - 2);
          char v8 = (void *)*((void *)v4 - 3);
          if (v7 != v6)
          {
            do
            {
              if (*(unsigned char *)(v7 - 8))
              {
                long long v9 = *(void **)(v7 - 32);
                if (v9)
                {
                  *(void *)(v7 - 24) = v9;
                  operator delete(v9);
                }
              }
              v7 -= 32;
            }
            while (v7 != v6);
            char v8 = (void *)*((void *)v4 - 3);
          }
          *((void *)v4 - 2) = v6;
          operator delete(v8);
        }
        if (*(v4 - 25) < 0) {
          operator delete(*((void **)v4 - 6));
        }
        v4 -= 56;
      }
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_10080CD18(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  *(void *)&long long v8 = *a2;
  *((void *)&v8 + 1) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100023950((uint64_t)v9, a3);
  sub_100058DB0(&__p, "/helper/requests/is_icloud_signed_in_with_encryption");
  xpc_object_t object = xpc_null_create();
  long long v10 = v8;
  long long v8 = 0uLL;
  sub_100023950((uint64_t)v11, (uint64_t)v9);
  long long v13 = 0;
  unsigned __int8 v4 = (char *)operator new(0x38uLL);
  *(void *)unsigned __int8 v4 = off_101A0D060;
  *(_OWORD *)(v4 + 8) = v10;
  long long v10 = 0uLL;
  sub_100023950((uint64_t)(v4 + 24), (uint64_t)v11);
  long long v13 = v4;
  ctu::RestModule::sendRequest();
  sub_10003F600(v12);
  sub_100060644(v11);
  if (*((void *)&v10 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
  }
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  sub_100060644(v9);
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
}

void sub_10080CE80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080CEE8(uint64_t a1)
{
  sub_100060644((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080CF20(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  *(void *)&long long v8 = *a2;
  *((void *)&v8 + 1) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100023950((uint64_t)v9, a3);
  sub_100058DB0(&__p, "/helper/requests/is_zone_existing");
  xpc_object_t object = xpc_null_create();
  long long v10 = v8;
  long long v8 = 0uLL;
  sub_100023950((uint64_t)v11, (uint64_t)v9);
  long long v13 = 0;
  unsigned __int8 v4 = (char *)operator new(0x38uLL);
  *(void *)unsigned __int8 v4 = off_101A0D0E0;
  *(_OWORD *)(v4 + 8) = v10;
  long long v10 = 0uLL;
  sub_100023950((uint64_t)(v4 + 24), (uint64_t)v11);
  long long v13 = v4;
  ctu::RestModule::sendRequest();
  sub_10003F600(v12);
  sub_100060644(v11);
  if (*((void *)&v10 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
  }
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  sub_100060644(v9);
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
}

void sub_10080D088(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080D0F0(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = a2[1];
  *(void *)&long long v14 = *a2;
  *((void *)&v14 + 1) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100023950((uint64_t)v15, a4);
  xpc_object_t v13 = 0;
  unint64_t v6 = rest::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v13, (ctu::rest::detail *)a3, v6, v7);
  sub_100058DB0(&__p, "/helper/requests/subscribe_record_change");
  xpc_object_t object = v13;
  xpc_object_t v8 = xpc_null_create();
  long long v16 = v14;
  xpc_object_t v13 = v8;
  long long v14 = 0uLL;
  sub_100023950((uint64_t)v17, (uint64_t)v15);
  std::string v19 = 0;
  long long v9 = (char *)operator new(0x38uLL);
  *(void *)long long v9 = off_101A0D160;
  *(_OWORD *)(v9 + 8) = v16;
  long long v16 = 0uLL;
  sub_100023950((uint64_t)(v9 + 24), (uint64_t)v17);
  std::string v19 = v9;
  ctu::RestModule::sendRequest();
  sub_10003F600(v18);
  sub_100060644(v17);
  if (*((void *)&v16 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v16 + 1));
  }
  xpc_release(object);
  if (v12 < 0) {
    operator delete(__p);
  }
  xpc_release(v13);
  sub_100060644(v15);
  if (*((void *)&v14 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
  }
}

void sub_10080D288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080D308(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  *(void *)&long long v8 = *a2;
  *((void *)&v8 + 1) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10080E824((uint64_t)v9, a3);
  sub_100058DB0(&__p, "/helper/requests/fetch_remote_device_info");
  xpc_object_t object = xpc_null_create();
  long long v10 = v8;
  long long v8 = 0uLL;
  sub_10080E824((uint64_t)v11, (uint64_t)v9);
  xpc_object_t v13 = 0;
  unsigned __int8 v4 = (char *)operator new(0x38uLL);
  *(void *)unsigned __int8 v4 = off_101A0D1E0;
  *(_OWORD *)(v4 + 8) = v10;
  long long v10 = 0uLL;
  sub_10080E824((uint64_t)(v4 + 24), (uint64_t)v11);
  xpc_object_t v13 = v4;
  ctu::RestModule::sendRequest();
  sub_10003F600(v12);
  sub_1003425A0(v11);
  if (*((void *)&v10 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
  }
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  sub_1003425A0(v9);
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
}

void sub_10080D470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080D4D8(uint64_t a1)
{
  sub_1003425A0((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080D510(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  *(void *)&long long v11 = *a2;
  *((void *)&v11 + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10042E708((uint64_t)v12, a4);
  xpc_object_t v10 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/helper/requests/update_remote_device_info");
  xpc_object_t object = v10;
  xpc_object_t v5 = xpc_null_create();
  long long v13 = v11;
  xpc_object_t v10 = v5;
  long long v11 = 0uLL;
  sub_10042E708((uint64_t)v14, (uint64_t)v12);
  long long v16 = 0;
  unint64_t v6 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v6 = off_101A0D260;
  *(_OWORD *)(v6 + 8) = v13;
  long long v13 = 0uLL;
  sub_10042E708((uint64_t)(v6 + 24), (uint64_t)v14);
  long long v16 = v6;
  ctu::RestModule::sendRequest();
  sub_10003F600(v15);
  sub_100322EB8(v14);
  if (*((void *)&v13 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
  }
  xpc_release(object);
  if (v9 < 0) {
    operator delete(__p);
  }
  xpc_release(v10);
  sub_100322EB8(v12);
  if (*((void *)&v11 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v11 + 1));
  }
}

void sub_10080D69C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080D71C(uint64_t a1)
{
  sub_100322EB8((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080D754(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  *(void *)&long long v11 = *a2;
  *((void *)&v11 + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100023950((uint64_t)v12, a4);
  xpc_object_t v10 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/helper/requests/delete_remote_device_info_for_record");
  xpc_object_t object = v10;
  xpc_object_t v5 = xpc_null_create();
  long long v13 = v11;
  xpc_object_t v10 = v5;
  long long v11 = 0uLL;
  sub_100023950((uint64_t)v14, (uint64_t)v12);
  long long v16 = 0;
  unint64_t v6 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v6 = off_101A0D2E0;
  *(_OWORD *)(v6 + 8) = v13;
  long long v13 = 0uLL;
  sub_100023950((uint64_t)(v6 + 24), (uint64_t)v14);
  long long v16 = v6;
  ctu::RestModule::sendRequest();
  sub_10003F600(v15);
  sub_100060644(v14);
  if (*((void *)&v13 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
  }
  xpc_release(object);
  if (v9 < 0) {
    operator delete(__p);
  }
  xpc_release(v10);
  sub_100060644(v12);
  if (*((void *)&v11 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v11 + 1));
  }
}

void sub_10080D8E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080D960(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  *(void *)&long long v11 = *a2;
  *((void *)&v11 + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100023950((uint64_t)v12, a4);
  xpc_object_t v10 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/helper/requests/delete_remote_device_info_for_zone");
  xpc_object_t object = v10;
  xpc_object_t v5 = xpc_null_create();
  long long v13 = v11;
  xpc_object_t v10 = v5;
  long long v11 = 0uLL;
  sub_100023950((uint64_t)v14, (uint64_t)v12);
  long long v16 = 0;
  unint64_t v6 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v6 = off_101A0D360;
  *(_OWORD *)(v6 + 8) = v13;
  long long v13 = 0uLL;
  sub_100023950((uint64_t)(v6 + 24), (uint64_t)v14);
  long long v16 = v6;
  ctu::RestModule::sendRequest();
  sub_10003F600(v15);
  sub_100060644(v14);
  if (*((void *)&v13 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
  }
  xpc_release(object);
  if (v9 < 0) {
    operator delete(__p);
  }
  xpc_release(v10);
  sub_100060644(v12);
  if (*((void *)&v11 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v11 + 1));
  }
}

void sub_10080DAEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080DB6C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  *(void *)&long long v8 = *a2;
  *((void *)&v8 + 1) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10080F5DC((uint64_t)v9, a3);
  sub_100058DB0(&__p, "/helper/requests/cellular_plan_fetch_remote_blacklist_info");
  xpc_object_t object = xpc_null_create();
  long long v10 = v8;
  long long v8 = 0uLL;
  sub_10080F5DC((uint64_t)v11, (uint64_t)v9);
  long long v13 = 0;
  uint64_t v4 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v4 = off_101A0D3E0;
  *(_OWORD *)(v4 + 8) = v10;
  long long v10 = 0uLL;
  sub_10080F5DC((uint64_t)(v4 + 24), (uint64_t)v11);
  long long v13 = v4;
  ctu::RestModule::sendRequest();
  sub_10003F600(v12);
  sub_1003216C8(v11);
  if (*((void *)&v10 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
  }
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  sub_1003216C8(v9);
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
}

void sub_10080DCD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080DD3C(uint64_t a1)
{
  sub_1003216C8((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080DD74(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  *(void *)&long long v11 = *a2;
  *((void *)&v11 + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10042E708((uint64_t)v12, a4);
  xpc_object_t v10 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/helper/requests/cellular_plan_update_blacklist_info");
  xpc_object_t object = v10;
  xpc_object_t v5 = xpc_null_create();
  long long v13 = v11;
  xpc_object_t v10 = v5;
  long long v11 = 0uLL;
  sub_10042E708((uint64_t)v14, (uint64_t)v12);
  long long v16 = 0;
  unint64_t v6 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v6 = off_101A0D460;
  *(_OWORD *)(v6 + 8) = v13;
  long long v13 = 0uLL;
  sub_10042E708((uint64_t)(v6 + 24), (uint64_t)v14);
  long long v16 = v6;
  ctu::RestModule::sendRequest();
  sub_10003F600(v15);
  sub_100322EB8(v14);
  if (*((void *)&v13 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v13 + 1));
  }
  xpc_release(object);
  if (v9 < 0) {
    operator delete(__p);
  }
  xpc_release(v10);
  sub_100322EB8(v12);
  if (*((void *)&v11 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v11 + 1));
  }
}

void sub_10080DF00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080DF84()
{
}

void *sub_10080DF98(void *a1)
{
  *a1 = off_101A0D060;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080DFE8(void *a1)
{
  *a1 = off_101A0D060;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080E058(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D060;
  sub_10080E1F8(v2 + 1, v1);
  return v2;
}

void sub_10080E0AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080E0C0(uint64_t a1, void *a2)
{
  *a2 = off_101A0D060;
  return sub_10080E1F8(a2 + 1, (void *)(a1 + 8));
}

void sub_10080E0EC(uint64_t a1)
{
}

void sub_10080E0F4(void *a1)
{
  sub_10080E258((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080E130(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  char v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  sub_1000607A8(a1 + 24, v4);
  xpc_release(object);
}

void sub_10080E194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10080E1AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080E1EC()
{
}

void *sub_10080E1F8(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080E240(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080E258(uint64_t a1)
{
  sub_100060644((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_10080E2A4(void *a1)
{
  *a1 = off_101A0D0E0;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080E2F4(void *a1)
{
  *a1 = off_101A0D0E0;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080E364(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D0E0;
  sub_10080E504(v2 + 1, v1);
  return v2;
}

void sub_10080E3B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080E3CC(uint64_t a1, void *a2)
{
  *a2 = off_101A0D0E0;
  return sub_10080E504(a2 + 1, (void *)(a1 + 8));
}

void sub_10080E3F8(uint64_t a1)
{
}

void sub_10080E400(void *a1)
{
  sub_10080E258((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080E43C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  char v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  sub_1000607A8(a1 + 24, v4);
  xpc_release(object);
}

void sub_10080E4A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10080E4B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080E4F8()
{
}

void *sub_10080E504(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080E54C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10080E564(void *a1)
{
  *a1 = off_101A0D160;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080E5B4(void *a1)
{
  *a1 = off_101A0D160;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080E624(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D160;
  sub_10080E7C4(v2 + 1, v1);
  return v2;
}

void sub_10080E678(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080E68C(uint64_t a1, void *a2)
{
  *a2 = off_101A0D160;
  return sub_10080E7C4(a2 + 1, (void *)(a1 + 8));
}

void sub_10080E6B8(uint64_t a1)
{
}

void sub_10080E6C0(void *a1)
{
  sub_10080E258((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080E6FC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  char v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  sub_1000607A8(a1 + 24, v4);
  xpc_release(object);
}

void sub_10080E760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10080E778(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080E7B8()
{
}

void *sub_10080E7C4(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080E80C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080E824(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_10080E8A4(void *a1)
{
  *a1 = off_101A0D1E0;
  sub_1003425A0(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080E8F4(void *a1)
{
  *a1 = off_101A0D1E0;
  sub_1003425A0(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080E964(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D1E0;
  sub_10080EC00(v2 + 1, v1);
  return v2;
}

void sub_10080E9B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080E9CC(uint64_t a1, void *a2)
{
  *a2 = off_101A0D1E0;
  return sub_10080EC00(a2 + 1, (void *)(a1 + 8));
}

void sub_10080E9F8(uint64_t a1)
{
}

void sub_10080EA00(void *a1)
{
  sub_10080ECF8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080EA3C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v7 = 0x1388000000000;
  rest::read_rest_value();
  uint64_t v5 = 0;
  long long v6 = 0uLL;
  long long v9 = 0uLL;
  uint64_t v8 = 0;
  uint64_t v10 = 0x1388000000000;
  memset(v11, 0, sizeof(v11));
  sub_1003422D4(v11, 0, 0, 0);
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v10);
  char v12 = (void **)v11;
  sub_10034251C(&v12);
  uint64_t v10 = (uint64_t)&v5;
  sub_10034251C((void ***)&v10);
  uint64_t v10 = (uint64_t)&v8;
  sub_10034251C((void ***)&v10);
  xpc_release(object);
}

void sub_10080EB64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  *(void *)(v11 - 40) = v10;
  sub_10034251C((void ***)(v11 - 40));
  *(void *)(v11 - 40) = v9;
  sub_10034251C((void ***)(v11 - 40));
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_10080EBB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080EBF4()
{
}

void *sub_10080EC00(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10080EC60((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080EC48(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080EC60(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10080ECF8(uint64_t a1)
{
  sub_1003425A0((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_10080ED44(void *a1)
{
  *a1 = off_101A0D260;
  sub_100322EB8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080ED94(void *a1)
{
  *a1 = off_101A0D260;
  sub_100322EB8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080EE04(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D260;
  sub_10080EFB0(v2 + 1, v1);
  return v2;
}

void sub_10080EE58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080EE6C(uint64_t a1, void *a2)
{
  *a2 = off_101A0D260;
  return sub_10080EFB0(a2 + 1, (void *)(a1 + 8));
}

void sub_10080EE98(uint64_t a1)
{
}

void sub_10080EEA0(void *a1)
{
  sub_10080F010((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080EEDC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  rest::read_rest_value();
  sub_100426B48(a1 + 24, 0x1388000000000);
  xpc_release(object);
}

void sub_10080EF4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

uint64_t sub_10080EF64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080EFA4()
{
}

void *sub_10080EFB0(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10042ECAC((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080EFF8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080F010(uint64_t a1)
{
  sub_100322EB8((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_10080F05C(void *a1)
{
  *a1 = off_101A0D2E0;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080F0AC(void *a1)
{
  *a1 = off_101A0D2E0;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080F11C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D2E0;
  sub_10080F2BC(v2 + 1, v1);
  return v2;
}

void sub_10080F170(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080F184(uint64_t a1, void *a2)
{
  *a2 = off_101A0D2E0;
  return sub_10080F2BC(a2 + 1, (void *)(a1 + 8));
}

void sub_10080F1B0(uint64_t a1)
{
}

void sub_10080F1B8(void *a1)
{
  sub_10080E258((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080F1F4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  char v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  sub_1000607A8(a1 + 24, v4);
  xpc_release(object);
}

void sub_10080F258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10080F270(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080F2B0()
{
}

void *sub_10080F2BC(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080F304(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10080F31C(void *a1)
{
  *a1 = off_101A0D360;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080F36C(void *a1)
{
  *a1 = off_101A0D360;
  sub_100060644(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080F3DC(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D360;
  sub_10080F57C(v2 + 1, v1);
  return v2;
}

void sub_10080F430(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080F444(uint64_t a1, void *a2)
{
  *a2 = off_101A0D360;
  return sub_10080F57C(a2 + 1, (void *)(a1 + 8));
}

void sub_10080F470(uint64_t a1)
{
}

void sub_10080F478(void *a1)
{
  sub_10080E258((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080F4B4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  char v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  sub_1000607A8(a1 + 24, v4);
  xpc_release(object);
}

void sub_10080F518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10080F530(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080F570()
{
}

void *sub_10080F57C(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080F5C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080F5DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_10080F65C(void *a1)
{
  *a1 = off_101A0D3E0;
  sub_1003216C8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080F6AC(void *a1)
{
  *a1 = off_101A0D3E0;
  sub_1003216C8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080F71C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D3E0;
  sub_10080F9B8(v2 + 1, v1);
  return v2;
}

void sub_10080F770(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080F784(uint64_t a1, void *a2)
{
  *a2 = off_101A0D3E0;
  return sub_10080F9B8(a2 + 1, (void *)(a1 + 8));
}

void sub_10080F7B0(uint64_t a1)
{
}

void sub_10080F7B8(void *a1)
{
  sub_10080FA80((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080F7F4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  uint64_t v7 = 0x1388000000000;
  rest::read_rest_value();
  uint64_t v5 = 0;
  long long v6 = 0uLL;
  long long v9 = 0uLL;
  uint64_t v8 = 0;
  uint64_t v10 = 0x1388000000000;
  memset(v11, 0, sizeof(v11));
  sub_100322898(v11, 0, 0, 0);
  uint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v10);
  char v12 = (void **)v11;
  sub_10010DF1C(&v12);
  uint64_t v10 = (uint64_t)&v5;
  sub_10010DF1C((void ***)&v10);
  uint64_t v10 = (uint64_t)&v8;
  sub_10010DF1C((void ***)&v10);
  xpc_release(object);
}

void sub_10080F91C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  *(void *)(v11 - 40) = v10;
  sub_10010DF1C((void ***)(v11 - 40));
  *(void *)(v11 - 40) = v9;
  sub_10010DF1C((void ***)(v11 - 40));
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t sub_10080F96C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080F9AC()
{
}

void *sub_10080F9B8(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[5];
  if (v4)
  {
    if ((void *)v4 == a2 + 2)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void, void *))(*(void *)a2[5] + 24))(a2[5], a1 + 2);
      return a1;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  a1[5] = v4;
  return a1;
}

void sub_10080FA68(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10080FA80(uint64_t a1)
{
  sub_1003216C8((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void *sub_10080FACC(void *a1)
{
  *a1 = off_101A0D460;
  sub_100322EB8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10080FB1C(void *a1)
{
  *a1 = off_101A0D460;
  sub_100322EB8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10080FB8C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A0D460;
  sub_10080FD38(v2 + 1, v1);
  return v2;
}

void sub_10080FBE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10080FBF4(uint64_t a1, void *a2)
{
  *a2 = off_101A0D460;
  return sub_10080FD38(a2 + 1, (void *)(a1 + 8));
}

void sub_10080FC20(uint64_t a1)
{
}

void sub_10080FC28(void *a1)
{
  sub_10080F010((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10080FC64(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  rest::read_rest_value();
  sub_100426B48(a1 + 24, 0x1388000000000);
  xpc_release(object);
}

void sub_10080FCD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

uint64_t sub_10080FCEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10080FD2C()
{
}

void *sub_10080FD38(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10042ECAC((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_10080FD80(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10080FD98()
{
  return 0;
}

uint64_t sub_10080FDA0()
{
  return 0;
}

void sub_10080FDA8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_10080FDB8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_10080FDE8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_10080FE10()
{
  return 1;
}

uint64_t sub_10080FE18()
{
  return 1;
}

uint64_t sub_10080FE28()
{
  return 1;
}

void sub_10080FE30(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_10080FE48()
{
  return 1;
}

void sub_10080FE54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t object = xpc_null_create();
  uint64_t v4 = *(void *)(a3 + 24);
  if (!v4) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v4 + 48))(v4, &object);
  xpc_release(object);
}

void sub_10080FECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void sub_10080FEF4()
{
}

const void **sub_10080FF0C@<X0>(unint64_t cf@<X1>, unint64_t a2@<X2>, const void **result@<X0>, unint64_t *a4@<X8>)
{
  if (!(cf | a2))
  {
    *a4 = 0;
    return result;
  }
  if (a2)
  {
    if (!cf)
    {
      *a4 = a2;
      return (const void **)CFRetain((CFTypeRef)a2);
    }
    uint64_t v7 = (uint64_t)result;
    CFPropertyListRef DeepCopy = CFPropertyListCreateDeepCopy(0, (CFPropertyListRef)cf, 1uLL);
    uint64_t v10 = (void *)DeepCopy;
    if (DeepCopy)
    {
      CFTypeID v11 = CFGetTypeID(DeepCopy);
      if (v11 == CFDictionaryGetTypeID())
      {
        std::string v19 = v10;
      }
      else
      {
        std::string v19 = 0;
        CFRelease(v10);
        uint64_t v10 = 0;
      }
    }
    else
    {
      std::string v19 = 0;
    }
    if (v10) {
      char v12 = sub_1000C06D0;
    }
    else {
      char v12 = 0;
    }
    if (v12)
    {
      if (DataUtils::deepMergeDictionary((DataUtils *)v10, (__CFDictionary *)a2, v9))
      {
        sub_10004EFE4(a4, &v19);
        return sub_10005717C(&v19);
      }
      long long v13 = *(NSObject **)(v7 + 56);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
        *(_DWORD *)int buf = 136315394;
        uint64_t v21 = v16;
        __int16 v22 = 2080;
        uint64_t v23 = " ";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sdeepMergeDictionary failed to merge", buf, 0x16u);
        long long v13 = *(NSObject **)(v7 + 56);
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
        *(_DWORD *)int buf = 136315650;
        uint64_t v21 = v17;
        __int16 v22 = 2080;
        uint64_t v23 = " ";
        __int16 v24 = 2112;
        unint64_t v25 = cf;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sorig: %@", buf, 0x20u);
        long long v13 = *(NSObject **)(v7 + 56);
      }
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
LABEL_32:
        *a4 = cf;
        CFRetain((CFTypeRef)cf);
        return sub_10005717C(&v19);
      }
    }
    else
    {
      long long v13 = *(NSObject **)(v7 + 56);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
        *(_DWORD *)int buf = 136315394;
        uint64_t v21 = v14;
        __int16 v22 = 2080;
        uint64_t v23 = " ";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sCFPropertyListCreateDeepCopy failed to copy", buf, 0x16u);
        long long v13 = *(NSObject **)(v7 + 56);
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
        *(_DWORD *)int buf = 136315650;
        uint64_t v21 = v15;
        __int16 v22 = 2080;
        uint64_t v23 = " ";
        __int16 v24 = 2112;
        unint64_t v25 = cf;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sorig: %@", buf, 0x20u);
        long long v13 = *(NSObject **)(v7 + 56);
      }
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_32;
      }
    }
    uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(v7 + 144));
    *(_DWORD *)int buf = 136315650;
    uint64_t v21 = v18;
    __int16 v22 = 2080;
    uint64_t v23 = " ";
    __int16 v24 = 2112;
    unint64_t v25 = a2;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%soverlay: %@", buf, 0x20u);
    goto LABEL_32;
  }

  return (const void **)sub_10004EFAC(a4, (CFTypeRef)cf);
}

void sub_10081031C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100810360(uint64_t a1, uint64_t a2, int a3, NSObject **a4, void *a5, void *a6, uint64_t a7, char *a8)
{
  *(void *)a1 = off_101A5C588;
  *(void *)(a1 + 8) = off_101A2E240;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v23, kCtLoggingSystemName, a8);
  Registry::getLogServer(&v21, *(Registry **)a2);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v15 = *a4;
  *(void *)(a1 + 104) = *a4;
  if (v15) {
    dispatch_retain(v15);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 16) = off_101A0D7E8;
  ctu::OsLogContext::OsLogContext();
  ctu::OsLogContext::OsLogContext();
  ctu::LoggerCommonBase::LoggerCommonBase();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v25);
  *(void *)(a1 + 24) = &off_101A0D868;
  uint64_t v16 = v22;
  *(void *)(a1 + 72) = v21;
  *(void *)(a1 + 80) = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v24);
  *(void *)(a1 + 16) = off_101A0D828;
  if (v22) {
    sub_10004D2C8(v22);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v23);
  *(void *)a1 = off_101A0D540;
  *(void *)(a1 + 8) = off_101A0D610;
  *(void *)(a1 + 16) = off_101A0D6E8;
  *(void *)(a1 + 120) = *(void *)a2;
  uint64_t v17 = *(void *)(a2 + 8);
  *(void *)(a1 + 128) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 136) = a3;
  *(void *)(a1 + 144) = *a6;
  uint64_t v18 = a6[1];
  *(void *)(a1 + 152) = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 160) = a7;
  *(void *)(a1 + 168) = *a5;
  uint64_t v19 = a5[1];
  *(void *)(a1 + 176) = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  return a1;
}

void sub_1008105CC(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  sub_100087E88(v3);
  if (a3) {
    sub_10004D2C8(a3);
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void sub_10081060C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 168);
  uint64_t v2 = **(void **)(a1 + 144);
  int v3 = *(_DWORD *)(v2 + 56);
  uint64_t v4 = v2 + 24;
  sub_10003E168(&v11, (void *)(a1 + 88));
  uint64_t v5 = v12;
  if (v12)
  {
    uint64_t v6 = v11;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v9 = v6;
      uint64_t v10 = v7;
      std::__shared_weak_count::__release_weak(v5);
      sub_10004D2C8(v8);
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  sub_1007FAE00(v1, v3, v4, &v9);
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
}

void sub_1008106E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100810700(uint64_t a1)
{
}

uint64_t sub_100810708(uint64_t a1)
{
  *(void *)a1 = off_101A0D540;
  *(void *)(a1 + 8) = off_101A0D610;
  *(void *)(a1 + 16) = off_101A0D6E8;
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 152);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    sub_10004D2C8(v4);
  }
  *(void *)(a1 + 16) = off_101A0D7E8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  sub_100087E88((void *)(a1 + 88));
  return a1;
}

void sub_100810810(uint64_t a1)
{
}

void sub_10081082C(uint64_t a1)
{
}

uint64_t sub_100810848(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 120));
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v13);
  if (v7)
  {
    uint64_t v9 = (GestaltUtilityInterface *)v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  uint64_t isWatch = GestaltUtilityInterface::isWatch(v9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  return isWatch;
}

void sub_100810930(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10081094C(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    int v4 = 136315394;
    uint64_t v5 = v3;
    __int16 v6 = 2080;
    uint64_t v7 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sstart processing iCloud data", (uint8_t *)&v4, 0x16u);
  }
  *(unsigned char *)(a1 + 232) = 0;
}

uint64_t sub_100810A0C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 232);
  *(unsigned char *)(a1 + 232) = 0;
  uint64_t v3 = *(NSObject **)(a1 + 56);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
      int v9 = 136315394;
      uint64_t v10 = v5;
      __int16 v11 = 2080;
      char v12 = " ";
      __int16 v6 = "#I %s%sfinished processing iCloud data - service evaluation required";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, 0x16u);
    }
  }
  else if (v4)
  {
    uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    int v9 = 136315394;
    uint64_t v10 = v7;
    __int16 v11 = 2080;
    char v12 = " ";
    __int16 v6 = "#I %s%sfinished processing iCloud data - no changes detected";
    goto LABEL_6;
  }
  return (*(uint64_t (**)(uint64_t, void, BOOL))(*(void *)(a1 + 8) + 104))(a1 + 8, 0, v2 != 0);
}

const void **sub_100810B58(uint64_t a1, unsigned int a2, const __CFDictionary *a3, int a4, int a5)
{
  if (a3)
  {
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1);
    (*(void (**)(uint64_t, void))(*(void *)a1 + 184))(a1, (v10 + 1));
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
  }
  uint64_t v11 = *(void *)(a1 + 168);
  unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1);

  return sub_1007FE5B8(v11, a2, a3, v12, (long long *)(a1 + 184), a4, a5);
}

void sub_100810C84(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 144));
    if (*(_DWORD *)(a1 + 136)) {
      BOOL v4 = "Secondary";
    }
    else {
      BOOL v4 = "Primary";
    }
    uint64_t v5 = (void *)(a1 + 208);
    if (*(char *)(a1 + 231) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1);
    int v7 = 136316162;
    uint64_t v8 = v3;
    __int16 v9 = 2080;
    int v10 = " ";
    __int16 v11 = 2080;
    unsigned int v12 = v4;
    __int16 v13 = 2080;
    uint64_t v14 = v5;
    __int16 v15 = 1024;
    int v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fDevType: %s, PhoneNumber: %s, fLastICloudVer: %u", (uint8_t *)&v7, 0x30u);
  }
}

void sub_100810DC4(uint64_t a1)
{
}

char *sub_100810DCC@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[207] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 23), *((void *)result + 24));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 184);
  *(void *)(a2 + 16) = *((void *)result + 25);
  return result;
}

uint64_t sub_100810DF8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 104))();
}

uint64_t sub_100810E24()
{
  return 0;
}

uint64_t sub_100810E2C()
{
  return 0;
}

uint64_t sub_100810E3C(uint64_t a1)
{
  return ctu::LoggerCommonBase::setInheritedLogLevel(a1 + 8);
}

void *sub_100810E48@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "ThumperController");
}

uint64_t sub_100810E58(uint64_t a1)
{
  return ctu::LoggerCommonBase::getLocalLogLevel(a1 + 8);
}

void *sub_100810E60(void *a1)
{
  *a1 = off_101A0D7E8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  return a1;
}

void sub_100810EA4(void *a1)
{
  *a1 = off_101A0D7E8;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();

  operator delete();
}

void *sub_100810F08(void *a1)
{
  *a1 = off_101A0D7E8;
  int v2 = a1 + 9;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  sub_100087E88(v2);
  return a1;
}

void sub_100810F5C(void *a1)
{
  *a1 = off_101A0D7E8;
  uint64_t v1 = a1 + 9;
  ctu::LoggerBase<std::shared_ptr<ctu::LogServer>>::~LoggerBase();
  sub_100087E88(v1);

  operator delete();
}

uint64_t sub_100810FD0(uint64_t a1, void *a2, const void **a3, const void **a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&keys, kCtLoggingSystemName, "cb.update.country.match");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&values, &keys);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)&values);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&values);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&keys);
  *(void *)(a1 + 8) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 16) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100083DA4((const void **)(a1 + 24), a4);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 32) = 0;
  __int16 v9 = (char **)(a1 + 32);
  *(void *)(a1 + 40) = 0;
  int v10 = (char **)(a1 + 40);
  *(void *)(a1 + 48) = 0;
  __int16 v11 = (char **)(a1 + 48);
  *(void *)(a1 + 72) = 0;
  unsigned int v12 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v39 = *(void *)(a1 + 8);
  long long v40 = v12;
  CFTypeRef cf = 0;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058198(&v38, a3);
  sub_1006CF420((os_log_t *)a1, (uint64_t)&v39, (CFDictionaryRef *)&v38, &cf);
  sub_100057D78(&v38);
  if (v40) {
    sub_10004D2C8(v40);
  }
  CFDictionaryRef v13 = (const __CFDictionary *)cf;
  if (cf) {
    uint64_t v14 = sub_100080778;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v14)
  {
    CFDictionaryRef theDict = (CFDictionaryRef)cf;
    if (cf)
    {
      CFRetain(cf);
      CFDictionaryRef v13 = theDict;
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v13, @"CountryId");
    CFDictionaryRef v16 = Value;
    if (Value && (CFTypeID v17 = CFGetTypeID(Value), v17 == CFDictionaryGetTypeID()))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFIndex Count = CFDictionaryGetCount(v16);
      keys.var0 = 0;
      keys.var1.fRef = 0;
      uint64_t v46 = 0;
      sub_10004EE3C(&keys, Count);
      values = 0;
      int v43 = 0;
      uint64_t v44 = 0;
      sub_10004EE3C(&values, Count);
      CFDictionaryGetKeysAndValues(v16, (const void **)keys.var0, (const void **)values);
      if (Count >= 1)
      {
        for (uint64_t i = 0; i != Count; ++i)
        {
          uint64_t v20 = *(const void **)&keys.var0[8 * i];
          if (v20)
          {
            CFTypeID v21 = CFGetTypeID(*(CFTypeRef *)&keys.var0[8 * i]);
            if (v21 != CFStringGetTypeID()) {
              uint64_t v20 = 0;
            }
          }
          CFDictionaryRef v22 = (const __CFDictionary *)values[i];
          if (v22)
          {
            CFTypeID v23 = CFGetTypeID(values[i]);
            if (v23 == CFDictionaryGetTypeID())
            {
              __int16 v24 = CFDictionaryGetValue(v22, @"BundleMapKey");
              unint64_t v25 = v24;
              if (v24)
              {
                CFTypeID v26 = CFGetTypeID(v24);
                if (v26 == CFStringGetTypeID()) {
                  CFDictionarySetValue(Mutable, v20, v25);
                }
              }
            }
          }
        }
      }
      sub_10004EFE4(&v37, (CFTypeRef *)&Mutable);
      if (values)
      {
        int v43 = values;
        operator delete(values);
      }
      if (keys.var0)
      {
        keys.var1.fRef = (os_log_s *)keys.var0;
        operator delete(keys.var0);
      }
      sub_10005717C((const void **)&Mutable);
    }
    else
    {
      unint64_t v37 = 0;
    }
    if (v9 != &v37)
    {
      keys.var0 = *v9;
      GestaltUtilityInterface *v9 = v37;
      unint64_t v37 = 0;
      sub_100057D78((const void **)&keys.var0);
    }
    sub_100057D78((const void **)&v37);
    sub_100057D78((const void **)&theDict);
    values = (void **)CFDictionaryGetValue((CFDictionaryRef)cf, @"BundleMappings");
    keys.var0 = 0;
    sub_10004EFE4(&keys, (CFTypeRef *)&values);
    long long v27 = *v11;
    *__int16 v11 = keys.var0;
    keys.var0 = v27;
    sub_100057D78((const void **)&keys.var0);
    CFDictionaryRef v28 = (const __CFDictionary *)cf;
    CFTypeRef v35 = cf;
    if (cf) {
      CFRetain(cf);
    }
    long long v29 = (void **)CFDictionaryGetValue(v28, @"Bundles");
    long long v30 = v29;
    if (v29 && (CFTypeID v31 = CFGetTypeID(v29), v31 == CFDictionaryGetTypeID()))
    {
      if (CFDictionaryGetCount((CFDictionaryRef)v30))
      {
        values = v30;
        CFRetain(v30);
LABEL_44:
        if (v10 != (char **)&values)
        {
          keys.var0 = *v10;
          *int v10 = (char *)v30;
          values = 0;
          sub_100057D78((const void **)&keys.var0);
        }
        sub_100057D78((const void **)&values);
        sub_100057D78(&v35);
        goto LABEL_47;
      }
      long long v32 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys.var0) = 0;
        long long v33 = "#I Bundles has 0 elements";
        goto LABEL_42;
      }
    }
    else
    {
      long long v32 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys.var0) = 0;
        long long v33 = "#I Bundles is not found in version.xml";
LABEL_42:
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, (uint8_t *)&keys, 2u);
      }
    }
    long long v30 = 0;
    values = 0;
    goto LABEL_44;
  }
LABEL_47:
  sub_100057D78(&cf);
  return a1;
}

void sub_100811440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10, char a11, int a12, const void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, const void *a18, void *a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_10005717C((const void **)(v28 - 88));
  sub_100057D78(&a13);
  sub_100057D78(&a18);
  sub_10005CD2C(v26, *(char **)(v23 + 64));
  sub_100057D78(v27);
  sub_100057D78(v24);
  sub_100057D78(v25);
  sub_1000558F4(a10);
  long long v30 = *(std::__shared_weak_count **)(v23 + 16);
  if (v30) {
    sub_10004D2C8(v30);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v23);
  _Unwind_Resume(a1);
}

const void **sub_100811544@<X0>(uint64_t a1@<X0>, CFDictionaryRef *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v4 = (const void **)(a1 + 32);
  if (*(void *)(a1 + 32)) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5
    || (*(void *)(a1 + 48) ? (int v7 = sub_100080778) : (int v7 = 0),
        !v7 || (*(void *)(a1 + 40) ? (uint64_t v8 = sub_100080778) : (uint64_t v8 = 0), !v8)))
  {
    *(unsigned char *)a3 = 3;
    *(void *)(a3 + 8) = 0;
    buf.__r_.__value_.__r.__words[0] = 0;
    return sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
  }
  CFDictionaryRef Value = (int *)CFDictionaryGetValue(*a2, @"kUpdateBundleType");
  LODWORD(buf.__r_.__value_.__l.__data_) = 0;
  if (Value && (__int16 v11 = Value, v12 = CFGetTypeID(Value), v12 == CFNumberGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&buf, v11, v13);
    std::string::value_type v14 = buf.__r_.__value_.__s.__data_[0];
  }
  else
  {
    std::string::value_type v14 = 0;
  }
  CFDictionaryRef v16 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = asString();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Checking update for %s", (uint8_t *)&buf, 0xCu);
  }
  if (v14 == 3)
  {
    sub_100058198(&v177, (const void **)a2);
    sub_1004D3980((CFDictionaryRef *)&v177, (const __CFDictionary **)&__str);
    if (&__str != (std::string *)a2)
    {
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)*a2;
      *a2 = (CFDictionaryRef)__str.__r_.__value_.__r.__words[0];
      __str.__r_.__value_.__r.__words[0] = 0;
      sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
    }
    sub_100057D78((const void **)&__str.__r_.__value_.__l.__data_);
    sub_100057D78(&v177);
  }
  CFStringRef key = 0;
  std::string::size_type v176 = 0;
  sub_100058198(&v174, v4);
  sub_1006CE9F8((const void **)a1, (Registry **)(a1 + 8), (const __CFDictionary **)&v174, *a2, &__str);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)key;
  CFStringRef key = (void *)__str.__r_.__value_.__r.__words[0];
  __str.__r_.__value_.__r.__words[0] = 0;
  sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
  sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
  sub_100057D78(&v174);
  if (key) {
    uint64_t v18 = sub_1000810B8;
  }
  else {
    uint64_t v18 = 0;
  }
  if (!v18)
  {
    uint64_t v20 = *(NSObject **)a1;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Did not get the bundle Map key to look for the update", (uint8_t *)&buf, 2u);
    }
    *(unsigned char *)a3 = 3;
    *(void *)(a3 + 8) = 0;
    buf.__r_.__value_.__r.__words[0] = 0;
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
    goto LABEL_291;
  }
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)*a2;
  if (__str.__r_.__value_.__r.__words[0])
  {
    CFRetain(__str.__r_.__value_.__l.__data_);
    std::string::size_type v19 = __str.__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type v19 = 0;
  }
  buf.__r_.__value_.__r.__words[0] = v176;
  std::string::size_type v176 = v19;
  __str.__r_.__value_.__r.__words[0] = 0;
  sub_1000577C4((const void **)&buf.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
  CFTypeID v21 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __str = buf;
    p_str = (std::string *)buf.__r_.__value_.__r.__words[0];
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    LODWORD(v186.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v186.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N The best match found from the version.xml is %{public}s", (uint8_t *)&v186, 0xCu);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  v172[0] = 0;
  v172[1] = 0;
  uint64_t v173 = 0;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)key;
  sub_1000292E0((uint64_t)v172);
  sub_100046BAC((uint64_t **)(a1 + 56), v172, (uint64_t)v172);
  if (!v23)
  {
    long long v32 = *(NSObject **)a1;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      long long v33 = v172;
      if (v173 < 0) {
        long long v33 = (void **)v172[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N %{public}s is already covered", (uint8_t *)&buf, 0xCu);
    }
    *(unsigned char *)a3 = 3;
    *(void *)(a3 + 8) = 0;
    buf.__r_.__value_.__r.__words[0] = 0;
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
    goto LABEL_289;
  }
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFTypeRef v25 = cf;
    CFTypeRef cf = Mutable;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
    sub_10005717C((const void **)&buf.__r_.__value_.__l.__data_);
  }
  sub_10010F3F0((__CFDictionary *)cf, @"BundleID", (uint64_t)key);
  uint64_t v170 = 0;
  uint64_t v26 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), key);
  long long v27 = v26;
  if (v26 && (CFTypeID v28 = CFGetTypeID(v26), v28 == CFDictionaryGetTypeID()))
  {
    uint64_t v170 = v27;
    CFRetain(v27);
    CFDictionaryRef v29 = (const __CFDictionary *)v27;
  }
  else
  {
    CFDictionaryRef v29 = 0;
    uint64_t v170 = 0;
  }
  if (v29) {
    long long v30 = sub_100080778;
  }
  else {
    long long v30 = 0;
  }
  if (!v30)
  {
    long long v34 = *(NSObject **)a1;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v159 = v172;
      if (v173 < 0) {
        v159 = (void **)v172[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v159;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "No entry for bundle Map key %{public}s in BundleMappings", (uint8_t *)&buf, 0xCu);
    }
    buf.__r_.__value_.__s.__data_[0] = 3;
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)cf;
    if (cf) {
      CFRetain(cf);
    }
    *(unsigned char *)a3 = 3;
    sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf.__r_.__value_.__l.__size_);
    sub_10005717C((const void **)&buf.__r_.__value_.__l.__size_);
    goto LABEL_288;
  }
  CFDictionaryRef theDict = v29;
  v169 = 0;
  if (v29)
  {
    CFRetain(v29);
    CFDictionaryRef v31 = theDict;
  }
  else
  {
    CFDictionaryRef v31 = 0;
  }
  v169 = 0;
  if (v31) {
    CFTypeRef v35 = sub_100080778;
  }
  else {
    CFTypeRef v35 = 0;
  }
  if (v35)
  {
    uint64_t v181 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
    unint64_t v37 = ServiceMap;
    if ((v38 & 0x8000000000000000) != 0)
    {
      uint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v40 = 5381;
      do
      {
        std::string::size_type v38 = v40;
        unsigned int v41 = *v39++;
        uint64_t v40 = (33 * v40) ^ v41;
      }
      while (v41);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v38;
    unint64_t v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)&buf);
    if (v42)
    {
      uint64_t v44 = v42[3];
      int v43 = (std::__shared_weak_count *)v42[4];
      if (v43)
      {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v37);
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v43);
        char v45 = 0;
        goto LABEL_76;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    std::mutex::unlock(v37);
    int v43 = 0;
    char v45 = 1;
LABEL_76:
    (*(void (**)(__CFString **__return_ptr, uint64_t))(*(void *)v44 + 112))(&v181, v44);
    if ((v45 & 1) == 0) {
      sub_10004D2C8(v43);
    }
    if (v181) {
      uint64_t v47 = sub_1000810B8;
    }
    else {
      uint64_t v47 = 0;
    }
    if (!v47)
    {
      long long v51 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "currentOSVersion is missing.", (uint8_t *)&buf, 2u);
      }
LABEL_210:
      sub_1000558F4((const void **)&v181);
      goto LABEL_211;
    }
    memset(&__str, 0, sizeof(__str));
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __str = buf;
    std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    CFStringRef v49 = &__str;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
      CFStringRef v49 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if (!size) {
      goto LABEL_94;
    }
    std::string::size_type v50 = 0;
    while (v49->__r_.__value_.__s.__data_[v50] != 46)
    {
      if (size == ++v50) {
        goto LABEL_94;
      }
    }
    if (size == v50)
    {
LABEL_94:
      memset(&v186, 0, sizeof(v186));
    }
    else
    {
      memset(&v186, 0, sizeof(v186));
      if (v50 != -1)
      {
        std::string::basic_string(&buf, &__str, 0, v50, (std::allocator<char> *)&keys);
LABEL_98:
        long long v52 = std::string::append(&buf, ".0", 2uLL);
        long long v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
        v186.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v186.__r_.__value_.__l.__data_ = v53;
        v52->__r_.__value_.__l.__size_ = 0;
        v52->__r_.__value_.__r.__words[2] = 0;
        v52->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        uint64_t v180 = 0;
        if ((v186.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v54 = &v186;
        }
        else {
          long long v54 = (std::string *)v186.__r_.__value_.__r.__words[0];
        }
        uint64_t v180 = (__CFString *)CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v54, 0x8000100u);
        CFIndex Count = CFDictionaryGetCount(theDict);
        memset(&keys, 0, sizeof(keys));
        sub_10004EE3C(&keys, Count);
        memset(&values, 0, sizeof(values));
        sub_10004EE3C(&values, Count);
        memset(&v182, 0, sizeof(v182));
        CFDictionaryGetKeysAndValues(theDict, (const void **)keys.__r_.__value_.__l.__data_, (const void **)values.__r_.__value_.__l.__data_);
        if (Count >= 1)
        {
          for (uint64_t i = 0; i != Count; ++i)
          {
            CFDictionaryRef v57 = *(const __CFDictionary **)(values.__r_.__value_.__r.__words[0] + 8 * i);
            if (v57
              && (CFTypeID v58 = CFGetTypeID(*(CFTypeRef *)(values.__r_.__value_.__r.__words[0] + 8 * i)),
                  v58 == CFDictionaryGetTypeID()))
            {
              CFDictionaryRef v59 = (const __CFDictionary *)CFDictionaryGetValue(v57, @"OS");
              CFDictionaryRef v60 = v59;
              if (v59 && (CFTypeID v61 = CFGetTypeID(v59), v61 == CFDictionaryGetTypeID()))
              {
                CFStringRef v62 = (const __CFString *)CFDictionaryGetValue(v60, @"Min");
                CFStringRef v63 = v62;
                if (v62)
                {
                  CFTypeID v64 = CFGetTypeID(v62);
                  if (v64 != CFStringGetTypeID()) {
                    CFStringRef v63 = 0;
                  }
                }
                CFStringRef v65 = (const __CFString *)CFDictionaryGetValue(v60, @"Max");
                CFStringRef v66 = v65;
                if (v65)
                {
                  CFTypeID v67 = CFGetTypeID(v65);
                  if (v67 != CFStringGetTypeID()) {
                    CFStringRef v66 = 0;
                  }
                }
                if (!v63)
                {
                  os_log_t v79 = *(os_log_t *)a1;
                  if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
                    continue;
                  }
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  uint64_t v76 = v79;
                  uint64_t v77 = "OS Dict is missing min OS entry. This is a mandatory key. Skipping";
                  goto LABEL_131;
                }
                if (_CompareBundleVersionStrings(v63, v180) != -1
                  && _CompareBundleVersionStrings(v63, v181) != 1
                  && (!v66 || _CompareBundleVersionStrings(v181, v66) != 1))
                {
                  CFDictionaryRef v68 = (const __CFDictionary *)CFDictionaryGetValue(v57, @"Device");
                  CFDictionaryRef v69 = v68;
                  if (v68)
                  {
                    CFTypeID v70 = CFGetTypeID(v68);
                    if (v70 == CFDictionaryGetTypeID())
                    {
                      CFArrayRef v71 = (const __CFArray *)CFDictionaryGetValue(v69, @"Supported");
                      CFArrayRef v72 = v71;
                      if (v71)
                      {
                        CFTypeID v73 = CFGetTypeID(v71);
                        if (v73 == CFArrayGetTypeID()) {
                          CFArrayRef v74 = v72;
                        }
                        else {
                          CFArrayRef v74 = 0;
                        }
                        CFArrayRef v165 = v74;
                      }
                      else
                      {
                        CFArrayRef v165 = 0;
                      }
                      CFArrayRef v80 = (const __CFArray *)CFDictionaryGetValue(v69, @"UnSupported");
                      CFArrayRef v81 = v80;
                      if (v80)
                      {
                        CFTypeID v82 = CFGetTypeID(v80);
                        if (v82 == CFArrayGetTypeID()) {
                          CFArrayRef v83 = v81;
                        }
                        else {
                          CFArrayRef v83 = 0;
                        }
                        CFArrayRef theArray = v83;
                        if (!v165)
                        {
                          if (v83)
                          {
                            CFIndex v84 = CFArrayGetCount(v83);
                            if (v84 >= 1)
                            {
                              CFIndex v85 = 0;
                              BOOL v86 = 1;
                              while (1)
                              {
                                CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v85);
                                CFStringRef v88 = ValueAtIndex;
                                if (ValueAtIndex)
                                {
                                  CFTypeID v89 = CFGetTypeID(ValueAtIndex);
                                  if (v89 == CFStringGetTypeID()
                                    && CFEqual(v88, *(CFStringRef *)(a1 + 24)))
                                  {
                                    break;
                                  }
                                }
                                BOOL v86 = ++v85 < v84;
                                if (v84 == v85) {
                                  goto LABEL_157;
                                }
                              }
                              if (v86) {
                                continue;
                              }
                            }
                          }
                          goto LABEL_157;
                        }
LABEL_149:
                        CFIndex v90 = CFArrayGetCount(v165);
                        if (v90 < 1) {
                          continue;
                        }
                        CFIndex v91 = 0;
                        BOOL v92 = 1;
                        while (1)
                        {
                          CFStringRef v93 = (const __CFString *)CFArrayGetValueAtIndex(v165, v91);
                          CFStringRef v94 = v93;
                          if (v93)
                          {
                            CFTypeID v95 = CFGetTypeID(v93);
                            if (v95 == CFStringGetTypeID()
                              && CFEqual(v94, *(CFStringRef *)(a1 + 24)))
                            {
                              break;
                            }
                          }
                          BOOL v92 = ++v91 < v90;
                          if (v90 == v91) {
                            goto LABEL_179;
                          }
                        }
                        if (!v92) {
                          continue;
                        }
                      }
                      else if (v165)
                      {
                        goto LABEL_149;
                      }
                    }
                  }
LABEL_157:
                  uint64_t v96 = *(void *)(keys.__r_.__value_.__r.__words[0] + 8 * i);
                  if (v96)
                  {
                    CFTypeID v97 = CFGetTypeID(*(CFTypeRef *)(keys.__r_.__value_.__r.__words[0] + 8 * i));
                    if (v97 == CFStringGetTypeID()) {
                      uint64_t v98 = v96;
                    }
                    else {
                      uint64_t v98 = 0;
                    }
                  }
                  else
                  {
                    uint64_t v98 = 0;
                  }
                  std::string::size_type v99 = v182.__r_.__value_.__l.__size_;
                  if (v182.__r_.__value_.__l.__size_ >= v182.__r_.__value_.__r.__words[2])
                  {
                    uint64_t v101 = (uint64_t)(v182.__r_.__value_.__l.__size_ - v182.__r_.__value_.__r.__words[0]) >> 3;
                    if ((unint64_t)(v101 + 1) >> 61) {
                      sub_10006A748();
                    }
                    unint64_t v102 = (uint64_t)(v182.__r_.__value_.__r.__words[2] - v182.__r_.__value_.__r.__words[0]) >> 2;
                    if (v102 <= v101 + 1) {
                      unint64_t v102 = v101 + 1;
                    }
                    if (v182.__r_.__value_.__r.__words[2] - v182.__r_.__value_.__r.__words[0] >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v103 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v103 = v102;
                    }
                    if (v103) {
                      char v104 = (char *)sub_10004EF74((uint64_t)&v182.__r_.__value_.__r.__words[2], v103);
                    }
                    else {
                      char v104 = 0;
                    }
                    CFDictionaryRef v105 = &v104[8 * v101];
                    *(void *)CFDictionaryRef v105 = v98;
                    std::string::size_type v100 = (std::string::size_type)(v105 + 8);
                    uint64_t v106 = (char *)v182.__r_.__value_.__l.__size_;
                    std::string::size_type v107 = v182.__r_.__value_.__r.__words[0];
                    if (v182.__r_.__value_.__l.__size_ != v182.__r_.__value_.__r.__words[0])
                    {
                      do
                      {
                        uint64_t v108 = *((void *)v106 - 1);
                        v106 -= 8;
                        *((void *)v105 - 1) = v108;
                        v105 -= 8;
                      }
                      while (v106 != (char *)v107);
                      uint64_t v106 = (char *)v182.__r_.__value_.__r.__words[0];
                    }
                    v182.__r_.__value_.__r.__words[0] = (std::string::size_type)v105;
                    v182.__r_.__value_.__l.__size_ = v100;
                    v182.__r_.__value_.__r.__words[2] = (std::string::size_type)&v104[8 * v103];
                    if (v106) {
                      operator delete(v106);
                    }
                  }
                  else
                  {
                    *(void *)v182.__r_.__value_.__l.__size_ = v98;
                    std::string::size_type v100 = v99 + 8;
                  }
                  v182.__r_.__value_.__l.__size_ = v100;
                }
              }
              else
              {
                os_log_t v78 = *(os_log_t *)a1;
                if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  uint64_t v76 = v78;
                  uint64_t v77 = "OS Dict is missing. Not a valid config. Skipping";
                  goto LABEL_131;
                }
              }
            }
            else
            {
              os_log_t v75 = *(os_log_t *)a1;
              if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                uint64_t v76 = v75;
                uint64_t v77 = "criteriaDict is empty";
LABEL_131:
                _os_log_error_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, v77, (uint8_t *)&buf, 2u);
              }
            }
LABEL_179:
            ;
          }
        }
        CFIndex v109 = (void *)v182.__r_.__value_.__r.__words[0];
        if (v182.__r_.__value_.__r.__words[0] != v182.__r_.__value_.__l.__size_)
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1006CEC10;
          sub_10049981C((uint64_t)v182.__r_.__value_.__l.__data_, (char *)v182.__r_.__value_.__l.__size_, (uint64_t (**)(uint64_t, uint64_t))&buf, 126 - 2 * __clz((uint64_t)(v182.__r_.__value_.__l.__size_ - v182.__r_.__value_.__r.__words[0]) >> 3), 1);
          CFDictionaryRef v179 = 0;
          CFDictionaryRef v110 = (const __CFDictionary *)CFDictionaryGetValue(theDict, *(const void **)(v182.__r_.__value_.__l.__size_ - 8));
          CFDictionaryRef v111 = v110;
          if (v110 && (CFTypeID v112 = CFGetTypeID(v110), v112 == CFDictionaryGetTypeID()))
          {
            CFDictionaryRef v179 = v111;
            CFRetain(v111);
            CFDictionaryRef v113 = v179;
          }
          else
          {
            CFDictionaryRef v113 = 0;
            CFDictionaryRef v179 = 0;
          }
          long long v114 = CFDictionaryGetValue(v113, @"BundleMatchEntry");
          std::string::size_type v115 = (std::string::size_type)v114;
          if (v114)
          {
            CFTypeID v116 = CFGetTypeID(v114);
            if (v116 == CFStringGetTypeID()) {
              std::string::size_type v117 = v115;
            }
            else {
              std::string::size_type v117 = 0;
            }
          }
          else
          {
            std::string::size_type v117 = 0;
          }
          buf.__r_.__value_.__r.__words[0] = v117;
          sub_100013168((const void **)&v169, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
          CFMutableArrayRef v118 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            memset(&buf, 0, sizeof(buf));
            ctu::cf::assign();
            std::string __p = buf;
            p_p = &__p;
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)v185 = 136446210;
            *(void *)&v185[4] = p_p;
            _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I Matched bundle entry from BundleMap dict is %{public}s", v185, 0xCu);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          sub_100057D78((const void **)&v179);
          CFIndex v109 = (void *)v182.__r_.__value_.__r.__words[0];
        }
        if (v109)
        {
          v182.__r_.__value_.__l.__size_ = (std::string::size_type)v109;
          operator delete(v109);
        }
        if (values.__r_.__value_.__r.__words[0])
        {
          values.__r_.__value_.__l.__size_ = values.__r_.__value_.__r.__words[0];
          operator delete(values.__r_.__value_.__l.__data_);
        }
        if (keys.__r_.__value_.__r.__words[0])
        {
          keys.__r_.__value_.__l.__size_ = keys.__r_.__value_.__r.__words[0];
          operator delete(keys.__r_.__value_.__l.__data_);
        }
        sub_1000558F4((const void **)&v180);
        if (SHIBYTE(v186.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v186.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        goto LABEL_210;
      }
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __str;
    }
    goto LABEL_98;
  }
  uint64_t v46 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#N bundleMap empty.", (uint8_t *)&buf, 2u);
  }
LABEL_211:
  sub_100057D78((const void **)&theDict);
  if (v169) {
    CFIndex v120 = sub_1000810B8;
  }
  else {
    CFIndex v120 = 0;
  }
  if (!v120)
  {
    CFDictionaryRef v130 = *(NSObject **)a1;
    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "#N No bundleMatchEntry in BundleMap", (uint8_t *)&buf, 2u);
    }
    buf.__r_.__value_.__s.__data_[0] = 3;
    buf.__r_.__value_.__l.__size_ = (std::string::size_type)cf;
    if (cf) {
      CFRetain(cf);
    }
    *(unsigned char *)a3 = 3;
    sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf.__r_.__value_.__l.__size_);
    sub_10005717C((const void **)&buf.__r_.__value_.__l.__size_);
    goto LABEL_287;
  }
  *(void *)v185 = 0;
  CFStringRef v121 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v169);
  long long v122 = v121;
  if (v121 && (CFTypeID v123 = CFGetTypeID(v121), v123 == CFDictionaryGetTypeID()))
  {
    *(void *)v185 = v122;
    CFRetain(v122);
    CFDictionaryRef v124 = *(const __CFDictionary **)v185;
  }
  else
  {
    CFDictionaryRef v124 = 0;
    *(void *)v185 = 0;
  }
  if (v124) {
    v125 = sub_100080778;
  }
  else {
    v125 = 0;
  }
  if (v125)
  {
    CFDictionaryRef v167 = v124;
    if (v124) {
      CFRetain(v124);
    }
    sub_100058198((const void **)&v166, (const void **)a2);
    v126 = CFDictionaryGetValue(v166, @"BundleIDOnTheDevice");
    CFTypeID v127 = v126;
    if (v126)
    {
      CFTypeID v128 = CFGetTypeID(v126);
      if (v128 == CFStringGetTypeID()) {
        uint64_t v129 = v127;
      }
      else {
        uint64_t v129 = 0;
      }
    }
    else
    {
      uint64_t v129 = 0;
    }
    CFStringRef v132 = (const __CFString *)CFDictionaryGetValue(v166, @"BundleVersionOnTheDevice");
    CFStringRef v133 = v132;
    if (v132)
    {
      CFTypeID v134 = CFGetTypeID(v132);
      if (v134 == CFStringGetTypeID()) {
        CFStringRef v135 = v133;
      }
      else {
        CFStringRef v135 = 0;
      }
    }
    else
    {
      CFStringRef v135 = 0;
    }
    CFStringRef v136 = (const __CFString *)CFDictionaryGetValue(v167, @"BundleVersion");
    CFStringRef v137 = v136;
    if (v136)
    {
      CFTypeID v138 = CFGetTypeID(v136);
      if (v138 == CFStringGetTypeID()) {
        CFStringRef v139 = v137;
      }
      else {
        CFStringRef v139 = 0;
      }
    }
    else
    {
      CFStringRef v139 = 0;
    }
    CFDictionaryRef v140 = CFDictionaryGetValue(v167, @"BundleID");
    CFBooleanRef v141 = v140;
    if (v140)
    {
      CFTypeID v142 = CFGetTypeID(v140);
      if (v142 == CFStringGetTypeID()) {
        v143 = v141;
      }
      else {
        v143 = 0;
      }
    }
    else
    {
      v143 = 0;
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v143;
    sub_1000292E0((uint64_t)&buf);
    CFDictionaryRef v144 = std::string::insert(&buf, 0, "com.apple.", 0xAuLL);
    CFArrayRef v145 = (const __CFArray *)v144->__r_.__value_.__r.__words[0];
    int v146 = SHIBYTE(v144->__r_.__value_.__r.__words[2]);
    v144->__r_.__value_.__r.__words[0] = 0;
    v144->__r_.__value_.__l.__size_ = 0;
    v144->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    CFTypeID v147 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__str, 0, sizeof(__str));
      CFArrayRef theArraya = v145;
      int v164 = v146;
      ctu::cf::assign();
      std::string v186 = __str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v148 = &v186;
      }
      else {
        v148 = (std::string *)v186.__r_.__value_.__r.__words[0];
      }
      memset(&__str, 0, sizeof(__str));
      CFStringRef v161 = v135;
      ctu::cf::assign();
      v149 = v129;
      std::string keys = __str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string keys = &keys;
      }
      else {
        p_std::string keys = (std::string *)keys.__r_.__value_.__r.__words[0];
      }
      memset(&__str, 0, sizeof(__str));
      ctu::cf::assign();
      std::string values = __str;
      int v151 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
      std::string::size_type v152 = __str.__r_.__value_.__r.__words[0];
      memset(&__str, 0, sizeof(__str));
      ctu::cf::assign();
      p_std::string values = &values;
      if (v151 < 0) {
        p_std::string values = (std::string *)v152;
      }
      std::string v182 = __str;
      CFStringRef v154 = &v182;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        CFStringRef v154 = (std::string *)v182.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446978;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v148;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_keys;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
      uint64_t v188 = p_values;
      __int16 v189 = 2082;
      BOOL v190 = v154;
      _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEFAULT, "#I Current bundle ID %{public}s and version %{public}s, Available bundle ID: %{public}s and version %{public}s", (uint8_t *)&buf, 0x2Au);
      if (SHIBYTE(v182.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v182.__r_.__value_.__l.__data_);
      }
      CFStringRef v135 = v161;
      CFArrayRef v145 = theArraya;
      uint64_t v129 = v149;
      if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(values.__r_.__value_.__l.__data_);
      }
      int v146 = v164;
      if (SHIBYTE(keys.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(keys.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v186.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v186.__r_.__value_.__l.__data_);
      }
    }
    char v155 = sub_1006CEC58((os_log_t *)a1, v129, v135, v143, v139);
    if ((v155 & 1) == 0)
    {
      unint64_t v156 = *(NSObject **)a1;
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, "#I Not a new bundle, nothing to download", (uint8_t *)&buf, 2u);
      }
    }
    if (v146 < 0) {
      operator delete(v145);
    }
    sub_100057D78((const void **)&v166);
    sub_100057D78((const void **)&v167);
    uint64_t v157 = *(NSObject **)a1;
    BOOL v158 = os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT);
    if (v155)
    {
      if (v158)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138543362;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = *(void *)v185;
        _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, "#I Updated bundle available. Printing dict %{public}@", (uint8_t *)&buf, 0xCu);
      }
      *(unsigned char *)a3 = 4;
      sub_100058198((const void **)(a3 + 8), (const void **)v185);
      goto LABEL_286;
    }
    if (v158)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, "#I Not a new bundle, nothing to download", (uint8_t *)&buf, 2u);
    }
    buf.__r_.__value_.__s.__data_[0] = 3;
    sub_100057240((const void **)&buf.__r_.__value_.__l.__size_, &cf);
    *(unsigned char *)a3 = buf.__r_.__value_.__s.__data_[0];
    sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf.__r_.__value_.__l.__size_);
  }
  else
  {
    CFIndex v131 = *(NSObject **)a1;
    if (os_log_type_enabled(v131, OS_LOG_TYPE_ERROR))
    {
      v186.__r_.__value_.__r.__words[0] = (std::string::size_type)v169;
      sub_1000292E0((uint64_t)&buf);
      uint64_t v160 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
           ? &buf
           : (std::string *)buf.__r_.__value_.__r.__words[0];
      LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v160;
      _os_log_error_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_ERROR, "No dict under bundles with key %{public}s ", (uint8_t *)&__str, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    buf.__r_.__value_.__s.__data_[0] = 3;
    sub_100057240((const void **)&buf.__r_.__value_.__l.__size_, &cf);
    *(unsigned char *)a3 = buf.__r_.__value_.__s.__data_[0];
    sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&buf.__r_.__value_.__l.__size_);
  }
  sub_10005717C((const void **)&buf.__r_.__value_.__l.__size_);
LABEL_286:
  sub_100057D78((const void **)v185);
LABEL_287:
  sub_1000558F4((const void **)&v169);
LABEL_288:
  sub_100057D78(&v170);
  sub_10005717C(&cf);
LABEL_289:
  if (SHIBYTE(v173) < 0) {
    operator delete(v172[0]);
  }
LABEL_291:
  sub_1000558F4((const void **)&key);
  return sub_1000577C4((const void **)&v176);
}

void sub_100812A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, const void *a17, const void *a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,const void *a27,const void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,const void *a34,const void *a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (__p)
  {
    a37 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a40)
  {
    a41 = (uint64_t)a40;
    operator delete(a40);
  }
  if (a44)
  {
    a45 = (uint64_t)a44;
    operator delete(a44);
  }
  sub_1000558F4(&a34);
  if (*(char *)(v45 - 185) < 0) {
    operator delete(*(void **)(v45 - 208));
  }
  if (*(char *)(v45 - 105) < 0) {
    operator delete(*(void **)(v45 - 128));
  }
  sub_1000558F4(&a35);
  sub_1000558F4(&a17);
  sub_100057D78(&a16);
  sub_100057D78(&a18);
  sub_10005717C(&a19);
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_1000558F4(&a27);
  sub_1000577C4(&a28);
  _Unwind_Resume(a1);
}

void CCIMSClientFactory::create(std::__shared_weak_count_vtbl **a1@<X0>, std::__shared_weak_count **a2@<X8>)
{
  BOOL v4 = (std::__shared_weak_count *)operator new(0x40uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_101A0D928;
  uint64_t v5 = v4 + 1;
  IMSClientFactory::IMSClientFactory((IMSClientFactory *)&v4[1]);
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A0D8E8;
  uint64_t v6 = (uint64_t)a1[1];
  v4[2].__vftable = *a1;
  v4[2].__shared_owners_ = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A0D978;
  shared_weak_owners = (std::__shared_weak_count *)v4[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v4[1].__shared_owners_ = (uint64_t)v5;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    goto LABEL_7;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v4[1].__shared_owners_ = (uint64_t)v5;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_7:
    sub_10004D2C8(v4);
  }
  *a2 = v5;
  a2[1] = v4;
}

void sub_100812EA4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_100812EBC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v5)
  {
    int v7 = 0;
LABEL_12:
    *a3 = 0;
    a3[1] = 0;
    goto LABEL_13;
  }
  int v7 = std::__shared_weak_count::lock(v5);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = *(Registry **)(a1 + 24);
  if (!v8) {
    goto LABEL_12;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
  int v10 = ServiceMap;
  if ((v11 & 0x8000000000000000) != 0)
  {
    CFTypeID v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      unint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v11;
  __int16 v15 = sub_10004D37C(&v10[1].__m_.__sig, &v19);
  if (!v15)
  {
    uint64_t v17 = 0;
LABEL_17:
    std::mutex::unlock(v10);
    CFDictionaryRef v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_10;
    }
    goto LABEL_18;
  }
  uint64_t v17 = v15[3];
  CFDictionaryRef v16 = (std::__shared_weak_count *)v15[4];
  if (!v16) {
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
  char v18 = 0;
  if (!v17)
  {
LABEL_10:
    *a3 = 0;
    a3[1] = 0;
    goto LABEL_19;
  }
LABEL_18:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 24))(v17, a2);
LABEL_19:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
LABEL_13:
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100813014(_Unwind_Exception *a1)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100813040(IMSClientFactory *this)
{
  *(void *)this = off_101A0D8E8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  IMSClientFactory::~IMSClientFactory(this);
}

void sub_10081309C(IMSClientFactory *this)
{
  *(void *)this = off_101A0D8E8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  IMSClientFactory::~IMSClientFactory(this);

  operator delete();
}

void sub_10081310C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0D928;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10081312C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0D928;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100813180(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1008131A8(IMSClientFactory *this)
{
  *(void *)this = off_101A0D8E8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  IMSClientFactory::~IMSClientFactory(this);
}

void sub_100813204(IMSClientFactory *this)
{
  *(void *)this = off_101A0D8E8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  IMSClientFactory::~IMSClientFactory(this);

  operator delete();
}

uint64_t sub_100813274(uint64_t a1, NSObject **a2, void *a3)
{
  uint64_t v6 = *a2;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  sub_1013BD45C(a1, &object, a3, "cp.rch.reg");
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = off_101A0D9B8;
  *(void *)(a1 + 8) = &off_101A0DAE8;
  sub_100058DB0(&__p, "CellularPlanRegisteredCommandHandler");
  int v7 = *a2;
  dispatch_object_t v10 = 0;
  dispatch_object_t v11 = v7;
  *a2 = 0;
  ctu::RestModule::RestModule();
  if (v10) {
    dispatch_release(v10);
  }
  if (v11) {
    dispatch_release(v11);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 264) = a1 + 272;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = a1 + 296;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 312) = a1 + 320;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(void *)(a1 + 384) = 0;
  int v9 = 1;
  sub_10078C71C((uint64_t **)(a1 + 72), &v9, &v9);
  return a1;
}

void sub_1008133D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (*(char *)(v18 + 391) < 0) {
    operator delete(*(void **)(v18 + 368));
  }
  char v23 = *(std::__shared_weak_count **)(v18 + 360);
  if (v23) {
    sub_10004D2C8(v23);
  }
  __int16 v24 = *(std::__shared_weak_count **)(v18 + 344);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10010C0E0(v21, *(void **)(v18 + 320));
  sub_100030EE0(v20, *(char **)(v18 + 296));
  sub_1000886C0(v19, *(char **)(v18 + 272));
  CFTypeRef v25 = *(std::__shared_weak_count **)(v18 + 256);
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_1013BD63C(v18);
  _Unwind_Resume(a1);
}

void sub_100813478(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  JUMPOUT(0x100813470);
}

const char *sub_10081348C()
{
  return "CellularPlanRegisteredCommandHandler";
}

void sub_100813498(uint64_t a1)
{
  if (*(void *)(a1 + 336)) {
    return;
  }
  sub_10003E168(buf, (void *)(a1 + 16));
  uint64_t v3 = *(void *)buf;
  char v2 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  (***(void (****)(void **__return_ptr))(a1 + 56))(&__p);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p);
  uint64_t v5 = ServiceMap;
  uint64_t v6 = "38CellularPlanIDSServiceManagerInterface";
  if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v29 = (unint64_t)v6;
  dispatch_object_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v29);
  if (v10)
  {
    uint64_t v12 = v10[3];
    dispatch_object_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  dispatch_object_t v11 = 0;
  char v13 = 1;
LABEL_12:
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v12 + 24))(buf, v12);
  long long v14 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  __int16 v15 = *(std::__shared_weak_count **)(a1 + 344);
  *(_OWORD *)(a1 + 336) = v14;
  if (v15)
  {
    sub_10004D2C8(v15);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  uint64_t v16 = *(void *)(a1 + 336);
  if (v16)
  {
    CFTypeID v28 = v2;
    unint64_t v29 = 32;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 1174405120;
    v27[2] = sub_100813BDC;
    v27[3] = &unk_101A0DB58;
    uint8_t v27[4] = a1;
    v27[5] = v3;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 1174405120;
    void v25[2] = sub_100813D80;
    unint64_t v25[3] = &unk_101A0DB88;
    v25[4] = a1;
    v25[5] = v3;
    uint64_t v26 = v2;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    if ((*(unsigned int (**)(uint64_t, const char *, unint64_t *, Block_layout *, void *, void *))(*(void *)v16 + 24))(v16, "CellularPlanRegisteredCommandHandler", &v29, &stru_101A0DB38, v27, v25))
    {
      (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
      Registry::createRestModuleOneTimeUseConnection(&v23, *(Registry **)buf);
      ctu::RestModule::connect();
      if (v24) {
        sub_10004D2C8(v24);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      sub_1005FE9F4(a1 + 264);
      sub_100058DB0(&__p, "/cc/props/csn_to_ids_device_id_map");
      uint64_t v17 = operator new(0x28uLL);
      *uint64_t v17 = off_101A0DBE0;
      v17[1] = a1 + 288;
      unint64_t v17[2] = a1;
      v17[3] = sub_100814014;
      void v17[4] = 0;
      long long v34 = v17;
      ctu::RestModule::observeProperty();
      sub_10003F600(buf);
      if (v32 < 0) {
        operator delete(__p);
      }
      sub_100058DB0(&__p, "/cc/events/iccid_to_ids_device_id_updated");
      uint64_t v18 = operator new(0x20uLL);
      *uint64_t v18 = off_101A0DC60;
      v18[1] = a1;
      void v18[2] = sub_100814224;
      void v18[3] = 0;
      long long v34 = v18;
      ctu::RestModule::observeEvent();
      sub_10003F600(buf);
      if (v32 < 0) {
        operator delete(__p);
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 56) + 584))(buf);
      long long v19 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      uint64_t v20 = *(std::__shared_weak_count **)(a1 + 360);
      *(_OWORD *)(a1 + 352) = v19;
      if (v20)
      {
        sub_10004D2C8(v20);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
    }
    else
    {
      CFDictionaryRef v22 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Cannot register callbacks", buf, 2u);
      }
    }
    if (v26) {
      std::__shared_weak_count::__release_weak(v26);
    }
    if (v28) {
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  else
  {
    uint64_t v21 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No Registered IDS Service allowed on this device", buf, 2u);
    }
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1008139C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  if (v31) {
    std::__shared_weak_count::__release_weak(v31);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100813AA4(id a1, const void *a2)
{
  int v3 = *((char *)a2 + 55);
  if (v3 >= 0) {
    uint64_t v4 = *((unsigned __int8 *)a2 + 55);
  }
  else {
    uint64_t v4 = *((void *)a2 + 5);
  }
  if (v3 >= 0) {
    uint64_t v5 = (char *)a2 + 32;
  }
  else {
    uint64_t v5 = (char *)*((void *)a2 + 4);
  }
  uint64_t v6 = &v5[v4];
  if (v4 > 4)
  {
    uint64_t v7 = v4;
    uint64_t v8 = v5;
    do
    {
      unsigned int v9 = (char *)memchr(v8, 80, v7 - 4);
      if (!v9) {
        break;
      }
      if (*(_DWORD *)v9 == 1852794960 && v9[4] == 101)
      {
        if (v9 != v6 && v9 - v5 != -1) {
          goto LABEL_23;
        }
        break;
      }
      uint64_t v8 = v9 + 1;
      uint64_t v7 = v6 - (unsigned char *)v8;
    }
    while (v6 - (unsigned char *)v8 > 4);
  }
  if (v4 >= 4)
  {
    dispatch_object_t v11 = v5;
    do
    {
      uint64_t v12 = (char *)memchr(v11, 105, v4 - 3);
      if (!v12) {
        break;
      }
      if (*(_DWORD *)v12 == 1684099177) {
        goto LABEL_21;
      }
      dispatch_object_t v11 = v12 + 1;
      uint64_t v4 = v6 - (unsigned char *)v11;
    }
    while (v6 - (unsigned char *)v11 > 3);
  }
  uint64_t v12 = v6;
LABEL_21:
  if (v12 != v6 && v12 - v5 != -1)
  {
LABEL_23:
    if (*((_DWORD *)a2 + 14) > 0xCFFFFu) {
      return 1;
    }
  }
  return 0;
}

void sub_100813BDC(uint64_t a1, uint64_t *a2, char a3)
{
  long long v5 = *(_OWORD *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  long long v6 = 0uLL;
  uint64_t v7 = 0;
  sub_1003C1BB8(&v6, *a2, a2[1], (a2[1] - *a2) >> 6);
  char v8 = a3;
  v9[0] = 0;
  v9[1] = 0;
  sub_10003E168(v9, (void *)(v5 + 16));
  operator new();
}

void sub_100813D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    std::__shared_weak_count::__release_weak(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100813D80(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long v5 = *(_OWORD *)a2;
    void v5[2] = *(void **)(a2 + 16);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(__p, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 24);
    __p[2] = *(void **)(a2 + 40);
  }
  __int16 v7 = *(_WORD *)(a2 + 48);
  sub_10002FD9C((const void **)&v8, (const void **)(a2 + 56));
  sub_100119B5C((const void **)&v8 + 1, (const void **)(a2 + 64));
  v9[0] = *(void *)(a2 + 72);
  *(void *)((char *)v9 + 6) = *(void *)(a2 + 78);
  v10[0] = 0;
  v10[1] = 0;
  sub_10003E168(v10, (void *)(v4 + 16));
  operator new();
}

void sub_100813FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a13) {
    std::__shared_weak_count::__release_weak(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100814014(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 288);
  char v2 = (void *)(a1 + 296);
  if (v1 != (void *)(a1 + 296))
  {
    long long v4 = (uint64_t **)(a1 + 120);
    do
    {
      memset(&v19, 0, sizeof(v19));
      long long v18 = *((_OWORD *)v1 + 2);
      if (*((char *)v1 + 71) < 0) {
        sub_10004FC84(&v19, (void *)v1[6], v1[7]);
      }
      else {
        std::string v19 = *(std::string *)((unsigned char *)v1 + 2);
      }
      long long v5 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        sCardSerialNumberAsString();
        long long v6 = __p;
        if (v13 < 0) {
          long long v6 = (void **)__p[0];
        }
        if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          __int16 v7 = &v19;
        }
        else {
          __int16 v7 = (std::string *)v19.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        __int16 v15 = v6;
        __int16 v16 = 2080;
        uint64_t v17 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Adding csn: [%s] -> device [%s]", buf, 0x16u);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
      }
      __p[0] = &v18;
      long long v8 = (std::string *)sub_1003DE940(v4, (uint64_t)&v18, (uint64_t)&unk_10144E20E, (_OWORD **)__p);
      std::string::operator=(v8 + 2, &v19);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v19.__r_.__value_.__l.__data_);
      }
      unsigned int v9 = (void *)v1[1];
      if (v9)
      {
        do
        {
          dispatch_object_t v10 = v9;
          unsigned int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          dispatch_object_t v10 = (void *)v1[2];
          BOOL v11 = *v10 == (void)v1;
          uint64_t v1 = v10;
        }
        while (!v11);
      }
      uint64_t v1 = v10;
    }
    while (v10 != v2);
  }
}

void sub_1008141FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_100814224(uint64_t a1, void *a2)
{
  char v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    long long v5 = (uint64_t **)(a1 + 312);
    do
    {
      long long v6 = v3 + 4;
      __int16 v7 = v3 + 7;
      *(void *)std::string buf = v3 + 4;
      long long v8 = sub_100366370(v5, (void **)v3 + 4, (uint64_t)&unk_10144E20E, (long long **)buf);
      std::string::operator=((std::string *)(v8 + 7), (const std::string *)(v3 + 7));
      unsigned int v9 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v3 + 55) < 0) {
          long long v6 = (void *)*v6;
        }
        if (*((char *)v3 + 79) < 0) {
          __int16 v7 = (void *)*v7;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v6;
        __int16 v14 = 2080;
        __int16 v15 = v7;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Adding iccid: [%s] -> device [%s]", buf, 0x16u);
      }
      dispatch_object_t v10 = (void *)v3[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          dispatch_object_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v3[2];
          BOOL v12 = *v11 == (void)v3;
          uint64_t v3 = v11;
        }
        while (!v12);
      }
      uint64_t v3 = v11;
    }
    while (v11 != v2);
  }
}

uint64_t sub_100814398(uint64_t a1)
{
  uint64_t v1 = (ctu::RestModule *)(a1 + 248);
  sub_100058DB0(__p, "/cc/events/iccid_to_ids_device_id_updated");
  ctu::RestModule::unobserveEvent();
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/csn_to_ids_device_id_map");
  ctu::RestModule::unobserveProperty();
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/prefs-nb/imeis");
  ctu::RestModule::unobserveProperty();
  if (v4 < 0) {
    operator delete(__p[0]);
  }

  return ctu::RestModule::disconnect(v1);
}

void sub_100814458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100814480()
{
  return 0;
}

void sub_100814488(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a1 + 312;
  if (sub_10010E128(a1 + 312, (void **)a2))
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v7 = sub_10005DDEC(v6, (void **)a2);
    if (*(char *)(v7 + 23) < 0)
    {
      BOOL v11 = *(void **)v7;
      unint64_t v12 = *(void *)(v7 + 8);
      sub_10004FC84((unsigned char *)a3, v11, v12);
    }
    else
    {
      long long v8 = *(_OWORD *)v7;
      *(void *)(a3 + 16) = *(void *)(v7 + 16);
      *(_OWORD *)a3 = v8;
    }
  }
  else
  {
    unsigned int v9 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        dispatch_object_t v10 = (void *)a2;
      }
      else {
        dispatch_object_t v10 = *(void **)a2;
      }
      int v13 = 136315138;
      __int16 v14 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I (%s) not in map", (uint8_t *)&v13, 0xCu);
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
}

void sub_1008145D0(uint64_t a1, const std::string **a2, uint64_t a3)
{
  if (!*(void *)(a1 + 352))
  {
    dispatch_object_t v10 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "cloud sender missing", buf, 2u);
    }
    goto LABEL_23;
  }
  if (!*a2)
  {
    BOOL v11 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "device info missing", buf, 2u);
    }
LABEL_23:
    *(void *)std::string buf = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    sub_1000C1BB8(a3, (uint64_t)buf, 1);
    __int16 v14 = buf;
    sub_1000C5238((void ***)&v14);
    return;
  }
  if (*(char *)(a1 + 391) < 0)
  {
    if (*(void *)(a1 + 376)) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (!*(unsigned char *)(a1 + 391)) {
LABEL_5:
  }
    std::string::operator=((std::string *)(a1 + 368), *a2 + 4);
LABEL_6:
  long long v5 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Fetching device info from cloud", buf, 2u);
  }
  __int16 v14 = 0;
  __int16 v15 = 0;
  *(void *)std::string buf = "CellularPlanRegisteredCommandHandler";
  sub_1002BFAE4((char **)buf, (dispatch_object_t *)(a1 + 32), &v14);
  (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
  Registry::createRestModuleOneTimeUseMobileHelperConnection(&v12, *(Registry **)buf);
  ctu::RestModule::connect();
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  uint64_t v6 = *(void *)(a1 + 352);
  uint64_t v7 = v14;
  *(void *)&long long v19 = a1;
  sub_10003E168(buf, (void *)(a1 + 16));
  long long v8 = v17;
  *((void *)&v19 + 1) = *(void *)buf;
  uint64_t v20 = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
  }
  sub_1008155F0((uint64_t)v21, a3);
  uint64_t v23 = 0;
  unsigned int v9 = (char *)operator new(0x40uLL);
  *(void *)unsigned int v9 = off_101A0DCE0;
  *(_OWORD *)(v9 + 8) = v19;
  *((void *)v9 + 3) = v20;
  *((void *)&v19 + 1) = 0;
  uint64_t v20 = 0;
  sub_10037E9EC((uint64_t)(v9 + 32), (uint64_t)v21);
  uint64_t v23 = v9;
  (*(void (**)(uint64_t, uint8_t *, void *))(*(void *)v6 + 24))(v6, v7, v22);
  sub_1003425A0(v22);
  sub_10034ABC0(v21);
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_1008148F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, std::__shared_weak_count *a19)
{
}

uint64_t sub_100814990(uint64_t a1)
{
  sub_10034ABC0((void *)(a1 + 24));
  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1008149C8()
{
  return 4;
}

uint64_t sub_1008149D0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 344);
  *a2 = *(void *)(result + 336);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100814A00(uint64_t a1)
{
  sub_100814A7C(a1);

  operator delete();
}

uint64_t sub_100814A38(uint64_t a1)
{
  return sub_100814A7C(a1 - 8);
}

void sub_100814A40(uint64_t a1)
{
  sub_100814A7C(a1 - 8);

  operator delete();
}

uint64_t sub_100814A7C(uint64_t a1)
{
  *(void *)a1 = off_101A0D9B8;
  *(void *)(a1 + 8) = &off_101A0DAE8;
  if (*(char *)(a1 + 391) < 0) {
    operator delete(*(void **)(a1 + 368));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 360);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 344);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10010C0E0(a1 + 312, *(void **)(a1 + 320));
  sub_100030EE0(a1 + 288, *(char **)(a1 + 296));
  sub_1000886C0(a1 + 264, *(char **)(a1 + 272));
  char v4 = *(std::__shared_weak_count **)(a1 + 256);
  if (v4) {
    sub_10004D2C8(v4);
  }

  return sub_1013BD63C(a1);
}

uint64_t *sub_100814B44(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void **)v1;
    char v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(v1 + 8))
      {
        memset(v17, 0, sizeof(v17));
        sub_1003C1BB8(v17, *(void *)(v1 + 24), *(void *)(v1 + 32), (uint64_t)(*(void *)(v1 + 32) - *(void *)(v1 + 24)) >> 6);
        sub_1013D1D6C(v3, v17);
        __int16 v15 = (char **)v17;
        sub_1002B2AEC((void ***)&v15);
        uint64_t v6 = (std::__shared_weak_count *)v3[19];
        if (v6)
        {
          uint64_t v7 = std::__shared_weak_count::lock(v6);
          if (v7)
          {
            long long v8 = v7;
            uint64_t v9 = v3[18];
            if (v9)
            {
              v16[0] = 0;
              v16[1] = 0;
              __int16 v15 = v16;
              dispatch_object_t v10 = *(void ***)(v1 + 24);
              BOOL v11 = *(void ***)(v1 + 32);
              while (v10 != v11)
              {
                sub_100046BAC((uint64_t **)&v15, v10, (uint64_t)v10);
                v10 += 8;
              }
              (*(void (**)(uint64_t, char ***, void))(*(void *)v9 + 56))(v9, &v15, *(unsigned __int8 *)(v1 + 48));
              sub_10005CD2C((uint64_t)&v15, v16[0]);
            }
            sub_10004D2C8(v8);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100814CDC(&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100814C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12)
{
  sub_10005CD2C((uint64_t)&a11, a12);
  sub_10004D2C8(v13);
  sub_10004D2C8(v12);
  sub_100814CDC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100814CDC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v3 = (void **)(v1 + 24);
    sub_1002B2AEC(&v3);
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100814D48(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(uint64_t ***)v1;
    char v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(v1 + 8)) {
        sub_1013CF5F4(v3, v1 + 24);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100814DE4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100814DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100814DE4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100814DE4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1000FE824((const void **)(v1 + 88));
    sub_100030068((const void **)(v1 + 80));
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100814E6C()
{
}

__n128 sub_100814E80(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A0DBE0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100814ED4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0DBE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100814F0C(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  uint64_t v4 = a1[1];
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_100030EE0(v4, *(char **)(v4 + 8));
  *(void *)uint64_t v4 = v4 + 8;
  *(void *)(v4 + 16) = 0;
  *(void *)(v4 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v19, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v18, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v20; ; uint64_t i = ++v20)
    {
      if (i == v18[1] && v19 == v18[0])
      {
        xpc_release(v19);
        xpc_release(v19);
        goto LABEL_39;
      }
      xpc_object_t v17 = 0;
      object[0] = &v19;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v17);
      if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_37:
      xpc_release(v17);
    }
    uint64_t v31 = 0;
    *(_OWORD *)dispatch_object_t object = 0u;
    *(_OWORD *)long long v30 = 0u;
    xpc_object_t v7 = v17;
    if (v17)
    {
      xpc_retain(v17);
      xpc_object_t v23 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v23 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        std::string __p = &v23;
        long long v27 = "first";
        sub_100048BAC((uint64_t)&__p, v24);
        ctu::rest::detail::read_raw_binary_value((ctu::rest::detail *)object, (void *)0x10, (unint64_t)v24, v9);
        xpc_release(v24[0]);
        v21[0] = &v23;
        v21[1] = "second";
        sub_100048BAC((uint64_t)v21, &v22);
        std::string __p = 0;
        long long v27 = 0;
        uint64_t v28 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v28) < 0) {
          operator delete(__p);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(v30[0]);
        }
        *(_OWORD *)long long v30 = *(_OWORD *)v24;
        uint64_t v31 = v25;
        xpc_release(v22);
        xpc_object_t v8 = v23;
      }
      xpc_release(v8);
      xpc_release(v7);
      std::string __p = 0;
      dispatch_object_t v10 = (uint64_t **)sub_1003DE9D4(v4, &__p, (uint64_t)object);
      if (!*v10)
      {
        BOOL v11 = operator new(0x48uLL);
        long long v12 = *(_OWORD *)v30;
        v11[2] = *(_OWORD *)object;
        void v11[3] = v12;
        *((void *)v11 + 8) = v31;
        v30[0] = 0;
        v30[1] = 0;
        uint64_t v31 = 0;
        sub_100046C38((uint64_t **)v4, (uint64_t)__p, v10, (uint64_t *)v11);
      }
      if (SHIBYTE(v31) < 0) {
        operator delete(v30[0]);
      }
      goto LABEL_37;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v23 = v8;
    goto LABEL_27;
  }
LABEL_39:
  xpc_release(v3);
  int v13 = (uint64_t (*)(void *))a1[3];
  uint64_t v14 = a1[4];
  __int16 v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    int v13 = *(uint64_t (**)(void *))(*v15 + v13);
  }

  return v13(v15);
}

void sub_1008152DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t a11, uint64_t a12, xpc_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, xpc_object_t a18, xpc_object_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t object,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100815404(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100815444()
{
}

void sub_100815454()
{
}

__n128 sub_100815468(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A0DC60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1008154BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A0DC60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1008154F4(void *a1, xpc_object_t *a2)
{
  v7[0] = 0;
  v7[1] = 0;
  uint64_t v6 = v7;
  sub_100314828((uint64_t)&v6, a2);
  xpc_object_t v3 = (void (*)(void *, void ***))a1[2];
  uint64_t v4 = a1[3];
  long long v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    xpc_object_t v3 = *(void (**)(void *, void ***))(*v5 + v3);
  }
  v3(v5, &v6);
  sub_10010C0E0((uint64_t)&v6, v7[0]);
}

void sub_10081558C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1008155A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008155E4()
{
}

uint64_t sub_1008155F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100815688(void *a1)
{
  *a1 = off_101A0DCE0;
  sub_10034ABC0(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1008156D8(void *a1)
{
  *a1 = off_101A0DCE0;
  sub_10034ABC0(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100815748(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A0DCE0;
  sub_100815ACC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10081579C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008157B0(uint64_t a1, void *a2)
{
  *a2 = off_101A0DCE0;
  return sub_100815ACC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1008157DC(uint64_t a1)
{
}

void sub_1008157E4(void *a1)
{
  sub_100815B34((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100815820(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  long long v6 = *((_OWORD *)a2 + 1);
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  long long v8 = *(_OWORD *)(a1 + 8);
  long long v10 = v8;
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 24);
  BOOL v11 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = v5;
  long long v13 = 0uLL;
  uint64_t v14 = 0;
  sub_1003422D4(&v13, v4, v6, 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v6 - v4) >> 3));
  sub_1008155F0((uint64_t)&v15, a1 + 32);
  v9[0] = 0;
  v9[1] = 0;
  sub_10003E168(v9, (void *)(v8 + 16));
  operator new();
}

void sub_100815A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100815A80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100815AC0()
{
}

uint64_t sub_100815ACC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1008155F0(a1 + 24, a2 + 24);
  return a1;
}

void sub_100815B1C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100815B34(uint64_t a1)
{
  sub_10034ABC0((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_100815B80(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v47 = a1;
  uint64_t v48 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v46 = *(void *)v1;
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*(void *)(v1 + 8))
      {
        if (*(unsigned char *)(v1 + 24))
        {
          uint64_t v45 = v3;
          uint64_t v49 = 0;
          unint64_t v50 = 0;
          unint64_t v51 = 0;
          uint64_t v5 = *(void *)(v1 + 32);
          uint64_t v6 = *(void *)(v1 + 40);
          uint64_t v67 = 0;
          CFDictionaryRef v68 = 0;
          unint64_t v69 = 0;
          memset(&v66, 0, sizeof(v66));
          while (v5 != v6)
          {
            long long v98 = 0u;
            long long v99 = 0u;
            long long v96 = 0u;
            long long v97 = 0u;
            long long v95 = 0u;
            long long v93 = 0u;
            memset(v94, 0, sizeof(v94));
            long long v91 = 0u;
            long long v92 = 0u;
            long long v89 = 0u;
            long long v90 = 0u;
            long long v87 = 0u;
            long long v88 = 0u;
            long long v85 = 0u;
            long long v86 = 0u;
            long long v83 = 0u;
            long long v84 = 0u;
            long long v81 = 0u;
            long long v82 = 0u;
            long long v79 = 0u;
            long long v80 = 0u;
            long long v77 = 0u;
            long long v78 = 0u;
            long long buf = 0u;
            memset(__str, 0, sizeof(__str));
            CFTypeID v70 = 0;
            uint64_t v71 = 0;
            uint64_t v72 = 0;
            memset(v65, 0, sizeof(v65));
            char v7 = sub_100CD7B0C((os_log_t *)(v46 + 48), (const unsigned __int8 **)(v5 + 24), (void *)(v46 + 264), (uint64_t *)&v70, v65, (uint64_t)&buf, (uint64_t)__str);
            v59[0] = (void **)v65;
            sub_100047F64(v59);
            v59[0] = (void **)&v70;
            sub_10010DF1C(v59);
            if (v7)
            {
              CFTypeID v70 = 0;
              uint64_t v71 = 0;
              if (*(_OWORD *)&__str[40] != 0)
              {
                uint64_t v8 = __str[23];
                if (__str[23] < 0) {
                  uint64_t v8 = *(void *)&__str[8];
                }
                if (v8)
                {
                  CFTypeID v70 = (uint64_t (**)(PB::Base *))&__str[40];
                  uint64_t v9 = (std::string *)sub_1003DE940((uint64_t **)(v46 + 120), (uint64_t)&__str[40], (uint64_t)&unk_10144E20E, (_OWORD **)&v70);
                  std::string::operator=(v9 + 2, (const std::string *)__str);
                }
              }
              long long v10 = v68;
              if ((unint64_t)v68 >= v69)
              {
                uint64_t v12 = (unsigned char *)sub_100341D00(&v67, (long long *)__str);
              }
              else
              {
                if ((__str[23] & 0x80000000) != 0)
                {
                  sub_10004FC84(v68, *(void **)__str, *(unint64_t *)&__str[8]);
                }
                else
                {
                  long long v11 = *(_OWORD *)__str;
                  *((void *)v68 + 2) = *(void *)&__str[16];
                  *long long v10 = v11;
                }
                long long v13 = *(_OWORD *)&__str[24];
                *(_OWORD *)((char *)v10 + 40) = *(_OWORD *)&__str[40];
                *(_OWORD *)((char *)v10 + 24) = v13;
                uint64_t v12 = (char *)v10 + 56;
              }
              CFDictionaryRef v68 = v12;
              long long __s1 = 0uLL;
              uint64_t v64 = 0;
              if (SHIBYTE(v94[3]) < 0)
              {
                sub_10004FC84(&__s1, (void *)v94[1], v94[2]);
              }
              else
              {
                long long __s1 = *(_OWORD *)&v94[1];
                uint64_t v64 = v94[3];
              }
              uint64_t v14 = HIBYTE(v64);
              if (v64 >= 0) {
                uint64_t v15 = HIBYTE(v64);
              }
              else {
                uint64_t v15 = *((void *)&__s1 + 1);
              }
              if (!v15) {
                goto LABEL_39;
              }
              uint64_t v16 = *(unsigned __int8 *)(v46 + 391);
              int v17 = (char)v16;
              if ((v16 & 0x80u) != 0) {
                uint64_t v16 = *(void *)(v46 + 376);
              }
              if (v15 != v16) {
                goto LABEL_39;
              }
              if (v17 >= 0) {
                uint64_t v18 = (unsigned __int8 *)(v46 + 368);
              }
              else {
                uint64_t v18 = *(unsigned __int8 **)(v46 + 368);
              }
              if (SHIBYTE(v64) < 0)
              {
                uint64_t v20 = (void *)__s1;
                if (memcmp((const void *)__s1, v18, *((size_t *)&__s1 + 1))) {
                  goto LABEL_39;
                }
                goto LABEL_85;
              }
              if (HIBYTE(v64))
              {
                p_s1 = &__s1;
                while (*(unsigned __int8 *)p_s1 == *v18)
                {
                  p_s1 = (long long *)((char *)p_s1 + 1);
                  ++v18;
                  if (!--v14)
                  {
                    if ((v64 & 0x8000000000000000) == 0) {
                      goto LABEL_86;
                    }
                    goto LABEL_84;
                  }
                }
LABEL_39:
                *((void *)&v99 + 1) = *(void *)(v5 + 48);
                unint64_t v21 = v50;
                if (v50 >= v51)
                {
                  uint64_t v22 = sub_100341B84(&v49, (uint64_t)&buf);
                }
                else
                {
                  sub_100341CA4(v50, (uint64_t)&buf);
                  uint64_t v22 = v21 + 400;
                }
                unint64_t v50 = v22;
                memset(&__dst, 0, sizeof(__dst));
                if ((_BYTE)v91)
                {
                  if (SBYTE7(v79) < 0)
                  {
                    sub_10004FC84(&__dst, (void *)v78, *((unint64_t *)&v78 + 1));
                  }
                  else
                  {
                    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v78;
                    __dst.__r_.__value_.__r.__words[2] = v79;
                  }
                }
                std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                char v24 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  std::string::size_type size = __dst.__r_.__value_.__l.__size_;
                }
                if (size)
                {
                  CFDictionaryRef v60 = 0;
                  v61[0] = 0;
                  v61[1] = 0;
                  sub_10098FAB8((uint64_t *)&buf, (uint64_t)&v60);
                  uint64_t v25 = v60;
                  if (v60 != v61)
                  {
                    do
                    {
                      CFTypeID v70 = (uint64_t (**)(PB::Base *))(v25 + 4);
                      uint64_t v26 = sub_100366370((uint64_t **)(v46 + 312), (void **)v25 + 4, (uint64_t)&unk_10144E20E, (long long **)&v70);
                      std::string::operator=((std::string *)(v26 + 7), &__dst);
                      long long v27 = v25[1];
                      if (v27)
                      {
                        do
                        {
                          uint64_t v28 = (char **)v27;
                          long long v27 = *(char **)v27;
                        }
                        while (v27);
                      }
                      else
                      {
                        do
                        {
                          uint64_t v28 = (char **)v25[2];
                          BOOL v29 = *v28 == (char *)v25;
                          uint64_t v25 = v28;
                        }
                        while (!v29);
                      }
                      uint64_t v25 = v28;
                    }
                    while (v28 != v61);
                  }
                  long long v30 = *(const unsigned __int8 **)(v5 + 24);
                  uint64_t v31 = *(const unsigned __int8 **)(v5 + 32);
                  if (v31 != v30)
                  {
                    memset(v59, 0, 32);
                    PB::Reader::Reader((PB::Reader *)v59, v30, v31 - v30);
                    uint64_t v73 = 0;
                    uint64_t v74 = 0;
                    CFTypeID v70 = &off_101A17F50;
                    uint64_t v71 = 0;
                    uint64_t v72 = 0;
                    sub_1008E296C((uint64_t)&v70, (PB::Reader *)v59);
                    ctu::hex();
                    char v32 = std::string::append(&v54, "\n\n", 2uLL);
                    long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
                    v55.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v33;
                    v32->__r_.__value_.__l.__size_ = 0;
                    v32->__r_.__value_.__r.__words[2] = 0;
                    v32->__r_.__value_.__r.__words[0] = 0;
                    PB::Base::formattedText((uint64_t *)v52, (PB::Base *)&v70);
                    if ((v53 & 0x80u) == 0) {
                      long long v34 = v52;
                    }
                    else {
                      long long v34 = (void **)v52[0];
                    }
                    if ((v53 & 0x80u) == 0) {
                      std::string::size_type v35 = v53;
                    }
                    else {
                      std::string::size_type v35 = (std::string::size_type)v52[1];
                    }
                    uint64_t v36 = std::string::append(&v55, (const std::string::value_type *)v34, v35);
                    long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
                    v56.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v37;
                    v36->__r_.__value_.__l.__size_ = 0;
                    v36->__r_.__value_.__r.__words[2] = 0;
                    v36->__r_.__value_.__r.__words[0] = 0;
                    std::string::size_type v38 = std::string::append(&v56, "\n\n", 2uLL);
                    long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
                    int64_t v58 = v38->__r_.__value_.__r.__words[2];
                    long long __p = v39;
                    v38->__r_.__value_.__l.__size_ = 0;
                    v38->__r_.__value_.__r.__words[2] = 0;
                    v38->__r_.__value_.__r.__words[0] = 0;
                    if (v58 >= 0) {
                      p_p = (const std::string::value_type *)&__p;
                    }
                    else {
                      p_p = (const std::string::value_type *)__p;
                    }
                    if (v58 >= 0) {
                      std::string::size_type v41 = HIBYTE(v58);
                    }
                    else {
                      std::string::size_type v41 = *((void *)&__p + 1);
                    }
                    std::string::append(&v66, p_p, v41);
                    if (SHIBYTE(v58) < 0) {
                      operator delete((void *)__p);
                    }
                    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v56.__r_.__value_.__l.__data_);
                    }
                    if ((char)v53 < 0) {
                      operator delete(v52[0]);
                    }
                    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v55.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v54.__r_.__value_.__l.__data_);
                    }
                    sub_1008E25A0((PB::Base *)&v70);
                  }
                  sub_10005CD2C((uint64_t)&v60, v61[0]);
                  char v24 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                }
                if (v24 < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
                if ((v64 & 0x8000000000000000) == 0) {
                  goto LABEL_86;
                }
LABEL_84:
                uint64_t v20 = (void *)__s1;
LABEL_85:
                operator delete(v20);
              }
            }
LABEL_86:
            if ((__str[23] & 0x80000000) != 0) {
              operator delete(*(void **)__str);
            }
            sub_1000C52BC((uint64_t)&buf);
            v5 += 56;
          }
          sub_100058DB0(&buf, "Manatee_DownloadData_");
          sub_100CD689C((os_log_t *)(v46 + 48), (uint64_t)&buf, (uint64_t)&v66);
          uint64_t v4 = v45;
          if (SBYTE7(v77) < 0) {
            operator delete((void *)buf);
          }
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          *(void *)std::string __str = &v67;
          sub_100342230((void ***)__str);
          sub_1000C1BB8(v1 + 56, (uint64_t)&v49, 0);
          *(void *)&long long buf = &v49;
          p_long long buf = (void ***)&buf;
        }
        else
        {
          int v43 = *(NSObject **)(v46 + 48);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Device info cloud fetch failed", (uint8_t *)&buf, 2u);
          }
          long long buf = 0uLL;
          *(void *)&long long v77 = 0;
          sub_1000C1BB8(v1 + 56, (uint64_t)&buf, 1);
          *(void *)std::string __str = &buf;
          p_long long buf = (void ***)__str;
        }
        sub_1000C5238(p_buf);
      }
      sub_10004D2C8(v4);
    }
  }
  sub_10081646C(&v48);
  return sub_100046B58((uint64_t *)&v47);
}

void sub_1008162AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v15 = va_arg(va1, void);
  STACK[0x200] = v12;
  sub_1000C5238((void ***)&STACK[0x200]);
  sub_10004D2C8(v13);
  sub_10081646C((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10081646C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10034ABC0((void *)(v1 + 56));
    uint64_t v3 = (void **)(v1 + 32);
    sub_10034251C(&v3);
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void BasebandSettings::handleCarrierInfo_sync(uint64_t a1, uint64_t a2, int a3, int a4, const __CFDictionary **a5, const __CFDictionary **a6)
{
  unint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Received Carrier Activation Info Available event, initializing carrier bundle", buf, 2u);
  }
  unsigned __int16 v13 = sub_100816B30(*a6, @"ServiceProvisionState");
  unsigned __int16 v14 = v13;
  BOOL v15 = a3 == 2;
  int v32 = v13;
  if ((_BYTE)v13) {
    BOOL v16 = 0;
  }
  else {
    BOOL v16 = v13 > 0xFFu;
  }
  if ((_BYTE)v13) {
    BOOL v15 = 0;
  }
  if (v13 > 0xFFu && v15) {
    int v17 = 114;
  }
  else {
    int v17 = 0;
  }
  int v35 = v17;
  switch(a4)
  {
    case 0:
      goto LABEL_16;
    case 5:
      xpc_object_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle is not set up. Hence, no need to do service provisioning ", buf, 2u);
      }
      BasebandSettings::fireBasebandPostponementStatus_sync((Registry **)a1);
      return;
    case 4:
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = asString();
        uint64_t v20 = asString();
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v20;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Overriding %s with %s", buf, 0x16u);
      }
LABEL_16:
      BasebandSettings::bbset_checkForCBFilesUpdate_sync(a1, a2, 0);
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      BasebandSettings::getModel_sync(a1, a2, buf);
      uint64_t v21 = *(void *)buf;
      if (*(void *)buf)
      {
        sub_100058198(&v34, (const void **)a6);
        unsigned int v22 = (*(unsigned __int16 (**)(uint64_t, const void **))(*(void *)v21 + 112))(v21, &v34);
        sub_100057D78(&v34);
        if (v22 >= 0x100)
        {
          BasebandSettings::lineupFile_sync((void *)a1, a2, 7, 0);
          BasebandSettings::lineupFile_sync((void *)a1, a2, 0, 0);
          BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 6, 0);
          if (v16 || sub_100816BB4(*a5)) {
            BasebandSettings::lineupFile_sync((void *)a1, a2, 2, 0);
          }
          BasebandSettings::lineupFile_sync((void *)a1, a2, 8, 0);
        }
      }
      else
      {
        uint64_t v25 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long v33 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Could not get model for PRI mismatch detection", v33, 2u);
        }
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      *(void *)long long buf = off_101A0E008;
      *(void *)&uint8_t buf[8] = a1;
      long long v37 = buf;
      BasebandSettings::sendLinedupFiles_sync(a1, buf);
      goto LABEL_36;
  }
  char v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Carrier ID changed, Hence send DMU, PRL, PRI files", buf, 2u);
  }
  BasebandSettings::lineupFile_sync((void *)a1, a2, 7, 0);
  BasebandSettings::lineupFile_sync((void *)a1, a2, 0, 0);
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 6, 0);
  if (v16 || sub_100816BB4(*a5)) {
    BasebandSettings::lineupFile_sync((void *)a1, a2, 2, 0);
  }
  BasebandSettings::lineupFile_sync((void *)a1, a2, 8, 0);
  *(unsigned char *)(a1 + 292) = 0;
  long long v37 = 0;
  BasebandSettings::sendLinedupFiles_sync(a1, buf);
LABEL_36:
  sub_10081A370(buf);
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 584) + 56))(*(void *)(a1 + 584)) & 1 | (v14 <= 0xFFu))
  {
    uint64_t v26 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Waiting to send all the files", buf, 2u);
    }
  }
  else
  {
    if (sub_100816EF0(a1, a3, v32 != 0, &v35))
    {
      BasebandSettings::fireBasebandPostponementStatus_sync((Registry **)a1);
      int v17 = v35;
      goto LABEL_45;
    }
    int v17 = v35;
  }
  if (v17 == 114)
  {
    sub_100817184((void *)(a1 + 112), 1, (uint64_t)kCFBooleanTrue);
    (*(void (**)(void, void))(**(void **)(a1 + 536) + 392))(*(void *)(a1 + 536), 0);
  }
  BasebandSettings::fireBasebandPostponementStatus_sync((Registry **)a1);
LABEL_45:
  if (v17)
  {
    long long v27 = *(_DWORD **)(a1 + 264);
    uint64_t v28 = *(_DWORD **)(a1 + 272);
    if (v27 != v28)
    {
      while (*v27 != a2)
      {
        v27 += 42;
        if (v27 == v28) {
          return;
        }
      }
    }
    if (v27 != v28 && (subscriber::isEsimCapable() & 1) == 0)
    {
      int v29 = v35;
      xpc_object_t v30 = xpc_null_create();
      *(void *)long long buf = v30;
      xpc_object_t v31 = xpc_null_create();
      *(void *)long long v33 = v31;
      sub_1000452AC(v29, (xpc_object_t *)buf, (xpc_object_t *)v33);
      xpc_release(v31);
      xpc_release(v30);
    }
  }
}

void sub_100816AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100816B30(const __CFDictionary *a1, const void *a2)
{
  if (a1)
  {
    CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue(a1, a2);
    if (Value)
    {
      uint64_t v3 = Value;
      unsigned __int8 v10 = 0;
      CFTypeID v4 = CFGetTypeID(Value);
      CFTypeID TypeID = CFBooleanGetTypeID();
      int v7 = 0;
      if (v4 == TypeID)
      {
        ctu::cf::assign((ctu::cf *)&v10, v3, v6);
        int v7 = v10;
      }
      int v8 = 1;
    }
    else
    {
      int v7 = 0;
      int v8 = 0;
    }
  }
  else
  {
    int v7 = 0;
    int v8 = 0;
  }
  return v7 | (v8 << 8);
}

uint64_t sub_100816BB4(const __CFDictionary *a1)
{
  value = 0;
  uint64_t result = CFDictionaryGetValueIfPresent(a1, kCTPostponementInfoIMSIOverride, (const void **)&value);
  if (result)
  {
    CFBooleanRef v2 = (const __CFBoolean *)value;
    if (value && (CFTypeID v3 = CFGetTypeID(value), v3 == CFBooleanGetTypeID())) {
      return CFBooleanGetValue(v2) == 1;
    }
    else {
      return 0;
    }
  }
  return result;
}

void BasebandSettings::bbset_checkForCBFilesUpdate_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFBooleanRef v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Checking if any of the files need an update on baseband", v7, 2u);
  }
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 0, a3);
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 6, 0);
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 7, 0);
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 5, 0);
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 8, a3);
  BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 2, 0);
  if (*(unsigned char *)(a1 + 292) == 3) {
    *(unsigned char *)(a1 + 292) = 0;
  }
}

uint64_t BasebandSettings::fireBasebandPostponementStatus_sync(Registry **this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(this[12]);
  CFTypeID v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v14);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10)
  {
LABEL_10:
    char v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 72))(v10);
    sub_100358C28((uint64_t)&event::activation::basebandActivated, v12);
  }
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t result = (*(uint64_t (**)(Registry *, uint64_t))(*(void *)this[69] + 168))(this[69], 1);
  if (result == 1) {
    return (*(uint64_t (**)(Registry *, uint64_t))(*(void *)this[67] + 392))(this[67], 1);
  }
  return result;
}

void sub_100816ED8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100816EF0(uint64_t a1, int a2, char a3, _DWORD *a4)
{
  if (a2 == 2)
  {
    unsigned int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Checking for service provisioning", buf, 2u);
    }
    if (a3)
    {
      int v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v15 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Already Service Provisioned", v15, 2u);
      }
      if (sub_100818C20(*(void *)(a1 + 112), 1))
      {
        *a4 = 115;
        sub_100817184((void *)(a1 + 112), 1, (uint64_t)kCFBooleanFalse);
      }
      else
      {
        *a4 = 0;
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 536) + 392))(*(void *)(a1 + 536), 1);
      return 0;
    }
    int v11 = *(_DWORD *)(a1 + 772);
    if (v11 < *(unsigned __int8 *)(a1 + 768))
    {
      char v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Service provisioning is needed", v16, 2u);
        int v11 = *(_DWORD *)(a1 + 772);
      }
      *(_DWORD *)(a1 + 772) = v11 + 1;
      (*(void (**)(uint64_t, void))(*(void *)a1 + 96))(a1, 0);
      return 0;
    }
    *a4 = 116;
    sub_100818BD8((uint64_t)&event::activation::seviceProvisioningState, 2);
    unint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v17 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Reached maximum attempts for serviced provisioning", v17, 2u);
    }
    uint64_t v10 = 1;
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 536) + 392))(*(void *)(a1 + 536), 1);
  }
  else
  {
    *a4 = 0;
    uint64_t v9 = *(NSObject **)(a1 + 40);
    uint64_t v10 = 0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Ignoring checking for service provisioned since bundle type is not carrier ID based", v19, 2u);
      return 0;
    }
  }
  return v10;
}

void *sub_100817184(void *result, int a2, uint64_t a3)
{
  CFStringRef v3 = @"WaitingForActivationFlag2";
  if (a2 != 2) {
    CFStringRef v3 = 0;
  }
  if (a2 == 1) {
    CFStringRef v4 = @"WaitingForActivationFlag";
  }
  else {
    CFStringRef v4 = v3;
  }
  if (v4)
  {
    uint64_t v5 = result;
    (*(void (**)(void, const __CFString *, uint64_t, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)*result + 16))(*result, v4, a3, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)*v5 + 48);
    return (void *)v6();
  }
  return result;
}

void BasebandSettings::handleDefaultCarrierInfo_sync(uint64_t a1, uint64_t a2, int a3, int a4, CFDictionaryRef *a5, CFDictionaryRef *a6)
{
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received Default Carrier Activation Info Available event, initializing carrier bundle", buf, 2u);
  }
  CFDictionaryRef Value = (int *)CFDictionaryGetValue(*a6, kCTPostponementInfoSimProvisionedState);
  unsigned __int16 v13 = Value;
  if (Value)
  {
    CFTypeID v14 = CFGetTypeID(Value);
    if (v14 == CFNumberGetTypeID()) {
      BOOL v15 = v13;
    }
    else {
      BOOL v15 = 0;
    }
  }
  else
  {
    BOOL v15 = 0;
  }
  *(_DWORD *)long long buf = 0;
  ctu::cf::assign((ctu::cf *)buf, v15, v12);
  int v16 = *(_DWORD *)buf;
  int v17 = (BOOL *)CFDictionaryGetValue(*a6, kCTPostponementInfoMultiphaseSetup);
  uint64_t v19 = v17;
  if (v17)
  {
    CFTypeID v20 = CFGetTypeID(v17);
    if (v20 == CFBooleanGetTypeID()) {
      uint64_t v21 = v19;
    }
    else {
      uint64_t v21 = 0;
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v21, v18);
  int v22 = buf[0];
  unsigned __int16 v23 = sub_100816B30(*a6, @"ServiceProvisionState");
  char v24 = operator new(0x10uLL);
  *(void *)long long buf = v24;
  *(void *)&uint8_t buf[16] = v24 + 2;
  *char v24 = @"OTAActivation";
  v24[1] = @"PriVersion";
  *(void *)&uint8_t buf[8] = v24 + 2;
  CFStringRef theString = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)&buf[8], *(Registry **)(a1 + 96));
  uint64_t v26 = ServiceMap;
  if (v27 < 0)
  {
    uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v29 = 5381;
    do
    {
      uint64_t v27 = v29;
      unsigned int v30 = *v28++;
      uint64_t v29 = (33 * v29) ^ v30;
    }
    while (v30);
  }
  std::mutex::lock(ServiceMap);
  *(void *)CFDictionaryRef v59 = v27;
  xpc_object_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)v59);
  if (v31 && (int v32 = (std::__shared_weak_count *)v31[4]) != 0)
  {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v26);
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v32);
    char v33 = 0;
  }
  else
  {
    std::mutex::unlock(v26);
    int v32 = 0;
    char v33 = 1;
  }
  CarrierSettingsInterface::CopyValueFromActiveBundleForKeyHierarchy();
  sub_100056248(&theString, &v57);
  sub_1000577C4(&v57);
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  int v34 = v22;
  BOOL v37 = 0;
  if (v23 >= 0x100u && !(_BYTE)v23)
  {
    if (theString ? sub_1000810B8 : 0)
    {
      CFIndex Length = CFStringGetLength(theString);
      if (a3 == 1 && Length > 0) {
        BOOL v37 = 1;
      }
    }
  }
  sub_1000558F4((const void **)&theString);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v22)
  {
    if (!v16)
    {
      int v43 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#N Multiphase setup but don't know the SIM provisioned state", buf, 2u);
      }
      return;
    }
    BOOL v38 = v16 == 1;
    long long v39 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = asString();
      std::string::size_type v41 = "false";
      if (v16 == 1) {
        std::string::size_type v41 = "true";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v40;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v41;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Multiphase setup, SIM provisioned state: %s, using OTA files: %s", buf, 0x16u);
    }
  }
  else if (v37)
  {
    unint64_t v42 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Using OTA files for unbricking", buf, 2u);
    }
    BOOL v38 = 1;
  }
  else
  {
    BOOL v38 = 0;
  }
  if (a4)
  {
    if (a4 != 5)
    {
      uint64_t v44 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle has changed, Hence send PRL, PRI and EFS files", buf, 2u);
      }
      BasebandSettings::lineupFile_sync((void *)a1, a2, 0, v38);
      BasebandSettings::compareAndLineupFile_sync((void *)a1, a2, 6, 0);
      BasebandSettings::lineupFile_sync((void *)a1, a2, 5, 0);
      if (!*(unsigned char *)(a1 + 290)) {
        BasebandSettings::lineupFile_sync((void *)a1, a2, 2, v38);
      }
      BasebandSettings::lineupFile_sync((void *)a1, a2, 8, v38);
      *(unsigned char *)(a1 + 292) = 0;
      *(void *)long long buf = off_101A0E088;
      *(void *)&uint8_t buf[8] = a1;
      CFTypeID v61 = buf;
      BasebandSettings::sendLinedupFiles_sync(a1, buf);
LABEL_65:
      sub_10081A370(buf);
    }
  }
  else
  {
    uint64_t v45 = CFDictionaryGetValue(*a5, kCTPostponementInfoIMSI);
    if (v45)
    {
      CFTypeID v46 = CFGetTypeID(v45);
      if (v46 == CFStringGetTypeID())
      {
        BasebandSettings::bbset_checkForCBFilesUpdate_sync(a1, a2, v38);
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        BasebandSettings::getModel_sync(a1, a2, buf);
        uint64_t v47 = *(void *)buf;
        if (*(void *)buf)
        {
          uint64_t v48 = a2;
          sub_100058198(&v56, (const void **)a6);
          unsigned int v49 = (*(unsigned __int16 (**)(uint64_t, const void **))(*(void *)v47 + 112))(v47, &v56);
          sub_100057D78(&v56);
          if (v49 >= 0x100) {
            BasebandSettings::lineupFile_sync((void *)a1, v48, 0, 0);
          }
        }
        else
        {
          unint64_t v50 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CFDictionaryRef v59 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Could not get model for PRI mismatch detection", v59, 2u);
          }
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        *(void *)long long buf = off_101A0E108;
        *(void *)&uint8_t buf[8] = a1;
        CFTypeID v61 = buf;
        BasebandSettings::sendLinedupFiles_sync(a1, buf);
        goto LABEL_65;
      }
    }
    BasebandSettings::fireBasebandPostponementStatus_sync((Registry **)a1);
  }
  int v51 = (v34 != 0) & (*(uint64_t (**)(void))(**(void **)(a1 + 584) + 56))(*(void *)(a1 + 584)) & v38;
  if (v51 == 1)
  {
    long long v52 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I File transfer is in progress and we need to enter provisioning mode", buf, 2u);
    }
  }
  else
  {
    if (byte_101B0D9E9 != 1) {
      return;
    }
    unsigned __int8 v53 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Entering provisioning mode", buf, 2u);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 536) + 328))(*(void *)(a1 + 536), 1);
  }
  byte_101B0D9E9 = v51;
}

void sub_100817A04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *__p,std::__shared_weak_count *a26)
{
  if (a26) {
    sub_10004D2C8(a26);
  }
  _Unwind_Resume(exception_object);
}

const void **BasebandSettings::handleSIMCarrierInfo_sync(uint64_t a1, unsigned int a2, uint64_t a3, int a4, CFDictionaryRef *a5, CFDictionaryRef *a6)
{
  uint64_t v8 = a1;
  uint64_t v9 = (os_log_t *)(a1 + 40);
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Received SIM Carrier Activation Info Available event, initializing carrier bundle", buf, 2u);
  }
  uint64_t v101 = 0;
  *(void *)long long buf = CFDictionaryGetValue(*a5, kCTPostponementInfoIMSI);
  sub_100056248(&v101, (CFTypeRef *)buf);
  CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue(*a6, kCTPostponementInfoMultiphaseSetup);
  CFNumberRef v12 = Value;
  if (Value)
  {
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 != CFBooleanGetTypeID()) {
      CFNumberRef v12 = 0;
    }
  }
  CFTypeID v14 = (int *)CFDictionaryGetValue(*a6, kCTPostponementInfoSimProvisionedState);
  int v16 = v14;
  if (v14)
  {
    CFTypeID v17 = CFGetTypeID(v14);
    if (v17 == CFNumberGetTypeID()) {
      CFBooleanRef v18 = v16;
    }
    else {
      CFBooleanRef v18 = 0;
    }
  }
  else
  {
    CFBooleanRef v18 = 0;
  }
  *(_DWORD *)long long buf = 0;
  ctu::cf::assign((ctu::cf *)buf, v18, v15);
  int v19 = *(_DWORD *)buf;
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v12, v20);
  int v21 = buf[0];
  if (buf[0] && !v19)
  {
    int v22 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#E Activated with multiphaseSetup but don't know the SIM provisioned state", buf, 2u);
    }
    return sub_1000558F4(&v101);
  }
  if (!a4) {
    goto LABEL_19;
  }
  if (a4 != 4)
  {
    int v95 = buf[0];
    long long v96 = (uint64_t *)(v8 + 96);
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(v8 + 96), *(Registry **)(v8 + 96));
    unsigned int v30 = ServiceMap;
    uint64_t v32 = v31;
    if (v31 < 0)
    {
      char v33 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v34 = 5381;
      do
      {
        uint64_t v32 = v34;
        unsigned int v35 = *v33++;
        uint64_t v34 = (33 * v34) ^ v35;
      }
      while (v35);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v32;
    uint64_t v36 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)buf);
    if (v36)
    {
      uint64_t v37 = v8;
      BOOL v38 = a6;
      uint64_t v40 = (CarrierSettingsInterface *)v36[3];
      long long v39 = (std::__shared_weak_count *)v36[4];
      if (v39)
      {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        CFStringRef v94 = v39;
        sub_10004D2C8(v39);
        a6 = v38;
        uint64_t v8 = v37;
        char v41 = 0;
        goto LABEL_40;
      }
      a6 = v38;
      uint64_t v8 = v37;
    }
    else
    {
      uint64_t v40 = 0;
    }
    std::mutex::unlock(v30);
    CFStringRef v94 = 0;
    char v41 = 1;
LABEL_40:
    CarrierSettingsInterface::CopyValueFromActiveBundleForKey((uint64_t *)v103, v40, @"PriVersion", 0);
    if (*(void *)v103) {
      int v43 = sub_100080934;
    }
    else {
      int v43 = 0;
    }
    if (!v43)
    {
      BOOL v53 = 0;
      goto LABEL_58;
    }
    uint64_t v44 = (std::mutex *)Registry::getServiceMap(v96, (Registry *)*v96);
    uint64_t v45 = v44;
    uint64_t v46 = v31;
    if (v31 < 0)
    {
      uint64_t v47 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v48 = 5381;
      do
      {
        uint64_t v46 = v48;
        unsigned int v49 = *v47++;
        uint64_t v48 = (33 * v48) ^ v49;
      }
      while (v49);
    }
    std::mutex::lock(v44);
    *(void *)long long buf = v46;
    unint64_t v50 = sub_10004D37C(&v45[1].__m_.__sig, (unint64_t *)buf);
    if (v50)
    {
      int v51 = (CarrierSettingsInterface *)v50[3];
      long long v52 = (std::__shared_weak_count *)v50[4];
      if (v52)
      {
        atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v45);
        atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v52);
        goto LABEL_53;
      }
    }
    else
    {
      int v51 = 0;
    }
    std::mutex::unlock(v45);
    long long v52 = 0;
LABEL_53:
    CarrierSettingsInterface::CopyValueFromActiveBundleForKey((uint64_t *)&v102, v51, @"PRIFileName", 0);
    if (v102) {
      std::string v54 = sub_100080934;
    }
    else {
      std::string v54 = 0;
    }
    BOOL v53 = v54 != 0;
    sub_1000577C4(&v102);
    if (v52) {
      sub_10004D2C8(v52);
    }
LABEL_58:
    std::string v55 = sub_1000577C4((const void **)v103);
    if ((v41 & 1) == 0) {
      sub_10004D2C8(v94);
    }
    if (v53)
    {
      BOOL v56 = 0;
LABEL_70:
      int v21 = v95;
LABEL_71:
      if (a4 != 2) {
        BOOL v56 = 0;
      }
      sub_100058198(&v100, (const void **)a5);
      v106[0] = off_101A0E188;
      v106[1] = v8;
      v106[3] = v106;
      int v66 = sub_100BC82A4((uint64_t)v96, v9, (uint64_t)&v100, (uint64_t)v106);
      sub_10081ACB4(v106);
      sub_100057D78(&v100);
      uint64_t v67 = (capabilities::ct *)sub_100816B30(*a6, @"ServiceProvisionState");
      int v68 = (a4 != 5) ^ v56;
      if ((_BYTE)v67) {
        BOOL v69 = 0;
      }
      else {
        BOOL v69 = (unsigned __int16)v67 > 0xFFu;
      }
      int v70 = v69;
      if ((v68 | v66) == 1)
      {
        uint64_t v71 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle has changed. Hence send PRL, PRI files", buf, 2u);
        }
        BasebandSettings::lineupFile_sync((void *)v8, a2, 0, 0);
        BasebandSettings::compareAndLineupFile_sync((void *)v8, a2, 6, 0);
        if (v70) {
          BasebandSettings::lineupFile_sync((void *)v8, a2, 2, 0);
        }
        BasebandSettings::lineupFile_sync((void *)v8, a2, 5, 0);
        BasebandSettings::lineupFile_sync((void *)v8, a2, 8, 0);
        *(unsigned char *)(v8 + 292) = 0;
        *(void *)long long buf = off_101A0E218;
        *(void *)&uint8_t buf[8] = v8;
        CFDictionaryRef v105 = buf;
        BasebandSettings::sendLinedupFiles_sync(v8, buf);
      }
      else
      {
        if (v56)
        {
          int v72 = capabilities::ct::supportsDualSIMSingleStackWithCrossMapping(v67);
          uint64_t v73 = *v9;
          BOOL v74 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
          if (v72)
          {
            if (v74)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I New carrier uses default PRI. Force PRI push", buf, 2u);
            }
            BasebandSettings::lineupFile_sync((void *)v8, a2, 0, 0);
          }
          else
          {
            if (v74)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I New carrier uses default PRI. Check if default PRI needs to be pushed", buf, 2u);
            }
            BasebandSettings::compareAndLineupFile_sync((void *)v8, a2, 0, 0);
          }
        }
        os_log_t v75 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I No carrier bundle change, evaluating if AttachAPN needs to be pushed", buf, 2u);
        }
        BasebandSettings::compareAndLineupFile_sync((void *)v8, a2, 8, 0);
        *(void *)long long buf = off_101A0E298;
        *(void *)&uint8_t buf[8] = v8;
        CFDictionaryRef v105 = buf;
        BasebandSettings::sendLinedupFiles_sync(v8, buf);
      }
      goto LABEL_96;
    }
    if (!capabilities::ct::supportsDERFileFormat((capabilities::ct *)v55))
    {
      BOOL v56 = 1;
      goto LABEL_70;
    }
    CFDictionaryRef v57 = (std::mutex *)Registry::getServiceMap(v96, (Registry *)*v96);
    int64_t v58 = v57;
    uint64_t v59 = v31;
    if (v31 < 0)
    {
      CFDictionaryRef v60 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v61 = 5381;
      do
      {
        uint64_t v59 = v61;
        unsigned int v62 = *v60++;
        uint64_t v61 = (33 * v61) ^ v62;
      }
      while (v62);
    }
    std::mutex::lock(v57);
    *(void *)long long buf = v59;
    CFStringRef v63 = sub_10004D37C(&v58[1].__m_.__sig, (unint64_t *)buf);
    if (v63)
    {
      CFStringRef v65 = (CarrierSettingsInterface *)v63[3];
      uint64_t v64 = (std::__shared_weak_count *)v63[4];
      if (v64)
      {
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v58);
        atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v64);
        goto LABEL_119;
      }
    }
    else
    {
      CFStringRef v65 = 0;
    }
    std::mutex::unlock(v58);
    uint64_t v64 = 0;
LABEL_119:
    CarrierSettingsInterface::CopyValueFromActiveBundleForKey((uint64_t *)v103, v65, @"DerPriFileVersion", 0);
    int v21 = v95;
    if (*(void *)v103) {
      long long v84 = sub_100080934;
    }
    else {
      long long v84 = 0;
    }
    if (!v84)
    {
      BOOL v56 = 1;
LABEL_137:
      sub_1000577C4((const void **)v103);
      if (v64) {
        sub_10004D2C8(v64);
      }
      goto LABEL_71;
    }
    long long v85 = (std::mutex *)Registry::getServiceMap(v96, (Registry *)*v96);
    long long v86 = v85;
    if (v31 < 0)
    {
      long long v87 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v88 = 5381;
      do
      {
        uint64_t v31 = v88;
        unsigned int v89 = *v87++;
        uint64_t v88 = (33 * v88) ^ v89;
      }
      while (v89);
    }
    std::mutex::lock(v85);
    *(void *)long long buf = v31;
    long long v90 = sub_10004D37C(&v86[1].__m_.__sig, (unint64_t *)buf);
    if (v90)
    {
      long long v91 = (CarrierSettingsInterface *)v90[3];
      long long v92 = (std::__shared_weak_count *)v90[4];
      if (v92)
      {
        atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v86);
        atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v92);
        goto LABEL_132;
      }
    }
    else
    {
      long long v91 = 0;
    }
    std::mutex::unlock(v86);
    long long v92 = 0;
LABEL_132:
    CarrierSettingsInterface::CopyValueFromActiveBundleForKey((uint64_t *)&v102, v91, @"DerPriFileName", 0);
    int v21 = v95;
    if (v102) {
      long long v93 = sub_100080934;
    }
    else {
      long long v93 = 0;
    }
    BOOL v56 = v93 == 0;
    sub_1000577C4(&v102);
    if (v92) {
      sub_10004D2C8(v92);
    }
    goto LABEL_137;
  }
  unsigned __int16 v23 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = asString();
    uint64_t v25 = asString();
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v24;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v25;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Overriding %s with %s", buf, 0x16u);
  }
LABEL_19:
  if (v101) {
    uint64_t v26 = sub_1000810B8;
  }
  else {
    uint64_t v26 = 0;
  }
  if (!v26) {
    goto LABEL_97;
  }
  BasebandSettings::bbset_checkForCBFilesUpdate_sync(v8, a2, 0);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  BasebandSettings::getModel_sync(v8, a2, buf);
  uint64_t v27 = *(void *)buf;
  if (*(void *)buf)
  {
    sub_100058198(&v99, (const void **)a6);
    unsigned int v28 = (*(unsigned __int16 (**)(uint64_t, const void **))(*(void *)v27 + 112))(v27, &v99);
    sub_100057D78(&v99);
    if (v28 >= 0x100) {
      BasebandSettings::lineupFile_sync((void *)v8, a2, 0, 0);
    }
  }
  else
  {
    unint64_t v42 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v8 + 48) + 16))(*(void *)(v8 + 48), a2);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v103 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Could not get model for PRI mismatch detection", v103, 2u);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  *(void *)long long buf = off_101A0E318;
  *(void *)&uint8_t buf[8] = v8;
  CFDictionaryRef v105 = buf;
  BasebandSettings::sendLinedupFiles_sync(v8, buf);
LABEL_96:
  sub_10081A370(buf);
LABEL_97:
  BOOL v76 = !sub_1008187C8(v8);
  if (!v21) {
    LOBYTE(v76) = 1;
  }
  if (!v76)
  {
    long long v77 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(v8 + 584) + 56))(*(void *)(v8 + 584));
    char v78 = v19 ? (char)v77 : 1;
    if ((v78 & 1) == 0)
    {
      if (v19 == 1 && *(_DWORD *)(v8 + 772) < (int)*(unsigned __int8 *)(v8 + 768))
      {
        int v79 = capabilities::ct::supportsCambioModeQuery(v77);
        long long v80 = *v9;
        BOOL v81 = os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT);
        if (v79)
        {
          if (v81)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I SIM is cold, querying provisioning mode", buf, 2u);
          }
          (*(void (**)(void))(**(void **)(v8 + 536) + 336))(*(void *)(v8 + 536));
        }
        else
        {
          if (v81)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I SIM is cold, now triggering an OTASP", buf, 2u);
          }
          ++*(_DWORD *)(v8 + 772);
          (*(void (**)(uint64_t, void))(*(void *)v8 + 96))(v8, 0);
        }
      }
      else
      {
        long long v82 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I Notifying SIM provisioned state", buf, 2u);
        }
        sub_100358C28((uint64_t)&event::activation::simProvisionedState, v19 == 2);
      }
    }
  }
  return sub_1000558F4(&v101);
}

void sub_1008186A8(_Unwind_Exception *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  CFTypeID v13 = va_arg(va1, const void *);
  uint64_t v15 = va_arg(va1, void);
  if ((v9 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  sub_1000577C4((const void **)va1);
  if ((a3 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1008187C8(uint64_t a1)
{
  CFBooleanRef v2 = operator new(0x10uLL);
  CFBooleanRef v18 = v2 + 2;
  int v19 = v2 + 2;
  *CFBooleanRef v2 = @"OTAActivation";
  v2[1] = @"SupportsColdSIMActivation";
  int v16 = 0;
  long long __p = v2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
  CFStringRef v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, &v20);
  if (v9 && (uint64_t v10 = (std::__shared_weak_count *)v9[4]) != 0)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v4);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    char v11 = 0;
  }
  else
  {
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v11 = 1;
  }
  CarrierSettingsInterface::CopyValueFromActiveBundleForKeyHierarchyWithDefault();
  sub_1000057AC(&v16, &v15);
  sub_1000577C4(&v15);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  LOBYTE(v20) = 0;
  ctu::cf::assign((ctu::cf *)&v20, v16, v12);
  int v13 = v20;
  sub_100062778((const void **)&v16);
  if (__p)
  {
    CFBooleanRef v18 = __p;
    operator delete(__p);
  }
  return v13 != 0;
}

void sub_100818928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12)
{
  if (__p)
  {
    a12 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL BasebandSettings::isSupportingColdSIMActivation(BasebandSettings *this)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100818AEC;
  v4[3] = &unk_101A0DFB8;
  void v4[4] = this;
  unint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_10081AFE8;
  void v6[3] = &unk_101A0E388;
  v6[4] = (char *)this + 8;
  v6[5] = &v5;
  uint64_t v7 = v6;
  CFBooleanRef v2 = (char *)this + 24;
  char v1 = *((void *)this + 3);
  if (*((void *)v2 + 1))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10005AFB4;
    char v11 = &unk_101A0E3C8;
    CFBooleanRef v12 = &v14;
    int v13 = &v7;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10005A250;
    char v11 = &unk_101A0E3A8;
    CFBooleanRef v12 = &v14;
    int v13 = &v7;
    dispatch_sync(v1, &block);
  }
  return v14 != 0;
}

BOOL sub_100818AEC(uint64_t a1)
{
  return sub_1008187C8(*(void *)(a1 + 32));
}

void BasebandSettings::checkForOTASP(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v8 = a2;
  if (a2)
  {
    v7[0] = a1;
    v7[1] = &v8;
    void v7[2] = a3;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_10081AFFC;
    block[3] = &unk_101A0E3E8;
    block[4] = a1 + 8;
    block[5] = v7;
    uint64_t v5 = a1 + 24;
    CFStringRef v4 = *(NSObject **)(a1 + 24);
    if (*(void *)(v5 + 8)) {
      dispatch_async_and_wait(v4, block);
    }
    else {
      dispatch_sync(v4, block);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N Cannot check for OTASP without a service provisioned state", (uint8_t *)block, 2u);
    }
    *a3 = 0;
  }
}

atomic_uint **sub_100818BD8(uint64_t a1, int a2)
{
  sub_10081B064((uint64_t *)(a1 + 24));
  CFStringRef v4 = (uint64_t *)sub_10081B200((uint64_t *)(a1 + 8));

  return sub_10081B244(v4, a2);
}

uint64_t sub_100818C20(uint64_t a1, int a2)
{
  unsigned int v3 = a2 - 1;
  if ((a2 - 1) <= 1)
  {
    uint64_t v7 = 0;
    (*(void (**)(const void **__return_ptr))(*(void *)a1 + 40))(&v6);
    sub_1000057AC(&v7, &v6);
    sub_1000577C4(&v6);
    LOBYTE(v6) = 0;
    ctu::cf::assign((ctu::cf *)&v6, v7, v4);
    BOOL v2 = (_BYTE)v6 != 0;
    sub_100062778((const void **)&v7);
  }
  return (v3 < 2) & v2;
}

void sub_100818D00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void BasebandSettings::performCarrierServiceProvisioning(BasebandSettings *this)
{
  BOOL v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Going to perform service provisioning", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v8 = 0;
  sub_100224000(*((Registry **)this + 12), buf);
  unsigned int v3 = *(CallController **)buf;
  CFBooleanRef v4 = *((void *)this + 5);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Starting OTASP service provisioning", v6, 2u);
    }
    sub_100818BD8((uint64_t)&event::activation::seviceProvisioningState, 0);
    CallController::startOTASP(*(CallController **)buf);
  }
  else if (v5)
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E Can't start OTASP because Call Controller is not valid", v6, 2u);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100818E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void BasebandSettings::fireSimProvisionedState(BasebandSettings *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void BasebandSettings::handleCardProvisionedState(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void BasebandSettings::incrementOTASPAttempts(BasebandSettings *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void BasebandSettings::clearOTASPAttempts(BasebandSettings *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void BasebandSettings::otaspStatusAvailable(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void BasebandSettings::otaspCommitFailed(BasebandSettings *this)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_1008193B8;
  v3[3] = &unk_101A0DFD8;
  v3[4] = this;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_10003E168(&v6, (void *)this + 1);
  BOOL v2 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10081CF00;
  block[3] = &unk_101A0E4D0;
  block[5] = v6;
  BOOL v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

atomic_uint **sub_1008193B8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = (atomic_uint **)sub_1008187C8(v1);
  if (result)
  {
    unsigned int v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFBooleanRef v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I OTASP failed, now enter provisioning mode!", v4, 2u);
    }
    return sub_100358C28((uint64_t)&event::activation::simProvisionedState, 0);
  }
  return result;
}

void BasebandSettings::handleSimState_sync(BasebandSettings *this)
{
  BOOL v2 = (BasicSimInfo *)*((void *)this + 33);
  if (v2 != *((BasicSimInfo **)this + 34) && BasicSimInfo::isEmptyEsimCapableCard(v2))
  {
    unsigned int v3 = *((void *)this + 5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFBooleanRef v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I vinyl SIM with no active profile clearing OTASP attempts", v4, 2u);
    }
    *((_DWORD *)this + 193) = 0;
  }
}

void BasebandSettings::resetBasebandUserSettings(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void BasebandSettings::resetBBAfterFileTransferComplete_sync(BasebandSettings *this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*((Registry **)this + 12));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 72))(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v12
    && CarrierBundleInterface::getCarrierBundleTechType(*((CarrierBundleInterface **)this + 69)) == 2)
  {
    int v13 = *((void *)this + 5);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = "true";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Restoring Carrier NV before resetting the baseband, activation state is: %s", buf, 0xCu);
    }
    char v14 = (std::mutex *)Registry::getServiceMap(*((Registry **)this + 12));
    uint64_t v15 = v14;
    if (v16 < 0)
    {
      CFTypeID v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(v14);
    *(void *)long long buf = v16;
    unint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      int v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
        goto LABEL_35;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    int v21 = 0;
    char v23 = 1;
LABEL_35:
    unsigned int v30 = *((void *)this + 5);
    if (!v22)
    {
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Missing ABM client interface", buf, 2u);
      }
      goto LABEL_58;
    }
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I RestoreCarrierNV. Will reset after successfull command", buf, 2u);
    }
    long long __p = 0;
    xpc_object_t v31 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v32 = v31;
    if (v31)
    {
      long long __p = v31;
    }
    else
    {
      xpc_object_t v32 = xpc_null_create();
      long long __p = v32;
      if (!v32)
      {
        xpc_object_t v33 = xpc_null_create();
        xpc_object_t v32 = 0;
        goto LABEL_47;
      }
    }
    if (xpc_get_type(v32) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v32);
LABEL_48:
      xpc_release(v32);
      xpc_object_t v42 = xpc_string_create(abm::kBasebandNVDataRestoreCarrierDefaults);
      if (!v42) {
        xpc_object_t v42 = xpc_null_create();
      }
      *(void *)long long buf = &__p;
      *(void *)&uint8_t buf[8] = abm::kKeyBasebandNVDataAction;
      sub_100035E70((uint64_t)buf, &v42, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v42);
      xpc_object_t v41 = __p;
      xpc_object_t v42 = 0;
      if (__p) {
        xpc_retain(__p);
      }
      else {
        xpc_object_t v41 = xpc_null_create();
      }
      uint64_t v34 = abm::kCommandBasebandNVData;
      unsigned int v35 = *((void *)this + 3);
      dispatch_object_t v40 = v35;
      if (v35) {
        dispatch_retain(v35);
      }
      *(void *)long long buf = off_101A0E610;
      *(void *)&uint8_t buf[8] = this;
      *((void *)&v45 + 1) = buf;
      (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, uint8_t *))(*(void *)v22 + 48))(v22, v34, &v41, &v40, buf);
      sub_1000595E4(buf);
      if (v40) {
        dispatch_release(v40);
      }
      xpc_release(v41);
      xpc_object_t v41 = 0;
      xpc_release(__p);
LABEL_58:
      if ((v23 & 1) == 0) {
        sub_10004D2C8(v21);
      }
      return;
    }
    xpc_object_t v33 = xpc_null_create();
LABEL_47:
    long long __p = v33;
    goto LABEL_48;
  }
  uint64_t v24 = *((void *)this + 5);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = "false";
    if (v12) {
      uint64_t v25 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Resetting the baseband without restoring carrier NV and activation state is: %s", buf, 0xCu);
  }
  uint64_t v60 = 0;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_10004DE24((uint64_t)buf);
  uint64_t v26 = sub_10004B96C(buf, (uint64_t)"Resetting baseband after pushing files (due to ", 47);
  uint64_t v27 = (const char *)asString();
  size_t v28 = strlen(v27);
  uint64_t v29 = sub_10004B96C(v26, (uint64_t)v27, v28);
  sub_10004B96C(v29, (uint64_t)")", 1);
  sub_10004BC98((uint64_t)&buf[8], &v36);
  rest::ResetPayload::ResetPayload();
  sub_1004BC4DC();
  if (v39 < 0) {
    operator delete(__p);
  }
  if (v37 < 0) {
    operator delete(v36);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete(*((void **)&v48 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
}

void sub_100819C14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t __p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,dispatch_object_t object,xpc_object_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void BasebandSettings::triggerRFSSync_sync(Registry **this)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, this[12]);
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v12 = 1;
    if (!v10) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v12 = 0;
  if (!v10)
  {
LABEL_15:
    int v14 = 1;
    if ((v12 & 1) == 0) {
      goto LABEL_16;
    }
    goto LABEL_13;
  }
LABEL_10:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10)) {
    goto LABEL_15;
  }
  int v13 = this[5];
  int v14 = 0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Simulating successful RFS sync", buf, 2u);
    int v14 = 0;
    if ((v12 & 1) == 0)
    {
LABEL_16:
      sub_10004D2C8(v9);
      if (!v14) {
        return;
      }
      goto LABEL_17;
    }
  }
  else if ((v12 & 1) == 0)
  {
    goto LABEL_16;
  }
LABEL_13:
  if (!v14) {
    return;
  }
LABEL_17:
  uint64_t v15 = (std::mutex *)Registry::getServiceMap(v11, this[12]);
  uint64_t v16 = v15;
  if (v17 < 0)
  {
    uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v15);
  *(void *)long long buf = v17;
  int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
  if (v21)
  {
    uint64_t v23 = v21[3];
    uint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v24 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v16);
  uint64_t v22 = 0;
  char v24 = 1;
LABEL_25:
  uint64_t v25 = this[5];
  if (!v23)
  {
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to trigger BB RFS sync. Missing ABM client interface", buf, 2u);
    }
    goto LABEL_52;
  }
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Triggering BB RFS sync", buf, 2u);
  }
  xpc_object_t v40 = 0;
  xpc_object_t v26 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v27 = v26;
  if (v26)
  {
    xpc_object_t v40 = v26;
  }
  else
  {
    xpc_object_t v27 = xpc_null_create();
    xpc_object_t v40 = v27;
    if (!v27)
    {
      xpc_object_t v28 = xpc_null_create();
      xpc_object_t v27 = 0;
      goto LABEL_39;
    }
  }
  if (xpc_get_type(v27) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v28 = xpc_null_create();
LABEL_39:
    xpc_object_t v40 = v28;
    goto LABEL_40;
  }
  xpc_retain(v27);
LABEL_40:
  xpc_release(v27);
  xpc_object_t v38 = xpc_BOOL_create(1);
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  *(void *)long long buf = &v40;
  uint64_t v37 = abm::kKeyFSSyncWaitForCompletion;
  sub_100035E70((uint64_t)buf, &v38, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_object_t v35 = v40;
  if (v40) {
    xpc_retain(v40);
  }
  else {
    xpc_object_t v35 = xpc_null_create();
  }
  uint64_t v29 = this[3];
  dispatch_object_t v34 = v29;
  if (v29) {
    dispatch_retain(v29);
  }
  xpc_object_t v31 = this[62];
  unsigned int v30 = this[63];
  if (v30) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v30 + 1, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v42 = 0;
  xpc_object_t v32 = operator new(0x20uLL);
  uint64_t v33 = abm::kCommandBasebandSyncFS;
  *xpc_object_t v32 = off_101A0E690;
  v32[1] = this;
  v32[2] = v31;
  v32[3] = v30;
  xpc_object_t v42 = v32;
  (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, void *))(*(void *)v23 + 48))(v23, v33, &v35, &v34, v41);
  sub_1000595E4(v41);
  if (v34) {
    dispatch_release(v34);
  }
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(v40);
LABEL_52:
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
}

void sub_10081A15C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, char a16)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void BasebandSettings::triggerPriRefreshStart_sync(uint64_t a1, int a2)
{
  uint64_t v3 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Triggering PRI refresh start", buf, 2u);
  }
  xpc_object_t v9 = 0;
  uint64_t v4 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, (ctu::rest::detail *)a2, v4, v5);
  sub_100058DB0(buf, "/cc/events/baseband_refresh_start");
  xpc_object_t object = v9;
  xpc_object_t v9 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(*(void **)buf);
  }
  xpc_release(v9);
}

void sub_10081A32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(a17);
  _Unwind_Resume(a1);
}

void *sub_10081A370(void *a1)
{
  BOOL v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10081A3F8()
{
}

void *sub_10081A40C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E008;
  result[1] = v3;
  return result;
}

uint64_t sub_10081A454(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E008;
  a2[1] = v2;
  return result;
}

uint64_t sub_10081A480(uint64_t a1)
{
  return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(a1 + 8));
}

uint64_t sub_10081A488(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081A4C8()
{
}

void sub_10081A4D8()
{
}

void *sub_10081A4EC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E088;
  result[1] = v3;
  return result;
}

uint64_t sub_10081A534(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E088;
  a2[1] = v2;
  return result;
}

uint64_t sub_10081A560(uint64_t a1)
{
  return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(a1 + 8));
}

uint64_t sub_10081A568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081A5A8()
{
}

void sub_10081A5B8()
{
}

void *sub_10081A5CC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E108;
  result[1] = v3;
  return result;
}

uint64_t sub_10081A614(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E108;
  a2[1] = v2;
  return result;
}

uint64_t sub_10081A640(uint64_t a1)
{
  return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(a1 + 8));
}

uint64_t sub_10081A648(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081A688()
{
}

void sub_10081A698()
{
}

void *sub_10081A6AC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E188;
  result[1] = v3;
  return result;
}

uint64_t sub_10081A6F4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E188;
  a2[1] = v2;
  return result;
}

const void **sub_10081A720@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v36 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 96));
  BOOL v5 = ServiceMap;
  unsigned int v7 = (void *)v6;
  if (v6 < 0)
  {
    char v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unsigned int v7 = (void *)v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = v7;
  char v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v11)
  {
    uint64_t v13 = v11[3];
    char v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  char v12 = 0;
  char v14 = 1;
LABEL_9:
  uint64_t v15 = operator new(0x10uLL);
  uint64_t v16 = kCarrier1BundleId;
  __p[1] = v15 + 2;
  xpc_object_t v38 = v15 + 2;
  void *v15 = @"OTAActivation";
  v15[1] = @"PriVersion";
  __p[0] = v15;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, void **, void, void))(*(void *)v13 + 24))(v33, v13, v16, __p, 0, 0);
  sub_100056248(&v36, (CFTypeRef *)v33);
  sub_1000577C4((const void **)v33);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v36) {
    uint64_t v17 = sub_1000810B8;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v17)
  {
    xpc_object_t v35 = 0;
    uint64_t v18 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 96));
    uint64_t v19 = v18;
    if (v6 < 0)
    {
      unsigned int v20 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v6 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(v18);
    __p[0] = (void *)v6;
    uint64_t v23 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)__p);
    if (v23)
    {
      uint64_t v25 = v23[3];
      char v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
LABEL_28:
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v25 + 40))(v33, v25, v16, @"PriVersion", 0, 0);
        sub_100056248(&v35, (CFTypeRef *)v33);
        sub_1000577C4((const void **)v33);
        if ((v26 & 1) == 0) {
          sub_10004D2C8(v24);
        }
        if (v35) {
          xpc_object_t v28 = sub_1000810B8;
        }
        else {
          xpc_object_t v28 = 0;
        }
        if (v28)
        {
          __p[0] = 0;
          __p[1] = 0;
          xpc_object_t v38 = 0;
          ctu::cf::assign();
          *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
          dispatch_object_t v34 = v38;
          __p[0] = 0;
          __p[1] = 0;
          xpc_object_t v38 = 0;
          ctu::cf::assign();
          *(_OWORD *)xpc_object_t v31 = *(_OWORD *)__p;
          xpc_object_t v32 = v38;
          sub_10081AC1C((char *)a2, (long long *)v33, (long long *)v31);
          if (SHIBYTE(v32) < 0) {
            operator delete(v31[0]);
          }
          if (SHIBYTE(v34) < 0) {
            operator delete(v33[0]);
          }
        }
        else
        {
          uint64_t v29 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#N Did not find PriVersion key in carrier bundle", (uint8_t *)__p, 2u);
          }
          *(_OWORD *)(a2 + 16) = 0u;
          *(_OWORD *)(a2 + 32) = 0u;
          *(_OWORD *)a2 = 0u;
        }
        sub_1000558F4(&v35);
        return sub_1000558F4(&v36);
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v19);
    char v24 = 0;
    char v26 = 1;
    goto LABEL_28;
  }
  xpc_object_t v27 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N Did not find OTA PriVersion key in carrier bundle", (uint8_t *)__p, 2u);
  }
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return sub_1000558F4(&v36);
}

void sub_10081AAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,const void *a23,const void *a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  sub_1000558F4(&a23);
  sub_1000558F4(&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_10081ABD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081AC10()
{
}

char *sub_10081AC1C(char *__dst, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  uint64_t v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v6 = v7;
  }
  return __dst;
}

void sub_10081AC98(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10081ACB4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10081AD3C()
{
}

void *sub_10081AD50(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E218;
  result[1] = v3;
  return result;
}

uint64_t sub_10081AD98(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E218;
  a2[1] = v2;
  return result;
}

uint64_t sub_10081ADC4(uint64_t a1)
{
  return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(a1 + 8));
}

uint64_t sub_10081ADCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081AE0C()
{
}

void sub_10081AE1C()
{
}

void *sub_10081AE30(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E298;
  result[1] = v3;
  return result;
}

uint64_t sub_10081AE78(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E298;
  a2[1] = v2;
  return result;
}

uint64_t sub_10081AEA4(uint64_t a1)
{
  return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(a1 + 8));
}

uint64_t sub_10081AEAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081AEEC()
{
}

void sub_10081AEFC()
{
}

void *sub_10081AF10(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E318;
  result[1] = v3;
  return result;
}

uint64_t sub_10081AF58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E318;
  a2[1] = v2;
  return result;
}

uint64_t sub_10081AF84(uint64_t result, _DWORD *a2)
{
  if (*a2 == 1) {
    return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(result + 8));
  }
  return result;
}

uint64_t sub_10081AF9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081AFDC()
{
}

void *sub_10081AFE8(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_10081AFFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int CarrierBundleTechType = CarrierBundleInterface::getCarrierBundleTechType(*(CarrierBundleInterface **)(*(void *)v1 + 552));
  char v4 = CFBooleanGetValue(**(CFBooleanRef **)(v1 + 8)) != 0;
  long long v5 = *(_DWORD **)(v1 + 16);

  return sub_100816EF0(v2, CarrierBundleTechType, v4, v5);
}

uint64_t sub_10081B064(uint64_t *a1)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v5 + 8, __p);
  sub_1001AA668(a1, (uint64_t *)__p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10081B1E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10081B200(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_10081B244(uint64_t *a1, int a2)
{
  int v24 = a2;
  long long v23 = 0uLL;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v3 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v27, v3);
  uint64_t v4 = a1[1];
  if (v4)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) == 1) {
      sub_10081B4C0(a1, &v27, 0, 1);
    }
    uint64_t v5 = *a1;
    uint64_t v6 = a1[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = *a1;
  }
  long long v7 = v23;
  *(void *)&long long v23 = v5;
  *((void *)&v23 + 1) = v6;
  v26[0] = v7;
  sub_10000A740((atomic_uint **)v26 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v38 + 1));
  sub_10000A5F8(&v27);
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  uint64_t v42 = 0;
  uint64_t v43 = 10;
  uint64_t v44 = (char *)&v27 + 8;
  uint64_t v45 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  long long v46 = &v24;
  long long v8 = (uint64_t *)sub_10081B574((uint64_t *)&v23);
  v22[0] = &v27;
  v22[1] = a1;
  v22[2] = sub_10081B7E4(v8);
  uint64_t v9 = sub_10081B574((uint64_t *)&v23);
  uint64_t v10 = sub_100060EA8((uint64_t *)(v9 + 16));
  long long v11 = (uint64_t *)sub_10081B574((uint64_t *)&v23);
  uint64_t v12 = *(void *)(sub_10081B7E4(v11) + 8);
  long long v13 = (uint64_t *)sub_10081B574((uint64_t *)&v23);
  *(void *)&long long v20 = v12;
  *((void *)&v20 + 1) = sub_10081B7E4(v13);
  *(void *)&long long v21 = &v27;
  *((void *)&v21 + 1) = *((void *)&v20 + 1);
  sub_10081BA48((uint64_t *)&v20);
  long long v14 = (uint64_t *)sub_10081B574((uint64_t *)&v23);
  uint64_t v15 = sub_10081B7E4(v14);
  long long v16 = (uint64_t *)sub_10081B574((uint64_t *)&v23);
  *(void *)&long long v18 = v15;
  *((void *)&v18 + 1) = sub_10081B7E4(v16);
  *(void *)&long long v19 = &v27;
  *((void *)&v19 + 1) = *((void *)&v18 + 1);
  sub_10081BA48((uint64_t *)&v18);
  v26[0] = v20;
  v26[1] = v21;
  v25[0] = v18;
  v25[1] = v19;
  sub_10081B828(v10, (uint64_t *)v26, v25);
  sub_10081BE08((uint64_t)v22);
  sub_10081C6E0((uint64_t)&v27);
  return sub_10000A740((atomic_uint **)&v23 + 1);
}

void sub_10081B46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t *sub_10081B4C0(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_10081B574(a1);
  uint64_t v10 = sub_10081B7E4(v9);
  long long v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    uint64_t v12 = (uint64_t *)sub_10081B574(a1);
    long long v11 = *(uint64_t **)(sub_10081B7E4(v12) + 8);
  }
  long long v14 = v11;
  return sub_10081B5B8(a1, a2, a3, &v14, a4);
}

uint64_t sub_10081B574(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_10081B5B8(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  unsigned int v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_10081B574(a1);
  uint64_t result = (uint64_t *)sub_10081B7E4(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_10081B6F4(result + 2);
        sub_10081B738(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_10081B6F4(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        long long v16 = (uint64_t *)sub_10081B574(a1);
        uint64_t v17 = sub_10081B7E4(v16);
        uint64_t v18 = sub_10081B6F4(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      unsigned int v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_10081B574(a1);
      long long v20 = (uint64_t *)sub_10081B7E4(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_10081B6F4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_10081B738(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_10081B7A0(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_10081B7A0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t sub_10081B7E4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10081B828(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_10081B8A8(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_10081BA48(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      unsigned char *v5 = 0;
    }
  }
}

unsigned char *sub_10081B8A8(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_10081B964((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      *uint64_t v2 = 1;
    }
  }
  uint64_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_10081B964(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_10081B6F4(a2);
  uint64_t v3 = (void *)(sub_10081B7A0((uint64_t *)(v2 + 32)) + 24);

  return sub_10081B9B0(v3);
}

uint64_t sub_10081B9B0(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_10081BA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_10081BA48(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_10081BCA4(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_10081B6F4((uint64_t *)(*a1 + 16));
      sub_10081BCE8(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_10081B6F4((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 280);
      }
      else {
        ++*(_DWORD *)(v7 + 284);
      }
      uint64_t v8 = sub_10081B6F4((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1001AB328(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_10081BCA4((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1001AB328(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_10081BC68(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10081BCA4(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_10081BCE8(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_10081B7A0((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_10081B7A0(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_10081BDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10081BE08(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 284) > *(_DWORD *)(*(void *)a1 + 280)) {
    sub_10081BE4C(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_10081BE4C(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_10081B574(a1);
  if (sub_10081B7E4(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_10081B574(a1);
    uint64_t v8 = *(uint64_t **)(sub_10081B7E4(v7) + 8);
    sub_10081B5B8(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_10081BF98()
{
}

void sub_10081BFEC(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_10081C0AC(&v2, a2);
}

uint64_t sub_10081C068(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_10081C0AC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10081C118(&v2);
}

void sub_10081C104(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10081C118(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10081C188(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_10081C19C(_Unwind_Exception *a1)
{
}

void sub_10081C1B4()
{
}

uint64_t sub_10081C1C8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10081C22C()
{
  return 0;
}

uint64_t sub_10081C234()
{
  return 0;
}

uint64_t sub_10081C23C()
{
  return 0;
}

void sub_10081C244()
{
}

void sub_10081C2C0()
{
}

uint64_t sub_10081C2E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10081C470((uint64_t *)a1, a2);
  sub_10081C4DC((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      long long v10 = (void *)v5[1];
      uint64_t v11 = v10;
      uint64_t v12 = v5;
      if (v10)
      {
        do
        {
          uint64_t v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          uint64_t v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          long long v16 = v10;
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      long long v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          long long v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          long long v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_10081C448(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10081C470(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_10081C4C8(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10081C4DC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_10081C52C(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10081C544(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_10081C5B0(&v2);
}

void sub_10081C59C(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_10081C5B0(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_10081C620(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_10081C634(_Unwind_Exception *a1)
{
}

void sub_10081C64C()
{
}

uint64_t sub_10081C660(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10081C6C8()
{
  return 0;
}

uint64_t sub_10081C6D0()
{
  return 0;
}

uint64_t sub_10081C6D8()
{
  return 0;
}

uint64_t sub_10081C6E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 288), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_10081C7B4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10081C7D4(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_100358C28((uint64_t)&event::activation::simProvisionedState, *(unsigned char *)(*(void *)a1 + 8));
  operator delete();
}

void sub_10081C830()
{
}

void sub_10081C85C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  int v3 = *((_DWORD *)*a1 + 3);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  long long v5 = v4;
  switch(v3)
  {
    case 1:
      if (!sub_100818C20(*(void *)(v1 + 112), v2))
      {
LABEL_16:
        int v9 = 0;
        uint64_t v7 = 1;
        char v8 = 1;
        goto LABEL_19;
      }
      long long v10 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Service provisioning has completed", buf, 2u);
      }
      sub_100817184((void *)(v1 + 112), v2, (uint64_t)kCFBooleanFalse);
      char v8 = 0;
      int v9 = 115;
      break;
    case 3:
      uint64_t v11 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Service provisioning has failed", buf, 2u);
      }
      sub_100817184((void *)(v1 + 112), v2, (uint64_t)kCFBooleanFalse);
      if (*(unsigned char *)(v1 + 291))
      {
        uint64_t v12 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Suppressing activation failed notification", buf, 2u);
        }
        goto LABEL_16;
      }
      char v8 = 0;
      int v9 = 116;
      break;
    case 2:
      uint64_t v6 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Service provisioning has started", buf, 2u);
      }
      sub_100817184((void *)(v1 + 112), v2, (uint64_t)kCFBooleanTrue);
      uint64_t v7 = 0;
      char v8 = 0;
      int v9 = 114;
LABEL_19:
      if (v2 == 1)
      {
        uint64_t v13 = *v5;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v14 = "false";
          if (v7) {
            BOOL v14 = "true";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Setting service provisioned to %s", buf, 0xCu);
        }
        (*(void (**)(void, uint64_t))(**(void **)(v1 + 536) + 392))(*(void *)(v1 + 536), v7);
      }
      if (v8) {
        goto LABEL_50;
      }
      uint64_t v15 = *(_DWORD **)(v1 + 264);
      long long v16 = *(_DWORD **)(v1 + 272);
      if (v15 != v16)
      {
        while (*v15 != v2)
        {
          v15 += 42;
          if (v15 == v16) {
            goto LABEL_50;
          }
        }
      }
      if (v15 == v16 || (subscriber::isEsimCapable() & 1) != 0) {
LABEL_50:
      }
        operator delete();
      xpc_object_t v27 = 0;
      xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v18 = v17;
      if (v17)
      {
        xpc_object_t v27 = v17;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
        xpc_object_t v27 = v18;
        if (!v18)
        {
          xpc_object_t v19 = xpc_null_create();
          xpc_object_t v18 = 0;
          goto LABEL_39;
        }
      }
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v18);
LABEL_40:
        xpc_release(v18);
        xpc_object_t object = xpc_int64_create((int)v2);
        if (!object) {
          xpc_object_t object = xpc_null_create();
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v29 = 0;
        ctu::cf::assign();
        *(_OWORD *)long long __p = *(_OWORD *)buf;
        uint64_t v24 = v29;
        long long v20 = __p;
        if (v29 < 0) {
          long long v20 = *(void ***)buf;
        }
        v25[0] = &v27;
        v25[1] = v20;
        sub_100035E70((uint64_t)v25, &object, (xpc_object_t *)buf);
        xpc_release(*(xpc_object_t *)buf);
        *(void *)long long buf = 0;
        if (SHIBYTE(v24) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_object_t v21 = v27;
        __p[0] = v27;
        if (v27)
        {
          xpc_retain(v27);
        }
        else
        {
          xpc_object_t v21 = xpc_null_create();
          __p[0] = v21;
        }
        xpc_object_t v22 = xpc_null_create();
        v25[0] = v22;
        sub_1000452AC(v9, __p, v25);
        xpc_release(v22);
        xpc_release(v21);
        xpc_release(v27);
        goto LABEL_50;
      }
      xpc_object_t v19 = xpc_null_create();
LABEL_39:
      xpc_object_t v27 = v19;
      goto LABEL_40;
    default:
      goto LABEL_50;
  }
  uint64_t v7 = 1;
  goto LABEL_19;
}

void sub_10081CD14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10081CDD4(uint64_t a1)
{
  uint64_t v1 = a1;
  ++*(_DWORD *)(**(void **)a1 + 772);
  operator delete();
}

void sub_10081CE24(uint64_t a1)
{
  uint64_t v1 = a1;
  *(_DWORD *)(**(void **)a1 + 772) = 0;
  operator delete();
}

void sub_10081CE6C(_DWORD **a1)
{
  uint64_t v1 = a1;
  if (**a1 == 8) {
    sub_100818BD8((uint64_t)&event::activation::seviceProvisioningState, 1);
  }
  operator delete();
}

void sub_10081CED4()
{
}

uint64_t sub_10081CF00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10081CF10(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10081CF2C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_10081CF3C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(_DWORD *)(v1 + 8);
  uint64_t v5 = *(void *)(v1 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 24);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v6 = *(void *)(v2 + 584);
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v6 = *(void *)(v2 + 584);
  }
  uint64_t v7 = operator new(0x28uLL);
  *uint64_t v7 = off_101A0E510;
  v7[1] = v2;
  *((_DWORD *)v7 + 4) = v3;
  void v7[3] = v5;
  char v7[4] = v4;
  void v11[3] = v7;
  (*(void (**)(uint64_t, void *))(*(void *)v6 + 64))(v6, v11);
  sub_100060644(v11);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10013A778(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_10081D050(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  sub_100060644((uint64_t *)va2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10013A778((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_10081D094(void *a1)
{
  *a1 = off_101A0E510;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10081D0E0(void *a1)
{
  *a1 = off_101A0E510;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_10081D14C(uint64_t a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E510;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  result[3] = *(void *)(a1 + 24);
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10081D1B4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A0E510;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10081D1FC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10081D20C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10081D24C(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(v4 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Acquired baseband booted assertion", buf, 2u);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 96));
    char v8 = ServiceMap;
    if (v9 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v9;
    uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v13)
    {
      uint64_t v15 = v13[3];
      BOOL v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    BOOL v14 = 0;
    char v16 = 1;
LABEL_17:
    xpc_object_t v17 = *(NSObject **)(v4 + 40);
    if (!v15)
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Missing ABM client interface", buf, 2u);
      }
      goto LABEL_44;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Erasing carrier NV items", buf, 2u);
    }
    xpc_object_t object = 0;
    xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v19 = v18;
    if (v18)
    {
      xpc_object_t object = v18;
    }
    else
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t object = v19;
      if (!v19)
      {
        xpc_object_t v20 = xpc_null_create();
        xpc_object_t v19 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v19);
LABEL_30:
      xpc_release(v19);
      xpc_object_t v28 = xpc_string_create(abm::kBasebandNVDataErase);
      if (!v28) {
        xpc_object_t v28 = xpc_null_create();
      }
      *(void *)long long buf = &object;
      long long v32 = (const char *)abm::kKeyBasebandNVDataAction;
      sub_100035E70((uint64_t)buf, &v28, &v29);
      xpc_release(v29);
      xpc_object_t v29 = 0;
      xpc_release(v28);
      xpc_object_t v27 = object;
      xpc_object_t v28 = 0;
      if (object) {
        xpc_retain(object);
      }
      else {
        xpc_object_t v27 = xpc_null_create();
      }
      xpc_object_t v21 = *(NSObject **)(v4 + 24);
      dispatch_object_t v26 = v21;
      if (v21) {
        dispatch_retain(v21);
      }
      uint64_t v23 = *(void *)(a1 + 24);
      uint64_t v22 = *(void *)(a1 + 32);
      if (v22) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
      }
      long long v33 = 0;
      uint64_t v24 = operator new(0x20uLL);
      uint64_t v25 = abm::kCommandBasebandNVData;
      *uint64_t v24 = off_101A0E580;
      v24[1] = v4;
      xpc_object_t v24[2] = v23;
      v24[3] = v22;
      long long v33 = v24;
      (*(void (**)(uint64_t, uint64_t, xpc_object_t *, dispatch_object_t *, uint8_t *))(*(void *)v15 + 48))(v15, v25, &v27, &v26, buf);
      sub_1000595E4(buf);
      if (v26) {
        dispatch_release(v26);
      }
      xpc_release(v27);
      xpc_object_t v27 = 0;
      if (*(_DWORD *)(a1 + 16) == 1)
      {
        CFPreferencesSetValue(@"CarrierId", &stru_101AC1B28, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        sub_1003F2A04();
      }
      xpc_release(object);
LABEL_44:
      if ((v16 & 1) == 0) {
        sub_10004D2C8(v14);
      }
      return;
    }
    xpc_object_t v20 = xpc_null_create();
LABEL_29:
    xpc_object_t object = v20;
    goto LABEL_30;
  }
  if (v6)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Could not acquire baseband booted assertion!", buf, 2u);
  }
  xpc_object_t v29 = xpc_int64_create(35);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)long long buf = *(void *)(a1 + 24);
  long long v32 = "kPosixError";
  sub_100035E70((uint64_t)buf, &v29, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v29);
}

void sub_10081D684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, xpc_object_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, char a15)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10081D740(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081D780()
{
}

void *sub_10081D78C(void *a1)
{
  *a1 = off_101A0E580;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10081D7D8(void *a1)
{
  *a1 = off_101A0E580;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10081D844(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A0E580;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10081D8A8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A0E580;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10081D8E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10081D8F8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10081D938(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(NSObject **)(v8 + 40);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v10)
    {
      LOWORD(v11[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Performing EFS erase failed", (uint8_t *)v11, 2u);
    }
    xpc_object_t v12 = xpc_int64_create(16);
    if (!v12) {
      xpc_object_t v12 = xpc_null_create();
    }
    v11[0] = *(void *)(a1 + 16);
    v11[1] = "kPosixError";
    sub_100035E70((uint64_t)v11, &v12, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v12);
    xpc_object_t v12 = 0;
  }
  else if (v10)
  {
    LOWORD(v11[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Performing EFS erase succeeded", (uint8_t *)v11, 2u);
  }
  (*(void (**)(void))(**(void **)(v8 + 584) + 72))(*(void *)(v8 + 584));
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_10081DAB0(_Unwind_Exception *a1)
{
  xpc_release(v2);
  if (v3 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10081DAD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10081DB18()
{
}

void sub_10081DB28()
{
}

void *sub_10081DB3C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A0E610;
  result[1] = v3;
  return result;
}

uint64_t sub_10081DB84(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A0E610;
  a2[1] = v2;
  return result;
}

void sub_10081DBB0(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  uint64_t v8 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "failed";
    if (!v4) {
      uint64_t v9 = "succeeded";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Performing restore of carrier NV %s", buf, 0xCu);
  }
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  *(_OWORD *)uint64_t v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v19 = 0u;
  sub_10004DE24((uint64_t)buf);
  BOOL v10 = sub_10004B96C(buf, (uint64_t)"Resetting Baseband after restore of carrier NV (due to ", 55);
  uint64_t v11 = (const char *)asString();
  size_t v12 = strlen(v11);
  uint64_t v13 = sub_10004B96C(v10, (uint64_t)v11, v12);
  sub_10004B96C(v13, (uint64_t)")", 1);
  sub_10004BC98((uint64_t)&buf[8], &v14);
  rest::ResetPayload::ResetPayload();
  sub_1004BC4DC();
  if (v17 < 0) {
    operator delete(__p);
  }
  if (v15 < 0) {
    operator delete(v14);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_10081DE5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_10081DFB0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10081DFF0()
{
}

void *sub_10081DFFC(void *a1)
{
  *a1 = off_101A0E690;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10081E048(void *a1)
{
  *a1 = off_101A0E690;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_10081E0B4(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A0E690;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10081E118(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A0E690;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10081E158(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10081E168(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_10081E1A8(uint64_t a1, int *a2, void **a3)
{
  int v4 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int v6 = *((char *)a2 + 31);
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  uint64_t v7 = *a3;
  *a3 = xpc_null_create();
  uint64_t v8 = *(BasebandSettings **)(a1 + 8);
  uint64_t v9 = *((void *)v8 + 5);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v10 = "failed";
    if (!v4) {
      BOOL v10 = "succeeded";
    }
    int v11 = 136315138;
    size_t v12 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Performing BB RFS sync %s", (uint8_t *)&v11, 0xCu);
  }
  if (v4) {
    BasebandSettings::resetBBAfterFileTransferComplete_sync(v8);
  }
  xpc_release(v7);
  if (v6 < 0) {
    operator delete(v5);
  }
}

void sub_10081E2B8(_Unwind_Exception *a1)
{
  xpc_release(v2);
  if (v3 < 0) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10081E2F4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10081E334()
{
}

void sub_10081E4EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v18);

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10081E560(uint64_t a1, void *a2, void *a3)
{
  int v4 = (id *)(a1 + 32);
  id v5 = a3;
  id v6 = a2;
  id WeakRetained = objc_loadWeakRetained(v4);
  [WeakRetained handleGPSSatsVisibility:v6 error:v5];
}

void sub_10081E5D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10081ECD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_10081EDA8(void *a1, id *a2, uint64_t a3)
{
  *a1 = off_101A0E748;
  id v6 = [StewieCLGPSSatsVisibilityAssertion alloc];
  uint64_t v7 = sub_100200FB4(a2);
  a1[1] = [(StewieCLGPSSatsVisibilityAssertion *)v6 initWithQueue:v7 callback:a3];

  return a1;
}

void sub_10081EE30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10081EE40(uint64_t a1)
{
  return a1;
}

void sub_10081EE6C(uint64_t a1)
{
  operator delete();
}

double sub_10081EEB8@<D0>(id *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  if (!*a1) {
    __TUAssertTrigger();
  }
  sub_10081EF20(a1, a2, v7);
  double result = v7[0];
  *a3 = *(_OWORD *)v7;
  return result;
}

void *sub_10081EF20@<X0>(id *a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  id v6 = operator new(0x28uLL);
  double result = sub_10081EF84(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10081EF70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10081EF84(void *a1, id *a2, uint64_t a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A0E790;
  sub_10081EDA8(a1 + 3, a2, a3);
  return a1;
}

void sub_10081EFCC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10081EFE0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0E790;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10081F000(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0E790;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10081F054(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10081F478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a30 && a26 < 0) {
    operator delete(__p);
  }
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v32);
  }

  _Unwind_Resume(a1);
}

void sub_10081F7B0(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_10081FB84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v24);
  }

  _Unwind_Resume(a1);
}

void sub_10081FED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v15);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10081FF48(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseSuccess])
  {
    uint64_t v2 = 0;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseSuccessNoIcon])
  {
    uint64_t v2 = 1;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseCancelled])
  {
    uint64_t v2 = 2;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseBack])
  {
    uint64_t v2 = 3;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseTimeout])
  {
    uint64_t v2 = 4;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseHelp])
  {
    uint64_t v2 = 5;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseBusy])
  {
    uint64_t v2 = 6;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseRefused])
  {
    uint64_t v2 = 8;
  }
  else if ([v1 isEqualToString:kCTSIMToolkitNotificationResponseNotSupported])
  {
    uint64_t v2 = 9;
  }
  else
  {
    uint64_t v2 = 2;
  }

  return v2;
}

void sub_100820094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100820350(_Unwind_Exception *a1)
{
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v5);
  }

  _Unwind_Resume(a1);
}

void sub_100820744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v28);
  }

  _Unwind_Resume(a1);
}

void sub_100820B24(_Unwind_Exception *a1)
{
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v5);
  }

  _Unwind_Resume(a1);
}

void sub_100820D84(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1008210F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1008215F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v32);
  }

  _Unwind_Resume(a1);
}

void sub_10082188C(_Unwind_Exception *a1)
{
  char v5 = v3;
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_1008218D0(dispatch_object_t *a1, uint64_t a2, uint64_t a3)
{
  if (*a1) {
    dispatch_retain(*a1);
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a3 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1008219F8();
}

void sub_1008219A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008219F8()
{
}

void sub_100821B24(_Unwind_Exception *exception_object)
{
  if (v3)
  {
    sub_10004D2C8(v3);
    if (!v2)
    {
LABEL_3:
      if (!v1) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if (!v2)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v2);
  if (!v1)
  {
LABEL_4:
    if (v4) {
      goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_9:
  dispatch_release(v1);
  if (v4) {
LABEL_5:
  }
    operator delete();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_100821B80(uint64_t a1)
{
  sub_10003E168(&v1, (void *)(a1 + 8));
  operator new();
}

void sub_100821BF8()
{
}

uint64_t sub_100821C30(uint64_t a1, NSObject **a2, void *a3, void *a4, char a5)
{
  *(void *)a1 = &off_1019B03F8;
  char v10 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, "cp.r.prov");
  *char v10 = 0;
  v10[1] = 0;
  int v11 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v16, &v15);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  *(void *)a1 = off_101A0E7E0;
  *(void *)(a1 + 48) = off_101A0E9A8;
  *(void *)(a1 + 56) = *a3;
  uint64_t v12 = a3[1];
  *(void *)(a1 + 64) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *a4;
  uint64_t v13 = a4[1];
  *(void *)(a1 + 80) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = 0;
  sub_100324590((void *)(a1 + 112));
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 304) = 0;
  *(unsigned char *)(a1 + 312) = 0;
  *(unsigned char *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 1200) = 2;
  *(unsigned char *)(a1 + 1224) = 0;
  *(_OWORD *)(a1 + 1208) = 0u;
  *(_DWORD *)(a1 + 1244) = 0;
  *(_OWORD *)(a1 + 1228) = 0u;
  *(unsigned char *)(a1 + 1248) = a5;
  *(unsigned char *)(a1 + 1249) = 0;
  *(_OWORD *)(a1 + 1256) = 0u;
  *(_OWORD *)(a1 + 1272) = 0u;
  *(_OWORD *)(a1 + 1288) = 0u;
  *(_OWORD *)(a1 + 1304) = 0u;
  *(_OWORD *)(a1 + 1320) = 0u;
  *(_OWORD *)(a1 + 1336) = 0u;
  return a1;
}

void sub_100821DD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v17 = *v15;
  uint64_t *v15 = 0;
  if (v17) {
    sub_100827E10((uint64_t)v15, v17);
  }
  char v18 = *(std::__shared_weak_count **)(v13 + 80);
  if (v18) {
    sub_10004D2C8(v18);
  }
  long long v19 = *(std::__shared_weak_count **)(v13 + 64);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  sub_100087E88(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_100821E50(uint64_t a1, _OWORD *a2, int a3, uint64_t a4, void **a5)
{
  char v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if ((a3 - 1) > 8) {
      int v11 = "GetPlansFetch";
    }
    else {
      int v11 = off_101A0EFD8[a3 - 1];
    }
    int v16 = 136315138;
    uint64_t v17 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I start (%s)", (uint8_t *)&v16, 0xCu);
  }
  *(_OWORD *)(a1 + 96) = *a2;
  *(_DWORD *)(a1 + 1200) = a3;
  if (*(unsigned char *)(a1 + 408))
  {
    uint64_t v12 = a1 + 408;
    if (*(unsigned char *)a4) {
      sub_1008270F0(v12, a4 + 8);
    }
    else {
      sub_10082769C(v12);
    }
  }
  else if (*(unsigned char *)a4)
  {
    sub_100827714((void *)(a1 + 416), (long long *)(a4 + 8));
    *(unsigned char *)(a1 + 408) = 1;
  }
  uint64_t v13 = *a5;
  if (*a5) {
    uint64_t v13 = _Block_copy(v13);
  }
  BOOL v14 = *(const void **)(a1 + 1208);
  *(void *)(a1 + 1208) = v13;
  if (v14) {
    _Block_release(v14);
  }
  return sub_100827F5C(*(void *)(a1 + 88), (uint64_t)&v16, 1);
}

void sub_100821FAC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100821FC0(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  sub_10030C024(a1 + 128, a4);
  v8[0] = 0;
  sub_100822064(a1, a2, a3, (uint64_t)v8);
  return sub_10082783C(v8);
}

void sub_100822050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

unsigned char *sub_100822064(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 72) + 48))(&v11);
  uint64_t v7 = *(void *)(a1 + 112);
  if (*(char *)(v7 + 23) < 0) {
    operator delete(*(void **)v7);
  }
  long long v8 = v11;
  *(void *)(v7 + 16) = v12;
  *(_OWORD *)uint64_t v7 = v8;
  v13[0] = 0;
  if (*(unsigned char *)a4)
  {
    sub_100827714(v14, (long long *)(a4 + 8));
    v13[0] = 1;
  }
  char v10 = 0;
  sub_100821E50(a1, a2, 2, (uint64_t)v13, &v10);
  return sub_10082783C(v13);
}

void sub_100822170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_10082218C(uint64_t a1, _OWORD *a2)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 72) + 48))(&v8);
  uint64_t v4 = *(void *)(a1 + 112);
  if (*(char *)(v4 + 23) < 0) {
    operator delete(*(void **)v4);
  }
  long long v5 = v8;
  *(void *)(v4 + 16) = v9;
  *(_OWORD *)uint64_t v4 = v5;
  v10[0] = 0;
  uint64_t v7 = 0;
  sub_100821E50(a1, a2, 4, (uint64_t)v10, &v7);
  return sub_10082783C(v10);
}

void sub_10082226C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_100822288(uint64_t a1, _OWORD *a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = v6;
  *(void *)(a1 + 120) = v5;
  if (v7) {
    sub_10004D2C8(v7);
  }
  *(_WORD *)(a1 + 1224) = 257;
  v10[0] = 0;
  uint64_t v9 = 0;
  sub_100821E50(a1, a2, 3, (uint64_t)v10, &v9);
  return sub_10082783C(v10);
}

void sub_10082233C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_100822350(uint64_t a1, _OWORD *a2, uint64_t *a3, int a4, uint64_t a5)
{
  uint64_t v10 = *a3;
  uint64_t v9 = a3[1];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  long long v11 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = v10;
  *(void *)(a1 + 120) = v9;
  if (v11) {
    sub_10004D2C8(v11);
  }
  *(unsigned char *)(a1 + 1225) = a4 ^ 1;
  *(unsigned char *)(a1 + 1224) = 1;
  sub_10030C024(a1 + 128, a5);
  if (a4) {
    int v12 = 5;
  }
  else {
    int v12 = 1;
  }
  v15[0] = 0;
  BOOL v14 = 0;
  sub_100821E50(a1, a2, v12, (uint64_t)v15, &v14);
  return sub_10082783C(v15);
}

void sub_100822430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_100822444(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  sub_10030C024(a1 + 128, a3);
  v7[0] = 0;
  uint64_t v6 = 0;
  sub_100821E50(a1, a2, 8, (uint64_t)v7, &v6);
  return sub_10082783C(v7);
}

void sub_1008224D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_1008224EC(uint64_t a1, _OWORD *a2, const void **a3)
{
  v8[0] = 0;
  if (*a3) {
    uint64_t v5 = _Block_copy(*a3);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v7 = v5;
  sub_100821E50(a1, a2, 0, (uint64_t)v8, &v7);
  if (v5) {
    _Block_release(v5);
  }
  return sub_10082783C(v8);
}

void sub_100822598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

unsigned char *sub_1008225D4(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 72) + 48))(&v11);
  uint64_t v7 = *(void *)(a1 + 112);
  if (*(char *)(v7 + 23) < 0) {
    operator delete(*(void **)v7);
  }
  long long v8 = v11;
  *(void *)(v7 + 16) = v12;
  *(_OWORD *)uint64_t v7 = v8;
  v13[0] = 0;
  if (*(unsigned char *)a4)
  {
    sub_100827714(v14, (long long *)(a4 + 8));
    v13[0] = 1;
  }
  uint64_t v10 = 0;
  sub_100821E50(a1, a2, 6, (uint64_t)v13, &v10);
  return sub_10082783C(v13);
}

void sub_1008226E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_1008226FC(uint64_t a1, _OWORD *a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = v6;
  *(void *)(a1 + 120) = v5;
  if (v7) {
    sub_10004D2C8(v7);
  }
  *(_WORD *)(a1 + 1224) = 257;
  v10[0] = 0;
  uint64_t v9 = 0;
  sub_100821E50(a1, a2, 9, (uint64_t)v10, &v9);
  return sub_10082783C(v10);
}

void sub_1008227B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

unsigned char *sub_1008227C4(uint64_t a1, _OWORD *a2, long long *a3)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 72) + 48))(&v10);
  uint64_t v6 = *(void *)(a1 + 112);
  if (*(char *)(v6 + 23) < 0) {
    operator delete(*(void **)v6);
  }
  long long v7 = v10;
  *(void *)(v6 + 16) = v11;
  *(_OWORD *)uint64_t v6 = v7;
  v12[0] = 0;
  sub_100827714(v13, a3);
  v12[0] = 1;
  uint64_t v9 = 0;
  sub_100821E50(a1, a2, 7, (uint64_t)v12, &v9);
  return sub_10082783C(v12);
}

void sub_1008228C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10082783C(va);
  _Unwind_Resume(a1);
}

void sub_1008228E4(void *a1, void *a2, uint64_t a3)
{
  if (*a2 == a1[12] && a2[1] == a1[13])
  {
    if (*(unsigned __int8 *)(a3 + 91) | *(unsigned __int8 *)(a3 + 90)
      || (uint64_t v6 = a1[14], *(unsigned char *)(v6 + 122))
      || *(unsigned char *)(v6 + 123)
      || *(unsigned char *)(v6 + 120)
      && (*(char *)(v6 + 95) < 0 ? (uint64_t v14 = *(void *)(v6 + 80)) : (uint64_t v14 = *(unsigned __int8 *)(v6 + 95)), !v14))
    {
      sub_100828AC8(a1[11], (uint64_t)&v18, 1);
      long long v7 = (std::__shared_weak_count *)a1[8];
      if (v7)
      {
        long long v8 = std::__shared_weak_count::lock(v7);
        if (v8)
        {
          uint64_t v9 = v8;
          uint64_t v10 = a1[7];
          if (v10)
          {
            uint64_t v11 = (const void *)a1[151];
            if (v11)
            {
              uint64_t v12 = a1[5];
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)
                && (*(_WORD *)uint64_t v17 = 0,
                    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I pending profile has ppr for get plan items", v17, 2u), (uint64_t v11 = (const void *)a1[151]) == 0))
              {
                uint64_t v13 = 0;
              }
              else
              {
                uint64_t v13 = _Block_copy(v11);
              }
              aBlock = v13;
              (*(void (**)(uint64_t, void **))(*(void *)v10 + 80))(v10, &aBlock);
              if (aBlock) {
                _Block_release(aBlock);
              }
            }
          }
          sub_10004D2C8(v9);
        }
      }
    }
    else
    {
      sub_100828F4C(a1[11], (uint64_t)&v15, 1);
    }
  }
  else
  {
    uint64_t v5 = a1[5];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I CSN does not match operation's", buf, 2u);
    }
  }
}

void sub_100822A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_100822AC0(uint64_t result, int a2, uint64_t a3)
{
  char v3 = (void *)result;
  if (a2)
  {
    if (a2 != 1)
    {
      if (a2 == 2) {
        return sub_100829300(*(void *)(result + 88), (uint64_t)&v15, 1);
      }
      return result;
    }
    uint64_t v6 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I user did consent", v14, 2u);
    }
    uint64_t v7 = *(unsigned __int8 *)(a3 + 23);
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a3 + 8);
    }
    if (!v7) {
      return sub_100829C94(v3[11], (uint64_t)&v12, 1);
    }
    uint64_t v8 = v3[14];
    if (*(char *)(v8 + 95) < 0)
    {
      if (!*(void *)(v8 + 80))
      {
LABEL_19:
        std::string::operator=((std::string *)(v8 + 72), (const std::string *)a3);
        return sub_100829C94(v3[11], (uint64_t)&v12, 1);
      }
    }
    else if (!*(unsigned char *)(v8 + 95))
    {
      goto LABEL_19;
    }
    uint64_t v9 = v3[5];
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "confirmation code already exists - overriding the old one", v13, 2u);
      uint64_t v8 = v3[14];
    }
    goto LABEL_19;
  }
  uint64_t v4 = *(NSObject **)(result + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I user did not consent", buf, 2u);
  }
  return sub_10082A0B4(v3[11], (uint64_t)&v10, 1);
}

uint64_t sub_100822C3C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1228);
}

uint64_t sub_100822C44(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

BOOL sub_100822C50(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1200) == 1;
}

std::string *sub_100822C60(std::string *result, const std::string *a2, const std::string *a3, const std::string *a4, const std::string *a5, const std::string *a6)
{
  if (result[12].__r_.__value_.__s.__data_[16])
  {
    char v10 = result;
    std::string::operator=(result + 7, a2);
    std::string::operator=(v10 + 8, a3);
    std::string::operator=(v10 + 9, a4);
    std::string::operator=(v10 + 10, a5);
    return std::string::operator=((std::string *)((char *)v10 + 272), a6);
  }
  return result;
}

void sub_100822D00(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(_WORD *)(a1 + 1224) = 257;
  BOOL v8 = *(void *)(a1 + 96) != *a2 || *(void *)(a1 + 104) != a2[1];
  uint64_t v9 = *(NSObject **)(a1 + 40);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v10)
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E eid does not match aborting!", (uint8_t *)&__p, 2u);
    }
    sub_100822EB8(a1, 0);
  }
  else
  {
    if (v10)
    {
      uint64_t v11 = *(unsigned __int8 *)(a3 + 23);
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a3 + 8);
      }
      std::string::basic_string(&__p, (const std::string *)a3, v11 - 4, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)buf);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      long long v19 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I got provisioning callback iccid : %s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v13 = *(uint64_t **)(a1 + 112);
    uint64_t v14 = v13 + 12;
    unint64_t v15 = v13[13];
    if (v15 >= v13[14])
    {
      uint64_t v16 = sub_10030E9EC(v14, (long long *)a3);
    }
    else
    {
      sub_1000D87F8(v14, (long long *)a3);
      uint64_t v16 = v15 + 24;
    }
    v13[13] = v16;
    if (*(unsigned char *)a4) {
      std::string::operator=(*(std::string **)(a1 + 112), (const std::string *)(a4 + 8));
    }
    sub_10082A538(*(void *)(a1 + 88), (uint64_t)&__p, 1);
  }
}

void sub_100822EB8(uint64_t a1, int a2)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 56);
      if (v6)
      {
        uint64_t v7 = *(const void **)(a1 + 1208);
        if (v7)
        {
          char v35 = _Block_copy(v7);
          (*(void (**)(uint64_t, void **))(*(void *)v6 + 80))(v6, &v35);
          if (v35) {
            _Block_release(v35);
          }
        }
        BOOL v8 = *(const void **)(a1 + 1216);
        if (v8)
        {
          char v34 = _Block_copy(v8);
          (*(void (**)(uint64_t, void **))(*(void *)v6 + 72))(v6, &v34);
          if (v34) {
            _Block_release(v34);
          }
          uint64_t v9 = *(const void **)(a1 + 1216);
          *(void *)(a1 + 1216) = 0;
          if (v9) {
            _Block_release(v9);
          }
        }
        int v10 = 1;
      }
      else
      {
        int v10 = 0;
      }
    }
    else
    {
      int v10 = 0;
      uint64_t v6 = 0;
    }
  }
  else
  {
    int v10 = 0;
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  switch(a2)
  {
    case 0:
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        char v12 = 2;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: failed", buf, 2u);
        char v13 = 0;
      }
      else
      {
        char v13 = 0;
        char v12 = 2;
      }
      uint64_t v15 = 1;
      if (v10) {
        goto LABEL_36;
      }
      goto LABEL_58;
    case 1:
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: successfully", buf, 2u);
      }
      uint64_t v15 = 0;
      char v13 = 1;
      char v12 = 1;
      if (v10) {
        goto LABEL_36;
      }
      goto LABEL_58;
    case 2:
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        char v13 = 0;
        char v12 = 3;
        goto LABEL_35;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v15 = 2;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: incomplete", buf, 2u);
      char v13 = 0;
      char v12 = 3;
      if (v10) {
        goto LABEL_36;
      }
      goto LABEL_58;
    case 3:
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: cancel", buf, 2u);
      }
      char v13 = 0;
      char v12 = 4;
      uint64_t v15 = 3;
      if (v10) {
        goto LABEL_36;
      }
      goto LABEL_58;
    default:
      char v13 = 0;
      char v12 = 0;
LABEL_35:
      uint64_t v15 = 2;
      if (v10)
      {
LABEL_36:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 88))(v6, v15);
        if (v13)
        {
          uint64_t v18 = 0;
        }
        else
        {
          if (*(_DWORD *)(a1 + 1200) == 7) {
            goto LABEL_41;
          }
          uint64_t v18 = 5;
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 160))(v6, v18);
LABEL_41:
        if (*(unsigned char *)(a1 + 304))
        {
          unsigned int v19 = *(unsigned __int8 *)(a1 + 132);
          if (v19 <= 0xC && ((1 << v19) & 0x1820) != 0) {
            *(unsigned char *)(a1 + 160) = 4;
          }
          *(unsigned char *)(a1 + 296) = v12;
          sub_100311AFC((uint64_t)&v20, (int *)(a1 + 128));
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 168))(v6, &v20);
          if (v32 < 0) {
            operator delete(__p);
          }
          if (v30 < 0) {
            operator delete(v29);
          }
          if (v28 < 0) {
            operator delete(v27);
          }
          if (v26 < 0) {
            operator delete(v25);
          }
          if (v24 < 0) {
            operator delete(v23);
          }
          if (v22 < 0) {
            operator delete(v21);
          }
          sub_10030C110(a1 + 128);
        }
      }
LABEL_58:
      if (v5) {
        sub_10004D2C8(v5);
      }
      return;
  }
}

void sub_1008232D4(_Unwind_Exception *a1)
{
  uint64_t v4 = *(const void **)(v2 - 80);
  if (v4) {
    _Block_release(v4);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100823344(uint64_t a1)
{
  *(_WORD *)(a1 + 1224) = 257;
  *(unsigned char *)(a1 + 1249) = 1;
  return sub_10082ABC0(*(void *)(a1 + 88), (uint64_t)&v2, 1);
}

void sub_100823380(uint64_t *a1, void *a2, uint64_t a3)
{
  if (!a1[162] && *(unsigned char *)(a3 + 176)) {
    sub_10030C024((uint64_t)(a1 + 16), a3);
  }
  if (a1[12] == *a2 && a1[13] == a2[1])
  {
    uint64_t v6 = a1[14];
    if (*(char *)(v6 + 23) < 0)
    {
      if (*(void *)(v6 + 8)) {
        return;
      }
    }
    else if (*(unsigned char *)(v6 + 23))
    {
      return;
    }
    if (a1[162]) {
      sub_10082AF40(a1[11], (uint64_t)&v7, 1);
    }
  }
}

BOOL sub_100823414(uint64_t a1)
{
  return *(void *)(a1 + 1296) != 0;
}

void sub_100823424(void *a1, void *a2)
{
  if (a1[12] == *a2 && a1[13] == a2[1])
  {
    sub_1008234CC((uint64_t)a1);
    sub_100822EB8((uint64_t)a1, 3);
  }
  else
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E eid does not match", v5, 2u);
    }
  }
}

void sub_1008234CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1232);
  if (v1)
  {
    char v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I reset wait for consent timer", v4, 2u);
      uint64_t v1 = *(void *)(a1 + 1232);
      *(void *)(a1 + 1232) = 0;
      if (!v1) {
        return;
      }
    }
    else
    {
      *(void *)(a1 + 1232) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

uint64_t sub_10082357C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 304)) {
    *(unsigned char *)(a1 + 160) = 4;
  }
  return sub_10082B360(*(void *)(a1 + 88), (uint64_t)&v2, 1);
}

uint64_t sub_1008235B8(uint64_t a1)
{
  *(_WORD *)(a1 + 1224) = 257;
  return sub_10082BAB4(*(void *)(a1 + 88), (uint64_t)&v2, 1);
}

uint64_t sub_1008235EC(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I websheet launched", buf, 2u);
  }
  if (!*(unsigned char *)(a1 + 1224)) {
    *(_WORD *)(a1 + 1224) = 1;
  }
  uint64_t v5 = *(void *)(a1 + 1240);
  *(void *)(a1 + 1240) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *a2;
  if (*a2) {
    uint64_t v6 = _Block_copy(v6);
  }
  char v7 = *(const void **)(a1 + 1216);
  *(void *)(a1 + 1216) = v6;
  if (v7) {
    _Block_release(v7);
  }
  return sub_10082BE34(*(void *)(a1 + 88), (uint64_t)&v9, 1);
}

void sub_1008236D4(uint64_t a1)
{
  char v2 = *(const void **)(a1 + 1216);
  if (v2)
  {
    *(void *)(a1 + 1216) = 0;
    _Block_release(v2);
    char v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I invalidate websheet callback on quit", buf, 2u);
    }
  }
  if (!*(unsigned char *)(a1 + 1224) || !*(unsigned char *)(a1 + 1225))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I abort on websheet quit", buf, 2u);
    }
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 64);
    if (v5)
    {
      uint64_t v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        uint64_t v7 = *(void *)(a1 + 56);
        if (v7)
        {
          if (*(unsigned char *)(a1 + 304))
          {
            if (*(unsigned char *)(a1 + 160) == 4) {
              char v8 = 1;
            }
            else {
              char v8 = 3;
            }
            *(unsigned char *)(a1 + 296) = v8;
            sub_100311AFC((uint64_t)&v9, (int *)(a1 + 128));
            (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 168))(v7, &v9);
            if (v21 < 0) {
              operator delete(__p);
            }
            if (v19 < 0) {
              operator delete(v18);
            }
            if (v17 < 0) {
              operator delete(v16);
            }
            if (v15 < 0) {
              operator delete(v14);
            }
            if (v13 < 0) {
              operator delete(v12);
            }
            if (v11 < 0) {
              operator delete(v10);
            }
            sub_10030C110(a1 + 128);
          }
        }
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    sub_100829300(*(void *)(a1 + 88), (uint64_t)buf, 1);
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
}

void sub_10082389C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002DB328((uint64_t)&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_1008238D0(void *a1)
{
  uint64_t v2 = a1[9];
  if (v2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 160))(v2);
    sub_10003E168(&v18, a1 + 1);
    uint64_t v5 = v18;
    uint64_t v4 = v19;
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v4);
    }
    (*(void (**)(uint64_t *__return_ptr))(*(void *)a1[9] + 152))(&v18);
    uint64_t v6 = v18;
    sub_100058DB0(__p, "Remote Provisioning User Consent Timer");
    uint64_t v7 = a1[3];
    dispatch_object_t object = v7;
    if (v7) {
      dispatch_retain(v7);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_100823B60;
    aBlock[3] = &unk_101A0EA90;
    aBlock[4] = a1;
    void aBlock[5] = v5;
    char v12 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    char v13 = _Block_copy(aBlock);
    sub_100118A44(v6, (uint64_t)__p, 1, v3, &object, &v13);
    uint64_t v8 = v17;
    uint64_t v17 = 0;
    uint64_t v9 = a1[154];
    a1[154] = v8;
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      uint64_t v10 = v17;
      uint64_t v17 = 0;
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
    }
    if (v13) {
      _Block_release(v13);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    if (v19) {
      sub_10004D2C8(v19);
    }
    if (v12) {
      std::__shared_weak_count::__release_weak(v12);
    }
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_100823AF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  long long v27 = *(std::__shared_weak_count **)(v25 - 56);
  if (v27) {
    sub_10004D2C8(v27);
  }
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  _Unwind_Resume(exception_object);
}

void sub_100823B60(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I waited too long for reply, aborting", buf, 2u);
        }
        uint64_t v7 = v3[154];
        v3[154] = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        sub_10082C450(v3[11], (uint64_t)&v8, 1);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100823C34(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100823C48(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100823C64(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100823C74(uint64_t a1)
{
}

void sub_100823C7C(uint64_t a1)
{
}

void sub_100823C84(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I delete all plans", buf, 2u);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[7];
      if (v6)
      {
        sub_10003E168(buf, a1 + 1);
        uint64_t v8 = *(void *)buf;
        uint64_t v7 = v13;
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v7);
        }
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 1174405120;
        void v9[2] = sub_100823E48;
        v9[3] = &unk_101A0EAC0;
        void v9[4] = a1;
        v9[5] = v8;
        uint64_t v10 = v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        aBlock = _Block_copy(v9);
        (*(void (**)(uint64_t, void **))(*(void *)v6 + 24))(v6, &aBlock);
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v10) {
          std::__shared_weak_count::__release_weak(v10);
        }
        if (v7) {
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100823E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100823E48(void *a1, int a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v10[0] = 67109120;
          v10[1] = a2;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I delete all plans result : %d", (uint8_t *)v10, 8u);
        }
        uint64_t v9 = *(void *)(v5 + 88);
        if (a2) {
          sub_10082C8D4(v9, (uint64_t)v10, 1);
        }
        else {
          sub_100829300(v9, (uint64_t)v10, 1);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100823F3C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100823F54(uint64_t a1)
{
}

void sub_100823F5C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I get subscription info", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)(a1 + 56);
      if (v6)
      {
        sub_10003E168(buf, (void *)(a1 + 8));
        uint64_t v8 = *(void *)buf;
        uint64_t v7 = v16;
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v7);
        }
        if (*(unsigned char *)(a1 + 1224)) {
          BOOL v9 = *(unsigned char *)(a1 + 1225) != 0;
        }
        else {
          BOOL v9 = 0;
        }
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 1174405120;
        _DWORD v10[2] = sub_100824168;
        v10[3] = &unk_101A0EAF0;
        v10[4] = a1;
        v10[5] = v8;
        char v11 = v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v12 = v6;
        char v13 = v5;
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        aBlock = _Block_copy(v10);
        (*(void (**)(uint64_t, BOOL, void **))(*(void *)v6 + 16))(v6, v9, &aBlock);
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v13) {
          sub_10004D2C8(v13);
        }
        if (v11) {
          std::__shared_weak_count::__release_weak(v11);
        }
        if (v7) {
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100824114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_100824168(uint64_t a1, void *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 40))
      {
        uint64_t v10 = (void *)*a2;
        uint64_t v8 = a2 + 1;
        BOOL v9 = v10;
        if (v10 == v8) {
          goto LABEL_24;
        }
        char v11 = 0;
        do
        {
          uint64_t v12 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = subscriber::asString();
            int v14 = *((_DWORD *)v9 + 10);
            *(_DWORD *)long long buf = 136315394;
            uint64_t v21 = v13;
            __int16 v22 = 1024;
            int v23 = v14;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I subscription info result for slot %s: %d", buf, 0x12u);
          }
          BOOL v15 = *((_DWORD *)v9 + 10) < 2u;
          char v16 = (void *)v9[1];
          if (v16)
          {
            do
            {
              uint64_t v17 = v16;
              char v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              uint64_t v17 = (void *)v9[2];
              BOOL v18 = *v17 == (void)v9;
              BOOL v9 = v17;
            }
            while (!v18);
          }
          v11 |= v15;
          BOOL v9 = v17;
        }
        while (v17 != v8);
        if ((v11 & 1) == 0)
        {
LABEL_24:
          if (*(unsigned char *)(v5 + 1224) && *(unsigned char *)(v5 + 1225)) {
            uint64_t v19 = 7;
          }
          else {
            uint64_t v19 = 6;
          }
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 56) + 160))(*(void *)(a1 + 56), v19);
          sub_10082D3B0(*(void *)(v5 + 88), (uint64_t)buf, 1);
        }
        else
        {
          sub_10082CCF8(*(void *)(v5 + 88), (uint64_t)buf, 1);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10082433C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_10082435C(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100824390(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1008243E0(uint64_t a1)
{
}

void sub_1008243E8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 1200)) {
    goto LABEL_7;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  if (*(char *)(v2 + 23) < 0)
  {
    if (!*(void *)(v2 + 8)) {
      goto LABEL_6;
    }
LABEL_7:
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(a1 + 56);
        if (v6)
        {
          sub_10003E168(buf, (void *)(a1 + 8));
          uint64_t v8 = *(void *)buf;
          uint64_t v7 = v19;
          if (v19)
          {
            atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v7);
          }
          BOOL v9 = *(std::__shared_weak_count **)(a1 + 120);
          uint64_t v16 = *(void *)(a1 + 112);
          uint64_t v17 = v9;
          if (v9) {
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v11[0] = _NSConcreteStackBlock;
          v11[1] = 1174405120;
          void v11[2] = sub_10082490C;
          void v11[3] = &unk_101A0EB20;
          void v11[4] = a1;
          void v11[5] = v8;
          uint64_t v12 = v7;
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v13 = v6;
          int v14 = v5;
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
          aBlock = _Block_copy(v11);
          (*(void (**)(uint64_t, uint64_t, uint64_t *, void **))(*(void *)v6 + 32))(v6, a1 + 96, &v16, &aBlock);
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (v17) {
            sub_10004D2C8(v17);
          }
          if (v14) {
            sub_10004D2C8(v14);
          }
          if (v12) {
            std::__shared_weak_count::__release_weak(v12);
          }
          if (v7) {
            std::__shared_weak_count::__release_weak(v7);
          }
        }
        sub_10004D2C8(v5);
      }
    }
    return;
  }
  if (*(unsigned char *)(v2 + 23)) {
    goto LABEL_7;
  }
LABEL_6:
  if (sub_100824654(a1)) {
    goto LABEL_7;
  }
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E GetPlansFetch: No install params found", buf, 2u);
  }
  sub_10082D868(*(void *)(a1 + 88), (uint64_t)buf, 1);
}

void sub_1008245F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, void *aBlock, uint64_t a19, std::__shared_weak_count *a20)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

BOOL sub_100824654(uint64_t a1)
{
  if (!*(void *)(a1 + 1296)) {
    return 0;
  }
  unint64_t v2 = *(void *)(a1 + 1288);
  long long v3 = *(_OWORD *)(*(void *)(*(void *)(a1 + 1264) + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v2);
  long long v12 = v3;
  uint64_t v4 = *(std::__shared_weak_count **)(*(void *)(*(void *)(a1 + 1264) + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8))
                                    + 16 * v2
                                    + 8);
  if (*((void *)&v3 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v3 + 1) + 8), 1uLL, memory_order_relaxed);
    unint64_t v2 = *(void *)(a1 + 1288);
    uint64_t v5 = *(std::__shared_weak_count **)(*(void *)(*(void *)(a1 + 1264) + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8))
                                      + 16 * v2
                                      + 8);
    if (v5)
    {
      sub_10004D2C8(v5);
      unint64_t v2 = *(void *)(a1 + 1288);
    }
  }
  --*(void *)(a1 + 1296);
  unint64_t v6 = v2 + 1;
  *(void *)(a1 + 1288) = v6;
  if (v6 >= 0x200)
  {
    operator delete(**(void ***)(a1 + 1264));
    *(void *)(a1 + 1264) += 8;
    *(void *)(a1 + 1288) -= 256;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = v12;
    if (*(char *)(v12 + 23) < 0) {
      uint64_t v8 = *(void *)v12;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Dequeuing server: (%s)", buf, 0xCu);
  }
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_10030BBA0(buf, *(void *)(*(void *)(a1 + 1312) + 8 * (*(void *)(a1 + 1336) / 0x16uLL))+ 184 * (*(void *)(a1 + 1336) % 0x16uLL));
  sub_10030AEBC(*(void *)(*(void *)(a1 + 1312) + 8 * (*(void *)(a1 + 1336) / 0x16uLL))+ 184 * (*(void *)(a1 + 1336) % 0x16uLL));
  int64x2_t v9 = vaddq_s64(*(int64x2_t *)(a1 + 1336), (int64x2_t)xmmword_10144F900);
  *(int64x2_t *)(a1 + 1336) = v9;
  if (v9.i64[0] >= 0x2CuLL)
  {
    operator delete(**(void ***)(a1 + 1312));
    *(void *)(a1 + 1312) += 8;
    *(void *)(a1 + 1336) -= 22;
  }
  if ((void)v12)
  {
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 120);
    *(_OWORD *)(a1 + 112) = v12;
    if (v10) {
      sub_10004D2C8(v10);
    }
    sub_10030C024(a1 + 128, (uint64_t)buf);
  }
  sub_10030AEBC((uint64_t)buf);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return (void)v12 != 0;
}

void sub_1008248E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10030AEBC((uint64_t)va);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

void sub_10082490C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      int64x2_t v9 = v8;
      if (!*(void *)(a1 + 40))
      {
LABEL_44:
        sub_10004D2C8(v9);
        return;
      }
      uint64_t v10 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 136315138;
        uint64_t v26 = asString();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I received fetch result : %s", (uint8_t *)&v25, 0xCu);
      }
      if (a2 > 1) {
        goto LABEL_30;
      }
      char v11 = (unsigned char *)(v7 + 312);
      if (*(unsigned char *)(v7 + 312))
      {
        if (*(unsigned char *)a3)
        {
          long long v12 = *(_OWORD *)(a3 + 24);
          *(_OWORD *)(v7 + 320) = *(_OWORD *)(a3 + 8);
          *(_OWORD *)(v7 + 336) = v12;
          std::string::operator=((std::string *)(v7 + 352), (const std::string *)(a3 + 40));
          sub_1000C86CC(v7 + 376, a3 + 64);
        }
        else
        {
          sub_1000C60D8(v7 + 312);
        }
        if (!*v11) {
          goto LABEL_17;
        }
      }
      else
      {
        if (!*(unsigned char *)a3) {
          goto LABEL_17;
        }
        sub_1000C5DA8(v7 + 320, a3 + 8);
        *char v11 = 1;
      }
      if (*(unsigned char *)(v7 + 400))
      {
        uint64_t v13 = *(NSObject **)(v7 + 40);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_20;
        }
        unint64_t v14 = 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v7 + 384) - *(void *)(v7 + 376)) >> 3);
        int v25 = 134217984;
        uint64_t v26 = v14;
        long long v15 = "#I remote vinyl info: number of profiles: %lu";
        long long v16 = v13;
        uint32_t v17 = 12;
        goto LABEL_19;
      }
LABEL_17:
      long long v18 = *(NSObject **)(v7 + 40);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_20;
      }
      LOWORD(v25) = 0;
      long long v15 = "#I remote vinyl info: no profiles";
      long long v16 = v18;
      uint32_t v17 = 2;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v25, v17);
LABEL_20:
      if (*(void *)(*(void *)(v7 + 112) + 104) == *(void *)(*(void *)(v7 + 112) + 96)
        || sub_100824D48(v7))
      {
        long long v19 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v25) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Fetch Profiles", (uint8_t *)&v25, 2u);
        }
LABEL_24:
        sub_10082DD38(*(void *)(v7 + 88), (uint64_t)&v25, 1);
        goto LABEL_44;
      }
      if (*(_DWORD *)(v7 + 1200) == 5)
      {
        long long v20 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v25) = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I no matching profile, start websheet", (uint8_t *)&v25, 2u);
        }
        goto LABEL_24;
      }
      a2 = 2;
LABEL_30:
      if (*(unsigned char *)(v7 + 1224) && *(unsigned char *)(v7 + 1225)) {
        uint64_t v21 = 9;
      }
      else {
        uint64_t v21 = 8;
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 56) + 160))(*(void *)(a1 + 56), v21);
      long long v22 = *(NSObject **)(v7 + 40);
      if (a2 == 5 && *(_DWORD *)(v7 + 1200) != 9)
      {
        if (os_log_type_enabled(*(os_log_t *)(v7 + 40), OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v23 = asString();
          int v25 = 136315138;
          uint64_t v26 = v23;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Overriding %s to general failure", (uint8_t *)&v25, 0xCu);
          long long v22 = *(NSObject **)(v7 + 40);
        }
        a2 = 2;
      }
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = asString();
        int v25 = 136315138;
        uint64_t v26 = v24;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Marking fetch failure: %s", (uint8_t *)&v25, 0xCu);
      }
      if (*(_DWORD *)(v7 + 1200)) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 112))(*(void *)(a1 + 56), a2, v7 + 96);
      }
      sub_10082D868(*(void *)(v7 + 88), (uint64_t)&v25, 1);
      goto LABEL_44;
    }
  }
}

void sub_100824D1C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100824D48(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 312) && *(unsigned char *)(a1 + 400))
  {
    if (*(void *)(*(void *)(a1 + 112) + 104) != *(void *)(*(void *)(a1 + 112) + 96))
    {
      uint64_t v2 = *(void *)(a1 + 376);
      uint64_t v21 = *(void *)(a1 + 384);
      if (v2 != v21)
      {
        while (1)
        {
          std::string __p = 0;
          size_t v24 = 0;
          uint64_t v25 = 0;
          sub_100CD7084(v2 + 16, (uint64_t)&__p);
          uint64_t v3 = *(void *)(a1 + 112);
          uint64_t v4 = *(void *)(v3 + 96);
          uint64_t v5 = *(void *)(v3 + 104);
          uint64_t v6 = HIBYTE(v25);
          if (v4 == v5)
          {
            BOOL v14 = 1;
          }
          else
          {
            unint64_t v7 = *(unsigned __int8 *)(v2 + 39);
            size_t v19 = v24;
            long long v20 = __p;
            size_t v8 = v25 >= 0 ? HIBYTE(v25) : v24;
            size_t v22 = v8;
            do
            {
              unint64_t v9 = *(char *)(v4 + 23) < 0 ? *(void *)(v4 + 8) : *(unsigned __int8 *)(v4 + 23);
              if ((v7 & 0x80) != 0)
              {
                if (v9 == -1) {
LABEL_61:
                }
                  sub_1000C14D8();
                char v11 = *(const void **)(v2 + 16);
                size_t v10 = *(void *)(v2 + 24) >= v9 ? v9 : *(void *)(v2 + 24);
              }
              else
              {
                if (v9 == -1) {
                  goto LABEL_61;
                }
                size_t v10 = v7 >= v9 ? v9 : v7;
                char v11 = (const void *)(v2 + 16);
              }
              long long v12 = *(char *)(v4 + 23) >= 0 ? (unsigned __int8 *)v4 : *(unsigned __int8 **)v4;
              BOOL v13 = !memcmp(v11, v12, v10) && v10 == v9;
              BOOL v14 = !v13;
              if (v13) {
                break;
              }
              if (v22 == v9)
              {
                if ((v6 & 0x80) != 0)
                {
                  if (!memcmp(v20, v12, v19))
                  {
                    operator delete(v20);
                    return 1;
                  }
                }
                else
                {
                  if (!v6) {
                    return 1;
                  }
                  uint64_t v15 = 0;
                  while (*((unsigned __int8 *)&__p + v15) == v12[v15])
                  {
                    if (v6 == ++v15) {
                      return 1;
                    }
                  }
                }
              }
              v4 += 24;
            }
            while (v4 != v5);
          }
          if ((v6 & 0x80) != 0) {
            operator delete(__p);
          }
          if (!v14) {
            return 1;
          }
          uint64_t result = 0;
          v2 += 216;
          if (v2 == v21) {
            return result;
          }
        }
      }
      return 0;
    }
    return 1;
  }
  if (*(unsigned char *)(a1 + 1224) && !*(unsigned char *)(a1 + 1225)) {
    return 0;
  }
  uint64_t result = *(void *)(a1 + 64);
  if (result)
  {
    uint64_t result = (uint64_t)std::__shared_weak_count::lock((std::__shared_weak_count *)result);
    if (result)
    {
      uint32_t v17 = (std::__shared_weak_count *)result;
      uint64_t v18 = *(void *)(a1 + 56);
      if (v18
        && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 136))(v18, *(void *)(a1 + 112) + 96) & 1) != 0)
      {
        sub_10004D2C8(v17);
        return 1;
      }
      sub_10004D2C8(v17);
      return 0;
    }
  }
  return result;
}

void sub_100824F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

BOOL sub_100824FBC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1200) == 5;
}

BOOL sub_100824FCC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1200) == 0;
}

void sub_100824FDC(uint64_t a1)
{
}

void sub_100824FE4(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 112);
  if (!v3) {
    goto LABEL_38;
  }
  if (*(char *)(v3 + 23) < 0)
  {
    if (!*(void *)(v3 + 8)) {
      goto LABEL_38;
    }
  }
  else if (!*(unsigned char *)(v3 + 23))
  {
    goto LABEL_38;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      unint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 56);
      if (v8)
      {
        switch(a2)
        {
          case 0:
            unint64_t v9 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              char v10 = 2;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: failed", buf, 2u);
            }
            else
            {
              char v10 = 2;
            }
            break;
          case 1:
            char v11 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: successfully", buf, 2u);
            }
            char v10 = 1;
            break;
          case 2:
            long long v12 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: incomplete", buf, 2u);
            }
            char v10 = 3;
            break;
          case 3:
            BOOL v13 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I provisioning finished: cancel", buf, 2u);
            }
            char v10 = 4;
            break;
          default:
            char v10 = 0;
            break;
        }
        if (*(unsigned char *)(a1 + 304))
        {
          *(unsigned char *)(a1 + 296) = v10;
          sub_100311AFC((uint64_t)&v14, (int *)(a1 + 128));
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 168))(v8, &v14);
          if (v26 < 0) {
            operator delete(__p);
          }
          if (v24 < 0) {
            operator delete(v23);
          }
          if (v22 < 0) {
            operator delete(v21);
          }
          if (v20 < 0) {
            operator delete(v19);
          }
          if (v18 < 0) {
            operator delete(v17);
          }
          if (v16 < 0) {
            operator delete(v15);
          }
          sub_10030C110(a1 + 128);
        }
      }
      sub_10004D2C8(v7);
    }
  }
LABEL_38:
  if (sub_100824654(a1)) {
    sub_1008243E8(a1);
  }
}

void sub_100825274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002DB328((uint64_t)&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_1008252A8(uint64_t a1, int a2)
{
}

void sub_1008252B0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 56);
      if (v5)
      {
        sub_10003E168(&v13, (void *)(a1 + 8));
        uint64_t v7 = v13;
        uint64_t v6 = v14;
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v6);
        }
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v13) = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fetching websheet info", (uint8_t *)&v13, 2u);
        }
        if (*(_DWORD *)(a1 + 1200) == 7)
        {
          unint64_t v9 = sub_10082550C((unsigned char *)(a1 + 408));
          if (v6) {
            atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          char v18 = 0;
          char v10 = operator new(0x20uLL);
          *char v10 = off_101A0EF18;
          v10[1] = a1;
          _DWORD v10[2] = v7;
          v10[3] = v6;
          char v18 = v10;
          char v11 = v17;
          (*(void (**)(uint64_t, unsigned char *, unsigned char *))(*(void *)v5 + 48))(v5, v9, v17);
        }
        else
        {
          if (v6) {
            atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          char v16 = 0;
          long long v12 = operator new(0x20uLL);
          *long long v12 = off_101A0EF18;
          v12[1] = a1;
          v12[2] = v7;
          void v12[3] = v6;
          char v16 = v12;
          char v11 = v15;
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v5 + 40))(v5, v15);
        }
        sub_100345BCC(v11);
        if (v6) {
          std::__shared_weak_count::__release_weak(v6);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1008254B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100345BCC(va);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  sub_10004D2C8(v4);
  _Unwind_Resume(a1);
}

unsigned char *sub_10082550C(unsigned char *a1)
{
  if (!*a1)
  {
    std::logic_error::logic_error(&v2, "Attempted to access the value of an uninitialized optional object.");
    v2.__vftable = (std::logic_error_vtbl *)&off_1019F8AE8;
    sub_10069F65C(&v2);
  }
  return a1 + 8;
}

void sub_100825578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::logic_error a9)
{
}

void sub_10082558C(uint64_t a1)
{
}

void sub_100825594(uint64_t a1)
{
  std::logic_error v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I launch websheet", buf, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3)
  {
    if (*(_DWORD *)(a1 + 1200) == 5) {
      *(_DWORD *)(a1 + 1200) = 2;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 168))(v3);
    sub_10003E168(buf, (void *)(a1 + 8));
    uint64_t v6 = *(void *)buf;
    uint64_t v5 = v25;
    if (v25)
    {
      atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v5);
    }
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 72) + 152))(buf);
    uint64_t v7 = *(void *)buf;
    sub_100058DB0(__p, "DA checkin timer");
    uint64_t v8 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_100825964;
    aBlock[3] = &unk_101A0EB50;
    aBlock[4] = a1;
    void aBlock[5] = v6;
    char v18 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    size_t v19 = _Block_copy(aBlock);
    sub_100118A44(v7, (uint64_t)__p, 1, 1000000 * v4, &object, &v19);
    uint64_t v9 = v23;
    uint64_t v23 = 0;
    uint64_t v10 = *(void *)(a1 + 1240);
    *(void *)(a1 + 1240) = v9;
    if (v10)
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      uint64_t v11 = v23;
      uint64_t v23 = 0;
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
      }
    }
    if (v19) {
      _Block_release(v19);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v22 < 0) {
      operator delete(__p[0]);
    }
    if (v25) {
      sub_10004D2C8(v25);
    }
    long long v12 = *(std::__shared_weak_count **)(a1 + 64);
    if (v12)
    {
      uint64_t v13 = std::__shared_weak_count::lock(v12);
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t v15 = *(void *)(a1 + 56);
        if (v15)
        {
          char v16 = *(unsigned char *)(a1 + 408);
          if (v16)
          {
            sub_100827714(__dst, (long long *)(a1 + 416));
            char v16 = 1;
          }
          else
          {
            LOBYTE(__dst[0]) = 0;
          }
          char v27 = v16;
          (*(void (**)(uint64_t, void *))(*(void *)v15 + 56))(v15, __dst);
          sub_10030AF48((uint64_t)__dst);
        }
        sub_10004D2C8(v14);
      }
    }
    if (v18) {
      std::__shared_weak_count::__release_weak(v18);
    }
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_1008258B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  sub_10004D2C8(v29);
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  _Unwind_Resume(a1);
}

void sub_100825964(void *a1)
{
  std::logic_error v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[5];
      if (v6 && *(void *)(v6 + 1240))
      {
        uint64_t v7 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I waited too long for checkin, aborting", buf, 2u);
        }
        sub_100829300(*(void *)(v3 + 88), (uint64_t)buf, 1);
        uint64_t v8 = *(void *)(v3 + 1232);
        *(void *)(v3 + 1232) = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
        uint64_t v9 = *(std::__shared_weak_count **)(v3 + 64);
        if (v9)
        {
          uint64_t v10 = std::__shared_weak_count::lock(v9);
          if (v10)
          {
            uint64_t v11 = v10;
            uint64_t v12 = *(void *)(v3 + 56);
            if (v12 && *(unsigned char *)(v3 + 304))
            {
              *(unsigned char *)(v3 + 296) = 3;
              sub_100311AFC((uint64_t)&v13, (int *)(v3 + 128));
              (*(void (**)(uint64_t, uint64_t *))(*(void *)v12 + 168))(v12, &v13);
              if (v25 < 0) {
                operator delete(__p);
              }
              if (v23 < 0) {
                operator delete(v22);
              }
              if (v21 < 0) {
                operator delete(v20);
              }
              if (v19 < 0) {
                operator delete(v18);
              }
              if (v17 < 0) {
                operator delete(v16);
              }
              if (v15 < 0) {
                operator delete(v14);
              }
              sub_10030C110(v3 + 128);
            }
            sub_10004D2C8(v11);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100825B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002DB328((uint64_t)&a9);
  sub_10004D2C8(v10);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_100825B54(uint64_t a1)
{
}

void sub_100825B5C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 408))
  {
    std::logic_error v2 = *(std::__shared_weak_count **)(a1 + 64);
    if (v2)
    {
      uint64_t v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        uint64_t v4 = v3;
        uint64_t v5 = *(void *)(a1 + 56);
        if (v5)
        {
          uint64_t v6 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            if (!*(unsigned char *)(a1 + 408)) {
              __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
            }
            uint64_t v7 = (void *)(a1 + 448);
            if (*(char *)(a1 + 471) < 0) {
              uint64_t v7 = (void *)*v7;
            }
            *(_DWORD *)long long buf = 136315138;
            uint64_t v14 = v7;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I load url: %s", buf, 0xCu);
          }
          uint64_t v8 = *(const void **)(a1 + 1216);
          if (v8)
          {
            aBlock = _Block_copy(v8);
            if (!*(unsigned char *)(a1 + 408)) {
              __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
            }
            (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v5 + 64))(v5, &aBlock, a1 + 416);
            if (aBlock) {
              _Block_release(aBlock);
            }
            uint64_t v9 = *(const void **)(a1 + 1216);
            *(void *)(a1 + 1216) = 0;
            if (v9) {
              _Block_release(v9);
            }
          }
          if (*(unsigned char *)(a1 + 304))
          {
            unsigned int v10 = *(unsigned __int8 *)(a1 + 132);
            if (v10 <= 0xC && ((1 << v10) & 0x1820) != 0) {
              *(unsigned char *)(a1 + 160) = 3;
            }
          }
        }
        sub_10004D2C8(v4);
      }
    }
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E missing websheet launch info", buf, 2u);
    }
  }
}

void sub_100825D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100825DA4(uint64_t a1)
{
}

void sub_100825DAC(void *a1, unsigned __int8 a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[7];
      if (v7)
      {
        sub_10003E168(&v15, a1 + 1);
        uint64_t v9 = v15;
        uint64_t v8 = v16;
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v8);
        }
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 1174405120;
        _DWORD v10[2] = sub_100825F68;
        v10[3] = &unk_101A0EB80;
        v10[4] = a1;
        v10[5] = v9;
        uint64_t v11 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v12 = v7;
        uint64_t v13 = v6;
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        aBlock = _Block_copy(v10);
        (*(void (**)(uint64_t, void *, void, void **))(*(void *)v7 + 96))(v7, a1 + 12, a2, &aBlock);
        if (aBlock) {
          _Block_release(aBlock);
        }
        if (v13) {
          sub_10004D2C8(v13);
        }
        if (v11) {
          std::__shared_weak_count::__release_weak(v11);
        }
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100825F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_100825F68(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 40) && (a2 & 0xFF00000000) != 0)
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E unable to send user consent response, aborting", buf, 2u);
        }
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 104))(*(void *)(a1 + 56), a2, v5 + 96);
        sub_100829300(*(void *)(v5 + 88), (uint64_t)&v9, 1);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100826050(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100826068(uint64_t a1, unsigned __int8 a2)
{
}

void sub_100826070(uint64_t a1, int a2)
{
  if (!a2)
  {
    int v3 = 1;
    goto LABEL_5;
  }
  if (a2 == 1)
  {
    int v3 = 2;
LABEL_5:
    *(_DWORD *)(a1 + 1228) = v3;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 56);
      if (v7) {
        (*(void (**)(uint64_t, void))(*(void *)v7 + 128))(v7, *(unsigned int *)(a1 + 1228));
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100826110(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100826124(uint64_t a1, int a2)
{
}

void sub_10082612C(uint64_t a1, int a2)
{
}

void sub_100826134(uint64_t a1)
{
  std::logic_error v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 56);
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 120))(v5, 1);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1008261B8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008261CC(uint64_t a1)
{
}

BOOL sub_1008261D4(uint64_t a1)
{
  return *(void *)(a1 + 1248) != 0;
}

uint64_t sub_1008261E4(uint64_t a1)
{
  return sub_100824D48(a1 - 48);
}

uint64_t sub_1008261EC(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 1200) - 2) > 5) {
    return 0;
  }
  std::logic_error v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (!v2) {
    return 0;
  }
  int v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 152))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_10082627C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100826290(uint64_t a1)
{
  return sub_1008261EC(a1 - 48);
}

uint64_t sub_100826298(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 1200) < 8u) & (0xC4u >> *(_DWORD *)(a1 + 1200));
}

uint64_t sub_1008262B4(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 1152) < 8u) & (0xC4u >> *(_DWORD *)(a1 + 1152));
}

BOOL sub_1008262D0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1200) == 4;
}

BOOL sub_1008262E0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1152) == 4;
}

BOOL sub_1008262F0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1200) == 8;
}

BOOL sub_100826300(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1152) == 8;
}

BOOL sub_100826310(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1200) == 1;
}

BOOL sub_100826320(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1152) == 1;
}

BOOL sub_100826330(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1152) == 0;
}

BOOL sub_100826340(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1152) == 5;
}

uint64_t sub_100826350(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 1200)) {
    return 1;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (!v4) {
    return 1;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v4);
  if (!v5) {
    return 1;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 56);
  if (v7) {
    uint64_t v1 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 144))(v7);
  }
  else {
    uint64_t v1 = 1;
  }
  sub_10004D2C8(v6);
  return v1;
}

void sub_1008263D8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008263EC(uint64_t a1)
{
  return sub_100826350(a1 - 48);
}

BOOL sub_1008263F4(uint64_t a1)
{
  return *(unsigned char *)(a1 + 408) && *(unsigned char *)(a1 + 440) == 0;
}

BOOL sub_100826414(uint64_t a1)
{
  return *(unsigned char *)(a1 + 360) && *(unsigned char *)(a1 + 392) == 0;
}

uint64_t sub_100826434(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1248);
}

uint64_t sub_10082643C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1200);
}

uint64_t sub_100826444(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1249);
}

uint64_t sub_10082644C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1201);
}

void sub_100826454(uint64_t a1, uint64_t *a2)
{
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136446210;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I moved to state: %{public}s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100826500(uint64_t a1, uint64_t *a2)
{
}

void sub_100826508(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void **)a2;
    if (*(char *)(*(void *)a2 + 23) < 0) {
      uint64_t v7 = (void *)*v7;
    }
    *(_DWORD *)long long buf = 136315138;
    v220 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Enqueuing server: (%s)", buf, 0xCu);
  }
  std::string::size_type v218 = a2;
  if (!*(void *)(a1 + 1296))
  {
    uint64_t v29 = *(void *)(a1 + 112);
    if (*(char *)(v29 + 23) < 0)
    {
      if (*(void *)(v29 + 8)) {
        goto LABEL_6;
      }
    }
    else if (*(unsigned char *)(v29 + 23))
    {
      goto LABEL_6;
    }
    if (*(unsigned char *)(a1 + 304)) {
      a3 = a1 + 128;
    }
  }
LABEL_6:
  uint64_t v8 = *(char **)(a1 + 1320);
  char v9 = *(char **)(a1 + 1312);
  unint64_t v10 = (v8 - v9) >> 3;
  if (v8 == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 22 * v10 - 1;
  }
  unint64_t v12 = *(void *)(a1 + 1336);
  if (v11 == *(void *)(a1 + 1344) + v12)
  {
    BOOL v13 = v12 >= 0x16;
    unint64_t v14 = v12 - 22;
    if (v13)
    {
      *(void *)(a1 + 1336) = v14;
      uint64_t v17 = *(void *)v9;
      uint64_t v15 = v9 + 8;
      uint64_t v16 = v17;
      *(void *)(a1 + 1312) = v15;
      if (v8 == *(char **)(a1 + 1328))
      {
        unint64_t v18 = *(void *)(a1 + 1304);
        uint64_t v19 = (uint64_t)&v15[-v18];
        if ((unint64_t)v15 <= v18)
        {
          uint64_t v45 = (uint64_t)&v8[-v18];
          BOOL v44 = v45 == 0;
          uint64_t v46 = v45 >> 2;
          if (v44) {
            unint64_t v47 = 1;
          }
          else {
            unint64_t v47 = v46;
          }
          uint64_t v48 = (char *)sub_100048350(v47);
          long long v50 = &v48[8 * (v47 >> 2)];
          long long v51 = *(uint64_t **)(a1 + 1312);
          uint64_t v8 = v50;
          uint64_t v52 = *(void *)(a1 + 1320) - (void)v51;
          if (v52)
          {
            uint64_t v8 = &v50[v52 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v53 = 8 * (v52 >> 3);
            long long v54 = &v48[8 * (v47 >> 2)];
            do
            {
              uint64_t v55 = *v51++;
              *(void *)long long v54 = v55;
              v54 += 8;
              v53 -= 8;
            }
            while (v53);
          }
          long long v56 = *(void **)(a1 + 1304);
          *(void *)(a1 + 1304) = v48;
          *(void *)(a1 + 1312) = v50;
          *(void *)(a1 + 1320) = v8;
          *(void *)(a1 + 1328) = &v48[8 * v49];
          if (v56)
          {
            operator delete(v56);
            uint64_t v8 = *(char **)(a1 + 1320);
          }
        }
        else
        {
          uint64_t v20 = v19 >> 3;
          BOOL v21 = v19 >> 3 < -1;
          uint64_t v22 = (v19 >> 3) + 2;
          if (v21) {
            uint64_t v23 = v22;
          }
          else {
            uint64_t v23 = v20 + 1;
          }
          uint64_t v24 = -(v23 >> 1);
          uint64_t v25 = v23 >> 1;
          char v26 = &v15[-8 * v25];
          int64_t v27 = v8 - v15;
          if (v8 != v15)
          {
            memmove(&v15[-8 * v25], v15, v8 - v15);
            uint64_t v8 = *(char **)(a1 + 1312);
          }
          char v28 = &v8[8 * v24];
          uint64_t v8 = &v26[v27];
          *(void *)(a1 + 1320) = &v26[v27];
          *(void *)(a1 + 1312) = v28;
        }
      }
      *(void *)uint64_t v8 = v16;
    }
    else
    {
      char v30 = *(char **)(a1 + 1328);
      long long v31 = *(char **)(a1 + 1304);
      if (v10 >= (v30 - v31) >> 3)
      {
        if (v30 == v31) {
          unint64_t v34 = 1;
        }
        else {
          unint64_t v34 = (v30 - v31) >> 2;
        }
        char v35 = (char *)sub_100048350(v34);
        uint64_t v37 = v36;
        long long v38 = operator new(0xFD0uLL);
        long long v39 = &v35[8 * v10];
        long long v40 = &v35[8 * v37];
        if (v10 == v37)
        {
          uint64_t v41 = 8 * v10;
          if (v8 - v9 < 1)
          {
            CFTypeID v147 = v38;
            uint64_t v148 = v41 >> 2;
            if (v8 == v9) {
              unint64_t v149 = 1;
            }
            else {
              unint64_t v149 = v148;
            }
            v150 = (char *)sub_100048350(v149);
            long long v39 = &v150[8 * (v149 >> 2)];
            long long v40 = &v150[8 * v151];
            if (v35) {
              operator delete(v35);
            }
            char v35 = v150;
            long long v38 = v147;
          }
          else
          {
            uint64_t v42 = v41 >> 3;
            if (v42 >= -1) {
              unint64_t v43 = v42 + 1;
            }
            else {
              unint64_t v43 = v42 + 2;
            }
            v39 -= 8 * (v43 >> 1);
          }
        }
        *(void *)long long v39 = v38;
        uint64_t v8 = v39 + 8;
        for (uint64_t i = *(void *)(a1 + 1320); i != *(void *)(a1 + 1312); i -= 8)
        {
          if (v39 == v35)
          {
            if (v8 >= v40)
            {
              if (v40 == v35) {
                unint64_t v157 = 1;
              }
              else {
                unint64_t v157 = (v40 - v35) >> 2;
              }
              BOOL v158 = (char *)sub_100048350(v157);
              uint64_t v160 = v158;
              long long v39 = &v158[(2 * v157 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v161 = v8 - v35;
              BOOL v44 = v8 == v35;
              uint64_t v8 = v39;
              if (!v44)
              {
                uint64_t v8 = &v39[v161 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v162 = 8 * (v161 >> 3);
                v163 = v39;
                int v164 = v35;
                do
                {
                  uint64_t v165 = *(void *)v164;
                  v164 += 8;
                  *(void *)v163 = v165;
                  v163 += 8;
                  v162 -= 8;
                }
                while (v162);
              }
              long long v40 = &v158[8 * v159];
              if (v35) {
                operator delete(v35);
              }
              char v35 = v160;
            }
            else
            {
              uint64_t v153 = (v40 - v8) >> 3;
              if (v153 >= -1) {
                uint64_t v154 = v153 + 1;
              }
              else {
                uint64_t v154 = v153 + 2;
              }
              uint64_t v155 = v154 >> 1;
              long long v39 = &v35[8 * (v154 >> 1)];
              unint64_t v156 = v35;
              if (v8 != v35)
              {
                memmove(v39, v35, v8 - v35);
                unint64_t v156 = v8;
              }
              uint64_t v8 = &v156[8 * v155];
            }
          }
          uint64_t v166 = *(void *)(i - 8);
          *((void *)v39 - 1) = v166;
          v39 -= 8;
        }
        CFDictionaryRef v167 = *(void **)(a1 + 1304);
        *(void *)(a1 + 1304) = v35;
        *(void *)(a1 + 1312) = v39;
        *(void *)(a1 + 1320) = v8;
        *(void *)(a1 + 1328) = v40;
        if (v167)
        {
          operator delete(v167);
          uint64_t v8 = *(char **)(a1 + 1320);
        }
        goto LABEL_49;
      }
      char v32 = operator new(0xFD0uLL);
      long long v33 = v32;
      if (v30 == v8)
      {
        if (v9 == v31)
        {
          if (v8 == v9) {
            unint64_t v112 = 1;
          }
          else {
            unint64_t v112 = (v30 - v9) >> 2;
          }
          CFDictionaryRef v113 = (char *)sub_100048350(v112);
          char v9 = &v113[8 * ((v112 + 3) >> 2)];
          std::string::size_type v115 = *(uint64_t **)(a1 + 1312);
          CFTypeID v116 = v9;
          uint64_t v117 = *(void *)(a1 + 1320) - (void)v115;
          if (v117)
          {
            CFTypeID v116 = &v9[v117 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v118 = 8 * (v117 >> 3);
            CFIndex v119 = &v113[8 * ((v112 + 3) >> 2)];
            do
            {
              uint64_t v120 = *v115++;
              *(void *)CFIndex v119 = v120;
              v119 += 8;
              v118 -= 8;
            }
            while (v118);
          }
          CFStringRef v121 = *(void **)(a1 + 1304);
          *(void *)(a1 + 1304) = v113;
          *(void *)(a1 + 1312) = v9;
          *(void *)(a1 + 1320) = v116;
          *(void *)(a1 + 1328) = &v113[8 * v114];
          if (v121)
          {
            operator delete(v121);
            char v9 = *(char **)(a1 + 1312);
          }
        }
        *((void *)v9 - 1) = v33;
        long long v122 = *(char **)(a1 + 1312);
        *(void *)(a1 + 1312) = v122 - 8;
        uint64_t v123 = *((void *)v122 - 1);
        *(void *)(a1 + 1312) = v122;
        CFDictionaryRef v124 = *(char **)(a1 + 1320);
        if (v124 == *(char **)(a1 + 1328))
        {
          unint64_t v125 = *(void *)(a1 + 1304);
          uint64_t v126 = (uint64_t)&v122[-v125];
          if ((unint64_t)v122 <= v125)
          {
            uint64_t v194 = (uint64_t)&v124[-v125];
            BOOL v44 = v194 == 0;
            uint64_t v195 = v194 >> 2;
            if (v44) {
              unint64_t v196 = 1;
            }
            else {
              unint64_t v196 = v195;
            }
            v197 = (char *)sub_100048350(v196);
            v199 = &v197[8 * (v196 >> 2)];
            v200 = *(uint64_t **)(a1 + 1312);
            CFDictionaryRef v124 = v199;
            uint64_t v201 = *(void *)(a1 + 1320) - (void)v200;
            if (v201)
            {
              CFDictionaryRef v124 = &v199[v201 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v202 = 8 * (v201 >> 3);
              v203 = &v197[8 * (v196 >> 2)];
              do
              {
                uint64_t v204 = *v200++;
                *(void *)v203 = v204;
                v203 += 8;
                v202 -= 8;
              }
              while (v202);
            }
            CFDictionaryRef v205 = *(void **)(a1 + 1304);
            *(void *)(a1 + 1304) = v197;
            *(void *)(a1 + 1312) = v199;
            *(void *)(a1 + 1320) = v124;
            *(void *)(a1 + 1328) = &v197[8 * v198];
            if (v205)
            {
              operator delete(v205);
              CFDictionaryRef v124 = *(char **)(a1 + 1320);
            }
          }
          else
          {
            uint64_t v127 = v126 >> 3;
            BOOL v21 = v126 >> 3 < -1;
            uint64_t v128 = (v126 >> 3) + 2;
            if (v21) {
              uint64_t v129 = v128;
            }
            else {
              uint64_t v129 = v127 + 1;
            }
            uint64_t v130 = -(v129 >> 1);
            uint64_t v131 = v129 >> 1;
            CFStringRef v132 = &v122[-8 * v131];
            int64_t v133 = v124 - v122;
            if (v124 != v122)
            {
              memmove(&v122[-8 * v131], v122, v124 - v122);
              long long v122 = *(char **)(a1 + 1312);
            }
            CFDictionaryRef v124 = &v132[v133];
            *(void *)(a1 + 1320) = &v132[v133];
            *(void *)(a1 + 1312) = &v122[8 * v130];
          }
        }
        *(void *)CFDictionaryRef v124 = v123;
      }
      else
      {
        *(void *)uint64_t v8 = v32;
      }
    }
    uint64_t v8 = (char *)(*(void *)(a1 + 1320) + 8);
    *(void *)(a1 + 1320) = v8;
LABEL_49:
    char v9 = *(char **)(a1 + 1312);
  }
  if (v8 == v9)
  {
    long long v58 = 0;
  }
  else
  {
    unint64_t v57 = *(void *)(a1 + 1344) + *(void *)(a1 + 1336);
    long long v58 = (unsigned char *)(*(void *)&v9[8 * (v57 / 0x16)] + 184 * (v57 % 0x16));
  }
  sub_10030BBA0(v58, a3);
  long long v59 = *(char **)(a1 + 1272);
  uint64_t v60 = *(char **)(a1 + 1264);
  uint64_t v61 = v59 - v60;
  ++*(void *)(a1 + 1344);
  if (v59 == v60) {
    uint64_t v62 = 0;
  }
  else {
    uint64_t v62 = 32 * (v59 - v60) - 1;
  }
  unint64_t v63 = *(void *)(a1 + 1288);
  uint64_t v64 = *(void *)(a1 + 1296);
  unint64_t v65 = v64 + v63;
  if (v62 != v64 + v63)
  {
    int v79 = v218;
    goto LABEL_130;
  }
  if (v63 >= 0x100)
  {
    *(void *)(a1 + 1288) = v63 - 256;
    uint64_t v68 = *(void *)v60;
    int v66 = v60 + 8;
    uint64_t v67 = v68;
    *(void *)(a1 + 1264) = v66;
    if (v59 == *(char **)(a1 + 1280))
    {
      unint64_t v69 = *(void *)(a1 + 1256);
      uint64_t v70 = (uint64_t)&v66[-v69];
      if ((unint64_t)v66 <= v69)
      {
        uint64_t v134 = (uint64_t)&v59[-v69];
        BOOL v44 = v134 == 0;
        uint64_t v135 = v134 >> 2;
        if (v44) {
          unint64_t v136 = 1;
        }
        else {
          unint64_t v136 = v135;
        }
        CFStringRef v137 = (char *)sub_100048350(v136);
        CFStringRef v139 = &v137[8 * (v136 >> 2)];
        CFDictionaryRef v140 = *(uint64_t **)(a1 + 1264);
        long long v59 = v139;
        uint64_t v141 = *(void *)(a1 + 1272) - (void)v140;
        if (v141)
        {
          long long v59 = &v139[v141 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v142 = 8 * (v141 >> 3);
          v143 = &v137[8 * (v136 >> 2)];
          do
          {
            uint64_t v144 = *v140++;
            *(void *)v143 = v144;
            v143 += 8;
            v142 -= 8;
          }
          while (v142);
        }
        CFArrayRef v145 = *(void **)(a1 + 1256);
        *(void *)(a1 + 1256) = v137;
        *(void *)(a1 + 1264) = v139;
        *(void *)(a1 + 1272) = v59;
        *(void *)(a1 + 1280) = &v137[8 * v138];
        if (v145)
        {
          operator delete(v145);
          long long v59 = *(char **)(a1 + 1272);
        }
      }
      else
      {
        uint64_t v71 = v70 >> 3;
        BOOL v21 = v70 >> 3 < -1;
        uint64_t v72 = (v70 >> 3) + 2;
        if (v21) {
          uint64_t v73 = v72;
        }
        else {
          uint64_t v73 = v71 + 1;
        }
        uint64_t v74 = -(v73 >> 1);
        uint64_t v75 = v73 >> 1;
        BOOL v76 = &v66[-8 * v75];
        int64_t v77 = v59 - v66;
        if (v59 != v66)
        {
          memmove(&v66[-8 * v75], v66, v59 - v66);
          long long v59 = *(char **)(a1 + 1264);
        }
        char v78 = &v59[8 * v74];
        long long v59 = &v76[v77];
        *(void *)(a1 + 1272) = &v76[v77];
        *(void *)(a1 + 1264) = v78;
      }
    }
    *(void *)long long v59 = v67;
    goto LABEL_128;
  }
  uint64_t v80 = v61 >> 3;
  BOOL v81 = *(char **)(a1 + 1280);
  long long v82 = *(char **)(a1 + 1256);
  if (v61 >> 3 >= (unint64_t)((v81 - v82) >> 3))
  {
    if (v81 == v82) {
      unint64_t v85 = 1;
    }
    else {
      unint64_t v85 = (v81 - v82) >> 2;
    }
    long long v86 = (char *)sub_100048350(v85);
    uint64_t v88 = v87;
    unsigned int v89 = operator new(0x1000uLL);
    long long v90 = &v86[8 * v80];
    long long v91 = &v86[8 * v88];
    if (v80 == v88)
    {
      uint64_t v92 = 8 * v80;
      if (v61 < 1)
      {
        uint64_t v168 = v92 >> 2;
        if (v59 == v60) {
          unint64_t v169 = 1;
        }
        else {
          unint64_t v169 = v168;
        }
        uint64_t v170 = (char *)sub_100048350(v169);
        long long v90 = &v170[8 * (v169 >> 2)];
        long long v91 = &v170[8 * v171];
        int v79 = v218;
        if (v86) {
          operator delete(v86);
        }
        long long v86 = v170;
        goto LABEL_80;
      }
      uint64_t v93 = v92 >> 3;
      if (v93 >= -1) {
        unint64_t v94 = v93 + 1;
      }
      else {
        unint64_t v94 = v93 + 2;
      }
      v90 -= 8 * (v94 >> 1);
    }
    int v79 = v218;
LABEL_80:
    *(void *)long long v90 = v89;
    int v95 = v90 + 8;
    for (uint64_t j = *(void *)(a1 + 1272); j != *(void *)(a1 + 1264); j -= 8)
    {
      if (v90 == v86)
      {
        if (v95 >= v91)
        {
          if (v91 == v86) {
            unint64_t v101 = 1;
          }
          else {
            unint64_t v101 = (v91 - v86) >> 2;
          }
          unint64_t v102 = (char *)sub_100048350(v101);
          char v104 = v102;
          long long v90 = &v102[(2 * v101 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v105 = v95 - v86;
          BOOL v44 = v95 == v86;
          int v95 = v90;
          if (!v44)
          {
            int v95 = &v90[v105 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v106 = 8 * (v105 >> 3);
            std::string::size_type v107 = v90;
            uint64_t v108 = (uint64_t *)v86;
            do
            {
              uint64_t v109 = *v108++;
              *(void *)std::string::size_type v107 = v109;
              v107 += 8;
              v106 -= 8;
            }
            while (v106);
          }
          long long v91 = &v102[8 * v103];
          if (v86) {
            operator delete(v86);
          }
          long long v86 = v104;
        }
        else
        {
          uint64_t v97 = (v91 - v95) >> 3;
          if (v97 >= -1) {
            uint64_t v98 = v97 + 1;
          }
          else {
            uint64_t v98 = v97 + 2;
          }
          uint64_t v99 = v98 >> 1;
          long long v90 = &v86[8 * (v98 >> 1)];
          std::string::size_type v100 = v86;
          if (v95 != v86)
          {
            memmove(v90, v86, v95 - v86);
            std::string::size_type v100 = v95;
          }
          int v95 = &v100[8 * v99];
        }
      }
      uint64_t v110 = *(void *)(j - 8);
      *((void *)v90 - 1) = v110;
      v90 -= 8;
    }
    CFDictionaryRef v111 = *(void **)(a1 + 1256);
    *(void *)(a1 + 1256) = v86;
    *(void *)(a1 + 1264) = v90;
    *(void *)(a1 + 1272) = v95;
    *(void *)(a1 + 1280) = v91;
    if (v111) {
      operator delete(v111);
    }
    goto LABEL_129;
  }
  long long v83 = operator new(0x1000uLL);
  long long v84 = v83;
  if (v81 == v59)
  {
    if (v60 == v82)
    {
      if (v59 == v60) {
        unint64_t v172 = 1;
      }
      else {
        unint64_t v172 = (v81 - v60) >> 2;
      }
      uint64_t v173 = (char *)sub_100048350(v172);
      uint64_t v60 = &v173[8 * ((v172 + 3) >> 2)];
      uint64_t v175 = *(uint64_t **)(a1 + 1264);
      std::string::size_type v176 = v60;
      uint64_t v177 = *(void *)(a1 + 1272) - (void)v175;
      int v79 = v218;
      if (v177)
      {
        std::string::size_type v176 = &v60[v177 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v178 = 8 * (v177 >> 3);
        CFDictionaryRef v179 = &v173[8 * ((v172 + 3) >> 2)];
        do
        {
          uint64_t v180 = *v175++;
          *(void *)CFDictionaryRef v179 = v180;
          v179 += 8;
          v178 -= 8;
        }
        while (v178);
      }
      uint64_t v181 = *(void **)(a1 + 1256);
      *(void *)(a1 + 1256) = v173;
      *(void *)(a1 + 1264) = v60;
      *(void *)(a1 + 1272) = v176;
      *(void *)(a1 + 1280) = &v173[8 * v174];
      if (v181)
      {
        operator delete(v181);
        uint64_t v60 = *(char **)(a1 + 1264);
      }
    }
    else
    {
      int v79 = v218;
    }
    *((void *)v60 - 1) = v84;
    std::string v182 = *(char **)(a1 + 1264);
    *(void *)(a1 + 1264) = v182 - 8;
    uint64_t v183 = *((void *)v182 - 1);
    *(void *)(a1 + 1264) = v182;
    v184 = *(char **)(a1 + 1272);
    if (v184 == *(char **)(a1 + 1280))
    {
      unint64_t v185 = *(void *)(a1 + 1256);
      uint64_t v186 = (uint64_t)&v182[-v185];
      if ((unint64_t)v182 <= v185)
      {
        uint64_t v206 = (uint64_t)&v184[-v185];
        BOOL v44 = v206 == 0;
        uint64_t v207 = v206 >> 2;
        if (v44) {
          unint64_t v208 = 1;
        }
        else {
          unint64_t v208 = v207;
        }
        v209 = (char *)sub_100048350(v208);
        v211 = &v209[8 * (v208 >> 2)];
        uint64_t v212 = *(uint64_t **)(a1 + 1264);
        v184 = v211;
        uint64_t v213 = *(void *)(a1 + 1272) - (void)v212;
        if (v213)
        {
          v184 = &v211[v213 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v214 = 8 * (v213 >> 3);
          uint64_t v215 = &v209[8 * (v208 >> 2)];
          do
          {
            uint64_t v216 = *v212++;
            *(void *)uint64_t v215 = v216;
            v215 += 8;
            v214 -= 8;
          }
          while (v214);
        }
        std::string v217 = *(void **)(a1 + 1256);
        *(void *)(a1 + 1256) = v209;
        *(void *)(a1 + 1264) = v211;
        *(void *)(a1 + 1272) = v184;
        *(void *)(a1 + 1280) = &v209[8 * v210];
        if (v217)
        {
          operator delete(v217);
          v184 = *(char **)(a1 + 1272);
        }
      }
      else
      {
        uint64_t v187 = v186 >> 3;
        BOOL v21 = v186 >> 3 < -1;
        uint64_t v188 = (v186 >> 3) + 2;
        if (v21) {
          uint64_t v189 = v188;
        }
        else {
          uint64_t v189 = v187 + 1;
        }
        uint64_t v190 = -(v189 >> 1);
        uint64_t v191 = v189 >> 1;
        v192 = &v182[-8 * v191];
        int64_t v193 = v184 - v182;
        if (v184 != v182)
        {
          memmove(&v182[-8 * v191], v182, v184 - v182);
          std::string v182 = *(char **)(a1 + 1264);
        }
        v184 = &v192[v193];
        *(void *)(a1 + 1272) = &v192[v193];
        *(void *)(a1 + 1264) = &v182[8 * v190];
      }
    }
    *(void *)v184 = v183;
    *(void *)(a1 + 1272) += 8;
    goto LABEL_129;
  }
  *(void *)long long v59 = v83;
LABEL_128:
  *(void *)(a1 + 1272) += 8;
  int v79 = v218;
LABEL_129:
  uint64_t v60 = *(char **)(a1 + 1264);
  uint64_t v64 = *(void *)(a1 + 1296);
  unint64_t v65 = v64 + *(void *)(a1 + 1288);
LABEL_130:
  long long v146 = *v79;
  *(_OWORD *)(*(void *)&v60[(v65 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v65) = *v79;
  if (*((void *)&v146 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v146 + 1) + 8), 1uLL, memory_order_relaxed);
    uint64_t v64 = *(void *)(a1 + 1296);
  }
  *(void *)(a1 + 1296) = v64 + 1;
}

void sub_100827028(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void sub_100827074(uint64_t a1)
{
  sub_100827874(a1);

  operator delete();
}

uint64_t sub_1008270AC(uint64_t a1)
{
  return sub_100827874(a1 - 48);
}

void sub_1008270B4(uint64_t a1)
{
  sub_100827874(a1 - 48);

  operator delete();
}

void sub_1008270F0(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)(a1 + 8), (const std::string *)a2);
  char v4 = *(unsigned char *)(a2 + 26);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 24);
  *(unsigned char *)(a1 + 34) = v4;
  std::string::operator=((std::string *)(a1 + 40), (const std::string *)(a2 + 32));
  sub_100827168((unsigned char *)(a1 + 64), a2 + 56);
  sub_1008272B4(a1 + 408, a2 + 400);

  sub_100179AF8((std::string *)(a1 + 760), (const std::string *)(a2 + 752));
}

void sub_100827168(unsigned char *a1, uint64_t a2)
{
  if (a1[336] == *(unsigned char *)(a2 + 336))
  {
    if (a1[336])
    {
      sub_1008271D0((uint64_t)a1, a2);
    }
  }
  else if (a1[336])
  {
    sub_100346324((uint64_t)a1);
  }
  else
  {
    sub_100346848(a1, (long long *)a2)[336] = 1;
  }
}

uint64_t sub_1008271D0(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)a1, (const std::string *)a2);
  std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 24));
  std::string::operator=((std::string *)(a1 + 48), (const std::string *)(a2 + 48));
  if (a1 != a2) {
    sub_10005CA3C(a1 + 72, *(std::string **)(a2 + 72), *(long long **)(a2 + 80), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 3));
  }
  sub_1003DC1E4(a1 + 96, a2 + 96);
  sub_1003DC1E4(a1 + 128, a2 + 128);
  sub_1003DC1E4(a1 + 160, a2 + 160);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  sub_1003DC1E4(a1 + 200, a2 + 200);
  long long v4 = *(_OWORD *)(a2 + 232);
  *(_WORD *)(a1 + 248) = *(_WORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v4;
  std::string::operator=((std::string *)(a1 + 256), (const std::string *)(a2 + 256));
  sub_1003DC1E4(a1 + 280, a2 + 280);
  if (a1 != a2) {
    sub_100328AC0((uint64_t **)(a1 + 312), *(long long **)(a2 + 312), (long long *)(a2 + 320));
  }
  return a1;
}

uint64_t sub_1008272B4(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int8 *)(result + 344) == *(unsigned __int8 *)(a2 + 344))
  {
    if (*(unsigned char *)(result + 344))
    {
      return sub_100827310(result, a2);
    }
  }
  else if (*(unsigned char *)(result + 344))
  {
    uint64_t result = sub_100310520(result);
    *(unsigned char *)(result + 344) = 0;
  }
  else
  {
    uint64_t result = sub_100346D28(result, a2);
    *(unsigned char *)(result + 344) = 1;
  }
  return result;
}

uint64_t sub_100827310(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)(a1 + 32), (const std::string *)(a2 + 32));
  std::string::operator=((std::string *)(a1 + 56), (const std::string *)(a2 + 56));
  if (a1 != a2) {
    sub_100827418(a1 + 80, *(std::string **)(a2 + 80), *(std::string **)(a2 + 88), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 3));
  }
  *(unsigned char *)(a1 + 104) = *(unsigned char *)(a2 + 104);
  std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 112));
  sub_1003DC1E4(a1 + 136, a2 + 136);
  sub_1003DC1E4(a1 + 168, a2 + 168);
  std::string::operator=((std::string *)(a1 + 200), (const std::string *)(a2 + 200));
  if (a1 != a2) {
    sub_100827418(a1 + 224, *(std::string **)(a2 + 224), *(std::string **)(a2 + 232), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 232) - *(void *)(a2 + 224)) >> 3));
  }
  *(unsigned char *)(a1 + 248) = *(unsigned char *)(a2 + 248);
  std::string::operator=((std::string *)(a1 + 256), (const std::string *)(a2 + 256));
  sub_1003DC1E4(a1 + 280, a2 + 280);
  sub_1003DC1E4(a1 + 312, a2 + 312);
  return a1;
}

void sub_100827418(uint64_t a1, std::string *__str, std::string *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  char v9 = *(std::string **)a1;
  if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_1008275B8((void **)a1);
    if (a4 > 0x2E8BA2E8BA2E8BALL) {
      sub_10006A748();
    }
    unint64_t v10 = 0x5D1745D1745D1746 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)) >= 0x1745D1745D1745DLL) {
      unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100311F60((void *)a1, v11);
    uint64_t v12 = sub_100346FDC(v8, (uint64_t)__str, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    BOOL v13 = (std::string *)((char *)__str + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3));
    sub_100827620((int)&v17, __str, v13, v9);
    uint64_t v12 = sub_100346FDC(v8, (uint64_t)v13, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  sub_100827620((int)&v18, __str, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 88;
      sub_100310760(v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_1008275A8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1008275B0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1008275B8(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    long long v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 88;
        sub_100310760(v3);
      }
      while ((void *)v3 != v1);
      long long v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

std::string *sub_100827620(int a1, std::string *__str, std::string *a3, std::string *this)
{
  int v5 = __str;
  if (__str == a3) {
    return __str;
  }
  uint64_t v6 = a3;
  do
  {
    std::string::operator=(this, v5);
    sub_1003DC1E4((uint64_t)&this[1], (uint64_t)&v5[1]);
    sub_1003DC1E4((uint64_t)&this[2].__r_.__value_.__l.__size_, (uint64_t)&v5[2].__r_.__value_.__l.__size_);
    this = (std::string *)((char *)this + 88);
    int v5 = (const std::string *)((char *)v5 + 88);
  }
  while (v5 != v6);
  return v6;
}

void sub_10082769C(uint64_t a1)
{
  uint64_t v2 = a1 + 64;
  if (*(unsigned char *)(a1 + 784) && *(char *)(a1 + 783) < 0) {
    operator delete(*(void **)(a1 + 760));
  }
  if (*(unsigned char *)(a1 + 752)) {
    sub_100310520(a1 + 408);
  }
  sub_1003107E0(v2);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  *(unsigned char *)a1 = 0;
}

void *sub_100827714(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  __int16 v5 = *((_WORD *)a2 + 12);
  *((unsigned char *)__dst + 26) = *((unsigned char *)a2 + 26);
  *((_WORD *)__dst + 12) = v5;
  if (*((char *)a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)__dst + 32, *((void **)a2 + 4), *((void *)a2 + 5));
  }
  else
  {
    long long v6 = a2[2];
    __dst[6] = *((void *)a2 + 6);
    *((_OWORD *)__dst + 2) = v6;
  }
  sub_1003467F0((unsigned char *)__dst + 56, (uint64_t)a2 + 56);
  sub_100346CC8((unsigned char *)__dst + 400, (uint64_t)(a2 + 25));
  sub_1000593FC((uint64_t)(__dst + 94), a2 + 47);
  return __dst;
}

void sub_1008277E0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_10082783C(unsigned char *a1)
{
  if (*a1) {
    sub_10082769C((uint64_t)a1);
  }
  return a1;
}

uint64_t sub_100827874(uint64_t a1)
{
  *(void *)a1 = off_101A0E7E0;
  *(void *)(a1 + 48) = off_101A0E9A8;
  uint64_t v2 = *(void ***)(a1 + 1312);
  uint64_t v3 = *(void ***)(a1 + 1320);
  if (v3 == v2)
  {
    uint64_t v7 = (void *)(a1 + 1344);
    uint64_t v3 = *(void ***)(a1 + 1312);
  }
  else
  {
    unint64_t v4 = *(void *)(a1 + 1336);
    __int16 v5 = &v2[v4 / 0x16];
    uint64_t v6 = (uint64_t)*v5 + 184 * (v4 % 0x16);
    uint64_t v7 = (void *)(a1 + 1344);
    unint64_t v8 = (unint64_t)v2[(*(void *)(a1 + 1344) + v4) / 0x16] + 184 * ((*(void *)(a1 + 1344) + v4) % 0x16);
    if (v6 != v8)
    {
      do
      {
        uint64_t v6 = sub_10030AEBC(v6) + 184;
        if (v6 - (void)*v5 == 4048)
        {
          uint64_t v9 = (uint64_t)v5[1];
          ++v5;
          uint64_t v6 = v9;
        }
      }
      while (v6 != v8);
      uint64_t v3 = *(void ***)(a1 + 1320);
      uint64_t v2 = *(void ***)(a1 + 1312);
    }
  }
  *uint64_t v7 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v2 = (void **)(*(void *)(a1 + 1312) + 8);
      *(void *)(a1 + 1312) = v2;
      uint64_t v3 = *(void ***)(a1 + 1320);
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 11;
    goto LABEL_14;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 22;
LABEL_14:
    *(void *)(a1 + 1336) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      BOOL v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v14 = *(void *)(a1 + 1312);
    uint64_t v15 = *(void *)(a1 + 1320);
    if (v15 != v14) {
      *(void *)(a1 + 1320) = v15 + ((v14 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  uint64_t v16 = *(void **)(a1 + 1304);
  if (v16) {
    operator delete(v16);
  }
  char v17 = *(void ***)(a1 + 1264);
  char v18 = *(void ***)(a1 + 1272);
  if (v18 == v17)
  {
    uint64_t v23 = (void *)(a1 + 1296);
    char v18 = *(void ***)(a1 + 1264);
  }
  else
  {
    unint64_t v19 = *(void *)(a1 + 1288);
    uint64_t v20 = &v17[v19 >> 8];
    uint64_t v21 = (uint64_t)*v20;
    uint64_t v22 = (uint64_t)*v20 + 16 * v19;
    uint64_t v23 = (void *)(a1 + 1296);
    uint64_t v24 = *(uint64_t *)((char *)v17 + (((*(void *)(a1 + 1296) + v19) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*(unsigned char *)(a1 + 1296) + v19);
    if (v22 != v24)
    {
      do
      {
        uint64_t v25 = *(std::__shared_weak_count **)(v22 + 8);
        if (v25)
        {
          sub_10004D2C8(v25);
          uint64_t v21 = (uint64_t)*v20;
        }
        v22 += 16;
        if (v22 - v21 == 4096)
        {
          uint64_t v26 = (uint64_t)v20[1];
          ++v20;
          uint64_t v21 = v26;
          uint64_t v22 = v26;
        }
      }
      while (v22 != v24);
      char v18 = *(void ***)(a1 + 1272);
      char v17 = *(void ***)(a1 + 1264);
    }
  }
  *uint64_t v23 = 0;
  unint64_t v27 = (char *)v18 - (char *)v17;
  if ((unint64_t)((char *)v18 - (char *)v17) >= 0x11)
  {
    do
    {
      operator delete(*v17);
      char v17 = (void **)(*(void *)(a1 + 1264) + 8);
      *(void *)(a1 + 1264) = v17;
      char v18 = *(void ***)(a1 + 1272);
      unint64_t v27 = (char *)v18 - (char *)v17;
    }
    while ((unint64_t)((char *)v18 - (char *)v17) > 0x10);
  }
  unint64_t v28 = v27 >> 3;
  if (v28 == 1)
  {
    uint64_t v29 = 128;
    goto LABEL_36;
  }
  if (v28 == 2)
  {
    uint64_t v29 = 256;
LABEL_36:
    *(void *)(a1 + 1288) = v29;
  }
  if (v17 != v18)
  {
    do
    {
      char v30 = *v17++;
      operator delete(v30);
    }
    while (v17 != v18);
    uint64_t v31 = *(void *)(a1 + 1264);
    uint64_t v32 = *(void *)(a1 + 1272);
    if (v32 != v31) {
      *(void *)(a1 + 1272) = v32 + ((v31 - v32 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  long long v33 = *(void **)(a1 + 1256);
  if (v33) {
    operator delete(v33);
  }
  uint64_t v34 = *(void *)(a1 + 1240);
  *(void *)(a1 + 1240) = 0;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
  }
  uint64_t v35 = *(void *)(a1 + 1232);
  *(void *)(a1 + 1232) = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  uint64_t v36 = *(const void **)(a1 + 1216);
  if (v36) {
    _Block_release(v36);
  }
  uint64_t v37 = *(const void **)(a1 + 1208);
  if (v37) {
    _Block_release(v37);
  }
  sub_10082783C((unsigned char *)(a1 + 408));
  sub_1000C60A0((unsigned char *)(a1 + 312));
  sub_10030AEBC(a1 + 128);
  long long v38 = *(std::__shared_weak_count **)(a1 + 120);
  if (v38) {
    sub_10004D2C8(v38);
  }
  uint64_t v39 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v39) {
    sub_100827E10(a1 + 88, v39);
  }
  long long v40 = *(std::__shared_weak_count **)(a1 + 80);
  if (v40) {
    sub_10004D2C8(v40);
  }
  uint64_t v41 = *(std::__shared_weak_count **)(a1 + 64);
  if (v41) {
    std::__shared_weak_count::__release_weak(v41);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100827C40(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100827D0C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100827DE4);
  __cxa_rethrow();
}

void sub_100827D34(_Unwind_Exception *a1)
{
}

void sub_100827D4C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100827D84(uint64_t a1)
{
}

uint64_t sub_100827DA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100827DE4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  return result;
}

void sub_100827E10(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1000B3D68((void *)(a2 + 32));
    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
}

uint64_t sub_100827E70(uint64_t a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  if (*a2) {
    uint64_t v4 = *a2 + 48;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v6 = v4;
  uint64_t v7 = v3;
  *a2 = 0;
  a2[1] = 0;
  sub_100827F00(a1, &v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_WORD *)(a1 + 88) = 0;
  *(void *)(a1 + 91) = 0;
  *(unsigned char *)(a1 + 99) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  return a1;
}

void sub_100827EE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100827F00(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 4) = 2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
    __int16 v5 = *(std::__shared_weak_count **)(a1 + 16);
    *(void *)(a1 + 8) = v3;
    *(void *)(a1 + 16) = v4;
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    *(void *)(a1 + 8) = v3;
    *(void *)(a1 + 16) = 0;
  }
  return a1;
}

uint64_t sub_100827F5C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 168])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1008280D4(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_8DidStartEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_8DidStartEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1008281E0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t *sub_100828214(uint64_t *result)
{
  if (result[9])
  {
    uint64_t v1 = result;
    uint64_t v2 = (int64x2_t *)(result + 4);
    do
    {
      memset(v6, 0, sizeof(v6));
      uint64_t v3 = *(void *)(v1[5] + (((unint64_t)v1[8] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v1[8] & 0x7F);
      uint64_t v4 = *(void *)v3;
      if (*(void *)v3)
      {
        *(void *)&v6[0] = *(void *)v3;
        if (v4)
        {
          long long v5 = *(_OWORD *)(v3 + 8);
          *((void *)&v6[1] + 1) = *(void *)(v3 + 24);
          *(_OWORD *)((char *)v6 + 8) = v5;
        }
        else
        {
          (*(void (**)(uint64_t, char *, void))(v4 & 0xFFFFFFFFFFFFFFFELL))(v3 + 8, (char *)v6 + 8, 0);
        }
      }
      sub_1000983B4(v2);
      sub_100098420(v6);
      uint64_t result = sub_100098288((uint64_t *)v6);
    }
    while (v1[9]);
  }
  return result;
}

void sub_1008282D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1008282EC()
{
  return 0;
}

uint64_t sub_1008282F4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 184))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_100828374(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100828388(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100828408(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10082841C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 224))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1008284B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008284C4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 136))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_100828544(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100828558(uint64_t a1)
{
  sub_100058DB0(__p, "WaitForWebsheet");
  sub_10082841C(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1008285AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008285C8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  char v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 200))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_100828648(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10082865C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1008286DC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008286F0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  char v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 144))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_100828770(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100828784(uint64_t a1, int a2, int a3)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  if (sub_1008282F4(a1))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(v5 + 24) = 0;
    uint64_t v6 = (int *)(v5 + 24);
    sub_100828388(a1);
    *uint64_t v6 = 0;
    sub_100058DB0(__p, "WaitForSubscription");
    sub_10082841C(a1, (uint64_t)__p);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
    int v7 = 3;
LABEL_6:
    *uint64_t v6 = v7;
    return 1;
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      unint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 152))(v11);
        sub_10004D2C8(v10);
        if (v12)
        {
          uint64_t v13 = a1 + 4 * a2;
          *(_DWORD *)(v13 + 24) = 0;
          uint64_t v6 = (int *)(v13 + 24);
          sub_100058DB0(__p, "UserInWebsheet");
          sub_10082841C(a1, (uint64_t)__p);
          if (v25 < 0) {
            operator delete(__p[0]);
          }
          int v7 = 7;
          goto LABEL_6;
        }
      }
      else
      {
        sub_10004D2C8(v10);
      }
    }
  }
  if (!sub_1008284C4(a1))
  {
    if (sub_1008285C8(a1))
    {
      uint64_t v21 = a1 + 4 * a2;
      *(_DWORD *)(v21 + 24) = 0;
      uint64_t v6 = (int *)(v21 + 24);
      sub_10082865C(a1);
      *uint64_t v6 = 0;
      sub_100058DB0(__p, "WaitForDeleteAllPlans");
      sub_10082841C(a1, (uint64_t)__p);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
      int v7 = 1;
    }
    else
    {
      int v22 = sub_1008286F0(a1);
      uint64_t v23 = a1 + 4 * a2;
      *(_DWORD *)(v23 + 24) = 0;
      uint64_t v6 = (int *)(v23 + 24);
      if (v22)
      {
        sub_100828558(a1);
        int v7 = 2;
      }
      else
      {
        sub_100828A34(a1);
        *uint64_t v6 = 0;
        sub_100058DB0(__p, "WaitForFetch");
        sub_10082841C(a1, (uint64_t)__p);
        if (v25 < 0) {
          operator delete(__p[0]);
        }
        int v7 = 4;
      }
    }
    goto LABEL_6;
  }
  uint64_t v14 = a1 + 4 * a2;
  *(_DWORD *)(v14 + 24) = 0;
  uint64_t v15 = (_DWORD *)(v14 + 24);
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 16);
  if (v16)
  {
    char v17 = std::__shared_weak_count::lock(v16);
    if (v17)
    {
      char v18 = v17;
      uint64_t v19 = *(void *)(a1 + 8);
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 48))(v19);
      }
      sub_10004D2C8(v18);
    }
  }
  _DWORD *v15 = 0;
  sub_100828558(a1);
  _DWORD *v15 = 2;
  return 1;
}

void sub_1008289F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100828A34(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100828AB4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100828AC8(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 248])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_100828C40(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_22DoesNeedInstallConsentEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_22DoesNeedInstallConsentEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100828D4C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_100828D80()
{
  return 0;
}

uint64_t sub_100828D88(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 4;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_100058DB0(__p, "WaitForUserResponse");
  sub_10082841C(a1, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 0);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 104))(v9);
      }
      sub_10004D2C8(v8);
    }
  }
  _DWORD *v5 = 5;
  return 1;
}

void sub_100828E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100828EA4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 72))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100828F38(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100828F4C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 328])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_1008290C4(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_25DoesNotNeedInstallConsentEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_25DoesNotNeedInstallConsentEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_1008291D0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_100829204()
{
  return 0;
}

uint64_t sub_10082920C(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 653, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 4;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_100058DB0(__p, "Post installing");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 1);
  _DWORD *v5 = 4;
  sub_100058DB0(__p, "WaitForFetch");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 4;
  return 1;
}

void sub_1008292E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100829300(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 408])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_100829478(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_5AbortEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_5AbortEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100829584(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_1008295B8()
{
  return 0;
}

uint64_t sub_1008295C0(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 7;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

void sub_100829624(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  switch(*(_DWORD *)(a1 + 4))
  {
    case 0:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1818845510;
      int v2 = 1701999980;
      goto LABEL_4;
    case 1:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1667462483;
      int v2 = 1936942435;
LABEL_4:
      *(_DWORD *)((char *)&v5 + 3) = v2;
      break;
    case 2:
      HIBYTE(v7) = 10;
      LOWORD(v6) = 25972;
      uint64_t v5 = *(void **)"Incomplete";
      break;
    case 3:
      HIBYTE(v7) = 6;
      qmemcpy(&v5, "Cancel", 6);
      break;
    default:
      break;
  }
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&__p);
  if (v4 < 0) {
    operator delete(__p);
  }
  sub_100829794(a1);
  if (SHIBYTE(v7) < 0) {
    operator delete(v5);
  }
}

void sub_10082974C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100829794(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t, void))(*(void *)v5 + 80))(v5, *(unsigned int *)(a1 + 4));
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100829818(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082982C(uint64_t a1, int a2, int a3)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 6;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_100829890(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_10082997C(a1);
  sub_100058DB0(__p, "Post installing");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 1);
  _DWORD *v5 = 5;
  sub_100829A10(a1);
  *(_DWORD *)(a1 + 4) = 3;
  _DWORD *v5 = 5;
  sub_100829624(a1);
  _DWORD *v5 = 8;
  return 1;
}

void sub_100829960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10082997C(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 112))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1008299FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100829A10(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 64))(v5, 2);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100829A94(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100829AA8(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 4;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_100829B0C(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 3;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_100829B70(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 2;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_100829BD4(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 1;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_100829C38(uint64_t a1, int a2, int a3)
{
  if (a3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  sub_100829624(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_100829C94(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 488])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_100829E0C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_19DidConsentToInstallEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_19DidConsentToInstallEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_100829F18(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_100829F4C()
{
  return 0;
}

uint64_t sub_100829F54(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_10082997C(a1);
  sub_100058DB0(__p, "Post installing");
  sub_10082841C(a1, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 1);
  _DWORD *v5 = 5;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      char v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 64))(v9, 1);
      }
      sub_10004D2C8(v8);
    }
  }
  _DWORD *v5 = 5;
  sub_100058DB0(__p, "WaitForFetch");
  sub_10082841C(a1, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 4;
  return 1;
}

void sub_10082A084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10082A0B4(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 568])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082A22C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_22DidNotConsentToInstallEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_22DidNotConsentToInstallEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082A338(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082A36C()
{
  return 0;
}

uint64_t sub_10082A374(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_10082997C(a1);
  sub_100058DB0(__p, "Post installing");
  sub_10082841C(a1, (uint64_t)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 1);
  _DWORD *v5 = 5;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      char v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, void))(*(void *)v9 + 64))(v9, 0);
      }
      sub_10004D2C8(v8);
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  _DWORD *v5 = 5;
  __p[1] = 0;
  uint64_t v14 = 0x700000000000000;
  strcpy((char *)__p, "Failure");
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&v11);
  if (v12 < 0) {
    operator delete(v11);
  }
  sub_100829794(a1);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 8;
  return 1;
}

void sub_10082A4EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_10082A538(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 648])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082A6B0(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_17DidGetMonitorModeEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_17DidGetMonitorModeEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082A7BC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082A7F0()
{
  return 0;
}

uint64_t sub_10082A7F8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 120))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_10082A878(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082A88C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 128))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_10082A90C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082A920(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  if (sub_10082A7F8(a1) && sub_10082A88C(a1))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(v5 + 24) = 7;
    uint64_t v6 = (int *)(v5 + 24);
    sub_100828388(a1);
    *uint64_t v6 = 7;
    sub_100058DB0(__p, "WaitForSubscription");
    sub_10082841C(a1, (uint64_t)__p);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    int v7 = 3;
  }
  else
  {
    uint64_t v6 = (int *)(a1 + 4 * a2 + 24);
    if (sub_10082A7F8(a1))
    {
      *(_DWORD *)(a1 + 4) = 1;
      *uint64_t v6 = 7;
      __p[1] = 0;
      uint64_t v12 = 0x700000000000000;
      strcpy((char *)__p, "Success");
      std::operator+<char>();
      sub_10082841C(a1, (uint64_t)&v9);
      if (v10 < 0) {
        operator delete(v9);
      }
      sub_100829794(a1);
      if (SHIBYTE(v12) < 0) {
        operator delete(__p[0]);
      }
      int v7 = 8;
    }
    else
    {
      *uint64_t v6 = 7;
      sub_100828A34(a1);
      *uint64_t v6 = 7;
      sub_10082AAD8(a1);
      int v7 = 4;
    }
  }
  *uint64_t v6 = v7;
  return 1;
}

void sub_10082AA9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10082AAD8(uint64_t a1)
{
  sub_100058DB0(__p, "WaitForFetch");
  sub_10082841C(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10082AB2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082AB48(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 3;
  sub_100828A34(a1);
  *(_DWORD *)(v4 + 24) = 3;
  sub_10082AAD8(a1);
  *(_DWORD *)(v4 + 24) = 4;
  return 1;
}

uint64_t sub_10082ABC0(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 728])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082AD38(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_17DidPendingReleaseEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_17DidPendingReleaseEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082AE44(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082AE78()
{
  return 0;
}

uint64_t sub_10082AE80(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 7;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_100828388(a1);
  _DWORD *v5 = 7;
  sub_100058DB0(__p, "WaitForSubscription");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 3;
  return 1;
}

void sub_10082AF24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082AF40(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 808])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082B0B8(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_21DidGetAvailableOptionEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_21DidGetAvailableOptionEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082B1C4(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082B1F8()
{
  return 0;
}

uint64_t sub_10082B200(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 4;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  *(_DWORD *)(a1 + 4) = 1;
  sub_10082B2C8(a1);
  _DWORD *v5 = 4;
  sub_100058DB0(__p, "WaitForFetch");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 4;
  return 1;
}

void sub_10082B2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10082B2C8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t, void))(*(void *)v5 + 96))(v5, *(unsigned int *)(a1 + 4));
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10082B34C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082B360(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 888])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082B4D8(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_20DidLeaveCellularPaneEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_20DidLeaveCellularPaneEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082B5E4(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082B618()
{
  return 0;
}

uint64_t sub_10082B620(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 7;
  sub_10082B684(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

void sub_10082B684(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  switch(*(_DWORD *)(a1 + 4))
  {
    case 0:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1818845510;
      int v2 = 1701999980;
      goto LABEL_4;
    case 1:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1667462483;
      int v2 = 1936942435;
LABEL_4:
      *(_DWORD *)((char *)&v5 + 3) = v2;
      break;
    case 2:
      HIBYTE(v7) = 10;
      LOWORD(v6) = 25972;
      uint64_t v5 = *(void **)"Incomplete";
      break;
    case 3:
      HIBYTE(v7) = 6;
      qmemcpy(&v5, "Cancel", 6);
      break;
    default:
      break;
  }
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&__p);
  if (v4 < 0) {
    operator delete(__p);
  }
  sub_100829794(a1);
  if (SHIBYTE(v7) < 0) {
    operator delete(v5);
  }
}

void sub_10082B7AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082B7F4(uint64_t a1, int a2, int a3)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 6;
  sub_10082B684(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_10082B858(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_10082997C(a1);
  sub_100058DB0(__p, "Post installing");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 1);
  _DWORD *v5 = 5;
  sub_100829A10(a1);
  *(_DWORD *)(a1 + 4) = 3;
  _DWORD *v5 = 5;
  sub_10082B684(a1);
  _DWORD *v5 = 8;
  return 1;
}

void sub_10082B928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082B944(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(v3 + 24) = 2;
  sub_10082B684(a1);
  *(_DWORD *)(v3 + 24) = 8;
  return 1;
}

uint64_t sub_10082B9A8(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  if (sub_1008286F0(a1))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(v5 + 24) = 1;
    sub_10082B684(a1);
    *(_DWORD *)(v5 + 24) = 8;
  }
  else
  {
    uint64_t v6 = (int *)(a1 + 4 * a2 + 24);
    if (sub_1008284C4(a1))
    {
      *(_DWORD *)(a1 + 4) = 0;
      *uint64_t v6 = 1;
      sub_10082B684(a1);
      int v7 = 8;
    }
    else
    {
      *uint64_t v6 = 1;
      sub_100058DB0(__p, "WaitForDeleteAllPlans");
      sub_10082841C(a1, (uint64_t)__p);
      if (v10 < 0) {
        operator delete(__p[0]);
      }
      int v7 = 1;
    }
    *uint64_t v6 = v7;
  }
  return 1;
}

void sub_10082BA98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082BAB4(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 968])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082BC2C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_18DidDismissWebsheetEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_18DidDismissWebsheetEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082BD38(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082BD6C()
{
  return 0;
}

uint64_t sub_10082BD74(uint64_t a1, int a2, int a3)
{
  if (a3 != 7) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 7;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_100828388(a1);
  _DWORD *v5 = 7;
  sub_100058DB0(__p, "WaitForSubscription");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 3;
  return 1;
}

void sub_10082BE18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082BE34(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1048])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082BFAC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_17DidLaunchWebsheetEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_17DidLaunchWebsheetEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082C0B8(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082C0EC()
{
  return 0;
}

void sub_10082C0F4(uint64_t a1)
{
  sub_100058DB0(__p, "UserInWebsheet");
  sub_10082841C(a1, (uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10082C148(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10082C164(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 56))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10082C1E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082C1F8(uint64_t a1, int a2, int a3)
{
  if (a3 != 2) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  if (sub_1008286F0(a1))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(v5 + 24) = 2;
LABEL_4:
    sub_10082C0F4(a1);
    *(_DWORD *)(v5 + 24) = 7;
    return 1;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      char v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 160))(v9);
        sub_10004D2C8(v8);
        if (v10)
        {
          uint64_t v5 = a1 + 4 * a2;
          *(_DWORD *)(v5 + 24) = 2;
          sub_10082C164(a1);
          *(_DWORD *)(v5 + 24) = 2;
          goto LABEL_4;
        }
      }
      else
      {
        sub_10004D2C8(v8);
      }
    }
  }
  int v11 = sub_1008285C8(a1);
  uint64_t v12 = a1 + 4 * a2;
  *(_DWORD *)(v12 + 24) = 2;
  uint64_t v13 = (int *)(v12 + 24);
  if (v11)
  {
    sub_10082865C(a1);
    *uint64_t v13 = 2;
    sub_100058DB0(__p, "WaitForDeleteAllPlans");
    sub_10082841C(a1, (uint64_t)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    int v14 = 1;
  }
  else
  {
    sub_10082C3BC(a1);
    *uint64_t v13 = 2;
    sub_100058DB0(__p, "WaitForWebsheetInfo");
    sub_10082841C(a1, (uint64_t)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    int v14 = 6;
  }
  *uint64_t v13 = v14;
  return 1;
}

void sub_10082C38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_10082C3BC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10082C43C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082C450(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1128])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082C5C8(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_18DidConsentTimedOutEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_18DidConsentTimedOutEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082C6D4(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082C708()
{
  return 0;
}

uint64_t sub_10082C710(uint64_t a1, int a2, int a3)
{
  if (a3 != 5) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 5;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_10082997C(a1);
  sub_100058DB0(__p, "Post installing");
  sub_10082841C(a1, (uint64_t)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  sub_100828EA4(a1, 1);
  _DWORD *v5 = 5;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    std::exception v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      char v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 64))(v9, 3);
      }
      sub_10004D2C8(v8);
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  _DWORD *v5 = 5;
  __p[1] = 0;
  uint64_t v14 = 0x700000000000000;
  strcpy((char *)__p, "Failure");
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&v11);
  if (v12 < 0) {
    operator delete(v11);
  }
  sub_100829794(a1);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 8;
  return 1;
}

void sub_10082C888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_10082C8D4(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1208])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082CA4C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_9DidDeleteEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_9DidDeleteEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082CB58(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082CB8C()
{
  return 0;
}

uint64_t sub_10082CB94(uint64_t a1, int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("execute", "state_machine.hpp", 524, "state == (current_state)");
  }
  if (sub_1008286F0(a1))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(v5 + 24) = 1;
    uint64_t v6 = (int *)(v5 + 24);
    sub_100058DB0(__p, "WaitForWebsheet");
    sub_10082841C(a1, (uint64_t)__p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    int v7 = 2;
  }
  else
  {
    int v8 = sub_1008284C4(a1);
    uint64_t v9 = a1 + 4 * a2;
    *(_DWORD *)(v9 + 24) = 1;
    uint64_t v6 = (int *)(v9 + 24);
    if (v8)
    {
      sub_10082C3BC(a1);
      *uint64_t v6 = 1;
      sub_100058DB0(__p, "WaitForWebsheetInfo");
      sub_10082841C(a1, (uint64_t)__p);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
      int v7 = 6;
    }
    else
    {
      sub_100828A34(a1);
      *uint64_t v6 = 1;
      sub_100058DB0(__p, "WaitForFetch");
      sub_10082841C(a1, (uint64_t)__p);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
      int v7 = 4;
    }
  }
  *uint64_t v6 = v7;
  return 1;
}

void sub_10082CCD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082CCF8(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1288])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082CE70(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_22DidGetSubscriptionInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_22DidGetSubscriptionInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082CF7C(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082CFB0()
{
  return 0;
}

void sub_10082CFB8(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  switch(*(_DWORD *)(a1 + 4))
  {
    case 0:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1818845510;
      int v2 = 1701999980;
      goto LABEL_4;
    case 1:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1667462483;
      int v2 = 1936942435;
LABEL_4:
      *(_DWORD *)((char *)&v5 + 3) = v2;
      break;
    case 2:
      HIBYTE(v7) = 10;
      LOWORD(v6) = 25972;
      uint64_t v5 = *(void **)"Incomplete";
      break;
    case 3:
      HIBYTE(v7) = 6;
      qmemcpy(&v5, "Cancel", 6);
      break;
    default:
      break;
  }
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&__p);
  if (v4 < 0) {
    operator delete(__p);
  }
  sub_100829794(a1);
  if (SHIBYTE(v7) < 0) {
    operator delete(v5);
  }
}

void sub_10082D0E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10082D128(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      char v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 88))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10082D1A8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082D1BC(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 208))(v8);
        sub_10004D2C8(v7);
        if (v9) {
          goto LABEL_15;
        }
      }
      else
      {
        sub_10004D2C8(v7);
      }
    }
  }
  if (sub_10082A7F8(a1) && sub_10082A88C(a1))
  {
    uint64_t v10 = a1 + 4 * a2;
    *(_DWORD *)(v10 + 24) = 3;
    *(_DWORD *)(a1 + 4) = 1;
    sub_10082D128(a1);
    *(_DWORD *)(v10 + 24) = 3;
LABEL_16:
    sub_10082CFB8(a1);
    *(_DWORD *)(v10 + 24) = 8;
    return 1;
  }
  int v11 = *(std::__shared_weak_count **)(a1 + 16);
  if (v11)
  {
    char v12 = std::__shared_weak_count::lock(v11);
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = *(void *)(a1 + 8);
      if (v14)
      {
        int v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 192))(v14);
        sub_10004D2C8(v13);
        if (v15)
        {
LABEL_15:
          uint64_t v10 = a1 + 4 * a2;
          *(_DWORD *)(a1 + 4) = 1;
          *(_DWORD *)(v10 + 24) = 3;
          goto LABEL_16;
        }
      }
      else
      {
        sub_10004D2C8(v13);
      }
    }
  }
  uint64_t v16 = a1 + 4 * a2;
  *(_DWORD *)(v16 + 24) = 3;
  char v17 = (_DWORD *)(v16 + 24);
  sub_100828A34(a1);
  *char v17 = 3;
  sub_100058DB0(__p, "WaitForFetch");
  sub_10082841C(a1, (uint64_t)__p);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  *char v17 = 4;
  return 1;
}

void sub_10082D380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10082D3B0(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1368])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082D528(uint64_t result, _WORD *a2, int a3)
{
  char v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_28DidFailToGetSubscriptionInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_28DidFailToGetSubscriptionInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082D634(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  char v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    char v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082D668()
{
  return 0;
}

uint64_t sub_10082D670(uint64_t a1, int a2, int a3)
{
  if (a3 != 3) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  if sub_10082A7F8(a1) && (sub_10082A88C(a1))
  {
    uint64_t v5 = a1 + 4 * a2;
    *(_DWORD *)(v5 + 24) = 3;
    uint64_t v6 = (_DWORD *)(v5 + 24);
    *(_DWORD *)(a1 + 4) = 0;
    sub_10082D128(a1);
    int v7 = *(_DWORD *)(a1 + 4);
    *uint64_t v6 = 3;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    switch(v7)
    {
      case 0:
        goto LABEL_7;
      case 1:
        HIBYTE(v15) = 7;
        LODWORD(v13) = 1667462483;
        int v8 = 1936942435;
        goto LABEL_8;
      case 2:
        HIBYTE(v15) = 10;
        LOWORD(v14) = 25972;
        uint64_t v13 = *(void **)"Incomplete";
        break;
      case 3:
        HIBYTE(v15) = 6;
        qmemcpy(&v13, "Cancel", 6);
        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v9 = a1 + 4 * a2;
    *(_DWORD *)(v9 + 24) = 3;
    uint64_t v6 = (_DWORD *)(v9 + 24);
    *(_DWORD *)(a1 + 4) = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
LABEL_7:
    HIBYTE(v15) = 7;
    LODWORD(v13) = 1818845510;
    int v8 = 1701999980;
LABEL_8:
    *(_DWORD *)((char *)&v13 + 3) = v8;
  }
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&__p);
  if (v12 < 0) {
    operator delete(__p);
  }
  sub_100829794(a1);
  if (SHIBYTE(v15) < 0) {
    operator delete(v13);
  }
  *uint64_t v6 = 8;
  return 1;
}

void sub_10082D820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082D868(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1448])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082D9E0(uint64_t result, _WORD *a2, int a3)
{
  char v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_12DidFailFetchEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_12DidFailFetchEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082DAEC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  char v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    char v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082DB20()
{
  return 0;
}

uint64_t sub_10082DB28(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  char v4 = v3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 216))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_10082DBA8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082DBBC(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  char v4 = (int *)(a1 + 4 * a2 + 24);
  if (sub_10082DB28(a1))
  {
    int *v4 = 4;
    *(_DWORD *)(a1 + 4) = 0;
    sub_10082B2C8(a1);
    int *v4 = 4;
    sub_100058DB0(__p, "WaitForFetch");
    sub_10082841C(a1, (uint64_t)__p);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
    int v5 = 4;
  }
  else
  {
    *(_DWORD *)(a1 + 4) = 0;
    int *v4 = 4;
    __p[1] = 0;
    uint64_t v10 = 0x700000000000000;
    strcpy((char *)__p, "Failure");
    std::operator+<char>();
    sub_10082841C(a1, (uint64_t)&v7);
    if (v8 < 0) {
      operator delete(v7);
    }
    sub_100829794(a1);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
    int v5 = 8;
  }
  int *v4 = v5;
  return 1;
}

void sub_10082DCFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082DD38(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1528])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082DEB0(uint64_t result, _WORD *a2, int a3)
{
  char v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_16DidFetchProfilesEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_16DidFetchProfilesEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082DFBC(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  char v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    char v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082DFF0()
{
  return 0;
}

void sub_10082DFF8(uint64_t a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  switch(*(_DWORD *)(a1 + 4))
  {
    case 0:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1818845510;
      int v2 = 1701999980;
      goto LABEL_4;
    case 1:
      HIBYTE(v7) = 7;
      LODWORD(v5) = 1667462483;
      int v2 = 1936942435;
LABEL_4:
      *(_DWORD *)((char *)&v5 + 3) = v2;
      break;
    case 2:
      HIBYTE(v7) = 10;
      LOWORD(v6) = 25972;
      uint64_t v5 = *(void **)"Incomplete";
      break;
    case 3:
      HIBYTE(v7) = 6;
      qmemcpy(&v5, "Cancel", 6);
      break;
    default:
      break;
  }
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&__p);
  if (v4 < 0) {
    operator delete(__p);
  }
  sub_100829794(a1);
  if (SHIBYTE(v7) < 0) {
    operator delete(v5);
  }
}

void sub_10082E120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082E168(uint64_t a1, int a2, int a3)
{
  if (a3 != 4) {
    __assert_rtn("execute", "state_machine.hpp", 445, "state == (current_state)");
  }
  if (!sub_10082DB28(a1))
  {
    if (sub_1008282F4(a1))
    {
      uint64_t v8 = a1 + 4 * a2;
      *(_DWORD *)(a1 + 4) = 1;
    }
    else
    {
      if (sub_10082A7F8(a1) && sub_10082A88C(a1))
      {
        uint64_t v9 = a1 + 4 * a2;
        *(_DWORD *)(v9 + 24) = 4;
        uint64_t v6 = (int *)(v9 + 24);
        sub_100828388(a1);
        *uint64_t v6 = 4;
        sub_100058DB0(__p, "WaitForSubscription");
        sub_10082841C(a1, (uint64_t)__p);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
        int v7 = 3;
        goto LABEL_6;
      }
      uint64_t v8 = a1 + 4 * a2;
      *(_DWORD *)(a1 + 4) = sub_10082A7F8(a1);
    }
    *(_DWORD *)(v8 + 24) = 4;
    sub_10082DFF8(a1);
    *(_DWORD *)(v8 + 24) = 8;
    return 1;
  }
  uint64_t v5 = a1 + 4 * a2;
  *(_DWORD *)(v5 + 24) = 4;
  uint64_t v6 = (int *)(v5 + 24);
  *(_DWORD *)(a1 + 4) = 1;
  sub_10082B2C8(a1);
  *uint64_t v6 = 4;
  sub_100058DB0(__p, "WaitForFetch");
  sub_10082841C(a1, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  int v7 = 4;
LABEL_6:
  *uint64_t v6 = v7;
  return 1;
}

void sub_10082E2D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082E2F0()
{
  return 0;
}

uint64_t sub_10082E2F8(uint64_t a1, int a2, int a3)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 6;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  sub_10082C164(a1);
  _DWORD *v5 = 6;
  sub_100058DB0(__p, "UserInWebsheet");
  sub_10082841C(a1, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  _DWORD *v5 = 7;
  return 1;
}

void sub_10082E39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10082E3B8()
{
  return 0;
}

uint64_t sub_10082E3C0(uint64_t a1, int a2, int a3)
{
  if (a3 != 6) {
    __assert_rtn("execute", "state_machine.hpp", 587, "state == (current_state)");
  }
  uint64_t v4 = a1 + 4 * a2;
  *(_DWORD *)(v4 + 24) = 6;
  uint64_t v5 = (_DWORD *)(v4 + 24);
  *(_DWORD *)(a1 + 4) = 0;
  v9[1] = 0;
  uint64_t v10 = 0x700000000000000;
  strcpy((char *)v9, "Failure");
  std::operator+<char>();
  sub_10082841C(a1, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
  sub_100829794(a1);
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
  _DWORD *v5 = 8;
  return 1;
}

void sub_10082E49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10082E4D4(void *a1)
{
  *a1 = off_101A0EF18;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10082E520(void *a1)
{
  *a1 = off_101A0EF18;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10082E58C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A0EF18;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10082E5F0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A0EF18;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10082E630(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10082E640(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10082E680(void *a1, unsigned __int8 *a2, long long *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v6 = *a2;
    uint64_t v7 = a1[1];
    char v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[2])
      {
        uint64_t v10 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11[0] = 67109120;
          v11[1] = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I websheet info result : %d", (uint8_t *)v11, 8u);
        }
        if (v6)
        {
          if (*(unsigned char *)(v7 + 408))
          {
            sub_1008270F0(v7 + 408, (uint64_t)a3);
          }
          else
          {
            sub_100827714((void *)(v7 + 416), a3);
            *(unsigned char *)(v7 + 408) = 1;
          }
          sub_10082E81C(*(void *)(v7 + 88), (uint64_t)v11, 1);
        }
        else
        {
          sub_10082EAD4(*(void *)(v7 + 88), (uint64_t)v11, 1);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_10082E7B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10082E7D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10082E810()
{
}

uint64_t sub_10082E81C(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1608])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082E994(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_18DidGetWebsheetInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_18DidGetWebsheetInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082EAA0(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

uint64_t sub_10082EAD4(uint64_t a1, uint64_t a2, char a3)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  *(unsigned char *)(a1 + 88) = 1;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))&byte_101B0D9F0[8 * *(_DWORD *)(a1 + 24) + 1688])(a1, 0);
  std::exception::~exception(&v7);
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    sub_100828214((uint64_t *)a1);
  }
  return v5;
}

uint64_t sub_10082EC4C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2) {
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machine"
                                        "IN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EER"
                                        "KNS9_24DidFailToGetWebsheetInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tINS_3msm4back11HandledEnumENS_4_mfi3mf2IS4_NS3_13state_machineIN8cellplan3fsm30RemoteProvisioningOperationFsmENS_9parameter5void_ESC_SC_SC_EERKNS9_24DidFailToGetWebsheetInfoEhEENS0_5list3INS0_5valueIPSD_EENSJ_ISE_EENSJ_IhEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

uint64_t sub_10082ED58(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))(*v5 + v4);
  }
  return v4(v5, v1 + 3, v3);
}

void sub_10082ED8C()
{
  if ((byte_101B0D9F0[0] & 1) == 0)
  {
    byte_101B0D9F0[0] = 1;
    qword_101B0DAD0 = (uint64_t)sub_1008282EC;
    unk_101B0DAD8 = sub_1008282EC;
    qword_101B0DAC0 = (uint64_t)sub_1008282EC;
    unk_101B0DAC8 = sub_1008282EC;
    qword_101B0DAB0 = (uint64_t)sub_1008282EC;
    unk_101B0DAB8 = sub_1008282EC;
    qword_101B0DAA0 = (uint64_t)sub_1008282EC;
    unk_101B0DAA8 = sub_1008282EC;
    qword_101B0DA98 = (uint64_t)sub_100828784;
  }
}

void sub_10082EDD8()
{
  if ((byte_101B0D9F8 & 1) == 0)
  {
    byte_101B0D9F8 = 1;
    qword_101B0DB20 = (uint64_t)sub_100828D80;
    unk_101B0DB28 = sub_100828D80;
    qword_101B0DB10 = (uint64_t)sub_100828D80;
    unk_101B0DB18 = sub_100828D80;
    qword_101B0DAF8 = (uint64_t)sub_100828D80;
    unk_101B0DB00 = sub_100828D80;
    qword_101B0DAE8 = (uint64_t)sub_100828D80;
    unk_101B0DAF0 = sub_100828D80;
    qword_101B0DB08 = (uint64_t)sub_100828D88;
  }
}

void sub_10082EE24()
{
  if ((byte_101B0DA00 & 1) == 0)
  {
    byte_101B0DA00 = 1;
    qword_101B0DB70 = (uint64_t)sub_100829204;
    unk_101B0DB78 = sub_100829204;
    qword_101B0DB60 = (uint64_t)sub_100829204;
    unk_101B0DB68 = sub_100829204;
    qword_101B0DB48 = (uint64_t)sub_100829204;
    unk_101B0DB50 = sub_100829204;
    qword_101B0DB38 = (uint64_t)sub_100829204;
    unk_101B0DB40 = sub_100829204;
    qword_101B0DB58 = (uint64_t)sub_10082920C;
  }
}

void sub_10082EE70()
{
  if ((byte_101B0DA08 & 1) == 0)
  {
    byte_101B0DA08 = 1;
    qword_101B0DBC8 = (uint64_t)sub_1008295B8;
    qword_101B0DBC0 = (uint64_t)sub_1008295C0;
    qword_101B0DBB8 = (uint64_t)sub_10082982C;
    qword_101B0DBB0 = (uint64_t)sub_100829890;
    qword_101B0DBA8 = (uint64_t)sub_100829AA8;
    qword_101B0DBA0 = (uint64_t)sub_100829B0C;
    qword_101B0DB98 = (uint64_t)sub_100829B70;
    qword_101B0DB90 = (uint64_t)sub_100829BD4;
    qword_101B0DB88 = (uint64_t)sub_100829C38;
  }
}

void sub_10082EF20()
{
  if ((byte_101B0DA10 & 1) == 0)
  {
    byte_101B0DA10 = 1;
    qword_101B0DC18 = (uint64_t)sub_100829F4C;
    qword_101B0DC08 = (uint64_t)sub_100829F4C;
    unk_101B0DC10 = sub_100829F4C;
    qword_101B0DBF0 = (uint64_t)sub_100829F4C;
    unk_101B0DBF8 = sub_100829F4C;
    qword_101B0DBE0 = (uint64_t)sub_100829F4C;
    unk_101B0DBE8 = sub_100829F4C;
    qword_101B0DBD8 = (uint64_t)sub_100829F4C;
    qword_101B0DC00 = (uint64_t)sub_100829F54;
  }
}

void sub_10082EF70()
{
  if ((byte_101B0DA18 & 1) == 0)
  {
    byte_101B0DA18 = 1;
    qword_101B0DC68 = (uint64_t)sub_10082A36C;
    qword_101B0DC60 = (uint64_t)sub_10082A36C;
    qword_101B0DC58 = (uint64_t)sub_10082A36C;
    qword_101B0DC48 = (uint64_t)sub_10082A36C;
    qword_101B0DC40 = (uint64_t)sub_10082A36C;
    qword_101B0DC38 = (uint64_t)sub_10082A36C;
    qword_101B0DC30 = (uint64_t)sub_10082A36C;
    qword_101B0DC28 = (uint64_t)sub_10082A36C;
    qword_101B0DC50 = (uint64_t)sub_10082A374;
  }
}

void sub_10082EFCC()
{
  if ((byte_101B0DA20 & 1) == 0)
  {
    byte_101B0DA20 = 1;
    qword_101B0DCB8 = (uint64_t)sub_10082A7F0;
    qword_101B0DCA8 = (uint64_t)sub_10082A7F0;
    qword_101B0DCA0 = (uint64_t)sub_10082A7F0;
    qword_101B0DC98 = (uint64_t)sub_10082A7F0;
    qword_101B0DC88 = (uint64_t)sub_10082A7F0;
    qword_101B0DC80 = (uint64_t)sub_10082A7F0;
    qword_101B0DC78 = (uint64_t)sub_10082A7F0;
    qword_101B0DCB0 = (uint64_t)sub_10082A920;
    qword_101B0DC90 = (uint64_t)sub_10082AB48;
  }
}

void sub_10082F034()
{
  if ((byte_101B0DA28 & 1) == 0)
  {
    byte_101B0DA28 = 1;
    qword_101B0DD08 = (uint64_t)sub_10082AE78;
    qword_101B0DCF8 = (uint64_t)sub_10082AE78;
    qword_101B0DCF0 = (uint64_t)sub_10082AE78;
    qword_101B0DCE8 = (uint64_t)sub_10082AE78;
    qword_101B0DCE0 = (uint64_t)sub_10082AE78;
    qword_101B0DCD8 = (uint64_t)sub_10082AE78;
    qword_101B0DCD0 = (uint64_t)sub_10082AE78;
    qword_101B0DCC8 = (uint64_t)sub_10082AE78;
    qword_101B0DD00 = (uint64_t)sub_10082AE80;
  }
}

void sub_10082F090()
{
  if ((byte_101B0DA30 & 1) == 0)
  {
    byte_101B0DA30 = 1;
    qword_101B0DD58 = (uint64_t)sub_10082B1F8;
    qword_101B0DD50 = (uint64_t)sub_10082B1F8;
    qword_101B0DD48 = (uint64_t)sub_10082B1F8;
    qword_101B0DD40 = (uint64_t)sub_10082B1F8;
    qword_101B0DD30 = (uint64_t)sub_10082B1F8;
    qword_101B0DD28 = (uint64_t)sub_10082B1F8;
    qword_101B0DD20 = (uint64_t)sub_10082B1F8;
    qword_101B0DD18 = (uint64_t)sub_10082B1F8;
    qword_101B0DD38 = (uint64_t)sub_10082B200;
  }
}

void sub_10082F0EC()
{
  if ((byte_101B0DA38 & 1) == 0)
  {
    byte_101B0DA38 = 1;
    qword_101B0DDA8 = (uint64_t)sub_10082B618;
    qword_101B0DD88 = (uint64_t)sub_10082B618;
    qword_101B0DD80 = (uint64_t)sub_10082B618;
    qword_101B0DD68 = (uint64_t)sub_10082B618;
    qword_101B0DDA0 = (uint64_t)sub_10082B620;
    qword_101B0DD98 = (uint64_t)sub_10082B7F4;
    qword_101B0DD90 = (uint64_t)sub_10082B858;
    qword_101B0DD78 = (uint64_t)sub_10082B944;
    qword_101B0DD70 = (uint64_t)sub_10082B9A8;
  }
}

void sub_10082F178()
{
  if ((byte_101B0DA40 & 1) == 0)
  {
    byte_101B0DA40 = 1;
    qword_101B0DDF8 = (uint64_t)sub_10082BD6C;
    qword_101B0DDE8 = (uint64_t)sub_10082BD6C;
    qword_101B0DDE0 = (uint64_t)sub_10082BD6C;
    qword_101B0DDD8 = (uint64_t)sub_10082BD6C;
    qword_101B0DDD0 = (uint64_t)sub_10082BD6C;
    qword_101B0DDC8 = (uint64_t)sub_10082BD6C;
    qword_101B0DDC0 = (uint64_t)sub_10082BD6C;
    qword_101B0DDB8 = (uint64_t)sub_10082BD6C;
    qword_101B0DDF0 = (uint64_t)sub_10082BD74;
  }
}

void sub_10082F1D4()
{
  if ((byte_101B0DA48 & 1) == 0)
  {
    byte_101B0DA48 = 1;
    qword_101B0DE48 = (uint64_t)sub_10082C0EC;
    qword_101B0DE40 = (uint64_t)sub_10082C0EC;
    qword_101B0DE38 = (uint64_t)sub_10082C0EC;
    qword_101B0DE30 = (uint64_t)sub_10082C0EC;
    qword_101B0DE28 = (uint64_t)sub_10082C0EC;
    qword_101B0DE20 = (uint64_t)sub_10082C0EC;
    qword_101B0DE10 = (uint64_t)sub_10082C0EC;
    qword_101B0DE08 = (uint64_t)sub_10082C0EC;
    qword_101B0DE18 = (uint64_t)sub_10082C1F8;
  }
}

void sub_10082F230()
{
  if ((byte_101B0DA50 & 1) == 0)
  {
    byte_101B0DA50 = 1;
    qword_101B0DE98 = (uint64_t)sub_10082C708;
    qword_101B0DE90 = (uint64_t)sub_10082C708;
    qword_101B0DE88 = (uint64_t)sub_10082C708;
    qword_101B0DE78 = (uint64_t)sub_10082C708;
    qword_101B0DE70 = (uint64_t)sub_10082C708;
    qword_101B0DE68 = (uint64_t)sub_10082C708;
    qword_101B0DE60 = (uint64_t)sub_10082C708;
    qword_101B0DE58 = (uint64_t)sub_10082C708;
    qword_101B0DE80 = (uint64_t)sub_10082C710;
  }
}

void sub_10082F28C()
{
  if ((byte_101B0DA58 & 1) == 0)
  {
    byte_101B0DA58 = 1;
    qword_101B0DEE8 = (uint64_t)sub_10082CB8C;
    qword_101B0DEE0 = (uint64_t)sub_10082CB8C;
    qword_101B0DED8 = (uint64_t)sub_10082CB8C;
    qword_101B0DED0 = (uint64_t)sub_10082CB8C;
    qword_101B0DEC8 = (uint64_t)sub_10082CB8C;
    qword_101B0DEC0 = (uint64_t)sub_10082CB8C;
    qword_101B0DEB8 = (uint64_t)sub_10082CB8C;
    qword_101B0DEA8 = (uint64_t)sub_10082CB8C;
    qword_101B0DEB0 = (uint64_t)sub_10082CB94;
  }
}

void sub_10082F2E8()
{
  if ((byte_101B0DA60 & 1) == 0)
  {
    byte_101B0DA60 = 1;
    qword_101B0DF38 = (uint64_t)sub_10082CFB0;
    qword_101B0DF30 = (uint64_t)sub_10082CFB0;
    qword_101B0DF28 = (uint64_t)sub_10082CFB0;
    qword_101B0DF20 = (uint64_t)sub_10082CFB0;
    qword_101B0DF18 = (uint64_t)sub_10082CFB0;
    qword_101B0DF08 = (uint64_t)sub_10082CFB0;
    qword_101B0DF00 = (uint64_t)sub_10082CFB0;
    qword_101B0DEF8 = (uint64_t)sub_10082CFB0;
    qword_101B0DF10 = (uint64_t)sub_10082D1BC;
  }
}

void sub_10082F344()
{
  if ((byte_101B0DA68 & 1) == 0)
  {
    byte_101B0DA68 = 1;
    qword_101B0DF88 = (uint64_t)sub_10082D668;
    qword_101B0DF80 = (uint64_t)sub_10082D668;
    qword_101B0DF78 = (uint64_t)sub_10082D668;
    qword_101B0DF70 = (uint64_t)sub_10082D668;
    qword_101B0DF68 = (uint64_t)sub_10082D668;
    qword_101B0DF58 = (uint64_t)sub_10082D668;
    qword_101B0DF50 = (uint64_t)sub_10082D668;
    qword_101B0DF48 = (uint64_t)sub_10082D668;
    qword_101B0DF60 = (uint64_t)sub_10082D670;
  }
}

void sub_10082F3A0()
{
  if ((byte_101B0DA70 & 1) == 0)
  {
    byte_101B0DA70 = 1;
    qword_101B0DFD8 = (uint64_t)sub_10082DB20;
    qword_101B0DFD0 = (uint64_t)sub_10082DB20;
    qword_101B0DFC8 = (uint64_t)sub_10082DB20;
    qword_101B0DFC0 = (uint64_t)sub_10082DB20;
    qword_101B0DFB0 = (uint64_t)sub_10082DB20;
    qword_101B0DFA8 = (uint64_t)sub_10082DB20;
    qword_101B0DFA0 = (uint64_t)sub_10082DB20;
    qword_101B0DF98 = (uint64_t)sub_10082DB20;
    qword_101B0DFB8 = (uint64_t)sub_10082DBBC;
  }
}

void sub_10082F3FC()
{
  if ((byte_101B0DA78 & 1) == 0)
  {
    byte_101B0DA78 = 1;
    qword_101B0E028 = (uint64_t)sub_10082DFF0;
    qword_101B0E020 = (uint64_t)sub_10082DFF0;
    qword_101B0E018 = (uint64_t)sub_10082DFF0;
    qword_101B0E010 = (uint64_t)sub_10082DFF0;
    qword_101B0E000 = (uint64_t)sub_10082DFF0;
    qword_101B0DFF8 = (uint64_t)sub_10082DFF0;
    qword_101B0DFF0 = (uint64_t)sub_10082DFF0;
    qword_101B0DFE8 = (uint64_t)sub_10082DFF0;
    qword_101B0E008 = (uint64_t)sub_10082E168;
  }
}

void sub_10082F458()
{
  if ((byte_101B0DA80 & 1) == 0)
  {
    byte_101B0DA80 = 1;
    qword_101B0E078 = (uint64_t)sub_10082E2F0;
    qword_101B0E070 = (uint64_t)sub_10082E2F0;
    qword_101B0E060 = (uint64_t)sub_10082E2F0;
    qword_101B0E058 = (uint64_t)sub_10082E2F0;
    qword_101B0E050 = (uint64_t)sub_10082E2F0;
    qword_101B0E048 = (uint64_t)sub_10082E2F0;
    qword_101B0E040 = (uint64_t)sub_10082E2F0;
    qword_101B0E038 = (uint64_t)sub_10082E2F0;
    qword_101B0E068 = (uint64_t)sub_10082E2F8;
  }
}

void sub_10082F4B4()
{
  if ((byte_101B0DA88 & 1) == 0)
  {
    byte_101B0DA88 = 1;
    qword_101B0E0C8 = (uint64_t)sub_10082E3B8;
    qword_101B0E0C0 = (uint64_t)sub_10082E3B8;
    qword_101B0E0B0 = (uint64_t)sub_10082E3B8;
    qword_101B0E0A8 = (uint64_t)sub_10082E3B8;
    qword_101B0E0A0 = (uint64_t)sub_10082E3B8;
    qword_101B0E098 = (uint64_t)sub_10082E3B8;
    qword_101B0E090 = (uint64_t)sub_10082E3B8;
    qword_101B0E088 = (uint64_t)sub_10082E3B8;
    qword_101B0E0B8 = (uint64_t)sub_10082E3C0;
  }
}

uint64_t *sub_10082F510(uint64_t a1)
{
  return sub_100C62630(a1, "kCDPSetWebsheetVisibility", (unint64_t)sub_10082F530, 3u);
}

void sub_10082F530(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  *(void *)long long buf = 4096;
  if (IsTelephonyRunningExtended(buf) && xpc_dictionary_get_value(*a4, "kCDPSetWebsheetVisibility"))
  {
    *(void *)long long buf = a4;
    char v25 = "kCDPSetWebsheetVisibility";
    sub_100048BAC((uint64_t)buf, &object);
    unsigned __int8 v7 = xpc::dyn_cast_or_default((xpc *)&object, 0, v6);
    xpc_release(object);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0E0E0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_101B0E0E0))
    {
      LogGroupName = (const char *)sGetLogGroupName();
      ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0E0D8, kCtLoggingSystemName, LogGroupName);
      __cxa_guard_release(&qword_101B0E0E0);
    }
    char v8 = qword_101B0E0D8;
    if (os_log_type_enabled((os_log_t)qword_101B0E0D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I XPC SetDataPlanWebSheetVisibility %d", buf, 8u);
    }
    if (qword_101B14190)
    {
      uint64_t v9 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v9)
      {
        uint64_t v10 = v9;
        if (!DataPlanManagerBootstrap::sInstance)
        {
LABEL_21:
          sub_10004D2C8(v10);
          return;
        }
        int v11 = v7;
        (*(void (**)(uint64_t, BOOL))(*(void *)DataPlanManagerBootstrap::sInstance + 72))(DataPlanManagerBootstrap::sInstance, v7 != 0);
        ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
        uint64_t v13 = ServiceMap;
        if (v14 < 0)
        {
          uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v16 = 5381;
          do
          {
            uint64_t v14 = v16;
            unsigned int v17 = *v15++;
            uint64_t v16 = (33 * v16) ^ v17;
          }
          while (v17);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v14;
        char v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
        if (v18)
        {
          uint64_t v20 = v18[3];
          uint64_t v19 = (std::__shared_weak_count *)v18[4];
          if (v19)
          {
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v13);
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v19);
            char v21 = 0;
            if (!v20)
            {
LABEL_19:
              if ((v21 & 1) == 0) {
                sub_10004D2C8(v19);
              }
              goto LABEL_21;
            }
LABEL_18:
            (*(void (**)(uint64_t, BOOL))(*(void *)v20 + 160))(v20, v11 != 0);
            goto LABEL_19;
          }
        }
        else
        {
          uint64_t v20 = 0;
        }
        std::mutex::unlock(v13);
        uint64_t v19 = 0;
        char v21 = 1;
        if (!v20) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
    }
  }
}

void sub_10082F7CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_10082F840()
{
  return sub_100C624B8((uint64_t)&unk_101B0E0D2, (uint64_t)sub_10082F510);
}

void sub_10082F85C(void **a1)
{
  *a1 = off_101A0F030;
  uint64_t v2 = (void ***)(a1 + 1);
  uint64_t v3 = a1 + 2;
  sub_100465E6C(&v3);
  sub_100110A40(v2, 0);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_10082F8CC(void **a1)
{
  sub_10082F85C(a1);

  operator delete();
}

uint64_t sub_10082F904(void *a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = (const PB::Data *)a1[1];
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  int v6 = (uint64_t *)a1[2];
  unsigned __int8 v7 = (uint64_t *)a1[3];
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "updatedSubscription");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10082F9B4(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      if ((v10 >> 3) == 2) {
        sub_100745204();
      }
      if (v19 == 1) {
        operator new();
      }
LABEL_24:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_20;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_10082FBD8(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  int v6 = *(const PB::Base ***)(v3 + 16);
  uint64_t v5 = *(const PB::Base ***)(v3 + 24);
  while (v6 != v5)
  {
    uint64_t v7 = *v6++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 2u);
  }
  return result;
}

uint64_t sub_10082FC38(uint64_t a1)
{
  *(_OWORD *)(a1 + 27) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 44) = 8;
  *(_DWORD *)(a1 + 76) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 80));
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = a1 + 240;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 255;
  *(_WORD *)(a1 + 260) = 0;
  *(_DWORD *)(a1 + 264) = -1;
  *(_OWORD *)(a1 + 268) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_DWORD *)(a1 + 312) = 1;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(void *)(a1 + 384) = 0;
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)(a1 + 392));
  *(unsigned char *)(a1 + 456) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  *(unsigned char *)(a1 + 472) = 0;
  *(unsigned char *)(a1 + 480) = 0;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 528) = 0;
  *(void *)(a1 + 520) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = a1 + 520;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 560) = 0;
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 536) = a1 + 544;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 568) = 0;
  *(unsigned char *)(a1 + 592) = 0;
  *(unsigned char *)(a1 + 600) = 0;
  return a1;
}

void sub_10082FD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  if (*(char *)(v10 + 391) < 0) {
    operator delete(*(void **)(v10 + 368));
  }
  char v17 = *(void **)(v10 + 344);
  if (v17)
  {
    *(void *)(v10 + 352) = v17;
    operator delete(v17);
  }
  if (*(char *)(v10 + 343) < 0) {
    operator delete(*v15);
  }
  uint64_t v18 = *(void *)(v10 + 304);
  *(void *)(v10 + 304) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = *(void *)(v10 + 296);
  *(void *)(v10 + 296) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  sub_10005CBF0(&a10);
  sub_1000346F8(v12, *v14);
  sub_100087E24(v11);
  if (*(char *)(v10 + 71) < 0) {
    operator delete(*v13);
  }
  uint64_t v20 = *(std::__shared_weak_count **)(v10 + 32);
  if (v20) {
    sub_10004D2C8(v20);
  }
  a10 = (void **)v10;
  sub_10005CBF0(&a10);
  _Unwind_Resume(a1);
}

void sub_10082FE4C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1000C6BDC(a2, a1 + 512);
  int v4 = *(void **)(a1 + 536);
  uint64_t v5 = (void *)(a1 + 544);
  if (v4 != v5)
  {
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v10 = 0;
      if (*((char *)v4 + 55) < 0)
      {
        sub_10004FC84(__p, (void *)v4[4], v4[5]);
      }
      else
      {
        *(_OWORD *)std::string __p = *((_OWORD *)v4 + 2);
        uint64_t v10 = v4[6];
      }
      sub_100046BAC((uint64_t **)a2, __p, (uint64_t)__p);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
      int v6 = (void *)v4[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          int v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v4[2];
          BOOL v8 = *v7 == (void)v4;
          int v4 = v7;
        }
        while (!v8);
      }
      int v4 = v7;
    }
    while (v7 != v5);
  }
}

void sub_10082FF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_10005CD2C(v14, *(char **)(v14 + 8));
  _Unwind_Resume(a1);
}

std::string *sub_10082FF60@<X0>(void *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  sub_100058DB0(a2, " dynamic [ ");
  int v4 = (void *)a1[67];
  if (v4 != a1 + 68)
  {
    do
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v27 = 0;
      if (*((char *)v4 + 55) < 0)
      {
        sub_10004FC84(__dst, (void *)v4[4], v4[5]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *((_OWORD *)v4 + 2);
        uint64_t v27 = v4[6];
      }
      if (v27 >= 0) {
        size_t v5 = HIBYTE(v27);
      }
      else {
        size_t v5 = (size_t)__dst[1];
      }
      std::string::size_type v24 = 0;
      uint64_t v25 = 0;
      std::string __p = 0;
      sub_1000C140C((uint64_t)&__p, v5 + 1);
      if (v25 >= 0) {
        p_p = (char *)&__p;
      }
      else {
        p_p = (char *)__p;
      }
      if (v5)
      {
        if (v27 >= 0) {
          uint64_t v7 = __dst;
        }
        else {
          uint64_t v7 = (void **)__dst[0];
        }
        memmove(p_p, v7, v5);
      }
      *(_WORD *)&p_p[v5] = 32;
      if (v25 >= 0) {
        BOOL v8 = (const std::string::value_type *)&__p;
      }
      else {
        BOOL v8 = (const std::string::value_type *)__p;
      }
      if (v25 >= 0) {
        std::string::size_type v9 = HIBYTE(v25);
      }
      else {
        std::string::size_type v9 = v24;
      }
      std::string::append(a2, v8, v9);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v27) < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v10 = (void *)v4[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v4[2];
          BOOL v12 = *v11 == (void)v4;
          int v4 = v11;
        }
        while (!v12);
      }
      int v4 = v11;
    }
    while (v11 != a1 + 68);
  }
  std::string::append(a2, "] bundle [ ", 0xBuLL);
  BOOL v13 = (void *)a1[64];
  uint64_t v14 = a1 + 65;
  if (v13 != a1 + 65)
  {
    do
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v27 = 0;
      if (*((char *)v13 + 55) < 0)
      {
        sub_10004FC84(__dst, (void *)v13[4], v13[5]);
      }
      else
      {
        *(_OWORD *)std::string __dst = *((_OWORD *)v13 + 2);
        uint64_t v27 = v13[6];
      }
      if (v27 >= 0) {
        size_t v15 = HIBYTE(v27);
      }
      else {
        size_t v15 = (size_t)__dst[1];
      }
      std::string::size_type v24 = 0;
      uint64_t v25 = 0;
      std::string __p = 0;
      sub_1000C140C((uint64_t)&__p, v15 + 1);
      if (v25 >= 0) {
        unint64_t v16 = (char *)&__p;
      }
      else {
        unint64_t v16 = (char *)__p;
      }
      if (v15)
      {
        if (v27 >= 0) {
          char v17 = __dst;
        }
        else {
          char v17 = (void **)__dst[0];
        }
        memmove(v16, v17, v15);
      }
      *(_WORD *)&v16[v15] = 32;
      if (v25 >= 0) {
        uint64_t v18 = (const std::string::value_type *)&__p;
      }
      else {
        uint64_t v18 = (const std::string::value_type *)__p;
      }
      if (v25 >= 0) {
        std::string::size_type v19 = HIBYTE(v25);
      }
      else {
        std::string::size_type v19 = v24;
      }
      std::string::append(a2, v18, v19);
      if (SHIBYTE(v25) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v27) < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v20 = (void *)v13[1];
      if (v20)
      {
        do
        {
          char v21 = v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          char v21 = (void *)v13[2];
          BOOL v12 = *v21 == (void)v13;
          BOOL v13 = v21;
        }
        while (!v12);
      }
      BOOL v13 = v21;
    }
    while (v21 != v14);
  }
  return std::string::append(a2, "]", 1uLL);
}

void sub_10083023C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 + 23) < 0) {
    operator delete(*(void **)v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100830298()
{
}

void sub_100830354(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  operator delete();
}

uint64_t sub_100830384(uint64_t a1)
{
  *(void *)a1 = off_101A0F080;
  [*(id *)(a1 + 32) dealloc];
  *(void *)(a1 + 32) = 0;
  unint64_t v2 = *(const void **)(a1 + 80);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 72);
  if (v3) {
    _Block_release(v3);
  }
  sub_100057D78((const void **)(a1 + 56));
  sub_1000558F4((const void **)(a1 + 40));
  int v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_10083041C(uint64_t a1)
{
  sub_100830384(a1);

  operator delete();
}

id sub_100830454(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) update:a2 withValue:a3];
}

const void **sub_10083046C(uint64_t a1, const void *a2)
{
  if (*(void *)(a1 + 32))
  {
    unint64_t v2 = *(void **)(a1 + 32);
    return (const void **)[v2 setBootstrapInformation:a2];
  }
  else
  {
    CFTypeRef v4 = a2;
    return sub_100282490((const void **)(a1 + 56), &v4);
  }
}

id sub_1008304C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [*(id *)(a1 + 32) sendMessageToDevice:a2 withName:a3 andValue:a4];
}

id sub_1008304D8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  id result = [*(id *)(a1 + 32) copyWatchDeviceID];
  *a2 = result;
  return result;
}

const void **sub_100830504(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v17 = 2080;
    uint64_t v18 = " ";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sStarted", buf, 0x16u);
  }
  BOOL v8 = [IDSClientDelegate alloc];
  sub_100083DA4(&v15, (const void **)(a1 + 40));
  *(void *)(a1 + 32) = [(IDSClientDelegate *)v8 initWithServiceName:v15 codeName:*(void *)(a1 + 48) localService:*(unsigned __int8 *)(a1 + 64) validate:*(void *)(a1 + 72) callback:a3 devices:*(void *)(a1 + 80) queue:a2 registry:a1 + 16];
  id result = sub_1000558F4(&v15);
  uint64_t v10 = (const void **)(a1 + 56);
  if (*(void *)(a1 + 56)) {
    uint64_t v11 = sub_100080778;
  }
  else {
    uint64_t v11 = 0;
  }
  if (v11)
  {
    BOOL v12 = *(void **)(a1 + 32);
    sub_100058198(&v14, v10);
    [v12 setBootstrapInformation:v14];
    sub_100057D78(&v14);
    BOOL v13 = *v10;
    *uint64_t v10 = 0;
    *(void *)long long buf = v13;
    return sub_100057D78((const void **)buf);
  }
  return result;
}

void sub_100830670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

id sub_1008306A0(uint64_t a1)
{
  return [*(id *)(a1 + 32) dumpState];
}

uint64_t sub_1008306A8(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t sub_1008306B0(uint64_t a1, void *a2, void *a3, uint64_t a4, char a5, const void *a6, const void *a7)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "ps.ids");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, (const OsLogContext *)buf);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v21);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  *(void *)a1 = off_101A0F080;
  *(void *)(a1 + 16) = *a2;
  uint64_t v14 = a2[1];
  *(void *)(a1 + 24) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 32) = 0;
  sub_100056210((void *)(a1 + 40), a3);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = a4;
  *(unsigned char *)(a1 + 64) = a5;
  if (a6) {
    size_t v15 = _Block_copy(a6);
  }
  else {
    size_t v15 = 0;
  }
  *(void *)(a1 + 72) = v15;
  if (a7) {
    unint64_t v16 = _Block_copy(a7);
  }
  else {
    unint64_t v16 = 0;
  }
  *(void *)(a1 + 80) = v16;
  __int16 v17 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = *(void *)(a1 + 48);
    id v19 = [a3 UTF8String];
    *(_DWORD *)long long buf = 136315650;
    uint64_t v23 = v18;
    __int16 v24 = 2080;
    uint64_t v25 = " ";
    __int16 v26 = 2080;
    id v27 = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sCreated a sync for service %s", buf, 0x20u);
  }
  return a1;
}

void sub_100830888(_Unwind_Exception *a1)
{
  int v6 = (const void *)v1[10];
  if (v6) {
    _Block_release(v6);
  }
  uint64_t v7 = (const void *)v1[9];
  if (v7) {
    _Block_release(v7);
  }
  sub_100057D78(v4);
  sub_1000558F4(v3);
  BOOL v8 = (std::__shared_weak_count *)v1[3];
  if (v8) {
    sub_10004D2C8(v8);
  }
  ctu::OsLogLogger::~OsLogLogger(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100830924(uint64_t a1, int a2, dispatch_object_t *a3, void *a4)
{
  uint64_t v7 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "cdp.dp");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_101A0F138;
  if (v7) {
    dispatch_release(v7);
  }
  *(void *)a1 = off_101A0F2A8;
  *(_DWORD *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *a4;
  uint64_t v8 = a4[1];
  *(void *)(a1 + 72) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 86) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(int64x2_t *)(a1 + 200) = vdupq_n_s64(0x8000000000000000);
  *(_WORD *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = ++dword_101B0A9E8;
  *(_DWORD *)(a1 + 160) = 0;
  std::string::size_type v9 = (char *)sub_10004EF74(a1 + 152, 5uLL);
  uint64_t v10 = *(char **)(a1 + 136);
  uint64_t v11 = *(char **)(a1 + 144);
  BOOL v13 = &v9[8 * v12];
  *((void *)v9 + 4) = 0;
  *(_OWORD *)std::string::size_type v9 = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  uint64_t v14 = v9 + 40;
  while (v11 != v10)
  {
    uint64_t v15 = *((void *)v11 - 1);
    v11 -= 8;
    *((void *)v9 - 1) = v15;
    v9 -= 8;
  }
  *(void *)(a1 + 136) = v9;
  *(void *)(a1 + 144) = v14;
  *(void *)(a1 + 152) = v13;
  if (v10) {
    operator delete(v10);
  }
  sub_100830BC0(a1);
  return a1;
}

void sub_100830B00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_100087E88(v2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  if (v3) {
    dispatch_release(v3);
  }
  _Unwind_Resume(a1);
}

void sub_100830BC0(uint64_t a1)
{
  unint64_t v2 = (char *)(a1 + 136);
  uint64_t v3 = *(char **)(a1 + 136);
  uint64_t v4 = *(void *)(a1 + 152);
  if ((unint64_t)(v4 - (void)v3) < 0x28)
  {
    if (v3)
    {
      *(void *)(a1 + 144) = v3;
      operator delete(v3);
      uint64_t v4 = 0;
      *(void *)unint64_t v2 = 0;
      *((void *)v2 + 1) = 0;
      *((void *)v2 + 2) = 0;
    }
    uint64_t v5 = v4 >> 2;
    if ((unint64_t)(v4 >> 2) <= 5) {
      uint64_t v5 = 5;
    }
    if ((unint64_t)v4 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v6 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v6 = v5;
    }
    sub_1004D669C(v2, v6);
    uint64_t v3 = *(char **)(a1 + 144);
    goto LABEL_15;
  }
  uint64_t v7 = *(char **)(a1 + 144);
  int64_t v8 = v7 - v3;
  if ((unint64_t)(v7 - v3) > 0x27)
  {
LABEL_15:
    *(_OWORD *)uint64_t v3 = xmmword_10150B108;
    *((_OWORD *)v3 + 1) = unk_10150B118;
    *((void *)v3 + 4) = 0x406E000000000000;
    size_t v10 = 40;
    goto LABEL_16;
  }
  std::string::size_type v9 = (char *)&xmmword_10150B108 + v8;
  if (v7 != v3)
  {
    memcpy(*(void **)(a1 + 136), &xmmword_10150B108, v7 - v3);
    uint64_t v3 = *(char **)(a1 + 144);
  }
  size_t v10 = 40 - v8;
  if (v9 != "21CellularPlanResponses") {
    memcpy(v3, v9, v10);
  }
LABEL_16:
  *(void *)(a1 + 144) = &v3[v10];
  *(_OWORD *)std::string __p = 0u;
  long long v14 = 0u;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 64) + 224))(__p);
  if (BYTE8(v14))
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Overriding Monitor Mode Timers", (uint8_t *)v12, 2u);
    }
    if (v2 != (char *)__p) {
      sub_1008356FC(v2, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 3);
    }
    if (BYTE8(v14))
    {
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100830D98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14)
{
  if (a14)
  {
    if (__p) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100830DBC(uint64_t a1)
{
  *(void *)a1 = off_101A0F2A8;
  sub_1009165A4((uint64_t *)(a1 + 80));
  uint64_t v2 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1009165A4((uint64_t *)(a1 + 224));
  uint64_t v3 = *(void **)(a1 + 168);
  if (v3)
  {
    *(void *)(a1 + 176) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 136);
  if (v4)
  {
    *(void *)(a1 + 144) = v4;
    operator delete(v4);
  }
  sub_100030068((const void **)(a1 + 120));
  uint64_t v5 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  unint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100830EB8(void *a1, int a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I DataPlan generating pdp failure parameters", buf, 2u);
  }
  uint64_t v5 = a1[23];
  uint64_t v6 = a1[21];
  a1[22] = v6;
  unint64_t v7 = v5 - v6;
  if (v7 >= 0x28)
  {
    *(void *)(v6 + 32) = 0;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    a1[22] = v6 + 40;
  }
  else
  {
    if (v7 >> 2 <= 5) {
      unint64_t v8 = 5;
    }
    else {
      unint64_t v8 = v7 >> 2;
    }
    std::string::size_type v9 = (char *)sub_10004EF74((uint64_t)(a1 + 23), v8);
    size_t v10 = (char *)a1[21];
    uint64_t v11 = (char *)a1[22];
    BOOL v13 = &v9[8 * v12];
    *((void *)v9 + 4) = 0;
    *(_OWORD *)std::string::size_type v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    long long v14 = v9 + 40;
    while (v11 != v10)
    {
      uint64_t v15 = *((void *)v11 - 1);
      v11 -= 8;
      *((void *)v9 - 1) = v15;
      v9 -= 8;
    }
    a1[21] = v9;
    a1[22] = v14;
    a1[23] = v13;
    if (v10) {
      operator delete(v10);
    }
  }
  uint64_t v16 = a1[21];
  *(void *)(v16 + 8) = 0;
  *(void *)(v16 + 16) = 0;
  *(void *)uint64_t v16 = a2;
  *(_OWORD *)(v16 + 24) = xmmword_1014FB930;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  *(_OWORD *)uint64_t v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_10004DE24((uint64_t)buf);
  sub_10004B96C(buf, (uint64_t)"Postponed Event = : ", 20);
  OsLogContext v17 = (void *)std::ostream::operator<<();
  sub_10004B96C(v17, (uint64_t)" count = ", 9);
  uint64_t v18 = (void *)std::ostream::operator<<();
  sub_10004B96C(v18, (uint64_t)" params = ", 10);
  unint64_t v19 = a1[21];
  while (v19 < a1[22])
  {
    std::ostream::operator<<();
    v19 += 8;
    if (v19 == a1[22]) {
      break;
    }
    sub_10004B96C(buf, (uint64_t)" ,", 2);
  }
  uint64_t v20 = a1[5];
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[8], __p);
    uint64_t v21 = v24 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uint64_t v42 = 136315138;
    unint64_t v43 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s", v42, 0xCu);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10083122C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void (__cdecl **a14)(std::stringbuf *__hidden this), uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  _Unwind_Resume(a1);
}

uint64_t sub_100831328(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 352))(a1);
  sub_1009165A4((uint64_t *)(a1 + 80));
  sub_100831414(a1, 0, 0);
  sub_100831720(a1, 0);
  *(unsigned char *)(a1 + 93) = 0;
  uint64_t v2 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1009165A4((uint64_t *)(a1 + 104));
  *(_DWORD *)(a1 + 112) = 0;
  uint64_t v3 = *(const void **)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  uint64_t v5 = v3;
  sub_100030068(&v5);
  sub_100830BC0(a1);
  atomic_store(0, (unsigned int *)(a1 + 236));
  *(unsigned char *)(a1 + 216) = 0;
  uint64_t result = sub_1009165A4((uint64_t *)(a1 + 224));
  *(void *)(a1 + 192) = 0;
  return result;
}

void sub_100831414(uint64_t a1, int a2, unsigned int a3)
{
  if (a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I calling plan expiry", (uint8_t *)&v20, 2u);
    }
    if (qword_101B14190)
    {
      uint64_t v6 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v6 && DataPlanManagerBootstrap::sInstance) {
        (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 136))();
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    if (*(unsigned char *)(a1 + 88))
    {
      size_t v10 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      if (*(unsigned char *)(a1 + 89)) {
        uint64_t v11 = "true";
      }
      else {
        uint64_t v11 = "false";
      }
      int v20 = 136315394;
      uint64_t v21 = "true";
      __int16 v22 = 2080;
      uint64_t v23 = v11;
      uint64_t v12 = "#I Attempt to enter NPW while already in it. CDP State npw=%s, mon=%s";
      BOOL v13 = v10;
      uint32_t v14 = 22;
    }
    else
    {
      *(unsigned char *)(a1 + 88) = 1;
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      int v17 = *(unsigned __int8 *)(a1 + 89);
      if (a3 > 6) {
        uint64_t v18 = "Data Plan Expiry Reason Undefined";
      }
      else {
        uint64_t v18 = off_101A0F5F0[a3];
      }
      unint64_t v19 = "true";
      int v20 = 136315650;
      uint64_t v21 = "true";
      __int16 v22 = 2080;
      if (!v17) {
        unint64_t v19 = "false";
      }
      uint64_t v23 = v19;
      __int16 v24 = 2080;
      uint64_t v25 = v18;
      uint64_t v12 = "#I Entered NPW. CDP State npw=%s, mon=%s, reason=%s";
      BOOL v13 = v16;
      uint32_t v14 = 32;
    }
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v20, v14);
LABEL_33:
    if (v6) {
      sub_10004D2C8(v6);
    }
    return;
  }
  if (*(unsigned char *)(a1 + 88))
  {
    *(unsigned char *)(a1 + 88) = 0;
    unint64_t v7 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    unint64_t v8 = "true";
    if (!*(unsigned char *)(a1 + 89)) {
      unint64_t v8 = "false";
    }
    int v20 = 136315394;
    uint64_t v21 = "false";
    __int16 v22 = 2080;
    uint64_t v23 = v8;
    std::string::size_type v9 = "#I Left NPW. CDP State npw=%s, mon=%s";
  }
  else
  {
    unint64_t v7 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v15 = "true";
    if (!*(unsigned char *)(a1 + 89)) {
      uint64_t v15 = "false";
    }
    int v20 = 136315394;
    uint64_t v21 = "false";
    __int16 v22 = 2080;
    uint64_t v23 = v15;
    std::string::size_type v9 = "#I Attempt to leave NPW while not in it. CDP State npw=%s, mon=%s";
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v20, 0x16u);
}

void sub_10083170C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100831720(uint64_t a1, int a2)
{
  sub_100831DB8(a1, 0);
  if (a2)
  {
    if (*(unsigned char *)(a1 + 89))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v5 = *(unsigned __int8 *)(a1 + 88);
      int v10 = 67109376;
      int v11 = v5;
      __int16 v12 = 1024;
      int v13 = 1;
      uint64_t v6 = "#I Attempt to enter Monitor Mode while already in it. CDP State npw=%d, mon=%d";
    }
    else
    {
      *(unsigned char *)(a1 + 89) = 1;
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v8 = *(unsigned __int8 *)(a1 + 88);
      int v10 = 67109376;
      int v11 = v8;
      __int16 v12 = 1024;
      int v13 = 1;
      uint64_t v6 = "#I Entered Monitor Mode.  CDP State npw=%d, mon=%d";
    }
  }
  else if (*(unsigned char *)(a1 + 89))
  {
    *(unsigned char *)(a1 + 89) = 0;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v7 = *(unsigned __int8 *)(a1 + 88);
    int v10 = 67109376;
    int v11 = v7;
    __int16 v12 = 1024;
    int v13 = 0;
    uint64_t v6 = "#I Left Monitor Mode. CDP State npw=%d, mon=%d";
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v9 = *(unsigned __int8 *)(a1 + 88);
    int v10 = 67109376;
    int v11 = v9;
    __int16 v12 = 1024;
    int v13 = 0;
    uint64_t v6 = "#I Attempt to leave Monitor Mode while not in it. CDP State npw=%d, mon=%d";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, 0xEu);
}

BOOL sub_1008318D8(uint64_t a1)
{
  return !*(unsigned char *)(a1 + 89) && *(unsigned char *)(a1 + 88) == 0;
}

uint64_t sub_1008318F8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 184))();
}

uint64_t sub_100831920(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 168);
  if ((unint64_t)(*(void *)(result + 176) - v1) >= 0x29
    && *(_DWORD *)(result + 160) == 51
    && *(void *)(v1 + 8) == 2
    && (*(unsigned char *)(v1 + 40) & 1) != 0)
  {
    return (*(uint64_t (**)(void))(**(void **)(result + 64) + 88))();
  }
  return result;
}

uint64_t sub_10083197C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 160);
}

void sub_100831984(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 89)) {
    sub_100831998(a1, 0);
  }
}

void sub_100831998(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 89)) {
    goto LABEL_46;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I _ExitMonitorMode called w/ wasSuccessful of %d", buf, 8u);
  }
  if (a2) {
    CFStringRef v5 = @"DATA-ACTIVATION?success=yes";
  }
  else {
    CFStringRef v5 = @"DATA-ACTIVATION?success=no";
  }
  uint64_t v24 = 0;
  *(_OWORD *)long long buf = 0u;
  long long v23 = 0u;
  NetworkNotification::NetworkNotification((NetworkNotification *)buf, v5);
  uint64_t v6 = (const void *)NetworkNotification::parsedNotification((NetworkNotification *)buf);
  if (*(void *)(a1 + 104))
  {
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Clearing Monitor Mode expiration timer", (uint8_t *)&v20, 2u);
    }
    sub_1009165A4((uint64_t *)(a1 + 104));
  }
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 64) + 24))(&v20);
  if (v21)
  {
    int v8 = std::__shared_weak_count::lock(v21);
    if (v8) {
      int v9 = v20;
    }
    else {
      int v9 = 0;
    }
    if (v21) {
      std::__shared_weak_count::__release_weak(v21);
    }
    if (v9) {
      (*(void (**)(const void *, uint64_t))(*(void *)v9 + 16))(v9, a2);
    }
  }
  else
  {
    int v8 = 0;
  }
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10)
  {
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I _ExitMonitorMode Clearing Monitor Mode timer", (uint8_t *)&v20, 2u);
      uint64_t v10 = *(void *)(a1 + 96);
      *(void *)(a1 + 96) = 0;
      if (!v10) {
        goto LABEL_26;
      }
    }
    else
    {
      *(void *)(a1 + 96) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
LABEL_26:
  sub_100831720(a1, 0);
  if (v6)
  {
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, v6, kCFPropertyListXMLFormat_v1_0, 0, 0);
    int v13 = *(const void **)(a1 + 120);
    *(void *)(a1 + 120) = Data;
    int v20 = v13;
    sub_100030068(&v20);
  }
  if (*(void *)(a1 + 120)) {
    uint32_t v14 = sub_10008324C;
  }
  else {
    uint32_t v14 = 0;
  }
  if (v14)
  {
    if (qword_101B14190)
    {
      uint64_t v15 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v15)
      {
        uint64_t v16 = v15;
        if (DataPlanManagerBootstrap::sInstance) {
          (*(void (**)(uint64_t))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 248))(DataPlanManagerBootstrap::sInstance + 8);
        }
        sub_10004D2C8(v16);
      }
    }
  }
  if (a2)
  {
    if (qword_101B14190)
    {
      int v17 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v17)
      {
        uint64_t v18 = v17;
        if (DataPlanManagerBootstrap::sInstance) {
          (*(void (**)(uint64_t))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 56))(DataPlanManagerBootstrap::sInstance + 8);
        }
        sub_10004D2C8(v18);
      }
    }
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  NetworkNotification::~NetworkNotification((NetworkNotification *)buf);
LABEL_46:
  sub_10079487C((uint64_t *)(a1 + 56), 169);
  *(void *)(a1 + 192) = 0;
  *(int64x2_t *)(a1 + 200) = vdupq_n_s64(0x8000000000000000);
  if ((a2 & 1) == 0 && *(unsigned char *)(a1 + 91))
  {
    unint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Re-instating the not-provisioned window after monitor mode failed", buf, 2u);
    }
    sub_1008326F4(a1);
  }
}

void sub_100831D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10004D2C8(v4);
  if (v3) {
    sub_10004D2C8(v3);
  }
  NetworkNotification::~NetworkNotification((NetworkNotification *)va);
  _Unwind_Resume(a1);
}

void sub_100831DB8(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 90) = a2;
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting allow next monitor mode activation to %d", (uint8_t *)v4, 8u);
  }
}

double sub_100831E58(uint64_t a1)
{
  return sub_100831E60(a1, 0);
}

double sub_100831E60(uint64_t a1, char a2)
{
  if (!*(unsigned char *)(a1 + 89))
  {
    *(unsigned char *)(a1 + 93) = a2;
    sub_100831720(a1, 1);
    *(_DWORD *)(a1 + 112) = 0;
    sub_100831FA4(a1, -1.0);
    if (!*(void *)(a1 + 104)) {
      operator new();
    }
    *(void *)(a1 + 192) = 0;
    *(int64x2_t *)(a1 + 200) = vdupq_n_s64(0x8000000000000000);
  }

  *(void *)&double result = sub_100832534(a1).u64[0];
  return result;
}

void sub_100831F60()
{
  if (v1) {
    _Block_release(v1);
  }
  if (v0) {
    dispatch_release(v0);
  }
  operator delete();
}

void sub_100831FA4(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4)
  {
    CFStringRef v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(double *)&uint8_t buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I scheduleMonitorModeTimer (interval %f) is Clearing Monitor Mode timer", buf, 0xCu);
      uint64_t v4 = *(void *)(a1 + 96);
      *(void *)(a1 + 96) = 0;
      if (!v4) {
        goto LABEL_7;
      }
    }
    else
    {
      *(void *)(a1 + 96) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
LABEL_7:
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(unsigned __int8 *)(a1 + 89);
    int v8 = *(_DWORD *)(a1 + 112);
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v7;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I scheduleMonitorModeTimer - monitor mode = %d, monitor mode time interval counter = %d", buf, 0xEu);
  }
  if (*(unsigned char *)(a1 + 89))
  {
    if (a2 == 0.0 || (int v9 = *(_DWORD *)(a1 + 112), v9 >= 9))
    {
      sub_100831998(a1, 0);
    }
    else
    {
      if (a2 == -1.0)
      {
        unsigned int v10 = v9 >= 4 ? 4 : *(_DWORD *)(a1 + 112);
        a2 = *(double *)(*(void *)(a1 + 136) + 8 * v10);
        int v11 = v9 + 1;
        *(_DWORD *)(a1 + 112) = v9 + 1;
        __int16 v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134218240;
          *(double *)&uint8_t buf[4] = a2;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v11;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Interval is %f, counter has been updated to [%d]", buf, 0x12u);
        }
      }
      *(double *)(a1 + 128) = a2;
      (*(void (**)(uint64_t))(*(void *)a1 + 376))(a1);
      sub_100831DB8(a1, 0);
      int v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = (uint64_t)a2;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I mm timer armed : %lld", buf, 0xCu);
      }
      sub_10003E168(buf, (void *)(a1 + 8));
      uint64_t v15 = *(void *)buf;
      uint32_t v14 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
      }
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1174405120;
      aBlock[2] = sub_1008328A4;
      aBlock[3] = &unk_101A0F470;
      aBlock[4] = a1;
      void aBlock[5] = v15;
      uint64_t v29 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 64) + 16))(&v25);
      Registry::getTimerService((uint64_t *)buf, v25);
      uint64_t v16 = *(void *)buf;
      sub_100058DB0(__p, "monitor mode timer");
      int v17 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v17;
      if (v17) {
        dispatch_retain(v17);
      }
      uint64_t v21 = _Block_copy(aBlock);
      sub_100118A44(v16, (uint64_t)__p, 1, 1000000 * (uint64_t)a2, &object, &v21);
      uint64_t v18 = v27;
      uint64_t v27 = 0;
      uint64_t v19 = *(void *)(a1 + 96);
      *(void *)(a1 + 96) = v18;
      if (v19)
      {
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        uint64_t v20 = v27;
        uint64_t v27 = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
        }
      }
      if (v21) {
        _Block_release(v21);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v26) {
        sub_10004D2C8(v26);
      }
      if (v29) {
        std::__shared_weak_count::__release_weak(v29);
      }
      if (v14) {
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
}

void sub_100832400(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, dispatch_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10083249C(id a1)
{
  if (qword_101B14190)
  {
    uint64_t v1 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v1)
    {
      uint64_t v2 = v1;
      if (DataPlanManagerBootstrap::sInstance) {
        (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 72))();
      }
      sub_10004D2C8(v2);
    }
  }
}

void sub_100832520(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

int64x2_t sub_100832534(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 80);
  if (*(void *)(a1 + 80))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Clearing not provisioned timer", (uint8_t *)&v7, 2u);
    }
    sub_1009165A4(v1);
    if (*(unsigned char *)(a1 + 88) && !*(unsigned char *)(a1 + 89))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        LODWORD(v7) = 134217984;
        *(CFAbsoluteTime *)((char *)&v7 + 4) = Current;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Closed the not-provisioned window at %f, resetting all interfaces as available again...", (uint8_t *)&v7, 0xCu);
      }
      long long v7 = 0uLL;
      (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 64) + 48))(&v7);
      if ((void)v7) {
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)v7 + 464))(v7, 1, 5);
      }
      if (*((void *)&v7 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v7 + 1));
      }
    }
    sub_100831414(a1, 0, 0);
    *(void *)(a1 + 192) = 0;
    int64x2_t result = vdupq_n_s64(0x8000000000000000);
    *(int64x2_t *)(a1 + 200) = result;
  }
  return result;
}

void sub_1008326D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008326F4(uint64_t result)
{
  if (!*(void *)(result + 80))
  {
    sub_10083411C(result);
    operator new();
  }
  return result;
}

void sub_100832848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008328A4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFStringRef v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I mm callback", v8, 2u);
        }
        (*(void (**)(uint64_t, double))(*(void *)v3 + 360))(v3, *(double *)(v3 + 128));
        uint64_t v7 = *(void *)(v3 + 96);
        *(void *)(v3 + 96) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10083299C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1008329B0(double *a1)
{
  return (*(uint64_t (**)(double))(*(void *)a1 + 360))(a1[16]);
}

uint64_t sub_1008329E0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008329FC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

const void **sub_100832A10@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  return sub_10002FD9C(a2, (const void **)(a1 + 120));
}

void sub_100832A1C(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I last subscribed error set to %d", (uint8_t *)v5, 8u);
  }
  atomic_store(a2, (unsigned int *)(a1 + 236));
}

BOOL sub_100832ACC(uint64_t a1)
{
  unsigned int v1 = atomic_load((unsigned int *)(a1 + 236));
  return v1 != 0;
}

double sub_100832AE0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88) && !*(unsigned char *)(a1 + 91))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Will exit NPW due to Throttle Timer", v4, 2u);
    }
    *(void *)&double result = sub_100832534(a1).u64[0];
  }
  return result;
}

uint64_t sub_100832B5C(uint64_t result, int a2)
{
  if (a2 == 1)
  {
    uint64_t v7 = v2;
    uint64_t v8 = v3;
    uint64_t v4 = result;
    CFStringRef v5 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I got a sim not inserted event", v6, 2u);
    }
    return sub_100831328(v4);
  }
  return result;
}

uint64_t sub_100832BD4(uint64_t a1, CFPropertyListRef *a2)
{
  CFDictionaryRef v3 = (const __CFDictionary *)*a2;
  if (*a2) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, *a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
    CFDataRef theData = Data;
    if (Data) {
      uint64_t v6 = sub_10008324C;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      CFIndex Length = CFDataGetLength(Data);
      if (Length >= 1025)
      {
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = Length;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#E Got a data plan notification that is longer than maximum allowed size (%lu). Truncating, hope that's OK!", (uint8_t *)&buf, 0xCu);
        }
        long long buf = 0uLL;
        *(void *)&long long v72 = 0;
        sub_10011FDF0((unint64_t *)&buf, 0x3FFuLL);
        v87.location = 0;
        v87.length = 1023;
        CFDataGetBytes(theData, v87, (UInt8 *)buf);
        CFDataRef v9 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)buf, 1023);
        CFDataRef v10 = theData;
        CFDataRef theData = v9;
        *(void *)&long long v62 = v10;
        sub_100030068((const void **)&v62);
        if (theData) {
          int v11 = sub_10008324C;
        }
        else {
          int v11 = 0;
        }
        if (!v11)
        {
          long long v32 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v62) = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#E Unable to truncate notification data, bailing", (uint8_t *)&v62, 2u);
          }
          if ((void)buf)
          {
            *((void *)&buf + 1) = buf;
            operator delete((void *)buf);
          }
          goto LABEL_88;
        }
        if ((void)buf)
        {
          *((void *)&buf + 1) = buf;
          operator delete((void *)buf);
        }
      }
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v3, kCTCellularDataPlanStatusTypeKey);
      CFStringRef v13 = Value;
      if (Value)
      {
        long long v85 = 0u;
        long long v86 = 0u;
        long long v83 = 0u;
        long long v84 = 0u;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        long long buf = 0u;
        long long v72 = 0u;
        CFStringGetCString(Value, (char *)&buf, 256, 0x8000100u);
        uint64_t v15 = (os_log_t *)(a1 + 40);
        uint32_t v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v62) = 136315138;
          *(void *)((char *)&v62 + 4) = &buf;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Received a data plan notification with type: %s", (uint8_t *)&v62, 0xCu);
        }
        int v17 = (const void **)(a1 + 120);
        uint64_t v16 = *(void *)(a1 + 120);
        *(void *)(a1 + 120) = 0;
        *(void *)&long long v62 = v16;
        sub_100030068((const void **)&v62);
        if (CFEqual(v13, kCTCellularDataPlanActivationStatus))
        {
          CFBooleanRef v18 = (const __CFBoolean *)CFDictionaryGetValue(v3, kCTCellularDataPlanActivationSuccessKey);
          CFStringRef v19 = (const __CFString *)CFDictionaryGetValue(v3, kCTCellularDataPlanMsisdnKey);
          CFStringRef v20 = v19;
          if (!v19 || (CFTypeID v21 = CFGetTypeID(v19), v21 != CFStringGetTypeID()))
          {
            CFBooleanRef v22 = kCFBooleanTrue;
            BOOL v23 = v18 == kCFBooleanTrue;
            goto LABEL_34;
          }
          CFBooleanRef v22 = kCFBooleanTrue;
          if (v18 != kCFBooleanTrue)
          {
            BOOL v23 = 0;
            goto LABEL_34;
          }
          memset(buffer, 0, sizeof(buffer));
          if (!CFStringGetCString(v20, (char *)buffer, 64, 0x8000100u))
          {
LABEL_108:
            BOOL v23 = 1;
            CFBooleanRef v22 = v18;
LABEL_34:
            if (*(unsigned char *)(a1 + 89) || *(unsigned char *)(a1 + 88))
            {
              uint64_t v27 = *v15;
              if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v62) = 0;
                _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Consuming data plan activation message", (uint8_t *)&v62, 2u);
              }
              if (v23)
              {
                sub_1003C5CD0((const void **)(a1 + 120), (const void **)&theData);
                *(_DWORD *)(a1 + 112) = 0;
                long long v28 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v62) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Got a data plan activation successful notification; ending monitor mode",
                    (uint8_t *)&v62,
                    2u);
                }
                double v29 = 0.001;
                if (*(unsigned char *)(a1 + 88)) {
                  sub_100831E60(a1, 0);
                }
              }
              else
              {
                long long v33 = *v15;
                double v29 = 0.0;
                if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v62) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Got a data plan activation failure notification; exiting monitor mode",
                    (uint8_t *)&v62,
                    2u);
                }
              }
              sub_100831FA4(a1, v29);
              if (qword_101B14190)
              {
                long long v34 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
                if (v34
                  && DataPlanManagerBootstrap::sInstance
                  && (*(unsigned int (**)(uint64_t))(*(void *)(DataPlanManagerBootstrap::sInstance + 8)
                                                             + 80))(DataPlanManagerBootstrap::sInstance + 8))
                {
                  *(unsigned char *)(a1 + 216) = 1;
LABEL_60:
                  sub_10004D2C8(v34);
LABEL_81:
                  operator new();
                }
              }
              else
              {
                long long v34 = 0;
              }
              (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64), a1 + 40);
              if (!v34) {
                goto LABEL_81;
              }
              goto LABEL_60;
            }
            CFBooleanRef v36 = (const __CFBoolean *)CFDictionaryGetValue(v3, kCTCellularDataPlanStackingKey);
            CFBooleanRef v37 = v36;
            if (v36 && (CFTypeID v38 = CFGetTypeID(v36), v38 == CFBooleanGetTypeID()) && v37 == v22)
            {
              sub_1003C5CD0(v17, (const void **)&theData);
              long long v30 = *v15;
              if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_81;
              }
              LOWORD(v62) = 0;
              long long v31 = "#I Got a data plan stacking notification.";
            }
            else
            {
              long long v30 = *v15;
              if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_81;
              }
              LOWORD(v62) = 0;
              long long v31 = "#I Got a data plan activation notification but not in monitor or NPW mode. Ignoring it.";
            }
LABEL_80:
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, (uint8_t *)&v62, 2u);
            goto LABEL_81;
          }
          *(void *)long long v58 = 0;
          uint64_t v59 = 0;
          uint64_t v60 = 0;
          sub_100058DB0(v58, (char *)buffer);
          long long v39 = *v15;
          if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v62) = 0;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Data Plan Phone Number Received: Device is in cdma core, not writing to the phone book", (uint8_t *)&v62, 2u);
          }
          (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 64) + 16))(&v56);
          ServiceMap = (std::mutex *)Registry::getServiceMap(v56);
          uint64_t v41 = ServiceMap;
          if (v42 < 0)
          {
            unint64_t v43 = (unsigned __int8 *)(v42 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v44 = 5381;
            do
            {
              uint64_t v42 = v44;
              unsigned int v45 = *v43++;
              uint64_t v44 = (33 * v44) ^ v45;
            }
            while (v45);
          }
          std::mutex::lock(ServiceMap);
          *(void *)&long long v62 = v42;
          uint64_t v46 = sub_10004D37C(&v41[1].__m_.__sig, (unint64_t *)&v62);
          if (v46)
          {
            uint64_t v47 = v46[3];
            uint64_t v48 = (std::__shared_weak_count *)v46[4];
            if (v48)
            {
              atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v41);
              atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v49 = v48;
              sub_10004D2C8(v48);
              char v50 = 0;
LABEL_92:
              sub_100058DB0(v54, "My Number");
              CSIPhoneNumber::CSIPhoneNumber();
              (*(void (**)(uint64_t, uint64_t, void **, long long *))(*(void *)v47 + 272))(v47, 1, v54, &v62);
              if (v69 < 0) {
                operator delete(__p);
              }
              if (v67 < 0) {
                operator delete(v66);
              }
              if (v65 < 0) {
                operator delete(v64);
              }
              if (v63 < 0) {
                operator delete(*((void **)&v62 + 1));
              }
              if (v55 < 0) {
                operator delete(v54[0]);
              }
              if ((v50 & 1) == 0) {
                sub_10004D2C8(v49);
              }
              if (v57) {
                sub_10004D2C8(v57);
              }
              if (SHIBYTE(v60) < 0) {
                operator delete(*(void **)v58);
              }
              goto LABEL_108;
            }
          }
          else
          {
            uint64_t v47 = 0;
          }
          std::mutex::unlock(v41);
          uint64_t v49 = 0;
          char v50 = 1;
          goto LABEL_92;
        }
        if (CFEqual(v13, kCTCellularDataPlanUsageStatus))
        {
          sub_1003C5CD0((const void **)(a1 + 120), (const void **)&theData);
          long long v30 = *v15;
          if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_81;
          }
          LOWORD(v62) = 0;
          long long v31 = "#I Got a data plan usage update notification.";
          goto LABEL_80;
        }
        long long v35 = *v15;
        if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v62) = 0;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Got a data plan notification of unknown type. Ignoring it.", (uint8_t *)&v62, 2u);
        }
        if (!*v17)
        {
          CFDataRef v51 = theData;
          if (theData ? sub_10008324C : 0)
          {
            CFDataRef theData = 0;
            *(void *)&long long v62 = v51;
            sub_100030068((const void **)&v62);
          }
        }
        goto LABEL_88;
      }
      uint64_t v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        long long v26 = "#E Got a data plan notification that does not contain a valid type";
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        long long v26 = "#E Could not get notification data, bailing";
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v26, (uint8_t *)&buf, 2u);
      }
    }
LABEL_88:
    sub_100030068((const void **)&theData);
    return 0;
  }
  char v24 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#E sms notification dictionary is empty", (uint8_t *)&buf, 2u);
  }
  return 0;
}

void sub_100833B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54)
{
  sub_100087E24((uint64_t)&a25);
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v55 & 1) == 0) {
    sub_10004D2C8(v54);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_100030068(&a24);
  _Unwind_Resume(a1);
}

void sub_100833CF4(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    if (*(unsigned char *)(a1 + 216)) {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64), a1 + 40);
    }
    if (*(unsigned char *)(a1 + 92))
    {
      CFDictionaryRef v3 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Internet context is up for provisioning deactivating", v4, 2u);
      }
      *(unsigned char *)(a1 + 92) = 0;
      sub_100833DB0(a1, 0, 0);
    }
  }
  *(unsigned char *)(a1 + 216) = 0;
}

void sub_100833DB0(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v22 = 0;
  BOOL v23 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 64) + 48))(&v22);
  uint64_t v6 = v22;
  if (!v22) {
    goto LABEL_20;
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 776))(v22);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 336))(v6, v7, 1);
    uint64_t v6 = v22;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 776))(v6);
  int v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 952))(v6, v8, 6);
  uint64_t v10 = v22;
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 776))(v22);
  int v12 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v10 + 952))(v10, v11, 0);
  if (qword_101B14190)
  {
    CFStringRef v13 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v13 && DataPlanManagerBootstrap::sInstance)
    {
      int v14 = (*(uint64_t (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 80))();
      int v15 = v9 == v12 ? v14 : 0;
      if (v15 == 1 && !*(unsigned char *)(a1 + 89))
      {
        uint64_t v16 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Websheet is visible not taking down internet context", buf, 2u);
        }
        *(unsigned char *)(a1 + 92) = 1;
LABEL_19:
        sub_10004D2C8(v13);
        goto LABEL_20;
      }
    }
  }
  else
  {
    CFStringRef v13 = 0;
  }
  uint64_t v17 = v22;
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 776))(v22);
  sub_100058DB0(__p, "Due to Cellular Data Plan");
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v17 + 80))(v17, v18, 1, a2, __p, 0, 0);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  if (v13) {
    goto LABEL_19;
  }
LABEL_20:
  if (v23) {
    sub_10004D2C8(v23);
  }
}

void sub_1008340D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(exception_object);
}

double sub_10083411C(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 232))(*(void *)(a1 + 64));
  if (!v3) {
    return 600.0;
  }
  uint64_t v4 = v2;
  double v5 = *(double *)&v2;
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 134217984;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Not Provisioned Window value is overriden: %f", (uint8_t *)&v8, 0xCu);
  }
  return v5;
}

void sub_100834208(id a1)
{
  if (qword_101B14190)
  {
    unsigned int v1 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v1)
    {
      uint64_t v2 = v1;
      if (DataPlanManagerBootstrap::sInstance) {
        (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 64))();
      }
      sub_10004D2C8(v2);
    }
  }
}

void sub_10083428C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008342A0()
{
  if (qword_101B14190)
  {
    v0 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v0)
    {
      unsigned int v1 = v0;
      if (DataPlanManagerBootstrap::sInstance) {
        (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 48))();
      }
      sub_10004D2C8(v1);
    }
  }
}

void sub_100834324(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100834338(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    sub_100832534(a1);
    if (*(unsigned char *)(a1 + 91))
    {
      uint64_t v2 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v3 = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Re-enter not-provisioned window since we are not allowed to exit in this state", v3, 2u);
      }
      sub_1008326F4(a1);
    }
  }
}

uint64_t sub_1008343BC(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 56);
  if (v4 != a2 && a2 != 0 && v4 != 0) {
    double result = __TUAssertTrigger();
  }
  *(void *)(v3 + 56) = a2;
  return result;
}

void sub_100834404(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  sub_100058DB0(__p, "Due to Cellular Data Plan");
  (*(void (**)(uint64_t, uint64_t, void **, uint64_t))(*(void *)v1 + 104))(v1, 1, __p, 1);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100834480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10083449C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)long long v30 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Data Plan Type:%d", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(a1 + 88);
    int v5 = *(unsigned __int8 *)(a1 + 91);
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)long long v30 = v4;
    *(_WORD *)&v30[4] = 1024;
    *(_DWORD *)&v30[6] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fInNotProvisionedWindow:%d, fStayInNPWAfterProvisioningFailure:%d", buf, 0xEu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "true";
    if (*(unsigned char *)(a1 + 89)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    if (*(unsigned char *)(a1 + 90)) {
      int v8 = "true";
    }
    else {
      int v8 = "false";
    }
    uint64_t v9 = *(void *)(a1 + 128);
    if (!*(unsigned char *)(a1 + 93)) {
      uint64_t v6 = "false";
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)long long v30 = v7;
    *(_WORD *)&v30[8] = 2080;
    long long v31 = v8;
    *(_WORD *)long long v32 = 2048;
    *(void *)&v32[2] = v9;
    *(_WORD *)long long v33 = 2080;
    *(void *)&v33[2] = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fInMonitorMode:%s, fStateAllowNextActivationInMonitorMode:%s, fMMTimerInterval:%f, fHaveResetBaseband:%s", buf, 0x2Au);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v10 = atomic_load((unsigned int *)(a1 + 236));
    int v12 = *(_DWORD *)(a1 + 192);
    int v11 = *(_DWORD *)(a1 + 196);
    (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 64) + 16))(&v25);
    Registry::getTimerService((uint64_t *)&v27, v25);
    uint64_t v13 = (**v27)(v27);
    uint64_t v14 = *(void *)(a1 + 200);
    (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 64) + 16))(&v21);
    Registry::getTimerService((uint64_t *)&v23, v21);
    uint64_t v15 = (**v23)(v23);
    int v16 = *(unsigned __int8 *)(a1 + 216);
    uint64_t v17 = v15 - *(void *)(a1 + 208);
    int v18 = *(_DWORD *)(a1 + 232);
    *(_DWORD *)long long buf = 67110658;
    *(_DWORD *)long long v30 = v10;
    *(_WORD *)&v30[4] = 1024;
    *(_DWORD *)&v30[6] = v12;
    LOWORD(v31) = 1024;
    *(_DWORD *)((char *)&v31 + 2) = v11;
    HIWORD(v31) = 2048;
    *(void *)long long v32 = (v13 - v14) / 1000000000;
    *(_WORD *)&uint8_t v32[8] = 2048;
    *(void *)long long v33 = v17 / 1000000000;
    *(_WORD *)&uint8_t v33[8] = 2080;
    if (v16) {
      CFStringRef v19 = "true";
    }
    else {
      CFStringRef v19 = "false";
    }
    long long v34 = v19;
    __int16 v35 = 1024;
    int v36 = v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fLastSubscribedError:%d, fPDPDisconnectCount: v4:%d v6:%d, fPDPDisconnectTimestamp: v4:%lld v6:%lld, fDataActivationSMSReceived:%s, fUniqueId:%d", buf, 0x38u);
    if (v24) {
      sub_10004D2C8(v24);
    }
    if (v22) {
      sub_10004D2C8(v22);
    }
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v26) {
      sub_10004D2C8(v26);
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 368))(a1);
}

void sub_10083485C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008348C0()
{
  return 0;
}

void sub_1008348C8(uint64_t a1, unsigned __int8 **a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I PCO: got update", buf, 2u);
  }
  if (!*(unsigned char *)(a1 + 88))
  {
    int v66 = 0;
    (*(void (**)(ctu **__return_ptr))(**(void **)(a1 + 64) + 240))(&v66);
    xpc_object_t v65 = 0;
    ctu::cf_to_xpc((uint64_t *)buf, v66, v7);
    int v8 = *(void **)buf;
    xpc_object_t v65 = *(xpc_object_t *)buf;
    if (*(void *)buf && xpc_get_type(*(xpc_object_t *)buf) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v65 = xpc_null_create();
    }
    xpc_release(*(xpc_object_t *)buf);
    if (xpc_get_type(v65) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc::object::to_string((uint64_t *)buf, (xpc::object *)&v65);
      if ((SBYTE7(v47[0]) & 0x80u) == 0) {
        uint64_t v11 = BYTE7(v47[0]);
      }
      else {
        uint64_t v11 = *(void *)&buf[8];
      }
      if (SBYTE7(v47[0]) < 0) {
        operator delete(*(void **)buf);
      }
      if (v11)
      {
        int v12 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          xpc::object::to_string((uint64_t *)buf, (xpc::object *)&v65);
          uint64_t v13 = (SBYTE7(v47[0]) & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I PCO: read data: %s", (uint8_t *)&v70, 0xCu);
          if (SBYTE7(v47[0]) < 0) {
            operator delete(*(void **)buf);
          }
        }
      }
    }
    if (xpc_get_type(v65) != (xpc_type_t)&_xpc_type_dictionary || !a3 || a2[1] == *a2) {
      goto LABEL_104;
    }
    *(void *)long long buf = &v65;
    *(void *)&uint8_t buf[8] = "ContainerId";
    sub_100048BAC((uint64_t)buf, &v70);
    unsigned __int16 v10 = xpc::dyn_cast_or_default((xpc *)&v70, 0, v9);
    xpc_release((xpc_object_t)v70);
    xpc_object_t v64 = 0;
    *(void *)long long buf = &v65;
    *(void *)&uint8_t buf[8] = "ExpiredValues";
    sub_10005107C((uint64_t)buf, &v64);
    long long v70 = 0uLL;
    uint64_t v71 = 0;
    *(void *)long long buf = v64;
    if (v64) {
      xpc_retain(v64);
    }
    else {
      *(void *)long long buf = xpc_null_create();
    }
    sub_100048BF4(&v62, (void **)buf, 0);
    xpc_release(*(xpc_object_t *)buf);
    *(void *)long long buf = v64;
    if (v64) {
      xpc_retain(v64);
    }
    else {
      *(void *)long long buf = xpc_null_create();
    }
    if (xpc_get_type(v64) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v64);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v61, (void **)buf, count);
    xpc_release(*(xpc_object_t *)buf);
    v69.__r_.__value_.__r.__words[0] = (std::string::size_type)&v70;
    for (uint64_t i = v63; i != v61[1] || v62 != v61[0]; uint64_t i = ++v63)
    {
      *(void *)long long buf = &v62;
      *(void *)&uint8_t buf[8] = i;
      sub_1000492E0((uint64_t)buf, v68);
      char v67 = xpc::dyn_cast_or_default((xpc *)v68, 0, v16);
      sub_100240714((unint64_t **)&v69, &v67);
      xpc_release(*(xpc_object_t *)v68);
    }
    xpc_release(v62);
    v61[0] = 0;
    xpc_release(v62);
    long long v62 = 0;
    uint64_t v60 = 0;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v49 = 0u;
    memset(v47, 0, sizeof(v47));
    *(_OWORD *)long long buf = 0u;
    sub_10004BD84((uint64_t)buf);
    sub_10004B96C(v47, (uint64_t)"cbdata-> containerid: ", 22);
    uint64_t v17 = (void *)std::ostream::operator<<();
    sub_10004B96C(v17, (uint64_t)", values: ", 10);
    CFStringRef v19 = (unsigned __int8 *)*((void *)&v70 + 1);
    for (uint64_t j = (unsigned __int8 *)v70; j != v19; ++j)
    {
      std::to_string(&v69, *j);
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v20 = &v69;
      }
      else {
        char v20 = (std::string *)v69.__r_.__value_.__r.__words[0];
      }
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v69.__r_.__value_.__l.__size_;
      }
      uint64_t v22 = sub_10004B96C(v47, (uint64_t)v20, size);
      sub_10004B96C(v22, (uint64_t)" ", 1);
      if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v69.__r_.__value_.__l.__data_);
      }
    }
    sub_10004B96C(v47, (uint64_t)", received data-> containerid: ", 31);
    BOOL v23 = (void *)std::ostream::operator<<();
    sub_10004B96C(v23, (uint64_t)", values: ", 10);
    char v24 = *a2;
    uint64_t v25 = a2[1];
    if (*a2 != v25)
    {
      do
      {
        std::to_string(&v69, *v24);
        if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          long long v26 = &v69;
        }
        else {
          long long v26 = (std::string *)v69.__r_.__value_.__r.__words[0];
        }
        if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v27 = HIBYTE(v69.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v27 = v69.__r_.__value_.__l.__size_;
        }
        long long v28 = sub_10004B96C(v47, (uint64_t)v26, v27);
        sub_10004B96C(v28, (uint64_t)" ", 1);
        if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v69.__r_.__value_.__l.__data_);
        }
        ++v24;
      }
      while (v24 != v25);
    }
    double v29 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004BC98((uint64_t)v47 + 8, &v69);
      long long v30 = (v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v69
          : (std::string *)v69.__r_.__value_.__r.__words[0];
      *(_DWORD *)uint64_t v68 = 136315138;
      *(void *)&v68[4] = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I PCO: %s", v68, 0xCu);
      if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v69.__r_.__value_.__l.__data_);
      }
    }
    if (a3 != v10)
    {
      BOOL v39 = 1;
LABEL_86:
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 64) + 24))(&v69);
      if (v69.__r_.__value_.__l.__size_)
      {
        uint64_t v41 = std::__shared_weak_count::lock((std::__shared_weak_count *)v69.__r_.__value_.__l.__size_);
        if (v41) {
          std::string::size_type v42 = v69.__r_.__value_.__r.__words[0];
        }
        else {
          std::string::size_type v42 = 0;
        }
        if (v69.__r_.__value_.__l.__size_) {
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v69.__r_.__value_.__l.__size_);
        }
        if (v42) {
          (*(void (**)(std::string::size_type, BOOL))(*(void *)v42 + 48))(v42, v39);
        }
      }
      else
      {
        uint64_t v41 = 0;
      }
      unint64_t v43 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v44 = asStringBool(v39);
        LODWORD(v69.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v69.__r_.__value_.__r.__words + 4) = v44;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I PCO: foundSecondaryProvisioningPco=%s", (uint8_t *)&v69, 0xCu);
      }
      if (v41) {
        sub_10004D2C8(v41);
      }
      *(void *)&v47[0] = v45;
      if (SHIBYTE(v49) < 0) {
        operator delete(__p[1]);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      if ((void)v70)
      {
        *((void *)&v70 + 1) = v70;
        operator delete((void *)v70);
      }
      xpc_release(v64);
LABEL_104:
      xpc_release(v65);
      sub_100057D78((const void **)&v66);
      return;
    }
    long long v32 = (unsigned __int8 *)*((void *)&v70 + 1);
    long long v31 = (unsigned __int8 *)v70;
    if ((void)v70 == *((void *)&v70 + 1))
    {
      BOOL v34 = 1;
    }
    else
    {
      char v33 = 0;
      BOOL v34 = 1;
      do
      {
        int v35 = *v31;
        if (v35 == **a2)
        {
          BOOL v34 = v35 != 5;
          int v36 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v69.__r_.__value_.__l.__data_) = 67109376;
            HIDWORD(v69.__r_.__value_.__r.__words[0]) = v35;
            LOWORD(v69.__r_.__value_.__r.__words[1]) = 1024;
            *(_DWORD *)((char *)&v69.__r_.__value_.__r.__words[1] + 2) = a3;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I PCO: Expired field received = %d, container id = %d", (uint8_t *)&v69, 0xEu);
          }
          if (*(unsigned char *)(a1 + 89))
          {
            CFBooleanRef v37 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v69.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I PCO: Telling internet context to deactivate", (uint8_t *)&v69, 2u);
            }
            sub_100833DB0(a1, 0, 0);
            CFTypeID v38 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v69.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I PCO: Error activating internet PDP context due to PCO. Continuing Monitor Mode.", (uint8_t *)&v69, 2u);
            }
            sub_100831FA4(a1, -1.0);
            char v33 = 1;
          }
          else
          {
            char v33 = 1;
            sub_1008326F4(a1);
          }
        }
        ++v31;
      }
      while (v31 != v32);
      if (v33) {
        goto LABEL_85;
      }
    }
    if (*(unsigned char *)(a1 + 89))
    {
      long long v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v69.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I PCO: exit monitor mode on getting PCO with no expired codes present", (uint8_t *)&v69, 2u);
      }
      sub_100831998(a1, 1);
    }
LABEL_85:
    BOOL v39 = v34;
    goto LABEL_86;
  }
}

void sub_100835224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  sub_10008248C((uint64_t)&object);
  uint64_t v13 = *(void **)(v11 - 128);
  if (v13)
  {
    *(void *)(v11 - 120) = v13;
    operator delete(v13);
  }
  xpc_release(*(xpc_object_t *)(v11 - 208));
  xpc_release(*(xpc_object_t *)(v11 - 200));
  sub_100057D78((const void **)(v11 - 192));
  _Unwind_Resume(a1);
}

BOOL sub_10083538C(uint64_t a1)
{
  int v4 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 64) + 240))(&v4);
  if (v4) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  BOOL v2 = v1 != 0;
  sub_100057D78(&v4);
  return v2;
}

uint64_t sub_100835410(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 89) && *(unsigned char *)(a1 + 90))
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Internet activate failed while in monitor mode", v8, 2u);
    }
    if (qword_101B14190)
    {
      int v5 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v5)
      {
        uint64_t v6 = v5;
        if (DataPlanManagerBootstrap::sInstance) {
          (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 144))();
        }
        sub_10004D2C8(v6);
      }
    }
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 320))(a1, a2);
}

void sub_100835518(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083552C()
{
  if (qword_101B14190)
  {
    v0 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v0)
    {
      uint64_t v1 = v0;
      if (DataPlanManagerBootstrap::sInstance) {
        (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 40))();
      }
      sub_10004D2C8(v1);
    }
  }
}

void sub_1008355B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1008355C4(uint64_t a1, int a2)
{
  int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 248))(*(void *)(a1 + 64));
  int v5 = *(unsigned __int8 *)(a1 + 217);
  int v6 = a2 & v4;
  *(unsigned char *)(a1 + 217) = a2 & v4;
  int v7 = v5;
  if (v5 != (a2 & v4))
  {
    int v8 = *(NSObject **)(a1 + 40);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    int v7 = v6;
    if (v9)
    {
      unsigned __int16 v10 = "false";
      if (v6) {
        unsigned __int16 v10 = "true";
      }
      int v12 = 136315138;
      uint64_t v13 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Will Suppress probe changed to %s", (uint8_t *)&v12, 0xCu);
      int v7 = *(unsigned __int8 *)(a1 + 217);
    }
  }
  return v5 != v7;
}

uint64_t sub_1008356D4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_1008356DC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 89);
}

uint64_t sub_1008356E4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 88);
}

uint64_t sub_1008356EC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 91) = a2;
  return result;
}

uint64_t sub_1008356F4()
{
  return 0;
}

char *sub_1008356FC(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  BOOL v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *int v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 61) {
      sub_1004D66E0();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = sub_1004D669C(v7, v11);
    uint64_t v13 = (char *)v7[1];
    int v12 = (void **)(v7 + 1);
    BOOL v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      int v18 = v9;
      CFStringRef v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  int v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  int v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    BOOL v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    int v18 = v9;
    CFStringRef v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *int v12 = &v9[v17];
  return result;
}

void sub_100835808(uint64_t a1)
{
  *(void *)a1 = off_101A0F638;
  uint64_t v4 = *(void *)(a1 + 48);
  BOOL v2 = (void *)(a1 + 48);
  uint64_t v3 = v4;
  *BOOL v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v5) {
    sub_100206334(a1 + 40, v5);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v6) {
    sub_100206334(a1 + 32, v6);
  }
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v7) {
    sub_100206334(a1 + 24, v7);
  }
  sub_100110A40((void ***)(a1 + 16), 0);
  uint64_t v8 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v8) {
    sub_100206334(a1 + 8, v8);
  }

  PB::Base::~Base((PB::Base *)a1);
}

void sub_1008358C8(uint64_t a1)
{
  sub_100835808(a1);

  operator delete();
}

uint64_t sub_100835900(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)double result = off_101A0F638;
  *(_OWORD *)(result + 40) = 0u;
  *(_DWORD *)(result + 64) = 0;
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  char v2 = *(unsigned char *)(a2 + 64);
  if (v2)
  {
    int v3 = *(_DWORD *)(a2 + 56);
    *(unsigned char *)(result + 64) |= 1u;
    *(_DWORD *)(result + 56) = v3;
    char v2 = *(unsigned char *)(a2 + 64);
  }
  if ((v2 & 2) != 0)
  {
    int v4 = *(_DWORD *)(a2 + 60);
    *(unsigned char *)(result + 64) |= 2u;
    *(_DWORD *)(result + 60) = v4;
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  return result;
}

uint64_t sub_100835C0C(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 64)) {
    PB::TextFormatter::format(this, "activationStatus", *(_DWORD *)(a1 + 56));
  }
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  if ((*(unsigned char *)(a1 + 64) & 2) != 0) {
    PB::TextFormatter::format(this, "associationType", *(_DWORD *)(a1 + 60));
  }
  uint64_t v5 = *(const PB::Data **)(a1 + 16);
  if (v5) {
    PB::TextFormatter::format(this, "eid", v5);
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100835D18(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_44:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        operator new();
      case 4u:
        *(unsigned char *)(a1 + 64) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_66;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_55:
          LODWORD(v27) = 0;
          goto LABEL_66;
        }
        char v39 = 0;
        unsigned int v40 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        while (2)
        {
          if (v23 == v22)
          {
            LODWORD(v27) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v41 = v22 + 1;
            char v42 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v41;
            v27 |= (unint64_t)(v42 & 0x7F) << v39;
            if (v42 < 0)
            {
              v39 += 7;
              unint64_t v22 = v41;
              BOOL v14 = v40++ > 8;
              if (v14) {
                goto LABEL_55;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v27) = 0;
            }
          }
          break;
        }
LABEL_66:
        *(_DWORD *)(a1 + 56) = v27;
        goto LABEL_44;
      case 5u:
        *(unsigned char *)(a1 + 64) |= 2u;
        unint64_t v30 = *((void *)this + 1);
        unint64_t v31 = *((void *)this + 2);
        uint64_t v32 = *(void *)this;
        if (v30 <= 0xFFFFFFFFFFFFFFF5 && v30 + 10 <= v31)
        {
          char v33 = 0;
          unsigned int v34 = 0;
          uint64_t v35 = 0;
          do
          {
            unint64_t v36 = v30 + 1;
            *((void *)this + 1) = v30 + 1;
            char v37 = *(unsigned char *)(v32 + v30);
            v35 |= (unint64_t)(v37 & 0x7F) << v33;
            if ((v37 & 0x80) == 0) {
              goto LABEL_70;
            }
            v33 += 7;
            unint64_t v30 = v36;
            BOOL v14 = v34++ > 8;
          }
          while (!v14);
LABEL_62:
          LODWORD(v35) = 0;
          goto LABEL_70;
        }
        char v43 = 0;
        unsigned int v44 = 0;
        uint64_t v35 = 0;
        if (v31 <= v30) {
          unint64_t v31 = *((void *)this + 1);
        }
        break;
      case 6u:
        operator new();
      case 7u:
        operator new();
      case 8u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v31 == v30)
      {
        LODWORD(v35) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_70;
      }
      unint64_t v45 = v30 + 1;
      char v46 = *(unsigned char *)(v32 + v30);
      *((void *)this + 1) = v45;
      v35 |= (unint64_t)(v46 & 0x7F) << v43;
      if ((v46 & 0x80) == 0) {
        break;
      }
      v43 += 7;
      unint64_t v30 = v45;
      BOOL v14 = v44++ > 8;
      if (v14) {
        goto LABEL_62;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v35) = 0;
    }
LABEL_70:
    *(_DWORD *)(a1 + 60) = v35;
    goto LABEL_44;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_1008362A0(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 16);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  char v5 = *(unsigned char *)(v3 + 64);
  if (v5)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 56), 4u);
    char v5 = *(unsigned char *)(v3 + 64);
  }
  if ((v5 & 2) != 0) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 60), 5u);
  }
  if (*(void *)(v3 + 8)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 40))
  {
    return PB::Writer::write();
  }
  return result;
}

void CallCommandDriverDelegate::create()
{
}

void sub_100836450(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *CallCommandDriverDelegate::CallCommandDriverDelegate(void *a1, void *a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, kCALL_LOG_DOMAIN);
  sub_10083659C(a1 + 1, "CallCommandDriverDelegate", QOS_CLASS_USER_INITIATED, &v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *a1 = off_101A0F688;
  a1[6] = *a2;
  uint64_t v6 = a2[1];
  a1[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  a1[8] = *a3;
  uint64_t v7 = a3[1];
  a1[9] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100836578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CallCommandDriverDelegateInterface::~CallCommandDriverDelegateInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_10083659C(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_100104718(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v7, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v7);
  return a1;
}

void sub_100836604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a9);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

const void **sub_10083663C(void *a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 92);
  unint64_t v17 = 0;
  sub_10012A394(&v17, (const void **)a2);
  char v5 = (std::__shared_weak_count *)a1[9];
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      if (!a1[8])
      {
LABEL_19:
        sub_10004D2C8(v7);
        return sub_10012577C(&v17);
      }
      uint64_t v15 = 0;
      unsigned int v16 = 0;
      sub_100836830(&v15, (uint64_t)a1, a2);
      uint64_t v8 = v15;
      if (!v15)
      {
        unsigned int v10 = a1[5];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          unsigned __int8 v19 = v17;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Call uuid %@ cannot be found. Unable to dial call.", buf, 0xCu);
        }
        goto LABEL_17;
      }
      int v9 = *(_DWORD *)(a2 + 92);
      if (*(_DWORD *)(v15 + 696) == 1)
      {
        if (v9 == CallInfo::kDefaultCallId)
        {
LABEL_17:
          if (v16) {
            sub_10004D2C8(v16);
          }
          goto LABEL_19;
        }
      }
      else
      {
        if (v9 == CallInfo::kDefaultCallId || CallInfo::getCCDisconnectErrorCode((CallInfo *)a2))
        {
          unint64_t v11 = a1[5];
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#E Dial Error, ending the call", buf, 2u);
          }
          uint64_t v12 = v15;
          *(_DWORD *)(v12 + 224) = CallInfo::getCCDisconnectErrorCode((CallInfo *)a2);
          *(unsigned char *)(v12 + 228) = 1;
          uint64_t v13 = v15;
          *(_WORD *)(v15 + 220) = *(_WORD *)(a2 + 116);
          sub_1013D9E58(v13);
          goto LABEL_17;
        }
        uint64_t v8 = v15;
      }
      sub_1013DA340(v8, v4);
      goto LABEL_17;
    }
  }
  return sub_10012577C(&v17);
}

void sub_100836800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  if (a4) {
    sub_10004D2C8(a4);
  }
  sub_10004D2C8(v4);
  sub_10012577C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100836830(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(std::__shared_weak_count **)(a2 + 72);
  if (!v4 || (uint64_t v7 = std::__shared_weak_count::lock(v4)) == 0)
  {
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  uint64_t v8 = v7;
  int v9 = *(const void ***)(a2 + 64);
  if (v9)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    CallController::findCallByUuid_sync(v9, (const void **)a3, &v16);
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    CallController::getPreferredDriverForSim((uint64_t)v9, *(_DWORD *)(a3 + 252), &v14);
    if (v14)
    {
      int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
      uint64_t v11 = v16;
      if (v10 == 1 || v16 != 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v11 = v16;
      if (v16)
      {
LABEL_14:
        uint64_t v13 = v17;
        *a1 = v11;
        a1[1] = (uint64_t)v13;
        uint64_t v16 = 0;
        unint64_t v17 = 0;
        goto LABEL_15;
      }
    }
    CallController::findCallByCallId_sync((CallController *)v9, *(_DWORD *)(a3 + 92), 1, a1);
LABEL_15:
    if (v15) {
      sub_10004D2C8(v15);
    }
    if (v17) {
      sub_10004D2C8(v17);
    }
    goto LABEL_19;
  }
  *a1 = 0;
  a1[1] = 0;
LABEL_19:
  sub_10004D2C8(v8);
}

void sub_100836944(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100836978(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  int v4 = v3;
  uint64_t v5 = *(void *)(a1 + 64);
  if (v5) {
    uint64_t v6 = CallController::emCallActiveOnSoSWhenCarrierSupportsWifiCalling(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_1008369E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1008369FC(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        uint64_t v18 = 0;
        unsigned __int8 v19 = 0;
        sub_100836830(&v18, (uint64_t)a1, a2);
        if (!v18)
        {
          sub_1013DB390((uint64_t)&v14, a1 + 6);
          int v17 = *(_DWORD *)(a2 + 252);
          if (*(char *)(a2 + 55) < 0)
          {
            sub_10004FC84(&__dst, *(void **)(a2 + 32), *(void *)(a2 + 40));
          }
          else
          {
            long long __dst = *(_OWORD *)(a2 + 32);
            uint64_t v13 = *(void *)(a2 + 48);
          }
          if (SHIBYTE(v16) < 0) {
            operator delete((void *)v15);
          }
          long long v15 = __dst;
          uint64_t v16 = v13;
          HIBYTE(v13) = 0;
          LOBYTE(__dst) = 0;
          uint64_t v8 = *(void *)(v7 + 296);
          v11[0] = *(void *)(v7 + 288);
          v11[1] = v8;
          if (v8) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v9 = sub_100836DDC((uint64_t)&v14, v11);
          sub_100836E38(v9, buf);
        }
        if ((*(_DWORD *)(v18 + 168) & 0xFFFFFFFE) == 2
          && CallController::emCallActiveOnSoSWhenCarrierSupportsWifiCalling(v7))
        {
          BOOL v10 = *(unsigned __int8 *)(v18 + 172) != 2;
        }
        else
        {
          uint64_t v14 = (_DWORD *)(a2 + 252);
          BOOL v10 = *((unsigned char *)sub_10005CE78((uint64_t **)(v7 + 472), (int *)(a2 + 252), (uint64_t)&unk_10144E20E, &v14) + 32) == 0;
        }
        CallController::setAndSendAudioInterruptionsNotification_sync((CallController *)v7, v10, (uint64_t)&v18);
        if (v19) {
          sub_10004D2C8(v19);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100836D50(_Unwind_Exception *a1)
{
  sub_100836F2C(v2 - 224);
  int v4 = *(std::__shared_weak_count **)(v2 - 104);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100836DDC(uint64_t a1, uint64_t *a2)
{
  sub_100840F50(a2, &v6);
  long long v3 = v6;
  long long v6 = 0uLL;
  int v4 = *(std::__shared_weak_count **)(a1 + 80);
  *(_OWORD *)(a1 + 72) = v3;
  if (v4)
  {
    sub_10004D2C8(v4);
    if (*((void *)&v6 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
    }
  }
  return a1;
}

void sub_100836E38(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long v7 = *(_OWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  int v2 = *(_DWORD *)(a1 + 44);
  long long v3 = *(_OWORD *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 64);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  long long v4 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)std::string __p = v3;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  sub_10083FB50((void *)a1, v2, __p, a2, (uint64_t *)&v4);
}

void sub_100836EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v20 - 25) < 0) {
    operator delete(*(void **)(v20 - 48));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100836F2C(uint64_t a1)
{
  sub_10012577C((const void **)(a1 + 96));
  int v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100836F90(void *a1, const void **a2)
{
  long long v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = (const void **)a1[8];
      if (v6)
      {
        long long v7 = a1[5];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N CT finished dialing. BB/IPT has call and media initialized.", buf, 2u);
        }
        *(void *)long long buf = 0;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        v11[0] = v6;
        v11[1] = (const void **)&v5->__vftable;
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100837100((const void **)buf, v11, a2);
        sub_10004D2C8(v5);
        uint64_t v8 = *(uint64_t **)buf;
        uint64_t v9 = v13;
        while (v8 != v9)
        {
          if (*v8) {
            sub_1013D9178(*v8);
          }
          v8 += 2;
        }
        long long v15 = buf;
        sub_10005CBF0((void ***)&v15);
        goto LABEL_15;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  BOOL v10 = a1[5];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Controller invalid. Something's wrong!", buf, 2u);
  }
LABEL_15:
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1008370CC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_100837100(const void **result, const void ***a2, const void **a3)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  if (*a2)
  {
    uint64_t v5 = (uint64_t *)result;
    uint64_t v11 = 0;
    sub_10012A394(&v11, a3);
    if (v11) {
      uint64_t v6 = sub_100136254;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      long long v9 = 0uLL;
      CallController::findCallByUuid_sync(*a2, &v11, (uint64_t *)&v9);
      if ((void)v9) {
        sub_100838C64(v5, &v9);
      }
      if (*((void *)&v9 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v9 + 1));
      }
    }
    else
    {
      long long v7 = *a2;
      sub_100245B5C((uint64_t)v8, (uint64_t)a3);
      CallController::findAllCallsByCallId_sync((void **)v7, (uint64_t)v8, (uint64_t *)&v9);
      sub_10019E074(v5);
      *(_OWORD *)uint64_t v5 = v9;
      _DWORD v5[2] = v10;
      uint64_t v10 = 0;
      long long v9 = 0uLL;
      uint64_t v12 = (void **)&v9;
      sub_10005CBF0(&v12);
      sub_1002243E8((uint64_t)v8);
    }
    return sub_10012577C(&v11);
  }
  return result;
}

void sub_100837210(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  sub_10012577C((const void **)(v3 - 48));
  *(void *)(v3 - 80) = v2;
  sub_10005CBF0((void ***)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_100837258(uint64_t a1, const void **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      long long v7 = *(const void ***)(a1 + 64);
      if (v7)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        sub_100836830(&v10, a1, (uint64_t)a2);
        if (v10) {
          sub_1013D94D8(v10);
        }
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        int v8 = sub_10083735C(v7, v6, a2);
        sub_10004D2C8(v6);
        if (v8)
        {
          sub_100477910(&event::call::emergencyCallInProgress[3]);
          long long v9 = (uint64_t *)sub_100161CDC(&event::call::emergencyCallInProgress[1]);
          sub_10035414C(v9);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100837324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  sub_10004D2C8(v10);
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10083735C(const void **a1, std::__shared_weak_count *a2, const void **a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  v11[0] = a1;
  v11[1] = (const void **)&a2->__vftable;
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100837100((const void **)&v12, v11, a3);
  if (a2) {
    sub_10004D2C8(a2);
  }
  long long v4 = v12;
  uint64_t v5 = v13;
  while (1)
  {
    if (v4 == v5)
    {
      uint64_t v8 = 0;
      goto LABEL_14;
    }
    uint64_t v7 = *v4;
    uint64_t v6 = (std::__shared_weak_count *)v4[1];
    if (!v6) {
      break;
    }
    uint64_t v8 = 1;
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    unsigned int v9 = *(_DWORD *)(v7 + 168) & 0xFFFFFFFE;
    sub_10004D2C8(v6);
    if (v9 == 2) {
      goto LABEL_14;
    }
LABEL_12:
    v4 += 2;
  }
  if ((*(_DWORD *)(v7 + 168) & 0xFFFFFFFE) != 2) {
    goto LABEL_12;
  }
  uint64_t v8 = 1;
LABEL_14:
  long long v15 = (const void **)&v12;
  sub_10005CBF0((void ***)&v15);
  return v8;
}

void sub_10083743C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100837454(uint64_t a1, const void **a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(const void ***)(a1 + 64);
      if (v7)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        int v8 = sub_10083735C(v7, v6, a2);
        sub_10004D2C8(v6);
        if (v8)
        {
          sub_100477910(&event::call::emergencyCallInProgress[3]);
          unsigned int v9 = (uint64_t *)sub_100161CDC(&event::call::emergencyCallInProgress[1]);
          sub_10035414C(v9);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100837504(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100837528(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = (const void **)a1[8];
      if (!v7)
      {
LABEL_12:
        sub_10004D2C8(v6);
        return;
      }
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      CallController::findCallByUuid_sync(v7, (const void **)a2, &v11);
      uint64_t v8 = v11;
      if (*(unsigned char *)(a2 + 332))
      {
        if (!v11) {
          goto LABEL_9;
        }
      }
      else if (!v11)
      {
        unsigned int v9 = a1[5];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Branded call has already been terminated", v10, 2u);
        }
        goto LABEL_10;
      }
      *(unsigned char *)(v11 + 436) = 0;
      std::string::operator=((std::string *)(v8 + 400), (const std::string *)(a2 + 296));
LABEL_9:
      CallController::updateRestCallValues((CallController *)v7);
LABEL_10:
      if (v12) {
        sub_10004D2C8(v12);
      }
      goto LABEL_12;
    }
  }
}

void sub_100837610(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100837638(void *a1, uint64_t a2, _DWORD *a3)
{
  long long v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    uint64_t v8 = v7;
    if (v7)
    {
      unsigned int v9 = (void **)a1[8];
      if (v9)
      {
        uint64_t v10 = v9 + 23;
        uint64_t v11 = 21;
        if (*a3 == 1) {
          uint64_t v11 = 23;
        }
        else {
          uint64_t v10 = v9 + 21;
        }
        uint64_t v12 = (CallCommandDriver *)v9[v11];
        uint64_t v13 = (std::__shared_weak_count *)v10[1];
        long long v55 = v12;
        long long v56 = v13;
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v12)
        {
          char v46 = v7;
          uint64_t v48 = 0;
          long long v49 = 0;
          CallController::getPreferredDriverForSim((uint64_t)v9, *(_DWORD *)(a2 + 252), &v48);
          memset(__dst, 0, sizeof(__dst));
          uint64_t v54 = 0;
          CallController::getCurrentCallsDialedOnSim_sync(v9, *(_DWORD *)(a2 + 252), 0, (uint64_t *)__dst);
          long long v15 = *(uint64_t **)__dst;
          uint64_t v14 = *(uint64_t **)&__dst[8];
          if (*(void *)__dst != *(void *)&__dst[8])
          {
            uint64_t v16 = v48;
            if (v55 != v48)
            {
              int v17 = a1[5];
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#E We have calls that are on another command driver, cleaning those calls up before switching command drivers", buf, 2u);
              }
              (*(void (**)(CallCommandDriver *, void))(*(void *)v16 + 160))(v16, *(unsigned int *)(a2 + 252));
              long long v15 = *(uint64_t **)__dst;
              uint64_t v14 = *(uint64_t **)&__dst[8];
            }
            for (; v15 != v14; v15 += 2)
            {
              uint64_t v19 = *v15;
              uint64_t v18 = (std::__shared_weak_count *)v15[1];
              if (v18) {
                atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              int v20 = *(_DWORD *)(v19 + 696);
              if (v20 == (*(unsigned int (**)(CallCommandDriver *))(*(void *)v55 + 16))(v55)) {
                goto LABEL_26;
              }
              *(void *)long long buf = 0;
              long long v52 = 0;
              CallController::getPreferredDriverForSim((uint64_t)v9, *(_DWORD *)(v19 + 356), buf);
              uint64_t v21 = *(void *)buf;
              if (*(void *)buf)
              {
                (*(void (**)(void, void))(**(void **)buf + 160))(*(void *)buf, *(unsigned int *)(a2 + 252));
                int v22 = 6;
              }
              else
              {
                unint64_t v23 = a1[5];
                int v22 = 0;
                if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v24 = subscriber::asString();
                  *(_DWORD *)long long v57 = 136315138;
                  uint64_t v58 = v24;
                  _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E Failed to end calls on the other driver Slot: %s", v57, 0xCu);
                  int v22 = 0;
                }
              }
              if (v52) {
                sub_10004D2C8(v52);
              }
              if (!v21) {
LABEL_26:
              }
                int v22 = 0;
              if (v18) {
                sub_10004D2C8(v18);
              }
              if (v22) {
                break;
              }
            }
          }
          CallController::setPreferredDriver_sync((uint64_t)v9, &v55, *(unsigned int *)(a2 + 252), 0);
          *(void *)long long buf = __dst;
          sub_10005CBF0((void ***)buf);
          uint64_t v8 = v46;
          if (v49) {
            sub_10004D2C8(v49);
          }
        }
        *(void *)long long buf = 0;
        long long v52 = 0;
        CallController::findFirstConnectedCallByCallId_sync((CallController *)v9, (const CallInfo *)a2, buf);
        uint64_t v25 = *(void *)buf;
        if (!*(void *)buf)
        {
          sub_100245B5C((uint64_t)v47, a2);
          CallController::addNewIncomingCall_sync((uint64_t)v9, (uint64_t)v47);
        }
        if (*(_DWORD *)(*(void *)buf + 668) != 2)
        {
          sub_1013D98B8(*(uint64_t *)buf);
          uint64_t v25 = *(void *)buf;
        }
        if (*(char *)(v25 + 135) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v25 + 112), *(void *)(v25 + 120));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)(v25 + 112);
          uint64_t v54 = *(void *)(v25 + 128);
        }
        uint64_t v27 = HIBYTE(v54);
        if (v54 >= 0) {
          uint64_t v28 = HIBYTE(v54);
        }
        else {
          uint64_t v28 = *(void *)&__dst[8];
        }
        uint64_t v29 = *(unsigned __int8 *)(a2 + 31);
        int v30 = (char)v29;
        if ((v29 & 0x80u) != 0) {
          uint64_t v29 = *(void *)(a2 + 16);
        }
        if (v28 != v29) {
          goto LABEL_58;
        }
        if (v30 >= 0) {
          unint64_t v31 = (unsigned __int8 *)(a2 + 8);
        }
        else {
          unint64_t v31 = *(unsigned __int8 **)(a2 + 8);
        }
        if (SHIBYTE(v54) < 0)
        {
          unsigned int v34 = *(void **)__dst;
          if (memcmp(*(const void **)__dst, v31, *(size_t *)&__dst[8]))
          {
            operator delete(v34);
            goto LABEL_89;
          }
        }
        else if (HIBYTE(v54))
        {
          uint64_t v32 = __dst;
          while (*v32 == *v31)
          {
            ++v32;
            ++v31;
            if (!--v27) {
              goto LABEL_63;
            }
          }
LABEL_58:
          BOOL v33 = 1;
          if ((v54 & 0x8000000000000000) == 0) {
            goto LABEL_59;
          }
LABEL_88:
          operator delete(*(void **)__dst);
          if (!v33)
          {
LABEL_90:
            if (v52) {
              sub_10004D2C8(v52);
            }
            if (v56) {
              sub_10004D2C8(v56);
            }
            goto LABEL_94;
          }
LABEL_89:
          CallController::setCallerIdForCall_sync((const void **)v9, (const CallInfo *)a2);
          goto LABEL_90;
        }
LABEL_63:
        CSIPhoneNumber::getFullNumber((uint64_t *)&v48, (CSIPhoneNumber *)(*(void *)buf + 512));
        if ((v50 & 0x80u) == 0) {
          unint64_t v35 = v50;
        }
        else {
          unint64_t v35 = (unint64_t)v49;
        }
        unint64_t v36 = (std::__shared_weak_count *)*(unsigned __int8 *)(a2 + 55);
        int v37 = (char)v36;
        if ((char)v36 < 0) {
          unint64_t v36 = *(std::__shared_weak_count **)(a2 + 40);
        }
        if ((std::__shared_weak_count *)v35 == v36)
        {
          if (v37 >= 0) {
            CFTypeID v38 = (unsigned __int8 *)(a2 + 32);
          }
          else {
            CFTypeID v38 = *(unsigned __int8 **)(a2 + 32);
          }
          if ((v50 & 0x80) != 0)
          {
            unint64_t v45 = v48;
            BOOL v33 = memcmp(v48, v38, (size_t)v49) != 0;
LABEL_85:
            operator delete(v45);
            goto LABEL_87;
          }
          if (!v50)
          {
            BOOL v33 = 0;
LABEL_87:
            if ((v54 & 0x8000000000000000) == 0)
            {
LABEL_59:
              if (!v33) {
                goto LABEL_90;
              }
              goto LABEL_89;
            }
            goto LABEL_88;
          }
          uint64_t v39 = v50 - 1;
          unsigned int v40 = &v48;
          do
          {
            int v42 = *(unsigned __int8 *)v40;
            unsigned int v40 = (CallCommandDriver **)((char *)v40 + 1);
            int v41 = v42;
            int v43 = *v38++;
            BOOL v33 = v41 != v43;
          }
          while (v41 == v43 && v39-- != 0);
        }
        else
        {
          BOOL v33 = 1;
        }
        if ((v50 & 0x80) == 0) {
          goto LABEL_87;
        }
        unint64_t v45 = v48;
        goto LABEL_85;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  unsigned int v26 = a1[5];
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long __dst = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#E Dropping incoming call due to invalid controller!", __dst, 2u);
  }
LABEL_94:
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100837BA4(_Unwind_Exception *a1)
{
  if (*(char *)(v2 - 137) < 0) {
    operator delete(*(void **)(v2 - 160));
  }
  long long v4 = *(std::__shared_weak_count **)(v2 - 168);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 - 120);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100837C68(void *a1, uint64_t a2, char a3)
{
  long long v4 = (std::__shared_weak_count *)a1[9];
  if (!v4) {
    return;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[8];
  if (!v9) {
    goto LABEL_32;
  }
  int v30 = 0;
  unint64_t v31 = 0;
  uint64_t v32 = 0;
  v29[0] = (const void **)v9;
  v29[1] = (const void **)&v7->__vftable;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v28 = v7;
  sub_100837100((const void **)&v30, v29, (const void **)a2);
  sub_10004D2C8(v8);
  uint64_t v10 = v30;
  uint64_t v11 = v31;
  if (v30 == v31) {
    goto LABEL_16;
  }
  do
  {
    uint64_t v12 = *v10;
    if (*v10)
    {
      *(unsigned char *)(v12 + 648) = a3;
      char v13 = *(unsigned char *)(a2 + 85);
      uint64_t v14 = v12;
      if (v13)
      {
        sub_100B228F4(*(void *)(v12 + 680));
        uint64_t v14 = *v10;
      }
      *(unsigned char *)(v12 + 189) = v13;
      sub_1013D9588(v14);
    }
    v10 += 2;
  }
  while (v10 != v11);
  long long v15 = v30;
  uint64_t v16 = v31;
  if (v30 == v31)
  {
LABEL_16:
    int v20 = 0;
    goto LABEL_17;
  }
  while (1)
  {
    uint64_t v18 = *v15;
    int v17 = (std::__shared_weak_count *)v15[1];
    if (!v17) {
      break;
    }
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    unsigned int v19 = *(_DWORD *)(v18 + 168) & 0xFFFFFFFE;
    sub_10004D2C8(v17);
    if (v19 == 2) {
      goto LABEL_34;
    }
LABEL_15:
    v15 += 2;
    if (v15 == v16) {
      goto LABEL_16;
    }
  }
  if ((*(_DWORD *)(v18 + 168) & 0xFFFFFFFE) != 2) {
    goto LABEL_15;
  }
LABEL_34:
  sub_100477910((uint64_t *)&event::call::emergencyCallConnected + 3);
  uint64_t v27 = (uint64_t *)sub_100161CDC((uint64_t *)&event::call::emergencyCallConnected + 1);
  sub_10035414C(v27);
  int v20 = 1;
LABEL_17:
  CallController::updateRestCallValues((CallController *)v9);
  if (((v20 | CallController::carrierRequiresEmergencyCallToCheckVoiceHistory(v9, *(unsigned int *)(a2 + 252)) ^ 1) & 1) == 0)CallController::setVoiceCallMade(v9); {
  int v22 = *(uint64_t **)(v9 + 120);
  }
  uint64_t v21 = *(uint64_t **)(v9 + 128);
  if (v22 != v21)
  {
    while (2)
    {
      uint64_t v23 = *v22;
      uint64_t v24 = (std::__shared_weak_count *)v22[1];
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unsigned int v25 = *(_DWORD *)(v23 + 356);
      if (v25 == *(_DWORD *)(a2 + 252))
      {
        if ((*(_DWORD *)(v23 + 168) & 0xFFFFFFFE) != 2)
        {
LABEL_28:
          if (v24) {
            sub_10004D2C8(v24);
          }
          v22 += 2;
          if (v22 == v21) {
            goto LABEL_31;
          }
          continue;
        }
      }
      else
      {
        unsigned int v26 = a1[5];
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Call is active with a call on the other sim, updating the call capabilities for that sim!", buf, 2u);
          unsigned int v25 = *(_DWORD *)(v23 + 356);
        }
      }
      break;
    }
    CallController::notifyCallCapabilities_sync(v9, v25);
    goto LABEL_28;
  }
LABEL_31:
  *(void *)long long buf = &v30;
  sub_10005CBF0((void ***)buf);
  uint64_t v8 = v28;
LABEL_32:
  sub_10004D2C8(v8);
}

void sub_100837EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9)
{
  sub_10004D2C8(v9);
  sub_10004D2C8(a9);
  _Unwind_Resume(a1);
}

void sub_100837F04(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = (void **)a1[8];
      if (v7)
      {
        int v17 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        sub_100245B5C((uint64_t)v16, a2);
        CallController::findAllCallsByCallId_sync(v7, (uint64_t)v16, (uint64_t *)&v17);
        sub_1002243E8((uint64_t)v16);
        uint64_t v8 = v17;
        uint64_t v9 = v18;
        if (v17 != v18)
        {
          uint64_t v10 = kAddCallAllowedKey;
          do
          {
            uint64_t v11 = *v8;
            if (*v8)
            {
              int v12 = *(_DWORD *)(v11 + 160);
              if (v12 == 7 || v12 == 4)
              {
                sub_100837C68(a1, v11 + 104, 1);
                uint64_t v14 = 0;
                long long v15 = 0;
                CallController::getPreferredDriverForSim((uint64_t)v7, *(_DWORD *)(a2 + 252), &v14);
                if (v14) {
                  (*((void (**)(void **, uint64_t, void, uint64_t, void))*v14 + 37))(v14, v10, 0, 1, *(unsigned int *)(a2 + 252));
                }
                if (v15) {
                  sub_10004D2C8(v15);
                }
              }
            }
            v8 += 2;
          }
          while (v8 != v9);
        }
        uint64_t v14 = (void **)&v17;
        sub_10005CBF0(&v14);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100838058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1002243E8((uint64_t)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_1008380A8(uint64_t a1, unsigned int *a2, int a3, int a4)
{
  long long v4 = (void *)a1;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v5) {
    return;
  }
  uint64_t v9 = std::__shared_weak_count::lock(v5);
  if (!v9) {
    return;
  }
  if (!v4[8]) {
    goto LABEL_147;
  }
  long long v74 = (CallController *)v4[8];
  int v66 = v9;
  long long v76 = (CallInfo *)a2;
  uint64_t v10 = a2[63];
  uint64_t v11 = v4[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)v76) {
      int v12 = sub_100136254;
    }
    else {
      int v12 = 0;
    }
    if (v12)
    {
      sub_10012A394(&v88, (const void **)v76);
      char v13 = &v89;
      printUuid();
    }
    else
    {
      char v13 = &v89;
      std::to_string(&v89, *((_DWORD *)v76 + 23));
    }
    if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      char v13 = (std::string *)v89.__r_.__value_.__r.__words[0];
    }
    uint64_t v14 = asString();
    uint64_t v15 = subscriber::asString();
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v92 = v15;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Call end: %s from %s of slot %s", buf, 0x20u);
    if (v12)
    {
      if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v89.__r_.__value_.__l.__data_);
      }
      sub_10012577C(&v88);
    }
    else if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v89.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v86 = 0;
  CFRange v87 = 0;
  CallController::getPreferredDriverForSim((uint64_t)v74, v10, &v86);
  uint64_t v16 = v86;
  if (v86) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v86 + 240))(v86, v10);
  }
  long long v84 = 0uLL;
  uint64_t v85 = 0;
  *(_DWORD *)long long v70 = CallController::carrierSupportsSwitchEmergencySubAfterFailures((uint64_t)v74, v10);
  long long v83 = 0uLL;
  CallController::findEmergencyCall_sync(v74, 0, &v83);
  if (!(void)v83) {
    goto LABEL_31;
  }
  if (*(void *)v76) {
    int v17 = sub_100136254;
  }
  else {
    int v17 = 0;
  }
  BOOL v49 = v17 == 0;
  int v18 = *(_DWORD *)v70;
  if (!v49) {
    int v18 = 0;
  }
  if (v18 == 1 && *(_DWORD *)(v83 + 196) == *((_DWORD *)v76 + 23) && *(_DWORD *)(v83 + 356) == *((_DWORD *)v76 + 63))
  {
    sub_100838C64((uint64_t *)&v84, &v83);
    uint64_t v19 = (const void **)sub_1013D824C(v83);
    sub_100224390((const void **)v76, v19);
    BOOL v20 = 1;
  }
  else
  {
LABEL_31:
    long long v82 = 0uLL;
    CallController::findCallByUuid_sync((const void **)v74, (const void **)v76, (uint64_t *)&v82);
    BOOL v20 = (void)v82 != 0;
    if ((void)v82)
    {
      sub_100838C64((uint64_t *)&v84, &v82);
    }
    else
    {
      sub_100245B5C((uint64_t)v81, (uint64_t)v76);
      CallController::findAllCallsByCallId_sync((void **)v74, (uint64_t)v81, (uint64_t *)buf);
      sub_10019E074((uint64_t *)&v84);
      long long v84 = *(_OWORD *)buf;
      uint64_t v85 = *(void *)&buf[16];
      long long v90 = buf;
      memset(buf, 0, sizeof(buf));
      sub_10005CBF0((void ***)&v90);
      sub_1002243E8((uint64_t)v81);
    }
    if (*((void *)&v82 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v82 + 1));
    }
  }
  uint64_t v67 = v16;
  unsigned int v73 = v10;
  int v68 = a3;
  int v65 = a4;
  if (*((void *)&v83 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v83 + 1));
  }
  long long v72 = (uint64_t *)*((void *)&v84 + 1);
  uint64_t v21 = (uint64_t *)v84;
  if ((void)v84 == *((void *)&v84 + 1))
  {
LABEL_140:
    CallController::retrieveOtherAfterCallEnded_sync(v74, v76);
    goto LABEL_144;
  }
  int v22 = !v20;
  if (v20) {
    uint64_t v23 = "true";
  }
  else {
    uint64_t v23 = "false";
  }
  std::string v69 = v23;
  if (a4) {
    uint64_t v24 = "true";
  }
  else {
    uint64_t v24 = "false";
  }
  xpc_object_t v64 = v24;
  int v71 = !v20;
  while (1)
  {
    uint64_t v25 = *v21;
    if (*v21) {
      break;
    }
LABEL_139:
    v21 += 2;
    if (v21 == v72) {
      goto LABEL_140;
    }
  }
  LODWORD(v82) = *(_DWORD *)(v25 + 160);
  int v26 = *(_DWORD *)(*(void *)(v25 + 760) + 24);
  if (v26 == 11) {
    int v75 = 0;
  }
  else {
    int v75 = isCallDialedAndBeingSetup();
  }
  uint64_t v27 = v76;
  int v28 = *((unsigned __int8 *)v74 + 872);
  int CCDisconnectErrorCode = CallInfo::getCCDisconnectErrorCode(v76);
  BOOL v30 = (CallController::isIMSRegisteredOverLTE_sync((uint64_t)v74, v73) & 1) != 0
     || CallController::isIMSRegisteredOverNR_sync((uint64_t)v74, v73);
  unint64_t v31 = v4[5];
  IsListedAsEmergency = (capabilities::ct *)os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
  if (IsListedAsEmergency)
  {
    BOOL v33 = v4;
    uint64_t v34 = asString();
    if ((*(_DWORD *)(*v21 + 168) & 0xFFFFFFFE) == 2
      || (unint64_t v35 = "false", CSIPhoneNumber::getIsListedAsEmergency((CSIPhoneNumber *)(*v21 + 512))))
    {
      unint64_t v35 = "true";
    }
    if (v26 == 11) {
      unint64_t v36 = "true";
    }
    else {
      unint64_t v36 = "false";
    }
    if (isCallDialedAndBeingSetup()) {
      int v37 = "true";
    }
    else {
      int v37 = "false";
    }
    CallInfo::getCCDisconnectErrorCode(v76);
    uint64_t v38 = asString();
    *(_DWORD *)long long buf = 136316674;
    uint64_t v39 = "false";
    if (v75) {
      uint64_t v39 = "true";
    }
    *(void *)&uint8_t buf[4] = v34;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v35;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v92 = (uint64_t)v36;
    __int16 v93 = 2080;
    unint64_t v94 = v37;
    __int16 v95 = 2080;
    uint64_t v96 = v38;
    __int16 v97 = 2080;
    uint64_t v98 = v69;
    __int16 v99 = 2080;
    std::string::size_type v100 = v39;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Call end: %s, em: %s, disconnecting: %s, set up: %s, cause: %s, can IMS redial: %s, need redial: %s", buf, 0x48u);
    long long v4 = v33;
    uint64_t v27 = v76;
    int v22 = v71;
  }
  if (CCDisconnectErrorCode) {
    int v40 = v22 | v75 ^ 1;
  }
  else {
    int v40 = 1;
  }
  if ((v40 | v30)) {
    goto LABEL_153;
  }
  sub_100838D80((uint64_t)v4, v73, (uint64_t *)buf);
  uint64_t v41 = *(void *)&buf[8] - *(void *)buf;
  *(void *)&long long v83 = buf;
  sub_1002244D8((void ***)&v83);
  unsigned int v42 = *(_DWORD *)(*v21 + 168) & 0xFFFFFFFE;
  int v43 = v4[5];
  IsListedAsEmergency = (capabilities::ct *)os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
  if (IsListedAsEmergency)
  {
    if (v28) {
      unsigned int v44 = "true";
    }
    else {
      unsigned int v44 = "false";
    }
    if (v41 == 408) {
      unint64_t v45 = "true";
    }
    else {
      unint64_t v45 = "false";
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v44;
    *(_WORD *)&unsigned char buf[12] = 2080;
    if (v42 == 2) {
      char v46 = "true";
    }
    else {
      char v46 = "false";
    }
    *(void *)&buf[14] = v45;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v92 = (uint64_t)v46;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Call end: Checking PDN down. airplane: %s, only one call: %s. emergency setup: %s.", buf, 0x20u);
  }
  uint64_t v27 = v76;
  if (v28 || *(_DWORD *)(*v21 + 696) != 1 || v41 != 408 || v42 == 2)
  {
LABEL_153:
    if ((v40 & 1) == 0)
    {
      if ((*(_DWORD *)(*v21 + 168) & 0xFFFFFFFE) == 2
        || (IsListedAsEmergency = (capabilities::ct *)CSIPhoneNumber::getIsListedAsEmergency((CSIPhoneNumber *)(*v21 + 512)),
            IsListedAsEmergency))
      {
        uint64_t v47 = v4[5];
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v48 = asStringBool(v70[0]);
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v48;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Call end: Checking Emergency redial. carrierRequiresSwitichingSubForEmCall: %s", buf, 0xCu);
        }
        if (*(_DWORD *)v70)
        {
          sub_100245B5C((uint64_t)v80, (uint64_t)v76);
          char v63 = v80;
          sub_100838EAC(v4, (uint64_t)v80, 11);
          goto LABEL_143;
        }
        if (v68) {
          BOOL v49 = v67 == *((void *)v74 + 23);
        }
        else {
          BOOL v49 = 0;
        }
        int v50 = v49;
        long long v51 = v4[5];
        IsListedAsEmergency = (capabilities::ct *)os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT);
        if (IsListedAsEmergency)
        {
          long long v52 = "false";
          if (v50) {
            long long v52 = "true";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v52;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Call end without requiring switching sub. Redial only if notLastEmCsFallback: %s", buf, 0xCu);
        }
        uint64_t v27 = v76;
        if (v50)
        {
          sub_100245B5C((uint64_t)v79, (uint64_t)v76);
          char v63 = v79;
          sub_100838EAC(v4, (uint64_t)v79, 11);
          goto LABEL_143;
        }
      }
    }
    if (((v22 | v75 ^ 1 | capabilities::ct::supports5G(IsListedAsEmergency) ^ 1) & 1) == 0
      && (*(_DWORD *)(*v21 + 168) & 0xFFFFFFFE) != 2
      && (CSIPhoneNumber::getIsListedAsEmergency((CSIPhoneNumber *)(*v21 + 512)) & 1) == 0)
    {
      long long v53 = v4[5];
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        if (CallInfo::isRedialOverLegacyRATRequestedInErrorCode(v76)) {
          uint64_t v54 = "true";
        }
        else {
          uint64_t v54 = "false";
        }
        if (*(unsigned char *)(*v21 + 438)) {
          long long v55 = "true";
        }
        else {
          long long v55 = "false";
        }
        if (*((unsigned char *)v76 + 335)) {
          long long v56 = "true";
        }
        else {
          long long v56 = "false";
        }
        *(_DWORD *)long long buf = 136315906;
        *(void *)&uint8_t buf[4] = v54;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v55;
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v92 = (uint64_t)v56;
        __int16 v93 = 2080;
        unint64_t v94 = v64;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Call end: Checking 5G redial. LegacyRatRedialRequested: %s, Originated over NR: %s, Invalid RAT: %s. normal redial allowed by SIP code: %s", buf, 0x2Au);
      }
      uint64_t v27 = v76;
      if (CallInfo::isRedialOverLegacyRATRequestedInErrorCode(v76))
      {
        if (*(unsigned char *)(*v21 + 438))
        {
          if (v65) {
            goto LABEL_150;
          }
        }
        else if (*((unsigned char *)v76 + 335) && (v65 & 1) != 0)
        {
LABEL_150:
          sub_100245B5C((uint64_t)v78, (uint64_t)v76);
          char v63 = v78;
          sub_100838EAC(v4, (uint64_t)v78, 12);
          goto LABEL_143;
        }
      }
    }
    int v57 = CallInfo::getCCDisconnectErrorCode(v27);
    uint64_t v58 = *v21;
    if (v28 && *(unsigned char *)(v58 + 172) != 2) {
      int v57 = 0;
    }
    if (!*(unsigned char *)(v58 + 228))
    {
      *(_DWORD *)(v58 + 224) = v57;
      *(unsigned char *)(v58 + 228) = 1;
      uint64_t v58 = *v21;
    }
    if (!v75) {
      goto LABEL_138;
    }
    if ((*(_DWORD *)(v58 + 168) & 0xFFFFFFFE) == 2
      || (CSIPhoneNumber::getIsListedAsEmergency((CSIPhoneNumber *)(v58 + 512)) & 1) != 0)
    {
      int v59 = CallInfo::getCCDisconnectErrorCode(v27);
      uint64_t v60 = v4[5];
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v61 = asStringBool(*(unsigned char *)(*v21 + 192));
        uint64_t v62 = asStringBool(v59 == 24);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v61;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v62;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Call end: Checking Emergency Fallback Needed: %s. no service: %s", buf, 0x16u);
      }
      uint64_t v58 = *v21;
      int v22 = v71;
      if (*(unsigned char *)(*v21 + 192))
      {
        BOOL v49 = v59 == 24;
        uint64_t v27 = v76;
        if (!v49) {
          goto LABEL_138;
        }
        sub_100245B5C((uint64_t)v77, v58 + 104);
        char v63 = v77;
        sub_100838EAC(v4, (uint64_t)v77, 9);
LABEL_143:
        sub_1002243E8((uint64_t)v63);
        goto LABEL_144;
      }
      uint64_t v27 = v76;
    }
    else
    {
      uint64_t v58 = *v21;
    }
LABEL_138:
    *(_WORD *)(v58 + 220) = *((_WORD *)v27 + 58);
    sub_1013D9E58(v58);
    goto LABEL_139;
  }
  CallController::redialCallOverCS(v74, v21, 5);
LABEL_144:
  *(void *)long long buf = &v84;
  sub_10005CBF0((void ***)buf);
  if (v87) {
    sub_10004D2C8(v87);
  }
  uint64_t v9 = v66;
LABEL_147:
  sub_10004D2C8(v9);
}

void sub_100838B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  sub_1002243E8((uint64_t)&STACK[0x250]);
  *(void *)(v16 - 176) = v16 - 256;
  sub_10005CBF0((void ***)(v16 - 176));
  int v18 = *(std::__shared_weak_count **)(v16 - 224);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10004D2C8(a16);
  _Unwind_Resume(a1);
}

void **sub_100838C64(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)sub_10006A794((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    void v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    void v18[2] = v15 + 16;
    sub_1008406A4(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = sub_1006C59A4(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_100838D6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1006C59A4((void **)va);
  _Unwind_Resume(a1);
}

void sub_100838D80(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v5)
  {
    uint64_t v7 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v5);
  if (!v7 || (uint64_t v8 = *(void ***)(a1 + 64)) == 0)
  {
LABEL_8:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    if (!v7) {
      return;
    }
    goto LABEL_9;
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  CallController::getCurrentCallsDialedOnSim_sync(v8, a2, 0, (uint64_t *)&v11);
  uint64_t v9 = v11;
  uint64_t v10 = v12;
  while (v9 != v10)
  {
    sub_100245B5C((uint64_t)v14, *v9 + 104);
    sub_1008407E4(a3, (uint64_t)v14);
    sub_1002243E8((uint64_t)v14);
    v9 += 2;
  }
  v14[0] = (void **)&v11;
  sub_10005CBF0(v14);
  if (v7) {
LABEL_9:
  }
    sub_10004D2C8(v7);
}

void sub_100838E64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002244D8((void ***)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_100838EAC(void *a1, uint64_t a2, uint64_t a3)
{
  long long v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = a1[8];
      if (!v9)
      {
LABEL_82:
        sub_10004D2C8(v8);
        return;
      }
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      CallController::findCallByUuid_sync((const void **)v9, (const void **)a2, &v37);
      uint64_t v10 = v37;
      unint64_t v11 = a1[5];
      if (!v37)
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "silentRedial failed: null call", (uint8_t *)__p, 2u);
        }
        goto LABEL_80;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        sub_1013D8DEC(v10);
        uint64_t v12 = asString();
        uint64_t v13 = __p;
        if (v36 < 0) {
          uint64_t v13 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136315394;
        int v40 = v13;
        __int16 v41 = 2080;
        uint64_t v42 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I silentRedial call %s requested: %s", buf, 0x16u);
        if (v36 < 0) {
          operator delete(__p[0]);
        }
      }
      CallController::saveSilentRedialMetric(v9, &v37);
      if (isSilentRedialReasonUndetectedEmergency())
      {
        uint64_t v14 = a1[5];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I silentRedial undetected emergency. Possibly end other calls before redial", (uint8_t *)__p, 2u);
        }
        if (!*(unsigned char *)(v9 + 2064))
        {
          *(unsigned char *)(v9 + 2064) = 1;
          uint64_t v15 = *(void *)(v9 + 2056);
          if (v15) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, v9 + 2064);
          }
        }
        uint64_t v16 = v37;
        *(unsigned char *)(v37 + 672) = 1;
        if (a3 == 8)
        {
          if (*(unsigned char *)(v16 + 508))
          {
            *(_WORD *)(v16 + 504) = 259;
          }
          else
          {
            *(unsigned char *)(v16 + 496) = 0;
            *(unsigned char *)(v16 + 500) = 0;
            *(_WORD *)(v16 + 504) = 259;
            *(unsigned char *)(v16 + 508) = 1;
          }
          *(unsigned char *)(v16 + 438) = 0;
        }
        else
        {
          if (*(unsigned char *)(v16 + 508))
          {
            *(_WORD *)(v16 + 504) = 257;
          }
          else
          {
            *(unsigned char *)(v16 + 496) = 0;
            *(unsigned char *)(v16 + 500) = 0;
            *(_WORD *)(v16 + 504) = 257;
            *(unsigned char *)(v16 + 508) = 1;
          }
          sub_1013D8CB0(v16, 2);
          uint64_t v16 = v37;
          *(_DWORD *)(v37 + 200) = *(_DWORD *)(a2 + 96);
        }
        sub_1013D9228(v16);
        CallController::_endCallsBeforeDialIfNeeded_sync(v9, &v37, 0);
        goto LABEL_80;
      }
      uint64_t v17 = *(void *)(v9 + 88);
      if (v17) {
        (*(void (**)(uint64_t, void, uint64_t *))(*(void *)v17 + 16))(v17, 0, &v37);
      }
      uint64_t v18 = v37;
      if ((*(_DWORD *)(v37 + 168) & 0xFFFFFFFE) == 2)
      {
        if (a3 != 9)
        {
LABEL_28:
          CallController::redialCallOverCS((void *)v9, &v37, a3);
          goto LABEL_80;
        }
LABEL_25:
        uint64_t v19 = a1[5];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I silentRedial call with emergency fallback. Setting type to emergency", (uint8_t *)__p, 2u);
          uint64_t v18 = v37;
        }
        sub_1013D8CB0(v18, 2);
        *(_DWORD *)(v37 + 200) = *(_DWORD *)(a2 + 96);
        CallController::checkAndSendLikelyToFail_sync((CallController *)v9, *(_DWORD *)(a2 + 252));
        goto LABEL_28;
      }
      uint64_t v20 = *(unsigned int *)(v37 + 356);
      int isIMSRegisteredOverLTE_sync = CallController::isIMSRegisteredOverLTE_sync(v9, v20);
      BOOL isIMSRegisteredOverNR_sync = CallController::isIMSRegisteredOverNR_sync(v9, v20);
      uint64_t v18 = v37;
      int v23 = *(unsigned __int8 *)(v37 + 172);
      if (*(unsigned char *)(a2 + 335))
      {
        if (v23 == 4 && isIMSRegisteredOverLTE_sync | isIMSRegisteredOverNR_sync && !*(unsigned char *)(v37 + 438))
        {
          unint64_t v31 = a1[5];
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v32 = (const void **)sub_1013D824C(v18);
            sub_10012A394(&v34, v32);
            printUuid();
            if (v36 >= 0) {
              BOOL v33 = __p;
            }
            else {
              BOOL v33 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136315138;
            int v40 = v33;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I silentRedial call %s: invalid rat over LTE. need rat reselection", buf, 0xCu);
            if (v36 < 0) {
              operator delete(__p[0]);
            }
            sub_10012577C(&v34);
            uint64_t v18 = v37;
          }
          *(unsigned char *)(v18 + 438) = 1;
          *(unsigned char *)(v18 + 172) = 8;
          goto LABEL_79;
        }
        if (isIMSRegisteredOverLTE_sync)
        {
          CallController::fetchAndSetPhoneCallSubType_sync(v9, &v37);
          uint64_t v18 = v37;
        }
        else
        {
          *(unsigned char *)(v37 + 439) = 1;
        }
        uint64_t v24 = a1[5];
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          sub_1013D8DEC(v18);
          if (v36 >= 0) {
            uint64_t v27 = __p;
          }
          else {
            uint64_t v27 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          int v40 = v27;
          int v26 = "#N silentRedial call %s over LTE: invalid rat";
LABEL_54:
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v26, buf, 0xCu);
          if (v36 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v18 = v37;
        }
      }
      else
      {
        if (v23 != 8)
        {
          if (a3 != 9)
          {
            if (a3 == 10
              && *(unsigned char *)(v37 + 438)
              && CallController::carrierBlocksCallsOverCS_sync(v9, v20, 1)
              && CallController::copyIMSConfigBoolValue(v9, (int)"Signaling", (uint64_t)"RedialOverLteIfEpsFallbackCallFailed", v20, (BOOL *)kCFBooleanFalse)&& v23 == 4&& ((isIMSRegisteredOverLTE_sync ^ 1) & 1) == 0)
            {
              int v28 = a1[5];
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                sub_1013D8DEC(v37);
                uint64_t v29 = v36 >= 0 ? __p : (void **)__p[0];
                *(_DWORD *)long long buf = 136315138;
                int v40 = v29;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N silentRedial call %s: carrierWantsRedialOverLteIfEpsFallbackCallFailed", buf, 0xCu);
                if (v36 < 0) {
                  operator delete(__p[0]);
                }
              }
              uint64_t v30 = v37;
              *(unsigned char *)(v37 + 438) = 0;
              sub_1013D9228(v30);
              goto LABEL_80;
            }
            goto LABEL_28;
          }
          goto LABEL_25;
        }
        uint64_t v24 = a1[5];
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          sub_1013D8DEC(v18);
          if (v36 >= 0) {
            uint64_t v25 = __p;
          }
          else {
            uint64_t v25 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          int v40 = v25;
          int v26 = "#N silentRedial call %s: failed over NR";
          goto LABEL_54;
        }
      }
LABEL_79:
      sub_1013D9228(v18);
LABEL_80:
      if (v38) {
        sub_10004D2C8(v38);
      }
      goto LABEL_82;
    }
  }
}

void sub_100839520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

BOOL sub_100839598(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    BOOL v5 = *(unsigned __int8 *)(v4 + 416) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  sub_10004D2C8(v3);
  return v5;
}

void sub_1008395F4(void *a1, const CallInfo *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = (CallController *)a1[8];
      if (v7)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        sub_100836830(&v11, (uint64_t)a1, (uint64_t)a2);
        if (!v11) {
          CallController::addCallWaitingCall_sync(v7, a2, &v10);
        }
        uint64_t v8 = a1[5];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I This Call Waiting call already exists, ignoring indication", v9, 2u);
        }
        if (v12) {
          sub_10004D2C8(v12);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1008396EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_100839714(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = (const void **)a1[8];
      if (!v9)
      {
LABEL_12:
        sub_10004D2C8(v8);
        return;
      }
      long long v14 = 0uLL;
      CallController::findCallByUuid_sync(v9, (const void **)a2, (uint64_t *)&v14);
      if ((void)v14) {
        goto LABEL_9;
      }
      CallController::findCallByCallId_sync((CallController *)v9, *(_DWORD *)(a2 + 92), 0, buf);
      long long v10 = *(_OWORD *)buf;
      memset(buf, 0, sizeof(buf));
      uint64_t v11 = (std::__shared_weak_count *)*((void *)&v14 + 1);
      long long v14 = v10;
      if (v11)
      {
        sub_10004D2C8(v11);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        if ((void)v14) {
          goto LABEL_9;
        }
      }
      else if ((void)v10)
      {
LABEL_9:
        CallController::setAndSendAudioToneRelay_sync((uint64_t)v9, a3 == 1, (uint64_t *)&v14);
LABEL_10:
        if (*((void *)&v14 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v14 + 1));
        }
        goto LABEL_12;
      }
      uint64_t v12 = a1[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = *(_DWORD *)(a2 + 92);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to find call with id: %u", buf, 8u);
      }
      goto LABEL_10;
    }
  }
}

void sub_100839878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1008398A4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    unint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(CallController **)(a1 + 64);
      if (v8)
      {
        CallController::setMediaStatus_sync(v8, a3);
        if (a3) {
          uint64_t v9 = 9;
        }
        else {
          uint64_t v9 = 10;
        }
        (*(void (**)(void *, uint64_t))(**((void **)v8 + 46) + 24))(*((void **)v8 + 46), v9);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100839950(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100839968(uint64_t a1, const CallInfo *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = *(CallController **)(a1 + 64);
      if (v6)
      {
        v7[0] = 0;
        v7[1] = 0;
        CallController::addCallWaitingCall_sync(v6, a2, v7);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100839A30(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100839A44(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        BOOL v49 = 0;
        int v50 = 0;
        uint64_t v51 = 0;
        v48[0] = (const void **)v7;
        v48[1] = (const void **)&v5->__vftable;
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        __int16 v41 = v5;
        sub_100837100((const void **)&v49, v48, (const void **)a2);
        sub_10004D2C8(v6);
        uint64_t v8 = a1[5];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          if (*(void *)a2) {
            uint64_t v9 = sub_100136254;
          }
          else {
            uint64_t v9 = 0;
          }
          if (v9)
          {
            sub_10012A394(&v46, (const void **)a2);
            printUuid();
          }
          else
          {
            std::to_string(&v47, *(_DWORD *)(a2 + 92));
          }
          if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            long long v10 = &v47;
          }
          else {
            long long v10 = (std::string *)v47.__r_.__value_.__r.__words[0];
          }
          uint64_t v11 = "true";
          if (!*(unsigned char *)(a2 + 85)) {
            uint64_t v11 = "false";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v10;
          __int16 v53 = 2080;
          uint64_t v54 = (void *)v11;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Call %s is held (conference: %s)", buf, 0x16u);
          if (v9)
          {
            if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v47.__r_.__value_.__l.__data_);
            }
            sub_10012577C(&v46);
          }
          else if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v47.__r_.__value_.__l.__data_);
          }
        }
        uint64_t v12 = v49;
        int v13 = v50;
        while (v12 != v13)
        {
          long long v14 = (void *)*v12;
          char v15 = *(unsigned char *)(a2 + 85);
          uint64_t v16 = (void *)*v12;
          if (v15)
          {
            sub_100B228F4(v14[85]);
            uint64_t v16 = (void *)*v12;
          }
          *((unsigned char *)v14 + 189) = v15;
          sub_1013D9FC8(v16);
          v12 += 2;
        }
        uint64_t v17 = *(uint64_t **)(v7 + 120);
        uint64_t v18 = *(uint64_t **)(v7 + 128);
        uint64_t v42 = v7;
        if (v17 != v18)
        {
          while (1)
          {
            uint64_t v20 = *v17;
            uint64_t v19 = (std::__shared_weak_count *)v17[1];
            if (v19) {
              atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (*(unsigned char *)(v20 + 752))
            {
              int v21 = 0;
              switch(*(_DWORD *)(v20 + 160))
              {
                case 1:
                  int v28 = a1[5];
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v29 = subscriber::asString();
                    sub_1013D8DEC(v20);
                    int v30 = v45;
                    unint64_t v31 = (void **)__p[0];
                    uint64_t v32 = subscriber::asString();
                    *(_DWORD *)long long buf = 136315650;
                    BOOL v33 = __p;
                    if (v30 < 0) {
                      BOOL v33 = v31;
                    }
                    *(void *)&uint8_t buf[4] = v29;
                    __int16 v53 = 2080;
                    uint64_t v54 = v33;
                    __int16 v55 = 2080;
                    uint64_t v56 = v32;
                    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Call on sim %s is held. Unhold RetrieveOnceReady call %s on the other sim (%s)", buf, 0x20u);
                    if (v45 < 0) {
                      operator delete(__p[0]);
                    }
                  }
                  *(unsigned char *)(v20 + 752) = 0;
                  uint64_t v34 = (const void **)sub_1013D824C(v20);
                  sub_10012A394(&v43, v34);
                  CallController::holdUnHoldActiveCall(v42, &v43);
                  sub_10012577C(&v43);
                  break;
                case 2:
                  unint64_t v35 = a1[5];
                  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v36 = subscriber::asString();
                    sub_1013D8DEC(v20);
                    int v37 = v45;
                    uint64_t v38 = (void **)__p[0];
                    uint64_t v39 = subscriber::asString();
                    *(_DWORD *)long long buf = 136315650;
                    int v40 = __p;
                    if (v37 < 0) {
                      int v40 = v38;
                    }
                    *(void *)&uint8_t buf[4] = v36;
                    __int16 v53 = 2080;
                    uint64_t v54 = v40;
                    __int16 v55 = 2080;
                    uint64_t v56 = v39;
                    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Call on sim %s is held. Dial RetrieveOnceReady call %s on the other sim (%s)", buf, 0x20u);
                    if (v45 < 0) {
                      operator delete(__p[0]);
                    }
                  }
                  *(unsigned char *)(v20 + 752) = 0;
                  sub_1013D8F68(v20);
                  break;
                case 5:
                case 8:
                  int v22 = a1[5];
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v23 = subscriber::asString();
                    sub_1013D8DEC(v20);
                    int v24 = v45;
                    uint64_t v25 = (void **)__p[0];
                    uint64_t v26 = subscriber::asString();
                    *(_DWORD *)long long buf = 136315650;
                    uint64_t v27 = __p;
                    if (v24 < 0) {
                      uint64_t v27 = v25;
                    }
                    *(void *)&uint8_t buf[4] = v23;
                    __int16 v53 = 2080;
                    uint64_t v54 = v27;
                    __int16 v55 = 2080;
                    uint64_t v56 = v26;
                    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Call on sim %s is held. Answer RetrieveOnceReady call %s on sim %s", buf, 0x20u);
                    if (v45 < 0) {
                      operator delete(__p[0]);
                    }
                  }
                  *(unsigned char *)(v20 + 752) = 0;
                  sub_100058DB0(buf, "");
                  sub_1013D9708(v20, (long long *)buf);
                  if (SHIBYTE(v55) < 0) {
                    operator delete(*(void **)buf);
                  }
                  break;
                default:
                  goto LABEL_40;
              }
              int v21 = 6;
              if (!v19) {
                goto LABEL_42;
              }
            }
            else
            {
              int v21 = 7;
LABEL_40:
              if (!v19) {
                goto LABEL_42;
              }
            }
            sub_10004D2C8(v19);
LABEL_42:
            if (v21 == 7 || !v21)
            {
              v17 += 2;
              if (v17 != v18) {
                continue;
              }
            }
            break;
          }
        }
        *(void *)long long buf = &v49;
        sub_10005CBF0((void ***)buf);
        unint64_t v6 = v41;
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100839F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  *(void *)(v27 - 128) = &a27;
  sub_10005CBF0((void ***)(v27 - 128));
  sub_10004D2C8(a9);
  _Unwind_Resume(a1);
}

void sub_10083A020(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        long long v29 = 0uLL;
        int v30 = 0;
        if (*(_DWORD *)(a2 + 92) == CallInfo::kDefaultCallId)
        {
          if (&v29 != (long long *)(v7 + 120))
          {
            uint64_t v8 = *(char **)(v7 + 120);
            uint64_t v9 = *(char **)(v7 + 128);
            uint64_t v10 = v9 - v8;
            if (v9 == v8)
            {
              uint64_t v23 = sub_10019E238(*(uint64_t **)(v7 + 120), *(uint64_t **)(v7 + 128), 0);
              for (uint64_t i = (void *)*((void *)&v29 + 1); i != v23; i -= 2)
              {
                uint64_t v25 = (std::__shared_weak_count *)*(i - 1);
                if (v25) {
                  sub_10004D2C8(v25);
                }
              }
              *((void *)&v29 + 1) = v23;
            }
            else
            {
              sub_10019E074((uint64_t *)&v29);
              if (v10 < 0) {
                goto LABEL_32;
              }
              uint64_t v11 = v10 >> 4;
              uint64_t v12 = (uint64_t)&v30[-v29];
              if ((uint64_t)&v30[-v29] >> 3 > (unint64_t)(v10 >> 4)) {
                uint64_t v11 = v12 >> 3;
              }
              unint64_t v13 = (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v11;
              if (v13 >> 60) {
LABEL_32:
              }
                sub_10006A748();
              long long v14 = sub_10006A794((uint64_t)&v30, v13);
              uint64_t v15 = 0;
              *(void *)&long long v29 = v14;
              *((void *)&v29 + 1) = v14;
              int v30 = (char *)&v14[2 * v16];
              uint64_t v17 = v14;
              do
              {
                *uint64_t v17 = *(void *)v8;
                uint64_t v18 = *((void *)v8 + 1);
                v17[1] = v18;
                if (v18) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
                }
                v15 += 2;
                v8 += 16;
                v17 += 2;
              }
              while (v8 != v9);
              *((void *)&v29 + 1) = &v14[v15];
            }
          }
        }
        else
        {
          sub_100245B5C((uint64_t)v26, a2);
          CallController::findAllCallsByCallId_sync((void **)v7, (uint64_t)v26, (uint64_t *)&buf);
          sub_10019E074((uint64_t *)&v29);
          long long v29 = buf;
          int v30 = v28;
          p_long long buf = (void **)&buf;
          int v28 = 0;
          long long buf = 0uLL;
          sub_10005CBF0(&p_buf);
          sub_1002243E8((uint64_t)v26);
        }
        uint64_t v19 = a1[5];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Calls going to active (due to being merged!)", (uint8_t *)&buf, 2u);
        }
        int v21 = (uint64_t *)*((void *)&v29 + 1);
        for (uint64_t j = (uint64_t *)v29; j != v21; j += 2)
        {
          uint64_t v22 = *j;
          sub_100B228F4(*(void *)(*j + 680));
          *(unsigned char *)(v22 + 189) = 1;
          sub_1013D9588(*j);
        }
        CallController::updateRestCallValues((CallController *)v7);
        *(void *)&long long buf = &v29;
        sub_10005CBF0((void ***)&buf);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083A288(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002243E8((uint64_t)va);
  *(void *)(v3 - 128) = v3 - 96;
  sub_10005CBF0((void ***)(v3 - 128));
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_10083A2C4(uint64_t a1, const std::string *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      if (*(void *)(a1 + 64))
      {
        *(_OWORD *)std::string __p = 0u;
        long long v9 = 0u;
        long long v7 = 0u;
        std::string::operator=((std::string *)&__p[1], a2 + 17);
        sub_10083A39C();
        if (SHIBYTE(v9) < 0) {
          operator delete(__p[1]);
        }
        uint64_t v10 = (void **)&v7;
        sub_100047F64(&v10);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083A380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10083A474((uint64_t)&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10083A39C()
{
  xpc_object_t v3 = 0;
  write_rest_value();
  sub_100058DB0(&__p, "/cc/events/call_control_failure");
  xpc_object_t object = v3;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10083A430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10083A474(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  xpc_object_t v3 = (void **)(a1 + 32);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10083A4D0(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[9];
  if (v2)
  {
    xpc_object_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (a1[8])
      {
        BOOL v5 = a1[5];
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v6[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Hold or Unhold failed, so sending rest::call_control_failure event!", (uint8_t *)v6, 2u);
        }
        *(_OWORD *)std::string __p = 0u;
        long long v10 = 0u;
        long long v7 = 0u;
        long long v8 = 0u;
        *(_OWORD *)unint64_t v6 = 0u;
        DWORD2(v7) = 3;
        sub_10083A39C();
        if (SHIBYTE(v10) < 0) {
          operator delete(__p[1]);
        }
        uint64_t v11 = (void **)&v8;
        sub_100047F64(&v11);
        if (SBYTE7(v7) < 0) {
          operator delete(v6[0]);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083A5B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10083A474((uint64_t)&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10083A5D4(void *a1, const std::string *a2)
{
  xpc_object_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        long long v8 = a1[5];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v11[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Answer call failed so going back to ringing & sending a status notifi of Ringing again", (uint8_t *)v11, 2u);
        }
        *(_OWORD *)std::string __p = 0u;
        long long v15 = 0u;
        long long v12 = 0u;
        long long v13 = 0u;
        *(_OWORD *)uint64_t v11 = 0u;
        std::string::operator=((std::string *)v11, a2);
        DWORD2(v12) = 1;
        sub_10083A39C();
        long long v9 = *(uint64_t **)(v7 + 120);
        long long v10 = *(uint64_t **)(v7 + 128);
        while (v9 != v10)
        {
          sub_1013DA080(*v9);
          v9 += 2;
        }
        if (SHIBYTE(v15) < 0) {
          operator delete(__p[1]);
        }
        uint64_t v16 = (void **)&v13;
        sub_100047F64(&v16);
        if (SBYTE7(v12) < 0) {
          operator delete(v11[0]);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083A6E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10083A474((uint64_t)&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10083A708(void *a1, int a2)
{
  xpc_object_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        long long v8 = *(uint64_t ***)(v7 + 120);
        long long v9 = *(uint64_t ***)(v7 + 128);
        if (v8 != v9)
        {
          if (a2) {
            long long v10 = "ECBM";
          }
          else {
            long long v10 = "IMS Emergency Mode";
          }
          do
          {
            unsigned int v11 = sub_1013296D4((Registry **)(v7 + 56), *((unsigned int *)*v8 + 89), *v8);
            long long v12 = *v8;
            if (!v11 && *((_DWORD *)v12 + 174) || (v12[21] & 0xFFFFFFFE) == 2)
            {
              long long v13 = a1[5];
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
              {
                sub_1013D8DEC((uint64_t)v12);
                long long v14 = __p;
                if (v23 < 0) {
                  long long v14 = (void **)__p[0];
                }
                *(_DWORD *)long long buf = 136315394;
                uint64_t v25 = v10;
                __int16 v26 = 2080;
                uint64_t v27 = v14;
                _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s exited but %s will be dialed as an emergency call. Not doing anything.", buf, 0x16u);
                if (v23 < 0) {
                  operator delete(__p[0]);
                }
              }
            }
            else
            {
              BOOL v15 = CallController::carrierBlocksCallsOverCS_sync(v7, *((_DWORD *)v12 + 89), 1);
              int isSimUsable = CallController::isSimUsable(v7, *((_DWORD *)*v8 + 89));
              BOOL IMSVoiceStatusForSim_sync = CallController::getIMSVoiceStatusForSim_sync(v7, *((_DWORD *)*v8 + 89));
              if ((v15 & isSimUsable ^ 1 | IMSVoiceStatusForSim_sync))
              {
                uint64_t v18 = a1[5];
                if (!v15 || IMSVoiceStatusForSim_sync)
                {
                  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_1013D8DEC((uint64_t)*v8);
                    uint64_t v19 = __p;
                    if (v23 < 0) {
                      uint64_t v19 = (void **)__p[0];
                    }
                    *(_DWORD *)long long buf = 136315394;
                    uint64_t v25 = v10;
                    __int16 v26 = 2080;
                    uint64_t v27 = v19;
                    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s exited so telling %s to go to dialing!!", buf, 0x16u);
                    if (v23 < 0) {
                      operator delete(__p[0]);
                    }
                  }
                  sub_1013D8F68((uint64_t)*v8);
                }
                else
                {
                  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(__p[0]) = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "We have exited emergency mode but will drop the call as carrier has blocked CS calling and we are not on IMS!", (uint8_t *)__p, 2u);
                  }
                  int v21 = *v8;
                  if (!*((unsigned char *)*v8 + 228))
                  {
                    *((_DWORD *)v21 + 56) = 1;
                    *((unsigned char *)v21 + 228) = 1;
                  }
                  sub_1013D9E58((uint64_t)v21);
                }
              }
              else
              {
                *((unsigned char *)*v8 + 754) = 1;
                uint64_t v20 = a1[5];
                if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(__p[0]) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I We have exited emergency mode but need to wait for IMS registraton!!", (uint8_t *)__p, 2u);
                }
              }
            }
            v8 += 2;
          }
          while (v8 != v9);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083AA14(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083AA3C(uint64_t a1, unsigned int a2)
{
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 64);
      if (v7) {
        CallController::notifyCallCapabilities_sync(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083AAB0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083AAC4(uint64_t a1, const CallInfo *a2)
{
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = *(const void ***)(a1 + 64);
      if (v7) {
        CallController::setCallerIdForCall_sync(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083AB38(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10083AB4C(uint64_t a1, int a2)
{
  uint64_t v3 = CallInfo::kDefaultCallId;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    unint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      long long v8 = *(void ***)(a1 + 64);
      if (v8)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        CallController::getCurrentCallsDialedOnSim_sync(v8, a2, 0, &v10);
        if (v10 != v11) {
          uint64_t v3 = *(unsigned int *)(*(void *)v10 + 196);
        }
        long long v13 = (void **)&v10;
        sub_10005CBF0(&v13);
      }
      sub_10004D2C8(v7);
    }
  }
  return v3;
}

void sub_10083ABF0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10083AC04(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    uint64_t v5 = (uint64_t)(*(void *)(v4 + 128) - *(void *)(v4 + 120)) >> 4;
  }
  else {
    uint64_t v5 = 0;
  }
  sub_10004D2C8(v3);
  return v5;
}

void sub_10083AC60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(a1 + 64);
      if (v13)
      {
        uint64_t v14 = 0;
        BOOL v15 = 0;
        CallController::getPreferredDriverForSim(v13, a5, &v14);
        if (v14) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 296))(v14, a2, a3, a4, a5);
        }
        if (v15) {
          sub_10004D2C8(v15);
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_10083AD50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10083AD70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    long long v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 64);
      if (v11)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        CallController::getPreferredDriverForSim(v11, a4, &v12);
        if (v12) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 304))(v12, a2, a3, a4);
        }
        if (v13) {
          sub_10004D2C8(v13);
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10083AE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10083AE78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 64);
      if (v9)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        CallController::getPreferredDriverForSim(v9, a3, &v10);
        if (v10)
        {
          (*(void (**)(uint64_t, void, void, uint64_t, uint64_t))(*(void *)v10 + 296))(v10, kVoicePrivacyKey, 0, a2, a3);
          (*(void (**)(void, uint64_t))(**(void **)(v9 + 368) + 48))(*(void *)(v9 + 368), a2);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083AF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10083AFAC(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 64);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 256);
        uint64_t v7 = *(std::__shared_weak_count **)(v5 + 264);
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083B05C(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083B07C(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 64);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 256);
        uint64_t v7 = *(std::__shared_weak_count **)(v5 + 264);
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083B12C(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_10083B14C(void *a1, char a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 92);
  uint64_t v27 = 0;
  sub_10012A394(&v27, (const void **)a3);
  uint64_t v7 = (std::__shared_weak_count *)a1[9];
  if (v7)
  {
    long long v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = a1[8];
      if (v10)
      {
        uint64_t v25 = 0;
        __int16 v26 = 0;
        if (v27) {
          uint64_t v11 = sub_100136254;
        }
        else {
          uint64_t v11 = 0;
        }
        if (v11) {
          CallController::findCallByUuid_sync((const void **)v10, &v27, (uint64_t *)v20);
        }
        else {
          CallController::findCallByCallId_sync((CallController *)v10, v6, 0, v20);
        }
        uint64_t v12 = (std::__shared_weak_count *)v20[1];
        uint64_t v25 = v20[0];
        __int16 v26 = (std::__shared_weak_count *)v20[1];
        if (v20[0])
        {
          if ((a2 & 1) == 0)
          {
            CallController::sendCallControlErrorNotificaton_sync(v10, (uint64_t *)&v25, 1);
            uint64_t v18 = a1[5];
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v20[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E Make private conversation failed. Sending call control error.", (uint8_t *)v20, 2u);
            }
            *(_OWORD *)std::string __p = 0u;
            long long v24 = 0u;
            long long v21 = 0u;
            long long v22 = 0u;
            *(_OWORD *)uint64_t v20 = 0u;
            std::string::operator=((std::string *)&__p[1], (const std::string *)(a3 + 408));
            DWORD2(v21) = 4;
            sub_10083A39C();
            if (SHIBYTE(v24) < 0) {
              operator delete(__p[1]);
            }
            int v28 = (void **)&v22;
            sub_100047F64(&v28);
            if (SBYTE7(v21) < 0) {
              operator delete(v20[0]);
            }
            uint64_t v17 = v26;
            if (!v26) {
              goto LABEL_31;
            }
            goto LABEL_30;
          }
          *((unsigned char *)v20[0] + 189) = 0;
          uint64_t v14 = *(char **)(v10 + 120);
          uint64_t v13 = *(char **)(v10 + 128);
          if (v13 != v14 && v13 - v14 == 32)
          {
            do
            {
              uint64_t v16 = *(void *)v14;
              BOOL v15 = (std::__shared_weak_count *)*((void *)v14 + 1);
              if (v15) {
                atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (*(unsigned char *)(v16 + 189)) {
                *(unsigned char *)(v16 + 189) = 0;
              }
              if (v15) {
                sub_10004D2C8(v15);
              }
              v14 += 16;
            }
            while (v14 != v13);
          }
        }
        CallController::updateRestCallValues((CallController *)v10);
        if (v12)
        {
          uint64_t v17 = v12;
LABEL_30:
          sub_10004D2C8(v17);
        }
      }
LABEL_31:
      sub_10004D2C8(v9);
    }
  }
  return sub_10012577C(&v27);
}

void sub_10083B344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_10004D2C8(v20);
  sub_10012577C((const void **)(v21 - 64));
  _Unwind_Resume(a1);
}

void CallCommandDriverDelegate::processRemainingDTMFDigits(CallCommandDriverDelegate *this)
{
  char v2 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *((void *)this + 8);
      if (v5)
      {
        int v6 = *(uint64_t ***)(v5 + 120);
        uint64_t v7 = *(uint64_t ***)(v5 + 128);
        while (v6 != v7)
        {
          if (*((unsigned char *)*v6 + 188))
          {
            sub_1013DAAAC(*v6);
            break;
          }
          v6 += 2;
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083B404(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083B418(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v4)
  {
    uint64_t v5 = 0;
    goto LABEL_10;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v4);
  if (!v5 || (uint64_t v6 = *(void *)(a1 + 64)) == 0)
  {
LABEL_10:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    if (!v5) {
      return;
    }
    goto LABEL_7;
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v7 = *(void **)(v6 + 120);
  long long v8 = *(void **)(v6 + 128);
  if (v7 == v8) {
    goto LABEL_7;
  }
  do
  {
    sub_100245B5C((uint64_t)v9, *v7 + 104);
    sub_1008407E4(a2, (uint64_t)v9);
    sub_1002243E8((uint64_t)v9);
    v7 += 2;
  }
  while (v7 != v8);
  if (v5) {
LABEL_7:
  }
    sub_10004D2C8(v5);
}

void sub_10083B4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002243E8((uint64_t)&a9);
  *(void *)(v11 - 56) = v10;
  sub_1002244D8((void ***)(v11 - 56));
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_10083B504(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 64);
      if (v7)
      {
        long long v8 = *(uint64_t **)(v7 + 120);
        uint64_t v9 = *(uint64_t **)(v7 + 128);
        if (v8 != v9)
        {
          while (1)
          {
            uint64_t v10 = *v8;
            uint64_t v11 = (std::__shared_weak_count *)v8[1];
            if (v11) {
              atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (!*(_DWORD *)(v10 + 160)) {
              break;
            }
            if (v11) {
              goto LABEL_9;
            }
LABEL_10:
            v8 += 2;
            if (v8 == v9) {
              goto LABEL_18;
            }
          }
          uint64_t v12 = v10 + 104;
          unint64_t v13 = a2[1];
          if (v13 >= a2[2])
          {
            uint64_t v14 = sub_100840BB0(a2, v12);
          }
          else
          {
            sub_100245B5C(a2[1], v12);
            uint64_t v14 = v13 + 408;
            a2[1] = v13 + 408;
          }
          a2[1] = v14;
          if (!v11) {
            goto LABEL_10;
          }
LABEL_9:
          sub_10004D2C8(v11);
          goto LABEL_10;
        }
      }
LABEL_18:
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083B618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10004D2C8(v2);
  sub_1002244D8((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10083B654(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 64);
  if (!v7 || (v8 = *(uint64_t **)(v7 + 120), uint64_t v9 = *(uint64_t **)(v7 + 128), v8 == v9))
  {
LABEL_10:
    uint64_t v12 = 0;
    goto LABEL_11;
  }
  while (1)
  {
    uint64_t v11 = *v8;
    uint64_t v10 = (std::__shared_weak_count *)v8[1];
    if (!v10) {
      break;
    }
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(_DWORD *)(v11 + 160) == 8) {
      goto LABEL_14;
    }
    sub_10004D2C8(v10);
LABEL_9:
    v8 += 2;
    if (v8 == v9) {
      goto LABEL_10;
    }
  }
  if (*(_DWORD *)(v11 + 160) != 8) {
    goto LABEL_9;
  }
LABEL_14:
  sub_100224390((const void **)a2, (const void **)(v11 + 104));
  std::string::operator=((std::string *)(a2 + 8), (const std::string *)(v11 + 112));
  std::string::operator=((std::string *)(a2 + 32), (const std::string *)(v11 + 136));
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(v11 + 160);
  long long v14 = *(_OWORD *)(v11 + 176);
  long long v15 = *(_OWORD *)(v11 + 192);
  long long v16 = *(_OWORD *)(v11 + 208);
  *(void *)(a2 + 117) = *(void *)(v11 + 221);
  *(_OWORD *)(a2 + 104) = v16;
  *(_OWORD *)(a2 + 88) = v15;
  *(_OWORD *)(a2 + 72) = v14;
  std::string::operator=((std::string *)(a2 + 128), (const std::string *)(v11 + 232));
  *(_DWORD *)(a2 + 152) = *(_DWORD *)(v11 + 256);
  std::string::operator=((std::string *)(a2 + 160), (const std::string *)(v11 + 264));
  long long v17 = *(_OWORD *)(v11 + 288);
  *(_OWORD *)(a2 + 193) = *(_OWORD *)(v11 + 297);
  *(_OWORD *)(a2 + 184) = v17;
  sub_100840CD0(a2 + 216, v11 + 320);
  long long v18 = *(_OWORD *)(v11 + 352);
  *(unsigned char *)(a2 + 264) = *(unsigned char *)(v11 + 368);
  *(_OWORD *)(a2 + 248) = v18;
  std::string::operator=((std::string *)(a2 + 272), (const std::string *)(v11 + 376));
  std::string::operator=((std::string *)(a2 + 296), (const std::string *)(v11 + 400));
  long long v19 = *(_OWORD *)(v11 + 440);
  *(_OWORD *)(a2 + 320) = *(_OWORD *)(v11 + 424);
  *(_OWORD *)(a2 + 336) = v19;
  long long v20 = *(_OWORD *)(v11 + 456);
  long long v21 = *(_OWORD *)(v11 + 472);
  long long v22 = *(_OWORD *)(v11 + 488);
  *(void *)(a2 + 397) = *(void *)(v11 + 501);
  *(_OWORD *)(a2 + 368) = v21;
  *(_OWORD *)(a2 + 384) = v22;
  *(_OWORD *)(a2 + 352) = v20;
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v12 = 1;
LABEL_11:
  sub_10004D2C8(v6);
  return v12;
}

void sub_10083B804(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10083B824(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 64);
  if (!v7 || (v8 = *(uint64_t **)(v7 + 120), uint64_t v9 = *(uint64_t **)(v7 + 128), v8 == v9))
  {
LABEL_10:
    uint64_t v12 = 0;
    goto LABEL_11;
  }
  while (1)
  {
    uint64_t v11 = *v8;
    uint64_t v10 = (std::__shared_weak_count *)v8[1];
    if (!v10) {
      break;
    }
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(_DWORD *)(v11 + 160) == 7) {
      goto LABEL_14;
    }
    sub_10004D2C8(v10);
LABEL_9:
    v8 += 2;
    if (v8 == v9) {
      goto LABEL_10;
    }
  }
  if (*(_DWORD *)(v11 + 160) != 7) {
    goto LABEL_9;
  }
LABEL_14:
  sub_100224390((const void **)a2, (const void **)(v11 + 104));
  std::string::operator=((std::string *)(a2 + 8), (const std::string *)(v11 + 112));
  std::string::operator=((std::string *)(a2 + 32), (const std::string *)(v11 + 136));
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(v11 + 160);
  long long v14 = *(_OWORD *)(v11 + 176);
  long long v15 = *(_OWORD *)(v11 + 192);
  long long v16 = *(_OWORD *)(v11 + 208);
  *(void *)(a2 + 117) = *(void *)(v11 + 221);
  *(_OWORD *)(a2 + 104) = v16;
  *(_OWORD *)(a2 + 88) = v15;
  *(_OWORD *)(a2 + 72) = v14;
  std::string::operator=((std::string *)(a2 + 128), (const std::string *)(v11 + 232));
  *(_DWORD *)(a2 + 152) = *(_DWORD *)(v11 + 256);
  std::string::operator=((std::string *)(a2 + 160), (const std::string *)(v11 + 264));
  long long v17 = *(_OWORD *)(v11 + 288);
  *(_OWORD *)(a2 + 193) = *(_OWORD *)(v11 + 297);
  *(_OWORD *)(a2 + 184) = v17;
  sub_100840CD0(a2 + 216, v11 + 320);
  long long v18 = *(_OWORD *)(v11 + 352);
  *(unsigned char *)(a2 + 264) = *(unsigned char *)(v11 + 368);
  *(_OWORD *)(a2 + 248) = v18;
  std::string::operator=((std::string *)(a2 + 272), (const std::string *)(v11 + 376));
  std::string::operator=((std::string *)(a2 + 296), (const std::string *)(v11 + 400));
  long long v19 = *(_OWORD *)(v11 + 440);
  *(_OWORD *)(a2 + 320) = *(_OWORD *)(v11 + 424);
  *(_OWORD *)(a2 + 336) = v19;
  long long v20 = *(_OWORD *)(v11 + 456);
  long long v21 = *(_OWORD *)(v11 + 472);
  long long v22 = *(_OWORD *)(v11 + 488);
  *(void *)(a2 + 397) = *(void *)(v11 + 501);
  *(_OWORD *)(a2 + 368) = v21;
  *(_OWORD *)(a2 + 384) = v22;
  *(_OWORD *)(a2 + 352) = v20;
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v12 = 1;
LABEL_11:
  sub_10004D2C8(v6);
  return v12;
}

void sub_10083B9D4(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083B9F4(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 64);
      if (v7)
      {
        long long v8 = *(uint64_t **)(v7 + 120);
        for (uint64_t i = *(uint64_t **)(v7 + 128); v8 != i; v8 += 2)
        {
          uint64_t v10 = *v8;
          uint64_t v11 = (std::__shared_weak_count *)v8[1];
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (*(_DWORD *)(v10 + 160) == 1)
          {
            uint64_t v12 = v10 + 104;
            unint64_t v13 = a2[1];
            if (v13 >= a2[2])
            {
              uint64_t v14 = sub_100840BB0(a2, v12);
            }
            else
            {
              sub_100245B5C(a2[1], v12);
              uint64_t v14 = v13 + 408;
              a2[1] = v13 + 408;
            }
            a2[1] = v14;
          }
          if (v11) {
            sub_10004D2C8(v11);
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083BB00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10004D2C8(v2);
  sub_1002244D8((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10083BB3C(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v4) {
    return 0;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return 0;
  }
  long long v8 = v7;
  uint64_t v9 = *(void *)(a1 + 64);
  if (!v9 || (uint64_t v10 = *(uint64_t **)(v9 + 120), v11 = *(uint64_t **)(v9 + 128), v10 == v11))
  {
LABEL_11:
    uint64_t v15 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v13 = *v10;
      uint64_t v12 = (std::__shared_weak_count *)v10[1];
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v14 = (CFTypeRef *)sub_1013D824C(v13);
      if (CFEqual(*v14, *a2)) {
        break;
      }
      if (v12) {
        sub_10004D2C8(v12);
      }
      v10 += 2;
      if (v10 == v11) {
        goto LABEL_11;
      }
    }
    sub_100224390((const void **)a3, (const void **)(v13 + 104));
    std::string::operator=((std::string *)(a3 + 8), (const std::string *)(v13 + 112));
    std::string::operator=((std::string *)(a3 + 32), (const std::string *)(v13 + 136));
    *(_OWORD *)(a3 + 56) = *(_OWORD *)(v13 + 160);
    long long v17 = *(_OWORD *)(v13 + 176);
    long long v18 = *(_OWORD *)(v13 + 192);
    long long v19 = *(_OWORD *)(v13 + 208);
    *(void *)(a3 + 117) = *(void *)(v13 + 221);
    *(_OWORD *)(a3 + 104) = v19;
    *(_OWORD *)(a3 + 88) = v18;
    *(_OWORD *)(a3 + 72) = v17;
    std::string::operator=((std::string *)(a3 + 128), (const std::string *)(v13 + 232));
    *(_DWORD *)(a3 + 152) = *(_DWORD *)(v13 + 256);
    std::string::operator=((std::string *)(a3 + 160), (const std::string *)(v13 + 264));
    long long v20 = *(_OWORD *)(v13 + 288);
    *(_OWORD *)(a3 + 193) = *(_OWORD *)(v13 + 297);
    *(_OWORD *)(a3 + 184) = v20;
    sub_100840CD0(a3 + 216, v13 + 320);
    long long v21 = *(_OWORD *)(v13 + 352);
    *(unsigned char *)(a3 + 264) = *(unsigned char *)(v13 + 368);
    *(_OWORD *)(a3 + 248) = v21;
    std::string::operator=((std::string *)(a3 + 272), (const std::string *)(v13 + 376));
    std::string::operator=((std::string *)(a3 + 296), (const std::string *)(v13 + 400));
    long long v22 = *(_OWORD *)(v13 + 440);
    *(_OWORD *)(a3 + 320) = *(_OWORD *)(v13 + 424);
    *(_OWORD *)(a3 + 336) = v22;
    long long v23 = *(_OWORD *)(v13 + 456);
    long long v24 = *(_OWORD *)(v13 + 472);
    long long v25 = *(_OWORD *)(v13 + 488);
    *(void *)(a3 + 397) = *(void *)(v13 + 501);
    *(_OWORD *)(a3 + 368) = v24;
    *(_OWORD *)(a3 + 384) = v25;
    *(_OWORD *)(a3 + 352) = v23;
    if (v12) {
      sub_10004D2C8(v12);
    }
    uint64_t v15 = 1;
  }
  sub_10004D2C8(v8);
  return v15;
}

void sub_10083BCF0(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083BD14(uint64_t a1, void *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 64);
      if (v7)
      {
        subscriber::makeSimSlotRange();
        uint64_t v9 = v16;
        long long v8 = v17;
        if (v16 != v17)
        {
          uint64_t v10 = v18;
          while ((v18(*v9) & 1) == 0)
          {
            if (++v9 == v17)
            {
              uint64_t v9 = v17;
              break;
            }
          }
          uint64_t v11 = v17;
LABEL_10:
          while (v9 != v11)
          {
            int v12 = *v9;
            uint64_t v14 = 0;
            uint64_t v15 = 0;
            CallController::getPreferredDriverForSim(v7, v12, &v14);
            if (*a2 == v14) {
              CallController::forceEndAllCalls(v7, v12, 1);
            }
            if (v15) {
              sub_10004D2C8(v15);
            }
            uint64_t v13 = v9 + 1;
            uint64_t v9 = v8;
            if (v13 != v8)
            {
              uint64_t v9 = v13;
              while ((v10(*v9) & 1) == 0)
              {
                if (++v9 == v8)
                {
                  uint64_t v9 = v8;
                  goto LABEL_10;
                }
              }
            }
          }
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083BE3C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083BE58(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v7 = (std::__shared_weak_count *)a1[9];
  if (v7)
  {
    uint64_t v13 = std::__shared_weak_count::lock(v7);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = (void *)a1[8];
      if (v15)
      {
        uint64_t v16 = v15[30];
        if (!v16)
        {
          long long v17 = a1[5];
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I USSDService is NULL. Creating one to handle USSD indication!", buf, 2u);
          }
          uint64_t v49 = 0;
          long long v47 = 0u;
          long long v48 = 0u;
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          long long v31 = 0u;
          long long v32 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          long long v27 = 0u;
          long long v28 = 0u;
          long long v25 = 0u;
          long long v26 = 0u;
          *(_OWORD *)long long buf = 0u;
          sub_10057F630((uint64_t)buf);
          HIDWORD(v39) = a6;
          uint64_t v18 = v15[9];
          long long v19 = (std::__shared_weak_count *)v15[41];
          long long v22 = v19;
          if (v19) {
            atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(long long *__return_ptr))(*(void *)v18 + 48))(&v23);
          long long v20 = v23;
          long long v23 = 0uLL;
          long long v21 = (std::__shared_weak_count *)v15[31];
          *((_OWORD *)v15 + 15) = v20;
          if (v21)
          {
            sub_10004D2C8(v21);
            if (*((void *)&v23 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v23 + 1));
            }
          }
          if (v22) {
            sub_10004D2C8(v22);
          }
          sub_1002243E8((uint64_t)buf);
          uint64_t v16 = v15[30];
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 24))(v16, a2, a3, a4, a5);
      }
      sub_10004D2C8(v14);
    }
  }
}

void sub_10083C02C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  if (a3) {
    sub_10004D2C8(a3);
  }
  sub_1002243E8((uint64_t)va);
  sub_10004D2C8(v5);
  _Unwind_Resume(a1);
}

void sub_10083C060(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[9];
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = a1[8];
      if (v11)
      {
        uint64_t v12 = *(void *)(v11 + 240);
        if (v12)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, a2, a3, a4);
        }
        else
        {
          uint64_t v13 = a1[5];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v14 = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Got a reply to a USSD Send but USSDService is NULL. Not handling it.", v14, 2u);
          }
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10083C140(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083C154(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 64);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 112))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083C1D4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083C1E8(void *a1, int a2, uint64_t a3)
{
  unsigned int v24 = a3;
  uint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = a1[8];
      if (v9)
      {
        if (*(void *)(v9 + 120) == *(void *)(v9 + 128))
        {
          uint64_t v13 = a1[5];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            uint64_t v14 = "#E Received handleVoiceHandoverEvent with no calls, not sure what's intended";
            goto LABEL_12;
          }
        }
        else
        {
          CallController::getPreferredDriverForSim(a1[8], a3, &buf);
          uint64_t v10 = *(void *)(v9 + 184);
          uint64_t v11 = (capabilities::ct *)*((void *)&buf + 1);
          uint64_t v12 = buf;
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v12 == v10)
          {
            switch(a2)
            {
              case 1:
                (*(void (**)(void, uint64_t))(**(void **)(v9 + 368) + 24))(*(void *)(v9 + 368), 143);
                uint64_t v15 = (void (**)(void))(**(void **)(v9 + 200) + 16);
                goto LABEL_33;
              case 2:
                (*(void (**)(void, void))(**(void **)(v9 + 368) + 96))(*(void *)(v9 + 368), 0);
                uint64_t v18 = 0;
                goto LABEL_30;
              case 3:
                (*(void (**)(void, uint64_t))(**(void **)(v9 + 368) + 96))(*(void *)(v9 + 368), 1);
                *(void *)&long long buf = &v24;
                if (*((unsigned char *)sub_10005CE78((uint64_t **)(v9 + 472), (int *)&v24, (uint64_t)&unk_10144E20E, (_DWORD **)&buf)+ 32))
                {
                  long long v19 = a1[5];
                  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Got handover indication during Wifi call, ending all calls but not switching the driver", (uint8_t *)&buf, 2u);
                  }
                  long long v20 = *(uint64_t **)(v9 + 120);
                  long long v21 = *(uint64_t **)(v9 + 128);
                  while (v20 != v21)
                  {
                    if (*(_DWORD *)(*v20 + 356) == v24)
                    {
                      long long v22 = (const void **)sub_1013D824C(*v20);
                      sub_10012A394(&v23, v22);
                      CallController::endCall(v9, &v23);
                      sub_10012577C(&v23);
                    }
                    v20 += 2;
                  }
                }
                else
                {
                  (*(void (**)(void, void))(**(void **)(v9 + 200) + 24))(*(void *)(v9 + 200), v24);
                  CallController::setPreferredDriver_sync(v9, (CallCommandDriver **)(v9 + 168), v24, 0);
                }
                goto LABEL_13;
              case 4:
                (*(void (**)(void, void))(**(void **)(v9 + 368) + 96))(*(void *)(v9 + 368), 0);
                uint64_t v18 = 1;
LABEL_30:
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v9 + 200) + 32))(*(void *)(v9 + 200), v18, a3);
                goto LABEL_13;
              case 5:
                uint64_t v15 = (void (**)(void))(**(void **)(v9 + 368) + 24);
                goto LABEL_33;
              case 6:
                if (!capabilities::ct::supportsMidCallSRVCC(v11)) {
                  goto LABEL_13;
                }
                uint64_t v15 = (void (**)(void))(**(void **)(v9 + 168) + 248);
LABEL_33:
                (*v15)();
                break;
              default:
                uint64_t v16 = a1[5];
                if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v17 = asString();
                  LODWORD(buf) = 136315138;
                  *(void *)((char *)&buf + 4) = v17;
                  _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Received unhandled handover state: %s", (uint8_t *)&buf, 0xCu);
                }
                goto LABEL_13;
            }
            goto LABEL_13;
          }
          uint64_t v13 = a1[5];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            uint64_t v14 = "#E Received handleVoiceHandoverEvent while using EurekaCallCommandDriver, not sure what's intended";
LABEL_12:
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&buf, 2u);
          }
        }
      }
LABEL_13:
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083C644(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083C678(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a2 + 92);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Handling SRVCC update info for %u", buf, 8u);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[9];
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = a1[8];
      if (!v9)
      {
LABEL_32:
        sub_10004D2C8(v8);
        return;
      }
      uint64_t v27 = 0;
      long long v28 = 0;
      CallController::getPreferredDriverForSim(v9, *(_DWORD *)(a2 + 252), &v27);
      if (v27 == *(void *)(v9 + 184))
      {
        *(void *)long long buf = a2 + 252;
        int v12 = *((unsigned __int8 *)sub_10005CE78((uint64_t **)(v9 + 472), (int *)(a2 + 252), (uint64_t)&unk_10144E20E, (_DWORD **)buf)+ 32);
        uint64_t v13 = a1[5];
        BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
        if (!v12)
        {
          if (v14)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Received handleHandoverCallInfo while using other CallCommandDriver, not sure what's intended", buf, 2u);
          }
          goto LABEL_30;
        }
        if (v14)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Handover for Wifi call, terminating the call", buf, 2u);
        }
        uint64_t v15 = *(void *)(v9 + 168);
        sub_100245B5C((uint64_t)v26, a2);
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v15 + 152))(v15, v26);
        uint64_t v16 = v26;
      }
      else
      {
        if (*(void *)(v9 + 120) != *(void *)(v9 + 128))
        {
          uint64_t v23 = 0;
          unsigned int v24 = 0;
          sub_100836830(&v23, (uint64_t)a1, a2);
          if (v23)
          {
            CallController::setupWorldForCS(v9, &v23, 0);
            uint64_t v10 = a1[5];
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              sub_1013D8DEC(v23);
              uint64_t v11 = v30 >= 0 ? buf : *(uint8_t **)buf;
              *(_DWORD *)long long v31 = 136315138;
              long long v32 = v11;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Handover complete for: %s", v31, 0xCu);
              if (v30 < 0) {
                operator delete(*(void **)buf);
              }
            }
          }
          else
          {
            long long v19 = a1[5];
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              int v20 = *(_DWORD *)(a2 + 92);
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v20;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Could not find call for handover, call ID: %d. Ending BB call.", buf, 8u);
            }
            uint64_t v21 = *(void *)(v9 + 168);
            sub_100245B5C((uint64_t)v22, a2);
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v21 + 152))(v21, v22);
            sub_1002243E8((uint64_t)v22);
          }
          if (v24) {
            sub_10004D2C8(v24);
          }
          goto LABEL_30;
        }
        uint64_t v17 = a1[5];
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#E Received handleHandoverCallInfo with no calls, not sure what's intended, going to clean up the BB call", buf, 2u);
        }
        uint64_t v18 = *(void *)(v9 + 168);
        sub_100245B5C((uint64_t)v25, a2);
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v18 + 152))(v18, v25);
        uint64_t v16 = v25;
      }
      sub_1002243E8((uint64_t)v16);
LABEL_30:
      if (v28) {
        sub_10004D2C8(v28);
      }
      goto LABEL_32;
    }
  }
}

void sub_10083CA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,std::__shared_weak_count *a62)
{
  if (a62) {
    sub_10004D2C8(a62);
  }
  int v65 = *(std::__shared_weak_count **)(v63 - 120);
  if (v65) {
    sub_10004D2C8(v65);
  }
  sub_10004D2C8(v62);
  _Unwind_Resume(a1);
}

void CallCommandDriverDelegate::handleCallWaitingToneDone(CallCommandDriverDelegate *this)
{
  char v2 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      int v5 = (CallController *)*((void *)this + 8);
      if (v5) {
        CallController::sendCallWaitingTones_sync(v5, 0);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083CAFC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void CallCommandDriverDelegate::handleCallToneEnd(CallCommandDriverDelegate *this)
{
  char v2 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      int v5 = (int64x2_t *)*((void *)this + 8);
      if (v5)
      {
        if (v5[45].i64[1])
        {
          CallController::sendCallToneEndEvent_sync((uint64_t)v5, (const void **)(*(void *)(v5[43].i64[1] + (((unint64_t)v5[45].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * (v5[45].i64[0] & 0x1FF)));
          sub_10083CBD4(v5 + 43);
          if (!v5[45].i64[1]) {
            sub_10083CC40((void **)&v5[43]);
          }
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083CBC0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10083CBD4(int64x2_t *a1)
{
  sub_10012577C((const void **)(*(void *)(a1->i64[1] + (((unint64_t)a1[2].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                              + 8 * (a1[2].i64[0] & 0x1FF)));
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_10144F900);

  return sub_1008413B8((uint64_t)a1, 1);
}

void sub_10083CC40(void **a1)
{
  if (a1[5])
  {
    sub_1008413B8((uint64_t)a1, 0);
    sub_100841418(a1, 0);
  }
  else
  {
    uint64_t v3 = a1[1];
    for (uint64_t i = (uint64_t)a1[2]; (void *)i != v3; a1[2] = (void *)i)
    {
      operator delete(*(void **)(i - 8));
      uint64_t v3 = a1[1];
      uint64_t i = (uint64_t)a1[2] - 8;
    }
    a1[4] = 0;
  }

  sub_100841488(a1);
}

void sub_10083CCC4(uint64_t a1, uint64_t a2, const void **a3, ctu *a4)
{
  int v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 64);
      if (v11)
      {
        sub_10012A394(&v12, a3);
        CallController::handleCallFrequencyLevelUpdate_sync(v11, a2, &v12, a4);
        sub_10012577C(&v12);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_10083CD54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10012577C((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_10083CD70(void *a1)
{
  char v2 = (std::__shared_weak_count *)a1[9];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[8];
      if (v5)
      {
        uint64_t v6 = a1[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Moving all calls to WaitingToDisconnect since user pressed end", v10, 2u);
        }
        uint64_t v7 = *(uint64_t **)(v5 + 120);
        long long v8 = *(uint64_t **)(v5 + 128);
        while (v7 != v8)
        {
          uint64_t v9 = *v7;
          char v11 = 0;
          sub_1013EB65C(*(void *)(v9 + 760), (uint64_t)&v11, 1);
          v7 += 2;
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10083CE2C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083CE40(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = a1[8];
      if (!v9)
      {
LABEL_51:
        sub_10004D2C8(v8);
        return;
      }
      uint64_t v31 = 0;
      long long v32 = 0;
      sub_10083D490(&v31, (uint64_t)a1, a2);
      uint64_t v10 = a1[5];
      if (!v31)
      {
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "IMSSilentRedial failed: null call", (uint8_t *)&__p, 2u);
        }
        goto LABEL_49;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        sub_10012A394(&v30, (const void **)a2);
        printUuid();
        int v11 = SHIBYTE(v34);
        int v12 = (long long *)__p;
        uint64_t v13 = asString();
        p_p = &__p;
        if (v11 < 0) {
          p_p = v12;
        }
        buf[0] = 136315394;
        *(void *)&buf[1] = p_p;
        LOWORD(buf[3]) = 2080;
        *(void *)((char *)&buf[3] + 2) = v13;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I IMSSilentRedial call %s requested: %s", (uint8_t *)buf, 0x16u);
        if (SHIBYTE(v34) < 0) {
          operator delete((void *)__p);
        }
        sub_10012577C(&v30);
      }
      int v15 = 0;
      switch(a3)
      {
        case 0:
          goto LABEL_13;
        case 1:
          int v15 = 1;
LABEL_13:
          uint64_t v16 = v31;
          if ((*(_DWORD *)(v31 + 168) & 0xFFFFFFFE) == 2)
          {
            int v17 = 1;
LABEL_25:
            if (isCallAllowedToRedial())
            {
              int v19 = 1;
LABEL_27:
              if (a3 == 2)
              {
                sub_1013D8CB0(v31, 2);
              }
              else if (!a3)
              {
                *(unsigned char *)(v31 + 753) = 1;
              }
              if (v19)
              {
                if (!*(unsigned char *)(v9 + 2064))
                {
                  *(unsigned char *)(v9 + 2064) = 1;
                  uint64_t v21 = *(void *)(v9 + 2056);
                  if (v21) {
                    (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 48))(v21, v9 + 2064);
                  }
                }
              }
              if (v17)
              {
                CallController::setPreferredDriver_sync(v9, (CallCommandDriver **)(v9 + 184), *(unsigned int *)(a2 + 252), 0);
                CallController::fetchAndSetPhoneCallSubType_sync(v9, &v31);
                long long __p = 0uLL;
                uint64_t v34 = 0;
                PersonalityIdFromSlotIdEx();
                pthread_mutex_lock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
                uint64_t v22 = xmmword_101B0AA30;
                if (!(void)xmmword_101B0AA30) {
                  sub_1008415C0();
                }
                if (*((void *)&xmmword_101B0AA30 + 1)) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&xmmword_101B0AA30 + 1) + 8), 1uLL, memory_order_relaxed);
                }
                pthread_mutex_unlock(&ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance);
                sub_1005021E8(v22);
              }
              uint64_t v23 = a1[5];
              BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
              uint64_t v25 = v31;
              if (v24)
              {
                sub_1013D8DEC(v31);
                if (v34 >= 0) {
                  long long v26 = &__p;
                }
                else {
                  long long v26 = (long long *)__p;
                }
                buf[0] = 136315138;
                *(void *)&buf[1] = v26;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#N IMSSilentRedial call %s over IMS", (uint8_t *)buf, 0xCu);
                if (SHIBYTE(v34) < 0) {
                  operator delete((void *)__p);
                }
                uint64_t v25 = v31;
              }
              sub_1013D9228(v25);
            }
            else
            {
              uint64_t v27 = a1[5];
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                uint64_t v29 = callStateToString();
                LODWORD(__p) = 136315138;
                *(void *)((char *)&__p + 4) = v29;
                _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "IMSSilentRedial failed: status %s not allowed", (uint8_t *)&__p, 0xCu);
              }
              if (v15) {
                sub_1013D9C48(v31);
              }
              else {
                sub_1013D9E58(v31);
              }
            }
            goto LABEL_49;
          }
          int v20 = a1[5];
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            long long v28 = "false";
            if (v15) {
              long long v28 = "true";
            }
            LODWORD(__p) = 136315138;
            *(void *)((char *)&__p + 4) = v28;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "IMSSilentRedial failed: not an emergency call. Requires manual release: %s", (uint8_t *)&__p, 0xCu);
            uint64_t v16 = v31;
            if (v15) {
              goto LABEL_23;
            }
          }
          else if (v15)
          {
LABEL_23:
            sub_1013D9C48(v16);
            goto LABEL_49;
          }
          sub_1013D9E58(v16);
LABEL_49:
          if (v32) {
            sub_10004D2C8(v32);
          }
          goto LABEL_51;
        case 2:
          uint64_t v18 = v31;
          int v17 = 0;
          int v15 = 0;
          if (*(unsigned char *)(v31 + 508))
          {
            *(_WORD *)(v31 + 504) = 258;
          }
          else
          {
            *(unsigned char *)(v31 + 496) = 0;
            *(unsigned char *)(v18 + 500) = 0;
            *(_WORD *)(v18 + 504) = 258;
            *(unsigned char *)(v18 + 508) = 1;
          }
          goto LABEL_25;
        case 3:
          int v15 = 1;
          goto LABEL_20;
        default:
LABEL_20:
          int v19 = 0;
          int v17 = v15;
          goto LABEL_27;
      }
    }
  }
}

void sub_10083D3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_10083D490(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 72);
  if (v4 && (uint64_t v7 = std::__shared_weak_count::lock(v4)) != 0)
  {
    long long v8 = v7;
    uint64_t v9 = *(const void ***)(a2 + 64);
    *a1 = 0;
    a1[1] = 0;
    if (v9)
    {
      CallController::findCallByUuid_sync(v9, (const void **)a3, a1);
      if (!*a1)
      {
        CallController::findCallByCallId_sync((CallController *)v9, *(_DWORD *)(a3 + 92), 1, &v12);
        long long v10 = v12;
        long long v12 = 0uLL;
        int v11 = (std::__shared_weak_count *)a1[1];
        *(_OWORD *)a1 = v10;
        if (v11)
        {
          sub_10004D2C8(v11);
          if (*((void *)&v12 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
          }
        }
      }
    }
    sub_10004D2C8(v8);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_10083D54C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083D574(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4 && (uint64_t v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 64);
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 + 272);
      uint64_t v7 = *(void *)(v6 + 280);
      *a2 = v8;
      a2[1] = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
    }
    sub_10004D2C8(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_10083D5F0(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 64);
      if (v9) {
        CallController::handleMediaStackSwitchComplete(v9, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083D66C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083D680(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        uint64_t v8 = a1[5];
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = (void *)(a2 + 32);
          if (*(char *)(a2 + 55) < 0) {
            uint64_t v9 = (void *)*v9;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I dialNewCallForATCommands dialing: %s", (uint8_t *)&buf, 0xCu);
        }
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 1174405120;
        v15[2] = sub_10083D8AC;
        void v15[3] = &unk_101A0F900;
        void v15[4] = v7;
        uint64_t v16 = v6;
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_100245B5C((uint64_t)v17, a2);
        long long v10 = (std::__shared_weak_count *)a1[2];
        if (!v10 || (uint64_t v11 = a1[1], (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v13 = v12;
        BOOL v14 = a1[3];
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 1174405120;
        int v19 = sub_1008419A0;
        int v20 = &unk_101A0FA40;
        uint64_t v22 = v11;
        uint64_t v23 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v21 = v15;
        dispatch_async(v14, &buf);
        if (v23) {
          sub_10004D2C8(v23);
        }
        sub_10004D2C8(v13);
        sub_1002243E8((uint64_t)v17);
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083D878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_10083D8AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(a1 + 80);
    uint64_t v5 = *(void *)(a1 + 96);
  }
  sub_100058DB0(__p, "");
  CallController::dial_sync(v2, (uint64_t)__dst, (uint64_t)__p, 0, *(_DWORD *)(a1 + 300));
}

void sub_10083D964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10083D998(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return sub_100245B5C(a1 + 48, a2 + 48);
}

void sub_10083D9DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 40);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10083D9F4(uint64_t a1)
{
  sub_1002243E8(a1 + 48);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_10083DA40(void *a1, const void **a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = (const void **)a1[8];
      if (v7)
      {
        uint64_t v16 = 0;
        int v17 = 0;
        CallController::findCallByUuid_sync(v7, a2, &v16);
        uint64_t v8 = v16;
        if (v16)
        {
          uint64_t v9 = a1[5];
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            sub_1013D8DEC(v8);
            if ((SBYTE7(v12) & 0x80u) == 0) {
              long long v10 = __p;
            }
            else {
              long long v10 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Call dial failed. Ending the call %s!", buf, 0xCu);
            if (SBYTE7(v12) < 0) {
              operator delete(__p[0]);
            }
            uint64_t v8 = v16;
          }
          *(_OWORD *)BOOL v14 = 0u;
          long long v15 = 0u;
          long long v12 = 0u;
          long long v13 = 0u;
          *(_OWORD *)long long __p = 0u;
          sub_1013D8DEC(v8);
          if (SBYTE7(v12) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)long long __p = *(_OWORD *)buf;
          *(void *)&long long v12 = v19;
          DWORD2(v12) = 0;
          sub_10083A39C();
          sub_1013D9E58(v16);
          if (SHIBYTE(v15) < 0) {
            operator delete(v14[1]);
          }
          *(void *)long long buf = &v13;
          sub_100047F64((void ***)buf);
          if (SBYTE7(v12) < 0) {
            operator delete(__p[0]);
          }
        }
        if (v17) {
          sub_10004D2C8(v17);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083DBF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_10083DC34(int a1, CallInfo *this)
{
  if (qword_101B13C98 != -1) {
    dispatch_once(&qword_101B13C98, &stru_1019BBCD0);
  }
  uint64_t v3 = (unsigned char *)qword_101B13C90;
  int v4 = *((_DWORD *)this + 25);
  CallInfo::getCCDisconnectErrorCode(this);
  CSIErrorString();
  sub_100356D8C(v3, 4, "disconnect: duration=%u;cause=%s;modemErr=%d;rat=%d", v5, v6, v7, v8, v9, v4);
}

void sub_10083DCC8(void *a1, uint64_t a2, int a3)
{
  int v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = (void **)a1[8];
      if (v8)
      {
        BOOL v24 = v7;
        uint64_t v9 = a1[5];
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = subscriber::asString();
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Due to SRVCC, got new call ids for calls on %s. Updating.", (uint8_t *)&buf, 0xCu);
        }
        long long buf = 0uLL;
        uint64_t v29 = 0;
        CallController::getCurrentCallsDialedOnSim_sync(v8, a3, 0, (uint64_t *)&buf);
        uint64_t v11 = (uint64_t *)*((void *)&buf + 1);
        long long v10 = (uint64_t *)buf;
        if ((void)buf != *((void *)&buf + 1))
        {
          long long v12 = (void *)(a2 + 8);
          do
          {
            uint64_t v14 = *v10;
            long long v13 = (std::__shared_weak_count *)v10[1];
            if (v13) {
              atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            unsigned int v15 = *(unsigned __int8 *)(v14 + 196);
            uint64_t v16 = *v12;
            if (!*v12) {
              goto LABEL_21;
            }
            int v17 = v12;
            do
            {
              unsigned int v18 = *(unsigned __int8 *)(v16 + 25);
              BOOL v19 = v18 >= v15;
              if (v18 >= v15) {
                int v20 = (uint64_t *)v16;
              }
              else {
                int v20 = (uint64_t *)(v16 + 8);
              }
              if (v19) {
                int v17 = (void *)v16;
              }
              uint64_t v16 = *v20;
            }
            while (*v20);
            if (v17 != v12 && *((unsigned __int8 *)v17 + 25) <= v15)
            {
              uint64_t v22 = a1[5];
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                int v23 = *((unsigned __int8 *)v17 + 26);
                *(_DWORD *)uint64_t v25 = 67109376;
                *(_DWORD *)&v25[4] = v15;
                __int16 v26 = 1024;
                int v27 = v23;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Curr Call Id: %d getting replaced with %d", v25, 0xEu);
              }
              sub_1013DA340(v14, *((unsigned __int8 *)v17 + 26));
            }
            else
            {
LABEL_21:
              uint64_t v21 = a1[5];
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)uint64_t v25 = 67109120;
                *(_DWORD *)&v25[4] = v15;
                _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find a replacement id for %d", v25, 8u);
              }
            }
            if (v13) {
              sub_10004D2C8(v13);
            }
            v10 += 2;
          }
          while (v10 != v11);
        }
        *(void *)uint64_t v25 = &buf;
        sub_10005CBF0((void ***)v25);
        uint64_t v7 = v24;
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10083DF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
}

uint64_t sub_10083DF5C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  if (*(void *)(a1 + 64))
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    sub_100836830(&v10, a1, a2);
    if (v10)
    {
      int v7 = *(_DWORD *)(v10 + 304);
      if (*(_DWORD *)(v10 + 176) == 2)
      {
        if (v7) {
          uint64_t v8 = 1;
        }
        else {
          uint64_t v8 = sub_10083E058(a1);
        }
      }
      else
      {
        uint64_t v8 = v7 != 0;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_10004D2C8(v6);
  return v8;
}

void sub_10083E030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10083E058(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      if (*(void *)(a1 + 64)) {
        PersonalityIdFromSlotIdEx();
      }
      sub_10004D2C8(v4);
    }
  }
  return 0;
}

void sub_10083E130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_10083E15C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    int v7 = std::__shared_weak_count::lock(v5);
    if (v7 && *(void *)(a1 + 64))
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      sub_100836830(&v8, a1, a2);
      if (v8) {
        CSIPhoneNumber::getBaseNumber(a3, (CSIPhoneNumber *)(v8 + 512));
      }
      else {
        sub_100058DB0(a3, "");
      }
      if (v9) {
        sub_10004D2C8(v9);
      }
      goto LABEL_12;
    }
  }
  else
  {
    int v7 = 0;
  }
  sub_100058DB0(a3, "");
  if (v7) {
LABEL_12:
  }
    sub_10004D2C8(v7);
}

void sub_10083E21C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10083E250(void *a1, uint64_t a2, char a3)
{
  int v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      if (a1[8])
      {
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        sub_10083D490(&v15, (uint64_t)a1, a2);
        uint64_t v9 = v15;
        uint64_t v10 = a1[5];
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
        if (v9)
        {
          if (v11)
          {
            int v12 = *(_DWORD *)(a2 + 92);
            uint64_t v13 = asString();
            *(_DWORD *)long long buf = 67109378;
            int v18 = v12;
            __int16 v19 = 2080;
            uint64_t v20 = v13;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Updating SRVCC state for call %u to %s", buf, 0x12u);
            uint64_t v9 = v15;
          }
          *(unsigned char *)(v9 + 164) = a3;
        }
        else if (v11)
        {
          int v14 = *(_DWORD *)(a2 + 92);
          *(_DWORD *)long long buf = 67109120;
          int v18 = v14;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N Unable to find call with ID %u, not updating SRVCC state", buf, 8u);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083E3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10083E3D8(uint64_t a1, uint64_t a2, char a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      if (*(void *)(a1 + 64))
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        sub_10083D490(&v9, a1, a2);
        if (v9) {
          *(unsigned char *)(v9 + 756) = a3;
        }
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083E460(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083E474(uint64_t a1, uint64_t a2, char a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    int v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      if (*(void *)(a1 + 64))
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        sub_10083D490(&v9, a1, a2);
        if (v9) {
          *(unsigned char *)(v9 + 434) = a3;
        }
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083E4FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083E510(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      int v7 = (CallController *)a1[8];
      if (v7)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        sub_10083D490(&v20, (uint64_t)a1, a2);
        uint64_t v8 = v20;
        uint64_t v9 = a1[5];
        BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        if (v8)
        {
          if (v10)
          {
            sub_10012A394(&v16, (const void **)a2);
            printUuid();
            if (v19 >= 0) {
              BOOL v11 = __p;
            }
            else {
              BOOL v11 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136315138;
            int v23 = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Updating audio stream tokens for call %s", buf, 0xCu);
            if (v19 < 0) {
              operator delete(__p[0]);
            }
            sub_10012577C(&v16);
            uint64_t v8 = v20;
          }
          if (!*(unsigned char *)(a2 + 240)) {
            sub_10016C840();
          }
          uint64_t v13 = 0;
          int v14 = 0;
          uint64_t v15 = 0;
          sub_100245E90(&v13, *(const void **)(a2 + 216), *(void *)(a2 + 224), (uint64_t)(*(void *)(a2 + 224) - *(void *)(a2 + 216)) >> 2);
          sub_10099B178(v8 + 320, (uint64_t)&v13);
          if (v13)
          {
            int v14 = v13;
            operator delete(v13);
          }
          CallController::updateRestCallValues(v7);
        }
        else if (v10)
        {
          sub_10012A394(&v17, (const void **)a2);
          printUuid();
          if (v19 >= 0) {
            int v12 = __p;
          }
          else {
            int v12 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          int v23 = v12;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unable to find call with ID %s, not updating audio stream tokens", buf, 0xCu);
          if (v19 < 0) {
            operator delete(__p[0]);
          }
          sub_10012577C(&v17);
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083E724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, int a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  sub_10012577C(&a14);
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_10083E780(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      int v7 = (CallController *)a1[8];
      if (v7)
      {
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        sub_10083D490(&v19, (uint64_t)a1, a2);
        uint64_t v8 = v19;
        uint64_t v9 = a1[5];
        BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        if (v8)
        {
          if (v10)
          {
            sub_10012A394(&v15, (const void **)a2);
            printUuid();
            if (!*(unsigned char *)(a2 + 208)) {
              sub_10016C840();
            }
            BOOL v11 = __p;
            if (v18 < 0) {
              BOOL v11 = (void **)__p[0];
            }
            int v12 = *(_DWORD *)(a2 + 204);
            *(_DWORD *)long long buf = 136315394;
            uint64_t v22 = v11;
            __int16 v23 = 1024;
            int v24 = v12;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Updating text stream token for call %s to %u", buf, 0x12u);
            if (v18 < 0) {
              operator delete(__p[0]);
            }
            sub_10012577C(&v15);
          }
          if (!*(unsigned char *)(a2 + 208)) {
            sub_10016C840();
          }
          uint64_t v13 = v19;
          *(_DWORD *)(v19 + 308) = *(_DWORD *)(a2 + 204);
          *(unsigned char *)(v13 + 312) = 1;
          CallController::updateRestCallValues(v7);
        }
        else if (v10)
        {
          sub_10012A394(&v16, (const void **)a2);
          printUuid();
          if (v18 >= 0) {
            int v14 = __p;
          }
          else {
            int v14 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v22 = v14;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unable to find call with ID %s, not updating text stream token", buf, 0xCu);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
          sub_10012577C(&v16);
        }
        if (v20) {
          sub_10004D2C8(v20);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083E98C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::__shared_weak_count *a20)
{
  sub_10012577C(&a12);
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_10083E9E8(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      int v7 = (CallController *)a1[8];
      if (v7)
      {
        uint64_t v13 = 0;
        int v14 = 0;
        sub_10083D490(&v13, (uint64_t)a1, a2);
        if (v13)
        {
          if (!*(unsigned char *)(a2 + 249)) {
            sub_10016C840();
          }
          *(_WORD *)(v13 + 352) = *(unsigned __int8 *)(a2 + 248) | 0x100;
          CallController::updateRestCallValues(v7);
        }
        else
        {
          uint64_t v8 = a1[5];
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            sub_10012A394(&v10, (const void **)a2);
            printUuid();
            if (v12 >= 0) {
              p_p = &__p;
            }
            else {
              p_p = __p;
            }
            *(_DWORD *)long long buf = 136315138;
            uint64_t v16 = p_p;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N Unable to find call with ID %s, not updating text stream token", buf, 0xCu);
            if (v12 < 0) {
              operator delete(__p);
            }
            sub_10012577C(&v10);
          }
        }
        if (v14) {
          sub_10004D2C8(v14);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083EB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  sub_10012577C(&a9);
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_10083EB80(void *a1, const void **a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        uint64_t v17 = 0;
        char v18 = 0;
        sub_10083D490(&v17, (uint64_t)a1, (uint64_t)a2);
        uint64_t v8 = v17;
        uint64_t v9 = a1[5];
        BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        if (v8)
        {
          if (v10)
          {
            sub_10012A394(&v13, a2);
            printUuid();
            if (v16 >= 0) {
              BOOL v11 = __p;
            }
            else {
              BOOL v11 = (void **)__p[0];
            }
            *(_DWORD *)long long buf = 136315138;
            uint64_t v20 = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Upgrade to RTT failed for call %s. Update call type from RTT to Voice.", buf, 0xCu);
            if (v16 < 0) {
              operator delete(__p[0]);
            }
            sub_10012577C(&v13);
          }
          CallController::downgradeTTYCallToVoice_sync(v7, &v17, 0);
        }
        else if (v10)
        {
          sub_10012A394(&v14, a2);
          printUuid();
          if (v16 >= 0) {
            char v12 = __p;
          }
          else {
            char v12 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v20 = v12;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unable to find call with ID %s, cannot fail RTT upgrade", buf, 0xCu);
          if (v16 < 0) {
            operator delete(__p[0]);
          }
          sub_10012577C(&v14);
        }
        if (v18) {
          sub_10004D2C8(v18);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083ED50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  sub_10012577C(&a11);
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_10083ED94(void *a1, const void **a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[8];
      if (v7)
      {
        uint64_t v15 = 0;
        char v16 = 0;
        sub_10083D490(&v15, (uint64_t)a1, (uint64_t)a2);
        uint64_t v8 = v15;
        uint64_t v9 = a1[5];
        BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
        if (v8)
        {
          if (v10)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N IPTelephony found text on this voice call, updating it to RTT", buf, 2u);
            uint64_t v8 = v15;
          }
          sub_1013D8DEC(v8);
          CallController::upgradeVoiceCallToTTY_sync(v7, (uint64_t)buf, 1);
          if (v14 < 0) {
            operator delete(*(void **)buf);
          }
        }
        else if (v10)
        {
          sub_10012A394(&v12, a2);
          printUuid();
          if (v14 >= 0) {
            BOOL v11 = buf;
          }
          else {
            BOOL v11 = *(uint8_t **)buf;
          }
          *(_DWORD *)uint64_t v17 = 136315138;
          char v18 = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Unable to find call with ID %s, not updating text stream token", v17, 0xCu);
          if (v14 < 0) {
            operator delete(*(void **)buf);
          }
          sub_10012577C(&v12);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_10083EF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  sub_10012577C(&a10);
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10083EF84(void *a1, const CallInfo *a2, unsigned __int8 a3)
{
  int v4 = (std::__shared_weak_count *)a1[9];
  if (!v4) {
    return 0;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  uint64_t v9 = (CallController *)a1[8];
  if (v9)
  {
    uint64_t isNewMTMOCallAllowed = CallController::isNewMTMOCallAllowed(v9, a2, a3);
    BOOL v11 = a1[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = subscriber::asString();
      uint64_t v13 = "NOT ALLOWED";
      if (isNewMTMOCallAllowed) {
        uint64_t v13 = "ALLOWED";
      }
      int v15 = 136315394;
      char v16 = v13;
      __int16 v17 = 2080;
      uint64_t v18 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Incoming call is %s on %s", (uint8_t *)&v15, 0x16u);
    }
  }
  else
  {
    uint64_t isNewMTMOCallAllowed = 0;
  }
  sub_10004D2C8(v8);
  return isNewMTMOCallAllowed;
}

void sub_10083F0A4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083F0BC(void *a1, int *a2, uint64_t a3)
{
  int v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = a1[8];
      if (v9)
      {
        BOOL v10 = (capabilities::ct *)CallController::carrierSupportsWifiCalling(a1[8]);
        int v11 = capabilities::ct::shouldSendWiFiCallStatus(v10);
        uint64_t v12 = a1[5];
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = *a2;
          char v14 = "false";
          if (v10) {
            int v15 = "true";
          }
          else {
            int v15 = "false";
          }
          v16[0] = 67109634;
          v16[1] = v13;
          __int16 v17 = 2080;
          if (v11) {
            char v14 = "true";
          }
          uint64_t v18 = v15;
          __int16 v19 = 2080;
          uint64_t v20 = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Wifi call status: %d isWifiCallingSupported: %s shouldSendWifiCallStatus: %s", (uint8_t *)v16, 0x1Cu);
        }
        if (v11) {
          (*(void (**)(void, int *, uint64_t, capabilities::ct *))(**(void **)(v9 + 168) + 336))(*(void *)(v9 + 168), a2, a3, v10);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083F22C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_10083F244(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 64);
  if (v7) {
    unint64_t v8 = CallController::copyIMSConfigBoolValue(v7, (int)"Voice", (uint64_t)"TestEmergencyPSAPSupported", a2, (BOOL *)kCFBooleanFalse);
  }
  else {
    unint64_t v8 = 0;
  }
  sub_10004D2C8(v6);
  return v8;
}

void sub_10083F2D8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_10083F2EC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 64);
  if (v2 == 2) {
    return 1;
  }
  if (v2 == 3) {
    return sub_10083F244(a1, *(_DWORD *)(a2 + 252));
  }
  return 0;
}

void sub_10083F318(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      uint64_t v9 = *(const void ***)(a1 + 64);
      if (v9)
      {
        long long v25 = 0uLL;
        int v24 = 0;
        sub_10012A394(&v24, (const void **)a2);
        if (v24) {
          BOOL v10 = sub_100136254;
        }
        else {
          BOOL v10 = 0;
        }
        if (v10)
        {
          CallController::findCallByUuid_sync(v9, &v24, (uint64_t *)__p);
          long long v25 = *(_OWORD *)__p;
          int v11 = __p[0];
        }
        else
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v23 = 0;
          CallController::getCurrentCallsDialedOnSim_sync((void **)v9, *(_DWORD *)(a2 + 252), 0, (uint64_t *)__p);
          uint64_t v12 = (char *)__p[0];
          int v13 = (char *)__p[1];
          if (__p[0] == __p[1])
          {
LABEL_19:
            int v11 = 0;
          }
          else
          {
            while (1)
            {
              int v11 = *(void **)v12;
              char v14 = (std::__shared_weak_count *)*((void *)v12 + 1);
              if (v14) {
                atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (*(_DWORD *)(v11[95] + 24) == 2
                && *((unsigned char *)v11 + 438)
                && (v11[21] & 0xFFFFFFFE) != 2
                && *((_DWORD *)v11 + 174) == 1)
              {
                break;
              }
              if (v14) {
                sub_10004D2C8(v14);
              }
              v12 += 16;
              if (v12 == v13) {
                goto LABEL_19;
              }
            }
            if (v14)
            {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              *(void *)&long long v25 = v11;
              *((void *)&v25 + 1) = v14;
              sub_10004D2C8(v14);
            }
            else
            {
              long long v25 = (unint64_t)v11;
            }
          }
          *(void *)long long buf = __p;
          sub_10005CBF0((void ***)buf);
        }
        sub_10012577C(&v24);
        int v15 = *(NSObject **)(a1 + 40);
        BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
        if (v11)
        {
          if (v16)
          {
            __int16 v17 = (const void **)sub_1013D824C((uint64_t)v11);
            sub_10012A394(&v21, v17);
            printUuid();
            uint64_t v18 = (void **)__p[0];
            __int16 v19 = "CS";
            if (v23 >= 0) {
              uint64_t v18 = __p;
            }
            if (a3) {
              __int16 v19 = "PS";
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v18;
            __int16 v27 = 2080;
            long long v28 = v19;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Rat Selection for call %s: %s", buf, 0x16u);
            if (SHIBYTE(v23) < 0) {
              operator delete(__p[0]);
            }
            sub_10012577C(&v21);
            int v11 = (void *)v25;
          }
          if (*((unsigned char *)v11 + 488) && *((unsigned char *)v11 + 456))
          {
            Registry::getTimerService((uint64_t *)__p, *(Registry **)(a1 + 48));
            uint64_t v20 = ((**(uint64_t (***)(void *))__p[0])(__p[0]) - v11[56]) / 1000000;
            if (__p[1]) {
              sub_10004D2C8((std::__shared_weak_count *)__p[1]);
            }
            v11[59] = v20;
            *((_DWORD *)v11 + 120) = 0;
          }
          if (a3)
          {
            if (*(unsigned char *)(a2 + 333))
            {
              sub_1013D9018((uint64_t)v11);
              CallController::fetchAndSetPhoneCallSubType_sync((uint64_t)v9, (uint64_t *)&v25);
            }
            else
            {
              CallController::fetchAndSetPhoneCallSubType_sync((uint64_t)v9, (uint64_t *)&v25);
              sub_1013D8F68(v25);
            }
          }
          else
          {
            CallController::redialCallOverCS(v9, (uint64_t *)&v25, 6);
          }
        }
        else if (v16)
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Drop Rat Selection result: no matching call", (uint8_t *)__p, 2u);
        }
        if (*((void *)&v25 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v25 + 1));
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10083F694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_10083F6F0(void *a1, uint64_t a2, uint64_t a3)
{
  int v4 = (std::__shared_weak_count *)a1[9];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = a1[8];
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 168);
        if (v9)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)v9 + 320))(v9, a2, a3, 0, 0);
LABEL_10:
          sub_10004D2C8(v7);
          return;
        }
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  BOOL v10 = a1[5];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v11 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Send IMS call status to BB failed: null controller/driver", v11, 2u);
  }
  if (v7) {
    goto LABEL_10;
  }
}

void sub_10083F7DC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_10083F7F0(void *a1, int a2, int a3, char a4)
{
  if (a2 == 2)
  {
    uint64_t v5 = (std::__shared_weak_count *)a1[9];
    if (v5)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v5);
      if (v8)
      {
        uint64_t v9 = v8;
        BOOL v10 = (void **)a1[8];
        if (v10)
        {
          __int16 v19 = 0;
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          CallController::getCurrentCallsDialedOnSim_sync(v10, a3, 0, (uint64_t *)&v19);
          if (v20 - (void)v19 == 16)
          {
            uint64_t v12 = *v19;
            int v11 = (std::__shared_weak_count *)v19[1];
            if (v11) {
              atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v12)
            {
              if (a4)
              {
                sub_1013D8F68(v12);
              }
              else
              {
                int v15 = a1[5];
                if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                {
                  sub_1013D8DEC(v12);
                  if (v18 >= 0) {
                    BOOL v16 = __p;
                  }
                  else {
                    BOOL v16 = (void **)__p[0];
                  }
                  *(_DWORD *)long long buf = 136315138;
                  uint64_t v23 = v16;
                  _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Sent IMS call status to BB failed. End the call %s", buf, 0xCu);
                  if (v18 < 0) {
                    operator delete(__p[0]);
                  }
                }
                *(_DWORD *)(v12 + 224) = 1;
                *(unsigned char *)(v12 + 228) = 1;
                sub_1013D9E58(v12);
              }
            }
            else
            {
              char v14 = a1[5];
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                LOWORD(__p[0]) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Sent IMS call status to BB for null call", (uint8_t *)__p, 2u);
              }
            }
            if (v11) {
              sub_10004D2C8(v11);
            }
          }
          else
          {
            int v13 = a1[5];
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Sent IMS call status to BB for incorrect number of calls", (uint8_t *)__p, 2u);
            }
          }
          __p[0] = &v19;
          sub_10005CBF0((void ***)__p);
        }
        sub_10004D2C8(v9);
      }
    }
  }
}

void sub_10083FA04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12)
{
  if (v13) {
    sub_10004D2C8(v13);
  }
  a9 = (void **)&a12;
  sub_10005CBF0(&a9);
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_10083FA40(void *a1)
{
  *a1 = off_101A0F688;
  int v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  CallCommandDriverDelegateInterface::~CallCommandDriverDelegateInterface((CallCommandDriverDelegateInterface *)a1);
}

void sub_10083FABC(void *a1)
{
  *a1 = off_101A0F688;
  int v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  CallCommandDriverDelegateInterface::~CallCommandDriverDelegateInterface((CallCommandDriverDelegateInterface *)a1);

  operator delete();
}

void sub_10083FB50(void *a1@<X0>, int a2@<W4>, void *a3@<X5>, void *a4@<X8>, uint64_t *a5)
{
  int v9 = a2;
  v8[0] = 0;
  v8[1] = 0;
  sub_10083FC78(a5, v8);
  *a4 = 0;
  a4[1] = 0;
  sub_100840478((uint64_t)&v10, a1, (uint64_t)&v9, a3, v8);
}

void sub_10083FC3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  char v18 = *(std::__shared_weak_count **)(v16 + 8);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10083FC78@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  int v4 = operator new(0x30uLL);
  uint64_t result = sub_10083FCD4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10083FCC0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10083FCD4(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A0FA80;
  sub_10083FDCC(a1 + 3, a2);
  return a1;
}

void sub_10083FD1C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10083FD30(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0FA80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10083FD50(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0FA80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10083FDA4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_10083FDCC(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = off_101A0FAD0;
  a1[1] = v4;
  a1[2] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_10083FE2C(CallStatusDelegateBase *this)
{
  *(void *)this = off_101A0FAD0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CallStatusDelegateBase::~CallStatusDelegateBase(this);
}

void sub_10083FE88(CallStatusDelegateBase *this)
{
  *(void *)this = off_101A0FAD0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CallStatusDelegateBase::~CallStatusDelegateBase(this);

  operator delete();
}

uint64_t sub_10083FEF8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t sub_10083FF28(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_10083FF58(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t sub_10083FF88(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t sub_10083FFB8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_10083FFE8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

uint64_t sub_100840018(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t sub_100840048(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t sub_100840078(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

uint64_t sub_1008400A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t sub_1008400D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  return result;
}

uint64_t sub_100840108(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

uint64_t sub_100840138(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

uint64_t sub_100840168(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  return result;
}

uint64_t sub_100840198(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 128))();
  }
  return result;
}

uint64_t sub_1008401C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 136))();
  }
  else {
    return 1;
  }
}

uint64_t sub_1008401FC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  return result;
}

uint64_t sub_10084022C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 152))();
  }
  return result;
}

uint64_t sub_10084025C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t sub_10084028C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  return result;
}

uint64_t sub_1008402BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 176))();
  }
  return result;
}

uint64_t sub_1008402EC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 184))();
  }
  return result;
}

uint64_t sub_10084031C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  return result;
}

uint64_t sub_10084034C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 200))();
  }
  return result;
}

uint64_t sub_10084037C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

uint64_t sub_1008403AC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  return result;
}

uint64_t sub_1008403DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 224))();
  }
  *(_WORD *)a2 = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  return result;
}

uint64_t sub_100840418(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 232))();
  }
  return result;
}

uint64_t sub_100840448(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

void sub_100840478(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  int v9 = operator new(0x318uLL);
  sub_10084050C(v9, a2, a3, a4, a5);
}

void sub_1008404F8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10084050C(void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A0FBF0;
  sub_100840604((uint64_t)(a1 + 3), a2, a3, a4, a5);
}

void sub_100840554(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100840568(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0FBF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100840588(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0FBF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1008405DC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100840604(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  *a5 = 0;
  a5[1] = 0;
  sub_1013D7CE4(a1, a2);
}

void sub_10084067C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008406A4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10084071C((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10084071C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v12[0] = a1;
  v12[1] = &v13;
  v12[2] = &v14;
  void v12[3] = 1;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v14 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v14;
  }
  sub_1008407AC((uint64_t)v12);
  return v10;
}

uint64_t sub_1008407AC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1006C5960(a1);
  }
  return a1;
}

void sub_1008407E4(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v9 = 0xFAFAFAFAFAFAFAFBLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v9 + 1 > 0xA0A0A0A0A0A0A0) {
      sub_10006A748();
    }
    unint64_t v10 = 0xFAFAFAFAFAFAFAFBLL * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x50505050505050) {
      unint64_t v12 = 0xA0A0A0A0A0A0A0;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      long long v13 = (char *)sub_100840B14(v4, v12);
    }
    else {
      long long v13 = 0;
    }
    long long v14 = v13;
    int v15 = &v13[408 * v9];
    __int16 v17 = &v13[408 * v12];
    sub_100840920((uint64_t)v15, a2);
    uint64_t v16 = v15 + 408;
    sub_100840A80(a1, &v14);
    uint64_t v8 = a1[1];
    sub_100840B60((uint64_t)&v14);
  }
  else
  {
    sub_100840920(*(void *)(v4 - 8), a2);
    uint64_t v8 = v7 + 408;
    a1[1] = v7 + 408;
  }
  a1[1] = v8;
}

void sub_10084090C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100840B60((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 sub_100840920(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v2;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v3;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  long long v4 = *(_OWORD *)(a2 + 88);
  long long v5 = *(_OWORD *)(a2 + 104);
  uint64_t v6 = *(void *)(a2 + 117);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 117) = v6;
  *(_OWORD *)(a1 + 104) = v5;
  *(_OWORD *)(a1 + 88) = v4;
  long long v7 = *(_OWORD *)(a2 + 128);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = v7;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  long long v8 = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = v8;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 160) = 0;
  long long v9 = *(_OWORD *)(a2 + 184);
  long long v10 = *(_OWORD *)(a2 + 193);
  *(unsigned char *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 193) = v10;
  *(_OWORD *)(a1 + 184) = v9;
  *(unsigned char *)(a1 + 240) = 0;
  if (*(unsigned char *)(a2 + 240))
  {
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
    *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 216);
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    *(void *)(a2 + 216) = 0;
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 232) = 0;
    *(unsigned char *)(a1 + 240) = 1;
  }
  long long v11 = *(_OWORD *)(a2 + 248);
  *(unsigned char *)(a1 + 264) = *(unsigned char *)(a2 + 264);
  *(_OWORD *)(a1 + 248) = v11;
  long long v12 = *(_OWORD *)(a2 + 272);
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(_OWORD *)(a1 + 272) = v12;
  *(void *)(a2 + 280) = 0;
  *(void *)(a2 + 288) = 0;
  *(void *)(a2 + 272) = 0;
  long long v13 = *(_OWORD *)(a2 + 296);
  *(void *)(a1 + 312) = *(void *)(a2 + 312);
  *(_OWORD *)(a1 + 296) = v13;
  *(void *)(a2 + 304) = 0;
  *(void *)(a2 + 312) = 0;
  *(void *)(a2 + 296) = 0;
  long long v14 = *(_OWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 336) = v14;
  long long v16 = *(_OWORD *)(a2 + 368);
  __n128 result = *(__n128 *)(a2 + 384);
  long long v17 = *(_OWORD *)(a2 + 352);
  *(void *)(a1 + 397) = *(void *)(a2 + 397);
  *(_OWORD *)(a1 + 368) = v16;
  *(__n128 *)(a1 + 384) = result;
  *(_OWORD *)(a1 + 352) = v17;
  return result;
}

void sub_100840A80(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 408;
    v4 -= 408;
    sub_100840920(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *sub_100840B14(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xA0A0A0A0A0A0A1) {
    sub_10006A7CC();
  }
  return operator new(408 * a2);
}

uint64_t sub_100840B60(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 408;
    sub_1002243E8(i - 408);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100840BB0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xFAFAFAFAFAFAFAFBLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xA0A0A0A0A0A0A0) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xFAFAFAFAFAFAFAFBLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x50505050505050) {
    unint64_t v9 = 0xA0A0A0A0A0A0A0;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v17 = a1 + 2;
  if (v9) {
    long long v10 = (char *)sub_100840B14(v7, v9);
  }
  else {
    long long v10 = 0;
  }
  long long v13 = v10;
  long long v14 = &v10[408 * v4];
  long long v16 = &v10[408 * v9];
  sub_100245B5C((uint64_t)v14, a2);
  int v15 = v14 + 408;
  sub_100840A80(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100840B60((uint64_t)&v13);
  return v11;
}

void sub_100840CBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100840B60((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100840CD0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v4 = (v3 - *(void *)a2) >> 2;
      unint64_t v5 = *(char **)a2;
      sub_10008A534((char *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v6 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v6;
      operator delete(v6);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_100245E90((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *(unsigned char *)(a1 + 24) = 1;
  }
}

void sub_100840D80(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100840E4C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100840F24);
  __cxa_rethrow();
}

void sub_100840E74(_Unwind_Exception *a1)
{
}

void sub_100840E8C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100840EC4(uint64_t a1)
{
}

uint64_t sub_100840EE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100840F24(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_100840F50@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x30uLL);
  __n128 result = sub_100840FAC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100840F98(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100840FAC(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A0FCA0;
  sub_1008410A4(a1 + 3, a2);
  return a1;
}

void sub_100840FF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100841008(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A0FCA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100841028(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A0FCA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10084107C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_1008410A4(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  *a1 = off_101A0FCF0;
  a1[1] = v4;
  a1[2] = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100841104(CallStatusDelegateBase *this)
{
  *(void *)this = off_101A0FCF0;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CallStatusDelegateBase::~CallStatusDelegateBase(this);
}

void sub_100841160(CallStatusDelegateBase *this)
{
  *(void *)this = off_101A0FCF0;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CallStatusDelegateBase::~CallStatusDelegateBase(this);

  operator delete();
}

void sub_1008411D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::prepareToDial(v2, a2);
  }
}

uint64_t sub_1008411E0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return CallController::CallStatusDelegate::shouldDial(result, a2);
  }
  return result;
}

void sub_1008411F0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::dial(v2, a2);
  }
}

void sub_100841200(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::sendCallStatusEvent(v3, a2, a3);
  }
}

void sub_100841210(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::handleAnswerWaitingHoldOther(v3, a2, a3);
  }
}

void sub_100841220(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    CallController::CallStatusDelegate::handleAnswerWaitingEndActive(v4, a2, a3, a4);
  }
}

void sub_100841230(uint64_t a1, uint64_t *a2, std::string *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::handleAnswerIncoming(v3, a2, a3);
  }
}

void sub_100841240(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    CallController::CallStatusDelegate::processCallDisconnected(v4, a2, a3, a4);
  }
}

void sub_100841250(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::endThisCall(v2, a2);
  }
}

void sub_100841260(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::endHeldCallWhenWaitingAnswered(v2, a2);
  }
}

void sub_100841270(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::sendToVoicemail(v3, a2, a3);
  }
}

void sub_100841280(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::sendEndCallAudio(v2, a2);
  }
}

void sub_100841290(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::setStartTimeForActiveCall(v2, a2);
  }
}

void sub_1008412A0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::setAudioSource(v3, a2, a3);
  }
}

uint64_t sub_1008412B0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return CallController::CallStatusDelegate::hasValidCallId(result, a2);
  }
  return result;
}

uint64_t sub_1008412C0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    return CallController::CallStatusDelegate::shouldAllowThisCall(v2, a2);
  }
  else {
    return 1;
  }
}

void sub_1008412D4(uint64_t a1)
{
  uint64_t v1 = *(CallController::CallStatusDelegate **)(a1 + 8);
  if (v1) {
    CallController::CallStatusDelegate::dialEmergencyIfNeeded(v1);
  }
}

void sub_1008412E4(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::sendSoftPauseDtmfTones(v2, a2);
  }
}

void sub_1008412F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::sendDTMFTone(v3, a2, a3);
  }
}

void sub_100841304(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::sendStopDTMFTone(v2, a2);
  }
}

void sub_100841314(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::cleanUpCall(v2, a2);
  }
}

void sub_100841324(uint64_t a1, char a2)
{
  uint64_t v2 = *(CallController::CallStatusDelegate **)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::sendCallWaitingTones(v2, a2);
  }
}

uint64_t sub_100841334(uint64_t result, uint64_t a2, int a3)
{
  if (*(void *)(result + 8))
  {
    if (*(void *)a2) {
      *(_DWORD *)(*(void *)a2 + 160) = a3;
    }
  }
  return result;
}

void sub_10084134C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    CallController::CallStatusDelegate::possiblySubmitThumperHandoffMetric(v3, a2, a3);
  }
}

void sub_10084135C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::tryUncipheredConnectionMetricSubmission(v2, a2);
  }
}

void sub_10084136C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::setAndSendAudioToneRelay(v2, a2);
  }
}

void sub_10084137C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    CallController::CallStatusDelegate::getTTYSettings(v2, a2);
  }
  else
  {
    *(_WORD *)a2 = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
  }
}

void sub_100841398(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    CallController::CallStatusDelegate::selectCallRat(v2, a2);
  }
}

uint64_t sub_1008413A8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return CallController::CallStatusDelegate::shouldReselectRatFirst(result, a2);
  }
  return result;
}

uint64_t sub_1008413B8(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

uint64_t sub_100841418(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200) {
    a2 = 1;
  }
  if (v5 < 0x400) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void sub_100841488(void **a1)
{
  uint64_t v3 = a1[3];
  uint64_t v2 = (uint64_t)(a1 + 3);
  uint64_t v4 = a1[1];
  unint64_t v5 = a1[2];
  unint64_t v6 = (v5 - v4) >> 3;
  if (v6 >= (v3 - (unsigned char *)*a1) >> 3) {
    return;
  }
  if (v5 == v4)
  {
    long long v10 = 0;
    int v7 = 0;
    goto LABEL_8;
  }
  int v7 = (char *)sub_10004EF74(v2, v6);
  unint64_t v8 = a1[1];
  unint64_t v5 = a1[2];
  long long v10 = &v7[8 * v9];
  uint64_t v11 = v5 - v8;
  if (v5 == v8)
  {
LABEL_8:
    long long v14 = v5;
    goto LABEL_9;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 8 * (v11 >> 3);
  do
  {
    *(void *)&v7[v12] = *(void *)&v8[v12];
    v12 += 8;
  }
  while (v13 != v12);
  unint64_t v5 = a1[1];
  long long v14 = a1[2];
LABEL_9:
  int64_t v15 = v14 - v5;
  long long v16 = *a1;
  *a1 = v7;
  a1[1] = v7;
  a1[2] = &v7[v15];
  a1[3] = v10;
  if (v16)
  {
    operator delete(v16);
  }
}

uint64_t sub_10084155C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_1008415C0()
{
}

void sub_10084161C()
{
}

void sub_100841640(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1008416B8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_100841790);
  __cxa_rethrow();
}

void sub_1008416E0(_Unwind_Exception *a1)
{
}

void sub_1008416F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100841730(uint64_t a1)
{
}

uint64_t sub_10084174C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_100841790(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(result + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

uint64_t sub_1008417E8(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t *sub_100841840(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v9 = 0;
  unint64_t v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1008418E4((uint64_t)a1, a4, v8);
    sub_100046C38(a1, v9, v6, v8[0]);
    return v8[0];
  }
  return result;
}

double sub_1008418E4@<D0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  unint64_t v6 = a3 + 1;
  int v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *unint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  unint64_t v8 = v7 + 32;
  uint64_t v9 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)v9, *((void *)v9 + 1));
  }
  else
  {
    long long v10 = *v9;
    *((void *)v7 + 6) = *((void *)v9 + 2);
    *(_OWORD *)unint64_t v8 = v10;
  }
  double result = COERCE_DOUBLE(&_mh_execute_header);
  *((void *)v7 + 7) = &_mh_execute_header;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100841984(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1008419A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1008419B0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1008419CC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1008419DC()
{
  {
    return __cxa_atexit((void (*)(void *))sub_10083FB4C, &ctu::Singleton<callList::model::CallState,callList::model::CallState,ctu::PthreadMutexGuardPolicy<callList::model::CallState>>::sInstance, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_100841BA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100841D28(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  v3[3] = 0;
  (*(void (**)(uint64_t, void *))(*(void *)v1 + 16))(v1, v3);
  return sub_10034D594(v3);
}

void sub_100841DBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10034D594((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100841DD0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  v3[3] = 0;
  (*(void (**)(uint64_t, void *))(*(void *)v1 + 16))(v1, v3);
  return sub_10034D594(v3);
}

void sub_100841E64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10034D594((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100841EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  long long v10 = v9;

  a9.super_class = (Class)AKRemoteDeviceObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void *sub_100841FB0(void *a1)
{
  *a1 = off_101A0FE10;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100842014(void *a1)
{
  sub_100841FB0(a1);

  operator delete();
}

void sub_10084204C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10084212C(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  long long __p = (void *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&__p);
  if (!v9)
  {
    long long v10 = 0;
    goto LABEL_8;
  }
  long long v10 = (GestaltUtilityInterface *)v9[3];
  uint64_t v11 = (std::__shared_weak_count *)v9[4];
  if (!v11)
  {
LABEL_8:
    std::mutex::unlock(v4);
    uint64_t v11 = 0;
    char v13 = 1;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
LABEL_9:
  if ((capabilities::ct::supportsSequoia(v12) & 1) != 0 || GestaltUtilityInterface::isIPhone(v10))
  {
    *a2 = 0;
    a2[1] = 0;
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100842674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, dispatch_object_t object, void *__p, std::__shared_weak_count *a15, int a16, __int16 a17, char a18, char a19, dispatch_object_t a20)
{
  if (a20) {
    (*((void (**)(dispatch_object_t))a20->isa + 1))(a20);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_10004D2C8(v20);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

void sub_100842820(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100842910(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100845E50((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100842A48(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100842A60(uint64_t a1)
{
  *(void *)a1 = off_101A0FE40;
  *(void *)(a1 + 8) = off_101A0FE70;
  uint64_t v2 = (void *)(a1 + 168);
  if (*(unsigned char *)(a1 + 224))
  {
    unint64_t v6 = (void **)(a1 + 200);
    sub_10019D378(&v6);
  }
  sub_100844DEC(v2);
  if (*(unsigned char *)(a1 + 160)) {
    sub_100313460(a1 + 136, *(void **)(a1 + 144));
  }
  sub_100844E70((void *)(a1 + 104));

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  return a1;
}

uint64_t sub_100842B44(uint64_t a1)
{
  return sub_100842A60(a1 - 8);
}

void sub_100842B4C(uint64_t a1)
{
  sub_100842A60(a1);

  operator delete();
}

void sub_100842B84(uint64_t a1)
{
  sub_100842A60(a1 - 8);

  operator delete();
}

void sub_100842BC0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 32);
  dispatch_object_t v19 = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  memset(v20, 0, sizeof(v20));
  sub_100846754((uint64_t)v20, a2);
  int v5 = *(unsigned __int8 *)(a1 + 96);
  unint64_t v6 = *(NSObject **)(a1 + 48);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Fetching Authkit devices", buf, 2u);
    }
    id v8 = objc_alloc_init((Class)ACAccountStore);
    if (v8)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3321888768;
      _DWORD v16[2] = sub_100843150;
      v16[3] = &unk_101A0FEF0;
      v16[4] = a1;
      dispatch_object_t object = v19;
      if (v19) {
        dispatch_retain(v19);
      }
      sub_100845E50((uint64_t)v18, (uint64_t)v20);
      objc_msgSend(v8, "aa_primaryAppleAccountWithCompletion:", v16);
      sub_10034D594(v18);
      if (object) {
        dispatch_release(object);
      }
    }
    else
    {
      uint64_t v9 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid account store", buf, 2u);
      }
      sub_10084304C(a1);
      v11[0] = 0;
      v11[1] = 0;
      long long v10 = v11;
      sub_100842EDC((uint64_t)&v19, 1, &v10);
      sub_100313460((uint64_t)&v10, v11[0]);
    }
  }
  else
  {
    if (v7)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Not signed into iCloud. Skipping fetch.", buf, 2u);
    }
    v15[0] = 0;
    v15[1] = 0;
    *(void *)long long buf = v15;
    if (sub_1008467D4(a1 + 136, (unsigned __int8 *)v15, 0)) {
      sub_1008468C0(a1 + 104, buf);
    }
    sub_100313460((uint64_t)buf, v15[0]);
    v13[0] = 0;
    v13[1] = 0;
    uint64_t v12 = v13;
    sub_100842EDC((uint64_t)&v19, 6, &v12);
    sub_100313460((uint64_t)&v12, v13[0]);
  }
  sub_10034D594(v20);
  if (v19) {
    dispatch_release(v19);
  }
}

void sub_100842E58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,dispatch_object_t object)
{
  sub_100313460((uint64_t)&a9, a10);

  sub_100844C48(v25 - 96);
  _Unwind_Resume(a1);
}

uint64_t sub_100842EDC(uint64_t result, char a2, void *a3)
{
  if (*(void *)(result + 32))
  {
    sub_100845E50((uint64_t)v7, result + 8);
    v7[32] = a2;
    int v5 = a3 + 1;
    uint64_t v6 = a3[1];
    id v8 = (uint64_t *)*a3;
    uint64_t v9 = v6;
    if (a3[2])
    {
      *(void *)(v6 + 16) = &v9;
      *a3 = v5;
      void *v5 = 0;
      a3[2] = 0;
    }
    else
    {
      id v8 = &v9;
    }
    operator new();
  }
  return result;
}

void sub_100843040(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10084304C(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v3 = &v4;
  if (sub_1008467D4(a1 + 136, (unsigned __int8 *)&v4, 0)) {
    sub_1008468C0(a1 + 104, &v3);
  }
  sub_100313460((uint64_t)&v3, v4);
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  if (sub_100846C20((uint64_t *)(a1 + 200), 0, 0))
  {
    sub_1001A99D4(a1 + 200, (uint64_t)&v3);
    uint64_t v2 = *(void *)(a1 + 192);
    if (v2) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 48))(v2, a1 + 200);
    }
  }
  uint64_t v6 = (void **)&v3;
  sub_10019D378(&v6);
}

void sub_100843124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10019D378((void ***)va);
  _Unwind_Resume(a1);
}

void sub_100843150(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = *(NSObject **)(v7 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1008432BC;
  block[3] = &unk_101A0FE90;
  uint64_t v15 = v7;
  id v9 = v6;
  id v13 = v9;
  id v10 = v5;
  uint64_t v11 = *(NSObject **)(a1 + 40);
  id v14 = v10;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  sub_100845E50((uint64_t)v17, a1 + 48);
  dispatch_async(v8, block);
  sub_10034D594(v17);
  if (object) {
    dispatch_release(object);
  }
}

void sub_100843284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }

  _Unwind_Resume(a1);
}

void sub_1008432BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(void *)(a1 + 32) || !*(void *)(a1 + 40))
  {
    uint64_t v3 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid account", buf, 2u);
    }
    sub_10084304C(v2);
    v19[0] = 0;
    v19[1] = 0;
    uint64_t v18 = v19;
    sub_100842EDC(a1 + 56, 2, &v18);
    sub_100313460((uint64_t)&v18, v19[0]);
  }
  else
  {
    uint64_t v25 = 0;
    __int16 v26 = &v25;
    uint64_t v27 = 0x2050000000;
    uint64_t v4 = (void *)qword_101B0E0F0;
    uint64_t v28 = qword_101B0E0F0;
    if (!qword_101B0E0F0)
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v21 = 3221225472;
      uint64_t v22 = sub_100845004;
      uint64_t v23 = &unk_1019DD010;
      int v24 = &v25;
      sub_100845004((uint64_t)buf);
      uint64_t v4 = (void *)v26[3];
    }
    id v5 = v4;
    _Block_object_dispose(&v25, 8);
    id v6 = objc_opt_new();
    if (v6)
    {
      uint64_t v7 = objc_msgSend(*(id *)(a1 + 40), "aa_altDSID");
      [v6 setAltDSID:v7];

      uint64_t v25 = 0;
      __int16 v26 = &v25;
      uint64_t v27 = 0x2050000000;
      id v8 = (void *)qword_101B0E0F8;
      uint64_t v28 = qword_101B0E0F8;
      if (!qword_101B0E0F8)
      {
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v21 = 3221225472;
        uint64_t v22 = sub_1008452D8;
        uint64_t v23 = &unk_1019DD010;
        int v24 = &v25;
        sub_1008452D8((uint64_t)buf);
        id v8 = (void *)v26[3];
      }
      id v9 = v8;
      _Block_object_dispose(&v25, 8);
      id v10 = objc_opt_new();
      if (v10)
      {
        v29[0] = _NSConcreteStackBlock;
        v29[1] = 3321888768;
        v29[2] = sub_100843754;
        v29[3] = &unk_101A0FEC0;
        uint64_t v11 = *(NSObject **)(a1 + 56);
        uint8_t v29[4] = v2;
        dispatch_object_t object = v11;
        if (v11) {
          dispatch_retain(v11);
        }
        sub_100845E50((uint64_t)v31, a1 + 64);
        [v10 deviceListWithContext:v6 completion:v29];
        sub_10034D594(v31);
        if (object) {
          dispatch_release(object);
        }
      }
      else
      {
        id v13 = *(NSObject **)(v2 + 48);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Invalid controller", buf, 2u);
        }
        sub_10084304C(v2);
        v15[0] = 0;
        v15[1] = 0;
        id v14 = v15;
        sub_100842EDC(a1 + 56, 4, &v14);
        sub_100313460((uint64_t)&v14, v15[0]);
      }
    }
    else
    {
      uint64_t v12 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid request context", buf, 2u);
      }
      sub_10084304C(v2);
      v17[0] = 0;
      v17[1] = 0;
      long long v16 = v17;
      sub_100842EDC(a1 + 56, 3, &v16);
      sub_100313460((uint64_t)&v16, v17[0]);
    }
  }
}

void sub_100843698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,dispatch_object_t object)
{
  sub_100313460((uint64_t)&a10, a11);

  _Unwind_Resume(a1);
}

void sub_100843754(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = *(NSObject **)(v7 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1008438B8;
  block[3] = &unk_101A0FE90;
  uint64_t v15 = v7;
  id v9 = v6;
  id v10 = *(NSObject **)(a1 + 40);
  id v13 = v9;
  dispatch_object_t object = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  sub_100845E50((uint64_t)v17, a1 + 48);
  id v11 = v5;
  id v14 = v11;
  dispatch_async(v8, block);

  sub_10034D594(v17);
  if (object) {
    dispatch_release(object);
  }
}

void sub_100843888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }

  _Unwind_Resume(a1);
}

void sub_1008438B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(void *)(a1 + 32))
  {
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v136 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Fetch failure", v136, 2u);
    }
    sub_10084304C(v2);
    v124[0] = 0;
    v124[1] = 0;
    uint64_t v123 = v124;
    sub_100842EDC(a1 + 56, 5, &v123);
    id v5 = (void *)v124[0];
    id v6 = (long long **)&v123;
    goto LABEL_5;
  }
  uint64_t v94 = *(void *)(a1 + 48);
  uint64_t v7 = *(void **)(a1 + 40);
  if (!v7 || ([v7 deviceList], id v8 = objc_claimAutoreleasedReturnValue(), v8, !v8))
  {
    int v68 = *(NSObject **)(v94 + 48);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unint64_t v136 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "No AuthKit device list", v136, 2u);
    }
    sub_10084304C(v94);
    return;
  }
  long long v122 = 0uLL;
  unint64_t v120 = 0;
  CFStringRef v121 = &v122;
  uint64_t v118 = 0;
  CFIndex v119 = 0;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  id obj = [*(id *)(a1 + 40) deviceList];
  id v9 = [obj countByEnumeratingWithState:&v114 objects:v141 count:16];
  if (!v9) {
    goto LABEL_105;
  }
  uint64_t v95 = *(void *)v115;
  do
  {
    uint64_t v10 = 0;
    id v96 = v9;
    do
    {
      if (*(void *)v115 != v95) {
        objc_enumerationMutation(obj);
      }
      uint64_t v100 = v10;
      id v11 = *(void **)(*((void *)&v114 + 1) + 8 * v10);
      *(_OWORD *)CFStringRef v139 = 0u;
      long long v140 = 0u;
      memset(v138, 0, sizeof(v138));
      *(_OWORD *)CFStringRef v137 = 0u;
      memset(v136, 0, sizeof(v136));
      v136[24] = [v11 trusted];
      uint64_t v12 = [v11 name];
      if (v12)
      {
        id v99 = [v11 name];
        id v13 = (char *)[v99 UTF8String];
      }
      else
      {
        id v13 = "";
      }
      sub_100058DB0(v137, v13);
      id v14 = [v11 model];
      if (v14)
      {
        id v98 = [v11 model];
        uint64_t v15 = (char *)[v98 UTF8String];
      }
      else
      {
        uint64_t v15 = "";
      }
      sub_100058DB0(&v138[1], v15);
      long long v16 = [v11 serialNumber];
      if (v16)
      {
        id v97 = [v11 serialNumber];
        long long v17 = (char *)[v97 UTF8String];
      }
      else
      {
        long long v17 = "";
      }
      sub_100058DB0(v139, v17);
      uint64_t v18 = [v11 lastUpdatedDate];
      [v18 timeIntervalSinceReferenceDate];
      *((void *)&v140 + 1) = v19;

      if (v16) {
      if (v14)
      }

      if (v12) {
      long long v112 = 0u;
      }
      long long v113 = 0u;
      long long v110 = 0u;
      long long v111 = 0u;
      uint64_t v20 = [v11 additionalInfo];
      id v101 = [v20 objectForKey:@"phones"];

      id v21 = [v101 countByEnumeratingWithState:&v110 objects:v135 count:16];
      if (!v21)
      {

LABEL_87:
        int v50 = *(NSObject **)(v94 + 48);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I ignore device without IMEIs: %@", buf, 0xCu);
        }
        goto LABEL_89;
      }
      char v22 = 0;
      uint64_t v102 = *(void *)v111;
      do
      {
        for (uint64_t i = 0; i != v21; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v111 != v102) {
            objc_enumerationMutation(v101);
          }
          int v24 = *(void **)(*((void *)&v110 + 1) + 8 * i);
          __src[0] = 0;
          __src[1] = 0;
          uint64_t v109 = 0;
          uint64_t v25 = [v24 objectForKey:@"imei"];
          if (v25)
          {
            id v1 = [v24 objectForKey:@"imei"];
            __int16 v26 = (char *)[v1 UTF8String];
          }
          else
          {
            __int16 v26 = "";
          }
          sub_100058DB0(__src, v26);
          if (v25) {

          }
          uint64_t v27 = (void *)HIBYTE(v109);
          char v28 = HIBYTE(v109);
          if (v109 < 0) {
            uint64_t v27 = __src[1];
          }
          if (v27)
          {
            uint64_t v29 = *(_OWORD **)&v136[8];
            if (*(void *)&v136[8] >= *(void *)&v136[16])
            {
              uint64_t v31 = sub_100048008((uint64_t *)v136, (long long *)__src);
            }
            else
            {
              if (SHIBYTE(v109) < 0)
              {
                sub_10004FC84(*(unsigned char **)&v136[8], __src[0], (unint64_t)__src[1]);
              }
              else
              {
                long long v30 = *(_OWORD *)__src;
                *(void *)(*(void *)&v136[8] + 16) = v109;
                *uint64_t v29 = v30;
              }
              uint64_t v31 = (uint64_t)v29 + 24;
            }
            *(void *)&v136[8] = v31;
            buf[0] = [v11 trusted];
            long long v32 = [v11 name];
            if (v32)
            {
              id v105 = [v11 name];
              long long v33 = (char *)[v105 UTF8String];
            }
            else
            {
              long long v33 = "";
            }
            sub_100058DB0(&buf[8], v33);
            uint64_t v34 = [v11 model];
            if (v34)
            {
              id v104 = [v11 model];
              long long v35 = (char *)[v104 UTF8String];
            }
            else
            {
              long long v35 = "";
            }
            sub_100058DB0(&__p, v35);
            long long v36 = [v11 serialNumber];
            if (v36)
            {
              id v103 = [v11 serialNumber];
              long long v37 = (char *)[v103 UTF8String];
            }
            else
            {
              long long v37 = "";
            }
            sub_100058DB0(&v132, v37);
            long long v38 = [v11 lastUpdatedDate];
            [v38 timeIntervalSinceReferenceDate];
            uint64_t v134 = v39;
            uint64_t v127 = 0;
            long long v40 = (uint64_t **)sub_100046ED4((uint64_t)&v121, &v127, __src);
            long long v41 = *v40;
            if (!*v40)
            {
              uint64_t v126 = 0;
              long long v42 = (char *)operator new(0x90uLL);
              v125[0] = v42;
              v125[1] = &v122;
              LOBYTE(v126) = 0;
              long long v43 = v42 + 32;
              if (SHIBYTE(v109) < 0)
              {
                sub_10004FC84(v43, __src[0], (unint64_t)__src[1]);
                long long v44 = (uint64_t *)v125[0];
              }
              else
              {
                *(_OWORD *)long long v43 = *(_OWORD *)__src;
                *((void *)v42 + 6) = v109;
                long long v44 = (uint64_t *)v42;
              }
              *((void *)v42 + 17) = 0;
              *(_OWORD *)(v42 + 120) = 0u;
              *(_OWORD *)(v42 + 104) = 0u;
              *(_OWORD *)(v42 + 88) = 0u;
              *(_OWORD *)(v42 + 72) = 0u;
              *(_OWORD *)(v42 + 56) = 0u;
              LOBYTE(v126) = 1;
              uint64_t v45 = v127;
              *long long v44 = 0;
              v44[1] = 0;
              v44[2] = v45;
              *long long v40 = v44;
              if (*(void *)v121)
              {
                CFStringRef v121 = *(long long **)v121;
                long long v44 = *v40;
              }
              sub_100046C90((uint64_t *)v122, v44);
              ++*((void *)&v122 + 1);
              long long v41 = (uint64_t *)v125[0];
              v125[0] = 0;
              sub_10031699C((uint64_t)v125, 0);
            }
            *((unsigned char *)v41 + 56) = buf[0];
            long long v46 = (void **)(v41 + 8);
            if (*((char *)v41 + 87) < 0) {
              operator delete(*v46);
            }
            *(_OWORD *)long long v46 = *(_OWORD *)&buf[8];
            v41[10] = (uint64_t)v129;
            HIBYTE(v129) = 0;
            uint8_t buf[8] = 0;
            long long v47 = (void **)(v41 + 11);
            if (*((char *)v41 + 111) < 0) {
              operator delete(*v47);
            }
            char v48 = 0;
            *(_OWORD *)long long v47 = __p;
            v41[13] = v131;
            HIBYTE(v131) = 0;
            LOBYTE(__p) = 0;
            uint64_t v49 = (void **)(v41 + 14);
            if (*((char *)v41 + 135) < 0)
            {
              operator delete(*v49);
              char v48 = HIBYTE(v131);
            }
            *(_OWORD *)uint64_t v49 = v132;
            v41[16] = v133;
            HIBYTE(v133) = 0;
            LOBYTE(v132) = 0;
            v41[17] = v134;
            if (v48 < 0) {
              operator delete((void *)__p);
            }
            if (SHIBYTE(v129) < 0) {
              operator delete(*(void **)&buf[8]);
            }

            if (v36) {
            if (v34)
            }

            if (v32) {
            char v22 = 1;
            }
            char v28 = HIBYTE(v109);
          }
          if (v28 < 0) {
            operator delete(__src[0]);
          }
        }
        id v21 = [v101 countByEnumeratingWithState:&v110 objects:v135 count:16];
      }
      while (v21);

      if ((v22 & 1) == 0) {
        goto LABEL_87;
      }
LABEL_89:
      uint64_t v51 = v119;
      if ((unint64_t)v119 >= v120)
      {
        uint64_t v57 = 0x6DB6DB6DB6DB6DB7 * ((v119 - v118) >> 4);
        unint64_t v58 = v57 + 1;
        id v56 = v96;
        uint64_t v54 = v100;
        if ((unint64_t)(v57 + 1) > 0x249249249249249) {
          sub_10006A748();
        }
        if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v120 - (void)v118) >> 4) > v58) {
          unint64_t v58 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v120 - (void)v118) >> 4);
        }
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v120 - (void)v118) >> 4)) >= 0x124924924924924) {
          unint64_t v59 = 0x249249249249249;
        }
        else {
          unint64_t v59 = v58;
        }
        *(void *)&long long __p = &v120;
        uint64_t v60 = (char *)sub_1001A9B30((uint64_t)&v120, v59);
        uint64_t v61 = &v60[112 * v57];
        *(void *)long long buf = v60;
        *(void *)&uint8_t buf[8] = v61;
        uint64_t v129 = &v60[112 * v62];
        *(void *)uint64_t v61 = 0;
        *((void *)v61 + 1) = 0;
        *((void *)v61 + 2) = 0;
        *(_OWORD *)uint64_t v61 = *(_OWORD *)v136;
        *((void *)v61 + 2) = *(void *)&v136[16];
        memset(v136, 0, 24);
        v61[24] = v136[24];
        long long v63 = *(_OWORD *)v137;
        *((void **)v61 + 6) = v138[0];
        *((_OWORD *)v61 + 2) = v63;
        v137[1] = 0;
        v138[0] = 0;
        v137[0] = 0;
        long long v64 = *(_OWORD *)&v138[1];
        *((void **)v61 + 9) = v138[3];
        *(_OWORD *)(v61 + 56) = v64;
        memset(&v138[1], 0, 24);
        long long v65 = *(_OWORD *)v139;
        *((void *)v61 + 12) = v140;
        *((_OWORD *)v61 + 5) = v65;
        v139[1] = 0;
        *(void *)&long long v140 = 0;
        v139[0] = 0;
        *((void *)v61 + 13) = *((void *)&v140 + 1);
        *(void *)&uint8_t buf[16] = v61 + 112;
        sub_1001A9AB8((uint64_t *)&v118, buf);
        int v66 = v119;
        sub_1001A9C28((uint64_t)buf);
        CFIndex v119 = v66;
        if (SBYTE7(v140) < 0) {
          operator delete(v139[0]);
        }
      }
      else
      {
        *(void *)CFIndex v119 = 0;
        *((void *)v51 + 1) = 0;
        *((void *)v51 + 2) = 0;
        *(_OWORD *)uint64_t v51 = *(_OWORD *)v136;
        *((void *)v51 + 2) = *(void *)&v136[16];
        memset(v136, 0, 24);
        v51[24] = v136[24];
        long long v52 = *(_OWORD *)v137;
        *((void **)v51 + 6) = v138[0];
        *((_OWORD *)v51 + 2) = v52;
        v137[1] = 0;
        v138[0] = 0;
        v137[0] = 0;
        long long v53 = *(_OWORD *)&v138[1];
        *((void **)v51 + 9) = v138[3];
        *(_OWORD *)(v51 + 56) = v53;
        memset(&v138[1], 0, 24);
        uint64_t v54 = v100;
        long long v55 = *(_OWORD *)v139;
        *((void *)v51 + 12) = v140;
        *((_OWORD *)v51 + 5) = v55;
        v139[1] = 0;
        *(void *)&long long v140 = 0;
        v139[0] = 0;
        *((void *)v51 + 13) = *((void *)&v140 + 1);
        CFIndex v119 = v51 + 112;
        id v56 = v96;
      }
      if (SHIBYTE(v138[3]) < 0) {
        operator delete(v138[1]);
      }
      if (SHIBYTE(v138[0]) < 0) {
        operator delete(v137[0]);
      }
      *(void *)long long buf = v136;
      sub_100047F64((void ***)buf);
      uint64_t v10 = v54 + 1;
    }
    while ((id)v10 != v56);
    id v9 = [obj countByEnumeratingWithState:&v114 objects:v141 count:16];
  }
  while (v9);
LABEL_105:

  uint64_t v67 = (uint64_t **)(v94 + 136);
  if (sub_1008467D4(v94 + 136, (unsigned __int8 *)v121, *((uint64_t *)&v122 + 1)))
  {
    if (*(unsigned char *)(v94 + 160))
    {
      if (v67 != (uint64_t **)&v121) {
        sub_100846934(v67, v121, &v122);
      }
    }
    else
    {
      sub_10034D220((uint64_t *)v67, (uint64_t)&v121);
      *(unsigned char *)(v94 + 160) = 1;
    }
    uint64_t v69 = *(void *)(v94 + 128);
    if (v69) {
      (*(void (**)(uint64_t, uint64_t **))(*(void *)v69 + 48))(v69, v67);
    }
  }
  long long v70 = *(NSObject **)(v94 + 48);
  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v136 = 134217984;
    *(void *)&v136[4] = 0x6DB6DB6DB6DB6DB7 * ((v119 - v118) >> 4);
    _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Detected %zu devices on account", v136, 0xCu);
  }
  long long v72 = v118;
  int v71 = v119;
  if (v119 == v118)
  {
    long long v72 = v119;
  }
  else
  {
    uint64_t v73 = 0;
    unint64_t v74 = 0;
    do
    {
      int v75 = *(NSObject **)(v94 + 48);
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        long long v76 = &v72[v73 + 56];
        if (v72[v73 + 79] < 0) {
          long long v76 = *(char **)v76;
        }
        *(_DWORD *)unint64_t v136 = 134218242;
        *(void *)&v136[4] = v74;
        *(_WORD *)&v136[12] = 2080;
        *(void *)&v136[14] = v76;
        _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I %2zu. model:%s", v136, 0x16u);
        long long v72 = v118;
        int v71 = v119;
      }
      ++v74;
      v73 += 112;
    }
    while (v74 < 0x6DB6DB6DB6DB6DB7 * ((v71 - v72) >> 4));
  }
  long long v77 = (void **)(v94 + 200);
  if (sub_100846C20((uint64_t *)(v94 + 200), v72, (uint64_t)v71))
  {
    if (*(unsigned char *)(v94 + 224))
    {
      uint64_t v78 = v94;
      if (v77 != (void **)&v118)
      {
        uint64_t v80 = (uint64_t)v118;
        long long v79 = v119;
        unint64_t v81 = 0x6DB6DB6DB6DB6DB7 * ((v119 - v118) >> 4);
        uint64_t v82 = *(void *)(v94 + 200);
        if (0x6DB6DB6DB6DB6DB7 * ((*(void *)(v94 + 216) - v82) >> 4) >= v81)
        {
          if (0x6DB6DB6DB6DB6DB7 * ((*(void *)(v94 + 208) - v82) >> 4) < v81)
          {
            uint64_t v88 = (uint64_t)&v118[16 * ((*(void *)(v94 + 208) - v82) >> 4)];
            sub_10084709C((uint64_t)v118, v88, v82);
            uint64_t v78 = v94;
            uint64_t v85 = sub_100846ED4(v88, (uint64_t)v79, *(void *)(v94 + 208));
            goto LABEL_142;
          }
          uint64_t v89 = sub_10084709C((uint64_t)v118, (uint64_t)v119, v82);
          for (uint64_t j = *(void *)(v94 + 208); j != v89; sub_10019D3FC(j))
            j -= 112;
          uint64_t v78 = v94;
          *(void *)(v94 + 208) = v89;
        }
        else
        {
          sub_1001A9A50(v77);
          if (v81 > 0x249249249249249) {
            sub_10006A748();
          }
          unint64_t v83 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)(v94 + 216) - *(void *)(v94 + 200)) >> 4);
          if (v83 <= v81) {
            unint64_t v83 = v81;
          }
          if ((unint64_t)(0x6DB6DB6DB6DB6DB7
                                * ((uint64_t)(*(void *)(v94 + 216) - *(void *)(v94 + 200)) >> 4)) >= 0x124924924924924)
            unint64_t v84 = 0x249249249249249;
          else {
            unint64_t v84 = v83;
          }
          sub_100846E7C(v77, v84);
          uint64_t v78 = v94;
          uint64_t v85 = sub_100846ED4(v80, (uint64_t)v79, *(void *)(v94 + 208));
LABEL_142:
          *(void *)(v78 + 208) = v85;
        }
      }
    }
    else
    {
      *long long v77 = 0;
      *(void *)(v94 + 208) = 0;
      *(void *)(v94 + 216) = 0;
      uint64_t v86 = (uint64_t)v118;
      CFRange v87 = v119;
      *(void *)unint64_t v136 = v94 + 200;
      if (v119 != v118)
      {
        *(void *)&v136[8] = 0;
        sub_100846E7C(v77, 0x6DB6DB6DB6DB6DB7 * ((v119 - v118) >> 4));
        *(void *)(v94 + 208) = sub_100846ED4(v86, (uint64_t)v87, *(void *)(v94 + 208));
      }
      uint64_t v78 = v94;
      *(unsigned char *)(v94 + 224) = 1;
    }
    uint64_t v91 = *(void *)(v78 + 192);
    if (v91) {
      (*(void (**)(uint64_t, void **))(*(void *)v91 + 48))(v91, v77);
    }
  }
  uint64_t v106 = v121;
  long long v107 = v122;
  if (*((void *)&v122 + 1))
  {
    *(void *)(v122 + 16) = &v107;
    CFStringRef v121 = &v122;
    long long v122 = 0uLL;
  }
  else
  {
    uint64_t v106 = &v107;
  }
  sub_100842EDC(a1 + 56, 0, &v106);
  sub_100313460((uint64_t)&v106, (void *)v107);
  *(void *)unint64_t v136 = &v118;
  sub_10019D378((void ***)v136);
  id v5 = (void *)v122;
  id v6 = &v121;
LABEL_5:
  sub_100313460((uint64_t)v6, v5);
}

void sub_1008447F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62)
{
  *(void *)(v63 + 208) = v62;
  STACK[0x2D0] = (unint64_t)&a58;
  sub_10019D378((void ***)&STACK[0x2D0]);
  sub_100313460((uint64_t)&a61, (void *)a62);
  _Unwind_Resume(a1);
}

uint64_t sub_100844BA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a2 + 56);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  return sub_100845E50(a1 + 64, a2 + 64);
}

void sub_100844BE4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(NSObject **)(v1 + 56);
  if (v3) {
    dispatch_release(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100844BFC(uint64_t a1)
{
  sub_10034D594((void *)(a1 + 64));
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_release(v2);
  }
}

uint64_t sub_100844C48(uint64_t a1)
{
  if (*(void *)a1) {
    dispatch_release(*(dispatch_object_t *)a1);
  }
  return a1;
}

uint64_t sub_100844C80(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  return sub_100845E50(a1 + 48, a2 + 48);
}

void sub_100844CC0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(NSObject **)(v1 + 40);
  if (v3) {
    dispatch_release(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100844CD8(uint64_t a1)
{
  sub_10034D594((void *)(a1 + 48));
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_release(v2);
  }
}

void sub_100844D24(uint64_t a1, uint64_t a2)
{
}

void sub_100844D2C(uint64_t a1, char a2)
{
  if (a2)
  {
    *(unsigned char *)(a1 + 96) = 1;
    v2[3] = 0;
    sub_100842BC0(a1, (uint64_t)v2);
    sub_10034D594(v2);
  }
  else
  {
    *(unsigned char *)(a1 + 96) = 0;
    sub_10084304C(a1);
  }
}

void sub_100844DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10034D594((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100844DEC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100844E70(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_100844EF4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100313460(v1 + 40, *(void **)(v1 + 48));
    sub_10034D594((void *)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100844F4C(uint64_t a1)
{
  uint64_t v5 = a1;
  char v2 = *(unsigned char *)(a1 + 32);
  sub_10034D220(v6, a1 + 40);
  uint64_t v3 = *(void *)(a1 + 24);
  char v7 = v2;
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char *, uint64_t *))(*(void *)v3 + 48))(v3, &v7, v6);
  sub_100313460((uint64_t)v6, (void *)v6[1]);
  return sub_100844EF4(&v5);
}

void sub_100844FDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100844EF4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100845004(uint64_t a1)
{
  sub_1008450E8();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("AKDeviceListRequestContext");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_101B0E0F0 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    char v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class getAKDeviceListRequestContextClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"AKRemoteDeviceService.mm", 24, @"Unable to find class %s", "AKDeviceListRequestContext");

    __break(1u);
  }
}

void sub_1008450CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1008450E8()
{
  v3[0] = 0;
  if (!qword_101B0E0E8)
  {
    v3[1] = _NSConcreteStackBlock;
    v3[2] = (void *)3221225472;
    v3[3] = sub_100845264;
    void v3[4] = &unk_1019A1BF8;
    void v3[5] = v3;
    long long v4 = off_101A100B8;
    uint64_t v5 = 0;
    qword_101B0E0E8 = _sl_dlopen();
  }
  if (!qword_101B0E0E8)
  {
    uint64_t v1 = +[NSAssertionHandler currentHandler];
    char v2 = +[NSString stringWithUTF8String:"void *AuthKitLibrary()"];
    objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v2, @"AKRemoteDeviceService.mm", 22, @"%s", v3[0]);

    __break(1u);
    goto LABEL_7;
  }
  v0 = v3[0];
  if (v3[0]) {
LABEL_7:
  }
    free(v0);
}

void sub_100845240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100845264()
{
  uint64_t result = _sl_dlopen();
  qword_101B0E0E8 = result;
  return result;
}

void sub_1008452D8(uint64_t a1)
{
  sub_1008450E8();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("AKAppleIDAuthenticationController");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_101B0E0F8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    char v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class getAKAppleIDAuthenticationControllerClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"AKRemoteDeviceService.mm", 25, @"Unable to find class %s", "AKAppleIDAuthenticationController");

    __break(1u);
  }
}

void sub_1008453A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1008453BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A100E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1008453DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A100E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100845430(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100845458(uint64_t **a1)
{
  uint64_t v1 = **a1;
  char v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Initializing...", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 48);
  Registry::createRestModuleOneTimeUseConnection(&v18, *(Registry **)(v3 + 56));
  uint64_t v4 = v3 + 72;
  ctu::RestModule::connect();
  if (v19) {
    sub_10004D2C8(v19);
  }
  uint64_t v5 = (uint8_t *)(v3 + 104);
  *(void *)long long buf = off_101A10228;
  id v21 = (std::__shared_weak_count *)(v3 + 72);
  char v22 = buf;
  if (buf != (uint8_t *)(v3 + 104))
  {
    id v6 = *(uint8_t **)(v3 + 128);
    if (v6 == v5)
    {
      uint64_t v24 = v3 + 72;
      uint64_t v25 = 0;
      char v22 = 0;
      uint64_t v23 = off_101A10228;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 24))(v3 + 104, buf);
      (*(void (**)(void))(**(void **)(v3 + 128) + 32))(*(void *)(v3 + 128));
      *(void *)(v3 + 128) = 0;
      char v22 = buf;
      ((void (*)(uint64_t (***)(), uint64_t))v23[3])(&v23, v3 + 104);
      ((void (*)(uint64_t (***)()))v23[4])(&v23);
    }
    else
    {
      *(void *)(v3 + 104) = off_101A10228;
      *(void *)(v3 + 112) = v4;
      char v22 = v6;
    }
    *(void *)(v3 + 128) = v5;
  }
  sub_100844E70(buf);
  uint64_t v7 = *(void *)(v3 + 128);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v3 + 136);
  }
  id v8 = (uint8_t *)(v3 + 168);
  *(void *)long long buf = off_101A102B8;
  id v21 = (std::__shared_weak_count *)(v3 + 72);
  char v22 = buf;
  if (buf != (uint8_t *)(v3 + 168))
  {
    id v9 = *(uint8_t **)(v3 + 192);
    if (v9 == v8)
    {
      uint64_t v24 = v3 + 72;
      uint64_t v25 = 0;
      char v22 = 0;
      uint64_t v23 = off_101A102B8;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v8 + 24))(v3 + 168, buf);
      (*(void (**)(void))(**(void **)(v3 + 192) + 32))(*(void *)(v3 + 192));
      *(void *)(v3 + 192) = 0;
      char v22 = buf;
      ((void (*)(uint64_t (***)(), uint64_t))v23[3])(&v23, v3 + 168);
      ((void (*)(uint64_t (***)()))v23[4])(&v23);
    }
    else
    {
      *(void *)(v3 + 168) = off_101A102B8;
      *(void *)(v3 + 176) = v4;
      char v22 = v9;
    }
    *(void *)(v3 + 192) = v8;
  }
  sub_100844DEC(buf);
  uint64_t v10 = *(void *)(v3 + 192);
  if (v10) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v3 + 200);
  }
  id v11 = [AKRemoteDeviceObserver alloc];
  uint64_t v12 = *(std::__shared_weak_count **)(v3 + 24);
  if (v12)
  {
    uint64_t v13 = *(void *)(v3 + 16);
    id v14 = std::__shared_weak_count::lock(v12);
    if (v14)
    {
      uint64_t v15 = v13 + 8;
      if (!v13) {
        uint64_t v15 = 0;
      }
      *(void *)long long buf = v15;
      id v21 = v14;
      long long v16 = [(AKRemoteDeviceObserver *)v11 initWithQueue:v3 + 32 delegate:buf];
      long long v17 = *(void **)(v3 + 88);
      *(void *)(v3 + 88) = v16;

      if (v21) {
        sub_10004D2C8(v21);
      }
      operator delete();
    }
  }
  sub_100088B9C();
}

void sub_1008458A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10084590C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  char v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Shutting down...", buf, 2u);
  }
  uint64_t v3 = *(void **)(v1 + 48);
  uint64_t v4 = (void *)v3[11];
  v3[11] = 0;

  uint64_t v5 = (void *)v3[16];
  uint8_t v3[16] = 0;
  if (v5 == v3 + 13)
  {
    (*(void (**)(void *))(v3[13] + 32))(v3 + 13);
  }
  else if (v5)
  {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  id v6 = (void *)v3[24];
  v3[24] = 0;
  if (v6 == v3 + 21)
  {
    (*(void (**)(void *))(v3[21] + 32))(v3 + 21);
  }
  else if (v6)
  {
    (*(void (**)(void *))(*v6 + 40))(v6);
  }
  operator delete();
}

void sub_100845A84(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100845ABC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100845AEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100845B30(ServiceManager::Service *this)
{
  *(void *)this = off_101A101A8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100845B8C(ServiceManager::Service *this)
{
  *(void *)this = off_101A101A8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100845BFC@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "AKRemoteDeviceService");
}

unsigned char *sub_100845C0C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  char v2 = operator new(1uLL);
  *a1 = v2;
  *char v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100845C48(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10084204C(v2);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10084204C(v4);
}

uint64_t sub_100845CC4()
{
  return 0;
}

uint64_t sub_100845CCC()
{
  return 1;
}

uint64_t sub_100845CD4()
{
  return 0;
}

void sub_100845CE4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100845DC4(uint64_t *a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(*(void *)*a1 + 48);
  if (v2) {
    sub_100844D2C(v2, *(unsigned char *)(v1 + 8));
  }
  operator delete();
}

void sub_100845E24()
{
}

uint64_t sub_100845E50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_100845EE8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 48);
  if (v2)
  {
    sub_100845E50((uint64_t)v6, v1 + 8);
    sub_100842BC0(v2, (uint64_t)v6);
    sub_10034D594(v6);
  }
  sub_100845FA8(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100845F7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_10034D594((uint64_t *)va2);
  sub_100845FA8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100845FA8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10034D594((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100845FFC()
{
}

void *sub_100846010(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A10228;
  result[1] = v3;
  return result;
}

uint64_t sub_100846058(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A10228;
  a2[1] = v2;
  return result;
}

void sub_100846084(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    xpc_object_t v3 = xpc_array_create(0, 0);
    if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v3);
        xpc_object_t v4 = v3;
      }
      else
      {
        xpc_object_t v4 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
    }
    xpc_release(v3);
    id v8 = *(void **)a2;
    id v6 = (void *)(a2 + 8);
    uint64_t v7 = v8;
    if (v8 != v6)
    {
      do
      {
        xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v10 = v9;
        if (v9)
        {
          xpc_object_t v24 = v9;
        }
        else
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v24 = v10;
          if (!v10)
          {
            xpc_object_t v11 = xpc_null_create();
            xpc_object_t v10 = 0;
            goto LABEL_17;
          }
        }
        if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_object_t v11 = xpc_null_create();
LABEL_17:
          xpc_object_t v24 = v11;
          goto LABEL_18;
        }
        xpc_retain(v10);
LABEL_18:
        xpc_release(v10);
        if (*((char *)v7 + 55) >= 0) {
          uint64_t v12 = (const char *)(v7 + 4);
        }
        else {
          uint64_t v12 = (const char *)v7[4];
        }
        xpc_object_t v22 = xpc_string_create(v12);
        if (!v22) {
          xpc_object_t v22 = xpc_null_create();
        }
        long long __p = &v24;
        uint64_t v18 = "first";
        sub_100035E70((uint64_t)&__p, &v22, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v22);
        xpc_object_t v22 = 0;
        sub_101118E80((uint64_t)(v7 + 7), &v20);
        long long __p = &v24;
        uint64_t v18 = "second";
        sub_100035E70((uint64_t)&__p, &v20, &v21);
        xpc_release(v21);
        xpc_object_t v21 = 0;
        xpc_release(v20);
        xpc_object_t v20 = 0;
        xpc_object_t v13 = v24;
        if (v24) {
          xpc_retain(v24);
        }
        else {
          xpc_object_t v13 = xpc_null_create();
        }
        xpc_release(v24);
        xpc_array_append_value(v4, v13);
        xpc_release(v13);
        id v14 = (void *)v7[1];
        if (v14)
        {
          do
          {
            uint64_t v15 = v14;
            id v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            uint64_t v15 = (void *)v7[2];
            BOOL v16 = *v15 == (void)v7;
            uint64_t v7 = v15;
          }
          while (!v16);
        }
        uint64_t v7 = v15;
      }
      while (v15 != v6);
    }
    if (v4)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
    xpc_release(v4);
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/imei_to_ak_remote_device_info");
  xpc_object_t v24 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if (v19 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100846380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100846430(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100846470()
{
}

void sub_100846480()
{
}

void *sub_100846494(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A102B8;
  result[1] = v3;
  return result;
}

uint64_t sub_1008464DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A102B8;
  a2[1] = v2;
  return result;
}

void sub_100846508(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    xpc_object_t v3 = xpc_array_create(0, 0);
    if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v3);
        xpc_object_t v4 = v3;
      }
      else
      {
        xpc_object_t v4 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
    }
    xpc_release(v3);
    uint64_t v7 = *(uint64_t **)a2;
    id v6 = *(uint64_t **)(a2 + 8);
    while (v7 != v6)
    {
      sub_1011194EC(v7, value);
      xpc_array_append_value(v4, value[0]);
      xpc_release(value[0]);
      v7 += 14;
    }
    if (v4)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
    xpc_release(v4);
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
  }
  sub_100058DB0(value, "/cc/props/ak_remote_device_info_list");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v10 < 0) {
    operator delete(value[0]);
  }
  xpc_release(v5);
}

void sub_100846694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100846708(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100846748()
{
}

uint64_t sub_100846754(uint64_t a1, uint64_t a2)
{
  xpc_object_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    xpc_object_t v3 = (void *)(a1 + 24);
  }
  *xpc_object_t v3 = 0;
  return a1;
}

uint64_t sub_1008467D4(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 24)) {
    return 1;
  }
  if (*(void *)(a1 + 16) == a3)
  {
    xpc_object_t v3 = (unsigned __int8 *)(a1 + 8);
    uint64_t v4 = *(unsigned __int8 **)a1;
    if (*(void *)a1 == a1 + 8)
    {
      BOOL v6 = 1;
    }
    else
    {
      do
      {
        BOOL v6 = sub_10030EE14((uint64_t)&v13, v4 + 32, a2 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (unsigned __int8 *)*((void *)v4 + 1);
        id v8 = v4;
        if (v7)
        {
          do
          {
            uint64_t v4 = v7;
            uint64_t v7 = *(unsigned __int8 **)v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v4 = (unsigned __int8 *)*((void *)v8 + 2);
            BOOL v9 = *(void *)v4 == (void)v8;
            id v8 = v4;
          }
          while (!v9);
        }
        char v10 = (unsigned __int8 *)*((void *)a2 + 1);
        if (v10)
        {
          do
          {
            xpc_object_t v11 = v10;
            char v10 = *(unsigned __int8 **)v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            xpc_object_t v11 = (unsigned __int8 *)*((void *)a2 + 2);
            BOOL v9 = *(void *)v11 == (void)a2;
            a2 = v11;
          }
          while (!v9);
        }
        a2 = v11;
      }
      while (v4 != v3);
    }
  }
  else
  {
    BOOL v6 = 0;
  }
  return !v6;
}

uint64_t sub_1008468C0(uint64_t a1, void *a2)
{
  sub_1003168B8(a1 + 32, a2);
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v4();
  }
  return result;
}

uint64_t **sub_100846934(uint64_t **result, long long *a2, long long *a3)
{
  xpc_object_t v5 = result;
  if (result[2])
  {
    BOOL v6 = *result;
    uint64_t v7 = result[1];
    *uint64_t result = (uint64_t *)(result + 1);
    void v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      id v8 = (uint64_t *)v6[1];
    }
    else {
      id v8 = v6;
    }
    uint64_t v15 = result;
    BOOL v16 = v8;
    long long v17 = v8;
    if (v8)
    {
      BOOL v16 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        BOOL v9 = a2;
        do
        {
          v18[0] = (uint64_t)(v8 + 4);
          v18[1] = (uint64_t)(v8 + 7);
          sub_100846AC8((uint64_t)v18, (uint64_t)(v9 + 2));
          v18[0] = 0;
          char v10 = (uint64_t **)sub_1000EA518((uint64_t)v5, v18, v17 + 4);
          sub_100046C38(v5, v18[0], v10, v17);
          long long v17 = v16;
          if (v16) {
            BOOL v16 = sub_1000EA590((uint64_t)v16);
          }
          xpc_object_t v11 = (long long *)*((void *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              xpc_object_t v11 = *(long long **)v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (long long *)*((void *)v9 + 2);
              BOOL v12 = *(void *)a2 == (void)v9;
              BOOL v9 = a2;
            }
            while (!v12);
          }
          id v8 = v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          BOOL v9 = a2;
        }
        while (!v12);
      }
    }
    uint64_t result = (uint64_t **)sub_100846B38((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_100846B90(v5, a2 + 2);
      char v13 = (long long *)*((void *)a2 + 1);
      if (v13)
      {
        do
        {
          id v14 = v13;
          char v13 = *(long long **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          id v14 = (long long *)*((void *)a2 + 2);
          BOOL v12 = *(void *)v14 == (void)a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_100846AB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100846B38((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100846AC8(uint64_t a1, uint64_t a2)
{
  std::string::operator=(*(std::string **)a1, (const std::string *)a2);
  uint64_t v4 = *(void *)(a1 + 8);
  *(unsigned char *)uint64_t v4 = *(unsigned char *)(a2 + 24);
  std::string::operator=((std::string *)(v4 + 8), (const std::string *)(a2 + 32));
  std::string::operator=((std::string *)(v4 + 32), (const std::string *)(a2 + 56));
  std::string::operator=((std::string *)(v4 + 56), (const std::string *)(a2 + 80));
  *(void *)(v4 + 80) = *(void *)(a2 + 104);
  return a1;
}

uint64_t sub_100846B38(uint64_t a1)
{
  sub_100313460(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    xpc_object_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        xpc_object_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_100313460(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *sub_100846B90(uint64_t **a1, long long *a2)
{
  memset(v7, 0, sizeof(v7));
  sub_10034D3A8((uint64_t)a1, a2, v7);
  uint64_t v6 = 0;
  xpc_object_t v3 = (uint64_t **)sub_1000EA518((uint64_t)a1, &v6, v7[0] + 4);
  sub_100046C38(a1, v6, v3, v7[0]);
  uint64_t v4 = v7[0];
  v7[0] = 0;
  sub_10031699C((uint64_t)v7, 0);
  return v4;
}

void sub_100846C08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10031699C((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100846C20(uint64_t *a1, void *a2, uint64_t a3)
{
  if (!*((unsigned char *)a1 + 24)) {
    return 1;
  }
  xpc_object_t v3 = a2;
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (v4 - *a1 != a3 - (void)a2) {
    return 1;
  }
  if (v5 == v4) {
    return 0;
  }
  while (1)
  {
    uint64_t v6 = *(unsigned __int8 **)v5;
    uint64_t v7 = *(unsigned __int8 **)(v5 + 8);
    id v8 = (unsigned __int8 *)*v3;
    if (&v7[-*(void *)v5] != (unsigned __int8 *)(v3[1] - *v3)) {
      break;
    }
    while (v6 != v7)
    {
      if (!sub_1000609C0((uint64_t)&v32, v6, v8)) {
        goto LABEL_64;
      }
      v6 += 24;
      v8 += 24;
    }
    if (*(unsigned __int8 *)(v5 + 24) != *((unsigned __int8 *)v3 + 24)) {
      break;
    }
    uint64_t v9 = *(unsigned __int8 *)(v5 + 55);
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = *(unsigned __int8 *)(v5 + 55);
    }
    else {
      uint64_t v10 = *(void *)(v5 + 40);
    }
    uint64_t v11 = *((unsigned __int8 *)v3 + 55);
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = v3[5];
    }
    if (v10 != v11) {
      break;
    }
    if (v12 >= 0) {
      char v13 = (unsigned __int8 *)(v3 + 4);
    }
    else {
      char v13 = (unsigned __int8 *)v3[4];
    }
    if ((v9 & 0x80) != 0)
    {
      if (memcmp(*(const void **)(v5 + 32), v13, *(void *)(v5 + 40))) {
        break;
      }
    }
    else if (*(unsigned char *)(v5 + 55))
    {
      uint64_t v14 = 0;
      while (*(unsigned __int8 *)(v5 + v14 + 32) == v13[v14])
      {
        if (v9 == ++v14) {
          goto LABEL_25;
        }
      }
      break;
    }
LABEL_25:
    uint64_t v15 = *(unsigned __int8 *)(v5 + 79);
    if ((v15 & 0x80u) == 0) {
      uint64_t v16 = *(unsigned __int8 *)(v5 + 79);
    }
    else {
      uint64_t v16 = *(void *)(v5 + 64);
    }
    uint64_t v17 = *((unsigned __int8 *)v3 + 79);
    int v18 = (char)v17;
    if ((v17 & 0x80u) != 0) {
      uint64_t v17 = v3[8];
    }
    if (v16 != v17) {
      break;
    }
    if (v18 >= 0) {
      char v19 = (unsigned __int8 *)(v3 + 7);
    }
    else {
      char v19 = (unsigned __int8 *)v3[7];
    }
    if ((v15 & 0x80) != 0)
    {
      if (memcmp(*(const void **)(v5 + 56), v19, *(void *)(v5 + 64))) {
        break;
      }
    }
    else if (*(unsigned char *)(v5 + 79))
    {
      uint64_t v20 = 0;
      while (*(unsigned __int8 *)(v5 + v20 + 56) == v19[v20])
      {
        if (v15 == ++v20) {
          goto LABEL_41;
        }
      }
      break;
    }
LABEL_41:
    uint64_t v21 = *(unsigned __int8 *)(v5 + 103);
    if ((v21 & 0x80u) == 0) {
      uint64_t v22 = *(unsigned __int8 *)(v5 + 103);
    }
    else {
      uint64_t v22 = *(void *)(v5 + 88);
    }
    uint64_t v23 = *((unsigned __int8 *)v3 + 103);
    int v24 = (char)v23;
    if ((v23 & 0x80u) != 0) {
      uint64_t v23 = v3[11];
    }
    if (v22 != v23) {
      break;
    }
    if (v24 >= 0) {
      uint64_t v25 = (unsigned __int8 *)(v3 + 10);
    }
    else {
      uint64_t v25 = (unsigned __int8 *)v3[10];
    }
    if ((v21 & 0x80) != 0)
    {
      if (memcmp(*(const void **)(v5 + 80), v25, *(void *)(v5 + 88))) {
        break;
      }
    }
    else if (*(unsigned char *)(v5 + 103))
    {
      uint64_t v26 = 0;
      while (*(unsigned __int8 *)(v5 + v26 + 80) == v25[v26])
      {
        if (v21 == ++v26) {
          goto LABEL_57;
        }
      }
      break;
    }
LABEL_57:
    double v27 = *(double *)(v5 + 104);
    double v28 = *((double *)v3 + 13);
    BOOL v29 = v27 == v28;
    v5 += 112;
    v3 += 14;
    if (v27 != v28 || v5 == v4) {
      return !v29;
    }
  }
LABEL_64:
  BOOL v29 = 0;
  return !v29;
}

char *sub_100846E7C(void *a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_1001A9B30((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[112 * v4];
  return result;
}

uint64_t sub_100846ED4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      uint64_t v8 = a1 + v6;
      *(void *)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
      *(void *)(v7 + 16) = 0;
      sub_1000302C0((char *)(a3 + v6), *(long long **)(a1 + v6), *(long long **)(a1 + v6 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + v6 + 8) - *(void *)(a1 + v6)) >> 3));
      *(unsigned char *)(v7 + 24) = *(unsigned char *)(a1 + v6 + 24);
      uint64_t v9 = (unsigned char *)(a3 + v6 + 32);
      uint64_t v10 = (void **)(a1 + v6 + 32);
      if (*(char *)(a1 + v6 + 55) < 0)
      {
        sub_10004FC84(v9, *v10, *(void *)(a1 + v6 + 40));
      }
      else
      {
        long long v11 = *(_OWORD *)v10;
        *(void *)(v7 + 48) = *(void *)(v8 + 48);
        *(_OWORD *)uint64_t v9 = v11;
      }
      int v12 = (unsigned char *)(a3 + v6 + 56);
      char v13 = (void **)(a1 + v6 + 56);
      if (*(char *)(v8 + 79) < 0)
      {
        sub_10004FC84(v12, *v13, *(void *)(a1 + v6 + 64));
      }
      else
      {
        long long v14 = *(_OWORD *)v13;
        *(void *)(a3 + v6 + 72) = *(void *)(a1 + v6 + 72);
        *(_OWORD *)int v12 = v14;
      }
      uint64_t v15 = (unsigned char *)(a3 + v6 + 80);
      uint64_t v16 = (void **)(a1 + v6 + 80);
      if (*(char *)(v8 + 103) < 0)
      {
        sub_10004FC84(v15, *v16, *(void *)(a1 + v6 + 88));
      }
      else
      {
        long long v17 = *(_OWORD *)v16;
        *(void *)(a3 + v6 + 96) = *(void *)(a1 + v6 + 96);
        *(_OWORD *)uint64_t v15 = v17;
      }
      *(void *)(a3 + v6 + 104) = *(void *)(v8 + 104);
      v6 += 112;
    }
    while (v8 + 112 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100847028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  if (*(char *)(v10 + v11 + 79) < 0) {
    operator delete(*(void **)(v10 + v11 + 56));
  }
  if (*(char *)(v10 + v11 + 55) < 0) {
    operator delete(*(void **)(v10 + v11 + 32));
  }
  a10 = (void **)(v10 + v11);
  sub_100047F64(&a10);
  if (v11)
  {
    uint64_t v13 = v10 - 112;
    do
    {
      sub_10019D3FC(v13 + v11);
      v11 -= 112;
    }
    while (v11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10084709C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      if (a1 != a3) {
        sub_10005CA3C(a3 + v6, *(std::string **)(a1 + v6), *(long long **)(a1 + v6 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + v6 + 8) - *(void *)(a1 + v6)) >> 3));
      }
      *(unsigned char *)(v7 + 24) = *(unsigned char *)(a1 + v6 + 24);
      std::string::operator=((std::string *)(v7 + 32), (const std::string *)(a1 + v6 + 32));
      std::string::operator=((std::string *)(v7 + 56), (const std::string *)(a1 + v6 + 56));
      std::string::operator=((std::string *)(v7 + 80), (const std::string *)(a1 + v6 + 80));
      *(void *)(v7 + 104) = *(void *)(a1 + v6 + 104);
      v6 += 112;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

const void **sub_100847168(uint64_t *a1, uint64_t a2, xpc::object *this)
{
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (v5 == 19)
  {
    if (v6 >= 0) {
      int v12 = (uint64_t *)a2;
    }
    else {
      int v12 = *(uint64_t **)a2;
    }
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    uint64_t v15 = *(uint64_t *)((char *)v12 + 11);
    if (v13 != 0x72746552736D536BLL || v14 != 0x7373654D65766569 || v15 != 0x6567617373654D65) {
      goto LABEL_12;
    }
  }
  else if (v5 != 15 {
         || (v6 >= 0 ? (uint64_t v7 = (uint64_t *)a2) : (uint64_t v7 = *(uint64_t **)a2),
  }
             (v8 = *v7, uint64_t v9 = *(uint64_t *)((char *)v7 + 7), v8 == 0x646E6553736D536BLL)
           ? (BOOL v10 = v9 == 0x6567617373654D64)
           : (BOOL v10 = 0),
             !v10))
  {
LABEL_12:
    return (const void **)xpc::object::to_string(a1, this);
  }
  CFDataRef v53 = 0;
  *(void *)&v31[0] = this;
  *((void *)&v31[0] + 1) = "kSmsMessageBody";
  sub_100048BAC((uint64_t)v31, &v48);
  xpc::bridge((uint64_t *)&v50, (xpc *)&v48, v18);
  sub_1000C15D8(&v53, (CFTypeRef *)&v50);
  sub_1000577C4((const void **)&v50);
  xpc_release(v48.__r_.__value_.__l.__data_);
  if (v53) {
    char v19 = sub_10008324C;
  }
  else {
    char v19 = 0;
  }
  if (v19)
  {
    BytePtr = CFDataGetBytePtr(v53);
    int Length = CFDataGetLength(v53);
    uint64_t v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v50, "com.apple.telephony", "msg.mms.pdu");
    HIDWORD(v51) = 106;
    LOWORD(v52) = 1;
    BYTE2(v52) = 1;
    HIDWORD(v52) = 1;
    *((void *)&v50 + 1) = BytePtr;
    LODWORD(v51) = Length;
    *(void *)((char *)&v51 + 4) = 0x6A00000000;
    *(void *)&v31[0] = this;
    *((void *)&v31[0] + 1) = "kSmsMessageType";
    sub_100048BAC((uint64_t)v31, &v48);
    int v23 = xpc::dyn_cast_or_default((xpc *)&v48, 0, v22);
    xpc_release(v48.__r_.__value_.__l.__data_);
    if (v23 == 2)
    {
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = 0uLL;
      sub_100FEEFA8();
    }
    if (v23 == 1)
    {
      memset(&v48, 0, sizeof(v48));
      memset(&v47, 0, sizeof(v47));
      memset(&v46, 0, sizeof(v46));
      memset(&v45, 0, sizeof(v45));
      sub_100FEFBD8((uint64_t)&v50, &v49, &v48, &v47, &v46, &v45);
      uint64_t v44 = 0;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v33 = 0u;
      memset(v31, 0, sizeof(v31));
      sub_10004DE24((uint64_t)v31);
      int v24 = sub_10004B96C(v31, (uint64_t)"SMS address: ", 13);
      if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v25 = &v48;
      }
      else {
        uint64_t v25 = (std::string *)v48.__r_.__value_.__r.__words[0];
      }
      if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v48.__r_.__value_.__l.__size_;
      }
      double v27 = sub_10004B96C(v24, (uint64_t)v25, size);
      double v28 = sub_10004B96C(v27, (uint64_t)" body: ", 7);
      if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v29 = &v47;
      }
      else {
        BOOL v29 = (std::string *)v47.__r_.__value_.__r.__words[0];
      }
      if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v30 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v30 = v47.__r_.__value_.__l.__size_;
      }
      sub_10004B96C(v28, (uint64_t)v29, v30);
      sub_10004BC98((uint64_t)v31 + 8, a1);
      if (SHIBYTE(v33) < 0) {
        operator delete(__p[1]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v47.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v48.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      xpc::object::to_string(a1, this);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v50);
  }
  else
  {
    xpc::object::to_string(a1, this);
  }
  return sub_100030068((const void **)&v53);
}

void sub_1008477BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(char *)(v9 - 121) < 0) {
    operator delete(*(void **)(v9 - 144));
  }
  sub_1000C937C((uint64_t)&a9);
  uint64_t v11 = *(std::__shared_weak_count **)(v9 - 160);
  if (v11) {
    sub_10004D2C8(v11);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v9 - 112));
  sub_100030068((const void **)(v9 - 64));
  _Unwind_Resume(a1);
}

void *sub_1008478D8(void *a1, NSObject **a2, uint64_t *a3)
{
  uint64_t v5 = *a2;
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  int v6 = (std::__shared_weak_count *)a3[1];
  uint64_t v8 = *a3;
  uint64_t v9 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100830924((uint64_t)a1, 1, &object, &v8);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (object) {
    dispatch_release(object);
  }
  *a1 = off_101A10370;
  return a1;
}

void sub_100847978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1008479A0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 384))(a1, a2, 1);
}

void sub_1008479D0(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = a2;
  if (*(unsigned char *)(a1 + 89))
  {
LABEL_2:
    if (*(unsigned char *)(a1 + 90))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v8) = 67109378;
        HIDWORD(v8) = v2;
        LOWORD(v9[0]) = 2080;
        *(std::__shared_weak_count **)((char *)v9 + 2) = (std::__shared_weak_count *)CSIErrorString();
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Error (%d) activating internet PDP %s.\nContinuing Monitor Mode.", (uint8_t *)&v8, 0x12u);
      }
      sub_100831FA4(a1, -1.0);
    }
    return;
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 384))(a1, a2, 1))
  {
    if (!*(unsigned char *)(a1 + 89)) {
      return;
    }
    goto LABEL_2;
  }
  sub_100832A1C(a1, v2);
  sub_1008326F4(a1);
  uint64_t v8 = 0;
  v9[0] = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 64) + 48))(&v8);
  uint64_t v5 = v8;
  if (v8)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 776))(v8);
    int v7 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v5 + 952))(v5, v6, 0);
  }
  else
  {
    int v7 = 0;
  }
  sub_100830EB8((void *)a1, v7);
  *(_DWORD *)(a1 + 160) = 52;
  if (v9[0]) {
    sub_10004D2C8(v9[0]);
  }
}

void sub_100847BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100847BF8()
{
  return 1;
}

uint64_t sub_100847C00()
{
  return 1;
}

BOOL sub_100847C08(uint64_t a1, unsigned char *a2)
{
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I User is not subscribed to a valid data plan for context id. Failing activation attempt w/ reason: .", (uint8_t *)&v9, 2u);
    }
    if (!*a2)
    {
      *a2 = 1;
      uint64_t v9 = 0;
      BOOL v10 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 64) + 48))(&v9);
      uint64_t v5 = v9;
      if (v9)
      {
        uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 776))(v9);
        int v7 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v5 + 952))(v5, v6, 0);
      }
      else
      {
        int v7 = 0;
      }
      sub_100830EB8((void *)a1, v7);
      *(_DWORD *)(a1 + 160) = 52;
      sub_100831920(a1);
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
    return 0;
  }
  else
  {
    return !*(unsigned char *)(a1 + 89) || *(unsigned char *)(a1 + 90) != 0;
  }
}

void sub_100847D84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100847D9C()
{
  return 0;
}

void sub_100847DA4(uint64_t a1)
{
  if (*(void *)(a1 + 224)) {
    sub_1009165A4((uint64_t *)(a1 + 224));
  }
  (*(void (**)(void))(**(void **)(a1 + 64) + 168))(*(void *)(a1 + 64));
  sub_10003E168(&aBlock, (void *)(a1 + 8));
  unsigned int v2 = v4;
  uint64_t aBlock = 0;
  uint64_t v4 = 0;
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  operator new();
}

void sub_100847FD8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v17) {
    _Block_release(v17);
  }
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    dispatch_release(v16);
  }
  operator delete();
}

uint64_t *sub_10084803C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 224);
  uint64_t result = (uint64_t *)(a1 + 224);
  if (v2) {
    return (uint64_t *)sub_1009165A4(result);
  }
  return result;
}

void sub_10084804C(uint64_t a1, int a2, int a3, int a4)
{
  int v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 136))(*(void *)(a1 + 64));
  char v9 = DataUtils::lteishDataMode();
  if (a4 == 15 && a3 == 4 && (v9 & 1) != 0 || a3 != 2 && v8 == 13)
  {
    uint64_t v41 = 0;
    long long v42 = 0;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 64) + 48))(&v41);
    uint64_t v10 = v41;
    if (v41)
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 776))(v41);
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v10 + 952))(v10, v11, 0);
    }
    int v12 = (os_log_t *)(a1 + 40);
    uint64_t v13 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 192))(*(void *)(a1 + 64), a1 + 40);
    int v14 = v13;
    if ((v13 & 0xFF00000000) == 0) {
      goto LABEL_55;
    }
    uint64_t v15 = *v12;
    if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 192);
      int v17 = *(_DWORD *)(a1 + 196);
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v16;
      LOWORD(v46) = 1024;
      *(_DWORD *)((char *)&v46 + 2) = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Internet PDP has been torn down by the network by v4:%d v6:%d times", buf, 0xEu);
    }
    if (a2 == 2) {
      uint64_t v18 = 196;
    }
    else {
      uint64_t v18 = 192;
    }
    if (a2 == 2) {
      uint64_t v19 = 208;
    }
    else {
      uint64_t v19 = 200;
    }
    (*(void (**)(Registry **__return_ptr))(**(void **)(a1 + 64) + 16))(&v43);
    Registry::getTimerService((uint64_t *)buf, v43);
    uint64_t v20 = (***(uint64_t (****)(void))buf)(*(void *)buf);
    if (v46) {
      sub_10004D2C8(v46);
    }
    if (v44) {
      sub_10004D2C8(v44);
    }
    if (*(void *)(a1 + v19) == 0x8000000000000000) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = *(void *)(a1 + v19);
    }
    *(void *)(a1 + v19) = v21;
    if ((v20 - v21) / 1000000000 <= (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 176))(*(void *)(a1 + 64)))
    {
      uint64_t v22 = *v12;
      if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v23 = "#I Retry [within threshold]";
        goto LABEL_29;
      }
    }
    else
    {
      *(_DWORD *)(a1 + v18) = 0;
      uint64_t v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v23 = "#I Retry [beyond threshold], reset pdp disconnect count";
LABEL_29:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v23, buf, 2u);
      }
    }
    int v24 = *(_DWORD *)(a1 + v18);
    if (v24 >= v14 && !*(unsigned char *)(a1 + 88))
    {
      long long v40 = *v12;
      if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Retry count[%d] has reached, enter NotProvisionedWindow", buf, 8u);
      }
      sub_100830EB8((void *)a1, v10);
      sub_100832A1C(a1, 0x3Fu);
      sub_1008326F4(a1);
      *(void *)(a1 + 192) = 0;
      *(int64x2_t *)(a1 + 200) = vdupq_n_s64(0x8000000000000000);
      goto LABEL_55;
    }
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 64) + 16))(buf);
    uint64_t v25 = *(Registry **)buf;
    uint64_t v26 = v46;
    *(void *)long long buf = 0;
    std::string v46 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v27, v25);
    BOOL v29 = ServiceMap;
    if (v30 < 0)
    {
      uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(ServiceMap);
    long long v43 = (Registry *)v30;
    long long v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&v43);
    if (v34)
    {
      uint64_t v36 = v34[3];
      long long v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v37 = 0;
        if (!v36) {
          goto LABEL_38;
        }
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v29);
    long long v35 = 0;
    char v37 = 1;
    if (!v36)
    {
LABEL_38:
      int v38 = 1;
      if (v37) {
        goto LABEL_44;
      }
      goto LABEL_43;
    }
LABEL_42:
    int v38 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v36 + 1072))(v36, v10);
    if (v37)
    {
LABEL_44:
      if (v26) {
        sub_10004D2C8(v26);
      }
      if (v46) {
        sub_10004D2C8(v46);
      }
      if (v38)
      {
        ++*(_DWORD *)(a1 + v18);
        *(void *)(a1 + v19) = v20;
        sub_100834404(a1);
      }
      else
      {
        *(void *)(a1 + 192) = 0;
        *(int64x2_t *)(a1 + 200) = vdupq_n_s64(0x8000000000000000);
        long long v39 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Not retrying, interface is not available", buf, 2u);
        }
      }
LABEL_55:
      if (v42) {
        sub_10004D2C8(v42);
      }
      return;
    }
LABEL_43:
    sub_10004D2C8(v35);
    goto LABEL_44;
  }
}

void sub_100848604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100848690(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 89))
  {
    uint64_t v2 = *(void *)(a1 + 96);
    xpc_object_t v3 = *(NSObject **)(a1 + 40);
    BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v4)
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I mm timer is already in place, skip", v5, 2u);
      }
    }
    else
    {
      if (v4)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Deactivated the provisioning interface, continuing monitor mode...", buf, 2u);
      }
      sub_100831FA4(a1, 1.0);
    }
  }
}

uint64_t sub_100848748(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v5 = 0;
  if (!a4 || !a5) {
    return v5;
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 200))(*(void *)(a1 + 64));
  *(_OWORD *)long long __p = 0u;
  long long v24 = 0u;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 64) + 216))(__p);
  if ((v9 & 0xFF00000000) != 0 && v9 == a2)
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v11 = "#I matches legacy NW reject code";
      int v12 = v10;
      uint32_t v13 = 2;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
    }
  }
  else
  {
    if (!BYTE8(v24)) {
      goto LABEL_18;
    }
    for (uint64_t i = __p[0]; i != __p[1]; ++i)
    {
      if (*i == a2) {
        goto LABEL_13;
      }
    }
    uint64_t i = __p[1];
LABEL_13:
    if (__p[1] == i)
    {
LABEL_18:
      uint64_t v5 = 0;
      goto LABEL_19;
    }
    char v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v26 = a2;
      uint64_t v11 = "#I matches NW reject code %d";
      int v12 = v15;
      uint32_t v13 = 8;
      goto LABEL_16;
    }
  }
  uint64_t v5 = 1;
LABEL_19:
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 208))(*(void *)(a1 + 64));
  if ((a3 - 9) <= 0xFFFFFFFD && (v16 & 0xFF00000000) != 0 && v16 == a2)
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v26 = a2;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I matches LTE NW reject code %d", buf, 8u);
    }
    goto LABEL_28;
  }
  if (v5)
  {
LABEL_28:
    int v19 = *(unsigned __int8 *)(a1 + 89);
    uint64_t v20 = *(NSObject **)(a1 + 40);
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      if (v21)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Rejected in monitor mode, ignore", buf, 2u);
      }
      uint64_t v5 = 1;
    }
    else
    {
      if (v21)
      {
        *(_DWORD *)long long buf = 67109120;
        int v26 = a2;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Rejected with cause code %d. Setting plan expired", buf, 8u);
      }
      uint64_t v5 = 1;
      sub_1008326F4(a1);
    }
  }
  if (BYTE8(v24) && __p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v5;
}

void sub_100848A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
}

void sub_100848A5C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I current data plan type Provisioning", v2, 2u);
  }
}

void sub_100848ABC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    xpc_object_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      BOOL v4 = v3;
      if (*(void *)(a1 + 40)) {
        sub_10083552C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100848B30(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100848B44(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100848B60(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100848B70(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 89))
  {
    int v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 152))(*(void *)(a1 + 64));
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 134218240;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      __int16 v15 = 1024;
      int v16 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Monitor mode timer fired at: %f, supportsLTE:%d", (uint8_t *)&v13, 0x12u);
    }
    if (!*(unsigned char *)(a1 + 93)
      && (!v4
       || ((*(uint64_t (**)(void))(**(void **)(a1 + 64) + 160))(*(void *)(a1 + 64)) & 1) != 0
       || !*(unsigned char *)(a1 + 93)
       && (*(unsigned int (**)(void))(**(void **)(a1 + 64) + 272))(*(void *)(a1 + 64))))
    {
      (*(void (**)(void))(**(void **)(a1 + 64) + 144))(*(void *)(a1 + 64));
      int v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        CFAbsoluteTime v9 = CFAbsoluteTimeGetCurrent();
        int v13 = 134217984;
        CFAbsoluteTime Current = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MM reset baseband at %f", (uint8_t *)&v13, 0xCu);
      }
      *(unsigned char *)(a1 + 93) = 1;
      *(_DWORD *)(a1 + 112) = 0;
      double v6 = 30.0;
      goto LABEL_15;
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 64) + 120))(*(void *)(a1 + 64)))
    {
      if (a2 < 1.0)
      {
        double v6 = -1.0;
LABEL_15:
        sub_100831FA4(a1, v6);
        return;
      }
      int v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v13) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Will tear down provisioning pdp", (uint8_t *)&v13, 2u);
      }
      sub_10079487C((uint64_t *)(a1 + 56), 169);
    }
    else
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
        int v13 = 134217984;
        CFAbsoluteTime Current = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Setting internet context active at %f", (uint8_t *)&v13, 0xCu);
      }
      sub_100831DB8(a1, 1);
      sub_100834404(a1);
    }
  }
  else
  {
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 134217984;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Monitor mode timer fired at: %f, but we're NOT IN MONITOR MODE", (uint8_t *)&v13, 0xCu);
    }
  }
}

void sub_100848EB4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 89))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)xpc_object_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DataProvisioningDataPlanManager::handleDataStatusNotification is calling exitMonitorMode(true)", v3, 2u);
    }
    sub_100831998(a1, 1);
  }
}

void sub_100848F30(uint64_t a1)
{
  sub_100830DBC(a1);

  operator delete();
}

void sub_100848F68(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = [a1 UUIDString];
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  id v4 = (id)v3;
  ctu::cf::assign();
}

void sub_100848FC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (*(char *)(v10 + 23) < 0) {
    operator delete(*(void **)v10);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100848FE8(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    long long v12 = 0u;
    long long v13 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    uint64_t v3 = objc_msgSend(v1, "actions", 0);
    uint64_t v4 = 0;
    id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v11;
      do
      {
        for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v11 != v6) {
            objc_enumerationMutation(v3);
          }
          int v8 = *(void **)(*((void *)&v10 + 1) + 8 * i);
          if (([v8 isComplete] & 1) == 0)
          {
            [v8 fail];
            ++v4;
          }
        }
        id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      }
      while (v5);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_100849114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100849140(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v2 = ServiceMap;
  if (v3 < 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  __int16 v15 = (BOOL *)v3;
  int v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)&v15);
  if (v7)
  {
    uint64_t v9 = v7[3];
    int v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      if (!v9) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  int v8 = 0;
  char v10 = 1;
  if (!v9)
  {
LABEL_7:
    BOOL v11 = 1;
    if (v10) {
      return v11;
    }
    goto LABEL_12;
  }
LABEL_11:
  __int16 v15 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, void, const __CFString *, const CFBooleanRef, void))(*(void *)v9 + 32))(&v14, v9, kCarrier1BundleId, @"SupportsVoicemail", kCFBooleanTrue, 0);
  sub_1000057AC(&v15, &v14);
  sub_1000577C4(&v14);
  LOBYTE(v14) = 1;
  ctu::cf::assign((ctu::cf *)&v14, v15, v12);
  BOOL v11 = (_BYTE)v14 != 0;
  sub_100062778((const void **)&v15);
  if ((v10 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v8);
  return v11;
}

void sub_1008492BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1008492F8(char **a1, unsigned __int8 *a2)
{
  uint64_t v2 = *a1;
  char v3 = a1[1];
  if (*a1 != v3)
  {
    while (1)
    {
      long long __p = v2;
      int v23 = "kCallStatus";
      sub_100048BAC((uint64_t)&__p, object);
      int v6 = xpc::dyn_cast_or_default((xpc *)object, 0, v5);
      xpc_release(object[0]);
      v18[0] = v2;
      v18[1] = "kUuid";
      sub_100048BAC((uint64_t)v18, &v19);
      long long __p = 0;
      int v23 = 0;
      uint64_t v24 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v24) < 0) {
        operator delete(__p);
      }
      uint64_t v7 = a2[23];
      if ((v7 & 0x80u) == 0) {
        int v8 = (void *)a2[23];
      }
      else {
        int v8 = (void *)*((void *)a2 + 1);
      }
      unint64_t v9 = v21;
      unsigned __int8 v10 = v21;
      if ((v21 & 0x80u) != 0) {
        unint64_t v9 = (unint64_t)object[1];
      }
      if (v8 != (void *)v9) {
        goto LABEL_22;
      }
      if ((v21 & 0x80u) == 0) {
        BOOL v11 = object;
      }
      else {
        BOOL v11 = (xpc_object_t *)object[0];
      }
      if ((v7 & 0x80) != 0)
      {
        if (memcmp(*(const void **)a2, v11, *((void *)a2 + 1))) {
          goto LABEL_22;
        }
      }
      else
      {
        CFBooleanRef v12 = a2;
        if (a2[23])
        {
          while (*v12 == *(unsigned __int8 *)v11)
          {
            ++v12;
            BOOL v11 = (xpc_object_t *)((char *)v11 + 1);
            if (!--v7) {
              goto LABEL_19;
            }
          }
          goto LABEL_22;
        }
      }
LABEL_19:
      if ((v6 & 0xFFFFFFFE) == 0)
      {
        v17[0] = v2;
        v17[1] = "kIsInMultiParty";
        sub_100048BAC((uint64_t)v17, &__p);
        uint64_t v14 = xpc::dyn_cast_or_default((xpc *)&__p, 0, v13);
        xpc_release(__p);
        if ((v21 & 0x80) != 0) {
          goto LABEL_23;
        }
        goto LABEL_24;
      }
LABEL_22:
      uint64_t v14 = 0;
      if ((v10 & 0x80) != 0) {
LABEL_23:
      }
        operator delete(object[0]);
LABEL_24:
      xpc_release(v19);
      v2 += 8;
      if (v2 == v3) {
        int v15 = 1;
      }
      else {
        int v15 = v14;
      }
      if (v15 == 1) {
        return v14;
      }
    }
  }
  return 0;
}

void sub_1008494C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t object,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  xpc_release(a14);
  _Unwind_Resume(a1);
}

void sub_100849534(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1008499AC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

const char *sub_100849BD0(int a1)
{
  id v1 = "ntw.ctr.?";
  if (a1 == 2) {
    id v1 = "ntw.ctr.2";
  }
  if (a1 == 1) {
    return "ntw.ctr.1";
  }
  else {
    return v1;
  }
}

void sub_100849BFC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100849CFC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting state", v6, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  *(_DWORD *)(a1 + 120) = 0;
  return sub_10084AC8C(a1, 0);
}

void sub_100849DB0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v5 = v4;
  if (*(void *)(a1 + 88))
  {
    int v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(int *)(a1 + 120);
      if (v7 > 2) {
        int v8 = "???";
      }
      else {
        int v8 = off_101A10A70[v7];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Already configured managed hours from source %s", buf, 0xCu);
    }
  }
  else
  {
    *(_OWORD *)long long buf = 0u;
    long long v12 = 0u;
    sub_1009501C8((Registry **)(a1 + 56), a2, buf);
    if (*(void *)buf == *(void *)&buf[8])
    {
      unint64_t v9 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I No managed hours configuration found in carrier bundle", (uint8_t *)v10, 2u);
      }
    }
    else
    {
      sub_100849F5C(a1, (uint64_t)buf, 2u);
    }
    sub_10007CA64((const void **)&v12 + 1);
    v10[0] = (void **)buf;
    sub_10061B228(v10);
  }
}

void sub_100849F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100615960((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100849F5C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6 = (Registry **)(a1 + 56);
  if ((sub_100950DC4(a1 + 56, a2) & 1) == 0)
  {
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v19 = *(void *)(a2 + 24);
    *(_DWORD *)uint64_t v73 = 138412290;
    *(void *)&v73[4] = v19;
    uint64_t v20 = "#I Current managed hours have expired (%@)";
    unsigned __int8 v21 = v18;
    uint32_t v22 = 12;
    goto LABEL_32;
  }
  unsigned int v54 = a3;
  uint64_t v7 = *(void *)(a2 + 8);
  if (*(void *)a2 == v7) {
    goto LABEL_26;
  }
  uint64_t v8 = *(void *)a2 + 16;
  while ((*(_DWORD *)(v8 - 16) & 0xFFFFFFFD) != 1)
  {
LABEL_19:
    uint64_t v17 = v8 + 16;
    v8 += 32;
    if (v17 == v7) {
      goto LABEL_26;
    }
  }
  double AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)v8);
  double v10 = CFDateGetAbsoluteTime(*(CFDateRef *)(v8 - 8));
  cf[0] = 0;
  getCurrentDate();
  int v11 = *(_DWORD *)(v8 + 8);
  uint64_t v75 = 0;
  memset(v74, 0, sizeof(v74));
  *(_OWORD *)uint64_t v73 = 0u;
  *(_DWORD *)uint64_t v73 = v11;
  sub_100602120((const void **)&v73[8], (const void **)v8);
  LOBYTE(v74[0]) = 1;
  theDate[0] = 0;
  CFDateRef v12 = (const __CFDate *)cf[0];
  v60.i64[0] = (uint64_t)cf[0];
  if (cf[0]) {
    CFRetain(cf[0]);
  }
  computeDeadlineAfterDate((const SchedulerSpec *)v73, v12);
  sub_10007CA64((const void **)&v60);
  double v13 = CFDateGetAbsoluteTime(theDate[0]);
  double v14 = v13 - CFDateGetAbsoluteTime((CFDateRef)cf[0]);
  if (v14 == AbsoluteTime - v10) {
    int v15 = 0;
  }
  else {
    int v15 = -127;
  }
  if (v14 > AbsoluteTime - v10) {
    int v15 = 1;
  }
  if (v14 < AbsoluteTime - v10) {
    int v15 = -1;
  }
  if (v15 == -127 || (char)v15 > 0)
  {
    sub_10007CA64((const void **)theDate);
    sub_100146540((uint64_t (**)(void, void, void, void, void))v74 + 1);
    sub_10007CA64((const void **)&v73[8]);
    sub_10007CA64(cf);
    goto LABEL_19;
  }
  int v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef v24 = cf[0];
    uint64_t v26 = *(void *)(v8 - 8);
    CFDateRef v25 = *(CFDateRef *)v8;
    uint64_t v27 = asString();
    *(_DWORD *)long long buf = 138413058;
    *(void *)&uint8_t buf[4] = v24;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v26;
    *(_WORD *)&unsigned char buf[22] = 2112;
    *(void *)&unsigned char buf[24] = v25;
    __int16 v71 = 2080;
    uint64_t v72 = v27;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Current time %@, is within window [start=%@, end=%@, day=%s]", buf, 0x2Au);
  }
  sub_10007CA64((const void **)theDate);
  sub_100146540((uint64_t (**)(void, void, void, void, void))v74 + 1);
  sub_10007CA64((const void **)&v73[8]);
  sub_10007CA64(cf);
  sub_10084AC8C(a1, 2);
LABEL_26:
  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    uint64_t v31 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint64_t v73 = 0;
    uint64_t v20 = "#I No time windows to schedule";
    unsigned __int8 v21 = v31;
    uint32_t v22 = 2;
LABEL_32:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, v73, v22);
    return;
  }
  int64x2_t v60 = 0uLL;
  uint64_t v61 = 0;
  sub_100950FAC((uint64_t *)a2, &v60);
  double v28 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v29 = v54;
    if (v54 > 2) {
      uint64_t v30 = "???";
    }
    else {
      uint64_t v30 = off_101A10A70[v54];
    }
    *(_DWORD *)uint64_t v73 = 136315138;
    *(void *)&v73[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Instantiating scheduler from source: %s", v73, 0xCu);
    double v28 = *(NSObject **)(a1 + 40);
  }
  else
  {
    unsigned int v29 = v54;
  }
  PeriodicSchedulerConfiguration::dumpState((PeriodicSchedulerConfiguration *)&v60, (os_log_s *)v28);
  uint64_t v32 = *(void *)(a1 + 72);
  unsigned int v33 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v33;
  if (v33) {
    dispatch_retain(v33);
  }
  int64x2_t v57 = v60;
  uint64_t v58 = v61;
  uint64_t v61 = 0;
  int64x2_t v60 = 0uLL;
  long long v34 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v34 || (uint64_t v35 = *(void *)(a1 + 8), (v36 = std::__shared_weak_count::lock(v34)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v55 = v35;
  id v56 = v36;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, dispatch_object_t *, int64x2_t *, uint64_t *))(*(void *)v32 + 16))(v73, v32, &object, &v57, &v55);
  long long v37 = *(_OWORD *)v73;
  memset(v73, 0, sizeof(v73));
  int v38 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v37;
  if (v38)
  {
    sub_10004D2C8(v38);
    if (*(void *)&v73[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v73[8]);
    }
  }
  if (v56) {
    sub_10004D2C8(v56);
  }
  *(void *)long long buf = &v57;
  sub_100146490((void ***)buf);
  if (object) {
    dispatch_release(object);
  }
  if (*(void *)(a2 + 24)) {
    long long v39 = sub_1001908E4;
  }
  else {
    long long v39 = 0;
  }
  if (v39)
  {
    memset(buf, 0, sizeof(buf));
    long long v40 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v40 || (uint64_t v41 = *(void *)(a1 + 8), (v42 = std::__shared_weak_count::lock(v40)) == 0)) {
      sub_100088B9C();
    }
    long long v43 = v42;
    atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v42);
    uint64_t v44 = operator new(0x20uLL);
    *uint64_t v44 = off_101A109F0;
    v44[1] = a1;
    v44[2] = v41;
    v44[3] = v43;
    *(void *)&unsigned char buf[24] = v44;
    CFDateRef v67 = 0;
    getCurrentDate();
    double v45 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 24));
    double v46 = CFDateGetAbsoluteTime(v67);
    std::string v47 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = *(void *)(a2 + 24);
      *(_DWORD *)uint64_t v73 = 138412290;
      *(void *)&v73[4] = v48;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Scheduling timer for managed hours expiration at %@", v73, 0xCu);
    }
    Registry::getTimerService(&v64, *v6);
    uint64_t v49 = v64;
    sub_100058DB0(theDate, "NetworkTimeWindowController Expiration Timer");
    *(_OWORD *)CFTypeRef cf = *(_OWORD *)theDate;
    uint64_t v69 = v63;
    theDate[0] = 0;
    theDate[1] = 0;
    uint64_t v63 = 0;
    sub_1000DA470((uint64_t)v73, (uint64_t)buf);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, CFTypeRef *, uint64_t, uint64_t, void, uint8_t *))(*(void *)v49 + 40))(&v66, v49, cf, 1, (uint64_t)((v45 - v46) * 1000000.0), 0, v73);
    sub_10003B34C(v73);
    if (SHIBYTE(v69) < 0) {
      operator delete((void *)cf[0]);
    }
    uint64_t v50 = v66;
    uint64_t v66 = 0;
    uint64_t v51 = *(void *)(a1 + 232);
    *(void *)(a1 + 232) = v50;
    if (v51)
    {
      (*(void (**)(uint64_t))(*(void *)v51 + 8))(v51);
      uint64_t v52 = v66;
      uint64_t v66 = 0;
      if (v52) {
        (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
      }
    }
    if (SHIBYTE(v63) < 0) {
      operator delete(theDate[0]);
    }
    if (v65) {
      sub_10004D2C8(v65);
    }
    sub_10007CA64((const void **)&v67);
    sub_10003B34C(buf);
  }
  else
  {
    uint64_t v53 = *(void *)(a1 + 232);
    *(void *)(a1 + 232) = 0;
    if (v53) {
      (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  *(_DWORD *)(a1 + 120) = v29;
  *(void *)uint64_t v73 = &v60;
  sub_100146490((void ***)v73);
}

void sub_10084A680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, dispatch_object_t object, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37)
{
  sub_10007CA64((const void **)&a20);
  sub_100146540(v38);
  sub_10007CA64(v37);
  sub_10007CA64((const void **)&__p);
  _Unwind_Resume(a1);
}

void sub_10084A79C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 176))
  {
    uint64_t v4 = *(unsigned int *)(a1 + 184);
    if ((subscriber::isValidSimSlot() & 1) == 0)
    {
      uint32_t v22 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v28) = 0;
      int v23 = "#I User data SIM has not settled yet, ignoring carrier bundle change event";
      CFTypeRef v24 = v22;
      uint32_t v25 = 2;
      goto LABEL_35;
    }
    uint64_t v7 = *(void *)(a2 + 8);
    uint64_t v6 = a2 + 8;
    uint64_t v5 = v7;
    if (!v7) {
      goto LABEL_13;
    }
    uint64_t v8 = v6;
    do
    {
      int v9 = *(_DWORD *)(v5 + 32);
      BOOL v10 = v9 < (int)v4;
      if (v9 >= (int)v4) {
        int v11 = (uint64_t *)v5;
      }
      else {
        int v11 = (uint64_t *)(v5 + 8);
      }
      if (!v10) {
        uint64_t v8 = v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    if (v8 != v6 && *(_DWORD *)(v8 + 32) <= (int)v4) {
      int v12 = *(unsigned __int8 *)(v8 + 40);
    }
    else {
LABEL_13:
    }
      int v12 = 255;
    uint64_t v13 = *(void *)(a1 + 168);
    if (!v13) {
      goto LABEL_24;
    }
    uint64_t v14 = a1 + 168;
    do
    {
      int v15 = *(_DWORD *)(v13 + 32);
      BOOL v16 = v15 < (int)v4;
      if (v15 >= (int)v4) {
        uint64_t v17 = (uint64_t *)v13;
      }
      else {
        uint64_t v17 = (uint64_t *)(v13 + 8);
      }
      if (!v16) {
        uint64_t v14 = v13;
      }
      uint64_t v13 = *v17;
    }
    while (*v17);
    if (v14 != a1 + 168 && *(_DWORD *)(v14 + 32) <= (int)v4) {
      unsigned int v18 = *(unsigned __int8 *)(v14 + 40);
    }
    else {
LABEL_24:
    }
      unsigned int v18 = 255;
    if (v12 != v18)
    {
      uint64_t v19 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      if (v12 == 255)
      {
        uint64_t v26 = *v19;
        if (os_log_type_enabled(*v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v28) = 0;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle became known, loading managed hours", (uint8_t *)&v28, 2u);
        }
        goto LABEL_43;
      }
      uint64_t v20 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      if (v18 <= 5)
      {
        if (((1 << v18) & 0x31) != 0)
        {
LABEL_41:
          os_log_t v27 = *v20;
          if (!os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT)) {
            return;
          }
          int v28 = 136315138;
          uint64_t v29 = asString();
          int v23 = "#I Ignoring bundle change type: %s";
          CFTypeRef v24 = v27;
          uint32_t v25 = 12;
LABEL_35:
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v28, v25);
          return;
        }
        if (((1 << v18) & 6) != 0)
        {
          unsigned __int8 v21 = *v20;
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
          {
            int v28 = 136315138;
            uint64_t v29 = asString();
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Resetting due to bundle change (%s)", (uint8_t *)&v28, 0xCu);
          }
          sub_100849CFC(a1);
          goto LABEL_43;
        }
      }
      if (v18 != 255)
      {
LABEL_43:
        sub_100849DB0(a1, v4);
        return;
      }
      goto LABEL_41;
    }
  }
}

void sub_10084AA78(uint64_t a1, int a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 184);
  if (subscriber::isValidSimSlot())
  {
    uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    if (v4 != a2)
    {
      uint64_t v6 = *(void *)(a1 + 168);
      if (!v6) {
        goto LABEL_17;
      }
      uint64_t v7 = a1 + 168;
      do
      {
        int v8 = *(_DWORD *)(v6 + 32);
        BOOL v9 = v8 < (int)v4;
        if (v8 >= (int)v4) {
          BOOL v10 = (uint64_t *)v6;
        }
        else {
          BOOL v10 = (uint64_t *)(v6 + 8);
        }
        if (!v9) {
          uint64_t v7 = v6;
        }
        uint64_t v6 = *v10;
      }
      while (*v10);
      if (v7 == a1 + 168 || (int)v4 < *(_DWORD *)(v7 + 32) || *(unsigned __int8 *)(v7 + 40) == 255)
      {
LABEL_17:
        int v12 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v13) = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle is not known yet", (uint8_t *)&v13, 2u);
        }
      }
      else
      {
        int v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315394;
          uint64_t v14 = subscriber::asString();
          __int16 v15 = 2080;
          uint64_t v16 = subscriber::asString();
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I User data SIM has changed from %s to %s", (uint8_t *)&v13, 0x16u);
        }
        sub_100849CFC(a1);
        sub_100849DB0(a1, v4);
      }
    }
  }
}

void sub_10084AC28(uint64_t a1)
{
  uint64_t v2 = a1 + 128;
  if ((rest::carrier_space::operator==() & 1) == 0)
  {
    sub_100849CFC(a1);
    sub_100849F5C(a1, v2, 1u);
  }
}

uint64_t sub_10084AC8C(uint64_t a1, int a2)
{
  LODWORD(v6) = a2;
  HIDWORD(v6) = *(_DWORD *)(a1 + 184);
  uint64_t v3 = a1 + 224;
  uint64_t result = rest::operator==();
  if ((result & 1) == 0)
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), HIDWORD(v6));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      uint64_t v8 = rest::asString();
      __int16 v9 = 2080;
      uint64_t v10 = rest::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Setting interface cost from %s to %s", buf, 0x16u);
    }
    *(void *)(a1 + 224) = v6;
    uint64_t result = *(void *)(a1 + 216);
    if (result) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v3);
    }
  }
  return result;
}

void sub_10084ADDC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 120);
    if (v3 > 2) {
      uint64_t v4 = "???";
    }
    else {
      uint64_t v4 = off_101A10A70[v3];
    }
    int v9 = 136315138;
    uint64_t v10 = (uint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Data Source: %s", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 228));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = rest::asString();
    int v9 = 136315138;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Internet Cost: %s", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Scheduler Config:", (uint8_t *)&v9, 2u);
      uint64_t v7 = *(void *)(a1 + 88);
    }
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
}

uint64_t sub_10084AF8C(uint64_t a1, uint64_t a2, SchedulerSpec *a3)
{
  uint64_t v3 = (uint64_t (*)(uint64_t, char *, void, _UNKNOWN **, void *))*((void *)a3 + 3);
    sub_10084C988();
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = "???";
    if (*v6 == 1) {
      uint64_t v8 = "kEnd";
    }
    if (*v6) {
      int v9 = v8;
    }
    else {
      int v9 = "kStart";
    }
    int v11 = 136315138;
    int v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Scheduler timer has fired with event type %s, spec:", (uint8_t *)&v11, 0xCu);
    uint64_t v7 = *(NSObject **)(a1 + 40);
  }
  SchedulerSpec::dumpState(a3, (os_log_s *)v7);
  return sub_10084AC8C(a1, 2 * (*v6 == 0));
}

void sub_10084B0BC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_10084B0CC(uint64_t a1)
{
  sub_10084B104(a1);

  operator delete();
}

uint64_t sub_10084B104(uint64_t a1)
{
  *(void *)a1 = off_101A10550;
  uint64_t v2 = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_10084B224((void *)(a1 + 192));
  sub_100087F94(a1 + 160, *(void **)(a1 + 168));
  sub_10007CA64((const void **)(a1 + 152));
  int v9 = (void **)(a1 + 128);
  sub_10061B228(&v9);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 64);
  if (v6) {
    sub_10004D2C8(v6);
  }
  PeriodicSchedulerDelegateInterface::~PeriodicSchedulerDelegateInterface((PeriodicSchedulerDelegateInterface *)a1);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void *sub_10084B224(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10084B2AC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10084B2E4(uint64_t a1)
{
}

uint64_t sub_10084B300(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10084B344(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10084B370(ServiceManager::Service *this)
{
  *(void *)this = off_101A106A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10084B3CC(ServiceManager::Service *this)
{
  *(void *)this = off_101A106A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10084B43C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "NetworkTimeWindowController");
}

unsigned char *sub_10084B44C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10084B48C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    sub_100849BFC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100849BFC(v4, 0);
}

uint64_t sub_10084B500()
{
  return 0;
}

uint64_t sub_10084B508()
{
  return 1;
}

uint64_t sub_10084B510()
{
  return 0;
}

void sub_10084B51C(uint64_t a1)
{
  id v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10084B5FC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10084B714()
{
}

uint64_t sub_10084B728(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_10084B734(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 88);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  sub_100088C88(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10084B7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10084B7F8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  sub_100058DB0(__p, "/cc/props/managed_hours");
  uint64_t v4 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v4 = off_101A10760;
  *((void *)v4 + 1) = v2 + 128;
  *((void *)v4 + 2) = v2;
  *((void *)v4 + 3) = sub_10084AC28;
  *((void *)v4 + 4) = 0;
  unsigned int v18 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v5 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v5 = off_101A107E0;
  *((void *)v5 + 1) = v2 + 160;
  *((void *)v5 + 2) = v2;
  *((void *)v5 + 3) = sub_10084A79C;
  *((void *)v5 + 4) = 0;
  unsigned int v18 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/user_preferred_data_slot");
  uint64_t v6 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v6 = off_101A10860;
  *((void *)v6 + 1) = v2 + 184;
  *((void *)v6 + 2) = v2;
  *((void *)v6 + 3) = sub_10084AA78;
  *((void *)v6 + 4) = 0;
  unsigned int v18 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v7 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v7 = off_101A108E0;
  *((void *)v7 + 1) = v2;
  *((void *)v7 + 2) = sub_10084ADDC;
  *((void *)v7 + 3) = 0;
  unsigned int v18 = v7;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection(&v14, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v8 = (uint8_t *)(v2 + 192);
  *(void *)long long buf = off_101A10960;
  uint64_t v17 = v2 + 104;
  unsigned int v18 = buf;
  if (buf != (uint8_t *)(v2 + 192))
  {
    int v9 = *(uint8_t **)(v2 + 216);
    if (v9 == v8)
    {
      __p[1] = (void *)(v2 + 104);
      uint64_t v20 = 0;
      unsigned int v18 = 0;
      __p[0] = off_101A10960;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v8 + 24))(v2 + 192, buf);
      (*(void (**)(void))(**(void **)(v2 + 216) + 32))(*(void *)(v2 + 216));
      *(void *)(v2 + 216) = 0;
      unsigned int v18 = buf;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, v2 + 192);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(v2 + 192) = off_101A10960;
      *(void *)(v2 + 200) = v2 + 104;
      unsigned int v18 = v9;
    }
    *(void *)(v2 + 216) = v8;
  }
  sub_10084B224(buf);
  uint64_t v10 = *(void *)(v2 + 216);
  if (v10) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v2 + 224);
  }
  sub_100088C88(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_10084BC30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10084BCB4()
{
}

__n128 sub_10084BCC8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A10760;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10084BD1C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10760;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10084BD54(void *a1)
{
  uint64_t v2 = (long long *)a1[1];
  long long v7 = *v2;
  uint64_t v3 = (const void *)*((void *)v2 + 3);
  uint64_t v8 = *((void *)v2 + 2);
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  int v9 = v3;
  *((void *)v2 + 3) = 0;
  rest::carrier_space::read_rest_value();
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  sub_10007CA64(&v9);
  uint64_t v10 = (void **)&v7;
  sub_10061B228(&v10);
}

void sub_10084BE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10007CA64(v6);
  sub_10061B228((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10084BE38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10084BE78()
{
}

void sub_10084BE88()
{
}

__n128 sub_10084BE9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A107E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10084BEF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A107E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10084BF28(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_10084BFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10084C000(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10084C040()
{
}

void sub_10084C050()
{
}

__n128 sub_10084C064(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A10860;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10084C0B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10084C0F0(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10084C1E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10084C228()
{
}

void sub_10084C238()
{
}

__n128 sub_10084C24C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A108E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10084C2A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A108E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10084C2D8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10084C320(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10084C360()
{
}

void sub_10084C370()
{
}

void *sub_10084C384(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A10960;
  result[1] = v3;
  return result;
}

uint64_t sub_10084C3CC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A10960;
  a2[1] = v2;
  return result;
}

void sub_10084C3F8()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/props/internet_interface_cost");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_10084C49C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10084C4E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10084C520()
{
}

void sub_10084C52C(uint64_t a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = *(NSObject **)(**(void **)a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  operator delete();
}

void *sub_10084C5B8(void *a1)
{
  *a1 = off_101A109F0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10084C604(void *a1)
{
  *a1 = off_101A109F0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10084C670(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A109F0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10084C6D4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A109F0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10084C714(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10084C724(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10084C764(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_10084C874(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10084C8B4()
{
}

void sub_10084C8C0(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Managed hours expiration timer triggered, stopping scheduler", buf, 2u);
  }
  sub_100849CFC(v1);
  operator delete();
}

void sub_10084C95C()
{
}

void sub_10084C988()
{
  exception = (std::bad_cast *)__cxa_allocate_exception(8uLL);
  exception->__vftable = 0;
  uint64_t v1 = sub_10084C9C0(exception);
}

std::bad_cast *sub_10084C9C0(std::bad_cast *a1)
{
  __n128 result = std::bad_cast::bad_cast(a1);
  return result;
}

void stewie::ConnectionAssistantGPSDataSource::create()
{
}

void sub_10084CA64()
{
}

void stewie::ConnectionAssistantGPSDataSource::currentGPSTime(stewie::ConnectionAssistantGPSDataSource *this@<X0>, unint64_t *a2@<X8>)
{
  if (*((unsigned char *)this + 40))
  {
    unint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 1) + 16))(*((void *)this + 1));
    unint64_t v5 = *((void *)this + 4);
    BOOL v6 = v4 >= v5;
    unint64_t v7 = v4 - v5;
    if (v6)
    {
      unint64_t v8 = v7 + *((void *)this + 2);
    }
    else
    {
      int v9 = *(NSObject **)this;
      if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_ERROR))
      {
        v11[0] = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Mach continuous time now is less than GPS data timestamp", (uint8_t *)v11, 2u);
      }
      unint64_t v8 = *((void *)this + 2);
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  *a2 = v8;
}

double stewie::ConnectionAssistantGPSDataSource::location(stewie::ConnectionAssistantGPSDataSource *this)
{
  if (*((unsigned char *)this + 72)) {
    return *((double *)this + 6);
  }
  else {
    return 0.0;
  }
}

void stewie::ConnectionAssistantGPSDataSource::handleDumpState(stewie::ConnectionAssistantGPSDataSource *this)
{
  uint64_t v2 = *(NSObject **)this;
  if (os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ******************************************", (uint8_t *)&__p, 2u);
    uint64_t v2 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * ConnectionAssistantGPSDataSource state *", (uint8_t *)&__p, 2u);
    uint64_t v2 = *(NSObject **)this;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ******************************************", (uint8_t *)&__p, 2u);
    uint64_t v2 = *(NSObject **)this;
  }
  int v3 = *((unsigned __int8 *)this + 40);
  BOOL v4 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v4)
    {
      std::string::size_type v5 = *((void *)this + 2);
      LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] GPS time, ns: %llu", (uint8_t *)&__p, 0xCu);
      uint64_t v2 = *(NSObject **)this;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *((_DWORD *)this + 6);
      LODWORD(__p.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v6;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] gpsUTCLeapSecond: %d", (uint8_t *)&__p, 8u);
      uint64_t v2 = *(NSObject **)this;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      std::to_string(&__p, *((void *)this + 4));
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v20 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Recorded at: %{public}s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else if (v4)
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Time not set", (uint8_t *)&__p, 2u);
  }
  int v8 = *((unsigned __int8 *)this + 72);
  os_log_t v9 = *(os_log_t *)this;
  BOOL v10 = os_log_type_enabled(*(os_log_t *)this, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (!v10) {
      return;
    }
    double v11 = *((double *)this + 6) * 180.0 / 3.14159265;
    double v12 = *((double *)this + 7) * 180.0;
    LODWORD(__p.__r_.__value_.__l.__data_) = 134284033;
    uint64_t v13 = *((void *)this + 8);
    *(double *)((char *)__p.__r_.__value_.__r.__words + 4) = v11;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2049;
    *(double *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v12 / 3.14159265;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 2049;
    uint64_t v18 = v13;
    unsigned int v14 = "#I [d] Location: [%{private}.6f, %{private}.6f, %{private}.6f]";
    __int16 v15 = v9;
    uint32_t v16 = 32;
  }
  else
  {
    if (!v10) {
      return;
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    unsigned int v14 = "#I [d] Location not set";
    __int16 v15 = v9;
    uint32_t v16 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&__p, v16);
}

uint64_t sub_10084CE94(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "rm.op");
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  int v3 = dispatch_queue_create("OperatingModeManager", v2);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = v3;
  if (v3)
  {
    BOOL v4 = v3;
    dispatch_retain(v3);
    *(void *)(a1 + 72) = 0;
    dispatch_release(v4);
  }
  else
  {
    *(void *)(a1 + 72) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 80), (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *(void *)a1 = off_101A10C78;
  sub_100058DB0(&__p, "OperatingModeManager");
  RestServiceBase::RestServiceBase();
  if (v11 < 0) {
    operator delete(__p.var0);
  }
  *(void *)a1 = off_101A10A98;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 109) = 0;
  std::string::size_type v5 = (capabilities::ct *)CTStopwatch::CTStopwatch();
  *(_DWORD *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(unsigned char *)(a1 + 220) = 1;
  int v6 = (capabilities::ct *)capabilities::ct::supportsStewie(v5);
  if (v6 && capabilities::ct::supportsSARAveraging(v6))
  {
    unint64_t v7 = operator new(8uLL);
    v9[0] = v7;
    *unint64_t v7 = @"Stewie";
    v9[1] = v7 + 1;
    void v9[2] = v7 + 1;
    sub_10026EFA4(&__p);
  }
  return a1;
}

void sub_10084D12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14) {
    sub_10026CD9C(v19 + 8, a14);
  }
  if (__p) {
    operator delete(__p);
  }
  unsigned __int8 v21 = (std::__shared_weak_count *)*((void *)v18 + 18);
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint32_t v22 = (std::__shared_weak_count *)*((void *)v18 + 16);
  if (v22) {
    sub_10004D2C8(v22);
  }
  int v23 = (std::__shared_weak_count *)*((void *)v18 + 12);
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_10084D204(v18);
  _Unwind_Resume(a1);
}

RestServiceBase *sub_10084D204(RestServiceBase *a1)
{
  RestServiceBase::~RestServiceBase(a1);
  int v3 = (void *)(v2 + 48);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v2 + 80));
  sub_100087E88(v3);
  return a1;
}

uint64_t sub_10084D240(void *a1)
{
  uint64_t v2 = a1[10];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Running", buf, 2u);
  }
  sub_100058DB0(__p, "/cc/prefs-nb/debug_baseband_operating_mode");
  int v3 = (uint8_t *)operator new(0x28uLL);
  *(void *)int v3 = off_101A10CA8;
  *((void *)v3 + 1) = a1 + 27;
  *((void *)v3 + 2) = a1;
  *((void *)v3 + 3) = sub_10084D71C;
  *((void *)v3 + 4) = 0;
  uint64_t v17 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100850478((uint64_t)__p);
  *(void *)long long buf = off_101A10D28;
  __int16 v15 = a1 + 25;
  uint32_t v16 = a1;
  uint64_t v17 = buf;
  ctu::RestModule::observeProperty();
  BOOL v4 = (capabilities::ct *)sub_10003F600(buf);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  std::string::size_type v5 = (capabilities::ct *)capabilities::ct::supportsCampOnlyMode(v4);
  if ((v5 & 1) != 0 || capabilities::ct::supportsCMASCampOnlyMode(v5))
  {
    sub_1008506BC((uint64_t)__p);
    *(void *)long long buf = off_101A10DA8;
    __int16 v15 = a1 + 22;
    uint32_t v16 = a1;
    uint64_t v17 = buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100850900((uint64_t)__p);
  *(void *)long long buf = off_101A10E28;
  __int16 v15 = a1 + 23;
  uint32_t v16 = a1;
  uint64_t v17 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_100850B44((uint64_t)__p);
  *(void *)long long buf = off_101A10EA8;
  __int16 v15 = a1 + 24;
  uint32_t v16 = a1;
  uint64_t v17 = buf;
  ctu::RestModule::observeProperty();
  int v6 = (capabilities::ct *)sub_10003F600(buf);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v7 = (capabilities::ct *)capabilities::ct::supportsStewie(v6);
  if (v7)
  {
    sub_100850D88((uint64_t)__p);
    *(void *)long long buf = off_101A10F28;
    __int16 v15 = a1 + 26;
    uint32_t v16 = a1;
    uint64_t v17 = buf;
    ctu::RestModule::observeProperty();
    int v8 = (capabilities::ct *)sub_10003F600(buf);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v7 = (capabilities::ct *)capabilities::ct::supportsSARAveraging(v8);
    if (v7)
    {
      sub_100058DB0(__p, "/cc/events/stewie_block_cellular_tx_event");
      *(void *)long long buf = off_101A10FA8;
      __int16 v15 = a1;
      uint64_t v17 = buf;
      ctu::RestModule::observeEvent();
      unint64_t v7 = (capabilities::ct *)sub_10003F600(buf);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
  }
  if ((capabilities::ct::supportsVoiceCall(v7) & 1) == 0)
  {
    sub_100058DB0(__p, "/cc/props/cellular_data_setting");
    os_log_t v9 = (uint8_t *)operator new(0x28uLL);
    *(void *)os_log_t v9 = off_101A11028;
    *((void *)v9 + 1) = (char *)a1 + 220;
    *((void *)v9 + 2) = a1;
    *((void *)v9 + 3) = sub_10084D71C;
    *((void *)v9 + 4) = 0;
    uint64_t v17 = v9;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  BOOL v10 = (uint8_t *)operator new(0x20uLL);
  *(void *)BOOL v10 = off_101A110A8;
  *((void *)v10 + 1) = a1;
  *((void *)v10 + 2) = sub_10084D720;
  *((void *)v10 + 3) = 0;
  uint64_t v17 = v10;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  sub_1008EEB4C((uint64_t)a1);
  sub_10084D744(a1, 1);
  uint64_t result = a1[11];
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  return result;
}

void sub_10084D6BC(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, int a5, __int16 a6, char a7, char a8, ...)
{
  va_start(va, a8);
  sub_10003F600((uint64_t *)va);
  if (a8 < 0) {
    operator delete(a3);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10084D720(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

void sub_10084D744(void *a1, char a2)
{
  a1[21] = 0;
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = CTStopwatch::stop((CTStopwatch *)(a1 + 17));
    if (v4) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = 0;
    }
    a1[21] = v5;
  }
  int v6 = (CTStopwatch *)(a1 + 17);
  CTStopwatch::start((CTStopwatch *)(a1 + 17));
  unint64_t v7 = a1[10];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = a1[21];
    uint64_t StartTime = CTStopwatch::getStartTime(v6);
    if (v10) {
      uint64_t v11 = StartTime;
    }
    else {
      uint64_t v11 = 0;
    }
    int v12 = 134218240;
    uint64_t v13 = v8;
    __int16 v14 = 2048;
    uint64_t v15 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Update Operating Mode Assertion Time: assertionHoldTime=%lld ms, currentTime=%lld ms", (uint8_t *)&v12, 0x16u);
  }
}

void sub_10084D830(void *a1)
{
  uint64_t v2 = a1[10];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Stopping", (uint8_t *)__p, 2u);
  }
  sub_100850478((uint64_t)__p);
  ctu::RestModule::unobserveProperty();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_100850900((uint64_t)__p);
  ctu::RestModule::unobserveProperty();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_1008506BC((uint64_t)__p);
  ctu::RestModule::unobserveProperty();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  sub_100850B44((uint64_t)__p);
  uint64_t v3 = (capabilities::ct *)ctu::RestModule::unobserveProperty();
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsStewie(v3))
  {
    sub_100850D88((uint64_t)__p);
    ctu::RestModule::unobserveProperty();
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
  char v4 = (std::__shared_weak_count *)a1[16];
  a1[15] = 0;
  a1[16] = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_10084D964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10084D994(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 216);
  if (!v2)
  {
    char v4 = (capabilities::ct *)capabilities::ct::supportsStewie((capabilities::ct *)a1);
    if (v4 && (*(_DWORD *)(a1 + 212) - 1) < 2) {
      return 3;
    }
    if (*(unsigned char *)(a1 + 116))
    {
      if ((*(_DWORD *)(a1 + 196) - 1) < 2) {
        return 2;
      }
    }
    else
    {
      if ((*(_DWORD *)(a1 + 204) - 1) < 2) {
        return 5;
      }
      if ((*(_DWORD *)(a1 + 196) - 1) < 2) {
        return 2;
      }
      if ((*(_DWORD *)(a1 + 188) - 1) < 2) {
        return 5;
      }
    }
    if ((*(_DWORD *)(a1 + 180) - 1) < 2) {
      return 4;
    }
    if ((capabilities::ct::supportsVoiceCall(v4) & 1) != 0 || *(unsigned char *)(a1 + 220)) {
      return 0;
    }
    return 2;
  }
  uint64_t v3 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315138;
    uint64_t v7 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [    ] evaluation uses forced debug mode: %s", (uint8_t *)&v6, 0xCu);
    return *(unsigned int *)(a1 + 216);
  }
  return v2;
}

uint64_t sub_10084DAF8(unsigned char *a1)
{
  uint64_t result = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 48))(a1);
  if (!result)
  {
    if (a1[116])
    {
      if (capabilities::ct::supportsCampOnlyMode((capabilities::ct *)result)) {
        return 4;
      }
      else {
        return 2;
      }
    }
    else
    {
      return 5;
    }
  }
  return result;
}

BOOL sub_10084DB64(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(int *)(a1 + 104);
  if (v3 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 80);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (v3 > 6) {
        int v6 = "?";
      }
      else {
        int v6 = off_101A115A8[v3];
      }
      if (a2 > 6) {
        uint64_t v7 = "?";
      }
      else {
        uint64_t v7 = off_101A115A8[a2];
      }
      int v9 = 136315394;
      char v10 = v6;
      __int16 v11 = 2080;
      int v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [... ] Operating mode transitioning from %s to %s", (uint8_t *)&v9, 0x16u);
    }
    *(_DWORD *)(a1 + 104) = a2;
  }
  return v3 != a2;
}

void *sub_10084DC68(void *result, int a2)
{
  uint64_t v3 = result;
  if (a2)
  {
    char v4 = result[10];
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_8;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v10 = asString();
    __int16 v11 = 2080;
    uint64_t v12 = asString();
    uint64_t v5 = "#I [ XX ] Operating mode set to: %s (was %s)";
    goto LABEL_7;
  }
  if (!*((_DWORD *)result + 27)) {
    return result;
  }
  char v4 = result[10];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    uint64_t v10 = asString();
    __int16 v11 = 2080;
    uint64_t v12 = asString();
    uint64_t v5 = "#I [    ] Operating mode set to: %s (was %s)";
LABEL_7:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 0x16u);
  }
LABEL_8:
  v3[27] = a2;
  uint64_t result = (void *)(*(uint64_t (**)(_DWORD *))(*(void *)v3 + 40))(v3);
  if (a2)
  {
    uint64_t v6 = v3[28];
    v3[28] = a2;
    sub_10084D744(v3, 0);
    unint64_t v7 = v3[28] | (unint64_t)(v6 << 32);
    v8[0] = off_101A11128;
    v8[1] = v3;
    void v8[2] = v7;
    void v8[3] = v8;
    sub_10084DE40((uint64_t)v3, (uint64_t)v8);
    return sub_10001E914(v8);
  }
  return result;
}

void sub_10084DE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10084DE40(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a1;
  sub_100058DB0(&v6, "/granted");
  char v4 = std::string::insert(&v6, 0, "/cc/assertions/baseband_booted", 0x1EuLL);
  std::string __p = *v4;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  *(void *)&long long v9 = a1;
  *((void *)&v9 + 1) = a1;
  sub_1000278EC((uint64_t)v10, a2);
  uint64_t v12 = 0;
  uint64_t v5 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v5 = off_101A11228;
  *(_OWORD *)(v5 + 8) = v9;
  sub_1000279CC((uint64_t)(v5 + 24), (uint64_t)v10);
  uint64_t v12 = v5;
  sub_10084F460(&v8, (uint64_t)"baseband booted", (long long *)&__p, (uint64_t)v11);
  sub_100851B80(v11);
  sub_10001E914(v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
}

void sub_10084DF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_100851B80((void *)(v22 - 56));
  sub_10001E914(v21);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void sub_10084DFDC(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 108))
  {
    case 1:
    case 2:
      if (*(_DWORD *)(a1 + 196) == 1)
      {
        uint64_t v2 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)
          || (*(_WORD *)long long buf = 0,
              _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [    ] granting airplane mode assertion", buf, 2u), *(_DWORD *)(a1 + 196) == 1))
        {
          sub_100058DB0(__p, "/cc/assertions/airplane_mode");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t object = xpc_int64_create(*(unsigned int *)(a1 + 192));
          if (!object) {
            xpc_object_t object = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(object);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (*(_DWORD *)(a1 + 180) == 2)
      {
        uint64_t v3 = *(NSObject **)(a1 + 80);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v4 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v4;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N [    ] camp-only-mode was granted but now in mode %s; revoking!",
            buf,
            0xCu);
        }
        goto LABEL_86;
      }
      break;
    case 3:
      if ((capabilities::ct::supportsStewie((capabilities::ct *)a1) & 1) == 0) {
        __TUAssertTrigger();
      }
      if (*(_DWORD *)(a1 + 212) == 1)
      {
        uint64_t v5 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)
          || (*(_WORD *)long long buf = 0,
              _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [    ] granting stewie-mode assertion", buf, 2u), *(_DWORD *)(a1 + 212) == 1))
        {
          sub_100058DB0(__p, "/cc/assertions/stewie_mode_assertion");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t objecta = xpc_int64_create(*(unsigned int *)(a1 + 208));
          if (!objecta) {
            xpc_object_t objecta = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(objecta);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (*(_DWORD *)(a1 + 204) == 2)
      {
        std::string v6 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)
          || (uint64_t v7 = asString(),
              *(_DWORD *)long long buf = 136315138,
              *(void *)&uint8_t buf[4] = v7,
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N [    ] emergency-mode was granted but now in mode %s; revoking!",
                buf,
                0xCu),
              *(_DWORD *)(a1 + 204)))
        {
          sub_100058DB0(__p, "/cc/assertions/emergency_online");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t objectb = xpc_int64_create(*(unsigned int *)(a1 + 200));
          if (!objectb) {
            xpc_object_t objectb = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(objectb);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (*(_DWORD *)(a1 + 196) == 2)
      {
        uint64_t v8 = *(NSObject **)(a1 + 80);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N [    ] airplane-mode was granted but now in mode %s; revoking!",
            buf,
            0xCu);
        }
        sub_10084EC54((unsigned int *)(a1 + 192));
      }
      if (*(_DWORD *)(a1 + 180) == 2)
      {
        uint64_t v10 = *(NSObject **)(a1 + 80);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N [    ] camp-only-mode was granted but now in mode %s; revoking!",
            buf,
            0xCu);
        }
        goto LABEL_86;
      }
      break;
    case 4:
      if (*(_DWORD *)(a1 + 180) == 1)
      {
        uint64_t v12 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)
          || (*(_WORD *)long long buf = 0,
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N [    ] granting camp-only-mode assertion", buf, 2u), *(_DWORD *)(a1 + 180) == 1))
        {
          sub_100058DB0(__p, "/cc/assertions/baseband_camp_only_assertion");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t objectc = xpc_int64_create(*(unsigned int *)(a1 + 176));
          if (!objectc) {
            xpc_object_t objectc = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(objectc);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      break;
    case 5:
      if (*(_DWORD *)(a1 + 204) == 1)
      {
        uint64_t v13 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)
          || (*(_WORD *)long long buf = 0,
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [    ] granting emergency-online assertion", buf, 2u), *(_DWORD *)(a1 + 204) == 1))
        {
          sub_100058DB0(__p, "/cc/assertions/emergency_online");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t objectd = xpc_int64_create(*(unsigned int *)(a1 + 200));
          if (!objectd) {
            xpc_object_t objectd = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(objectd);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (*(_DWORD *)(a1 + 188) == 1)
      {
        __int16 v14 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)
          || (*(_WORD *)long long buf = 0,
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [    ] granting baseband-online mode assertion", buf, 2u), *(_DWORD *)(a1 + 188) == 1))
        {
          sub_100058DB0(__p, "/cc/assertions/baseband_online");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t objecte = xpc_int64_create(*(unsigned int *)(a1 + 184));
          if (!objecte) {
            xpc_object_t objecte = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(objecte);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (*(_DWORD *)(a1 + 196) == 2)
      {
        uint64_t v15 = *(NSObject **)(a1 + 80);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N [    ] airplane-mode was granted but now in mode %s; revoking!",
            buf,
            0xCu);
        }
        sub_10084EC54((unsigned int *)(a1 + 192));
      }
      if (*(_DWORD *)(a1 + 212) == 2)
      {
        uint64_t v17 = *(NSObject **)(a1 + 80);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)
          || (uint64_t v18 = asString(),
              *(_DWORD *)long long buf = 136315138,
              *(void *)&uint8_t buf[4] = v18,
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N [    ] stewie-mode was granted but now in mode %s; revoking!",
                buf,
                0xCu),
              *(_DWORD *)(a1 + 212)))
        {
          sub_100058DB0(__p, "/cc/assertions/stewie_mode_assertion");
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          uint64_t v34 = v32;
          __p[1] = 0;
          uint64_t v32 = 0;
          __p[0] = 0;
          ctu::path_join_impl();
          xpc_object_t objectf = xpc_int64_create(*(unsigned int *)(a1 + 208));
          if (!objectf) {
            xpc_object_t objectf = xpc_null_create();
          }
          ctu::RestModule::setProperty();
          xpc_release(objectf);
          if (SHIBYTE(v34) < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v32) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      if (*(_DWORD *)(a1 + 180) == 2)
      {
        uint64_t v19 = *(NSObject **)(a1 + 80);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N [    ] camp-only-mode was granted but now in mode %s; revoking!",
            buf,
            0xCu);
        }
LABEL_86:
        sub_10084EB44((unsigned int *)(a1 + 176));
      }
      break;
    default:
      break;
  }
  if ((*(_DWORD *)(a1 + 108) - 1) <= 3 && *(_DWORD *)(a1 + 188) == 2)
  {
    unsigned __int8 v21 = *(NSObject **)(a1 + 80);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)
      || (uint64_t v22 = asString(),
          *(_DWORD *)long long buf = 136315138,
          *(void *)&uint8_t buf[4] = v22,
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N [    ] baseband-online was granted but now in mode %s; revoking!",
            buf,
            0xCu),
          *(_DWORD *)(a1 + 188)))
    {
      sub_100058DB0(__p, "/cc/assertions/baseband_online");
      *(_OWORD *)long long buf = *(_OWORD *)__p;
      uint64_t v34 = v32;
      __p[1] = 0;
      uint64_t v32 = 0;
      __p[0] = 0;
      ctu::path_join_impl();
      xpc_object_t objectg = xpc_int64_create(*(unsigned int *)(a1 + 184));
      if (!objectg) {
        xpc_object_t objectg = xpc_null_create();
      }
      ctu::RestModule::setProperty();
      xpc_release(objectg);
      if (SHIBYTE(v34) < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_10084E9D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10084EB44(unsigned int *a1)
{
  if (a1[1])
  {
    sub_100058DB0(v3, "/cc/assertions/baseband_camp_only_assertion");
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v6 = v4;
    v3[1] = 0;
    uint64_t v4 = 0;
    v3[0] = 0;
    ctu::path_join_impl();
    xpc_object_t object = xpc_int64_create(*a1);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    ctu::RestModule::setProperty();
    xpc_release(object);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v4) < 0) {
      operator delete(v3[0]);
    }
  }
}

void sub_10084EC0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void sub_10084EC54(unsigned int *a1)
{
  if (a1[1])
  {
    sub_100058DB0(v3, "/cc/assertions/airplane_mode");
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v6 = v4;
    v3[1] = 0;
    uint64_t v4 = 0;
    v3[0] = 0;
    ctu::path_join_impl();
    xpc_object_t object = xpc_int64_create(*a1);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    ctu::RestModule::setProperty();
    xpc_release(object);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v4) < 0) {
      operator delete(v3[0]);
    }
  }
}

void sub_10084ED1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void sub_10084ED64(void *a1)
{
  switch(*((_DWORD *)a1 + 26))
  {
    case 0:
    case 1:
      sub_10084EDC8(a1);
      break;
    case 2:
      sub_10084F204((uint64_t)a1);
      break;
    case 3:
      sub_10084F2F4((uint64_t)a1);
      break;
    case 4:
      sub_10084F36C((uint64_t)a1);
      break;
    case 5:
      sub_10084F3E4((uint64_t)a1);
      break;
    case 6:
      sub_10084F27C((uint64_t)a1);
      break;
    default:
      return;
  }
}

void sub_10084EDC8(void *a1)
{
  int v2 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (v2 == *((_DWORD *)a1 + 27))
  {
    uint64_t v3 = a1[10];
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [----] Operating Mode: %s; no further changes needed",
        (uint8_t *)&buf,
        0xCu);
    }
    sub_10084DB64((uint64_t)a1, 1u);
    (*(void (**)(void *))(*a1 + 40))(a1);
    return;
  }
  sub_10084DC68(a1, 0);
  if (isBasebandBootedInMode())
  {
    uint64_t v4 = a1[15];
    if (!v4)
    {
      uint64_t v6 = a1[10];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = asString();
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [.   ] Booted baseband assertion required for next mode %s; grabbing now!",
          (uint8_t *)&buf,
          0xCu);
      }
      sub_100058DB0(&buf, "/cc/assertions/baseband_booted");
      ctu::rest::AssertionHandle::create();
      if (v12 < 0) {
        operator delete((void *)buf);
      }
      uint64_t v7 = (std::__shared_weak_count *)a1[16];
      *(_OWORD *)(a1 + 15) = v10;
      if (v7) {
        sub_10004D2C8(v7);
      }
      *(void *)&long long buf = off_101A111A8;
      *((void *)&buf + 1) = a1;
      p_long long buf = &buf;
      ctu::rest::AssertionHandle::setHandler_impl();
      sub_100060644(&buf);
      goto LABEL_23;
    }
    if (*(_DWORD *)(v4 + 68) != 2)
    {
LABEL_23:
      uint64_t v8 = a1[10];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [..  ] Baseband not booted in correct state for %s; waiting",
          (uint8_t *)&buf,
          0xCu);
      }
      return;
    }
  }
  else
  {
    uint64_t v5 = (std::__shared_weak_count *)a1[16];
    a1[15] = 0;
    a1[16] = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  switch(v2)
  {
    case 1:
      sub_10084F36C((uint64_t)a1);
      break;
    case 2:
      sub_10084F204((uint64_t)a1);
      break;
    case 3:
      sub_10084F27C((uint64_t)a1);
      break;
    case 4:
      sub_10084F3E4((uint64_t)a1);
      break;
    case 5:
      sub_10084F2F4((uint64_t)a1);
      break;
    default:
      return;
  }
}

void sub_10084F1BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t sub_10084F204(uint64_t a1)
{
  if (sub_10084DB64(a1, 2u)) {
    (*(void (**)(void, void))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), 0);
  }
  sub_10084DC68((void *)a1, 2);

  return sub_10084EDC8(a1);
}

uint64_t sub_10084F27C(uint64_t a1)
{
  if (sub_10084DB64(a1, 6u)) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), 1);
  }
  sub_10084DC68((void *)a1, 3);

  return sub_10084EDC8(a1);
}

uint64_t sub_10084F2F4(uint64_t a1)
{
  if (sub_10084DB64(a1, 3u)) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), 2);
  }
  sub_10084DC68((void *)a1, 5);

  return sub_10084EDC8(a1);
}

uint64_t sub_10084F36C(uint64_t a1)
{
  if (sub_10084DB64(a1, 4u)) {
    (*(void (**)(void, void))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), 0);
  }
  sub_10084DC68((void *)a1, 1);

  return sub_10084EDC8(a1);
}

uint64_t sub_10084F3E4(uint64_t a1)
{
  if (sub_10084DB64(a1, 5u)) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), 3);
  }
  sub_10084DC68((void *)a1, 4);

  return sub_10084EDC8(a1);
}

void sub_10084F460(uint64_t *a1, uint64_t a2, long long *a3, uint64_t a4)
{
  uint64_t v7 = *a1;
  if ((*((char *)a3 + 23) & 0x80000000) == 0)
  {
    *(_OWORD *)uint64_t v13 = *a3;
    uint64_t v14 = *((void *)a3 + 2);
    *(void *)&long long v15 = v7;
    *((void *)&v15 + 1) = a2;
LABEL_4:
    long long __p = *a3;
    uint64_t v17 = *((void *)a3 + 2);
    goto LABEL_5;
  }
  sub_10004FC84(v13, *(void **)a3, *((void *)a3 + 1));
  int v8 = *((char *)a3 + 23);
  *(void *)&long long v15 = v7;
  *((void *)&v15 + 1) = a2;
  if ((v8 & 0x80000000) == 0) {
    goto LABEL_4;
  }
  sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
LABEL_5:
  sub_10084FBA4((uint64_t)v18, a4);
  unsigned __int8 v21 = 0;
  uint64_t v9 = (char *)operator new(0x50uLL);
  long long v10 = v9;
  *(void *)uint64_t v9 = off_101A10BF8;
  *(_OWORD *)(v9 + 8) = v15;
  uint64_t v11 = v17;
  *(_OWORD *)(v9 + 24) = __p;
  *((void *)v9 + 5) = v11;
  uint64_t v17 = 0;
  long long __p = 0uLL;
  if (!v19)
  {
    char v12 = v9 + 72;
    goto LABEL_9;
  }
  if (v19 != v18)
  {
    char v12 = &v19;
    *((void *)v9 + 9) = v19;
LABEL_9:
    *char v12 = 0;
    goto LABEL_11;
  }
  *((void *)v9 + 9) = v9 + 48;
  (*(void (**)(void *))(v18[0] + 24))(v18);
LABEL_11:
  unsigned __int8 v21 = v10;
  ctu::RestModule::getPropertyOnce();
  sub_10003F600(v20);
  sub_100851B80(v18);
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
}

void sub_10084F630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, void *a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10084F69C(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 80);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 104);
    if (v3 > 6) {
      uint64_t v4 = "?";
    }
    else {
      uint64_t v4 = off_101A115A8[v3];
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v26 = (uint64_t)v4;
    __int16 v27 = 2080;
    *(void *)int v28 = asString();
    *(_WORD *)&v28[8] = 2080;
    *(void *)&v28[10] = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I TransitionState=%s; stableMode=%s (last mode=%s)",
      buf,
      0x20u);
    int v2 = *(NSObject **)(a1 + 80);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 120);
    if (v5)
    {
      int v6 = *(_DWORD *)(v5 + 68);
      uint64_t v7 = "pending";
      if (!v6) {
        uint64_t v7 = "REVOKED";
      }
      if (v6 == 2) {
        int v8 = "held";
      }
      else {
        int v8 = v7;
      }
    }
    else
    {
      int v8 = "<none>";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v26 = (uint64_t)v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I   -- booted assertion acquired=%s", buf, 0xCu);
    int v2 = *(NSObject **)(a1 + 80);
  }
  BOOL v9 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    uint64_t v10 = ctu::rest::asString();
    int v11 = *(_DWORD *)(a1 + 200);
    uint64_t v12 = ctu::rest::asString();
    int v13 = *(_DWORD *)(a1 + 184);
    uint64_t v14 = ctu::rest::asString();
    int v15 = *(_DWORD *)(a1 + 192);
    uint64_t v16 = ctu::rest::asString();
    int v17 = *(_DWORD *)(a1 + 176);
    *(_DWORD *)long long buf = 136316930;
    uint64_t v26 = v10;
    __int16 v27 = 1024;
    *(_DWORD *)int v28 = v11;
    *(_WORD *)&v28[4] = 2080;
    *(void *)&v28[6] = v12;
    *(_WORD *)&v28[14] = 1024;
    *(_DWORD *)&v28[16] = v13;
    __int16 v29 = 2080;
    uint64_t v30 = v14;
    __int16 v31 = 1024;
    int v32 = v15;
    __int16 v33 = 2080;
    uint64_t v34 = v16;
    __int16 v35 = 1024;
    int v36 = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I   -- emergency assertion=%s (%d) online assertion=%s (%d); airplane assertion=%s (%d); camp-only assertion=%s (%d)",
      buf,
      0x42u);
  }
  if (capabilities::ct::supportsStewie((capabilities::ct *)v9))
  {
    uint64_t v18 = *(NSObject **)(a1 + 80);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = ctu::rest::asString();
      int v20 = *(_DWORD *)(a1 + 208);
      *(_DWORD *)long long buf = 136315394;
      uint64_t v26 = v19;
      __int16 v27 = 1024;
      *(_DWORD *)int v28 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I   -- stewie mode assertion=%s (%d)", buf, 0x12u);
      uint64_t v18 = *(NSObject **)(a1 + 80);
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 116)) {
        unsigned __int8 v21 = "blocked due to regulatory";
      }
      else {
        unsigned __int8 v21 = "unblocked";
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v26 = (uint64_t)v21;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I   -- [CellularTx]: %s", buf, 0xCu);
    }
  }
  uint64_t v22 = *(void *)(a1 + 88);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  v24[0] = off_101A11538;
  v24[1] = a1;
  v24[3] = v24;
  sub_10084DE40(a1, (uint64_t)v24);
  return sub_10001E914(v24);
}

void sub_10084FA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

RestServiceBase *sub_10084FA48(RestServiceBase *this)
{
  *(void *)this = off_101A10A98;
  int v2 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4) {
    sub_10004D2C8(v4);
  }
  RestServiceBase::~RestServiceBase(this);
  ctu::OsLogLogger::~OsLogLogger((RestServiceBase *)((char *)this + 80));
  sub_100087E88((void *)this + 6);
  return this;
}

void sub_10084FAC8(RestServiceBase *this)
{
  *(void *)this = off_101A10A98;
  int v2 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4) {
    sub_10004D2C8(v4);
  }
  RestServiceBase::~RestServiceBase(this);
  ctu::OsLogLogger::~OsLogLogger((RestServiceBase *)((char *)this + 80));
  sub_100087E88((void *)this + 6);

  operator delete();
}

uint64_t sub_10084FB68(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

uint64_t sub_10084FBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10084FC3C(uint64_t a1)
{
  *(void *)a1 = off_101A10BF8;
  sub_100851B80((void *)(a1 + 48));
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_10084FC90(uint64_t a1)
{
  *(void *)a1 = off_101A10BF8;
  sub_100851B80((void *)(a1 + 48));
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void *sub_10084FD04(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x50uLL);
  *int v2 = off_101A10BF8;
  sub_100850120((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10084FD58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10084FD6C(uint64_t a1, void *a2)
{
  *a2 = off_101A10BF8;
  return sub_100850120((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10084FD98(uint64_t a1)
{
}

void sub_10084FDA0(void *a1)
{
  sub_1008501B0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10084FDDC(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = a1[1];
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_null)
  {
    uint64_t v7 = *(NSObject **)(v4 + 80);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = (void *)a1[3];
      BOOL v9 = a1 + 3;
      int v8 = v10;
      if (*((char *)v9 + 23) >= 0) {
        int v8 = v9;
      }
      *(_DWORD *)xpc_object_t object = 136315138;
      *(void *)&object[4] = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not get %s", object, 0xCu);
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v6 = v3;
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
    }
    if (xpc_get_type(v6) != (xpc_type_t)&_xpc_type_array)
    {
      if (v5)
      {
        xpc_retain(v5);
        xpc_object_t v11 = v5;
      }
      else
      {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v6);
      xpc_object_t v6 = v11;
    }
    xpc_release(v5);
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
    {
      *(void *)xpc_object_t object = v6;
      if (v6) {
        xpc_retain(v6);
      }
      else {
        *(void *)xpc_object_t object = xpc_null_create();
      }
      uint64_t v17 = a1[9];
      if (!v17) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v17 + 48))(v17, object);
      xpc_release(*(xpc_object_t *)object);
      *(void *)xpc_object_t object = 0;
    }
    else
    {
      uint64_t v12 = *(NSObject **)(v4 + 80);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v15 = (void *)a1[3];
        uint64_t v14 = a1 + 3;
        int v13 = v15;
        if (*((char *)v14 + 23) >= 0) {
          int v13 = v14;
        }
        uint64_t v16 = *(v14 - 1);
        *(_DWORD *)xpc_object_t object = 136315394;
        *(void *)&object[4] = v13;
        __int16 v19 = 2080;
        uint64_t v20 = v16;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not get array of %s %s assertion holders", object, 0x16u);
      }
    }
    xpc_release(v6);
  }
  xpc_release(v3);
}

void sub_100850038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1008500D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100850114()
{
}

uint64_t sub_100850120(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v4;
  }
  sub_10084FBA4(a1 + 40, a2 + 40);
  return a1;
}

void sub_100850194(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008501B0(uint64_t a1)
{
  sub_100851B80((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0)
  {
    int v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

RestServiceBase *sub_100850200(RestServiceBase *a1)
{
  RestServiceBase::~RestServiceBase(a1);
  uint64_t v3 = (void *)(v2 + 48);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v2 + 80));
  sub_100087E88(v3);
  return a1;
}

void sub_10085023C(RestServiceBase *a1)
{
  RestServiceBase::~RestServiceBase(a1);
  uint64_t v2 = (void *)(v1 + 48);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 80));
  sub_100087E88(v2);

  operator delete();
}

void sub_10085029C()
{
}

__n128 sub_1008502B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A10CA8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100850304(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10CA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10085033C(void *a1, xpc_object_t *a2)
{
  long long v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    int *v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  BOOL v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  xpc_object_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    BOOL v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_10085042C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10085046C()
{
}

void sub_100850478(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/assertions/emergency_online");
  *(_OWORD *)a1 = *(_OWORD *)__p;
  *(void *)(a1 + 16) = v3;
  __p[1] = 0;
  uint64_t v3 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1008504E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100850518()
{
}

__n128 sub_10085052C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A10D28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100850578(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10D28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1008505A8(uint64_t a1)
{
  ctu::rest::read_rest_value();
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(NSObject **)(v2 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = ctu::rest::asString();
    int v5 = *(_DWORD *)(v2 + 200);
    int v6 = 136315394;
    uint64_t v7 = v4;
    __int16 v8 = 1024;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Emergency online assertion change: %s (%d)", (uint8_t *)&v6, 0x12u);
  }
  sub_10084ED64((void *)v2);
}

uint64_t sub_100850670(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008506B0()
{
}

void sub_1008506BC(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/assertions/baseband_camp_only_assertion");
  *(_OWORD *)a1 = *(_OWORD *)__p;
  *(void *)(a1 + 16) = v3;
  __p[1] = 0;
  uint64_t v3 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10085072C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10085075C()
{
}

__n128 sub_100850770(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A10DA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1008507BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10DA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1008507EC(uint64_t a1)
{
  ctu::rest::read_rest_value();
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(NSObject **)(v2 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = ctu::rest::asString();
    int v5 = *(_DWORD *)(v2 + 176);
    int v6 = 136315394;
    uint64_t v7 = v4;
    __int16 v8 = 1024;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband camp only assertion change: %s (%d)", (uint8_t *)&v6, 0x12u);
  }
  sub_10084ED64((void *)v2);
}

uint64_t sub_1008508B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1008508F4()
{
}

void sub_100850900(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/assertions/baseband_online");
  *(_OWORD *)a1 = *(_OWORD *)__p;
  *(void *)(a1 + 16) = v3;
  __p[1] = 0;
  uint64_t v3 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100850970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1008509A0()
{
}

__n128 sub_1008509B4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A10E28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100850A00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10E28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100850A30(uint64_t a1)
{
  ctu::rest::read_rest_value();
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(NSObject **)(v2 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = ctu::rest::asString();
    int v5 = *(_DWORD *)(v2 + 184);
    int v6 = 136315394;
    uint64_t v7 = v4;
    __int16 v8 = 1024;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Baseband online assertion change: %s (%d)", (uint8_t *)&v6, 0x12u);
  }
  sub_10084ED64((void *)v2);
}

uint64_t sub_100850AF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100850B38()
{
}

void sub_100850B44(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/assertions/airplane_mode");
  *(_OWORD *)a1 = *(_OWORD *)__p;
  *(void *)(a1 + 16) = v3;
  __p[1] = 0;
  uint64_t v3 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100850BB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100850BE4()
{
}

__n128 sub_100850BF8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A10EA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100850C44(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A10EA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100850C74(uint64_t a1)
{
  ctu::rest::read_rest_value();
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(NSObject **)(v2 + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = ctu::rest::asString();
    int v5 = *(_DWORD *)(v2 + 192);
    int v6 = 136315394;
    uint64_t v7 = v4;
    __int16 v8 = 1024;
    int v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Airplane mode assertion change: %s (%d)", (uint8_t *)&v6, 0x12u);
  }
  sub_10084ED64((void *)v2);
}

uint64_t sub_100850D3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100850D7C()
{
}

void sub_100850D88(uint64_t a1)
{
  sub_100058DB0(__p, "/cc/assertions/stewie_mode_assertion");
  *(_OWORD *)a1 = *(_OWORD *)__p;
  *(void *)(a1 + 16) = v3;
  __p[1] = 0;
  uint64_t v3 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}