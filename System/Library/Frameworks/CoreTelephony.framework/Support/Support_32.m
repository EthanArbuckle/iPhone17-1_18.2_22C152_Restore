void sub_10118D5C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  void *v19;

  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_10118D678(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118D6B8()
{
}

void sub_10118D6C8()
{
}

void *sub_10118D6DC(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A96D58;
  result[1] = v3;
  return result;
}

uint64_t sub_10118D724(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96D58;
  a2[1] = v2;
  return result;
}

void sub_10118D750(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100982DFC(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/ims_handover_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10118D7F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118D838(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118D878()
{
}

void sub_10118D888()
{
}

void *sub_10118D89C(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A96DD8;
  result[1] = v3;
  return result;
}

uint64_t sub_10118D8E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96DD8;
  a2[1] = v2;
  return result;
}

void sub_10118D910(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/cellular_data_setting");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_10118D9C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10118DA08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118DA48()
{
}

void sub_10118DA58()
{
}

void *sub_10118DA6C(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A96E58;
  result[1] = v3;
  return result;
}

uint64_t sub_10118DAB4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96E58;
  a2[1] = v2;
  return result;
}

void sub_10118DAE0(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/congestion_status");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10118DB84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10118DBC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118DC08()
{
}

void sub_10118DC18()
{
}

void *sub_10118DC2C(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A96ED8;
  result[1] = v3;
  return result;
}

uint64_t sub_10118DC74(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A96ED8;
  a2[1] = v2;
  return result;
}

void sub_10118DCA0(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/cellular_data_setting_internal");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_10118DD50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_10118DD98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118DDD8()
{
}

void sub_10118DDE8()
{
}

__n128 sub_10118DDFC(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x20uLL);
  *(void *)xpc_object_t v2 = off_101A96F58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10118DE50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A96F58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118DE88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118DEC8()
{
}

void sub_10118DED8()
{
}

__n128 sub_10118DEEC(uint64_t a1)
{
  xpc_object_t v2 = (char *)operator new(0x28uLL);
  *(void *)xpc_object_t v2 = off_101A96FD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118DF40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A96FD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118DF78(void *a1, xpc_object_t *a2)
{
  char v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    *char v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *char v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_10118E068(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118E0A8()
{
}

void sub_10118E0B8()
{
}

void *sub_10118E0CC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A97058;
  result[1] = v3;
  return result;
}

uint64_t sub_10118E114(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A97058;
  a2[1] = v2;
  return result;
}

void sub_10118E140(uint64_t a1)
{
  memset(v3, 0, sizeof(v3));
  read_rest_value();
  uint64_t v2 = *(void *)(a1 + 8);
  *(_OWORD *)__p = *(_OWORD *)&v3[1];
  uint64_t v5 = 0;
  sub_10116E15C(v2, 0, 0, (long long *)__p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10118E1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10118E228(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118E268()
{
}

void sub_10118E278()
{
}

__n128 sub_10118E28C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A970D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118E2E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A970D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118E318(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *char v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10118E3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10118E3F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118E430()
{
}

void sub_10118E440()
{
}

__n128 sub_10118E454(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97158;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118E4A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118E4E0(uint64_t *a1, xpc_object_t *a2)
{
  sub_10025697C(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10118E55C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118E59C()
{
}

void sub_10118E5AC()
{
}

__n128 sub_10118E5C0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A971D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118E614(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A971D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118E64C(uint64_t *a1, xpc_object_t *a2)
{
  sub_10003447C(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10118E6C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118E708()
{
}

void sub_10118E718()
{
}

__n128 sub_10118E72C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97258;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118E780(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118E7B8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10118E878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10118E890(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118E8D0()
{
}

void sub_10118E8E0()
{
}

__n128 sub_10118E8F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A972D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118E948(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A972D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118E980(uint64_t *a1, xpc_object_t *a2)
{
  sub_1005BF770(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10118E9FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118EA3C()
{
}

void sub_10118EA4C()
{
}

__n128 sub_10118EA60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97358;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118EAB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118EAEC(uint64_t *a1, xpc_object_t *a2)
{
  sub_10057CDB0(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10118EB68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118EBA8()
{
}

void sub_10118EBB8()
{
}

__n128 sub_10118EBCC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A973D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118EC20(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A973D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118EC58(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v9 = &v10;
  }
  sub_100A5892C((uint64_t)v3, a2, "PersonalityID", "State");
  v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1007035FC((uint64_t)&v9, v10);
}

void sub_10118ED28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10118ED40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118ED80()
{
}

void sub_10118ED90()
{
}

__n128 sub_10118EDA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97458;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118EDF8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118EE30(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v9 = &v10;
  }
  sub_100169118((uint64_t)v3, a2);
  v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_10118EEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10118EF08(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118EF48()
{
}

void sub_10118EF58()
{
}

__n128 sub_10118EF6C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A974D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118EFC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A974D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118EFF8(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10118F094(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118F0D4()
{
}

void sub_10118F0E4()
{
}

__n128 sub_10118F0F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97558;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118F14C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118F184(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10118F220(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118F260()
{
}

void sub_10118F270()
{
}

__n128 sub_10118F284(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A975D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118F2D8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A975D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118F310(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v9 = &v10;
  }
  sub_10031571C((uint64_t)v3, a2);
  v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_10118F3D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10118F3E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118F428()
{
}

void sub_10118F438()
{
}

__n128 sub_10118F44C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A97658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10118F4A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118F4D8(void *a1)
{
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, 0);
}

uint64_t sub_10118F558(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118F598()
{
}

void sub_10118F5A8()
{
}

__n128 sub_10118F5BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A976D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118F610(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A976D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118F648(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    v9 = &v10;
  }
  sub_100F77EBC((uint64_t)v3, a2);
  v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10118F708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10118F720(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118F760()
{
}

void sub_10118F770()
{
}

__n128 sub_10118F784(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97758;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118F7D8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97758;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118F810(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_10118F898(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118F8D8()
{
}

void sub_10118F8E8()
{
}

__n128 sub_10118F8FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A977D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10118F950(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A977D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118F988(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  sub_100089CF0(v3, a2);
  uint64_t v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  v9 = (void **)&v7;
  sub_10008A88C(&v9);
}

void sub_10118FA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_10118FA48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118FA88()
{
}

void sub_10118FA98()
{
}

__n128 sub_10118FAAC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A97858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10118FB00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97858;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118FB38(void *a1)
{
  uint64_t v5 = 255;
  *(_OWORD *)uint64_t v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)__p_8 = 0u;
  uint64_t v9 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (SHIBYTE(__p_8[1]) < 0) {
    operator delete(*((void **)&v7 + 1));
  }
  if (SBYTE7(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_10118FBF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10118FC24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118FC64()
{
}

void sub_10118FC74()
{
}

__n128 sub_10118FC88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A978D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10118FCDC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A978D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10118FD14(void *a1)
{
  uint64_t v5 = 255;
  *(_OWORD *)uint64_t v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)__p_8 = 0u;
  uint64_t v9 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, uint64_t *))(*v4 + v2);
  }
  v2(v4, &v5);
  if (SHIBYTE(__p_8[1]) < 0) {
    operator delete(*((void **)&v7 + 1));
  }
  if (SBYTE7(v7) < 0) {
    operator delete(v6[0]);
  }
}

void sub_10118FDD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10118FE00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118FE40()
{
}

void sub_10118FE50()
{
}

__n128 sub_10118FE64(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A97958;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10118FEB8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97958;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10118FEF0(void *a1)
{
  long long v6 = xmmword_1015111A0;
  int v7 = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, long long *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, long long *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_10118FF7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10118FFBC()
{
}

void sub_10118FFCC()
{
}

__n128 sub_10118FFE0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A979D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101190034(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A979D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10119006C(void *a1)
{
  *(_OWORD *)__p = 0u;
  long long v6 = 0u;
  read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_101190100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10119011C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10119015C()
{
}

void sub_10119016C()
{
}

__n128 sub_101190180(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A97A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1011901D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97A58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10119020C(void *a1)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  *(_OWORD *)__p = 0u;
  long long v6 = 0u;
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)v7 + 12));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[2] + 4));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[3] + 12));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[5] + 4));
  CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)((char *)&v7[6] + 12));
  read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[1]);
  }
}

void sub_1011902F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101190318(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101190358()
{
}

void sub_101190368()
{
}

__n128 sub_10119037C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97AD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011903D0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97AD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101190408(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1011904C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1011904E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101190520()
{
}

void sub_101190530()
{
}

__n128 sub_101190544(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97B58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101190598(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97B58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011905D0(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10119066C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011906AC()
{
}

void sub_1011906BC()
{
}

__n128 sub_1011906D0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97BD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101190724(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97BD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10119075C(uint64_t *a1, xpc_object_t *a2)
{
  sub_10072E934(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1011907D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101190818()
{
}

void sub_101190828()
{
}

__n128 sub_10119083C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A97C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101190890(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011908C8(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_1011909AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011909EC()
{
}

void sub_1011909FC()
{
}

__n128 sub_101190A10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97CD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101190A64(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97CD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101190A9C(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_101190B38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101190B78()
{
}

void sub_101190B88()
{
}

__n128 sub_101190B9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97D58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101190BF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97D58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101190C28(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_101190CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101190D00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101190D40()
{
}

void sub_101190D50()
{
}

__n128 sub_101190D64(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97DD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101190DB8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97DD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101190DF0(uint64_t *a1, xpc_object_t *a2)
{
  sub_100256368(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  int v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_101190E6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101190EAC()
{
}

void sub_101190EBC()
{
}

__n128 sub_101190ED0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97E58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101190F24(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97E58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101190F5C(void *a1, xpc *this, int a3)
{
  uint64_t v4 = (_DWORD *)a1[1];
  uint64_t v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v6 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(uint64_t (**)(void *, uint64_t))(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_101190FF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101191034()
{
}

void sub_101191044()
{
}

__n128 sub_101191058(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97ED8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011910AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97ED8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011910E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101191124()
{
}

void sub_101191134()
{
}

__n128 sub_101191148(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97F58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10119119C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97F58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011911D4(void *a1, const xpc::object *a2)
{
  uint64_t v4 = (const RegisteredNetworkInfo *)a1[1];
  bzero(v9, 0x320uLL);
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)v9, v4);
  read_rest_value(v4, a2);
  uint64_t v5 = (void (*)(void *, unsigned char *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, unsigned char *))(*v7 + v5);
  }
  v5(v7, v9);
  if (v18 && v17 < 0) {
    operator delete(__p);
  }
  sub_10002B2D8((uint64_t)&v15);
  sub_10002B28C((uint64_t)&v14);
  sub_10002B1F4((uint64_t)&v13);
  sub_10002B1A8((uint64_t)&v12);
  sub_10002B1A8((uint64_t)&v11);
  return sub_10002B240((uint64_t)&v10);
}

void sub_1011912F4(_Unwind_Exception *a1)
{
}

uint64_t sub_101191354(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101191394()
{
}

void sub_1011913A4()
{
}

__n128 sub_1011913B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A97FD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10119140C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A97FD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101191444(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031B0B4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_101191504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10119151C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10119155C()
{
}

void sub_10119156C()
{
}

__n128 sub_101191580(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A98058;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011915D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98058;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10119160C(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_1011916A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011916E8()
{
}

void sub_1011916F8()
{
}

__n128 sub_10119170C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A980D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101191760(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A980D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101191798(void *a1, xpc_object_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = a1[1];
  int v5 = (uint64_t **)(v3 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  v26 = *(uint64_t **)v3;
  v27 = v4;
  if (*(void *)(v3 + 16))
  {
    v4[2] = &v27;
    *(void *)uint64_t v3 = v5;
    *int v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    v26 = (uint64_t *)&v27;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_1000346F8(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v31, &object, 0);
    xpc_release(object);
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    v25 = v2;
    sub_100048BF4(v30, &object, count);
    xpc_release(object);
    for (i = v32; ; i = ++v32)
    {
      if (i == v30[1] && v31 == v30[0])
      {
        xpc_release(v31);
        xpc_release(v31);
        uint64_t v2 = v25;
        goto LABEL_57;
      }
      xpc_object_t v29 = 0;
      xpc_object_t object = &v31;
      v34 = i;
      sub_10003FBDC((uint64_t)&object, &v29);
      if (xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_55:
      xpc_release(v29);
    }
    xpc_object_t v9 = v29;
    if (v29)
    {
      xpc_retain(v29);
      xpc_object_t v36 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v36 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v36;
      goto LABEL_30;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v36 = v10;
LABEL_30:
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t object = &v36;
      v34 = "first";
      sub_100048BAC((uint64_t)&object, &v35);
      xpc_type_t type = xpc_get_type(v35);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v37 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v37, (int *)&v35, v14);
        int v12 = v37;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        int v12 = xpc::dyn_cast_or_default((xpc *)&v35, 0, (uint64_t)v14);
      }
      else
      {
        int v12 = 0;
      }
      xpc_release(v35);
      xpc_object_t object = &v36;
      v34 = "second";
      sub_100048BAC((uint64_t)&object, &v35);
      xpc_type_t v15 = xpc_get_type(v35);
      if (v15 == (xpc_type_t)&_xpc_type_string)
      {
        LOBYTE(v37) = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v37, (unsigned __int8 *)&v35, v16);
        char v11 = v37;
      }
      else if (v15 == (xpc_type_t)&_xpc_type_BOOL {
             || v15 == (xpc_type_t)&_xpc_type_int64
      }
             || v15 == (xpc_type_t)&_xpc_type_uint64)
      {
        char v11 = xpc::dyn_cast_or_default((xpc *)&v35, 0, (uint64_t)v16);
      }
      else
      {
        char v11 = 0;
      }
      xpc_release(v35);
    }
    else
    {
      char v11 = 0;
      int v12 = 0;
    }
    xpc_release(v36);
    xpc_release(v9);
    char v17 = *v5;
    char v18 = (uint64_t **)(v3 + 8);
    v19 = (uint64_t **)(v3 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          v19 = (uint64_t **)v17;
          int v20 = *((_DWORD *)v17 + 7);
          if (v20 <= v12) {
            break;
          }
          char v17 = *v19;
          char v18 = v19;
          if (!*v19) {
            goto LABEL_54;
          }
        }
        if (v20 >= v12) {
          break;
        }
        char v17 = v19[1];
        if (!v17)
        {
          char v18 = v19 + 1;
          goto LABEL_54;
        }
      }
    }
    else
    {
LABEL_54:
      v21 = operator new(0x28uLL);
      v21[7] = v12;
      *((unsigned char *)v21 + 32) = v11;
      sub_100046C38((uint64_t **)v3, (uint64_t)v19, v18, (uint64_t *)v21);
    }
    goto LABEL_55;
  }
LABEL_57:
  xpc_release(v6);
  v22 = (void (*)(void *, uint64_t **))v2[3];
  uint64_t v23 = v2[4];
  v24 = (void *)(v2[2] + (v23 >> 1));
  if (v23) {
    v22 = *(void (**)(void *, uint64_t **))(*v24 + v22);
  }
  v22(v24, &v26);
  sub_1000346F8((uint64_t)&v26, v27);
}

void sub_101191C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20,xpc_object_t a21)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a16);
  xpc_release(v21);
  sub_1000346F8((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_101191D00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101191D40()
{
}

void sub_101191D50()
{
}

__n128 sub_101191D64(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A98158;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101191DB8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101191DF0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_101191EB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101191EC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101191F08()
{
}

void sub_101191F18()
{
}

__n128 sub_101191F2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A981D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101191F80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A981D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101191FB8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  xpc_object_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_101192008(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101192048()
{
}

void sub_101192058()
{
}

__n128 sub_10119206C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A98258;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011920C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011920F8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1000DF110((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1011921B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1011921D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101192210()
{
}

void sub_101192220()
{
}

__n128 sub_101192234(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A982D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101192288(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A982D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011922C0(void *a1, const xpc::object *a2)
{
  uint64_t v3 = (EmergencyMode *)a1[1];
  long long v4 = *(_OWORD *)v3;
  int v9 = *((_DWORD *)v3 + 4);
  long long v8 = v4;
  read_rest_value(v3, a2);
  uint64_t v5 = (void (*)(void *, long long *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, long long *))(*v7 + v5);
  }
  v5(v7, &v8);
  EmergencyMode::~EmergencyMode((EmergencyMode *)&v8);
}

void sub_101192354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_101192368(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011923A8()
{
}

void sub_1011923B8()
{
}

__n128 sub_1011923CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A98358;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101192420(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101192458(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101192498()
{
}

void sub_1011924A8()
{
}

__n128 sub_1011924BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A983D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101192510(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A983D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101192548(void *a1)
{
  v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101192590(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011925D0()
{
}

void sub_1011925E0()
{
}

__n128 sub_1011925F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A98458;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101192648(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101192680(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  long long v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    *long long v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_100A59E10((uint64_t)v3, a2, "PersonalityID", (uint64_t)"State");
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100313534((uint64_t)&v9, v10);
}

void sub_101192750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_101192768(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011927A8()
{
}

void sub_1011927B8()
{
}

__n128 sub_1011927CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A984D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101192820(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A984D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101192858(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1011928D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101192914()
{
}

uint64_t sub_101192920(void *a1)
{
  v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

NSObject **sub_10119296C(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_1011929BC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    __n128 result = (uint64_t)sub_10119296C((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_101193218(v6);
  }
  __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEbEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEbEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_101192A94(uint64_t a1)
{
  v1 = *(const void **)(a1 + 8);
  if (v1 && (v2 = _Block_copy(v1)) != 0 && (uint64_t v3 = _Block_copy(v2), (v4 = v3) != 0))
  {
    uint64_t v5 = _Block_copy(v3);
    uint64_t v6 = v5;
    if (v5)
    {
      uint64_t v7 = _Block_copy(v5);
      long long v8 = v7;
      if (v7)
      {
        int v9 = _Block_copy(v7);
        xpc_object_t v10 = v9;
        if (v9)
        {
          char v11 = _Block_copy(v9);
          int v12 = v11;
          if (v11)
          {
            *(void *)&long long v14 = _Block_copy(v11);
            _Block_release(v12);
          }
          else
          {
            *(void *)&long long v14 = 0;
          }
          _Block_release(v10);
        }
        else
        {
          *(void *)&long long v14 = 0;
        }
        _Block_release(v8);
      }
      else
      {
        *(void *)&long long v14 = 0;
      }
      uint64_t v13 = off_101A985A8;
      _Block_release(v6);
    }
    else
    {
      uint64_t v13 = off_101A985A8;
      *(void *)&long long v14 = 0;
    }
    _Block_release(v4);
  }
  else
  {
    uint64_t v13 = off_101A985A8;
    *(void *)&long long v14 = 0;
  }
  operator new();
}

void sub_101192D04()
{
}

uint64_t sub_101192D54(uint64_t a1)
{
  sub_100A96174(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100FB0B08(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    operator delete();
  }
  return result;
}

void sub_101192DFC(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      long long v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEbEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN10subscriber7SimSlotEbEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      uint64_t v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      uint64_t v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_101192ED8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void *sub_101192EE8(void *a1)
{
  *a1 = off_101A985D8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101192F34(void *a1)
{
  *a1 = off_101A985D8;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_101192FA0(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_101193050(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101193068(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_101193088()
{
}

void *sub_1011930F4(void *a1)
{
  *a1 = off_101A98628;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_101193140(void *a1)
{
  *a1 = off_101A98628;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1011931AC()
{
}

uint64_t sub_101193218(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_101193258()
{
}

__n128 sub_10119326C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A98668;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1011932C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98668;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011932F8(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  char v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    int v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_1011933DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10119341C()
{
}

void sub_10119342C()
{
}

__n128 sub_101193440(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A986E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101193494(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A986E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011934CC(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  char v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    int v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_1011935B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011935F0()
{
}

void sub_101193600()
{
}

__n128 sub_101193614(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A98768;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101193668(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98768;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011936A0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1011936E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101193728()
{
}

void sub_101193738()
{
}

void *sub_10119374C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A987E8;
  result[1] = v3;
  return result;
}

uint64_t sub_101193794(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A987E8;
  a2[1] = v2;
  return result;
}

void sub_1011937C0(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      __p = &v26;
      int v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value();
      __p = &v26;
      int v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_type_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          xpc_type_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          uint64_t v6 = v16;
        }
        while (!v17);
      }
      uint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/bandwidth_infos");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_101193A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_101193B40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101193B80()
{
}

void sub_101193B90()
{
}

void *sub_101193BA4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A98878;
  result[1] = v3;
  return result;
}

uint64_t sub_101193BEC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A98878;
  a2[1] = v2;
  return result;
}

void sub_101193C18(uint64_t a1, void *a2)
{
  xpc_object_t v6 = 0;
  sub_101193D50(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/data_slicing_configured");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_101193CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_101193D04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101193D44()
{
}

void sub_101193D50(xpc_object_t *a1, void *a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v8 = (void *)*a2;
  xpc_object_t v6 = a2 + 1;
  uint64_t v7 = v8;
  if (v8 != v6)
  {
    do
    {
      xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v10 = v9;
      if (v9)
      {
        xpc_object_t v26 = v9;
      }
      else
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v26 = v10;
        if (!v10)
        {
          xpc_object_t v11 = xpc_null_create();
          xpc_object_t v10 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v11 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v11;
        goto LABEL_16;
      }
      xpc_retain(v10);
LABEL_16:
      xpc_release(v10);
      int v12 = *((_DWORD *)v7 + 7);
      uint64_t v13 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v12, v13, v14);
      xpc_object_t v22 = &v26;
      xpc_object_t v23 = "first";
      sub_100035E70((uint64_t)&v22, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      rest::write_rest_value((rest *)(v7 + 4), v15);
      xpc_object_t v22 = &v26;
      xpc_object_t v23 = "second";
      sub_100035E70((uint64_t)&v22, &v20, &v21);
      xpc_release(v21);
      xpc_object_t v21 = 0;
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_object_t v16 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v16 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v5, v16);
      xpc_release(v16);
      BOOL v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          xpc_object_t v18 = v17;
          BOOL v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          xpc_object_t v18 = (void *)v7[2];
          BOOL v19 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v19);
      }
      uint64_t v7 = v18;
    }
    while (v18 != v6);
  }
  *a1 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_101193FC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  xpc_release(v17);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

void *sub_101194024(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_10119428C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_10119429C()
{
}

void *sub_1011942B0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A98908;
  result[1] = v3;
  return result;
}

uint64_t sub_1011942F8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A98908;
  a2[1] = v2;
  return result;
}

void sub_101194324(uint64_t a1, void *a2)
{
  xpc_object_t v6 = 0;
  sub_101193D50(&v6, a2);
  sub_100058DB0(&__p, "/cc/props/data_slicing_support");
  xpc_object_t v2 = v6;
  xpc_object_t object = v6;
  if (v6) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_1011943C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t sub_101194410(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101194450()
{
}

void sub_101194460()
{
}

void *sub_101194474(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A98988;
  result[1] = v3;
  return result;
}

uint64_t sub_1011944BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A98988;
  a2[1] = v2;
  return result;
}

void sub_1011944E8(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/data_slicing_active");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10119458C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1011945D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101194610()
{
}

void sub_101194620()
{
}

void *sub_101194634(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A98A08;
  result[1] = v3;
  return result;
}

uint64_t sub_10119467C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A98A08;
  a2[1] = v2;
  return result;
}

void sub_1011946A8(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1011946B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011946F0()
{
}

void sub_101194700()
{
}

__n128 sub_101194714(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A98A88;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_101194768(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98A88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011947A0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (long long *)a1[1];
  long long v4 = *v3;
  uint64_t v11 = *((void *)v3 + 2);
  *(_OWORD *)xpc_object_t v10 = v4;
  *((void *)v3 + 1) = 0;
  *((void *)v3 + 2) = 0;
  *(void *)uint64_t v3 = 0;
  long long v5 = *(long long *)((char *)v3 + 24);
  uint64_t v13 = *((void *)v3 + 5);
  *(_OWORD *)__p = v5;
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 5) = 0;
  *((void *)v3 + 3) = 0;
  xpc_object_t object = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  xpc_object_t v6 = (void (*)(void *, void **))a1[3];
  uint64_t v7 = a1[4];
  xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void **))(*v8 + v6);
  }
  v6(v8, v10);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
}

void sub_10119489C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011948E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101194928()
{
}

uint64_t sub_101194934(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_101194980(int a1, int a2, uint64_t *a3, dispatch_object_t object, void **a5)
{
  sub_1001644F8(v6, a5, object);
  sub_100164540(v7, v6);
  sub_101194A3C((uint64_t)v7, *a3, a3[1]);
}

void sub_101194A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_101194A3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_101194BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100163BC8((uint64_t)va);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 8))(a3);
  }
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101194C18(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101194C64(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101194CB0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101194CFC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101194D48(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void sub_101194D94(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    long long v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_101194E0C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_101194E20(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_101194E6C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_101194EC0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_101194F24(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_101194F88(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      long long v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      long long v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        xpc_object_t v8 = v4;
        if (v7)
        {
          do
          {
            long long v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            long long v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            xpc_object_t v8 = v4;
          }
          while (!v6);
        }
        xpc_object_t v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            xpc_object_t v10 = v9;
            xpc_object_t v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            xpc_object_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            long long v5 = v10;
          }
          while (!v6);
        }
        long long v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_1011950BC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_101195120(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t *sub_101195184(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v9 = a1;
  uint64_t v10 = v1;
  unint64_t v2 = *(unsigned int *)(v1 + 8);
  if ((v2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(*(void *)v1 + 4136), v2 >= (*(void *)(*(void *)v1 + 4144) - v3) >> 4))
  {
    long long v5 = 0;
  }
  else
  {
    long long v4 = (uint64_t *)(v3 + 16 * v2);
    uint64_t v6 = *v4;
    long long v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      uint64_t v7 = *(void *)(v1 + 40);
      sub_1000DFC90((uint64_t)v11, v1 + 48);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v6 + 624))(v6, v1 + 16, v7, v11);
      sub_100060644(v11);
      goto LABEL_9;
    }
  }
  sub_1000607A8(v1 + 48, 0);
LABEL_9:
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1011952DC(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1011952A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  sub_100060644((uint64_t *)va2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1011952DC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011952DC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 48));
    unint64_t v2 = (void **)(v1 + 16);
    sub_100523284(&v2);
    operator delete();
  }
  return result;
}

uint64_t *sub_101195344(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v9 = a1;
  uint64_t v10 = v1;
  unint64_t v2 = *(unsigned int *)(v1 + 8);
  if ((v2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(*(void *)v1 + 4136), v2 >= (*(void *)(*(void *)v1 + 4144) - v3) >> 4))
  {
    long long v5 = 0;
  }
  else
  {
    uint64_t v4 = (uint64_t *)(v3 + 16 * v2);
    uint64_t v6 = *v4;
    long long v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      uint64_t v7 = *(void *)(v1 + 40);
      sub_1000DFC90((uint64_t)v11, v1 + 48);
      (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v6 + 632))(v6, v1 + 16, v7, v11);
      sub_100060644(v11);
      goto LABEL_9;
    }
  }
  sub_1000607A8(v1 + 48, 0);
LABEL_9:
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1011952DC(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_101195464(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  sub_100060644((uint64_t *)va2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1011952DC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_10119549C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  unint64_t v2 = *(unsigned int *)(v1 + 8);
  if ((v2 & 0x80000000) != 0
    || (uint64_t v3 = *(void *)(*(void *)v1 + 4136), v2 >= (*(void *)(*(void *)v1 + 4144) - v3) >> 4))
  {
    long long v5 = 0;
  }
  else
  {
    uint64_t v4 = (uint64_t *)(v3 + 16 * v2);
    uint64_t v6 = *v4;
    long long v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      uint64_t v7 = *(void *)(v1 + 16);
      sub_1008DC004((uint64_t)v13, v1 + 24);
      (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v6 + 640))(v6, v7, v13);
      sub_100523F74(v13);
      if (!v5) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  memset(v13, 0, 24);
  uint64_t v8 = *(void *)(v1 + 48);
  if (!v8) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v8 + 48))(v8, v13);
  int v12 = (void **)v13;
  sub_100523284(&v12);
  if (v5) {
LABEL_11:
  }
    sub_10004D2C8(v5);
LABEL_12:
  sub_101195650(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_101195600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  sub_100523F74(&a12);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_101195650(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101195650(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100523F74((void *)(v1 + 24));
    operator delete();
  }
  return result;
}

uint64_t sub_1011956A0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    int v3 = *(unsigned __int8 *)(a1 + 16);
    if (*(unsigned __int8 *)(v2 + 32) != v3)
    {
      *(unsigned char *)(v2 + 32) = v3;
      uint64_t v4 = *(void *)(v2 + 24);
      if (v4) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v2 + 32);
      }
    }
  }
  return a1;
}

uint64_t sub_101195718(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_101195728(uint64_t *a1)
{
  uint64_t v6 = a1;
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v2 = *(std::__shared_weak_count **)(*a1 + 16);
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (v1[1]) {
        *(unsigned char *)(v3 + 313) = *((unsigned char *)v1 + 24);
      }
      sub_10004D2C8(v4);
    }
    long long v5 = (std::__shared_weak_count *)v1[2];
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  operator delete();
}

uint64_t *sub_1011957A8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(unsigned __int8 *)(*(void *)v1 + 313) != *(unsigned __int8 *)(v1 + 8))
  {
    if (*(unsigned char *)(v1 + 8)) {
      uint64_t v3 = (CFPropertyListRef *)&kCFBooleanTrue;
    }
    else {
      uint64_t v3 = (CFPropertyListRef *)&kCFBooleanFalse;
    }
    CFPreferencesSetValue(@"DisallowCellularDataConnections", *v3, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    uint64_t v4 = (void *)(v1 + 16);
    if (*(char *)(v1 + 39) < 0)
    {
      uint64_t v6 = *(const UInt8 **)(v1 + 16);
      CFIndex v5 = *(void *)(v1 + 24);
    }
    else
    {
      CFIndex v5 = *(unsigned __int8 *)(v1 + 39);
      uint64_t v6 = (const UInt8 *)(v1 + 16);
    }
    CFStringRef v7 = CFStringCreateWithBytesNoCopy(0, v6, v5, 0x8000100u, 0, kCFAllocatorNull);
    __p[0] = (void *)v7;
    if (v7) {
      uint64_t v8 = sub_1000810B8;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8)
    {
      CFPreferencesSetValue(@"DisallowCellularDataConnectionsByWhom", v7, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    }
    else
    {
      xpc_object_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v22[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Writing data blocked: cannot create byWhomStr", (uint8_t *)v22, 2u);
      }
    }
    sub_1000558F4((const void **)__p);
    memset(__p, 0, sizeof(__p));
    __t.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v22[0] = std::chrono::system_clock::to_time_t(&__t);
    uint64_t v10 = operator new(0x20uLL);
    __p[0] = v10;
    *(_OWORD *)&__p[1] = xmmword_1015C55A0;
    v10[1] = 0;
    v10[2] = 0;
    *uint64_t v10 = 0;
    *(void *)((char *)v10 + 23) = 0;
    uint64_t v11 = localtime(v22);
    strftime((char *)v10, 0x1EuLL, "%Y-%m-%d %H:%M:%S", v11);
    if (SHIBYTE(__p[2]) >= 0) {
      int v12 = __p;
    }
    else {
      int v12 = (void **)__p[0];
    }
    if (SHIBYTE(__p[2]) >= 0) {
      CFIndex v13 = HIBYTE(__p[2]);
    }
    else {
      CFIndex v13 = (CFIndex)__p[1];
    }
    CFStringRef v14 = CFStringCreateWithBytesNoCopy(0, (const UInt8 *)v12, v13, 0x8000100u, 0, kCFAllocatorNull);
    v22[0] = (time_t)v14;
    if (v14) {
      xpc_type_t v15 = sub_1000810B8;
    }
    else {
      xpc_type_t v15 = 0;
    }
    if (v15)
    {
      CFPreferencesSetValue(@"DisallowCellularDataConnectionsTime", v14, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    }
    else
    {
      uint64_t v16 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__t.__d_.__rep_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Writing data blocked: cannot create timeStr", (uint8_t *)&__t, 2u);
      }
    }
    sub_1000558F4((const void **)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    sub_1003F2A04();
    BOOL v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v18 = "YES";
      if (!*(unsigned char *)(v1 + 8)) {
        xpc_object_t v18 = "NO";
      }
      if (*(char *)(v1 + 39) < 0) {
        uint64_t v4 = (void *)*v4;
      }
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = "operator()";
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = (void *)v18;
      HIWORD(__p[2]) = 2082;
      xpc_object_t v26 = v4;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: Writing data blocked to [%s] by %{public}s in the CommCenter pref file", (uint8_t *)__p, 0x20u);
    }
    *(unsigned char *)(v2 + 313) = *(unsigned char *)(v1 + 8);
  }
  sub_100058DB0(v22, "Data Block change");
  LODWORD(__p[0]) = 3;
  BYTE4(__p[0]) = 0;
  if (SHIBYTE(v23) < 0)
  {
    sub_10004FC84(&__p[1], (void *)v22[0], v22[1]);
  }
  else
  {
    *(_OWORD *)&__p[1] = *(_OWORD *)v22;
    xpc_object_t v26 = v23;
  }
  sub_10011AE40();
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete((void *)v22[0]);
  }
  sub_10033CAD4(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_101195B9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,void *a21,int a22,__int16 a23,char a24,char a25,int a26,__int16 a27,char a28,char a29)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_10033CAD4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_101195C28(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_101195C8C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t **sub_101195CF0(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  CFIndex v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        CFStringRef v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        CFIndex v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= a2) {
        return v7;
      }
      CFIndex v5 = v7[1];
    }
    while (v5);
    uint64_t v6 = v7 + 1;
  }
  else
  {
    CFStringRef v7 = a1 + 1;
  }
LABEL_10:
  xpc_object_t v9 = (uint64_t *)operator new(0x140uLL);
  *((_DWORD *)v9 + 7) = *a3;
  ConnectionAvailabilityContainer::ConnectionAvailabilityContainer((ConnectionAvailabilityContainer *)(v9 + 4));
  sub_100046C38(a1, (uint64_t)v7, v6, v9);
  return (uint64_t **)v9;
}

void sub_101195DA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_101195DBC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_101195DF4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    operator delete();
  }
  return result;
}

uint64_t sub_101195E14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101195E58(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t *sub_101195EBC(void *a1)
{
  uint64_t v1 = *a1;
  v30 = a1;
  uint64_t v31 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 16);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFIndex v5 = v4;
      if (*(void *)v1)
      {
        uint64_t v6 = sub_100AEFE40(*(void *)(v3 + 144), *(_DWORD *)(v1 + 48));
        CFStringRef v7 = *(void **)(v6 + 104);
        int v8 = *(void **)(v6 + 112);
        if (v7 == v8)
        {
LABEL_10:
          uint64_t v11 = (void *)sub_100AEFE40(*(void *)(v3 + 144), *(_DWORD *)(v1 + 48));
          unint64_t v12 = v11[15];
          CFIndex v13 = (void *)v11[14];
          if ((unint64_t)v13 >= v12)
          {
            uint64_t v15 = v11[13];
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v13 - v15) >> 3);
            if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_10006A748();
            }
            unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v15) >> 3);
            uint64_t v18 = 2 * v17;
            if (2 * v17 <= v16 + 1) {
              uint64_t v18 = v16 + 1;
            }
            if (v17 >= 0x555555555555555) {
              unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v19 = v18;
            }
            xpc_object_t v35 = v11 + 15;
            if (v19) {
              xpc_object_t v20 = (char *)sub_10004812C((uint64_t)(v11 + 15), v19);
            }
            else {
              xpc_object_t v20 = 0;
            }
            uint64_t v21 = &v20[24 * v16];
            v32 = v20;
            v33.i64[0] = (uint64_t)v21;
            v33.i64[1] = (uint64_t)v21;
            v34 = &v20[24 * v19];
            *(void *)uint64_t v21 = 0;
            *((void *)v21 + 1) = 0;
            *((void *)v21 + 2) = 0;
            sub_1006121D4(v21, *(const void **)(v1 + 24), *(void *)(v1 + 32), (uint64_t)(*(void *)(v1 + 32) - *(void *)(v1 + 24)) >> 3);
            uint64_t v22 = v33.i64[0];
            uint64_t v14 = v33.i64[1] + 24;
            v33.i64[1] += 24;
            xpc_object_t v24 = (void *)v11[13];
            xpc_object_t v23 = (void *)v11[14];
            if (v23 == v24)
            {
              int64x2_t v26 = vdupq_n_s64((unint64_t)v23);
            }
            else
            {
              do
              {
                *(void *)(v22 - 24) = 0;
                *(void *)(v22 - 16) = 0;
                v22 -= 24;
                *(void *)(v22 + 16) = 0;
                long long v25 = *(_OWORD *)(v23 - 3);
                v23 -= 3;
                *(_OWORD *)uint64_t v22 = v25;
                *(void *)(v22 + 16) = v23[2];
                *xpc_object_t v23 = 0;
                v23[1] = 0;
                v23[2] = 0;
              }
              while (v23 != v24);
              int64x2_t v26 = *(int64x2_t *)(v11 + 13);
              uint64_t v14 = v33.i64[1];
            }
            v11[13] = v22;
            v11[14] = v14;
            int64x2_t v33 = v26;
            v27 = (char *)v11[15];
            v11[15] = v34;
            v34 = v27;
            v32 = (char *)v26.i64[0];
            sub_101196268((uint64_t)&v32);
          }
          else
          {
            *CFIndex v13 = 0;
            v13[1] = 0;
            v13[2] = 0;
            sub_1006121D4(v13, *(const void **)(v1 + 24), *(void *)(v1 + 32), (uint64_t)(*(void *)(v1 + 32) - *(void *)(v1 + 24)) >> 3);
            uint64_t v14 = (uint64_t)(v13 + 3);
            v11[14] = v14;
          }
          v11[14] = v14;
          uint64_t v28 = *(void *)(v1 + 8);
          if (v28) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 16), 1uLL, memory_order_relaxed);
          }
          v32 = 0;
          v33.i64[0] = 0;
          sub_10003E168(&v32, (void *)(v3 + 8));
          operator new();
        }
        xpc_object_t v9 = *(void **)(v1 + 24);
        while (1)
        {
          uint64_t v10 = (void *)*v7;
          if (*(void *)*v7 == *v9 && v10[4] == v9[4] && v10[5] == v9[5]) {
            break;
          }
          v7 += 3;
          if (v7 == v8) {
            goto LABEL_10;
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_101196204(&v31);
  return sub_100046B58((uint64_t *)&v30);
}

void sub_1011961B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  sub_101196268((uint64_t)va2);
  sub_10004D2C8(v2);
  sub_101196204((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_101196204(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = (void *)v1[3];
    if (v2)
    {
      v1[4] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[1];
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_101196268(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_1011962CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v32 = a1;
  uint64_t v33 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 16);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)v1)
      {
        v30 = v4;
        uint64_t v5 = sub_100AEFE40(*(void *)(v3 + 144), *(_DWORD *)(v1 + 24));
        uint64_t v6 = *(int ***)(v5 + 104);
        for (i = *(int ***)(v5 + 112); v6 != i; v6 += 3)
        {
          int v7 = *(_DWORD *)(v1 + 24);
          if (v7 == (*(unsigned int (**)(uint64_t))(*(void *)v3 + 1088))(v3))
          {
            __p = 0;
            v38 = 0;
            v39 = 0;
            uint64_t v8 = *v6;
            uint64_t v9 = v6[1];
            if (*v6 != v9)
            {
              uint64_t v10 = 0;
              do
              {
                int v11 = *v8;
                if (v10 >= v39)
                {
                  CFIndex v13 = (char *)__p;
                  uint64_t v14 = (v10 - (unsigned char *)__p) >> 2;
                  unint64_t v15 = v14 + 1;
                  if ((unint64_t)(v14 + 1) >> 62) {
                    sub_10006A748();
                  }
                  uint64_t v16 = v39 - (unsigned char *)__p;
                  if ((v39 - (unsigned char *)__p) >> 1 > v15) {
                    unint64_t v15 = v16 >> 1;
                  }
                  if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
                    unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v17 = v15;
                  }
                  if (v17)
                  {
                    uint64_t v18 = (char *)sub_10005ECD8((uint64_t)&v39, v17);
                    CFIndex v13 = (char *)__p;
                    uint64_t v10 = v38;
                  }
                  else
                  {
                    uint64_t v18 = 0;
                  }
                  unint64_t v19 = &v18[4 * v14];
                  *(_DWORD *)unint64_t v19 = v11;
                  unint64_t v12 = v19 + 4;
                  while (v10 != v13)
                  {
                    int v20 = *((_DWORD *)v10 - 1);
                    v10 -= 4;
                    *((_DWORD *)v19 - 1) = v20;
                    v19 -= 4;
                  }
                  __p = v19;
                  v38 = v12;
                  v39 = &v18[4 * v17];
                  if (v13) {
                    operator delete(v13);
                  }
                }
                else
                {
                  *(_DWORD *)uint64_t v10 = v11;
                  unint64_t v12 = v10 + 4;
                }
                v38 = v12;
                v8 += 2;
                uint64_t v10 = v12;
              }
              while (v8 != v9);
            }
            sub_100CC95AC((uint64_t)&v34, 202, (uint64_t)&__p);
            uint64_t v21 = (uint64_t *)sub_100A013DC(&qword_101B13E28);
            sub_100A01420(v21, (uint64_t)&v34);
            if (v35)
            {
              xpc_object_t v36 = v35;
              operator delete(v35);
            }
            if (__p)
            {
              v38 = (char *)__p;
              operator delete(__p);
            }
          }
          LODWORD(__p) = *(_DWORD *)(v1 + 24);
          uint64_t v22 = (char *)*((void *)*v6 + 4);
          HIDWORD(__p) = *((void *)*v6 + 3);
          v38 = v22;
          xpc_object_t v41 = 0;
          write_rest_value();
          sub_100058DB0(&v34, "/cc/events/connection_activate_error");
          xpc_object_t object = v41;
          xpc_object_t v41 = xpc_null_create();
          ctu::RestModule::sendEvent();
          xpc_release(object);
          xpc_object_t object = 0;
          if (SHIBYTE(v36) < 0) {
            operator delete(v34);
          }
          xpc_release(v41);
          unsigned int v23 = *(_DWORD *)(v1 + 24);
          if (capabilities::ct::supportsCellRadio(v24)) {
            uint64_t v25 = v23;
          }
          else {
            uint64_t v25 = 0;
          }
          uint64_t v26 = ConnectionMaskToType(*((void *)*v6 + 4));
          uint64_t v27 = (*v6)[6];
          (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v3 + 4240) + 32))(*(void *)(v3 + 4240), v25, v26, v27);
          if (v25 == (*(unsigned int (**)(uint64_t))(*(void *)v3 + 1088))(v3) && !v26) {
            (*(void (**)(void, uint64_t))(**(void **)(v3 + 4240) + 40))(*(void *)(v3 + 4240), v27);
          }
        }
        uint64_t v28 = sub_100AEFE40(*(void *)(v3 + 144), *(_DWORD *)(v1 + 24));
        sub_10011FFE8((uint64_t *)(v28 + 104));
        uint64_t v4 = v30;
      }
      sub_10004D2C8(v4);
    }
  }
  sub_100DA2438(&v33);
  return sub_100046B58((uint64_t *)&v32);
}

void sub_10119663C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,xpc_object_t object)
{
}

uint64_t sub_1011966F8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_27;
      }
      uint64_t v4 = *(void **)(a1 + 16);
      while (1)
      {
        BOOL v5 = *((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8);
        if (!v5) {
          break;
        }
        uint64_t v6 = (void *)v3[1];
        int v7 = v3;
        if (v6)
        {
          do
          {
            uint64_t v3 = v6;
            uint64_t v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v7[2];
            BOOL v5 = *v3 == (void)v7;
            int v7 = v3;
          }
          while (!v5);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v5 = *v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v5);
        }
        uint64_t v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_27;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_1000346F8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    int v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_27:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t *sub_10119685C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  if (!*(unsigned char *)(*(void *)v1 + 288))
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v1 + 31) >= 0) {
        uint64_t v5 = v1 + 8;
      }
      else {
        uint64_t v5 = *(void *)(v1 + 8);
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v14 = "setLocalRoutableAddress_sync";
      __int16 v15 = 2080;
      uint64_t v16 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Local routable WAN IP address %s", buf, 0x16u);
    }
    if (*(unsigned char *)(v2 + 312))
    {
      uint64_t v6 = *(void *)(v2 + 144);
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t v8 = *(void *)(v6 + 16);
      while (v7 != v8)
      {
        uint64_t v9 = *(void *)(v7 + 40);
        if (v9) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 552))(v9, v1 + 8);
        }
        v7 += 432;
      }
    }
    else
    {
      uint64_t v10 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v14 = "setLocalRoutableAddress_sync";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E %s: !!! too early start", buf, 0xCu);
      }
    }
  }
  sub_1001102C4(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_1011969F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_101196A10(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(uint64_t **)(v1 + 4136);
  for (i = *(uint64_t **)(v1 + 4144); v2 != i; v2 += 2)
  {
    uint64_t v4 = *v2;
    uint64_t v5 = (std::__shared_weak_count *)v2[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 456))(v4);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_101196AD8()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void sub_101196B10(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (!*(unsigned char *)(v2 + 288))
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    DataServiceController::getConnection_sync(v2, *((_DWORD *)v1 + 2), 17, &v3);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 360))(v3);
    }
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  operator delete();
}

void sub_101196BBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

void sub_101196BFC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A98CA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_101196C1C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A98CA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_101196C70(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_1011974F0(&v1);
}

uint64_t sub_101196CA0(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  unint64_t v6 = a1[1];
  if (v6 >= v5)
  {
    uint64_t v9 = (uint64_t)(v6 - *a1) >> 5;
    if ((unint64_t)(v9 + 1) >> 59) {
      sub_10006A748();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 4;
    if (v10 >> 4 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    unsigned int v23 = v4;
    if (v12)
    {
      if (v12 >> 59) {
        sub_10006A7CC();
      }
      uint64_t v13 = (char *)operator new(32 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[32 * v12];
    uint64_t v15 = sub_101196DCC((uint64_t)&v13[32 * v9], a2);
    uint64_t v8 = v15 + 32;
    uint64_t v17 = *a1;
    unint64_t v16 = a1[1];
    if (v16 == *a1)
    {
      int64x2_t v18 = vdupq_n_s64(v16);
    }
    else
    {
      do
      {
        v16 -= 32;
        uint64_t v15 = sub_101196DCC(v15 - 32, v16);
      }
      while (v16 != v17);
      int64x2_t v18 = *(int64x2_t *)a1;
    }
    *a1 = v15;
    a1[1] = v8;
    int64x2_t v21 = v18;
    uint64_t v19 = a1[2];
    a1[2] = (uint64_t)v14;
    uint64_t v22 = v19;
    uint64_t v20 = v18.i64[0];
    uint64_t result = sub_101196E4C((uint64_t)&v20);
  }
  else
  {
    uint64_t result = sub_101196DCC(v6, a2);
    uint64_t v8 = result + 32;
  }
  a1[1] = v8;
  return result;
}

uint64_t sub_101196DCC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_101196E4C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_101197178((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_101196E9C(uint64_t a1)
{
  *(void *)a1 = off_101A98CF8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_101196EEC(uint64_t a1)
{
  *(void *)a1 = off_101A98CF8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_101196F5C(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = off_101A98CF8;
  uint64_t v3 = v2 + 1;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_10004FC84(v3, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)uint64_t v3 = *(_OWORD *)(a1 + 8);
    v2[3] = *(void *)(a1 + 24);
  }
  return v2;
}

void sub_101196FD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_101196FE4(char *result, void *a2)
{
  *a2 = off_101A98CF8;
  uint64_t v2 = a2 + 1;
  if (result[31] < 0) {
    return (char *)sub_10004FC84(v2, *((void **)result + 1), *((void *)result + 2));
  }
  long long v3 = *(_OWORD *)(result + 8);
  v2[2] = *((void *)result + 3);
  *(_OWORD *)uint64_t v2 = v3;
  return result;
}

void sub_101197030(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

void sub_101197044(void **__p)
{
  if (*((char *)__p + 31) < 0) {
    operator delete(__p[1]);
  }

  operator delete(__p);
}

uint64_t sub_101197088(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 31);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  unint64_t v6 = (const void **)(a1 + 8);
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v6, a2, *(void *)(a1 + 16)) == 0;
  }
  if (!*(unsigned char *)(a1 + 31)) {
    return 1;
  }
  uint64_t v7 = v2 - 1;
  do
  {
    int v9 = *(unsigned __int8 *)v6;
    unint64_t v6 = (const void **)((char *)v6 + 1);
    int v8 = v9;
    int v11 = *a2++;
    int v10 = v11;
    BOOL v13 = v7-- != 0;
    uint64_t result = v8 == v10;
  }
  while (v8 == v10 && v13);
  return result;
}

uint64_t sub_10119712C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10119716C()
{
}

void *sub_101197178(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1011971FC(uint64_t a1)
{
  *(void *)a1 = off_101A98D88;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_10119725C(uint64_t a1)
{
  *(void *)a1 = off_101A98D88;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

char *sub_1011972DC(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = off_101A98D88;
  sub_101197458(v2 + 8, v1);
  return v2;
}

void sub_101197330(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_101197344(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98D88;
  return sub_101197458((char *)(a2 + 8), (long long *)(a1 + 8));
}

void sub_101197370(uint64_t a1)
{
}

void sub_101197378(void *a1)
{
  sub_1000FECD4((uint64_t)a1 + 8);

  operator delete(a1);
}

BOOL sub_1011973B4(uint64_t a1, void **a2)
{
  return (int)(sub_100046FE8((void *)(a1 + 8), a2) << 24) <= 0xFFFFFF
      && (int)(sub_100046FE8(a2, (void **)(a1 + 32)) << 24) < 0x1000000;
}

uint64_t sub_10119740C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10119744C()
{
}

char *sub_101197458(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }
  int v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)int v5 = v6;
  }
  return __dst;
}

void sub_1011974D4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011974F0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    long long v4 = v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        long long v4 = sub_101197178(v4 - 4);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_101197574(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void **)v1;
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(v1 + 8))
      {
        uint64_t v5 = v3[37];
        sub_10004D2C8(v4);
        if (v5)
        {
          uint64_t v6 = v3[18];
          uint64_t v7 = *(void *)(v6 + 8);
          uint64_t v8 = *(void *)(v6 + 16);
          if (v7 == v8) {
            goto LABEL_18;
          }
          int v9 = 0;
          do
          {
            int v10 = *(char **)(v7 + 24);
            if (v10) {
              int v11 = (*(uint64_t (**)(char *))(*(void *)&v10[*(void *)(*(void *)v10 - 320)] + 216))(&v10[*(void *)(*(void *)v10 - 320)]);
            }
            else {
              int v11 = 0;
            }
            unint64_t v12 = *(char **)(v7 + 40);
            if (v12) {
              int v13 = (*(uint64_t (**)(char *))(*(void *)&v12[*(void *)(*(void *)v12 - 320)] + 216))(&v12[*(void *)(*(void *)v12 - 320)]);
            }
            else {
              int v13 = 0;
            }
            v9 += v11 + v13;
            v7 += 432;
          }
          while (v7 != v8);
          if (!v9)
          {
LABEL_18:
            sub_10117EC58((uint64_t)v3);
            uint64_t v15 = v3[5];
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              uint64_t v22 = "operator()";
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s: Done with Shutdown", buf, 0xCu);
            }
            uint64_t v16 = v3[38];
            v3[38] = 0;
            if (v16) {
              (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
            }
            uint64_t v17 = v3[37];
            v3[37] = 0;
            if (v17)
            {
              dispatch_group_leave(v17);
              dispatch_release(v17);
            }
          }
          else
          {
            uint64_t v14 = v3[5];
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              uint64_t v22 = "operator()";
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Still waiting on contexts to go down", buf, 0xCu);
            }
          }
        }
      }
      else
      {
        sub_10004D2C8(v4);
      }
    }
  }
  sub_100004A84(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1011977E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_101197804(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = (dispatch_group_t *)v1;
  uint64_t v2 = *(NSObject **)(*(void *)(v1 + 8) + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enabling cellular data, as network settings have been reset", buf, 2u);
  }
  uint64_t v3 = (uint64_t **)sub_100365D74();
  sub_100058DB0(buf, "GsmRadioModule::fCellularDataIsEnabled");
  sub_1003660FC(v3, (void **)buf);
  if (v8 < 0) {
    operator delete(*(void **)buf);
  }
  sub_10062AF08(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1011978B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10062AF08(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_1011978E8(void *a1)
{
  *a1 = off_101A98E08;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  long long v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_10119794C(void *a1)
{
  *a1 = off_101A98E08;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  long long v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_1011979D0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A98E08;
  sub_100912044(v2 + 1, v1);
  return v2;
}

void *sub_101197A24(uint64_t a1, void *a2)
{
  *a2 = off_101A98E08;
  return sub_100912044(a2 + 1, (void *)(a1 + 8));
}

void sub_101197A50(uint64_t a1)
{
}

void sub_101197A58(void *a1)
{
  sub_10091209C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101197A94(void *a1, unsigned int *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = a1[3];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1])
      {
        char v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v4);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I enterLowPower callback from iWLAN driver", v9, 2u);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_101197B58(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101197B6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101197BAC()
{
}

void *sub_101197BB8(void *a1)
{
  *a1 = off_101A98E88;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_101197C1C(void *a1)
{
  *a1 = off_101A98E88;
  uint64_t v2 = a1[4];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[4];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_101197CA0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A98E88;
  sub_100912044(v2 + 1, v1);
  return v2;
}

void *sub_101197CF4(uint64_t a1, void *a2)
{
  *a2 = off_101A98E88;
  return sub_100912044(a2 + 1, (void *)(a1 + 8));
}

void sub_101197D20(uint64_t a1)
{
}

void sub_101197D28(void *a1)
{
  sub_10091209C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101197D64(void *a1, unsigned int *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = a1[3];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1])
      {
        char v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v4);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I enterLowPower callback from iWLAN driver", v9, 2u);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_101197E28(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101197E3C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A98EE8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_101197E7C()
{
  return &off_101A98EE8;
}

uint64_t *sub_101197E88(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_101197EE4(void *a1)
{
  char v8 = a1;
  uint64_t v2 = a1[2];
  sub_1000607A8((uint64_t)(a1 + 3), 1);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*a1)
      {
        uint64_t v6 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I (completed) enterLowPower callback from iWLAN driver", buf, 2u);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  return sub_101197E88((uint64_t *)&v8);
}

void sub_101197F90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_101197E88((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101197FA4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void **)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(v1 + 8))
      {
        uint64_t v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          unint64_t v12 = "operator()";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: (1) refreshapn", buf, 0xCu);
        }
        (*(void (**)(void *, void, void, void, void))(*v3 + 840))(v3, *(unsigned int *)(v1 + 24), *(unsigned int *)(v1 + 28), *(unsigned int *)(v1 + 32), *(unsigned __int8 *)(v1 + 36));
        uint64_t v7 = v3[5];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          unint64_t v12 = "operator()";
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: (2) refreshapn", buf, 0xCu);
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_10119813C(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_101198118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10119813C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10119813C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void sub_101198194()
{
}

__n128 sub_1011981A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A98F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1011981F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A98F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101198224(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v3)
  {
    uint64_t v5 = 0;
    if (!v4) {
      return v5;
    }
    goto LABEL_5;
  }
  uint64_t v5 = (*(unsigned int (**)(uint64_t, void, void))(*(void *)v3 + 96))(v3, *(unsigned int *)(a1 + 8), *(void *)(a1 + 16)) ^ 1;
  if (v4) {
LABEL_5:
  }
    sub_10004D2C8(v4);
  return v5;
}

void sub_1011982A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011982C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101198300()
{
}

void *sub_10119830C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_101198390(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_10119842C()
{
}

void *sub_101198440()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_101A98F98;
  return result;
}

void sub_101198478(uint64_t a1, void *a2)
{
  *a2 = off_101A98F98;
}

uint64_t sub_1011984A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v2)
  {
    uint64_t v4 = 0;
    if (!v3) {
      return v4;
    }
    goto LABEL_5;
  }
  uint64_t v4 = (*(unsigned int (**)(uint64_t))(*(void *)v2 + 88))(v2) ^ 1;
  if (v3) {
LABEL_5:
  }
    sub_10004D2C8(v3);
  return v4;
}

void sub_101198518(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101198530(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101198570()
{
}

void sub_101198580()
{
}

void *sub_101198594()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_101A99018;
  return result;
}

void sub_1011985CC(uint64_t a1, void *a2)
{
  *a2 = off_101A99018;
}

uint64_t sub_1011985F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a2 + 8);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v2);
  }
  return 1;
}

uint64_t sub_101198624(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101198664()
{
}

uint64_t sub_101198670(char *__s, char **a2)
{
  sub_100058DB0(v7, __s);
  sub_100058DB0(__p, *a2);
  char v3 = sub_100046FE8(v7, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0) {
    operator delete(v7[0]);
  }
  return (v3 >> 7) & 1;
}

void sub_1011986E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101198704(char *__s, char **a2)
{
  sub_100058DB0(v7, __s);
  sub_100058DB0(__p, *a2);
  char v3 = sub_100046FE8(v7, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0) {
    operator delete(v7[0]);
  }
  return (v3 >> 7) & 1;
}

void sub_10119877C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101198798(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_1011987FC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      uint64_t v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v4 + 8) == *((_DWORD *)v5 + 8);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        char v8 = v4;
        if (v7)
        {
          do
          {
            uint64_t v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            char v8 = v4;
          }
          while (!v6);
        }
        int v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            int v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            uint64_t v5 = v10;
          }
          while (!v6);
        }
        uint64_t v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_101198928(void **a1)
{
  v54 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  uint64_t v3 = v2 + 451;
  uint64_t v4 = v2[451];
  if (v4)
  {
    uint64_t v5 = *((unsigned int *)v1 + 2);
    BOOL v6 = v2 + 451;
    do
    {
      int v7 = *((_DWORD *)v4 + 8);
      BOOL v8 = v7 < (int)v5;
      if (v7 >= (int)v5) {
        int v9 = v4;
      }
      else {
        int v9 = v4 + 1;
      }
      if (!v8) {
        BOOL v6 = (uint64_t **)v4;
      }
      uint64_t v4 = (void *)*v9;
    }
    while (*v9);
    if (v6 != v3 && (int)v5 >= *((_DWORD *)v6 + 8))
    {
      unint64_t v12 = v6[6];
      uint64_t v10 = (uint64_t *)(v6 + 6);
      uint64_t v11 = v12;
      if (v12)
      {
        int v13 = *((_DWORD *)v1 + 3);
        uint64_t v14 = v10;
        do
        {
          int v15 = *((_DWORD *)v11 + 8);
          BOOL v16 = v15 < v13;
          if (v15 >= v13) {
            uint64_t v17 = (uint64_t **)v11;
          }
          else {
            uint64_t v17 = (uint64_t **)(v11 + 1);
          }
          if (!v16) {
            uint64_t v14 = v11;
          }
          uint64_t v11 = *v17;
        }
        while (*v17);
        if (v14 != v10 && v13 >= *((_DWORD *)v14 + 8))
        {
          uint64_t v20 = (void *)v14[6];
          int64x2_t v18 = v14 + 6;
          uint64_t v19 = v20;
          if (v20)
          {
            int v21 = *((_DWORD *)v1 + 4);
            uint64_t v22 = v18;
            do
            {
              int v23 = *((_DWORD *)v19 + 7);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = v19;
              }
              else {
                uint64_t v25 = v19 + 1;
              }
              if (!v24) {
                uint64_t v22 = v19;
              }
              uint64_t v19 = (void *)*v25;
            }
            while (*v25);
            if (v22 != v18
              && v21 >= *((_DWORD *)v22 + 7)
              && *((unsigned __int8 *)v22 + 32) == *((unsigned __int8 *)v1 + 20))
            {
              uint64_t v26 = *(NSObject **)(*(uint64_t (**)(void *))(*v2[6] + 16))(v2[6]);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v27 = asStringBool(*((unsigned char *)v1 + 20));
                int v28 = *((_DWORD *)v1 + 3);
                *(_DWORD *)buf = 136315650;
                *(void *)&uint8_t buf[4] = v27;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v28;
                __int16 v56 = 2080;
                uint64_t v57 = asString();
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I fPdpActiveStateSource alreadyHasValue %s for pdpId %d [%s]", buf, 0x1Cu);
              }
              goto LABEL_64;
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v5 = *((unsigned int *)v1 + 2);
  }
  xpc_object_t v29 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v2[6] + 16))(v2[6], v5);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v30 = asStringBool(*((unsigned char *)v1 + 20));
    int v31 = *((_DWORD *)v1 + 3);
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = v30;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v31;
    __int16 v56 = 2080;
    uint64_t v57 = asString();
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Publish fPdpActiveStateSource %s for pdpId %d [%s]", buf, 0x1Cu);
  }
  *(void *)buf = 1;
  *(void *)&uint8_t buf[8] = v2 + 446;
  char v32 = *((unsigned char *)v1 + 20);
  int v33 = *((_DWORD *)v1 + 2);
  v34 = *v3;
  xpc_object_t v35 = v2 + 451;
  if (*v3)
  {
    do
    {
      while (1)
      {
        xpc_object_t v35 = (uint64_t **)v34;
        int v36 = *((_DWORD *)v34 + 8);
        if (v36 <= v33) {
          break;
        }
        v34 = *v35;
        uint64_t v3 = v35;
        if (!*v35) {
          goto LABEL_44;
        }
      }
      if (v36 >= v33) {
        goto LABEL_45;
      }
      v34 = v35[1];
    }
    while (v34);
    uint64_t v3 = v35 + 1;
  }
LABEL_44:
  int v37 = operator new(0x40uLL);
  v37[8] = v33;
  *((void *)v37 + 7) = 0;
  *((void *)v37 + 6) = 0;
  *((void *)v37 + 5) = v37 + 12;
  sub_100046C38(v2 + 450, (uint64_t)v35, v3, (uint64_t *)v37);
  xpc_object_t v35 = (uint64_t **)v37;
LABEL_45:
  v40 = v35[6];
  v39 = v35 + 6;
  v38 = v40;
  int v41 = *((_DWORD *)v1 + 3);
  if (v40)
  {
    do
    {
      while (1)
      {
        v42 = (uint64_t **)v38;
        int v43 = *((_DWORD *)v38 + 8);
        if (v43 <= v41) {
          break;
        }
        v38 = *v42;
        v44 = v42;
        if (!*v42) {
          goto LABEL_53;
        }
      }
      if (v43 >= v41) {
        goto LABEL_54;
      }
      v38 = v42[1];
    }
    while (v38);
    v44 = v42 + 1;
  }
  else
  {
    v44 = v39;
    v42 = v39;
  }
LABEL_53:
  v45 = operator new(0x40uLL);
  v45[8] = v41;
  *((void *)v45 + 7) = 0;
  *((void *)v45 + 6) = 0;
  *((void *)v45 + 5) = v45 + 12;
  sub_100046C38(v39 - 1, (uint64_t)v42, v44, (uint64_t *)v45);
  v42 = (uint64_t **)v45;
LABEL_54:
  v48 = v42[6];
  v47 = v42 + 6;
  uint64_t v46 = (uint64_t)v48;
  int v49 = *((_DWORD *)v1 + 4);
  if (v48)
  {
    do
    {
      while (1)
      {
        uint64_t v50 = v46;
        int v51 = *(_DWORD *)(v46 + 28);
        if (v51 <= v49) {
          break;
        }
        uint64_t v46 = *(void *)v50;
        v52 = (uint64_t **)v50;
        if (!*(void *)v50) {
          goto LABEL_62;
        }
      }
      if (v51 >= v49) {
        goto LABEL_63;
      }
      uint64_t v46 = *(void *)(v50 + 8);
    }
    while (v46);
    v52 = (uint64_t **)(v50 + 8);
  }
  else
  {
    v52 = v47;
    uint64_t v50 = (uint64_t)v47;
  }
LABEL_62:
  v53 = operator new(0x28uLL);
  v53[7] = v49;
  *((unsigned char *)v53 + 32) = 0;
  sub_100046C38(v47 - 1, v50, v52, (uint64_t *)v53);
  uint64_t v50 = (uint64_t)v53;
LABEL_63:
  *(unsigned char *)(v50 + 32) = v32;
  sub_101198D94((uint64_t)buf);
LABEL_64:
  operator delete();
}

void sub_101198D58()
{
}

uint64_t sub_101198D94(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_101198DF8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    int v3 = *(unsigned __int8 *)(a1 + 16);
    if (*(unsigned __int8 *)(v2 + 32) != v3)
    {
      *(unsigned char *)(v2 + 32) = v3;
      uint64_t v4 = *(void *)(v2 + 24);
      if (v4) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v2 + 32);
      }
    }
  }
  return a1;
}

uint64_t *sub_101198E70(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)(v1 + 32);
  if (!*(unsigned char *)(v2 + 288))
  {
    int v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v4 = asStringBool(*(unsigned char *)(v2 + 316));
      std::string::size_type v5 = asStringBool(*(unsigned char *)v1);
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v4;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I (set) fCellularDataIsEnabled changed: %s ==>> %s", (uint8_t *)&buf, 0x16u);
    }
    unsigned __int8 v6 = *(unsigned char *)v1;
    *(unsigned char *)(v2 + 316) = *(unsigned char *)v1;
    buf.__r_.__value_.__r.__words[0] = 1;
    buf.__r_.__value_.__l.__size_ = v2 + 3888;
    buf.__r_.__value_.__r.__words[2] = v6;
    sub_1011956A0((uint64_t)&buf);
    if (*(unsigned char *)(v1 + 24))
    {
      int v7 = (uint64_t **)sub_100365D74();
      sub_100058DB0(&buf, "GsmRadioModule::fCellularDataIsEnabled");
      unsigned __int8 v18 = *(unsigned char *)(v2 + 316);
      sub_100571BC4(v7, &buf, &v18);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      int v8 = *(unsigned __int8 *)(v2 + 315);
      char v9 = *(unsigned char *)(v2 + 315);
      if (v8 != *(unsigned __int8 *)(v2 + 316))
      {
        uint64_t v10 = *(NSObject **)(v2 + 40);
        char v9 = *(unsigned char *)(v2 + 316);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v11 = asStringBool(v8 != 0);
          std::string::size_type v12 = asStringBool(*(unsigned char *)(v2 + 316));
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v11;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v12;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I (persist) fCellularDataIsEnabledPersisted changed: %s ==>> %s", (uint8_t *)&buf, 0x16u);
          char v9 = *(unsigned char *)(v2 + 316);
        }
      }
      *(unsigned char *)(v2 + 315) = v9;
      uint64_t v13 = *(void *)(v2 + 152);
      os_unfair_lock_lock((os_unfair_lock_t)(v13 + 24));
      *(unsigned char *)(v13 + 85) = v9;
      os_unfair_lock_unlock((os_unfair_lock_t)(v13 + 24));
      buf.__r_.__value_.__r.__words[0] = 1;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = (unint64_t)(v2 + 3848);
      buf.__r_.__value_.__s.__data_[16] = *(unsigned char *)(v2 + 315);
      sub_101198DF8((uint64_t)&buf);
      char v14 = *(unsigned char *)v1;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
      buf.__r_.__value_.__l.__size_ = 0x40000000;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)sub_1011866E4;
      uint64_t v20 = &unk_101A95DC8;
      uint64_t v21 = v2;
      char v22 = v14;
      sub_1011864F4((wis::MetricFactory *)&buf);
    }
  }
  sub_101199124(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_1011990F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_101199124(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101199124(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_101199178(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      int v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      std::string::size_type v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7) && rest::operator==())
      {
        std::string::size_type v5 = (void *)v3[1];
        unsigned __int8 v6 = v3;
        if (v5)
        {
          do
          {
            int v3 = v5;
            std::string::size_type v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            int v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            unsigned __int8 v6 = v3;
          }
          while (!v7);
        }
        int v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            char v9 = v8;
            int v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            char v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            std::string::size_type v4 = v9;
          }
          while (!v7);
        }
        std::string::size_type v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_1000346F8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    std::string::size_type v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1011992F4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)**a1;
  if (v2[564])
  {
    int v3 = (uint64_t *)v2[517];
    for (uint64_t i = (uint64_t *)v2[518]; v3 != i; v3 += 2)
    {
      uint64_t v6 = *v3;
      std::string::size_type v5 = (std::__shared_weak_count *)v3[1];
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v7 = *((_DWORD *)v1 + 2);
      if (v7 == -1 || v7 == (*(unsigned int (**)(uint64_t))(*(void *)v6 + 72))(v6))
      {
        uint64_t v8 = v2[564];
        uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 72))(v6);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v8 + 24))(v8, v9, *((unsigned __int8 *)v1 + 12));
        (*(void (**)(uint64_t, void))(*(void *)v6 + 616))(v6, *((unsigned __int8 *)v1 + 12));
      }
      if (v5) {
        sub_10004D2C8(v5);
      }
    }
  }
  operator delete();
}

void sub_10119946C()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

void sub_1011994A4(unint64_t **a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  int v3 = *((unsigned __int8 *)*a1 + 8);
  int v4 = *((unsigned __int8 *)*a1 + 9);
  if (*(unsigned __int8 *)(v2 + 5096) != v3 || *(unsigned __int8 *)(v2 + 5097) != v4)
  {
    *(unsigned char *)(v2 + 5096) = v3;
    *(unsigned char *)(v2 + 5097) = v4;
    int v6 = (*(uint64_t (**)(unint64_t))(*(void *)v2 + 1088))(v2);
    uint64_t v7 = *(void *)(v2 + 112);
    *(void *)std::string buf = *(void *)(v2 + 104);
    *(void *)&uint8_t buf[8] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    int isValidSimSlot = subscriber::isValidSimSlot();
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (isValidSimSlot)
    {
      uint64_t v9 = sub_100AEFE40(*(void *)(v2 + 144), v6);
      uint64_t v10 = *(uint64_t **)(v9 + 56);
      std::string::size_type v11 = *(uint64_t **)(v9 + 64);
      if (v10 != v11)
      {
        do
        {
          uint64_t v13 = *v10;
          uint64_t v12 = (std::__shared_weak_count *)v10[1];
          if (v12) {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v13)
          {
            if ((*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v13 + 216))(v13, 0, 1, 1))
            {
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | *((unsigned __int16 *)v1 + 4);
              (*(void (**)(uint64_t, unint64_t))(*(void *)v13 + 696))(v13, v2);
              LOBYTE(v13) = 1;
              if (!v12) {
                goto LABEL_18;
              }
LABEL_17:
              sub_10004D2C8(v12);
              goto LABEL_18;
            }
            LOBYTE(v13) = 0;
          }
          if (v12) {
            goto LABEL_17;
          }
LABEL_18:
          v10 += 2;
          if (v10 == v11) {
            char v14 = 1;
          }
          else {
            char v14 = v13;
          }
        }
        while ((v14 & 1) == 0);
      }
    }
    else
    {
      int v15 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = "operator()";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = subscriber::asString();
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E %s: invalid SIM: %s", buf, 0x16u);
      }
    }
  }
  operator delete();
}

void sub_10119970C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

uint64_t *sub_10119975C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 112);
  *(void *)std::string buf = *(void *)(*(void *)v1 + 104);
  *(void *)&uint8_t buf[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (isValidSimSlot)
  {
    uint64_t v5 = sub_100AEFE40(*(void *)(v2 + 144), *(_DWORD *)(v1 + 8));
    int v6 = *(uint64_t **)(v5 + 56);
    uint64_t v7 = *(uint64_t **)(v5 + 64);
    if (v6 != v7)
    {
      while (1)
      {
        uint64_t v9 = *v6;
        uint64_t v8 = (std::__shared_weak_count *)v6[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v9
          && ((*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v9 + 216))(v9, 0, 1, 1) & 0x20000) != 0)
        {
          break;
        }
        char v10 = 1;
        if (v8) {
          goto LABEL_12;
        }
LABEL_13:
        if ((v10 & 1) == 0) {
          goto LABEL_23;
        }
        v6 += 2;
        if (v6 == v7) {
          goto LABEL_20;
        }
      }
      uint64_t v11 = *(unsigned int *)(v1 + 12);
      int v12 = *(unsigned __int8 *)(v1 + 16);
      sub_1000DFC90((uint64_t)buf, v1 + 24);
      (*(void (**)(uint64_t, uint64_t, BOOL, unsigned char *))(*(void *)v9 + 680))(v9, v11, v12 != 0, buf);
      sub_100060644(buf);
      char v10 = 0;
      if (!v8) {
        goto LABEL_13;
      }
LABEL_12:
      sub_10004D2C8(v8);
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s: invalid SIM: %s", buf, 0x16u);
    }
  }
LABEL_20:
  char v14 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unsigned __int8 v18 = 136315138;
    uint64_t v19 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: did not find valid IMS settings", v18, 0xCu);
  }
  sub_1000607A8(v1 + 24, 0);
LABEL_23:
  sub_101199A28(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_1011999D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_101199A28(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101199A28(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 24));
    operator delete();
  }
  return result;
}

uint64_t *sub_101199A78(int **a1)
{
  uint64_t v1 = *a1;
  char v14 = a1;
  int v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 112);
  *(void *)std::string buf = *(void *)(*(void *)v1 + 104);
  *(void *)&uint8_t buf[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (isValidSimSlot)
  {
    uint64_t v5 = sub_100AEFE40(*(void *)(v2 + 144), v1[2]);
    int v6 = *(uint64_t **)(v5 + 56);
    uint64_t v7 = *(uint64_t **)(v5 + 64);
    if (v6 != v7)
    {
      while (1)
      {
        uint64_t v9 = *v6;
        uint64_t v8 = (std::__shared_weak_count *)v6[1];
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v9
          && ((*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v9 + 216))(v9, 0, 1, 1) & 0x20000) != 0)
        {
          break;
        }
        char v10 = 1;
        if (v8) {
          goto LABEL_12;
        }
LABEL_13:
        if ((v10 & 1) == 0) {
          goto LABEL_23;
        }
        v6 += 2;
        if (v6 == v7) {
          goto LABEL_20;
        }
      }
      sub_100323990((uint64_t)buf, (uint64_t)(v1 + 4));
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v9 + 688))(v9, buf);
      sub_1000605C0(buf);
      char v10 = 0;
      if (!v8) {
        goto LABEL_13;
      }
LABEL_12:
      sub_10004D2C8(v8);
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v11 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "operator()";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: invalid SIM: %s", buf, 0x16u);
    }
  }
LABEL_20:
  int v12 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)BOOL v16 = 136315138;
    uint64_t v17 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: did not find valid IMS settings", v16, 0xCu);
  }
  sub_10006074C((uint64_t)(v1 + 4), 0, 0);
LABEL_23:
  sub_101199D2C((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_101199CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_101199D2C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_101199D2C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000605C0((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

NSObject ***sub_101199D7C(NSObject ***a1, NSObject **a2, NSObject ***a3, NSObject **a4, NSObject **a5)
{
  uint64_t v5 = a2;
  *a1 = a2;
  a1[1] = *a3;
  uint64_t v7 = a3[1];
  a1[2] = v7;
  if (v7)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
    uint64_t v5 = *a1;
  }
  a1[3] = a4;
  a1[4] = a5;
  ((void (*)(Registry **__return_ptr))(**a3)->isa)(&v26);
  uint64_t v8 = v26;
  uint64_t v9 = v27;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  int v28 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v12;
  BOOL v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v19 = 1;
LABEL_11:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v18 + 80))(&v29, v18, 1, 4, @"iCloudDataExpiryThreshold", 0, 0);
  sub_1000842D0(&v28, &v29);
  sub_1000577C4(&v29);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  uint64_t v20 = v28;
  if (v28) {
    uint64_t v21 = sub_100081E58;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v21)
  {
    char v22 = *v5;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v29 = 0;
      ctu::cf::assign((ctu::cf *)&v29, v20, v23);
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v29;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I read expiry threshold from carrier bundle - day count: %ld", buf, 0xCu);
      uint64_t v20 = v28;
    }
    *(_DWORD *)std::string buf = 0;
    ctu::cf::assign((ctu::cf *)buf, (unsigned int *)v20, v23);
    uint64_t v24 = 86400 * *(unsigned int *)buf;
  }
  else
  {
    uint64_t v24 = 7776000;
  }
  sub_1000570E8((const void **)&v28);
  a1[5] = (NSObject **)v24;
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v27) {
    sub_10004D2C8(v27);
  }
  return a1;
}

void sub_10119A01C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va, a3);
  sub_1000570E8((const void **)va);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (a3) {
    sub_10004D2C8(a3);
  }
  int v6 = *(std::__shared_weak_count **)(v3 + 16);
  if (v6) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10119A09C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 319);
  size_t v3 = *(void *)(a2 + 304);
  if ((v2 & 0x80u) == 0) {
    int v4 = (unsigned __int8 *)*(unsigned __int8 *)(a2 + 319);
  }
  else {
    int v4 = *(unsigned __int8 **)(a2 + 304);
  }
  if (!v4) {
    return 0;
  }
  int v6 = *(unsigned __int8 ***)(a1 + 32);
  uint64_t v7 = (unsigned __int8 *)*((unsigned __int8 *)v6 + 23);
  int v8 = (char)v7;
  if ((char)v7 < 0) {
    uint64_t v7 = v6[1];
  }
  if (v4 != v7) {
    return 0;
  }
  char v10 = (void *)(a2 + 296);
  if (v8 >= 0) {
    uint64_t v11 = *(unsigned __int8 **)(a1 + 32);
  }
  else {
    uint64_t v11 = *v6;
  }
  if ((v2 & 0x80) != 0)
  {
    char v10 = (void *)*v10;
    if (!memcmp(v10, v11, v3)) {
      goto LABEL_21;
    }
    return 0;
  }
  if (v2)
  {
    uint64_t v12 = (unsigned __int8 *)v10;
    while (*v12 == *v11)
    {
      ++v12;
      ++v11;
      if (!--v2)
      {
        uint64_t v13 = **(NSObject ***)a1;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_22;
        }
        return 1;
      }
    }
    return 0;
  }
LABEL_21:
  uint64_t v13 = **(NSObject ***)a1;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
LABEL_22:
    uint64_t v15 = a2 + 248;
    if (*(char *)(a2 + 271) < 0) {
      uint64_t v15 = *(void *)(a2 + 248);
    }
    int v16 = 136315394;
    uint64_t v17 = v10;
    __int16 v18 = 2082;
    uint64_t v19 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I filter out self device: S/N:%s, name:%{public}s", (uint8_t *)&v16, 0x16u);
  }
  return 1;
}

uint64_t sub_10119A214(NSObject ***a1, uint64_t a2, double a3)
{
  if (a1[3][2])
  {
    int v6 = (unsigned __int8 *)(a2 + 296);
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    uint64_t v7 = *(void *)(a2 + 368);
    uint64_t v8 = *(void *)(a2 + 376);
    while (v7 != v8)
    {
      if (sub_10010E128((uint64_t)a1[3], (void **)(v7 + 8)))
      {
        uint64_t v33 = (uint64_t)a1[3];
        *(void *)std::string buf = 0;
        uint64_t v12 = *sub_100046ED4(v33, buf, (void **)(v7 + 8));
        if (!v12) {
          sub_1000C14F0("map::at:  key not found");
        }
LABEL_47:
        sub_10034D494((uint64_t)&v48, (uint64_t)&v12[7]);
        BYTE8(v53) = 1;
        if ((_BYTE)v48)
        {
          if (*(double *)&v53 >= a3) {
            a3 = *(double *)&v53;
          }
          v34 = **a1;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            *(_DWORD *)std::string buf = 134218240;
            *(double *)&uint8_t buf[4] = a3;
            __int16 v55 = 2048;
            CFAbsoluteTime v56 = Current;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I record last sync up time:%.2f, now: %.2f", buf, 0x16u);
          }
          CFAbsoluteTime v36 = CFAbsoluteTimeGetCurrent() - a3;
          CFAbsoluteTime v37 = (double)(uint64_t)a1[5];
          v38 = **a1;
          BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
          if (v36 <= v37)
          {
            if (v39)
            {
              if (*(char *)(a2 + 319) >= 0) {
                v40 = v6;
              }
              else {
                v40 = *(unsigned __int8 **)(a2 + 296);
              }
              double v41 = COERCE_DOUBLE((long long *)((char *)&v48 + 8));
              if (v49 < 0) {
                double v41 = *((double *)&v48 + 1);
              }
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = v40;
              __int16 v55 = 2080;
              CFAbsoluteTime v56 = v41;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I valid device: S/N:%s, name:%s", buf, 0x16u);
            }
            uint64_t v27 = 1;
            goto LABEL_78;
          }
          if (v39)
          {
            if (*(char *)(a2 + 319) >= 0) {
              v45 = v6;
            }
            else {
              v45 = *(unsigned __int8 **)(a2 + 296);
            }
            double v46 = COERCE_DOUBLE((long long *)((char *)&v48 + 8));
            if (v49 < 0) {
              double v46 = *((double *)&v48 + 1);
            }
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v45;
            __int16 v55 = 2080;
            CFAbsoluteTime v56 = v46;
            char v32 = "#I filter out not up to date device. S/N:%s, name:%s";
            v44 = v38;
LABEL_76:
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v32, buf, 0x16u);
          }
          uint64_t v27 = 0;
          goto LABEL_78;
        }
        xpc_object_t v29 = **a1;
        uint64_t v27 = 0;
        if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        if (*(char *)(a2 + 319) >= 0) {
          v42 = v6;
        }
        else {
          v42 = *(unsigned __int8 **)(a2 + 296);
        }
        double v43 = COERCE_DOUBLE((long long *)((char *)&v48 + 8));
        if (v49 < 0) {
          double v43 = *((double *)&v48 + 1);
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v42;
        __int16 v55 = 2080;
        CFAbsoluteTime v56 = v43;
        char v32 = "#I filter out untrusted device. S/N:%s, name:%s";
LABEL_68:
        v44 = v29;
        goto LABEL_76;
      }
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      uint64_t v9 = *a1;
      char v10 = a1[3];
      uint64_t v13 = *v10;
      uint64_t v11 = (v10 + 1);
      uint64_t v12 = v13;
      if (v13 != v11)
      {
        char v14 = *(unsigned char *)(a2 + 319);
        if (v14 >= 0) {
          uint64_t v15 = (objc_class *)*(unsigned __int8 *)(a2 + 319);
        }
        else {
          uint64_t v15 = *(objc_class **)(a2 + 304);
        }
        if (v14 >= 0) {
          int v16 = v6;
        }
        else {
          int v16 = *(unsigned __int8 **)(a2 + 296);
        }
        do
        {
          uint64_t isa_high = HIBYTE(v12[16].isa);
          if ((isa_high & 0x80u) == 0) {
            Class isa = (Class)HIBYTE(v12[16].isa);
          }
          else {
            Class isa = v12[15].isa;
          }
          if (isa == v15)
          {
            p_Class isa = (const void **)&v12[14].isa;
            if ((isa_high & 0x80) != 0)
            {
              int v21 = memcmp(*p_isa, v16, (size_t)v12[15].isa);
              if (v15 && !v21) {
                goto LABEL_47;
              }
            }
            else if (HIBYTE(v12[16].isa))
            {
              uint64_t v20 = v16;
              while (*(unsigned __int8 *)p_isa == *v20)
              {
                p_Class isa = (const void **)((char *)p_isa + 1);
                ++v20;
                if (!--isa_high) {
                  goto LABEL_21;
                }
              }
            }
            else
            {
LABEL_21:
              if (v15) {
                goto LABEL_47;
              }
            }
          }
          char v22 = v12[1].isa;
          if (v22)
          {
            do
            {
              CFNumberRef v23 = v22;
              char v22 = v22->isa;
            }
            while (v22);
          }
          else
          {
            do
            {
              CFNumberRef v23 = v12[2].isa;
              BOOL v24 = v23->isa == (Class)v12;
              uint64_t v12 = v23;
            }
            while (!v24);
          }
          uint64_t v12 = v23;
        }
        while (v23 != v11);
      }
      uint64_t v25 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I No matching device by serial number", buf, 2u);
      }
      LOBYTE(v48) = 0;
      BYTE8(v53) = 0;
      sub_10119BF54((uint64_t)&v48);
      v7 += 80;
    }
    int v28 = **a1;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Failed to find device info by record!", buf, 2u);
    }
    LOBYTE(v48) = 0;
    BYTE8(v53) = 0;
    xpc_object_t v29 = **a1;
    uint64_t v27 = 0;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&double v30 = a2 + 248;
      if (*(char *)(a2 + 319) >= 0) {
        int v31 = v6;
      }
      else {
        int v31 = *(unsigned __int8 **)(a2 + 296);
      }
      if (*(char *)(a2 + 271) < 0) {
        double v30 = *(double *)(a2 + 248);
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v31;
      __int16 v55 = 2080;
      CFAbsoluteTime v56 = v30;
      char v32 = "#I filter out signed out device: S/N:%s, name:%s";
      goto LABEL_68;
    }
LABEL_78:
    sub_10119BF54((uint64_t)&v48);
  }
  else
  {
    uint64_t v26 = **a1;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v48) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "invalid remote device list from AuthKit. no filter", (uint8_t *)&v48, 2u);
    }
    return 1;
  }
  return v27;
}

void sub_10119A754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10119A774(NSObject ***a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 240)) {
    return 0;
  }
  uint64_t v5 = a2 + 32;
  if ((void **)(a3 + 8) != sub_100046F68(a3, (void **)(a2 + 32))) {
    return 1;
  }
  uint64_t v7 = **a1;
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v8)
  {
    if (*(char *)(a2 + 55) >= 0) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = *(void *)(a2 + 32);
    }
    int v10 = 136315138;
    uint64_t v11 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Not found ids device id: %s", (uint8_t *)&v10, 0xCu);
    return 0;
  }
  return result;
}

uint64_t sub_10119A86C(NSObject ***a1, uint64_t a2, uint64_t *a3, uint64_t **a4)
{
  if (!*(unsigned char *)(a2 + 240)) {
    return 0;
  }
  uint64_t v5 = a2;
  if (sub_10119A09C((uint64_t)a1, a2)) {
    return 0;
  }
  uint64_t result = sub_10119A214(a1, v5, *(double *)(v5 + 392));
  if (!result) {
    return result;
  }
  sub_10098FD3C((void *)v5, (uint64_t)&buf);
  std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = buf.__r_.__value_.__l.__size_;
  }
  if (size == 6)
  {
    p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    int data = (int)p_buf->__r_.__value_.__l.__data_;
    int v11 = WORD2(p_buf->__r_.__value_.__r.__words[0]);
    BOOL v13 = data == 1869107305 && v11 == 25966;
    if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  BOOL v13 = 0;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
LABEL_20:
  }
    operator delete(buf.__r_.__value_.__l.__data_);
LABEL_21:
  if (v13)
  {
    uint64_t v15 = *(void *)(v5 + 200);
    uint64_t v14 = *(void *)(v5 + 208);
    if (v15 == v14) {
      return 1;
    }
    uint64_t v71 = *(void *)(v5 + 208);
    uint64_t v72 = v5;
    while (1)
    {
      if (*(unsigned char *)(v15 + 80))
      {
        uint64_t v17 = *(_DWORD **)(v5 + 368);
        int v16 = *(_DWORD **)(v5 + 376);
        sub_1000C5DA8((uint64_t)v79, v15);
        if (v17 != v16)
        {
          while (v80 != *v17)
          {
            v17 += 20;
            if (v17 == v16)
            {
              uint64_t v17 = v16;
              break;
            }
          }
        }
        if (v83[24])
        {
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v83;
          sub_1000C57C8((void ***)&buf);
        }
        if (v82 < 0) {
          operator delete(__p);
        }
        if (v17 != *(_DWORD **)(v5 + 376))
        {
          memset(&__str, 0, sizeof(__str));
          ctu::hex((uint64_t *)&__str, (ctu *)(v15 + 16), (const void *)0x10, v18);
          if (!*(unsigned char *)(v15 + 80)) {
            sub_10016C840();
          }
          uint64_t v19 = a3;
          uint64_t v20 = *(void *)(v15 + 56);
          uint64_t v21 = *(void *)(v15 + 64);
          if (v20 != v21)
          {
            v73 = (void **)(v17 + 16);
            uint64_t v74 = (uint64_t)(v17 + 14);
            do
            {
              char v22 = *(unsigned char *)(v20 + 39);
              if (v22 < 0)
              {
                if (*(void *)(v20 + 24))
                {
LABEL_41:
                  CFNumberRef v23 = (std::string::size_type *)(v20 + 16);
                  if (*(unsigned char *)(v20 + 89))
                  {
                    BOOL v24 = sub_100046F68(v74, (void **)(v20 + 16));
                    if (v73 == v24)
                    {
                      v40 = **a1;
                      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_75;
                      }
                      std::string::size_type v41 = v20 + 16;
                      if (*(char *)(v20 + 39) < 0) {
                        std::string::size_type v41 = *v23;
                      }
                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v41;
                      xpc_object_t v35 = v40;
                      CFAbsoluteTime v36 = "#I Filter iccid (%s) for additional profile info not present";
                    }
                    else
                    {
                      uint64_t v25 = sub_100046F68(*v19, (void **)(v20 + 16));
                      if ((void **)(*v19 + 8) != v25)
                      {
                        uint64_t v26 = (int *)(v25 + 31);
                        uint64_t v27 = (void *)*((unsigned __int8 *)v25 + 271);
                        int v28 = (char)v27;
                        if ((char)v27 < 0) {
                          uint64_t v27 = v25[32];
                        }
                        if (v27 == (void *)7)
                        {
                          xpc_object_t v29 = *(int **)v26;
                          if (v28 >= 0) {
                            xpc_object_t v29 = (int *)(v25 + 31);
                          }
                          int v30 = *v29;
                          int v31 = *(int *)((char *)v29 + 3);
                          if (v30 == 1330400321 && v31 == 1145395023)
                          {
                            memset(&buf, 0, sizeof(buf));
                            ((void (*)(std::string *__return_ptr))(*a1[1])->isa)(&v76);
                            ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)v76.__r_.__value_.__l.__data_);
                            v54 = ServiceMap;
                            if ((v55 & 0x8000000000000000) != 0)
                            {
                              CFAbsoluteTime v56 = (unsigned __int8 *)(v55 & 0x7FFFFFFFFFFFFFFFLL);
                              uint64_t v57 = 5381;
                              do
                              {
                                unint64_t v55 = v57;
                                unsigned int v58 = *v56++;
                                uint64_t v57 = (33 * v57) ^ v58;
                              }
                              while (v58);
                            }
                            std::mutex::lock(ServiceMap);
                            unint64_t v77 = v55;
                            v59 = sub_10004D37C(&v54[1].__m_.__sig, &v77);
                            if (v59)
                            {
                              uint64_t v60 = v59[3];
                              v61 = (std::__shared_weak_count *)v59[4];
                              if (v61)
                              {
                                atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
                                std::mutex::unlock(v54);
                                atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
                                sub_10004D2C8(v61);
                                char v62 = 0;
LABEL_98:
                                if (v76.__r_.__value_.__l.__size_) {
                                  sub_10004D2C8((std::__shared_weak_count *)v76.__r_.__value_.__l.__size_);
                                }
                                if (v60)
                                {
                                  (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v60 + 24))(&v76, v60, v20 + 96);
                                  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                                    operator delete(buf.__r_.__value_.__l.__data_);
                                  }
                                  std::string buf = v76;
                                }
                                if ((v62 & 1) == 0) {
                                  sub_10004D2C8(v61);
                                }
                                std::string::size_type v63 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                                char v64 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                                if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                                  std::string::size_type v63 = buf.__r_.__value_.__l.__size_;
                                }
                                if (v63)
                                {
                                  std::string::operator=((std::string *)(v24 + 19), &buf);
                                  char v64 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                                }
                                if (v64 < 0) {
                                  operator delete(buf.__r_.__value_.__l.__data_);
                                }
                                goto LABEL_88;
                              }
                            }
                            else
                            {
                              uint64_t v60 = 0;
                            }
                            std::mutex::unlock(v54);
                            v61 = 0;
                            char v62 = 1;
                            goto LABEL_98;
                          }
                        }
                        uint64_t v33 = **a1;
                        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                        {
                          if (*(char *)(v20 + 39) >= 0) {
                            std::string::size_type v34 = v20 + 16;
                          }
                          else {
                            std::string::size_type v34 = *(void *)(v20 + 16);
                          }
                          if (v28 < 0) {
                            uint64_t v26 = *(int **)v26;
                          }
                          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v34;
                          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v26;
                          xpc_object_t v35 = v33;
                          CFAbsoluteTime v36 = "#I Filter iccid (%s) for server policy result [%s]";
                          uint32_t v37 = 22;
LABEL_74:
                          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v36, (uint8_t *)&buf, v37);
                        }
LABEL_75:
                        v44 = *a4;
                        unint64_t v45 = (*a4)[1];
                        double v46 = (unint64_t *)(*a4 + 2);
                        if (v45 >= *v46)
                        {
                          unint64_t v48 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v45 - *v44) >> 3);
                          unint64_t v49 = v48 + 1;
                          if (v48 + 1 > 0x147AE147AE147AELL) {
                            sub_10006A748();
                          }
                          if (0x1EB851EB851EB852 * ((uint64_t)(*v46 - *v44) >> 3) > v49) {
                            unint64_t v49 = 0x1EB851EB851EB852 * ((uint64_t)(*v46 - *v44) >> 3);
                          }
                          if (0x8F5C28F5C28F5C29 * ((uint64_t)(*v46 - *v44) >> 3) >= 0xA3D70A3D70A3D7) {
                            unint64_t v50 = 0x147AE147AE147AELL;
                          }
                          else {
                            unint64_t v50 = v49;
                          }
                          uint64_t v86 = (uint64_t)(*a4 + 2);
                          if (v50) {
                            long long v51 = (char *)sub_10030FA44((uint64_t)v46, v50);
                          }
                          else {
                            long long v51 = 0;
                          }
                          std::string::size_type v52 = (std::string::size_type)&v51[200 * v48];
                          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v51;
                          buf.__r_.__value_.__l.__size_ = v52;
                          v85 = &v51[200 * v50];
                          *(_OWORD *)std::string::size_type v52 = 0u;
                          *(_OWORD *)(v52 + 16) = 0u;
                          *(_OWORD *)(v52 + 32) = 0u;
                          *(_OWORD *)(v52 + 48) = 0u;
                          *(_OWORD *)(v52 + 64) = 0u;
                          *(_OWORD *)(v52 + 80) = 0u;
                          *(_OWORD *)(v52 + 96) = 0u;
                          *(_OWORD *)(v52 + 112) = 0u;
                          *(_OWORD *)(v52 + 128) = 0u;
                          *(_OWORD *)(v52 + 144) = 0u;
                          *(_OWORD *)(v52 + 160) = 0u;
                          *(_OWORD *)(v52 + 176) = 0u;
                          *(void *)(v52 + 192) = 0;
                          buf.__r_.__value_.__r.__words[2] = v52 + 200;
                          sub_100427EAC(v44, &buf);
                          uint64_t v47 = v44[1];
                          sub_100428018((uint64_t)&buf);
                        }
                        else
                        {
                          *(void *)(v45 + 192) = 0;
                          *(_OWORD *)(v45 + 160) = 0u;
                          *(_OWORD *)(v45 + 176) = 0u;
                          *(_OWORD *)(v45 + 128) = 0u;
                          *(_OWORD *)(v45 + 144) = 0u;
                          *(_OWORD *)(v45 + 96) = 0u;
                          *(_OWORD *)(v45 + 112) = 0u;
                          *(_OWORD *)(v45 + 64) = 0u;
                          *(_OWORD *)(v45 + 80) = 0u;
                          *(_OWORD *)(v45 + 32) = 0u;
                          *(_OWORD *)(v45 + 48) = 0u;
                          *(_OWORD *)unint64_t v45 = 0u;
                          *(_OWORD *)(v45 + 16) = 0u;
                          uint64_t v47 = v45 + 200;
                          v44[1] = v45 + 200;
                        }
                        v44[1] = v47;
                        std::string::operator=((std::string *)(v47 - 128), (const std::string *)(v20 + 16));
                        std::string::operator=((std::string *)(v47 - 152), &__str);
                        goto LABEL_88;
                      }
                      v42 = **a1;
                      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_75;
                      }
                      if (*(char *)(v20 + 39) >= 0) {
                        std::string::size_type v43 = v20 + 16;
                      }
                      else {
                        std::string::size_type v43 = *(void *)(v20 + 16);
                      }
                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v43;
                      xpc_object_t v35 = v42;
                      CFAbsoluteTime v36 = "#I Filter iccid (%s) for server policy not present";
                    }
                  }
                  else
                  {
                    v38 = **a1;
                    if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_75;
                    }
                    std::string::size_type v39 = v20 + 16;
                    if (v22 < 0) {
                      std::string::size_type v39 = *v23;
                    }
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v39;
                    xpc_object_t v35 = v38;
                    CFAbsoluteTime v36 = "#I Filter iccid (%s) for profile not active at iPhone";
                  }
                  uint32_t v37 = 12;
                  goto LABEL_74;
                }
              }
              else if (*(unsigned char *)(v20 + 39))
              {
                goto LABEL_41;
              }
LABEL_88:
              v20 += 216;
            }
            while (v20 != v21);
          }
          uint64_t v5 = v72;
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          a3 = v19;
          uint64_t v14 = v71;
        }
      }
      v15 += 88;
      if (v15 == v14) {
        return 1;
      }
    }
  }
  v65 = **a1;
  BOOL v66 = os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v66)
  {
    sub_10098FD3C((void *)v5, (uint64_t)&buf);
    v67 = (std::string *)buf.__r_.__value_.__r.__words[0];
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v67 = &buf;
    }
    std::string::size_type v70 = *(void *)(v5 + 248);
    std::string::size_type v69 = v5 + 248;
    std::string::size_type v68 = v70;
    if (*(char *)(v69 + 23) >= 0) {
      std::string::size_type v68 = v69;
    }
    LODWORD(__str.__r_.__value_.__l.__data_) = 136446466;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v67;
    WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = v68;
    _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I filter out device: %{public}s name: %s", (uint8_t *)&__str, 0x16u);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    return 0;
  }
  return result;
}

void sub_10119B040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (*(char *)(v30 - 121) < 0) {
    operator delete(*(void **)(v30 - 144));
  }
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10119B0D4(NSObject ***a1@<X0>, void **a2@<X1>, void *a3@<X2>, void **a4@<X8>)
{
  uint64_t v7 = *a2;
  if (*a2) {
    BOOL v8 = sub_100083F10;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    uint64_t v86 = a4;
    id v9 = v7;
    if (v7)
    {
      v85 = v9;
      v124[1] = 0;
      v124[0] = 0;
      v123 = v124;
      v122[0] = 0;
      v122[1] = 0;
      v121 = v122;
      uint64_t v12 = (void *)*a3;
      int v10 = a3 + 1;
      int v11 = v12;
      if (v12 != v10)
      {
        while (1)
        {
          sub_1002055B4((const void **)v11 + 11, (const void **)v11 + 14, &v119);
          int v13 = *((char *)v11 + 159);
          if (v13 >= 0) {
            uint64_t v14 = (const std::string::value_type *)(v11 + 17);
          }
          else {
            uint64_t v14 = (const std::string::value_type *)v11[17];
          }
          if (v13 >= 0) {
            std::string::size_type v15 = *((unsigned __int8 *)v11 + 159);
          }
          else {
            std::string::size_type v15 = v11[18];
          }
          int v16 = std::string::append(&v119, v14, v15);
          long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
          v120.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v120.__r_.__value_.__l.__data_ = v17;
          v16->__r_.__value_.__l.__size_ = 0;
          v16->__r_.__value_.__r.__words[2] = 0;
          v16->__r_.__value_.__r.__words[0] = 0;
          int v18 = *((char *)v11 + 183);
          if (v18 >= 0) {
            uint64_t v19 = (const std::string::value_type *)(v11 + 20);
          }
          else {
            uint64_t v19 = (const std::string::value_type *)v11[20];
          }
          if (v18 >= 0) {
            std::string::size_type v20 = *((unsigned __int8 *)v11 + 183);
          }
          else {
            std::string::size_type v20 = v11[21];
          }
          uint64_t v21 = std::string::append(&v120, v19, v20);
          long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
          std::string::size_type v129 = v21->__r_.__value_.__r.__words[2];
          long long buf = v22;
          v21->__r_.__value_.__l.__size_ = 0;
          v21->__r_.__value_.__r.__words[2] = 0;
          v21->__r_.__value_.__r.__words[0] = 0;
          sub_1000EA6A0((uint64_t **)&v123, (void **)&buf, (uint64_t)&buf);
          if (SHIBYTE(v129) < 0) {
            operator delete((void *)buf);
          }
          if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v120.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v119.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v119.__r_.__value_.__l.__data_);
          }
          if ((*((char *)v11 + 55) & 0x80000000) == 0) {
            break;
          }
          if (v11[5]) {
            goto LABEL_29;
          }
LABEL_30:
          CFNumberRef v23 = (void *)v11[1];
          if (v23)
          {
            do
            {
              BOOL v24 = v23;
              CFNumberRef v23 = (void *)*v23;
            }
            while (v23);
          }
          else
          {
            do
            {
              BOOL v24 = (void *)v11[2];
              BOOL v25 = *v24 == (void)v11;
              int v11 = v24;
            }
            while (!v25);
          }
          int v11 = v24;
          if (v24 == v10) {
            goto LABEL_36;
          }
        }
        if (!*((unsigned char *)v11 + 55)) {
          goto LABEL_30;
        }
LABEL_29:
        sub_100046BAC((uint64_t **)&v121, (void **)v11 + 4, (uint64_t)(v11 + 4));
        goto LABEL_30;
      }
LABEL_36:
      cf = objc_opt_new();
      long long v117 = 0u;
      long long v118 = 0u;
      long long v115 = 0u;
      long long v116 = 0u;
      id obj = v85;
      id v91 = [obj countByEnumeratingWithState:&v115 objects:v127 count:16];
      if (!v91) {
        goto LABEL_140;
      }
      uint64_t v90 = *(void *)v116;
LABEL_38:
      uint64_t v92 = 0;
      while (1)
      {
        if (*(void *)v116 != v90) {
          objc_enumerationMutation(obj);
        }
        v93 = *(void **)(*((void *)&v115 + 1) + 8 * v92);
        v94 = objc_opt_new();
        v95 = objc_opt_new();
        long long v113 = 0u;
        long long v114 = 0u;
        long long v112 = 0u;
        long long v111 = 0u;
        id v99 = [v93 remoteDisplayPlans];
        id v26 = [v99 countByEnumeratingWithState:&v111 objects:v126 count:16];
        if (v26) {
          break;
        }
LABEL_136:

        if ([v95 count])
        {
          v83 = objc_opt_new();
          [v83 setRemotePlans:v94];
          [v83 setRemoteDisplayPlans:v95];
          v84 = [v93 deviceID];
          [v83 setDeviceID:v84];

          objc_msgSend(v83, "setIsMultiESimEnabled:", objc_msgSend(v93, "isMultiESimEnabled"));
          [cf addObject:v83];
        }
        if ((id)++v92 == v91)
        {
          id v91 = [obj countByEnumeratingWithState:&v115 objects:v127 count:16];
          if (!v91)
          {
LABEL_140:

            sub_100044D34(v86, cf);
            sub_10005CD2C((uint64_t)&v121, v122[0]);
            sub_10005CD2C((uint64_t)&v123, v124[0]);
            id v9 = v85;
            goto LABEL_143;
          }
          goto LABEL_38;
        }
      }
      uint64_t v27 = *(void *)v112;
LABEL_43:
      uint64_t v28 = 0;
      while (1)
      {
        if (*(void *)v112 != v27) {
          objc_enumerationMutation(v99);
        }
        xpc_object_t v29 = *(void **)(*((void *)&v111 + 1) + 8 * v28);
        uint64_t v30 = [v29 plan];
        int v31 = [v30 planID];
        char v32 = [v31 mcc];
        if (![v32 length]) {
          goto LABEL_52;
        }
        uint64_t v33 = [v31 mnc];
        if (![v33 length])
        {

LABEL_52:
LABEL_53:
          v42 = **a1;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v31;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Invalid add on plan identifiers: %@", (uint8_t *)&buf, 0xCu);
          }
          goto LABEL_105;
        }
        std::string::size_type v34 = [v31 iccid];
        BOOL v35 = [v34 length] == 0;

        if (v35) {
          goto LABEL_53;
        }
        long long buf = 0uLL;
        std::string::size_type v129 = 0;
        id v36 = [v31 mcc];
        sub_100058DB0(&buf, (char *)[v36 UTF8String]);

        memset(&v120, 0, sizeof(v120));
        id v37 = [v31 mnc];
        sub_100058DB0(&v120, (char *)[v37 UTF8String]);

        memset(&v119, 0, sizeof(v119));
        id v38 = [v31 iccid];
        sub_100058DB0(&v119, (char *)[v38 UTF8String]);

        v108 = 0;
        std::string::size_type v109 = 0;
        uint64_t v110 = 0;
        std::string::size_type v39 = [v31 gid1];
        id v40 = [v39 length];
        if (v40)
        {
          id v98 = [v31 gid1];
          std::string::size_type v41 = (char *)[v98 UTF8String];
        }
        else
        {
          std::string::size_type v41 = "";
        }
        sub_100058DB0(&v108, v41);
        if (v40) {

        }
        v105 = 0;
        std::string::size_type v106 = 0;
        uint64_t v107 = 0;
        std::string::size_type v43 = [v31 gid2];
        id v44 = [v43 length];
        if (v44)
        {
          id v97 = [v31 gid2];
          unint64_t v45 = (char *)[v97 UTF8String];
        }
        else
        {
          unint64_t v45 = "";
        }
        sub_100058DB0(&v105, v45);
        if (v44) {

        }
        v103[0] = 0;
        v103[1] = 0;
        uint64_t v104 = 0;
        double v46 = [v31 carrierName];
        id v47 = [v46 length];
        if (v47)
        {
          id v96 = [v31 carrierName];
          unint64_t v48 = (char *)[v96 UTF8String];
        }
        else
        {
          unint64_t v48 = "";
        }
        sub_100058DB0(v103, v48);
        if (v47) {

        }
        if (sub_10010E128((uint64_t)&v121, v103)) {
          break;
        }
        sub_1002055B4((const void **)&buf, (const void **)&v120.__r_.__value_.__l.__data_, &v101);
        if (v110 >= 0) {
          unint64_t v49 = (const std::string::value_type *)&v108;
        }
        else {
          unint64_t v49 = (const std::string::value_type *)v108;
        }
        if (v110 >= 0) {
          std::string::size_type v50 = HIBYTE(v110);
        }
        else {
          std::string::size_type v50 = v109;
        }
        long long v51 = std::string::append(&v101, v49, v50);
        long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
        v102.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v102.__r_.__value_.__l.__data_ = v52;
        v51->__r_.__value_.__l.__size_ = 0;
        v51->__r_.__value_.__r.__words[2] = 0;
        v51->__r_.__value_.__r.__words[0] = 0;
        if (v107 >= 0) {
          long long v53 = (const std::string::value_type *)&v105;
        }
        else {
          long long v53 = (const std::string::value_type *)v105;
        }
        if (v107 >= 0) {
          std::string::size_type v54 = HIBYTE(v107);
        }
        else {
          std::string::size_type v54 = v106;
        }
        unint64_t v55 = std::string::append(&v102, v53, v54);
        long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
        __p[2] = (void *)v55->__r_.__value_.__r.__words[2];
        *(_OWORD *)__p = v56;
        v55->__r_.__value_.__l.__size_ = 0;
        v55->__r_.__value_.__r.__words[2] = 0;
        v55->__r_.__value_.__r.__words[0] = 0;
        uint64_t v57 = sub_10010E128((uint64_t)&v123, __p);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v102.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v101.__r_.__value_.__l.__data_);
          if (v57) {
            break;
          }
        }
        else if (v57)
        {
          break;
        }
        if ([v30 addOnPurchaseType] != (id)2
          && ((unsigned int (*)(NSObject **, long long *, std::string *, void **, void **, std::string *))(*a1[1])[24].isa)(a1[1], &buf, &v120, &v108, &v105, &v119))
        {
          std::string::size_type v63 = **a1;
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_93;
          }
          int v64 = SHIBYTE(v119.__r_.__value_.__r.__words[2]);
          std::string::size_type v65 = v119.__r_.__value_.__r.__words[0];
          id v66 = [v30 addOnPurchaseType];
          LODWORD(__p[0]) = 136315394;
          v67 = &v119;
          if (v64 < 0) {
            v67 = (std::string *)v65;
          }
          *(void **)((char *)__p + 4) = v67;
          WORD2(__p[1]) = 2048;
          *(void **)((char *)&__p[1] + 6) = v66;
          uint64_t v60 = v63;
          v61 = "#I Filter iccid (%s) for feature not supported by remote plan addOnPurchaseType: %lu";
          uint32_t v62 = 22;
          goto LABEL_92;
        }
        int v68 = ((uint64_t (*)(NSObject **, long long *, std::string *, void **, void **, std::string *))(*a1[1])[22].isa)(a1[1], &buf, &v120, &v108, &v105, &v119);
        if (v68 == 2)
        {
          uint64_t v77 = 2;
          goto LABEL_125;
        }
        if (v68 == 1)
        {
          uint64_t v71 = [v30 signUpDetails];
          uint64_t v72 = [v71 signUpUrl];
          BOOL v73 = [v72 length] == 0;

          if (v73)
          {
            v78 = **a1;
            if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_93;
            }
            v79 = &v119;
            if ((v119.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              v79 = (std::string *)v119.__r_.__value_.__r.__words[0];
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v79;
            uint64_t v60 = v78;
            v61 = "#I Filter iccid (%s) for addOnPlanEndPoint not present";
          }
          else
          {
            uint64_t v74 = [v30 signUpDetails];
            v75 = [v74 signUpUrlType];
            BOOL v76 = [v75 length] == 0;

            if (!v76)
            {
              uint64_t v77 = 1;
LABEL_125:
              [v30 setAddOnCarrierFlowType:v77];
LABEL_126:
              [v94 addObject:v30];
              [v95 addObject:v29];
              goto LABEL_93;
            }
            int v80 = **a1;
            if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_93;
            }
            v81 = &v119;
            if ((v119.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              v81 = (std::string *)v119.__r_.__value_.__r.__words[0];
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v81;
            uint64_t v60 = v80;
            v61 = "#I Filter iccid (%s) for addOnPlanEndPointType not present";
          }
LABEL_91:
          uint32_t v62 = 12;
LABEL_92:
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, v61, (uint8_t *)__p, v62);
          goto LABEL_93;
        }
        if (v68) {
          goto LABEL_126;
        }
        std::string::size_type v69 = **a1;
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
        {
          std::string::size_type v70 = &v119;
          if ((v119.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v70 = (std::string *)v119.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v70;
          uint64_t v60 = v69;
          v61 = "#I Filter iccid (%s) for feature not supported by carrier";
          goto LABEL_91;
        }
LABEL_93:
        if (SHIBYTE(v104) < 0) {
          operator delete(v103[0]);
        }
        if (SHIBYTE(v107) < 0) {
          operator delete(v105);
        }
        if (SHIBYTE(v110) < 0) {
          operator delete(v108);
        }
        if (SHIBYTE(v119.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v119.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v120.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v129) < 0) {
          operator delete((void *)buf);
        }
LABEL_105:

        if (v26 == (id)++v28)
        {
          id v82 = [v99 countByEnumeratingWithState:&v111 objects:v126 count:16];
          id v26 = v82;
          if (!v82) {
            goto LABEL_136;
          }
          goto LABEL_43;
        }
      }
      unsigned int v58 = **a1;
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        v59 = &v119;
        if ((v119.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          v59 = (std::string *)v119.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = v59;
        uint64_t v60 = v58;
        v61 = "#I Filter iccid (%s) for carrier plan present on device";
        goto LABEL_91;
      }
      goto LABEL_93;
    }
    *a4 = *a2;
    *a2 = 0;
LABEL_143:
  }
  else
  {
    *a4 = v7;
    *a2 = 0;
  }
}

void sub_10119BC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10005CD2C((uint64_t)&a71, (char *)a72);
  sub_10005CD2C((uint64_t)&STACK[0x208], (char *)STACK[0x210]);

  _Unwind_Resume(a1);
}

uint64_t sub_10119BF54(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

void sub_10119BFB0()
{
}

void *sub_10119BFD8@<X0>(int a1@<W0>, char a2@<W1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  uint64_t result = operator new(0x28uLL);
  result[1] = 0;
  result[2] = 0;
  if (a1 == 2)
  {
    void *result = off_101A99148;
    uint64_t v7 = (char *)(result + 3);
    *((unsigned char *)result + 32) = a2;
    BOOL v8 = off_101A990B0;
  }
  else
  {
    void *result = off_101A99198;
    uint64_t v7 = (char *)(result + 3);
    *((unsigned char *)result + 32) = a2;
    BOOL v8 = off_101A991E8;
  }
  result[3] = v8;
  *a3 = v7;
  a3[1] = result;
  return result;
}

void sub_10119C0A8()
{
}

const char *sub_10119C0BC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable5GSwitchSupport";
  }
  else {
    return "MaxDataRateManager::Enable5GSwitchSupport_2";
  }
}

const char *sub_10119C0DC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "EnableLTESwitchSupport";
  }
  else {
    return "MaxDataRateManager::EnableLTESwitchSupport_2";
  }
}

const char *sub_10119C0FC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable3GSwitchSupport";
  }
  else {
    return "MaxDataRateManager::Enable3GSwitchSupport_2";
  }
}

const char *sub_10119C11C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable5G";
  }
  else {
    return "MaxDataRateManager::Enable5G_2";
  }
}

const char *sub_10119C13C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "EnableLTE";
  }
  else {
    return "MaxDataRateManager::EnableLTE_2";
  }
}

const char *sub_10119C15C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable3G";
  }
  else {
    return "MaxDataRateManager::Enable3G_2";
  }
}

const char *sub_10119C17C()
{
  return "EnableLTEAfterUpgrade_2";
}

void sub_10119C188(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A99148;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10119C1A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A99148;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10119C204(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A99198;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10119C224(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A99198;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10119C284()
{
}

const char *sub_10119C298(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable5GSwitchSupport";
  }
  else {
    return "MaxDataRateManager::Enable5GSwitchSupport";
  }
}

const char *sub_10119C2B8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "EnableLTESwitchSupport";
  }
  else {
    return "MaxDataRateManager::EnableLTESwitchSupport";
  }
}

const char *sub_10119C2D8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable3GSwitchSupport";
  }
  else {
    return "MaxDataRateManager::Enable3GSwitchSupport";
  }
}

const char *sub_10119C2F8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable5G";
  }
  else {
    return "MaxDataRateManager::Enable5G";
  }
}

const char *sub_10119C318(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "EnableLTE";
  }
  else {
    return "MaxDataRateManager::EnableLTE";
  }
}

const char *sub_10119C338(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return "Enable3G";
  }
  else {
    return "MaxDataRateManager::Enable3G";
  }
}

const char *sub_10119C358()
{
  return "EnableLTEAfterUpgrade";
}

void sub_10119C364(void *a1, uint64_t a2, NSObject **a3)
{
  int v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "DATA.nwpolicySession");
  sub_10119C468(v6, a3, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *a1 = &off_101A99270;
  uint64_t v7 = *(void *)(a2 + 8);
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10119C4F4();
}

void sub_10119C428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (v13) {
    sub_10004D2C8(v13);
  }
  DataConnectionAgentPolicySessionInterface::~DataConnectionAgentPolicySessionInterface((DataConnectionAgentPolicySessionInterface *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v11 + 40));
  sub_100087E88(v12);
  _Unwind_Resume(a1);
}

void *sub_10119C468(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_10119C4D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_10119C4F4()
{
}

void sub_10119C5A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_10119C5DC()
{
}

void sub_10119C690(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

DataConnectionAgentPolicySessionInterface *sub_10119C6C4(DataConnectionAgentPolicySessionInterface *this)
{
  *(void *)this = &off_101A99270;
  int v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2) {
    sub_10004D2C8(v2);
  }
  DataConnectionAgentPolicySessionInterface::~DataConnectionAgentPolicySessionInterface(this);
  ctu::OsLogLogger::~OsLogLogger((DataConnectionAgentPolicySessionInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

void sub_10119C730(DataConnectionAgentPolicySessionInterface *a1)
{
  sub_10119C6C4(a1);

  operator delete();
}

uint64_t sub_10119C768@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 56);
  *a2 = *(void *)(result + 48);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_10119C784(void *a1, void *a2, NSObject **a3)
{
  int v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "DATA.nwpolicySession");
  sub_10119C84C(v6, a3, &v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *a1 = off_101A99298;
  a1[6] = *a2;
  uint64_t v7 = a2[1];
  a1[7] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  a1[8] = 0;
  return a1;
}

void sub_10119C838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10119C84C(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_10119C8B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10119C8D8(uint64_t a1)
{
  *(void *)a1 = off_101A99298;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  DataConnectionAgentPolicySessionPrivateInterface::~DataConnectionAgentPolicySessionPrivateInterface((DataConnectionAgentPolicySessionPrivateInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10119C94C(uint64_t a1)
{
  sub_10119C8D8(a1);

  operator delete();
}

id sub_10119C984(uint64_t a1)
{
  if (!*(void *)(a1 + 64))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I initializing common CCNEPolicySession...", buf, 2u);
    }
    size_t v3 = objc_alloc_init(CCNEPolicySession);
    int v4 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = v3;

    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)OsLogContext v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I common CCNEPolicySession initialized", v8, 2u);
    }
  }
  int v6 = *(void **)(a1 + 64);

  return v6;
}

void sub_10119CA58(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10119CB24(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10119CBFC);
  __cxa_rethrow();
}

void sub_10119CB4C(_Unwind_Exception *a1)
{
}

void sub_10119CB64(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10119CB9C(uint64_t a1)
{
}

uint64_t sub_10119CBB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10119CBFC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10119CC28(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10119CCF4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10119CDCC);
  __cxa_rethrow();
}

void sub_10119CD1C(_Unwind_Exception *a1)
{
}

void sub_10119CD34(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10119CD6C(uint64_t a1)
{
}

uint64_t sub_10119CD88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10119CDCC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_10119CDF8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *a2;
  *a1 = *a2;
  int v4 = (std::__shared_weak_count *)a2[1];
  a1[1] = (uint64_t)v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *a1;
    int v4 = (std::__shared_weak_count *)a1[1];
  }
  a1[3] = 0;
  a1[2] = (uint64_t)(a1 + 3);
  a1[6] = 0;
  a1[4] = 0;
  a1[5] = (uint64_t)(a1 + 6);
  uint64_t v33 = (uint64_t **)(a1 + 5);
  a1[7] = 0;
  a1[9] = 0;
  a1[8] = (uint64_t)(a1 + 9);
  std::string::size_type v34 = (uint64_t **)(a1 + 8);
  a1[10] = 0;
  *((_DWORD *)a1 + 22) = 3;
  a1[12] = 160;
  uint64_t v36 = v3;
  id v37 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v37) {
    sub_10004D2C8(v37);
  }
  int v6 = v38;
  uint64_t v5 = v39;
  if (v38 != v39)
  {
    uint64_t v7 = v40;
    while ((v40(*v6) & 1) == 0)
    {
      if (++v6 == v39)
      {
        int v6 = v39;
        break;
      }
    }
    char v32 = v39;
    while (v6 != v32)
    {
      int v35 = 0;
      int v35 = *v6;
      std::string::size_type v41 = &v35;
      *((_DWORD *)sub_10030B04C(v34, &v35, (uint64_t)&unk_10144E20E, (unsigned int **)&v41) + 8) = 0;
      std::string::size_type v41 = &v35;
      OsLogContext v8 = sub_10119E608(v33, &v35, (uint64_t)&unk_10144E20E, &v41);
      OsLogContext v9 = v8;
      unint64_t v10 = (unint64_t)v8[9];
      uint64_t v11 = v8[6];
      uint64_t v12 = v8[7];
      int v13 = (char *)&v11[v10 / 0xAA];
      if (v12 == v11)
      {
        unint64_t v14 = 0;
        unint64_t v18 = 0;
        int v16 = v8 + 10;
        std::string::size_type v15 = v8[10];
        long long v17 = (char *)&v11[((unint64_t)v15 + v10) / 0xAA];
      }
      else
      {
        unint64_t v14 = *(void *)v13 + 24 * (v10 % 0xAA);
        int v16 = v8 + 10;
        std::string::size_type v15 = v8[10];
        long long v17 = (char *)&v11[((unint64_t)v15 + v10) / 0xAA];
        unint64_t v18 = *(void *)v17 + 24 * (((unint64_t)v15 + v10) % 0xAA);
      }
      if (v14 != v18)
      {
        uint64_t v19 = 170 * ((v17 - v13) >> 3) - 0x5555555555555555 * ((uint64_t)(v18 - *(void *)v17) >> 3);
        uint64_t v20 = *(void *)v13;
        uint64_t v21 = (uint64_t)(v14 - *(void *)v13) >> 3;
        uint64_t v22 = v19 + 0x5555555555555555 * v21;
        if (v22 >= 1)
        {
          uint64_t v23 = v20 + 24 * (v10 % 0xAA);
          if (v12 == v11) {
            uint64_t v23 = 0;
          }
          if (v14 == v23) {
            uint64_t v24 = 0;
          }
          else {
            uint64_t v24 = 0xAAAAAAAAAAAAAAABLL * v21 + 0x5555555555555555 * ((v23 - v20) >> 3);
          }
          std::string::size_type v41 = (int *)v13;
          uint64_t v42 = v23;
          sub_10119ECB0(&v41, v24);
          uint64_t v25 = v42;
          if (v42 != v18)
          {
            id v26 = v41;
            do
            {
              if (*(char *)(v25 + 23) < 0) {
                operator delete(*(void **)v25);
              }
              v25 += 24;
              if (v25 - *(void *)v26 == 4080)
              {
                uint64_t v27 = *((void *)v26 + 1);
                v26 += 2;
                uint64_t v25 = v27;
              }
            }
            while (v25 != v18);
            std::string::size_type v15 = *v16;
          }
          uint64_t v28 = v9 + 5;
          *int v16 = (uint64_t *)((char *)v15 - v22);
          uint64_t v2 = a1;
          while ((sub_100BEF1F4(v28, 1) & 1) != 0)
            ;
        }
      }
      xpc_object_t v29 = v6 + 1;
      int v6 = v5;
      if (v29 != v5)
      {
        int v6 = v29;
        while ((v7(*v6) & 1) == 0)
        {
          if (++v6 == v5)
          {
            int v6 = v5;
            break;
          }
        }
      }
    }
  }
  return v2;
}

void sub_10119D148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_1000346F8(a13, *(void **)(a10 + 72));
  sub_100BEEC6C(a12, *(void **)(a10 + 48));
  sub_1000886C0(a9, *(char **)(a10 + 24));
  long long v17 = *(std::__shared_weak_count **)(a10 + 8);
  if (v17) {
    sub_10004D2C8(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10119D1A8(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t result = a1 + 72;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      int v6 = *(_DWORD *)(v3 + 28);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        OsLogContext v8 = (uint64_t *)v3;
      }
      else {
        OsLogContext v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != result && *(_DWORD *)(v5 + 28) <= a2) {
      ++*(_DWORD *)(v5 + 32);
    }
  }
  return result;
}

uint64_t sub_10119D1F4(uint64_t a1, int a2)
{
  int v10 = a2;
  uint64_t v2 = a1 + 72;
  uint64_t v3 = *(void *)(a1 + 72);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = a1 + 64;
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 28);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      OsLogContext v8 = (uint64_t *)v3;
    }
    else {
      OsLogContext v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 != v2 && *(_DWORD *)(v5 + 28) <= a2) {
    return *(unsigned int *)sub_10118358C(v4, &v10);
  }
  else {
    return 0;
  }
}

std::string *sub_10119D26C(uint64_t a1, unsigned int a2, const std::string *a3)
{
  unsigned int v6 = a2;
  BOOL v7 = &v6;
  uint64_t v4 = sub_10119ED4C((uint64_t **)(a1 + 16), &v6, (uint64_t)&unk_10144E20E, &v7);
  return std::string::operator=((std::string *)(v4 + 5), a3);
}

uint64_t *sub_10119D2C8@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t result = (uint64_t *)(a1 + 24);
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  BOOL v7 = (uint64_t **)(result - 1);
  uint64_t v8 = (uint64_t)result;
  do
  {
    unsigned int v9 = *(_DWORD *)(v5 + 32);
    BOOL v10 = v9 >= a2;
    if (v9 >= a2) {
      uint64_t v11 = (uint64_t *)v5;
    }
    else {
      uint64_t v11 = (uint64_t *)(v5 + 8);
    }
    if (v10) {
      uint64_t v8 = v5;
    }
    uint64_t v5 = *v11;
  }
  while (*v11);
  if ((uint64_t *)v8 != result && *(_DWORD *)(v8 + 32) <= a2)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    if (*(char *)(v8 + 63) < 0)
    {
      sub_10004FC84((unsigned char *)a3, *(void **)(v8 + 40), *(void *)(v8 + 48));
    }
    else
    {
      long long v12 = *(_OWORD *)(v8 + 40);
      *(void *)(a3 + 16) = *(void *)(v8 + 56);
      *(_OWORD *)a3 = v12;
    }
    return sub_1003DE770(v7, v8);
  }
  else
  {
LABEL_12:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  return result;
}

void sub_10119D37C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10119D398(uint64_t a1, unsigned __int8 **a2, int a3)
{
  int v65 = a3;
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v3 = a1 + 48;
  uint64_t v4 = v5;
  if (v5)
  {
    BOOL v7 = (uint64_t **)(v3 - 8);
    uint64_t v8 = v3;
    do
    {
      int v9 = *(_DWORD *)(v4 + 32);
      BOOL v10 = v9 < a3;
      if (v9 >= a3) {
        uint64_t v11 = (uint64_t *)v4;
      }
      else {
        uint64_t v11 = (uint64_t *)(v4 + 8);
      }
      if (!v10) {
        uint64_t v8 = v4;
      }
      uint64_t v4 = *v11;
    }
    while (*v11);
    if (v8 != v3 && *(_DWORD *)(v8 + 32) <= a3)
    {
      *(void *)&long long v66 = &v65;
      int v13 = sub_10119E608((uint64_t **)(v3 - 8), &v65, (uint64_t)&unk_10144E20E, (_DWORD **)&v66);
      unint64_t v14 = (unint64_t)v13[9];
      std::string::size_type v15 = v13[6];
      int v16 = &v15[v14 / 0xAA];
      if (v13[7] == v15) {
        unint64_t v17 = 0;
      }
      else {
        unint64_t v17 = *v16 + 24 * (v14 % 0xAA);
      }
      while (1)
      {
        *(void *)&long long v66 = &v65;
        unint64_t v18 = sub_10119E608(v7, &v65, (uint64_t)&unk_10144E20E, (_DWORD **)&v66);
        uint64_t v19 = v18[6];
        if (v18[7] == v19)
        {
          unint64_t v21 = 0;
        }
        else
        {
          unint64_t v20 = (unint64_t)v18[9] + (void)v18[10];
          unint64_t v21 = v19[v20 / 0xAA] + 24 * (v20 % 0xAA);
        }
        if (v17 == v21) {
          break;
        }
        uint64_t v22 = *(unsigned __int8 *)(v17 + 23);
        if ((v22 & 0x80u) == 0) {
          uint64_t v23 = (unsigned __int8 *)*(unsigned __int8 *)(v17 + 23);
        }
        else {
          uint64_t v23 = *(unsigned __int8 **)(v17 + 8);
        }
        uint64_t v24 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
        int v25 = (char)v24;
        if ((char)v24 < 0) {
          uint64_t v24 = a2[1];
        }
        if (v23 == v24)
        {
          if (v25 >= 0) {
            id v26 = (unsigned __int8 *)a2;
          }
          else {
            id v26 = *a2;
          }
          if ((v22 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v17, v26, *(void *)(v17 + 8)))
            {
LABEL_38:
              *(void *)&long long v66 = &v65;
              xpc_object_t v29 = sub_10119E608(v7, &v65, (uint64_t)&unk_10144E20E, (_DWORD **)&v66);
              unint64_t v30 = (unint64_t)v29[9];
              int v31 = v29[6];
              char v32 = v29[7];
              uint64_t v33 = &v31[v30 / 0xAA];
              if (v32 == v31) {
                unint64_t v34 = 0;
              }
              else {
                unint64_t v34 = *v33 + 24 * (v30 % 0xAA);
              }
              if (v17 == v34) {
                unint64_t v35 = 0;
              }
              else {
                unint64_t v35 = 170 * (v16 - v33)
              }
                    - 0x5555555555555555 * ((uint64_t)(v17 - *v16) >> 3)
                    + 0x5555555555555555 * ((uint64_t)(v34 - *v33) >> 3);
              *(void *)&long long v66 = &v31[v30 / 0xAA];
              *((void *)&v66 + 1) = v34;
              sub_10119ECB0(&v66, v35);
              long long v36 = v66;
              id v37 = v29[10];
              uint64_t v38 = *(void *)v66;
              uint64_t v39 = *((void *)&v66 + 1) - *(void *)v66;
              unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * (v39 >> 3);
              if (v35 <= ((unint64_t)v37 - 1) >> 1)
              {
                if (v39 < -23)
                {
                  unint64_t v45 = (void *)(v66 - 8 * ((168 - v40) / 0xAA));
                  uint64_t v46 = *v45 + 24 * (170 * ((168 - v40) / 0xAA) - (168 - v40)) + 4056;
                }
                else
                {
                  unint64_t v45 = (void *)(v66 + 8 * ((v40 + 1) / 0xAA));
                  uint64_t v46 = *v45 + 24 * ((v40 + 1) % 0xAA);
                }
                if (v33 == (uint64_t *)v66)
                {
                  uint64_t v55 = v34;
                  uint64_t v54 = *((void *)&v66 + 1);
                }
                else
                {
                  long long v66 = 0uLL;
                  uint64_t v67 = 0;
                  sub_10119EE14((uint64_t)&v66, v38, *((uint64_t *)&v36 + 1), v45, v46);
                  unint64_t v45 = (void *)*((void *)&v66 + 1);
                  uint64_t v46 = v67;
                  long long v52 = (uint64_t *)(v36 - 8);
                  while (v52 != v33)
                  {
                    uint64_t v53 = *v52--;
                    long long v66 = 0uLL;
                    uint64_t v67 = 0;
                    sub_10119EE14((uint64_t)&v66, v53, v53 + 4080, v45, v46);
                    unint64_t v45 = (void *)*((void *)&v66 + 1);
                    uint64_t v46 = v67;
                  }
                  uint64_t v54 = *v33 + 4080;
                  uint64_t v55 = v34;
                }
                sub_10119EE14((uint64_t)&v66, v55, v54, v45, v46);
                if (*(char *)(v34 + 23) < 0) {
                  operator delete(*(void **)v34);
                }
                *(int64x2_t *)(v29 + 9) = vaddq_s64(*(int64x2_t *)(v29 + 9), (int64x2_t)xmmword_10144F900);
                sub_100BEF194((uint64_t)(v29 + 5), 1);
              }
              else
              {
                if (v39 < -23)
                {
                  unint64_t v47 = 168 - v40;
                  unint64_t v48 = 168 - v40;
                  uint64_t v42 = (long long **)(v66 - 8 * ((168 - v40) / 0xAA));
                  std::string::size_type v43 = *v42;
                  id v44 = (long long *)((char *)*v42 + 24 * (170 * (v48 / 0xAA) - v47) + 4056);
                }
                else
                {
                  unint64_t v41 = v40 + 1;
                  uint64_t v42 = (long long **)(v66 + 8 * ((v40 + 1) / 0xAA));
                  std::string::size_type v43 = *v42;
                  id v44 = (long long *)((char *)*v42 + 24 * (v41 % 0xAA));
                }
                unint64_t v49 = (unint64_t)v37 + v30;
                std::string::size_type v50 = (long long **)&v31[v49 / 0xAA];
                if (v32 == v31) {
                  unint64_t v51 = 0;
                }
                else {
                  unint64_t v51 = (unint64_t)*v50 + 24 * (v49 % 0xAA);
                }
                if (v42 == v50)
                {
                  long long v66 = 0uLL;
                  uint64_t v67 = 0;
                  uint64_t v60 = (long long *)v51;
                  uint64_t v57 = *((void *)&v36 + 1);
                  long long v56 = (uint64_t *)v36;
                }
                else
                {
                  long long v66 = 0uLL;
                  uint64_t v67 = 0;
                  sub_10119EEF0(&v66, v44, v43 + 255, (uint64_t *)v36, *((uint64_t *)&v36 + 1));
                  long long v56 = (uint64_t *)*((void *)&v66 + 1);
                  uint64_t v57 = v67;
                  unsigned int v58 = v42 + 1;
                  while (v58 != v50)
                  {
                    v59 = *v58++;
                    long long v66 = 0uLL;
                    uint64_t v67 = 0;
                    sub_10119EEF0(&v66, v59, v59 + 255, v56, v57);
                    long long v56 = (uint64_t *)*((void *)&v66 + 1);
                    uint64_t v57 = v67;
                  }
                  id v44 = *v50;
                  long long v66 = 0uLL;
                  uint64_t v67 = 0;
                  uint64_t v60 = (long long *)v51;
                }
                sub_10119EEF0(&v66, v44, v60, v56, v57);
                if (*(char *)(v67 + 23) < 0) {
                  operator delete(*(void **)v67);
                }
                v29[10] = (uint64_t *)((char *)v29[10] - 1);
                sub_100BEF1F4(v29 + 5, 1);
              }
              unint64_t v61 = (unint64_t)v29[9];
              uint32_t v62 = v29[6];
              std::string::size_type v63 = &v62[v61 / 0xAA];
              if (v29[7] == v62) {
                unint64_t v64 = 0;
              }
              else {
                unint64_t v64 = *v63 + 24 * (v61 % 0xAA);
              }
              *(void *)&long long v66 = v63;
              *((void *)&v66 + 1) = v64;
              sub_10119ECB0(&v66, v35);
              return 1;
            }
          }
          else
          {
            if (!*(unsigned char *)(v17 + 23)) {
              goto LABEL_38;
            }
            uint64_t v27 = 0;
            while (*(unsigned __int8 *)(v17 + v27) == v26[v27])
            {
              if (v22 == ++v27) {
                goto LABEL_38;
              }
            }
          }
        }
        v17 += 24;
        if (v17 - *v16 == 4080)
        {
          unint64_t v28 = v16[1];
          ++v16;
          unint64_t v17 = v28;
        }
      }
    }
  }
  return 0;
}

void sub_10119D940(uint64_t a1@<X0>, Registry **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  ctu::cf::assign();
  long long v79 = 0uLL;
  uint64_t v80 = 0;
  ctu::cf::assign();
  long long v77 = 0uLL;
  uint64_t v78 = 0;
  ctu::cf::assign();
  long long v75 = 0uLL;
  uint64_t v76 = 0;
  long long v53 = 0uLL;
  *(void *)&long long v54 = 0;
  ctu::cf::assign();
  long long v73 = 0uLL;
  uint64_t v74 = 0;
  BOOL v10 = *a2;
  long long v71 = 0uLL;
  uint64_t v72 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(0, v10);
  long long v12 = ServiceMap;
  if (v13 < 0)
  {
    unint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v53 = v13;
  unint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v53);
  if (v17)
  {
    uint64_t v19 = v17[3];
    unint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  unint64_t v18 = 0;
  char v20 = 1;
LABEL_9:
  (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, uint64_t))(*(void *)v19 + 96))(&v70, v19, a4, 1, @"PhoneNumberRegistrationMessagePrefix", 0, 1);
  long long v53 = 0uLL;
  *(void *)&long long v54 = 0;
  ctu::cf::assign();
  long long v71 = v53;
  uint64_t v72 = v54;
  sub_1000577C4((const void **)&v70.__r_.__value_.__l.__data_);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  memset(&v70, 0, sizeof(v70));
  if (*(char *)(a3 + 23) >= 0) {
    unint64_t v21 = (int *)a3;
  }
  else {
    unint64_t v21 = *(int **)a3;
  }
  int v22 = *v21;
  LODWORD(v53) = v22 * time(0);
  int v23 = rand_r((unsigned int *)&v53);
  std::to_string(&v70, v23);
  sub_10119E00C(a1, (long long *)&v70, a4);
  uint64_t v69 = 0;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  *(_OWORD *)__p = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  sub_10004DE24((uint64_t)&v53);
  if (v72 >= 0) {
    uint64_t v24 = &v71;
  }
  else {
    uint64_t v24 = (long long *)v71;
  }
  if (v72 >= 0) {
    uint64_t v25 = HIBYTE(v72);
  }
  else {
    uint64_t v25 = *((void *)&v71 + 1);
  }
  id v26 = sub_10004B96C(&v53, (uint64_t)v24, v25);
  if (v80 >= 0) {
    uint64_t v27 = &v79;
  }
  else {
    uint64_t v27 = (long long *)v79;
  }
  if (v80 >= 0) {
    uint64_t v28 = HIBYTE(v80);
  }
  else {
    uint64_t v28 = *((void *)&v79 + 1);
  }
  xpc_object_t v29 = sub_10004B96C(v26, (uint64_t)v27, v28);
  unint64_t v30 = sub_10004B96C(v29, (uint64_t)"?", 1);
  if (v76 >= 0) {
    int v31 = &v75;
  }
  else {
    int v31 = (long long *)v75;
  }
  if (v76 >= 0) {
    uint64_t v32 = HIBYTE(v76);
  }
  else {
    uint64_t v32 = *((void *)&v75 + 1);
  }
  uint64_t v33 = sub_10004B96C(v30, (uint64_t)v31, v32);
  sub_10004B96C(v33, (uint64_t)"=", 1);
  unint64_t v34 = (void *)std::ostream::operator<<();
  unint64_t v35 = sub_10004B96C(v34, (uint64_t)";", 1);
  if (v78 >= 0) {
    long long v36 = &v77;
  }
  else {
    long long v36 = (long long *)v77;
  }
  if (v78 >= 0) {
    uint64_t v37 = HIBYTE(v78);
  }
  else {
    uint64_t v37 = *((void *)&v77 + 1);
  }
  uint64_t v38 = sub_10004B96C(v35, (uint64_t)v36, v37);
  uint64_t v39 = sub_10004B96C(v38, (uint64_t)"=", 1);
  int v40 = *(char *)(a3 + 23);
  if (v40 >= 0) {
    uint64_t v41 = a3;
  }
  else {
    uint64_t v41 = *(void *)a3;
  }
  if (v40 >= 0) {
    uint64_t v42 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v42 = *(void *)(a3 + 8);
  }
  std::string::size_type v43 = sub_10004B96C(v39, v41, v42);
  id v44 = sub_10004B96C(v43, (uint64_t)";", 1);
  if (v74 >= 0) {
    unint64_t v45 = &v73;
  }
  else {
    unint64_t v45 = (long long *)v73;
  }
  if (v74 >= 0) {
    uint64_t v46 = HIBYTE(v74);
  }
  else {
    uint64_t v46 = *((void *)&v73 + 1);
  }
  unint64_t v47 = sub_10004B96C(v44, (uint64_t)v45, v46);
  unint64_t v48 = sub_10004B96C(v47, (uint64_t)"=", 1);
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v49 = &v70;
  }
  else {
    unint64_t v49 = (std::string *)v70.__r_.__value_.__r.__words[0];
  }
  if ((v70.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v70.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v70.__r_.__value_.__l.__size_;
  }
  sub_10004B96C(v48, (uint64_t)v49, size);
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  sub_10004BC98((uint64_t)&v53 + 8, (void *)a5);
  std::string::size_type v51 = *(unsigned __int8 *)(a5 + 23);
  if ((v51 & 0x80u) != 0) {
    std::string::size_type v51 = *(void *)(a5 + 8);
  }
  std::string::size_type v52 = *(void *)(a1 + 96);
  if (v51 > v52) {
    std::string::resize((std::string *)a5, v52, 0);
  }
  if (SHIBYTE(v58) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v70.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)v71);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete((void *)v73);
  }
  if (SHIBYTE(v76) < 0) {
    operator delete((void *)v75);
  }
  if (SHIBYTE(v78) < 0) {
    operator delete((void *)v77);
  }
  if (SHIBYTE(v80) < 0) {
    operator delete((void *)v79);
  }
}

void sub_10119DECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (*(char *)(v50 + 23) < 0) {
    operator delete(*(void **)v50);
  }
  sub_1000C937C((uint64_t)&a9);
  if (a50 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v51 - 217) < 0) {
    operator delete(*(void **)(v51 - 240));
  }
  if (*(char *)(v51 - 185) < 0) {
    operator delete(*(void **)(v51 - 208));
  }
  if (*(char *)(v51 - 153) < 0) {
    operator delete(*(void **)(v51 - 176));
  }
  if (*(char *)(v51 - 121) < 0) {
    operator delete(*(void **)(v51 - 144));
  }
  if (*(char *)(v51 - 89) < 0) {
    operator delete(*(void **)(v51 - 112));
  }
  _Unwind_Resume(a1);
}

void *sub_10119E00C(uint64_t a1, long long *a2, int a3)
{
  int v73 = a3;
  uint64_t v4 = (uint64_t **)(a1 + 40);
  *(void *)&long long v75 = &v73;
  if ((unint64_t)sub_10119E608((uint64_t **)(a1 + 40), &v73, (uint64_t)&unk_10144E20E, (_DWORD **)&v75)[10] >= 5)
  {
    *(void *)&long long v75 = &v73;
    uint64_t v5 = sub_10119E608(v4, &v73, (uint64_t)&unk_10144E20E, (_DWORD **)&v75);
    unint64_t v6 = (unint64_t)v5[9];
    unint64_t v7 = v5[6][v6 / 0xAA] + 24 * (v6 % 0xAA);
    if (*(char *)(v7 + 23) < 0)
    {
      operator delete(*(void **)v7);
      unint64_t v6 = (unint64_t)v5[9];
    }
    uint64_t v8 = (uint64_t)v5[10] - 1;
    v5[9] = (uint64_t *)(v6 + 1);
    v5[10] = (uint64_t *)v8;
    sub_100BEF194((uint64_t)(v5 + 5), 1);
  }
  *(void *)&long long v75 = &v73;
  int v9 = sub_10119E608(v4, &v73, (uint64_t)&unk_10144E20E, (_DWORD **)&v75);
  BOOL v10 = v9;
  uint64_t v11 = v9[6];
  long long v12 = (char *)v9[7];
  unint64_t v13 = (v12 - (char *)v11) >> 3;
  if (v12 == (char *)v11) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = 170 * v13 - 1;
  }
  unint64_t v15 = (unint64_t)v9[9];
  if ((uint64_t *)v14 == (uint64_t *)((char *)v9[10] + v15))
  {
    unsigned int v16 = v9 + 5;
    BOOL v17 = v15 >= 0xAA;
    unint64_t v18 = v15 - 170;
    if (v17)
    {
      uint64_t v19 = (uint64_t)(v9 + 8);
      char v20 = (char *)v10[8];
      v10[9] = (uint64_t *)v18;
      uint64_t v23 = *v11;
      unint64_t v21 = (char *)(v11 + 1);
      uint64_t v22 = v23;
      v10[6] = (uint64_t *)v21;
      if (v12 != v20) {
        goto LABEL_40;
      }
      uint64_t v24 = (uint64_t)&v21[-*v16];
      if ((unint64_t)v21 > *v16)
      {
        uint64_t v25 = v24 >> 3;
        BOOL v26 = v24 >> 3 < -1;
        uint64_t v27 = (v24 >> 3) + 2;
        if (v26) {
          uint64_t v28 = v27;
        }
        else {
          uint64_t v28 = v25 + 1;
        }
        uint64_t v29 = -(v28 >> 1);
        uint64_t v30 = v28 >> 1;
        int v31 = &v21[-8 * v30];
        int64_t v32 = v12 - v21;
        if (v12 != v21)
        {
          memmove(&v21[-8 * v30], v21, v12 - v21);
          long long v12 = (char *)v10[6];
        }
        uint64_t v33 = &v12[8 * v29];
        long long v12 = &v31[v32];
        goto LABEL_19;
      }
      if (v12 == (char *)*v16) {
        unint64_t v41 = 1;
      }
      else {
        unint64_t v41 = (uint64_t)&v12[-*v16] >> 2;
      }
      uint64_t v42 = (uint64_t *)sub_10004EF74(v19, v41);
      std::string::size_type v43 = (char *)&v42[v41 >> 2];
      unint64_t v45 = (char *)&v42[v44];
      uint64_t v46 = (char *)v10[6];
      long long v12 = v43;
      uint64_t v47 = (char *)v10[7] - v46;
      if (v47)
      {
        long long v12 = &v43[v47 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v48 = 8 * (v47 >> 3);
        unint64_t v49 = (char *)&v42[v41 >> 2];
        do
        {
          uint64_t v50 = *(void *)v46;
          v46 += 8;
          *(void *)unint64_t v49 = v50;
          v49 += 8;
          v48 -= 8;
        }
        while (v48);
      }
    }
    else
    {
      unint64_t v34 = v9[8];
      unint64_t v35 = v9[5];
      if (v13 >= v34 - v35)
      {
        if (v34 == v35) {
          unint64_t v36 = 1;
        }
        else {
          unint64_t v36 = ((char *)v34 - (char *)v35) >> 2;
        }
        long long v77 = v9 + 8;
        *(void *)&long long v75 = sub_10004EF74((uint64_t)(v9 + 8), v36);
        *((void *)&v75 + 1) = v75 + 8 * v13;
        *(void *)&long long v76 = *((void *)&v75 + 1);
        *((void *)&v76 + 1) = v75 + 8 * v37;
        uint64_t v74 = operator new(0xFF0uLL);
        sub_100097E4C(&v75, &v74);
        for (uint64_t i = v10[7]; i != v10[6]; sub_100097F64((uint64_t)&v75, i))
          --i;
        uint64_t v39 = v10[5];
        long long v40 = v76;
        *(_OWORD *)(v10 + 5) = v75;
        *(_OWORD *)(v10 + 7) = v40;
        if (v39) {
          operator delete(v39);
        }
        goto LABEL_41;
      }
      if (v34 != (uint64_t *)v12)
      {
        *(void *)&long long v75 = operator new(0xFF0uLL);
        sub_100097C14(v10 + 5, &v75);
LABEL_41:
        uint64_t v11 = v10[6];
        long long v12 = (char *)v10[7];
        goto LABEL_42;
      }
      *(void *)&long long v75 = operator new(0xFF0uLL);
      sub_100097D2C((uint64_t)(v10 + 5), &v75);
      std::string::size_type v52 = v10[6];
      long long v12 = (char *)v10[7];
      uint64_t v54 = *v52;
      long long v53 = (char *)(v52 + 1);
      uint64_t v22 = v54;
      v10[6] = (uint64_t *)v53;
      if (v12 != (char *)v10[8])
      {
LABEL_40:
        *(void *)long long v12 = v22;
        ++v10[7];
        goto LABEL_41;
      }
      uint64_t v58 = (uint64_t)&v53[-*v16];
      if ((unint64_t)v53 > *v16)
      {
        uint64_t v59 = v58 >> 3;
        BOOL v26 = v58 >> 3 < -1;
        uint64_t v60 = (v58 >> 3) + 2;
        if (v26) {
          uint64_t v61 = v60;
        }
        else {
          uint64_t v61 = v59 + 1;
        }
        uint64_t v62 = -(v61 >> 1);
        uint64_t v63 = v61 >> 1;
        long long v64 = &v53[-8 * v63];
        int64_t v65 = v12 - v53;
        if (v12 != v53)
        {
          memmove(&v53[-8 * v63], v53, v12 - v53);
          long long v53 = (char *)v10[6];
        }
        long long v12 = &v64[v65];
        uint64_t v33 = &v53[8 * v62];
LABEL_19:
        v10[6] = (uint64_t *)v33;
        v10[7] = (uint64_t *)v12;
        goto LABEL_40;
      }
      if (v12 == (char *)*v16) {
        unint64_t v66 = 1;
      }
      else {
        unint64_t v66 = (uint64_t)&v12[-*v16] >> 2;
      }
      uint64_t v42 = (uint64_t *)sub_10004EF74((uint64_t)(v10 + 8), v66);
      std::string::size_type v43 = (char *)&v42[v66 >> 2];
      unint64_t v45 = (char *)&v42[v67];
      long long v68 = (char *)v10[6];
      long long v12 = v43;
      uint64_t v69 = (char *)v10[7] - v68;
      if (v69)
      {
        long long v12 = &v43[v69 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v70 = 8 * (v69 >> 3);
        long long v71 = (char *)&v42[v66 >> 2];
        do
        {
          uint64_t v72 = *(void *)v68;
          v68 += 8;
          *(void *)long long v71 = v72;
          v71 += 8;
          v70 -= 8;
        }
        while (v70);
      }
    }
    uint64_t v51 = v10[5];
    v10[5] = v42;
    v10[6] = (uint64_t *)v43;
    v10[7] = (uint64_t *)v12;
    v10[8] = (uint64_t *)v45;
    if (v51)
    {
      operator delete(v51);
      long long v12 = (char *)v10[7];
    }
    goto LABEL_40;
  }
LABEL_42:
  if (v12 == (char *)v11)
  {
    uint64_t result = 0;
  }
  else
  {
    unint64_t v55 = (unint64_t)v10[9] + (void)v10[10];
    uint64_t result = (void *)(v11[v55 / 0xAA] + 24 * (v55 % 0xAA));
  }
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v57 = *a2;
    result[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t result = v57;
  }
  v10[10] = (uint64_t *)((char *)v10[10] + 1);
  return result;
}

void sub_10119E454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  operator delete(v11);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10119E480@<X0>(uint64_t result@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  int v11 = a2;
  uint64_t v5 = result + 48;
  uint64_t v4 = *(void *)(result + 48);
  if (!v4) {
    goto LABEL_11;
  }
  result += 40;
  uint64_t v6 = v5;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v4;
    }
    else {
      int v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != v5 && *(_DWORD *)(v6 + 32) <= a2)
  {
    long long v12 = &v11;
    BOOL v10 = sub_10119E608((uint64_t **)result, &v11, (uint64_t)&unk_10144E20E, &v12);
    return sub_10119EFD0((uint64_t)a3, v10 + 5);
  }
  else
  {
LABEL_11:
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return result;
}

uint64_t sub_10119E52C(uint64_t a1, unsigned __int8 *a2)
{
  std::to_string(&v18, *(_DWORD *)(a1 + 88));
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v18.__r_.__value_.__l.__size_;
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (size == v4)
  {
    if (v5 >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = *(unsigned __int8 **)a2;
    }
    if ((*((unsigned char *)&v18.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      unsigned int v16 = (void *)v18.__r_.__value_.__r.__words[0];
      BOOL v15 = memcmp(v18.__r_.__value_.__l.__data_, v6, v18.__r_.__value_.__l.__size_) == 0;
      goto LABEL_23;
    }
    if (!*((unsigned char *)&v18.__r_.__value_.__s + 23)) {
      return 1;
    }
    uint64_t v7 = HIBYTE(v18.__r_.__value_.__r.__words[2]) - 1;
    BOOL v8 = &v18;
    do
    {
      int v10 = v8->__r_.__value_.__s.__data_[0];
      BOOL v8 = (std::string *)((char *)v8 + 1);
      int v9 = v10;
      int v12 = *v6++;
      int v11 = v12;
      BOOL v14 = v7-- != 0;
      BOOL v15 = v9 == v11;
    }
    while (v9 == v11 && v14);
  }
  else
  {
    BOOL v15 = 0;
  }
  if ((*((unsigned char *)&v18.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    unsigned int v16 = (void *)v18.__r_.__value_.__r.__words[0];
LABEL_23:
    operator delete(v16);
  }
  return v15;
}

uint64_t **sub_10119E608(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  BOOL v8 = a1 + 1;
  int v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        uint64_t v6 = *v9;
        BOOL v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        BOOL v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v14[2] = 1;
    int v12 = (char *)operator new(0x58uLL);
    v14[1] = v7;
    *((_DWORD *)v12 + 8) = **a4;
    *(_OWORD *)(v12 + 72) = 0u;
    *(_OWORD *)(v12 + 56) = 0u;
    *(_OWORD *)(v12 + 40) = 0u;
    sub_100046C38(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_10119E704((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

void sub_10119E704(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100BEF03C(v2 + 5);
    }
    operator delete(v2);
  }
}

void sub_10119E75C(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0xAA) {
    unint64_t v6 = v5 / 0xAA + 1;
  }
  else {
    unint64_t v6 = v5 / 0xAA;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0xAA) {
    unint64_t v8 = v7 / 0xAA;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0xAA)
  {
    for (a1[4] = v7 - 170 * v8; v8; --v8)
    {
      unsigned int v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      BOOL v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          uint64_t v29 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v28);
          int v31 = &v29[8 * (v28 >> 2)];
          int64_t v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            unint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)unint64_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          *(void *)&long long v85 = operator new(0xFF0uLL);
          sub_100097C14(a1, &v85);
          --v6;
          if (!--v9) {
            goto LABEL_73;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          *(void *)&long long v85 = operator new(0xFF0uLL);
          sub_100097D2C((uint64_t)a1, &v85);
          if (a1[2] - a1[1] == 8) {
            uint64_t v60 = 169;
          }
          else {
            uint64_t v60 = 170;
          }
          uint64_t v61 = v60 + a1[4];
          a1[4] = v61;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_73:
        uint64_t v61 = a1[4];
      }
      a1[4] = v61 - 170 * v8;
      if (v8)
      {
        uint64_t v62 = (char *)a1[2];
        do
        {
          uint64_t v63 = (void *)a1[1];
          uint64_t v66 = *v63;
          long long v64 = (char *)(v63 + 1);
          uint64_t v65 = v66;
          a1[1] = v64;
          if (v62 == (char *)a1[3])
          {
            uint64_t v67 = (uint64_t)&v64[-*a1];
            if ((unint64_t)v64 <= *a1)
            {
              if (v62 == (char *)*a1) {
                unint64_t v74 = 1;
              }
              else {
                unint64_t v74 = (uint64_t)&v62[-*a1] >> 2;
              }
              long long v75 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v74);
              long long v77 = &v75[8 * (v74 >> 2)];
              uint64_t v78 = (uint64_t *)a1[1];
              uint64_t v62 = v77;
              uint64_t v79 = a1[2] - (void)v78;
              if (v79)
              {
                uint64_t v62 = &v77[v79 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v80 = 8 * (v79 >> 3);
                v81 = &v75[8 * (v74 >> 2)];
                do
                {
                  uint64_t v82 = *v78++;
                  *(void *)v81 = v82;
                  v81 += 8;
                  v80 -= 8;
                }
                while (v80);
              }
              v83 = (char *)*a1;
              *a1 = v75;
              a1[1] = v77;
              a1[2] = v62;
              a1[3] = &v75[8 * v76];
              if (v83)
              {
                operator delete(v83);
                uint64_t v62 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v68 = v67 >> 3;
              BOOL v22 = v67 >> 3 < -1;
              uint64_t v69 = (v67 >> 3) + 2;
              if (v22) {
                uint64_t v70 = v69;
              }
              else {
                uint64_t v70 = v68 + 1;
              }
              long long v71 = &v64[-8 * (v70 >> 1)];
              int64_t v72 = v62 - v64;
              if (v62 != v64)
              {
                memmove(&v64[-8 * (v70 >> 1)], v64, v62 - v64);
                uint64_t v62 = (char *)a1[1];
              }
              int v73 = &v62[-8 * (v70 >> 1)];
              uint64_t v62 = &v71[v72];
              a1[1] = v73;
              a1[2] = &v71[v72];
            }
          }
          *(void *)uint64_t v62 = v65;
          uint64_t v62 = (char *)(a1[2] + 8);
          a1[2] = v62;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      v87 = a1 + 3;
      if (v13) {
        BOOL v15 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v13);
      }
      else {
        BOOL v15 = 0;
      }
      uint64_t v38 = -170 * v8;
      *(void *)&long long v85 = v15;
      *((void *)&v85 + 1) = &v15[8 * v14];
      *(void *)&long long v86 = *((void *)&v85 + 1);
      *((void *)&v86 + 1) = &v15[8 * v13];
      do
      {
        v84 = operator new(0xFF0uLL);
        sub_100097E4C(&v85, &v84);
        --v9;
      }
      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        long long v40 = (char *)v86;
        do
        {
          if (v40 == *((char **)&v86 + 1))
          {
            unint64_t v41 = (char *)*((void *)&v85 + 1);
            uint64_t v42 = (void *)v85;
            if (*((void *)&v85 + 1) <= (unint64_t)v85)
            {
              if (v40 == (char *)v85) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (uint64_t)&v40[-v85] >> 2;
              }
              unint64_t v49 = (char *)sub_10004EF74((uint64_t)v87, v48);
              uint64_t v52 = v40 - v41;
              BOOL v51 = v40 == v41;
              long long v40 = &v49[8 * (v48 >> 2)];
              if (!v51)
              {
                long long v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                uint64_t v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *(void *)v41;
                  v41 += 8;
                  *(void *)uint64_t v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              *(void *)&long long v85 = v49;
              *((void *)&v85 + 1) = &v49[8 * (v48 >> 2)];
              *(void *)&long long v86 = v40;
              *((void *)&v86 + 1) = &v49[8 * v50];
              if (v42) {
                operator delete(v42);
              }
            }
            else
            {
              uint64_t v43 = (uint64_t)(*((void *)&v85 + 1) - v85) >> 3;
              if (v43 >= -1) {
                uint64_t v44 = v43 + 1;
              }
              else {
                uint64_t v44 = v43 + 2;
              }
              uint64_t v45 = *((void *)&v85 + 1) - 8 * (v44 >> 1);
              uint64_t v46 = &v40[-*((void *)&v85 + 1)];
              if (v40 != *((char **)&v85 + 1))
              {
                memmove((void *)(*((void *)&v85 + 1) - 8 * (v44 >> 1)), *((const void **)&v85 + 1), (size_t)&v40[-*((void *)&v85 + 1)]);
                long long v40 = v41;
              }
              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              long long v40 = &v46[v45];
              *((void *)&v85 + 1) = v47;
              *(void *)&long long v86 = &v46[v45];
            }
          }
          *(void *)long long v40 = *v39;
          long long v40 = (char *)(v86 + 8);
          *(void *)&long long v86 = v86 + 8;
          uint64_t v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      for (j = (void *)a1[2]; j != (void *)a1[1]; sub_100097F64((uint64_t)&v85, j))
        --j;
      long long v57 = (char *)*a1;
      long long v58 = v86;
      *(_OWORD *)a1 = v85;
      *((_OWORD *)a1 + 1) = v58;
      a1[4] += v38;
      if (v57) {
        operator delete(v57);
      }
    }
  }
}

void sub_10119EC60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10119ECB0(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x5555555555555555 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 169 - v3;
      unint64_t v6 = &v2[-(v5 / 0xAA)];
      void *result = v6;
      unint64_t v4 = *v6 + 24 * (170 * (v5 / 0xAA) - v5) + 4056;
    }
    else
    {
      void *result = &v2[v3 / 0xAA];
      unint64_t v4 = v2[v3 / 0xAA] + 24 * (v3 % 0xAA);
    }
    result[1] = v4;
  }
  return result;
}

uint64_t **sub_10119ED4C(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 5) = 0;
    sub_100046C38(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_10119EE14(uint64_t result, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  unint64_t v5 = a4;
  unint64_t v7 = (void *)result;
  if (a2 == a3)
  {
    uint64_t v8 = a2;
  }
  else
  {
    uint64_t v8 = a3;
    uint64_t v9 = *a4;
    while (1)
    {
      int64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a5 - v9) >> 3);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3)) < v10) {
        int64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3);
      }
      uint64_t v11 = a3 - 24 * v10;
      uint64_t result = sub_1008611B4((uint64_t)&v15, v11, a3, a5);
      if (v11 == a2) {
        break;
      }
      uint64_t v13 = *--v5;
      uint64_t v9 = v13;
      a5 = v13 + 4080;
      a3 = v11;
    }
    a5 = v12;
    if (*v5 + 4080 == v12)
    {
      uint64_t v14 = v5[1];
      ++v5;
      a5 = v14;
    }
  }
  *unint64_t v7 = v8;
  v7[1] = v5;
  v7[2] = a5;
  return result;
}

long long *sub_10119EEF0(long long *result, long long *a2, long long *a3, uint64_t *a4, uint64_t a5)
{
  unint64_t v5 = a4;
  unint64_t v6 = a2;
  unint64_t v7 = result;
  if (a2 == a3)
  {
    uint64_t v8 = a2;
  }
  else
  {
    uint64_t v8 = a3;
    unint64_t v5 = a4 + 1;
    uint64_t v9 = *a4;
    while (1)
    {
      int64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v9 - a5 + 4080) >> 3);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v6) >> 3)) < v10) {
        int64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v6) >> 3);
      }
      uint64_t result = sub_1000D935C((uint64_t)&v13, v6, (long long *)((char *)v6 + 24 * v10), a5);
      if (result == v8) {
        break;
      }
      unint64_t v6 = result;
      uint64_t v12 = *v5++;
      uint64_t v9 = v12;
      a5 = v12;
    }
    a5 = v11;
    if (*(v5 - 1) + 4080 == v11) {
      a5 = *v5;
    }
    else {
      --v5;
    }
  }
  *(void *)unint64_t v7 = v8;
  *((void *)v7 + 1) = v5;
  *((void *)v7 + 2) = a5;
  return result;
}

uint64_t sub_10119EFD0(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  if (a2[2] == v4)
  {
    unint64_t v5 = 0;
    uint64_t v8 = 0;
    unint64_t v7 = (void *)(v4 + 8 * ((a2[5] + v3) / 0xAA));
  }
  else
  {
    unint64_t v5 = (long long *)(*(void *)(v4 + 8 * (v3 / 0xAA)) + 24 * (v3 % 0xAA));
    unint64_t v6 = a2[5] + v3;
    unint64_t v7 = (void *)(v4 + 8 * (v6 / 0xAA));
    uint64_t v8 = (long long *)(*v7 + 24 * (v6 % 0xAA));
  }
  sub_10119F098((void *)a1, (void *)(v4 + 8 * (v3 / 0xAA)), v5, v7, v8);
  return a1;
}

void sub_10119F084(_Unwind_Exception *a1)
{
  sub_10005EE1C(v1);
  _Unwind_Resume(a1);
}

void *sub_10119F098(void *a1, void *a2, long long *a3, void *a4, long long *a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = 170 * (a4 - a2)
  }
       - 0x5555555555555555 * (((uint64_t)a5 - *a4) >> 3)
       + 0x5555555555555555 * (((uint64_t)a3 - *a2) >> 3);
  return sub_10119F0E8(a1, a2, a3, v5);
}

void *sub_10119F0E8(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 170 * ((v9 - v8) >> 3) - 1;
  }
  uint64_t v11 = a1[5];
  unint64_t v12 = v11 + a1[4];
  unint64_t v13 = v10 - v12;
  if (a4 > v13)
  {
    sub_10119E75C(a1, a4 - v13);
    uint64_t v11 = a1[5];
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v12 = a1[4] + v11;
  }
  uint64_t v14 = (void *)(v8 + 8 * (v12 / 0xAA));
  if (v9 == v8) {
    unint64_t v15 = 0;
  }
  else {
    unint64_t v15 = *v14 + 24 * (v12 % 0xAA);
  }
  uint64_t v24 = (void *)(v8 + 8 * (v12 / 0xAA));
  unint64_t v25 = v15;
  uint64_t result = sub_10119ECB0(&v24, a4);
  uint64_t v17 = v25;
  if (v15 != v25)
  {
    uint64_t v18 = v24;
    do
    {
      if (v14 == v18) {
        uint64_t v19 = v17;
      }
      else {
        uint64_t v19 = *v14 + 4080;
      }
      if (v15 == v19)
      {
        uint64_t v19 = v15;
      }
      else
      {
        uint64_t v20 = 0;
        do
        {
          uint64_t result = (void *)(v15 + v20);
          if (*((char *)a3 + 23) < 0)
          {
            uint64_t result = sub_10004FC84(result, *(void **)a3, *((void *)a3 + 1));
          }
          else
          {
            long long v21 = *a3;
            result[2] = *((void *)a3 + 2);
            *(_OWORD *)uint64_t result = v21;
          }
          a3 = (long long *)((char *)a3 + 24);
          if ((long long *)((char *)a3 - *a2) == (long long *)4080)
          {
            BOOL v22 = (long long *)a2[1];
            ++a2;
            a3 = v22;
          }
          v20 += 24;
        }
        while (v15 + v20 != v19);
        uint64_t v11 = a1[5];
      }
      v11 -= 0x5555555555555555 * ((uint64_t)(v19 - v15) >> 3);
      a1[5] = v11;
      if (v14 == v18) {
        break;
      }
      unint64_t v23 = v14[1];
      ++v14;
      unint64_t v15 = v23;
    }
    while (v23 != v17);
  }
  return result;
}

void sub_10119F288(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) -= 0x5555555555555555 * (v2 >> 3);
  _Unwind_Resume(a1);
}

void sub_10119F2A4(uint64_t a1@<X0>, NSObject **a2@<X1>, char **a3@<X8>)
{
  unint64_t v6 = operator new(0xD8uLL);
  unint64_t v7 = v6;
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = off_101A99610;
  uint64_t v8 = (char *)(v6 + 3);
  uint64_t v10 = *(Registry **)a1;
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v6[3] = off_101A994D8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "ipcu");
  v7[4] = 0;
  v7[5] = 0;
  uint64_t v11 = *a2;
  v7[6] = *a2;
  if (v11) {
    dispatch_retain(v11);
  }
  v7[7] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v38, &buf);
  uint64_t v36 = (os_log_t *)(v7 + 8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v7 + 8), (const ctu::OsLogLogger *)&v38);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v38);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  unint64_t add_explicit = 850045863;
  v7[9] = 850045863;
  _OWORD v7[3] = off_101A99660;
  *((_OWORD *)v7 + 5) = 0u;
  *((_OWORD *)v7 + 6) = 0u;
  *((_OWORD *)v7 + 7) = 0u;
  v7[16] = 0;
  v7[17] = v10;
  v7[18] = v9;
  if (v9)
  {
    unint64_t add_explicit = atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v10 = (Registry *)v7[17];
  }
  *((_OWORD *)v7 + 11) = 0uLL;
  *((_DWORD *)v7 + 38) = 0;
  *((_DWORD *)v7 + 49) = 0;
  *((_OWORD *)v7 + 10) = 0uLL;
  *((unsigned char *)v7 + 192) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)add_explicit, v10);
  uint64_t v14 = ServiceMap;
  if (v15 < 0)
  {
    unsigned int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v17 = 5381;
    do
    {
      uint64_t v15 = v17;
      unsigned int v18 = *v16++;
      uint64_t v17 = (33 * v17) ^ v18;
    }
    while (v18);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v19 = (Registry **)a1;
  buf.var0 = (char *)v15;
  uint64_t v20 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)&buf);
  long long v21 = a3;
  if (v20)
  {
    uint64_t v23 = v20[3];
    BOOL v22 = (std::__shared_weak_count *)v20[4];
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v23 = 0;
    BOOL v22 = 0;
  }
  std::mutex::unlock(v14);
  v7[25] = v23;
  v7[26] = v22;
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
  }
  uint64_t v24 = *v36;
  if (os_log_type_enabled(*v36, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I created IPCU_CellProfileImpl", (uint8_t *)&buf, 2u);
  }
  if (!v7[25]) {
    __TUAssertTrigger();
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  unint64_t v25 = (std::__shared_weak_count *)v7[5];
  if (v25)
  {
    if (v25->__shared_owners_ != -1) {
      goto LABEL_27;
    }
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(v7 + 2, 1uLL, memory_order_relaxed);
    v7[4] = v8;
    v7[5] = v7;
    std::__shared_weak_count::__release_weak(v25);
  }
  else
  {
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(v7 + 2, 1uLL, memory_order_relaxed);
    v7[4] = v8;
    v7[5] = v7;
  }
  sub_10004D2C8((std::__shared_weak_count *)v7);
LABEL_27:
  int64_t v26 = *v36;
  if (os_log_type_enabled(*v36, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.var0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I init", (uint8_t *)&buf, 2u);
  }
  sub_1011A2324((uint64_t)v8);
  uint64_t v27 = (std::mutex *)Registry::getServiceMap(*v19);
  unint64_t v28 = v27;
  uint64_t v29 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    uint64_t v30 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v31 = 5381;
    do
    {
      uint64_t v29 = (const char *)v31;
      unsigned int v32 = *v30++;
      uint64_t v31 = (33 * v31) ^ v32;
    }
    while (v32);
  }
  std::mutex::lock(v27);
  atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
  buf.var0 = v8;
  buf.var1.fRef = (os_log_s *)v7;
  uint64_t v38 = v29;
  sub_100136784((uint64_t)&v28[1], (unint64_t *)&v38, &v38, (uint64_t *)&buf);
  char v34 = v33;
  if (buf.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)buf.var1.fRef);
  }
  std::mutex::unlock(v28);
  if ((v34 & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "The given type is already in the map!");
  }
  char *v21 = v8;
  v21[1] = (char *)v7;
}

void sub_10119F688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, ctu::OsLogLogger *a10, char a11, uint64_t a12, uint64_t a13, char a14)
{
  shared_weak_owners = (std::__shared_weak_count *)v14[8].__shared_weak_owners_;
  if (shared_weak_owners) {
    sub_10004D2C8(shared_weak_owners);
  }
  sub_100057D78(v17 + 1);
  sub_100057D78(v17);
  uint64_t v20 = (std::__shared_weak_count *)v14[7].__vftable;
  if (v20) {
    sub_10004D2C8(v20);
  }
  long long v21 = (std::__shared_weak_count *)v14[6].__vftable;
  if (v21) {
    sub_10004D2C8(v21);
  }
  std::mutex::~mutex(v16);
  ctu::OsLogLogger::~OsLogLogger(a10);
  sub_100087E88(a9);
  if (v15) {
    sub_10004D2C8(v15);
  }
  std::__shared_weak_count::~__shared_weak_count(v14);
  operator delete(v22);
  _Unwind_Resume(a1);
}

void *sub_10119F764(void *a1)
{
  *a1 = off_101A99540;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  *a1 = off_101A4D980;
  unint64_t v3 = a1[2];
  if (v3) {
    dispatch_release(v3);
  }
  return a1;
}

void sub_10119F7E4(void *a1)
{
  sub_10119F764(a1);

  operator delete();
}

const char *sub_10119F81C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  uint64_t v2 = "ipcu-apn.?";
  if (v1 == 2) {
    uint64_t v2 = "ipcu-apn.2";
  }
  if (v1 == 1) {
    return "ipcu-apn.1";
  }
  else {
    return v2;
  }
}

BOOL sub_10119F84C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 8);
  unint64_t v3 = (std::mutex *)(v1 + 48);
  std::mutex::lock((std::mutex *)(v1 + 48));
  if (*(_DWORD *)(v1 + 128) == v2 && !*(unsigned char *)(v1 + 168))
  {
    if (*(void *)(v1 + 152)) {
      unint64_t v5 = sub_100080778;
    }
    else {
      unint64_t v5 = 0;
    }
    BOOL v4 = v5 != 0;
  }
  else
  {
    BOOL v4 = 0;
  }
  std::mutex::unlock(v3);
  return v4;
}

void sub_10119F8D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(a1 + 8);
  BOOL v4 = (std::mutex *)(v2 + 48);
  std::mutex::lock((std::mutex *)(v2 + 48));
  if (*(_DWORD *)(v2 + 128) == v3 && !*(unsigned char *)(v2 + 168))
  {
    uint64_t v5 = *(void *)(v2 + 136);
    unint64_t v6 = *(std::__shared_weak_count **)(v2 + 144);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v9 = *(NSObject **)(a1 + 24);
  unint64_t v7 = (os_log_t *)(a1 + 24);
  uint64_t v8 = v9;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I DATA:: IPCU_APN_Storage:", (uint8_t *)v10, 2u);
    uint64_t v8 = *v7;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v10[0] = 67109120;
    v10[1] = v5 != 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t%d APN(s) found", (uint8_t *)v10, 8u);
  }
  if (v5) {
    sub_100C97150(v5, v7);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_10119FA24(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10119FA3C(uint64_t a1@<X0>, const void **a2@<X8>)
{
}

void sub_10119FA4C(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
}

void sub_10119FA64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A99610;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10119FA84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A99610;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10119FAD8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_10119FB00(uint64_t a1)
{
  *(void *)a1 = off_101A99660;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 160));
  sub_100057D78((const void **)(a1 + 152));
  int v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 120);
  if (v4) {
    sub_10004D2C8(v4);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 48));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10119FB90(uint64_t a1)
{
  *(void *)a1 = off_101A99660;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 160));
  sub_100057D78((const void **)(a1 + 152));
  int v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 120);
  if (v4) {
    sub_10004D2C8(v4);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 48));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  operator delete();
}

void sub_10119FC40(uint64_t a1@<X0>, int a2@<W1>, const void **a3@<X8>)
{
  unint64_t v6 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  if (*(_DWORD *)(a1 + 128) == a2 && !*(unsigned char *)(a1 + 168)) {
    sub_100058198(a3, (const void **)(a1 + 160));
  }
  else {
    *a3 = 0;
  }

  std::mutex::unlock(v6);
}

void sub_10119FCB8(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  unsigned int v32 = (std::mutex *)(a1 + 48);
  uint64_t v33 = 1;
  std::mutex::lock((std::mutex *)(a1 + 48));
  if (*(_DWORD *)(a1 + 128) != a2) {
    goto LABEL_3;
  }
  if (*(unsigned char *)(a1 + 168)) {
    goto LABEL_3;
  }
  uint64_t v10 = *(void *)(a1 + 136);
  if (!v10) {
    goto LABEL_3;
  }
  if ((*(_DWORD *)(v10 + 188) & a4) != 0) {
    goto LABEL_52;
  }
  uint64_t v11 = *(Registry **)(a1 + 112);
  *(void *)(v10 + 152) = *(unsigned int *)(a1 + 172);
  *(_DWORD *)(v10 + 188) = 236;
  *(unsigned char *)(v10 + 192) = 1;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v10, v11);
  unint64_t v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v30 = v14;
  unsigned int v18 = sub_10004D37C(&v13[1].__m_.__sig, &v30);
  if (!v18)
  {
    std::mutex::unlock(v13);
    goto LABEL_17;
  }
  uint64_t v20 = v18[3];
  uint64_t v19 = (std::__shared_weak_count *)v18[4];
  if (!v19)
  {
    std::mutex::unlock(v13);
    if (v20) {
      goto LABEL_21;
    }
LABEL_17:
    uint64_t v23 = *(void *)(a1 + 136);
    if (*(_DWORD *)(v23 + 168))
    {
      uint64_t v22 = 0;
      if (*(_DWORD *)(v23 + 172))
      {
        long long v21 = 0;
        goto LABEL_47;
      }
      int v25 = 1;
      long long v21 = 0;
      goto LABEL_39;
    }
    long long v21 = 0;
    uint64_t v22 = 0;
    goto LABEL_32;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  if (!v20)
  {
    long long v21 = 0;
    uint64_t v22 = 0;
LABEL_28:
    sub_10004D2C8(v19);
    goto LABEL_29;
  }
LABEL_21:
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  sub_100BBB920(v20, &v30);
  if (v30)
  {
    sub_1011A07AC((uint64_t)&v32);
    (*(void (**)(void *__return_ptr))(*(void *)v30 + 72))(v29);
    uint64_t v22 = v29[0];
    long long v21 = (std::__shared_weak_count *)v29[1];
    sub_1011A07F0((uint64_t)&v32);
  }
  else
  {
    uint64_t v22 = 0;
    long long v21 = 0;
  }
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (v19) {
    goto LABEL_28;
  }
LABEL_29:
  uint64_t v23 = *(void *)(a1 + 136);
  if (!*(_DWORD *)(v23 + 168))
  {
    if (v22)
    {
      int v24 = *(_DWORD *)(v22 + 168);
LABEL_33:
      *(_DWORD *)(v23 + 168) = v24;
      goto LABEL_34;
    }
LABEL_32:
    int v24 = 1;
    goto LABEL_33;
  }
LABEL_34:
  if (*(_DWORD *)(v23 + 172)) {
    goto LABEL_40;
  }
  if (v22) {
    int v25 = *(_DWORD *)(v22 + 172);
  }
  else {
    int v25 = 1;
  }
LABEL_39:
  *(_DWORD *)(v23 + 172) = v25;
LABEL_40:
  if (!*(unsigned char *)(v23 + 180))
  {
    if (!v22) {
      goto LABEL_47;
    }
    if (*(unsigned char *)(v22 + 180))
    {
      int v26 = *(_DWORD *)(v22 + 176);
      *(unsigned char *)(v23 + 180) = *(unsigned char *)(v22 + 180);
      *(_DWORD *)(v23 + 176) = v26;
      uint64_t v23 = *(void *)(a1 + 136);
    }
    goto LABEL_46;
  }
  if (v22) {
LABEL_46:
  }
    *(_DWORD *)(v23 + 188) = *(_DWORD *)(v22 + 188);
LABEL_47:
  if ((*(_DWORD *)(v23 + 152) & 0x8000030) != 0
    && (sub_100C9A548(v23, (Registry **)(a1 + 112), *(unsigned int *)(a1 + 128)) & 1) == 0)
  {
    *(void *)(v23 + 152) &= 0xFFFFFFFFF7FFFFCFLL;
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
LABEL_52:
  uint64_t v27 = *(void *)(a1 + 136);
  if (!v27 || (*(void *)(v27 + 152) & a3) == 0)
  {
LABEL_3:
    *a5 = 0;
    a5[1] = 0;
    goto LABEL_4;
  }
  uint64_t v28 = *(void *)(a1 + 144);
  *a5 = v27;
  a5[1] = v28;
  if (v28) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_4:
  if ((_BYTE)v33) {
    std::mutex::unlock(v32);
  }
}

void sub_10119FFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, std::mutex *a13, char a14)
{
  if (a12)
  {
    sub_10004D2C8(a12);
    if (!v14)
    {
LABEL_6:
      if (a14) {
        std::mutex::unlock(a13);
      }
      _Unwind_Resume(exception_object);
    }
  }
  else if (!v14)
  {
    goto LABEL_6;
  }
  sub_10004D2C8(v14);
  goto LABEL_6;
}

void sub_1011A0054(uint64_t a1@<X0>, const void **a2@<X8>)
{
  BOOL v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  if (*(unsigned char *)(a1 + 168)) {
    sub_100058198(a2, (const void **)(a1 + 152));
  }
  else {
    *a2 = 0;
  }

  std::mutex::unlock(v4);
}

void sub_1011A00BC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)OsLogContext buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I refresh", buf, 2u);
  }
  std::mutex::lock((std::mutex *)(a1 + 48));
  int v3 = *(_DWORD *)(a1 + 128);
  uint64_t v5 = 0;
  sub_100058198(&v5, (const void **)(a1 + 160));
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 144);
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1011A084C(a1, v3, v5);
  sub_100057D78(&v5);
  std::mutex::unlock((std::mutex *)(a1 + 48));
}

void sub_1011A0178(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void sub_1011A0194(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  int v3 = (os_log_t *)(a1 + 40);
  BOOL v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  | IPCU_CellProfile:", v12, 2u);
    BOOL v4 = *v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = subscriber::asString();
    *(_DWORD *)unint64_t v12 = 136315138;
    *(void *)&v12[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  | IPCU profile assigned to: %s", v12, 0xCu);
    BOOL v4 = *v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 168));
    *(_DWORD *)unint64_t v12 = 136315138;
    *(void *)&v12[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I  | NAI mode: %s", v12, 0xCu);
    BOOL v4 = *v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v12 = 136315394;
    *(void *)&v12[4] = "";
    *(_WORD *)&v12[12] = 2080;
    *(void *)&v12[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s | APN dict:", v12, 0x16u);
  }
  *(void *)unint64_t v12 = off_101A99770;
  *(void *)&v12[8] = a1;
  unint64_t v13 = v12;
  logger::CFTypeRefLogger();
  sub_10012C330(v12);
  unint64_t v7 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unint64_t v12 = 136315394;
    *(void *)&v12[4] = "";
    *(_WORD *)&v12[12] = 2080;
    *(void *)&v12[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s | AttachAPN:", v12, 0x16u);
  }
  *(void *)unint64_t v12 = off_101A997F0;
  *(void *)&v12[8] = a1;
  unint64_t v13 = v12;
  logger::CFTypeRefLogger();
  sub_10012C330(v12);
  uint64_t v8 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)unint64_t v12 = 67109120;
    *(_DWORD *)&v12[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I  | fIPCUApnTypemask: 0x%X", v12, 8u);
  }
  uint64_t v10 = *(void *)(a1 + 136);
  if (v10)
  {
    sub_100C97150(v10, (os_log_t *)(a1 + 40));
  }
  else
  {
    uint64_t v11 = *v3;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I  | APN: not present", v12, 2u);
    }
  }
  std::mutex::unlock(v2);
}

void sub_1011A04B0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1011A04E0(uint64_t a1, uint64_t a2)
{
}

void sub_1011A05D4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1011A05E8(uint64_t a1)
{
}

void sub_1011A0684(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1011A0698(uint64_t a1@<X0>, void *a2@<X8>)
{
  BOOL v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  *a2 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 176) + 40))(&v5);
  sub_10004EFE4(a2, &v5);
  sub_1000577C4(&v5);
  std::mutex::unlock(v4);
}

void sub_1011A074C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1011A0770(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  uint64_t v3 = *(unsigned int *)(a1 + 128);
  std::mutex::unlock(v2);
  return v3;
}

void sub_1011A07AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    std::mutex::unlock(*(std::mutex **)a1);
    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    sub_1011A07F0();
  }
}

void sub_1011A07F0(uint64_t a1)
{
  uint64_t v2 = *(std::mutex **)a1;
  if (v2)
  {
    if (!*(unsigned char *)(a1 + 8))
    {
      std::mutex::lock(v2);
      *(unsigned char *)(a1 + 8) = 1;
      return;
    }
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::lock: references null mutex");
  }
  std::__throw_system_error(11, "unique_lock::lock: already locked");
  sub_1011A084C(v3, v4, v5);
}

void sub_1011A084C(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    *(_WORD *)OsLogContext buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I reactOnRefresh", buf, 2u);
  }
  if (*(void *)(a1 + 152)) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8 || (*(void *)(a1 + 160) ? (int v9 = sub_100080778) : (int v9 = 0), v9))
  {
    uint64_t v10 = (const void **)capabilities::ct::supportsGemini((capabilities::ct *)v7);
    if (!v10 || !*(_DWORD *)(a1 + 128))
    {
LABEL_88:
      if (*(_DWORD *)(a1 + 128)) {
        goto LABEL_167;
      }
      if ((capabilities::ct::supportsGemini((capabilities::ct *)v10) & 1) == 0) {
        __TUAssertTrigger();
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v41, *(Registry **)(a1 + 112));
      uint64_t v43 = ServiceMap;
      if (v44 < 0)
      {
        uint64_t v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v46 = 5381;
        do
        {
          uint64_t v44 = v46;
          unsigned int v47 = *v45++;
          uint64_t v46 = (33 * v46) ^ v47;
        }
        while (v47);
      }
      std::mutex::lock(ServiceMap);
      *(void *)OsLogContext buf = v44;
      unint64_t v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)buf);
      if (v48)
      {
        uint64_t v50 = v48[3];
        unint64_t v49 = (std::__shared_weak_count *)v48[4];
        if (v49)
        {
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v43);
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v49);
          char v51 = 0;
LABEL_99:
          v133 = 0;
          v134 = 0;
          (*(void (**)(const std::string **__return_ptr, uint64_t, uint64_t))(*(void *)v50 + 8))(&v133, v50, 1);
          uint64_t v131 = 0;
          v132 = 0;
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v50 + 8))(&v131, v50, 2);
          BOOL v52 = v133
             && isReal()
             && !v133[2].__r_.__value_.__s.__data_[14]
             && v133[2].__r_.__value_.__s.__data_[15] == 0;
          BOOL v53 = v131;
          BOOL v127 = v52;
          if (v131 && isReal() && (BOOL v53 = v131, !*(unsigned char *)(v131 + 62)))
          {
            BOOL v53 = *(unsigned __int8 *)(v131 + 63) == 0;
            BOOL v128 = *(unsigned __int8 *)(v131 + 63) == 0;
          }
          else
          {
            BOOL v128 = 0;
          }
          uint64_t v54 = (std::mutex *)Registry::getServiceMap((uint64_t *)v53, *(Registry **)(a1 + 112));
          uint64_t v55 = v54;
          if (v56 < 0)
          {
            long long v57 = (unsigned __int8 *)(v56 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v58 = 5381;
            do
            {
              uint64_t v56 = v58;
              unsigned int v59 = *v57++;
              uint64_t v58 = (33 * v58) ^ v59;
            }
            while (v59);
          }
          std::mutex::lock(v54);
          *(void *)OsLogContext buf = v56;
          uint64_t v60 = sub_10004D37C(&v55[1].__m_.__sig, (unint64_t *)buf);
          if (v60)
          {
            uint64_t v61 = v60[3];
            uint64_t v62 = (std::__shared_weak_count *)v60[4];
            if (v62)
            {
              atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v55);
              atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v62);
              char v63 = 0;
              if (!v61) {
                goto LABEL_113;
              }
              goto LABEL_117;
            }
          }
          else
          {
            uint64_t v61 = 0;
          }
          std::mutex::unlock(v55);
          uint64_t v62 = 0;
          char v63 = 1;
          if (!v61)
          {
LABEL_113:
            long long v64 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)OsLogContext buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I findSlotAssignment, DataService is missing", buf, 2u);
            }
LABEL_159:
            if ((v63 & 1) == 0) {
              sub_10004D2C8(v62);
            }
            if (v132) {
              sub_10004D2C8(v132);
            }
            if (v134) {
              sub_10004D2C8(v134);
            }
            if ((v51 & 1) == 0) {
              sub_10004D2C8(v49);
            }
            goto LABEL_167;
          }
LABEL_117:
          int v65 = a2;
          int v66 = (*(uint64_t (**)(uint64_t))(*(void *)v61 + 760))(v61);
          memset(&__p, 0, sizeof(__p));
          uint64_t v67 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            char v126 = v51;
            v125 = v49;
            uint64_t v124 = asStringBool(v127);
            uint64_t v68 = asStringBool(v128);
            if (v133)
            {
              int data = (const char *)&v133[1];
              std::string::size_type size = HIBYTE(v133[1].__r_.__value_.__r.__words[2]);
              int v71 = (char)size;
              if ((size & 0x80u) != 0) {
                std::string::size_type size = v133[1].__r_.__value_.__l.__size_;
              }
              if (v71 < 0) {
                int data = v133[1].__r_.__value_.__l.__data_;
              }
              if (size) {
                int64_t v72 = data;
              }
              else {
                int64_t v72 = "<invalid>";
              }
            }
            else
            {
              int64_t v72 = "-";
            }
            if (v131)
            {
              int v73 = (const char *)(v131 + 24);
              uint64_t v74 = *(unsigned __int8 *)(v131 + 47);
              int v75 = (char)v74;
              if ((v74 & 0x80u) != 0) {
                uint64_t v74 = *(void *)(v131 + 32);
              }
              if (v75 < 0) {
                int v73 = *(const char **)(v131 + 24);
              }
              if (v74) {
                uint64_t v76 = v73;
              }
              else {
                uint64_t v76 = "<invalid>";
              }
            }
            else
            {
              uint64_t v76 = "-";
            }
            uint64_t v77 = subscriber::asString();
            *(_DWORD *)OsLogContext buf = 136316162;
            *(void *)&uint8_t buf[4] = v124;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v68;
            *(_WORD *)&unsigned char buf[22] = 2080;
            v136 = v72;
            __int16 v137 = 2080;
            v138 = v76;
            __int16 v139 = 2080;
            uint64_t v140 = v77;
            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I findSlotAssignment, sim1:%s, sim2:%s, persona1:%s, persona2:%s, data preferred:%s", buf, 0x34u);
            unint64_t v49 = v125;
            char v51 = v126;
          }
          if (v127 && v128)
          {
            a2 = v65;
            if ((v66 - 1) > 1)
            {
              uint64_t v80 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)OsLogContext buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I cannot find preferred slot for IPCU profile while in Dual Sim mode", buf, 2u);
              }
              goto LABEL_151;
            }
            *(_DWORD *)(a1 + 128) = v66;
            uint64_t v78 = (const std::string **)&v131;
            if (v66 == 1) {
              uint64_t v78 = &v133;
            }
            uint64_t v79 = *v78;
          }
          else
          {
            a2 = v65;
            if (v127)
            {
              *(_DWORD *)(a1 + 128) = 1;
              uint64_t v79 = v133;
            }
            else
            {
              if (!v128)
              {
LABEL_151:
                int v81 = *(_DWORD *)(a1 + 128);
                uint64_t v82 = *(NSObject **)(a1 + 40);
                BOOL v83 = os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
                if (v81)
                {
                  if (v83)
                  {
                    uint64_t v84 = subscriber::asString();
                    *(_DWORD *)OsLogContext buf = 136315138;
                    *(void *)&uint8_t buf[4] = v84;
                    _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I assigned IPCU profile on slot %s", buf, 0xCu);
                    int v81 = *(_DWORD *)(a1 + 128);
                  }
                  sub_1011A1A34((const void **)a1, v81, (uint64_t)&__p);
                  sub_1011A1CE4(a1);
                }
                if (v83)
                {
                  *(_WORD *)OsLogContext buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I slot for IPCU profile not yet defined", buf, 2u);
                }
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                goto LABEL_159;
              }
              *(_DWORD *)(a1 + 128) = 2;
              uint64_t v79 = (const std::string *)v131;
            }
          }
          std::string::operator=(&__p, v79 + 1);
          goto LABEL_151;
        }
      }
      else
      {
        uint64_t v50 = 0;
      }
      std::mutex::unlock(v43);
      unint64_t v49 = 0;
      char v51 = 1;
      goto LABEL_99;
    }
    std::string::size_type v129 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 176) + 40))(buf);
    sub_100056248(&v129, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v129) {
      uint64_t v11 = sub_1000810B8;
    }
    else {
      uint64_t v11 = 0;
    }
    if (!v11)
    {
LABEL_87:
      uint64_t v10 = sub_1000558F4(&v129);
      goto LABEL_88;
    }
    memset(&__p, 0, sizeof(__p));
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    unint64_t v12 = *(void **)buf;
    LODWORD(v133) = *(_DWORD *)&buf[16];
    *(_DWORD *)((char *)&v133 + 3) = *(_DWORD *)&buf[19];
    unint64_t v13 = (uint64_t *)(char)buf[23];
    if ((v13 & 0x80000000) != 0)
    {
      sub_10004FC84(&__p, *(void **)buf, *(unint64_t *)&buf[8]);
      operator delete(v12);
    }
    else
    {
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)buf;
      LODWORD(__p.__r_.__value_.__r.__words[2]) = v133;
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)&v133 + 3);
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = buf[23];
    }
    unint64_t v14 = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(a1 + 112));
    uint64_t v15 = v14;
    if (v16 < 0)
    {
      unsigned int v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        uint64_t v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(v14);
    *(void *)OsLogContext buf = v16;
    uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      long long v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    long long v21 = 0;
    char v23 = 1;
LABEL_28:
    v133 = 0;
    v134 = 0;
    (*(void (**)(const std::string **__return_ptr, uint64_t, uint64_t))(*(void *)v22 + 8))(&v133, v22, 1);
    uint64_t v131 = 0;
    v132 = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v22 + 8))(&v131, v22, 2);
    if (*(_DWORD *)(a1 + 128) == 1)
    {
      if ((!v133 || !sub_10001D294((unsigned __int8 *)&v133[1], (unsigned __int8 *)&__p))
        && v131
        && sub_10001D294((unsigned __int8 *)(v131 + 24), (unsigned __int8 *)&__p))
      {
        int v24 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = subscriber::asString();
          std::string::size_type v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v26 = __p.__r_.__value_.__l.__size_;
          }
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if (v26) {
            uint64_t v28 = (const char *)p_p;
          }
          else {
            uint64_t v28 = "<invalid>";
          }
          *(_DWORD *)OsLogContext buf = 136315394;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v28;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I re-assigned IPCU profile on slot %s since initial SIM %s was moved there", buf, 0x16u);
        }
        int v29 = 2;
        goto LABEL_57;
      }
    }
    else if ((!v131 || !sub_10001D294((unsigned __int8 *)(v131 + 24), (unsigned __int8 *)&__p)) {
           && v133
    }
           && sub_10001D294((unsigned __int8 *)&v133[1], (unsigned __int8 *)&__p))
    {
      unint64_t v30 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = subscriber::asString();
        std::string::size_type v32 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v32 = __p.__r_.__value_.__l.__size_;
        }
        uint64_t v33 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v33 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (v32) {
          char v34 = (const char *)v33;
        }
        else {
          char v34 = "<invalid>";
        }
        *(_DWORD *)OsLogContext buf = 136315394;
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v34;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I re-assigned IPCU profile on slot %s since initial SIM %s was moved there", buf, 0x16u);
      }
      int v29 = 1;
LABEL_57:
      *(_DWORD *)(a1 + 128) = v29;
      sub_1011A1A34((const void **)a1, v29, (uint64_t)&__p);
      sub_1011A1CE4(a1);
    }
    int v35 = *(_DWORD *)(a1 + 128);
    if (v35 == 1)
    {
      if (!v133)
      {
LABEL_79:
        if (v132) {
          sub_10004D2C8(v132);
        }
        if (v134) {
          sub_10004D2C8(v134);
        }
        if ((v23 & 1) == 0) {
          sub_10004D2C8(v21);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        goto LABEL_87;
      }
      if (sub_10001D294((unsigned __int8 *)&v133[1], (unsigned __int8 *)&__p)
        && v133[2].__r_.__value_.__s.__data_[14]
        && v133[2].__r_.__value_.__s.__data_[15])
      {
LABEL_69:
        uint64_t v36 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = subscriber::asString();
          std::string::size_type v38 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v38 = __p.__r_.__value_.__l.__size_;
          }
          uint64_t v39 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint64_t v39 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if (v38) {
            long long v40 = (const char *)v39;
          }
          else {
            long long v40 = "<invalid>";
          }
          *(_DWORD *)OsLogContext buf = 136315394;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v40;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I unassigned IPCU profile from slot %s since initial SIM %s happens to be irrelevant", buf, 0x16u);
        }
        *(_DWORD *)(a1 + 128) = 0;
        sub_1011A1A34((const void **)a1, 0, (uint64_t)&__p);
        sub_1011A1CE4(a1);
      }
      int v35 = *(_DWORD *)(a1 + 128);
    }
    if (v35 == 2
      && v131
      && sub_10001D294((unsigned __int8 *)(v131 + 24), (unsigned __int8 *)&__p)
      && *(unsigned char *)(v131 + 62)
      && *(unsigned char *)(v131 + 63))
    {
      goto LABEL_69;
    }
    goto LABEL_79;
  }
LABEL_167:
  if (*(void *)(a1 + 152)) {
    long long v85 = (uint64_t *)sub_100080778;
  }
  else {
    long long v85 = 0;
  }
  if (v85)
  {
    uint64_t v86 = *(unsigned int *)(a1 + 128);
    if (v86)
    {
      __p.__r_.__value_.__r.__words[0] = 0;
      v87 = (std::mutex *)Registry::getServiceMap(v85, *(Registry **)(a1 + 112));
      v88 = v87;
      if (v89 < 0)
      {
        uint64_t v90 = (unsigned __int8 *)(v89 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v91 = 5381;
        do
        {
          uint64_t v89 = v91;
          unsigned int v92 = *v90++;
          uint64_t v91 = (33 * v91) ^ v92;
        }
        while (v92);
      }
      std::mutex::lock(v87);
      *(void *)OsLogContext buf = v89;
      v93 = sub_10004D37C(&v88[1].__m_.__sig, (unint64_t *)buf);
      if (v93)
      {
        uint64_t v94 = v93[3];
        v95 = (std::__shared_weak_count *)v93[4];
        if (v95)
        {
          atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v88);
          atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v95);
          char v96 = 0;
          goto LABEL_180;
        }
      }
      else
      {
        uint64_t v94 = 0;
      }
      std::mutex::unlock(v88);
      v95 = 0;
      char v96 = 1;
LABEL_180:
      (*(void (**)(const std::string **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v94 + 96))(&v133, v94, v86, 1, @"IPCUApnTypemask", 0, 0);
      sub_1000842D0(&__p, (CFTypeRef *)&v133);
      sub_1000577C4((const void **)&v133);
      if ((v96 & 1) == 0) {
        sub_10004D2C8(v95);
      }
      if (__p.__r_.__value_.__r.__words[0]) {
        id v98 = sub_100081E58;
      }
      else {
        id v98 = 0;
      }
      if (v98)
      {
        *(_DWORD *)OsLogContext buf = 0;
        ctu::cf::assign((ctu::cf *)buf, (unsigned int *)__p.__r_.__value_.__l.__data_, v97);
        int v99 = *(_DWORD *)buf;
      }
      else
      {
        int v99 = 1;
      }
      *(_DWORD *)(a1 + 172) = v99;
      sub_1000570E8((const void **)&__p.__r_.__value_.__l.__data_);
      sub_100BBEC88(buf);
    }
  }
  v100 = *(const void **)(a1 + 160);
  if (v100) {
    std::string v101 = sub_100080778;
  }
  else {
    std::string v101 = 0;
  }
  if ((a3 == 0) != (v101 != 0))
  {
    if (!v101) {
      goto LABEL_196;
    }
    if (CFEqual(v100, a3))
    {
      v100 = *(const void **)(a1 + 160);
LABEL_196:
      if (v100) {
        std::string v102 = sub_100080778;
      }
      else {
        std::string v102 = 0;
      }
      if (!v102 || *(_DWORD *)(a1 + 128) == a2) {
        goto LABEL_209;
      }
    }
  }
  int v103 = *(_DWORD *)(a1 + 128);
  if (v103)
  {
    uint64_t v104 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v105 = subscriber::asString();
      *(_DWORD *)OsLogContext buf = 136315138;
      *(void *)&uint8_t buf[4] = v105;
      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I trigger data::refreshAttachApn for slot %s", buf, 0xCu);
      int v103 = *(_DWORD *)(a1 + 128);
    }
    sub_100C9E680((uint64_t)&event::data::refreshAttachApn, v103, "ipcu-attachapn-added");
  }
  else if (a2)
  {
    std::string::size_type v106 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v107 = subscriber::asString();
      *(_DWORD *)OsLogContext buf = 136315138;
      *(void *)&uint8_t buf[4] = v107;
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I trigger data::refreshAttachApn for prev slot %s", buf, 0xCu);
    }
    sub_100C9E680((uint64_t)&event::data::refreshAttachApn, a2, "ipcu-attachapn-revoked");
  }
LABEL_209:
  if (*(void *)(a1 + 152)) {
    v108 = sub_100080778;
  }
  else {
    v108 = 0;
  }
  if (!v108) {
    goto LABEL_222;
  }
  std::string::size_type v109 = (uint64_t *)*(unsigned int *)(a1 + 128);
  if (!v109) {
    goto LABEL_222;
  }
  uint64_t v110 = (std::mutex *)Registry::getServiceMap(v109, *(Registry **)(a1 + 112));
  long long v111 = v110;
  if (v112 < 0)
  {
    long long v113 = (unsigned __int8 *)(v112 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v114 = 5381;
    do
    {
      uint64_t v112 = v114;
      unsigned int v115 = *v113++;
      uint64_t v114 = (33 * v114) ^ v115;
    }
    while (v115);
  }
  std::mutex::lock(v110);
  *(void *)OsLogContext buf = v112;
  long long v116 = sub_10004D37C(&v111[1].__m_.__sig, (unint64_t *)buf);
  if (!v116)
  {
    std::mutex::unlock(v111);
LABEL_222:
    int v119 = 0;
    LODWORD(v118) = 0;
    goto LABEL_223;
  }
  uint64_t v118 = v116[3];
  long long v117 = (std::__shared_weak_count *)v116[4];
  if (v117)
  {
    atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v111);
    atomic_fetch_add_explicit(&v117->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v117);
    if (!v118)
    {
      int v119 = 0;
LABEL_242:
      sub_10004D2C8(v117);
      goto LABEL_223;
    }
  }
  else
  {
    std::mutex::unlock(v111);
    if (!v118)
    {
      int v119 = 0;
      goto LABEL_223;
    }
  }
  *(void *)OsLogContext buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v118 + 16))(buf, v118, *(unsigned int *)(a1 + 128));
  if (*(void *)buf)
  {
    int v119 = (*(uint64_t (**)(void))(**(void **)buf + 88))(*(void *)buf);
    LODWORD(v118) = 1;
  }
  else
  {
    int v119 = 0;
    LODWORD(v118) = 0;
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v117) {
    goto LABEL_242;
  }
LABEL_223:
  std::string v120 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
  {
    if (v118) {
      v121 = (const char *)asStringBool(v119);
    }
    else {
      v121 = "no NAI selector, assuming false";
    }
    *(_DWORD *)OsLogContext buf = 136315138;
    *(void *)&uint8_t buf[4] = v121;
    _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I NAI mode: %s", buf, 0xCu);
  }
  if (v118) {
    BOOL v122 = v119 == 0;
  }
  else {
    BOOL v122 = 1;
  }
  char v123 = !v122;
  *(unsigned char *)(a1 + 168) = v123;
}

void sub_1011A1878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::__shared_weak_count *a22,char a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  if (a24) {
    sub_10004D2C8(a24);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a14);
  _Unwind_Resume(a1);
}

const void **sub_1011A1A34(const void **result, int a2, uint64_t a3)
{
  uint64_t v3 = result;
  if ((a2 - 1) < 2)
  {
    uint64_t v6 = result[22];
    CFNumberRef v17 = 0;
    LOBYTE(valuePtr) = a2;
    CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCharType, &valuePtr);
    if (v7)
    {
      CFNumberRef v8 = v17;
      CFNumberRef v17 = v7;
      CFNumberRef valuePtr = v8;
      sub_1000570E8((const void **)&valuePtr);
    }
    CFNumberRef v9 = v17;
    CFNumberRef v16 = v17;
    CFNumberRef v17 = 0;
    sub_1000570E8((const void **)&v17);
    (*(void (**)(const void *, const __CFString *, CFNumberRef, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v6 + 16))(v6, @"assignedSlot", v9, @"com.apple.commcenter.cellular_profile", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
    sub_1000570E8((const void **)&v16);
    uint64_t v11 = v3[22];
    if (*(char *)(a3 + 23) >= 0) {
      unint64_t v12 = (const __CFString **)a3;
    }
    else {
      unint64_t v12 = *(const __CFString ***)a3;
    }
    CFNumberRef v16 = 0;
    CFNumberRef v17 = 0;
    if (ctu::cf::convert_copy((ctu::cf *)&v17, v12, (const char *)0x8000100, kCFAllocatorDefault, v10))
    {
      CFNumberRef v13 = v16;
      CFNumberRef v16 = v17;
      CFNumberRef valuePtr = v13;
      sub_1000558F4((const void **)&valuePtr);
    }
    CFNumberRef v14 = v16;
    CFNumberRef v15 = v16;
    CFNumberRef v16 = 0;
    sub_1000558F4((const void **)&v16);
    (*(void (**)(const void *, const __CFString *, CFNumberRef, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)v11 + 16))(v11, @"initiatedIccid", v14, @"com.apple.commcenter.cellular_profile", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
    return sub_1000558F4((const void **)&v15);
  }
  else if (!a2 || a2 == 3)
  {
    (*(void (**)(const void *, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(*(void *)result[22] + 16))(result[22], @"assignedSlot", 0, @"com.apple.commcenter.cellular_profile", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
    int v4 = *(uint64_t (**)(void))(*(void *)v3[22] + 16);
    return (const void **)v4();
  }
  return result;
}

void sub_1011A1CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_1011A1CE4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A1DC4(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  if (((*(uint64_t (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v1 + 176) + 48))(*(void *)(v1 + 176), @"com.apple.commcenter.cellular_profile", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost) & 1) == 0)
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)OsLogContext buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Failed to synchronize preferences", buf, 2u);
    }
  }
  operator delete();
}

void sub_1011A1E9C()
{
}

void sub_1011A1ECC()
{
}

void *sub_1011A1EE0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A99770;
  result[1] = v3;
  return result;
}

uint64_t sub_1011A1F28(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A99770;
  a2[1] = v2;
  return result;
}

void sub_1011A1F54(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v4 = a2;
    }
    else {
      int v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    CFNumberRef v8 = "";
    __int16 v9 = 2080;
    CFAllocatorRef v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1011A2020(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011A2060()
{
}

void sub_1011A2070()
{
}

void *sub_1011A2084(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A997F0;
  result[1] = v3;
  return result;
}

uint64_t sub_1011A20CC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A997F0;
  a2[1] = v2;
  return result;
}

void sub_1011A20F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v4 = a2;
    }
    else {
      int v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    CFNumberRef v8 = "";
    __int16 v9 = 2080;
    CFAllocatorRef v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1011A21C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011A2204()
{
}

uint64_t sub_1011A2210(uint64_t a1)
{
  (*(void (**)(void, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 176) + 16))(*(void *)(a1 + 176), @"profile", 0, @"com.apple.commcenter.cellular_profile", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  (*(void (**)(void, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 176) + 16))(*(void *)(a1 + 176), @"assignedSlot", 0, @"com.apple.commcenter.cellular_profile", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 176) + 16);

  return v2();
}

void sub_1011A2324(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)OsLogContext buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I reload", buf, 2u);
  }
  std::mutex::lock((std::mutex *)(a1 + 48));
  int v3 = *(_DWORD *)(a1 + 128);
  uint64_t v45 = 0;
  int v4 = (void **)(a1 + 160);
  sub_100058198(&v45, (const void **)(a1 + 160));
  *(_DWORD *)(a1 + 128) = 0;
  int v5 = *(std::__shared_weak_count **)(a1 + 144);
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = 0;
  *(void *)OsLogContext buf = v6;
  sub_100057D78((const void **)buf);
  CFNumberRef v8 = (const void **)(a1 + 152);
  uint64_t v7 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0;
  *(void *)OsLogContext buf = v7;
  sub_100057D78((const void **)buf);
  CFDictionaryRef theDict = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 176) + 40))(buf);
  sub_10004EFE4(&theDict, (CFTypeRef *)buf);
  __int16 v9 = sub_1000577C4((const void **)buf);
  if (theDict) {
    CFAllocatorRef v10 = sub_100080778;
  }
  else {
    CFAllocatorRef v10 = 0;
  }
  if (v10)
  {
    if (capabilities::ct::supportsGemini((capabilities::ct *)v9))
    {
      *(void *)OsLogContext buf = 0;
      (*(void (**)(void **__return_ptr))(**(void **)(a1 + 176) + 40))(__p);
      sub_1000842D0(buf, (CFTypeRef *)__p);
      sub_1000577C4((const void **)__p);
      if (*(void *)buf) {
        unint64_t v12 = sub_100081E58;
      }
      else {
        unint64_t v12 = 0;
      }
      if (!v12
        || (LOBYTE(__p[0]) = 0,
            ctu::cf::assign((ctu::cf *)__p, *(signed __int8 **)buf, v11),
            (SLOBYTE(__p[0]) - 1) >= 2))
      {
        sub_1000570E8((const void **)buf);
        goto LABEL_24;
      }
      int v13 = LOBYTE(__p[0]);
      sub_1000570E8((const void **)buf);
    }
    else
    {
      int v13 = 1;
    }
    *(_DWORD *)(a1 + 128) = v13;
LABEL_24:
    CFNumberRef v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = subscriber::asString();
      *(_DWORD *)OsLogContext buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I IPCU associated slot: %s", buf, 0xCu);
    }
    uint64_t v43 = 0;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"APNs");
    CFArrayRef v19 = Value;
    if (Value)
    {
      CFTypeID v20 = CFGetTypeID(Value);
      if (v20 == CFArrayGetTypeID() && CFArrayGetCount(v19) >= 1)
      {
        __p[0] = (void *)CFArrayGetValueAtIndex(v19, 0);
        *(void *)OsLogContext buf = 0;
        sub_10004EFE4(buf, (CFTypeRef *)__p);
        CFArrayRef v19 = *(const __CFArray **)buf;
        uint64_t v43 = *(const void **)buf;
        *(void *)OsLogContext buf = 0;
        sub_100057D78((const void **)buf);
      }
      else
      {
        CFArrayRef v19 = 0;
      }
    }
    if (v19) {
      long long v21 = sub_100080778;
    }
    else {
      long long v21 = 0;
    }
    if (!v21)
    {
      uint64_t v22 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)OsLogContext buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I No APN in IPCU profile", buf, 2u);
        uint64_t v22 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)OsLogContext buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Reading old APN from Managed preferences", buf, 2u);
        uint64_t v22 = *(NSObject **)(a1 + 40);
      }
      uint64_t v46 = 0;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)OsLogContext buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Pulling APN settings for %d from profile or carrier settings", buf, 8u);
      }
      if (access("/Library/Managed Preferences/mobile/com.apple.managedCarrier.plist", 0))
      {
        char v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)OsLogContext buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I IPCU file DOES NOT exist - old style profile reading skipped", buf, 2u);
        }
      }
      else
      {
        __p[0] = &off_101A0BD40;
        *(void *)uint64_t v50 = 0;
        sub_100058DB0(buf, "/Library/Managed Preferences/mobile/com.apple.managedCarrier.plist");
        (*((void (**)(unsigned char *__return_ptr, void **, const CFAllocatorRef, uint8_t *))__p[0] + 20))(v50, __p, kCFAllocatorDefault, buf);
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        if (*(void *)v50) {
          int v24 = sub_100080778;
        }
        else {
          int v24 = 0;
        }
        if (v24)
        {
          unint64_t v48 = 0;
          CFArrayRef theArray = 0;
          CFTypeRef ValueAtIndex = CFDictionaryGetValue(*(CFDictionaryRef *)v50, @"apns");
          *(void *)OsLogContext buf = 0;
          sub_100044D6C(buf, &ValueAtIndex);
          CFArrayRef v25 = theArray;
          CFArrayRef theArray = *(CFArrayRef *)buf;
          *(void *)OsLogContext buf = v25;
          sub_100044D00((const void **)buf);
          CFArrayRef v26 = theArray;
          if (theArray) {
            uint64_t v27 = sub_100083F10;
          }
          else {
            uint64_t v27 = 0;
          }
          if (v27)
          {
            uint64_t v28 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)OsLogContext buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Found a list of APN settings in the managed profile", buf, 2u);
              CFArrayRef v26 = theArray;
            }
            if (CFArrayGetCount(v26) >= 1)
            {
              CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
              *(void *)OsLogContext buf = 0;
              sub_10004EFE4(buf, &ValueAtIndex);
              uint64_t v46 = *(const void **)buf;
              *(void *)OsLogContext buf = 0;
              sub_100057D78((const void **)buf);
            }
          }
          else
          {
            CFTypeRef ValueAtIndex = CFDictionaryGetValue(*(CFDictionaryRef *)v50, @"apns");
            *(void *)OsLogContext buf = 0;
            sub_10004EFE4(buf, &ValueAtIndex);
            unint64_t v30 = v48;
            unint64_t v48 = *(const void **)buf;
            *(void *)OsLogContext buf = v30;
            sub_100057D78((const void **)buf);
            if (v48) {
              char v31 = sub_100080778;
            }
            else {
              char v31 = 0;
            }
            std::string::size_type v32 = *(NSObject **)(a1 + 40);
            BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
            if (v31)
            {
              if (v33)
              {
                *(_WORD *)OsLogContext buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Found a dictionary of APN settings in the managed profile", buf, 2u);
              }
              sub_100058140(&v46, &v48);
            }
            else if (v33)
            {
              *(_WORD *)OsLogContext buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Found garbage for the APN settings in the managed profile", buf, 2u);
            }
          }
          sub_100057D78(&v48);
          sub_100044D00((const void **)&theArray);
        }
        else
        {
          int v29 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)OsLogContext buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I IPCU old style file is of incompatible format - skipped", buf, 2u);
          }
        }
        sub_100057D78((const void **)v50);
        FileSystemInterface::~FileSystemInterface((FileSystemInterface *)__p);
      }
      char v34 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (v46) {
          int v35 = sub_100080778;
        }
        else {
          int v35 = 0;
        }
        if (v35) {
          uint64_t v36 = "";
        }
        else {
          uint64_t v36 = "not ";
        }
        *(_DWORD *)OsLogContext buf = 136315138;
        *(void *)&uint8_t buf[4] = v36;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I IPCU APN %sfound (old style)", buf, 0xCu);
      }
      *(void *)OsLogContext buf = v43;
      uint64_t v43 = v46;
      uint64_t v46 = 0;
      sub_100057D78((const void **)buf);
      sub_100057D78(&v46);
    }
    if (v8 != &v43)
    {
      *(void *)OsLogContext buf = *v8;
      const char *v8 = v43;
      uint64_t v43 = 0;
      sub_100057D78((const void **)buf);
    }
    sub_100057D78(&v43);
    uint64_t v37 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s%sIPCU APN:", buf, 0x16u);
    }
    *(void *)OsLogContext buf = off_101A99870;
    *(void *)&uint8_t buf[8] = a1;
    BOOL v52 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
    __p[0] = 0;
    *(void *)OsLogContext buf = CFDictionaryGetValue(theDict, @"AttachAPN");
    sub_10004EFE4(__p, (CFTypeRef *)buf);
    if (__p[0]) {
      std::string::size_type v38 = sub_100080778;
    }
    else {
      std::string::size_type v38 = 0;
    }
    if (!v38)
    {
      uint64_t v39 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)OsLogContext buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I No AttachAPN in IPCU profile", buf, 2u);
      }
    }
    if (v4 != __p)
    {
      *(void *)OsLogContext buf = *v4;
      *int v4 = __p[0];
      __p[0] = 0;
      sub_100057D78((const void **)buf);
    }
    sub_100057D78((const void **)__p);
    long long v40 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sIPCU AttachAPN:", buf, 0x16u);
    }
    *(void *)OsLogContext buf = off_101A998F0;
    *(void *)&uint8_t buf[8] = a1;
    BOOL v52 = buf;
    logger::CFTypeRefLogger();
    sub_10012C330(buf);
    goto LABEL_95;
  }
  CFNumberRef v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v42 = *(void *)&buf[16];
    CFNumberRef v15 = __p;
    if ((buf[23] & 0x80u) != 0) {
      CFNumberRef v15 = *(void ***)buf;
    }
    *(_DWORD *)uint64_t v50 = 136315138;
    *(void *)&v50[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I No IPCU profile or missing key '%s'", v50, 0xCu);
    if (SHIBYTE(v42) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_95:
  sub_1011A084C(a1, v3, v45);
  sub_100057D78((const void **)&theDict);
  sub_100057D78(&v45);
  std::mutex::unlock((std::mutex *)(a1 + 48));
}

void sub_1011A2DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, const void *a14, const void *a15, uint64_t a16, const void *a17, const void *a18, const void *a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_100057D78(&a17);
  sub_100044D00(&a18);
  sub_100057D78(&a19);
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a9);
  sub_100057D78(&a15);
  sub_100057D78(&a12);
  sub_100057D78(&a13);
  sub_100057D78(&a14);
  std::mutex::unlock(v26);
  _Unwind_Resume(a1);
}

void sub_1011A2EBC()
{
}

void *sub_1011A2ED0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A99870;
  result[1] = v3;
  return result;
}

uint64_t sub_1011A2F18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A99870;
  a2[1] = v2;
  return result;
}

void sub_1011A2F44(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v4 = a2;
    }
    else {
      int v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    CFNumberRef v8 = "";
    __int16 v9 = 2080;
    CFAllocatorRef v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1011A3010(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011A3050()
{
}

void sub_1011A3060()
{
}

void *sub_1011A3074(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A998F0;
  result[1] = v3;
  return result;
}

uint64_t sub_1011A30BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A998F0;
  a2[1] = v2;
  return result;
}

void sub_1011A30E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v4 = a2;
    }
    else {
      int v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    CFNumberRef v8 = "";
    __int16 v9 = 2080;
    CFAllocatorRef v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_1011A31B4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011A31F4()
{
}

void *sub_1011A3200@<X0>(Registry **a1@<X1>, int *a2@<X2>, NSObject **a3@<X3>, void *a4@<X8>)
{
  CFNumberRef v8 = operator new(0x48uLL);
  uint64_t result = sub_1011A3274(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1011A3260(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1011A3274(void *a1, Registry **a2, int *a3, NSObject **a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A99970;
  sub_1011A3370((uint64_t)(a1 + 3), a2, *a3, a4);
  return a1;
}

void sub_1011A32C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1011A32D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A99970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011A32F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A99970;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011A3348(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1011A3370(uint64_t a1, Registry **a2, int a3, NSObject **a4)
{
  *(void *)a1 = off_101A4D980;
  *(_DWORD *)(a1 + 8) = a3;
  uint64_t v6 = *a4;
  *(void *)(a1 + 16) = *a4;
  if (v6)
  {
    dispatch_retain(v6);
    a3 = *(_DWORD *)(a1 + 8);
  }
  *(void *)a1 = off_101A99540;
  __int16 v7 = "ipcu-apn.?";
  if (a3 == 2) {
    __int16 v7 = "ipcu-apn.2";
  }
  if (a3 == 1) {
    CFNumberRef v8 = "ipcu-apn.1";
  }
  else {
    CFNumberRef v8 = v7;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v19, kCtLoggingSystemName, v8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v20, &v19);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 24), (const ctu::OsLogLogger *)v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  *(void *)a1 = off_101A99540;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  CFAllocatorRef v10 = ServiceMap;
  CFNumberRef v11 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    unint64_t v12 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      CFNumberRef v11 = (char *)v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  v19.var0 = v11;
  CFNumberRef v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v19);
  if (!v15)
  {
    uint64_t v17 = 0;
    goto LABEL_15;
  }
  uint64_t v17 = v15[3];
  CFNumberRef v16 = (std::__shared_weak_count *)v15[4];
  if (!v16)
  {
LABEL_15:
    std::mutex::unlock(v10);
    CFNumberRef v16 = 0;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v16);
LABEL_16:
  *(void *)(a1 + 32) = v17;
  *(void *)(a1 + 40) = v16;
  return a1;
}

void sub_1011A3508(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  *uint64_t v2 = v3;
  int v5 = v2[2];
  if (v5) {
    dispatch_release(v5);
  }
  _Unwind_Resume(a1);
}

void sub_1011A3554(uint64_t a1, uint64_t a2, unsigned int a3, const char *a4)
{
  memset(&__str, 0, sizeof(__str));
  sub_1007DF5E4(a1 + 64, &v56);
  uint64_t v8 = std::string::insert(&v56, 0, "Carrier:", 8uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v57.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  CFAllocatorRef v10 = std::string::append(&v57, ", Error domain: ", 0x10uLL);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v58.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  int v12 = *(char *)(a2 + 23);
  if (v12 >= 0) {
    uint64_t v13 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v13 = *(const std::string::value_type **)a2;
  }
  if (v12 >= 0) {
    std::string::size_type v14 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v14 = *(void *)(a2 + 8);
  }
  CFNumberRef v15 = std::string::append(&v58, v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v59.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = std::string::append(&v59, " and error code:", 0x10uLL);
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v60.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v55, a3);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    OsLogContext v19 = &v55;
  }
  else {
    OsLogContext v19 = (std::string *)v55.__r_.__value_.__r.__words[0];
  }
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v55.__r_.__value_.__l.__size_;
  }
  long long v21 = std::string::append(&v60, (const std::string::value_type *)v19, size);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v61.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  char v23 = std::string::append(&v61, ", Location:", 0xBuLL);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  *(void *)&v48[16] = *((void *)&v23->__r_.__value_.__l + 2);
  *(_OWORD *)unint64_t v48 = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  if (a4[23] < 0) {
    a4 = *(const char **)a4;
  }
  size_t v25 = strlen(a4);
  CFArrayRef v26 = std::string::append((std::string *)v48, a4, v25);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  __str.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if ((v48[23] & 0x80000000) != 0) {
    operator delete(*(void **)v48);
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v60.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
  memset(&v48[8], 0, 32);
  uint64_t v49 = 0x900000000000000;
  *(_OWORD *)&v50[8] = 0u;
  long long v54 = 0u;
  long long v53 = 0u;
  memset(&v51, 0, sizeof(v51));
  uint64_t v52 = 23;
  qmemcpy(&v48[23], "\tCBOverlay", 10);
  qmemcpy(v48, "Telephony", 9);
  v50[23] = 19;
  qmemcpy(v50, "OverlayWriteFailure", 19);
  std::string::operator=(&v51, &__str);
  v52 |= 1uLL;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  int v29 = ServiceMap;
  if ((v30 & 0x8000000000000000) != 0)
  {
    char v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v32 = 5381;
    do
    {
      std::string::size_type v30 = v32;
      unsigned int v33 = *v31++;
      uint64_t v32 = (33 * v32) ^ v33;
    }
    while (v33);
  }
  std::mutex::lock(ServiceMap);
  v61.__r_.__value_.__r.__words[0] = v30;
  char v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&v61);
  if (v34)
  {
    uint64_t v36 = v34[3];
    int v35 = (std::__shared_weak_count *)v34[4];
    if (v35)
    {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v35);
      char v37 = 0;
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v36 = 0;
  }
  std::mutex::unlock(v29);
  int v35 = 0;
  char v37 = 1;
LABEL_39:
  sub_1000DB86C((char *)__dst, (long long *)v48);
  v63[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v36 + 16))(v36, __dst, v63);
  sub_1000DBADC(v63);
  if (v47 < 0) {
    operator delete(__p);
  }
  if (v45 < 0) {
    operator delete(v44);
  }
  if (v43 < 0) {
    operator delete(v42);
  }
  if (v41 < 0) {
    operator delete(v40);
  }
  if ((v39 & 0x80000000) == 0)
  {
    if (v37) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }
  operator delete(__dst[0]);
  if ((v37 & 1) == 0) {
LABEL_49:
  }
    sub_10004D2C8(v35);
LABEL_50:
  if (SBYTE7(v54) < 0) {
    operator delete((void *)v53);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if ((v50[23] & 0x80000000) != 0) {
    operator delete(*(void **)v50);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete(*(void **)&v48[24]);
  }
  if ((v48[23] & 0x80000000) != 0) {
    operator delete(*(void **)v48);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1011A3A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p)
{
  sub_1000DBADC((void *)(v29 - 88));
  sub_1001278A0((uint64_t)&a10);
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  sub_1001278A0((uint64_t)&__p);
  if (*(char *)(v29 - 89) < 0) {
    operator delete(*(void **)(v29 - 112));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011A3B40(uint64_t result, int a2)
{
  if (result)
  {
    CFStringRef v3 = (const __CFString *)result;
    if (CFStringCompare((CFStringRef)result, @"EncryptedIdentity", 0))
    {
      if (CFStringCompare(v3, @"EntitlementPseudoID", 0)
        && (a2 != 1 || CFStringCompare(v3, @"PseudoID", 0)))
      {
        return 0;
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void sub_1011A3BCC()
{
}

void sub_1011A3F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object, dispatch_object_t a16, void *a17, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

uint64_t sub_1011A4124(uint64_t a1)
{
  *(void *)a1 = off_101A999C0;
  sub_1001FEC70(*(void **)(a1 + 344));
  sub_1000886C0(a1 + 312, *(char **)(a1 + 320));
  sub_10010C0E0(a1 + 288, *(void **)(a1 + 296));
  sub_1000346F8(a1 + 264, *(void **)(a1 + 272));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 96));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFStringRef v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  EncryptedIdentity::~EncryptedIdentity((EncryptedIdentity *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1011A41DC(uint64_t a1)
{
  sub_1011A4124(a1);

  operator delete();
}

void sub_1011A4214(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

const void **sub_1011A433C(const void **result, int a2)
{
  if (*((unsigned __int8 *)result + 360) != a2)
  {
    uint64_t v2 = result;
    *((unsigned char *)result + 360) = a2;
    if (a2)
    {
      CFStringRef v3 = (const void **)result[42];
      int v4 = result + 43;
      if (v3 != result + 43)
      {
        do
        {
          uint64_t result = sub_1011A51F4(v2, (uint64_t)v3[7]);
          int v5 = (const void **)v3[1];
          if (v5)
          {
            do
            {
              uint64_t v6 = v5;
              int v5 = (const void **)*v5;
            }
            while (v5);
          }
          else
          {
            do
            {
              uint64_t v6 = (const void **)v3[2];
              BOOL v7 = *v6 == v3;
              CFStringRef v3 = v6;
            }
            while (!v7);
          }
          CFStringRef v3 = v6;
        }
        while (v6 != v4);
      }
    }
  }
  return result;
}

capabilities::ct *sub_1011A43CC(uint64_t a1, uint64_t a2)
{
  sub_1011A621C(a1, a2);
  *(_DWORD *)(a2 + 112) = 0;
  uint64_t v4 = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a2 + 104);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  if (v5) {
    sub_10004D2C8(v5);
  }
  *(_DWORD *)(a2 + 128) = 0;
  v88 = 0;
  int v81 = (uint64_t *)(a1 + 48);
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(a1 + 48), *(Registry **)(a1 + 48));
  BOOL v7 = ServiceMap;
  uint64_t v9 = v8;
  if (v8 < 0)
  {
    CFAllocatorRef v10 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)OsLogContext buf = v9;
  uint64_t v13 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    std::string::size_type v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v7);
  std::string::size_type v14 = 0;
  char v16 = 1;
LABEL_13:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v15 + 96))(&v88, v15, *(unsigned int *)(*(void *)a2 + 52), 1, @"EncryptedIdentity", 0, 0);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  v87 = 0;
  sub_1011A6DA8((uint64_t)&v87, a1, a2, @"UpdateURL");
  if (v88) {
    uint64_t v17 = sub_100080934;
  }
  else {
    uint64_t v17 = 0;
  }
  if (v17 && (v87 ? (long long v18 = sub_100080934) : (long long v18 = 0), v18))
  {
    int v86 = 48;
    long long v85 = 0;
    sub_1011A6DA8((uint64_t)buf, a1, a2, @"UpdatePeriod");
    sub_1000842D0(&v85, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v85) {
      CFTypeID v20 = sub_100081E58;
    }
    else {
      CFTypeID v20 = 0;
    }
    if (v20) {
      ctu::cf::assign((ctu::cf *)&v86, v85, v19);
    }
    CFBooleanRef BOOLean = 0;
    sub_1011A6DA8((uint64_t)&cf, a1, a2, @"UpdateOnBootup");
    *(void *)__dst = cf;
    if (cf) {
      CFRetain(cf);
    }
    v89[0] = 0;
    *(void *)OsLogContext buf = 0;
    sub_1000057AC(buf, (CFTypeRef *)__dst);
    if (*(void *)buf) {
      long long v21 = sub_100084B4C;
    }
    else {
      long long v21 = 0;
    }
    if (v21) {
      sub_1005AED68(v89, (const void **)buf);
    }
    sub_100062778((const void **)buf);
    CFBooleanRef BOOLean = (CFBooleanRef)v89[0];
    v89[0] = 0;
    sub_100062778(v89);
    sub_1000577C4((const void **)__dst);
    sub_1000577C4(&cf);
    if (BOOLean) {
      long long v22 = sub_100084B4C;
    }
    else {
      long long v22 = 0;
    }
    if (v22) {
      int Value = CFBooleanGetValue(BOOLean);
    }
    else {
      int Value = 1;
    }
    if (v86)
    {
      uint64_t v26 = 60 * v86;
      long long v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        *(_DWORD *)OsLogContext buf = 136315650;
        *(void *)&uint8_t buf[4] = v28;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2048;
        uint64_t v91 = (void *)v26;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%sConfigured update period %ld minutes", buf, 0x20u);
      }
      uint64_t v29 = *(std::__shared_weak_count **)(a1 + 16);
      if (v29)
      {
        uint64_t v30 = *(void *)(a1 + 8);
        char v31 = std::__shared_weak_count::lock(v29);
        if (v31)
        {
          uint64_t v32 = v31;
          atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v31);
          memset(__dst, 0, sizeof(__dst));
          unsigned int v33 = *(PersonalityInfo **)a2;
          if (*(char *)(*(void *)a2 + 47) < 0)
          {
            sub_10004FC84(__dst, *((void **)v33 + 3), *((void *)v33 + 4));
          }
          else
          {
            *(_OWORD *)__dst = *(_OWORD *)((char *)v33 + 24);
            *(void *)&__dst[16] = *((void *)v33 + 5);
          }
          *(void *)OsLogContext buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3321888768;
          *(void *)&uint8_t buf[16] = sub_1011A9D80;
          uint64_t v91 = &unk_101A99A20;
          uint64_t v92 = a1;
          uint64_t v93 = v30;
          uint64_t v94 = v32;
          atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          if ((char)__dst[23] < 0)
          {
            sub_10004FC84(__p, *(void **)__dst, *(unint64_t *)&__dst[8]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)__dst;
            __p[2] = *(void **)&__dst[16];
          }
          sub_100D2031C();
        }
      }
      sub_100088B9C();
    }
    sub_1011AA074(a1, a2);
    char v34 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v35;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I %s%sPeriodic update disabled.", buf, 0x16u);
    }
    if (Value)
    {
      uint64_t v36 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        *(_DWORD *)__dst = 136315394;
        *(void *)&__dst[4] = v37;
        *(_WORD *)&__dst[12] = 2080;
        *(void *)&__dst[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%sstart initial certificate update", __dst, 0x16u);
      }
      *(unsigned char *)(a2 + 116) = 1;
      sub_1011A51F4((const void **)a1, a2);
    }
    sub_100062778((const void **)&BOOLean);
    sub_1000570E8((const void **)&v85);
  }
  else
  {
    long long v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%scertificate update is not supported", buf, 0x16u);
    }
    sub_1011AA074(a1, a2);
    *(unsigned char *)(a2 + 116) = 0;
  }
  sub_1000577C4(&v87);
  uint64_t result = (capabilities::ct *)sub_1000577C4(&v88);
  char v39 = *(void **)(a1 + 336);
  if (v39 != (void *)(a1 + 344))
  {
    uint64_t v80 = kIWLANSettingsKey;
    while (1)
    {
      uint64_t v82 = v39[7];
      if (!capabilities::ct::supportsVoiceCall(result))
      {
        char v51 = 0;
        goto LABEL_88;
      }
      long long v40 = operator new(0x10uLL);
      *(void *)&__dst[8] = v40 + 2;
      *(void *)&__dst[16] = v40 + 2;
      void *v40 = v80;
      v40[1] = @"WiFiCallingIdentityProtectionMethod";
      *(void *)__dst = v40;
      v89[0] = 0;
      char v41 = (std::mutex *)Registry::getServiceMap(v81, (Registry *)*v81);
      uint64_t v42 = v41;
      uint64_t v43 = v8;
      if (v8 < 0)
      {
        uint64_t v44 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v45 = 5381;
        do
        {
          uint64_t v43 = v45;
          unsigned int v46 = *v44++;
          uint64_t v45 = (33 * v45) ^ v46;
        }
        while (v46);
      }
      std::mutex::lock(v41);
      *(void *)OsLogContext buf = v43;
      char v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)buf);
      if (!v47) {
        break;
      }
      uint64_t v49 = v47[3];
      unint64_t v48 = (std::__shared_weak_count *)v47[4];
      if (!v48) {
        goto LABEL_75;
      }
      atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v42);
      atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v48);
      char v50 = 0;
LABEL_76:
      (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint8_t *, void, void))(*(void *)v49 + 104))(&v88, v49, *(unsigned int *)(*(void *)v82 + 52), 1, __dst, 0, 0);
      sub_100056248(v89, &v88);
      sub_1000577C4(&v88);
      if ((v50 & 1) == 0) {
        sub_10004D2C8(v48);
      }
      if (v89[0]) {
        uint64_t v52 = sub_1000810B8;
      }
      else {
        uint64_t v52 = 0;
      }
      if (v52 && (CFTypeID v53 = CFGetTypeID(v89[0]), v53 == CFStringGetTypeID()))
      {
        char v51 = sub_1011A3B40((uint64_t)v89[0], 0);
      }
      else
      {
        long long v54 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v77 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v82);
          if (v89[0]) {
            uint64_t v78 = sub_1000810B8;
          }
          else {
            uint64_t v78 = 0;
          }
          *(_DWORD *)OsLogContext buf = 136315650;
          BOOL v73 = v78 == 0;
          *(void *)&uint8_t buf[4] = v77;
          uint64_t v79 = "a string";
          if (v73) {
            uint64_t v79 = "found";
          }
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v91 = (void *)v79;
          _os_log_debug_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "#D %s%sWiFiCalling identity protection method is not %s", buf, 0x20u);
        }
        char v51 = 0;
      }
      sub_1000558F4(v89);
      if (*(void *)__dst)
      {
        *(void *)&__dst[8] = *(void *)__dst;
        operator delete(*(void **)__dst);
      }
LABEL_88:
      buf[0] = 0;
      *((unsigned char *)sub_1011AECC4((uint64_t **)(v82 + 16), 0, buf) + 26) = v51;
      std::string v55 = operator new(8uLL);
      *(void *)__dst = v55;
      *std::string v55 = @"WiFiHotspotIdentityProtectionMethod";
      *(void *)&__dst[8] = v55 + 1;
      *(void *)&__dst[16] = v55 + 1;
      v89[0] = 0;
      std::string v56 = (std::mutex *)Registry::getServiceMap(v81, (Registry *)*v81);
      std::string v57 = v56;
      uint64_t v58 = v8;
      if (v8 < 0)
      {
        std::string v59 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v60 = 5381;
        do
        {
          uint64_t v58 = v60;
          unsigned int v61 = *v59++;
          uint64_t v60 = (33 * v60) ^ v61;
        }
        while (v61);
      }
      std::mutex::lock(v56);
      *(void *)OsLogContext buf = v58;
      uint64_t v62 = sub_10004D37C(&v57[1].__m_.__sig, (unint64_t *)buf);
      if (!v62)
      {
        uint64_t v64 = 0;
LABEL_95:
        std::mutex::unlock(v57);
        char v63 = 0;
        char v65 = 1;
        goto LABEL_96;
      }
      uint64_t v64 = v62[3];
      char v63 = (std::__shared_weak_count *)v62[4];
      if (!v63) {
        goto LABEL_95;
      }
      atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v57);
      atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v63);
      char v65 = 0;
LABEL_96:
      (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint8_t *, void, void))(*(void *)v64 + 104))(&v88, v64, *(unsigned int *)(*(void *)v82 + 52), 1, __dst, 0, 0);
      sub_100056248(v89, &v88);
      sub_1000577C4(&v88);
      if ((v65 & 1) == 0) {
        sub_10004D2C8(v63);
      }
      if (v89[0]) {
        int v66 = sub_1000810B8;
      }
      else {
        int v66 = 0;
      }
      if (v66 && (CFTypeID v67 = CFGetTypeID(v89[0]), v67 == CFStringGetTypeID()))
      {
        char v68 = sub_1011A3B40((uint64_t)v89[0], 1);
      }
      else
      {
        uint64_t v69 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v74 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v82);
          if (v89[0]) {
            int v75 = sub_1000810B8;
          }
          else {
            int v75 = 0;
          }
          *(_DWORD *)OsLogContext buf = 136315650;
          BOOL v73 = v75 == 0;
          *(void *)&uint8_t buf[4] = v74;
          uint64_t v76 = "a string";
          if (v73) {
            uint64_t v76 = "found";
          }
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v91 = (void *)v76;
          _os_log_debug_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEBUG, "#D %s%sWiFiHotspot identity protection method is not %s", buf, 0x20u);
        }
        if (*(void *)(v82 + 40)) {
          uint64_t v70 = sub_1008A95D4;
        }
        else {
          uint64_t v70 = 0;
        }
        char v68 = v70 != 0;
      }
      sub_1000558F4(v89);
      if (*(void *)__dst)
      {
        *(void *)&__dst[8] = *(void *)__dst;
        operator delete(*(void **)__dst);
      }
      buf[0] = 1;
      uint64_t result = (capabilities::ct *)sub_1011AECC4((uint64_t **)(v82 + 16), 1u, buf);
      *((unsigned char *)result + 26) = v68;
      int v71 = (void *)v39[1];
      if (v71)
      {
        do
        {
          int64_t v72 = v71;
          int v71 = (void *)*v71;
        }
        while (v71);
      }
      else
      {
        do
        {
          int64_t v72 = (void *)v39[2];
          BOOL v73 = *v72 == (void)v39;
          char v39 = v72;
        }
        while (!v73);
      }
      char v39 = v72;
      if (v72 == (void *)(a1 + 344)) {
        return result;
      }
    }
    uint64_t v49 = 0;
LABEL_75:
    std::mutex::unlock(v42);
    unint64_t v48 = 0;
    char v50 = 1;
    goto LABEL_76;
  }
  return result;
}

void sub_1011A505C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20,const void *a21,const void *a22,uint64_t a23,const void *a24,const void *a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a44 < 0) {
    operator delete(__p);
  }
  if (a38) {
    std::__shared_weak_count::__release_weak(a38);
  }
  if (*(char *)(v45 - 105) < 0) {
    operator delete(*(void **)(v45 - 128));
  }
  std::__shared_weak_count::__release_weak(v44);
  sub_100062778(&a21);
  sub_1000570E8(&a22);
  sub_1000577C4(&a24);
  sub_1000577C4(&a25);
  _Unwind_Resume(a1);
}

const void **sub_1011A51F4(const void **result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 116)) {
    BOOL v2 = *(void *)(a2 + 96) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2 && !*(void *)(a2 + 120) && *(_DWORD *)(a2 + 112) <= 4u)
  {
    int v5 = result;
    if (*((unsigned char *)result + 360) || *((unsigned char *)result + 361))
    {
      uint64_t v6 = result[5];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        *(_DWORD *)OsLogContext buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%srefreshCertificates needed", buf, 0x16u);
      }
      uint64_t v74 = 0;
      sub_1011A6DA8((uint64_t)buf, (uint64_t)v5, a2, @"UpdateURL");
      sub_100056248(&v74, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      if (v74) {
        uint64_t v8 = sub_1000810B8;
      }
      else {
        uint64_t v8 = 0;
      }
      if (!v8) {
        return sub_1000558F4(&v74);
      }
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)int64_t v72 = *(_OWORD *)buf;
      uint64_t v73 = *(void *)&buf[16];
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 3221225472;
      aBlock[2] = sub_1011AB1A0;
      aBlock[3] = &unk_101A99A80;
      aBlock[4] = v5;
      uint64_t v9 = _Block_copy(aBlock);
      if (*(char *)(a2 + 71) >= 0) {
        uint64_t v10 = *(unsigned __int8 *)(a2 + 71);
      }
      else {
        uint64_t v10 = *(void *)(a2 + 56);
      }
      uint64_t v11 = v5[5];
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      uint64_t v70 = v9;
      if (v10)
      {
        if (v12)
        {
          uint64_t v13 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
          if (*(char *)(a2 + 71) >= 0) {
            std::string::size_type v14 = (void **)(a2 + 48);
          }
          else {
            std::string::size_type v14 = *(void ***)(a2 + 48);
          }
          *(_DWORD *)OsLogContext buf = 136315650;
          *(void *)&uint8_t buf[4] = v13;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          *(_WORD *)&unsigned char buf[22] = 2080;
          v87 = v14;
          uint64_t v15 = "#I %s%s_____________>  Sending refresh request for key-identifier: [%s]";
          char v16 = v11;
          uint32_t v17 = 32;
          goto LABEL_29;
        }
      }
      else if (v12)
      {
        uint64_t v18 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        *(_DWORD *)OsLogContext buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        uint64_t v15 = "#I %s%s_____________>  Sending refresh request without key-identifier";
        char v16 = v11;
        uint32_t v17 = 22;
LABEL_29:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
      strcpy(v80, "Accept");
      strcpy((char *)v96, "Accept-Encoding");
      strcpy((char *)v85, "Content-Type");
      strcpy((char *)__dst, "Content-Encoding");
      strcpy(__s, "User-Agent");
      strcpy(v79, "gzip");
      strcpy((char *)v83, "application/json");
      int v75 = 0;
      v76[0] = 0;
      v76[1] = 0;
      sub_100E79688(buf, v80, (char *)v83);
      sub_100E796DC(&v89, (char *)v96, v79);
      sub_100637AF8(v93, (char *)v85, (char *)v83);
      sub_100E79730(v94, (char *)__dst, v79);
      sub_1002369E0((uint64_t)&v75, (long long *)buf, 4);
      for (uint64_t i = 0; i != -24; i -= 6)
      {
        CFTypeID v20 = &buf[i * 8];
        if (SHIBYTE(v94[i + 5]) < 0) {
          operator delete(*((void **)v20 + 21));
        }
        if ((char)v20[167] < 0) {
          operator delete(*((void **)v20 + 18));
        }
      }
      value = 0;
      sub_1011A6DA8((uint64_t)&value, (uint64_t)v5, a2, @"UserAgent");
      if (value) {
        long long v21 = sub_100080934;
      }
      else {
        long long v21 = 0;
      }
      if (v21)
      {
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v78 = *(void *)&buf[16];
        if ((buf[23] & 0x80u) == 0) {
          long long v22 = (char *)__p;
        }
        else {
          long long v22 = (char *)__p[0];
        }
      }
      else
      {
        long long v22 = "Apple device";
      }
      sub_100058DB0(buf, __s);
      CFTypeRef cf = buf;
      char v23 = sub_10014BECC(&v75, (uint64_t)buf, (uint64_t)&unk_10144E20E, (_OWORD **)&cf);
      sub_10003ED78((std::string *)((char *)v23 + 56), v22);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      if (v21 && SHIBYTE(v78) < 0) {
        operator delete(__p[0]);
      }
      sub_1000577C4((const void **)&value);
      long long v24 = v5[5];
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        uint64_t v26 = v72;
        if (v73 < 0) {
          uint64_t v26 = (void **)v72[0];
        }
        *(_DWORD *)OsLogContext buf = 136315650;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        v87 = v26;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%sRequesting: %s", buf, 0x20u);
      }
      uint64_t v69 = (const __CFString ***)(a2 + 48);
      long long v27 = v75;
      if (v75 != (uint64_t *)v76)
      {
        do
        {
          uint64_t v28 = v5[5];
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v29 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
            uint64_t v30 = (void **)(v27 + 4);
            if (*((char *)v27 + 55) < 0) {
              uint64_t v30 = (void **)*v30;
            }
            char v31 = v27 + 7;
            if (*((char *)v27 + 79) < 0) {
              char v31 = (void *)*v31;
            }
            *(_DWORD *)OsLogContext buf = 136315906;
            *(void *)&uint8_t buf[4] = v29;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            v87 = v30;
            LOWORD(v88) = 2080;
            *(void *)((char *)&v88 + 2) = v31;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%s  %s: %s", buf, 0x2Au);
          }
          uint64_t v32 = (uint64_t *)v27[1];
          if (v32)
          {
            do
            {
              unsigned int v33 = v32;
              uint64_t v32 = (uint64_t *)*v32;
            }
            while (v32);
          }
          else
          {
            do
            {
              unsigned int v33 = (uint64_t *)v27[2];
              BOOL v2 = *v33 == (void)v27;
              long long v27 = v33;
            }
            while (!v2);
          }
          long long v27 = v33;
        }
        while (v33 != (uint64_t *)v76);
      }
      v96[0] = 0;
      v96[1] = 0;
      ctu::Http::HttpRequest::create();
      uint64_t v35 = *(void *)buf;
      uint64_t v34 = *(void *)&buf[8];
      *(void *)OsLogContext buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      if (v96[1]) {
        sub_10004D2C8((std::__shared_weak_count *)v96[1]);
      }
      if (!v35)
      {
        char v41 = v5[5];
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
          *(_DWORD *)OsLogContext buf = 136315394;
          *(void *)&uint8_t buf[4] = v42;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#W %s%sUnable to allocate request", buf, 0x16u);
        }
        goto LABEL_130;
      }
      v85[0] = 0;
      v85[1] = 0;
      *(void *)__s = 0;
      ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)__s);
      CFTypeRef cf = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFTypeRef v38 = cf;
        CFTypeRef cf = Mutable;
        *(void *)OsLogContext buf = v38;
        sub_10005717C((const void **)buf);
      }
      if (*(char *)(a2 + 71) < 0)
      {
        if (!*(void *)(a2 + 56)) {
          goto LABEL_81;
        }
        char v39 = (__CFDictionary *)cf;
        long long v40 = *v69;
      }
      else
      {
        if (!*(unsigned char *)(a2 + 71)) {
          goto LABEL_81;
        }
        char v39 = (__CFDictionary *)cf;
        long long v40 = (const __CFString **)(a2 + 48);
      }
      v83[0] = 0;
      __dst[0] = 0;
      if (ctu::cf::convert_copy((ctu::cf *)__dst, v40, (const char *)0x8000100, kCFAllocatorDefault, v37))
      {
        uint64_t v43 = v83[0];
        v83[0] = __dst[0];
        *(void *)OsLogContext buf = v43;
        sub_1000558F4((const void **)buf);
      }
      value = (void *)v83[0];
      v83[0] = 0;
      sub_1000558F4(v83);
      CFDictionarySetValue(v39, @"key-identifier", value);
      sub_1000558F4((const void **)&value);
LABEL_81:
      __dst[0] = (void *)cf;
      if (cf)
      {
        CFRetain(cf);
        uint64_t v44 = __dst[0];
      }
      else
      {
        uint64_t v44 = 0;
      }
      unsigned int v45 = +[NSJSONSerialization isValidJSONObject:](NSJSONSerialization, "isValidJSONObject:", v44, v69);
      sub_10005717C((const void **)__dst);
      if (v45)
      {
        v83[0] = 0;
        value = (void *)cf;
        if (cf)
        {
          CFRetain(cf);
          unsigned int v46 = value;
        }
        else
        {
          unsigned int v46 = 0;
        }
        char v51 = +[NSJSONSerialization dataWithJSONObject:v46 options:1 error:v83];
        sub_10005717C((const void **)&value);
        if (v51)
        {
          if ([(NSData *)v51 length])
          {
            [(NSData *)v51 bytes];
            operator new();
          }
          operator new();
        }
        uint64_t v52 = v5[5];
        if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_97;
        }
        id v53 = objc_msgSend(objc_msgSend((id)v83[0], "description"), "UTF8String");
        *(_DWORD *)OsLogContext buf = 136315138;
        *(void *)&uint8_t buf[4] = v53;
        unint64_t v48 = "#E Unable to serialize properly, error: %s";
        uint64_t v49 = v52;
        uint32_t v50 = 12;
      }
      else
      {
        char v47 = v5[5];
        if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
LABEL_97:
          sub_10005717C(&cf);
          ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)__s);
          uint64_t v54 = v85[0];
          if (v85[0])
          {
            std::string v55 = v5[5];
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v56 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
              std::string v57 = (void **)(*(void *)(v85[0] + 8) - *(void *)v85[0]);
              *(_DWORD *)OsLogContext buf = 136315650;
              *(void *)&uint8_t buf[4] = v56;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = " ";
              *(_WORD *)&unsigned char buf[22] = 2048;
              v87 = v57;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I %s%sBody: %zu bytes", buf, 0x20u);
              uint64_t v54 = v85[0];
            }
            (*(void (**)(uint64_t, uint64_t))(*(void *)v35 + 56))(v35, v54);
          }
          __dst[0] = 0;
          sub_1011A6DA8((uint64_t)buf, (uint64_t)v5, a2, @"UpdateRequestTimeout");
          sub_1000842D0(__dst, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          if (__dst[0]) {
            std::string v59 = sub_100081E58;
          }
          else {
            std::string v59 = 0;
          }
          if (v59)
          {
            *(void *)OsLogContext buf = 0;
            ctu::cf::assign((ctu::cf *)buf, (unint64_t *)__dst[0], v58);
            unint64_t v60 = *(void *)buf;
          }
          else
          {
            unint64_t v60 = 30;
          }
          sub_1000570E8((const void **)__dst);
          (*(void (**)(uint64_t, double))(*(void *)v35 + 96))(v35, (double)v60);
          (*(void (**)(uint64_t, const void *))(*(void *)v35 + 8))(v35, v5[3]);
          memset(__dst, 0, 24);
          unsigned int v61 = *(PersonalityInfo **)a2;
          if (*(char *)(*(void *)a2 + 47) < 0)
          {
            sub_10004FC84(__dst, *((void **)v61 + 3), *((void *)v61 + 4));
          }
          else
          {
            *(_OWORD *)__dst = *(_OWORD *)((char *)v61 + 24);
            __dst[2] = *((void **)v61 + 5);
          }
          uint64_t v62 = (std::__shared_weak_count *)v5[2];
          if (!v62 || (char v63 = v5[1], (v64 = std::__shared_weak_count::lock(v62)) == 0)) {
            sub_100088B9C();
          }
          char v65 = v64;
          p_shared_weak_owners = &v64->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v64->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v64);
          *(void *)OsLogContext buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3321888768;
          *(void *)&uint8_t buf[16] = sub_1011AA1A0;
          v87 = (void **)&unk_101A99A50;
          *(void *)&long long v88 = v5;
          *((void *)&v88 + 1) = v63;
          uint64_t v89 = v65;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          if (SHIBYTE(__dst[2]) < 0)
          {
            sub_10004FC84(&v90, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            long long v90 = *(_OWORD *)__dst;
            uint64_t v91 = __dst[2];
          }
          if (v70) {
            CFTypeID v67 = _Block_copy(v70);
          }
          else {
            CFTypeID v67 = 0;
          }
          uint64_t v92 = v67;
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v35 + 16))(v35, buf);
          memset(v83, 0, 24);
          (*(void (**)(uint64_t, const void **))(*(void *)v35 + 40))(v35, v83);
          if (SHIBYTE(v83[2]) < 0) {
            operator delete((void *)v83[0]);
          }
          if (v92) {
            _Block_release(v92);
          }
          if (SHIBYTE(v91) < 0) {
            operator delete((void *)v90);
          }
          if (v89) {
            std::__shared_weak_count::__release_weak(v89);
          }
          std::__shared_weak_count::__release_weak(v65);
          if (SHIBYTE(__dst[2]) < 0) {
            operator delete(__dst[0]);
          }
          if (v85[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v85[1]);
          }
LABEL_130:
          sub_10010C0E0((uint64_t)&v75, v76[0]);
          char v68 = *(std::__shared_weak_count **)(a2 + 104);
          *(void *)(a2 + 96) = v35;
          *(void *)(a2 + 104) = v34;
          if (v68) {
            sub_10004D2C8(v68);
          }
          if (v70) {
            _Block_release(v70);
          }
          if (SHIBYTE(v73) < 0) {
            operator delete(v72[0]);
          }
          return sub_1000558F4(&v74);
        }
        *(_WORD *)OsLogContext buf = 0;
        unint64_t v48 = "#E Invalid JSON Object";
        uint64_t v49 = v47;
        uint32_t v50 = 2;
      }
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, v48, buf, v50);
      goto LABEL_97;
    }
  }
  return result;
}

void sub_1011A5F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *aBlock, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,const void *a26,__int16 a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,const void *a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  sub_10005717C(&a37);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)(v48 - 144));
  if (a47) {
    sub_10004D2C8((std::__shared_weak_count *)a47);
  }
  sub_10010C0E0((uint64_t)&a27, (void *)a28);
  if (v47) {
    sub_10004D2C8(v47);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  sub_1000558F4(&a26);
  _Unwind_Resume(a1);
}

const void **sub_1011A621C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2 + 40;
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)OsLogContext buf = v4;
  sub_100127DDC((const void **)buf);
  if (*(char *)(v5 + 31) < 0)
  {
    **(unsigned char **)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
  }
  else
  {
    *(unsigned char *)(a2 + 48) = 0;
    *(unsigned char *)(a2 + 71) = 0;
  }
  CFTypeRef cf = 0;
  memset(&__p, 0, sizeof(__p));
  v33[0] = 0;
  v33[1] = 0;
  uint64_t v34 = 0;
  uint64_t v32 = 0;
  sub_1011A6DA8((uint64_t)&v32, a1, a2, @"Certificate");
  if (v32) {
    uint64_t v6 = sub_100080934;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6)
  {
    sub_1011A6F40((uint64_t)buf, a1, (PersonalityInfo **)a2);
    *(void *)&long long v41 = cf;
    CFTypeRef cf = *(CFTypeRef *)buf;
    *(void *)OsLogContext buf = 0;
    sub_100127DDC((const void **)&v41);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = *(std::string *)&buf[8];
    buf[31] = 0;
    uint8_t buf[8] = 0;
    if (SHIBYTE(v34) < 0) {
      operator delete(v33[0]);
    }
    *(_OWORD *)unsigned int v33 = *(_OWORD *)v38;
    uint64_t v34 = v39;
    HIBYTE(v39) = 0;
    LOBYTE(v38[0]) = 0;
    sub_1000558F4(&v40);
    if (SHIBYTE(v39) < 0) {
      operator delete(v38[0]);
    }
    if ((buf[31] & 0x80000000) != 0) {
      operator delete(*(void **)&buf[8]);
    }
    sub_100127DDC((const void **)buf);
    if (cf) {
      uint64_t v7 = sub_1008A95D4;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      *(_DWORD *)(a2 + 72) = 1;
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        uint64_t v10 = v33;
        if (v34 < 0) {
          uint64_t v10 = (void **)v33[0];
        }
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)OsLogContext buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&uint8_t buf[24] = v10;
        LOWORD(v38[0]) = 2080;
        *(void **)((char *)v38 + 2) = p_p;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%susing public key override [%s], identifier [%s]", buf, 0x2Au);
      }
    }
    else
    {
      char v31 = 0;
      sub_100056248(&v31, &v32);
      if (v31) {
        BOOL v12 = sub_1000810B8;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12)
      {
        long long v41 = 0uLL;
        uint64_t v42 = 0;
        ctu::cf::assign();
        *(_OWORD *)uint64_t v29 = v41;
        uint64_t v30 = v42;
        sub_1011A68E0((uint64_t)buf, a1, (PersonalityInfo **)a2, (uint64_t)v29, (uint64_t)"CB");
        *(void *)&long long v41 = &cf;
        *((void *)&v41 + 1) = v33;
        sub_1011ABDA0((uint64_t)&v41, (uint64_t)buf);
        if ((buf[31] & 0x80000000) != 0) {
          operator delete(*(void **)&buf[8]);
        }
        sub_100127DDC((const void **)buf);
        if (SHIBYTE(v30) < 0) {
          operator delete(v29[0]);
        }
        if (cf) {
          uint64_t v13 = sub_1008A95D4;
        }
        else {
          uint64_t v13 = 0;
        }
        if (v13)
        {
          *(_DWORD *)(a2 + 72) = 0;
          v29[0] = 0;
          sub_1011A6DA8((uint64_t)buf, a1, a2, @"KeyIdentifier");
          sub_100056248(v29, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          if (v29[0]) {
            std::string::size_type v14 = sub_1000810B8;
          }
          else {
            std::string::size_type v14 = 0;
          }
          if (v14)
          {
            memset(buf, 0, 24);
            ctu::cf::assign();
            std::string::size_type v15 = *(void *)buf;
            *(void *)&long long v41 = *(void *)&buf[8];
            *(void *)((char *)&v41 + 7) = *(void *)&buf[15];
            char v16 = buf[23];
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            __p.__r_.__value_.__r.__words[0] = v15;
            __p.__r_.__value_.__l.__size_ = v41;
            *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)&v41 + 7);
            *((unsigned char *)&__p.__r_.__value_.__s + 23) = v16;
          }
          uint32_t v17 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v18 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
            CFNumberRef v19 = v33;
            if (v34 < 0) {
              CFNumberRef v19 = (void **)v33[0];
            }
            CFTypeID v20 = &__p;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              CFTypeID v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)OsLogContext buf = 136315906;
            *(void *)&uint8_t buf[4] = v18;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&uint8_t buf[24] = v19;
            LOWORD(v38[0]) = 2080;
            *(void **)((char *)v38 + 2) = v20;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%susing original public key [%s], identifier [%s]", buf, 0x2Au);
          }
          sub_1000558F4((const void **)v29);
        }
      }
      else
      {
        long long v21 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
          *(_DWORD *)OsLogContext buf = 136315394;
          *(void *)&uint8_t buf[4] = v22;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#W %s%sCB certificate is not a string field", buf, 0x16u);
        }
      }
      sub_1000558F4(&v31);
    }
  }
  CFTypeRef v23 = cf;
  if (cf) {
    long long v24 = sub_1008A95D4;
  }
  else {
    long long v24 = 0;
  }
  if (v24)
  {
    if ((CFTypeRef *)v5 != &cf)
    {
      *(void *)OsLogContext buf = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v25 = *(CFTypeRef *)v5;
      *(void *)uint64_t v5 = v23;
      *(void *)OsLogContext buf = v25;
      sub_100127DDC((const void **)buf);
    }
    std::string::operator=((std::string *)(v5 + 8), &__p);
  }
  else
  {
    uint64_t v26 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
      *(_DWORD *)OsLogContext buf = 136315394;
      *(void *)&uint8_t buf[4] = v27;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%sencrypted identity is not supported", buf, 0x16u);
    }
  }
  sub_1000577C4(&v32);
  if (SHIBYTE(v34) < 0) {
    operator delete(v33[0]);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return sub_100127DDC(&cf);
}

void sub_1011A6800(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, const void *a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,const void *a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_100127DDC(&a31);
  _Unwind_Resume(a1);
}

const void **sub_1011A68E0(uint64_t a1, uint64_t a2, PersonalityInfo **a3, uint64_t a4, uint64_t a5)
{
  char v16 = 0;
  memset(v15, 0, 7);
  BOOL v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  ctu::base64::decode();
  uint64_t v9 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(*a3);
    int buf = 136315650;
    *(void *)buf_4 = v10;
    __int16 v19 = 2080;
    CFTypeID v20 = " ";
    __int16 v21 = 2080;
    uint64_t v22 = a5;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#W %s%s%s certificate is not base64 encoded string", (uint8_t *)&buf, 0x20u);
  }
  sub_100637AC0((const void **)a1, &v16);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = v15[0];
  *(_DWORD *)(a1 + 27) = *(_DWORD *)((char *)v15 + 3);
  *(unsigned char *)(a1 + 31) = 0;
  if (v12)
  {
    uint64_t v13 = v12;
    operator delete(v12);
  }
  return sub_100127DDC(&v16);
}

void sub_1011A6CB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char a12, int a13, const void *a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100127DDC(&a19);
  _Unwind_Resume(a1);
}

void sub_1011A6DA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = (uint64_t *)operator new(0x10uLL);
  __int16 v19 = v7 + 2;
  CFTypeID v20 = v7 + 2;
  *uint64_t v7 = @"EncryptedIdentity";
  v7[1] = a4;
  std::string __p = v7;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7 + 2, *(Registry **)(a2 + 48));
  uint64_t v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, &v21);
  if (v14)
  {
    uint64_t v16 = v14[3];
    std::string::size_type v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  std::string::size_type v15 = 0;
  char v17 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void, uint64_t, void **, void, void))(*(void *)v16 + 104))(v16, *(unsigned int *)(*(void *)a3 + 52), 1, &__p, 0, 0);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (__p)
  {
    __int16 v19 = __p;
    operator delete(__p);
  }
}

void sub_1011A6F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1011A6F40(uint64_t a1, uint64_t a2, PersonalityInfo **a3)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  v20[0] = 0;
  v20[1] = 0;
  memset(v19, 0, 7);
  memset(__p, 0, sizeof(__p));
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  char v17 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a2 + 80) + 40))(&v15);
  if (v15) {
    goto LABEL_7;
  }
  unsigned int v13 = 0;
  ctu::cf::assign();
  *(void *)&long long __dst = 0;
  *(void *)((char *)&__dst + 7) = 0;
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = (void *)__dst;
  *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&__dst + 7);
  HIBYTE(__p[2]) = 0;
  v12[0] = 0;
  v12[1] = 0;
  unsigned int v13 = 0;
  ctu::cf::assign();
  memset(v19, 0, 7);
  sub_1011A68E0((uint64_t)v12, a2, a3, (uint64_t)__p, (uint64_t)"override");
  *(void *)&long long __dst = &v22;
  *((void *)&__dst + 1) = v20;
  sub_1011ABDA0((uint64_t)&__dst, (uint64_t)v12);
  if (v14 < 0) {
    operator delete(v12[1]);
  }
  sub_100127DDC((const void **)v12);
  if (SHIBYTE(__p[2]) < 0)
  {
    sub_10004FC84(v9, __p[0], (unint64_t)__p[1]);
  }
  else
  {
LABEL_7:
    *(_OWORD *)uint64_t v9 = *(_OWORD *)__p;
    char v10 = __p[2];
  }
  if (SHIBYTE(v10) < 0)
  {
    sub_10004FC84(&__dst, v9[0], (unint64_t)v9[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v9;
    uint64_t v27 = v10;
  }
  CFTypeRef v23 = 0;
  if (SHIBYTE(v27) < 0)
  {
    sub_10004FC84(v12, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)uint64_t v12 = __dst;
    unsigned int v13 = v27;
  }
  long long v24 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v6 = v23;
    CFTypeRef v23 = v24;
    CFTypeRef v25 = v6;
    sub_1000558F4(&v25);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  uint64_t v11 = v23;
  CFTypeRef v23 = 0;
  sub_1000558F4(&v23);
  if (SHIBYTE(v27) < 0) {
    operator delete((void *)__dst);
  }
  sub_100637AC0((const void **)a1, &v22);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = v19[0];
  *(_DWORD *)(a1 + 27) = *(_DWORD *)((char *)v19 + 3);
  *(unsigned char *)(a1 + 31) = 0;
  uint64_t v7 = (unsigned char *)(a1 + 32);
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(v7, v20[0], (unint64_t)v20[1]);
  }
  else
  {
    *(_OWORD *)uint64_t v7 = *(_OWORD *)v20;
    *(void *)(a1 + 48) = v21;
  }
  *(void *)(a1 + 56) = v11;
  uint64_t v11 = 0;
  sub_1000558F4(&v11);
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
  sub_1000577C4(&v17);
  sub_1000577C4(&v16);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(v20[0]);
  }
  return sub_100127DDC(&v22);
}

void sub_1011A72D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,const void *a39)
{
  sub_1000577C4(v40);
  sub_1000577C4(v39);
  if (a31 < 0) {
    operator delete(__p);
  }
  if (v42 < 0) {
    operator delete(v41);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  sub_100127DDC(&a39);
  _Unwind_Resume(a1);
}

void sub_1011A73D4(const __CFData **a1, uint64_t a2, PersonalityInfo **a3, CFStringRef theString, SecKeyRef *a5)
{
  *a1 = 0;
  if (*a5) {
    uint64_t v8 = sub_1008A95D4;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, theString, 0x600u, 0);
    CFDataRef plaintext = ExternalRepresentation;
    if (ExternalRepresentation) {
      uint64_t v11 = sub_10008324C;
    }
    else {
      uint64_t v11 = 0;
    }
    if (v11)
    {
      unint64_t Length = CFDataGetLength(ExternalRepresentation);
      size_t v13 = SecKeyGetBlockSize(*a5) - 66;
      if (Length <= v13)
      {
        CFErrorRef error = 0;
        CFDataRef v20 = SecKeyCreateEncryptedData(*a5, kSecKeyAlgorithmRSAEncryptionOAEPSHA256, plaintext, &error);
        *a1 = v20;
        *(void *)int buf = 0;
        sub_100030068((const void **)buf);
        if (v20) {
          uint64_t v21 = sub_10008324C;
        }
        else {
          uint64_t v21 = 0;
        }
        if (v21)
        {
          uint64_t v22 = *(NSObject **)(a2 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = PersonalityInfo::logPrefix(*a3);
            CFIndex v24 = CFDataGetLength(v20);
            *(_DWORD *)int buf = 136315650;
            *(void *)&uint8_t buf[4] = v23;
            __int16 v39 = 2080;
            long long v40 = " ";
            __int16 v41 = 2048;
            char v42 = (void **)v24;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sencryption result %zu bytes", buf, 0x20u);
          }
        }
        else
        {
          CFErrorRef v25 = error;
          uint64_t v26 = *(NSObject **)(a2 + 40);
          BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
          if (v25)
          {
            if (v27)
            {
              uint64_t v28 = PersonalityInfo::logPrefix(*a3);
              sub_1011A78F8(&v31, error);
              long long v36 = 0uLL;
              uint64_t v37 = 0;
              ctu::cf::assign();
              *(_OWORD *)std::string __p = v36;
              uint64_t v33 = v37;
              uint64_t v29 = __p;
              if (v37 < 0) {
                uint64_t v29 = (void **)v36;
              }
              *(_DWORD *)int buf = 136315650;
              *(void *)&uint8_t buf[4] = v28;
              __int16 v39 = 2080;
              long long v40 = " ";
              __int16 v41 = 2080;
              char v42 = v29;
              _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "#E %s%sencryption failed, %s", buf, 0x20u);
              if (SHIBYTE(v33) < 0) {
                operator delete(__p[0]);
              }
              sub_1000558F4(&v31);
            }
          }
          else if (v27)
          {
            uint64_t v30 = PersonalityInfo::logPrefix(*a3);
            *(_DWORD *)int buf = 136315394;
            *(void *)&uint8_t buf[4] = v30;
            __int16 v39 = 2080;
            long long v40 = " ";
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "#E %s%sencryption failed, unknown error", buf, 0x16u);
          }
        }
        if (error) {
          CFRelease(error);
        }
      }
      else
      {
        char v14 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          uint64_t v15 = PersonalityInfo::logPrefix(*a3);
          *(_DWORD *)int buf = 136315906;
          *(void *)&uint8_t buf[4] = v15;
          __int16 v39 = 2080;
          long long v40 = " ";
          __int16 v41 = 2048;
          char v42 = (void **)Length;
          __int16 v43 = 2048;
          size_t v44 = v13;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "#E %s%sencryption cannot be performed, data is too long %zu while max is %zu", buf, 0x2Au);
        }
      }
    }
    else
    {
      uint64_t v18 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = PersonalityInfo::logPrefix(*a3);
        long long v36 = 0uLL;
        uint64_t v37 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = 0uLL;
        uint64_t v33 = 0;
        *(_DWORD *)int buf = 136315650;
        *(void *)&uint8_t buf[4] = v19;
        __int16 v39 = 2080;
        long long v40 = " ";
        __int16 v41 = 2080;
        char v42 = __p;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "#E %s%sinvalid string to encrypt '%s'", buf, 0x20u);
        if (SHIBYTE(v33) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    sub_100030068((const void **)&plaintext);
  }
  else
  {
    uint64_t v16 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = PersonalityInfo::logPrefix(*a3);
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = v17;
      __int16 v39 = 2080;
      long long v40 = " ";
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "#E %s%sno key", buf, 0x16u);
    }
  }
}

void sub_1011A7874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_100030068(&a15);
  sub_100030068(v21);
  _Unwind_Resume(a1);
}

const void **sub_1011A78F8(const void **result, CFErrorRef err)
{
  capabilities::ct *result = 0;
  if (err)
  {
    CFStringRef v3 = result;
    CFStringRef v8 = CFErrorCopyDescription(err);
    CFErrorDomain Domain = CFErrorGetDomain(err);
    CFIndex Code = CFErrorGetCode(err);
    CFStringRef v6 = @"-";
    if (Domain) {
      CFStringRef v7 = Domain;
    }
    else {
      CFStringRef v7 = @"-";
    }
    if (v8) {
      CFStringRef v6 = v8;
    }
    *CFStringRef v3 = CFStringCreateWithFormat(0, 0, @"(%@:%ld) '%@'", v7, Code, v6);
    uint64_t v9 = 0;
    sub_1000558F4(&v9);
    return sub_1000558F4((const void **)&v8);
  }
  return result;
}

void sub_1011A79A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000558F4((const void **)va);
  sub_1000558F4(v5);
  _Unwind_Resume(a1);
}

void sub_1011A79D0(const void **a1, uint64_t a2, uint64_t a3, unsigned int a4, const __CFString *a5)
{
  char v10 = sub_100046F68(a2 + 336, (void **)a3);
  if ((void **)(a2 + 344) == v10)
  {
    uint64_t v11 = 0;
LABEL_21:
    uint64_t v22 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_51;
    }
    uint64_t v23 = *(unsigned __int8 *)(a3 + 23);
    BOOL v24 = (v23 & 0x80u) != 0;
    if ((v23 & 0x80u) != 0) {
      uint64_t v23 = *(void *)(a3 + 8);
    }
    if (v24) {
      CFErrorRef v25 = *(const char **)a3;
    }
    else {
      CFErrorRef v25 = (const char *)a3;
    }
    if (v23) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = "<invalid>";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
    BOOL v27 = "#E No model for %s";
    uint64_t v28 = v22;
    uint32_t v29 = 12;
    goto LABEL_50;
  }
  uint64_t v12 = (uint64_t)v10[7];
  uint64_t v11 = (std::__shared_weak_count *)v10[8];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12) {
    goto LABEL_21;
  }
  uint64_t v13 = *(void *)(v12 + 24);
  if (!v13) {
    goto LABEL_16;
  }
  uint64_t v14 = v12 + 24;
  do
  {
    unsigned int v15 = *(unsigned __int8 *)(v13 + 25);
    BOOL v16 = v15 >= a4;
    if (v15 >= a4) {
      uint64_t v17 = (uint64_t *)v13;
    }
    else {
      uint64_t v17 = (uint64_t *)(v13 + 8);
    }
    if (v16) {
      uint64_t v14 = v13;
    }
    uint64_t v13 = *v17;
  }
  while (*v17);
  if (v14 != v12 + 24 && *(unsigned __int8 *)(v14 + 25) <= a4) {
    unsigned int v18 = *(unsigned __int8 *)(v14 + 26);
  }
  else {
LABEL_16:
  }
    unsigned int v18 = 0;
  uint64_t v19 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v20 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v12);
    if (v18 > 2) {
      uint64_t v21 = "???";
    }
    else {
      uint64_t v21 = off_101A9A020[(char)v18];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v20;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)uint64_t v107 = v21;
    *(_WORD *)&v107[8] = 2080;
    *(void *)&v107[10] = asString();
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%ssupportsIdentityProtection %s for type %s", (uint8_t *)&buf, 0x2Au);
  }
  if (v18 != 1)
  {
    char v42 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_51;
    }
    std::string::size_type v43 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v12);
    uint64_t v44 = asString();
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v43;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    *(void *)uint64_t v107 = v44;
    BOOL v27 = "#I %s%sIdentity Encryption is not supported for type %s";
    uint64_t v28 = v42;
    uint32_t v29 = 32;
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&buf, v29);
LABEL_51:
    *a1 = 0;
    if (!v11) {
      return;
    }
    goto LABEL_52;
  }
  std::string v101 = 0;
  sub_1011A6DA8((uint64_t)&buf, a2, v12, @"IncludeIMEI");
  sub_1000057AC(&v101, (CFTypeRef *)&buf.__r_.__value_.__l.__data_);
  uint64_t v30 = sub_1000577C4((const void **)&buf.__r_.__value_.__l.__data_);
  buf.__r_.__value_.__s.__data_[0] = 0;
  ctu::cf::assign((ctu::cf *)v30, v101, v31);
  int v32 = buf.__r_.__value_.__s.__data_[0];
  CFStringRef v100 = 0;
  if (buf.__r_.__value_.__s.__data_[0])
  {
    uint64_t v33 = *(PersonalityInfo **)v12;
    uint64_t v34 = *(void *)(a2 + 320);
    if (!v34) {
      goto LABEL_45;
    }
    int v35 = *((_DWORD *)v33 + 13);
    uint64_t v36 = a2 + 320;
    do
    {
      int v37 = *(_DWORD *)(v34 + 32);
      BOOL v38 = v37 < v35;
      if (v37 >= v35) {
        __int16 v39 = (uint64_t *)v34;
      }
      else {
        __int16 v39 = (uint64_t *)(v34 + 8);
      }
      if (!v38) {
        uint64_t v36 = v34;
      }
      uint64_t v34 = *v39;
    }
    while (*v39);
    if (v36 == a2 + 320 || v35 < *(_DWORD *)(v36 + 32))
    {
LABEL_45:
      long long v40 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v41 = PersonalityInfo::logPrefix(v33);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v41;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#W %s%sNO REQUIRED IMEI - unable to build identity", (uint8_t *)&buf, 0x16u);
      }
      *a1 = 0;
      goto LABEL_160;
    }
    memset(&__p, 0, sizeof(__p));
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string v98 = buf;
    std::string::push_back(&v98, 44);
    std::string v103 = v98;
    memset(&v98, 0, sizeof(v98));
    char v47 = *(const std::string::value_type **)(v36 + 40);
    uint64_t v46 = v36 + 40;
    unsigned int v45 = v47;
    int v48 = *(char *)(v46 + 23);
    if (v48 >= 0) {
      uint64_t v49 = (const std::string::value_type *)v46;
    }
    else {
      uint64_t v49 = v45;
    }
    if (v48 >= 0) {
      std::string::size_type v50 = *(unsigned __int8 *)(v46 + 23);
    }
    else {
      std::string::size_type v50 = *(void *)(v46 + 8);
    }
    char v51 = std::string::append(&v103, v49, v50);
    long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v103.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v98.__r_.__value_.__l.__data_);
    }
    id v53 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v54 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v12);
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v54;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      *(void *)uint64_t v107 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I %s%scompiled identity: %s", (uint8_t *)&buf, 0x20u);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v98, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v98 = __p;
    }
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v103, v98.__r_.__value_.__l.__data_, v98.__r_.__value_.__l.__size_);
    }
    else {
      std::string v103 = v98;
    }
    long long v88 = 0;
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, v103.__r_.__value_.__l.__data_, v103.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = v103;
    }
    __dst[0] = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v56 = v88;
      long long v88 = __dst[0];
      uint64_t v94 = v56;
      sub_1000558F4((const void **)&v94);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    CFStringRef v105 = (const __CFString *)v88;
    long long v88 = 0;
    sub_1000558F4((const void **)&v88);
    if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v103.__r_.__value_.__l.__data_);
    }
    std::string::size_type v57 = (std::string::size_type)v100;
    CFStringRef v100 = v105;
    CFStringRef v105 = 0;
    buf.__r_.__value_.__r.__words[0] = v57;
    sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&v105);
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v98.__r_.__value_.__l.__data_);
    }
    a5 = v100;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  *a1 = 0;
  CFNumberRef v97 = 0;
  buf.__r_.__value_.__r.__words[0] = 0;
  sub_100637AC0((const void **)&buf.__r_.__value_.__l.__data_, (const void **)(v12 + 40));
  v103.__r_.__value_.__r.__words[0] = buf.__r_.__value_.__r.__words[0];
  if (buf.__r_.__value_.__r.__words[0]) {
    CFRetain(buf.__r_.__value_.__l.__data_);
  }
  sub_1011A73D4((const __CFData **)&v97, a2, (PersonalityInfo **)v12, a5, (SecKeyRef *)&v103);
  sub_100127DDC((const void **)&v103.__r_.__value_.__l.__data_);
  sub_100127DDC((const void **)&buf.__r_.__value_.__l.__data_);
  if (v97) {
    CFNumberRef v58 = sub_10008324C;
  }
  else {
    CFNumberRef v58 = 0;
  }
  if (v58)
  {
    std::string v59 = operator new(1uLL);
    if (v32) {
      unsigned char *v59 = 97;
    }
    else {
      unsigned char *v59 = 0;
    }
    __p.__r_.__value_.__l.__size_ = (std::string::size_type)(v59 + 1);
    __p.__r_.__value_.__r.__words[2] = (std::string::size_type)(v59 + 1);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
    uint64_t v94 = 0;
    uint64_t v95 = 0;
    uint64_t v96 = 0;
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string v103 = buf;
    ctu::base64::encode();
    if (v103.__r_.__value_.__r.__words[0])
    {
      v103.__r_.__value_.__l.__size_ = v103.__r_.__value_.__r.__words[0];
      operator delete(v103.__r_.__value_.__l.__data_);
    }
    uint64_t v62 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v63 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v12);
      uint64_t v64 = HIBYTE(v96);
      if (v96 < 0) {
        uint64_t v64 = v95;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v63;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2048;
      *(void *)uint64_t v107 = v64;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s%sencoded identity part is of %zu bytes", (uint8_t *)&buf, 0x20u);
    }
    if (v96 >= 0) {
      char v65 = (char *)&v94;
    }
    else {
      char v65 = (char *)v94;
    }
    if (v96 >= 0) {
      uint64_t v66 = HIBYTE(v96);
    }
    else {
      uint64_t v66 = v95;
    }
    sub_1007DCB2C(&__p.__r_.__value_.__l.__data_, (char *)__p.__r_.__value_.__l.__size_, v65, &v65[v66], v66);
    uint64_t v67 = *(unsigned __int8 *)(v12 + 71);
    if ((v67 & 0x80u) != 0) {
      uint64_t v67 = *(void *)(v12 + 56);
    }
    if (v67)
    {
      std::string::size_type size = (char *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_ >= __p.__r_.__value_.__r.__words[2])
      {
        std::string::size_type v70 = __p.__r_.__value_.__r.__words[0];
        std::string::size_type v71 = __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0];
        int64_t v72 = __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0] + 1;
        if (v72 < 0) {
          sub_10006A748();
        }
        std::string::size_type v73 = __p.__r_.__value_.__r.__words[2] - __p.__r_.__value_.__r.__words[0];
        if (2 * (__p.__r_.__value_.__r.__words[2] - __p.__r_.__value_.__r.__words[0]) > v72) {
          int64_t v72 = 2 * v73;
        }
        if (v73 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v74 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v74 = v72;
        }
        if (v74) {
          std::string::size_type v75 = (std::string::size_type)operator new(v74);
        }
        else {
          std::string::size_type v75 = 0;
        }
        std::string::size_type v76 = v75 + v74;
        *(unsigned char *)(v75 + v71) = 44;
        uint64_t v69 = (char *)(v75 + v71 + 1);
        if (size == (char *)v70)
        {
          v75 += v71;
        }
        else
        {
          uint64_t v77 = &size[~v70];
          do
          {
            char v78 = *--size;
            (v77--)[v75] = v78;
          }
          while (size != (char *)v70);
          std::string::size_type size = (char *)__p.__r_.__value_.__r.__words[0];
        }
        __p.__r_.__value_.__r.__words[0] = v75;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v69;
        __p.__r_.__value_.__r.__words[2] = v76;
        if (size) {
          operator delete(size);
        }
      }
      else
      {
        *(unsigned char *)__p.__r_.__value_.__l.__size_ = 44;
        uint64_t v69 = size + 1;
      }
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)v69;
      int v79 = *(char *)(v12 + 71);
      if (v79 >= 0) {
        uint64_t v80 = (char *)(v12 + 48);
      }
      else {
        uint64_t v80 = *(char **)(v12 + 48);
      }
      if (v79 >= 0) {
        uint64_t v81 = *(unsigned __int8 *)(v12 + 71);
      }
      else {
        uint64_t v81 = *(void *)(v12 + 56);
      }
      sub_1007DCB2C(&__p.__r_.__value_.__l.__data_, v69, v80, &v80[v81], v81);
    }
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v93 = 0;
    sub_1000D95C8(__dst, (void *)(__p.__r_.__value_.__r.__words[0] + 1), __p.__r_.__value_.__l.__size_ + ~__p.__r_.__value_.__r.__words[0]);
    uint64_t v82 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v83 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v12);
      int v84 = *__p.__r_.__value_.__l.__data_;
      long long v85 = __dst;
      if (v93 < 0) {
        long long v85 = (void **)__dst[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v83;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
      *(_DWORD *)uint64_t v107 = v84;
      *(_WORD *)&v107[4] = 2080;
      *(void *)&v107[6] = v85;
      _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I %s%scompiled encrypted identity: [prefix:0x%x] %s", (uint8_t *)&buf, 0x26u);
    }
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    long long v88 = 0;
    sub_10005C928(&v88, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]);
    memset(&v103, 0, sizeof(v103));
    sub_10005C928(&v103, v88, (uint64_t)v89, v89 - (unsigned char *)v88);
    CFStringRef v102 = 0;
    memset(&buf, 0, sizeof(buf));
    sub_10005C928(&buf, v103.__r_.__value_.__l.__data_, v103.__r_.__value_.__l.__size_, v103.__r_.__value_.__l.__size_ - v103.__r_.__value_.__r.__words[0]);
    CFStringRef v104 = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v86 = v102;
      CFStringRef v102 = v104;
      CFStringRef v105 = v86;
      sub_100030068((const void **)&v105);
    }
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    CFStringRef v87 = v102;
    CFStringRef v91 = v102;
    CFStringRef v102 = 0;
    sub_100030068((const void **)&v102);
    if (v103.__r_.__value_.__r.__words[0])
    {
      v103.__r_.__value_.__l.__size_ = v103.__r_.__value_.__r.__words[0];
      operator delete(v103.__r_.__value_.__l.__data_);
    }
    if (&v91 != (const __CFString **)a1)
    {
      buf.__r_.__value_.__r.__words[0] = 0;
      *a1 = v87;
      CFStringRef v91 = 0;
      sub_100030068((const void **)&buf.__r_.__value_.__l.__data_);
    }
    sub_100030068((const void **)&v91);
    if (v88)
    {
      uint64_t v89 = v88;
      operator delete(v88);
    }
    if (SHIBYTE(v93) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v96) < 0) {
      operator delete(v94);
    }
    if (__p.__r_.__value_.__r.__words[0])
    {
      __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    unint64_t v60 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v61 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v12);
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v61;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
      _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "#E %s%sfail to encrypt identity", (uint8_t *)&buf, 0x16u);
    }
  }
  sub_100030068(&v97);
LABEL_160:
  sub_1000558F4((const void **)&v100);
  sub_100062778((const void **)&v101);
  if (v11) {
LABEL_52:
  }
    sub_10004D2C8(v11);
}

void sub_1011A84D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,const void *a40,const void *a41,__int16 a42,char a43,char a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  sub_1000558F4((const void **)&a10);
  if (a50 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  sub_1000558F4(&a40);
  sub_100062778(&a41);
  if (v50) {
    sub_10004D2C8(v50);
  }
  _Unwind_Resume(a1);
}

void sub_1011A86E8(void *a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v6 = sub_100046F68(a2 + 336, (void **)a3);
  if ((void **)(a2 + 344) == v6)
  {
    CFStringRef v8 = 0;
  }
  else
  {
    uint64_t v7 = (uint64_t)v6[7];
    CFStringRef v8 = (std::__shared_weak_count *)v6[8];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7)
    {
      sub_1011A6DA8((uint64_t)v14, a2, v7, @"AnonymousUsername");
      sub_100056248(a1, (CFTypeRef *)v14);
      goto LABEL_18;
    }
  }
  uint64_t v9 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
    BOOL v11 = (v10 & 0x80u) != 0;
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *(void *)(a3 + 8);
    }
    if (v11) {
      uint64_t v12 = *(const char **)a3;
    }
    else {
      uint64_t v12 = (const char *)a3;
    }
    if (v10) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = "<invalid>";
    }
    *(_DWORD *)uint64_t v14 = 136315138;
    *(void *)&v14[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E No model for %s", v14, 0xCu);
  }
  *(void *)uint64_t v14 = 0;
  sub_100056248(a1, (CFTypeRef *)v14);
LABEL_18:
  sub_1000577C4((const void **)v14);
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1011A8838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000577C4(&a9);
  if (v9) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1011A8864(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void (***v23)(uint64_t *__return_ptr, void, uint64_t);
  char v24;
  NSObject *v25;
  uint64_t v26;
  BOOL v27;
  const char *v28;
  const char *v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  std::__shared_weak_count *v43;
  unsigned char buf[12];
  __int16 v45;
  const char *v46;
  __int16 v47;
  uint64_t v48;

  CFStringRef v6 = sub_100046F68(a1 + 336, (void **)a2);
  if ((void **)(a1 + 344) == v6)
  {
    uint64_t v7 = 0;
LABEL_26:
    CFErrorRef v25 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    uint64_t v26 = *(unsigned __int8 *)(a2 + 23);
    BOOL v27 = (v26 & 0x80u) != 0;
    if ((v26 & 0x80u) != 0) {
      uint64_t v26 = *(void *)(a2 + 8);
    }
    if (v27) {
      uint64_t v28 = *(const char **)a2;
    }
    else {
      uint64_t v28 = (const char *)a2;
    }
    if (v26) {
      uint32_t v29 = v28;
    }
    else {
      uint32_t v29 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v29;
    uint64_t v30 = "#E No model for %s";
    CFBooleanRef v31 = v25;
    int v32 = 12;
LABEL_38:
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
    goto LABEL_39;
  }
  uint64_t v8 = (uint64_t)v6[7];
  uint64_t v7 = (std::__shared_weak_count *)v6[8];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v8) {
    goto LABEL_26;
  }
  uint64_t v9 = *(void *)(v8 + 24);
  if (!v9) {
    goto LABEL_36;
  }
  uint64_t v10 = v8 + 24;
  do
  {
    unsigned int v11 = *(unsigned __int8 *)(v9 + 25);
    BOOL v12 = v11 >= a3;
    if (v11 >= a3) {
      uint64_t v13 = (uint64_t *)v9;
    }
    else {
      uint64_t v13 = (uint64_t *)(v9 + 8);
    }
    if (v12) {
      uint64_t v10 = v9;
    }
    uint64_t v9 = *v13;
  }
  while (*v13);
  if (v10 == v8 + 24
    || *(unsigned __int8 *)(v10 + 25) > a3
    || (uint64_t v14 = (uint64_t *)*(unsigned __int8 *)(v10 + 26), !v14))
  {
LABEL_36:
    uint64_t v33 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    uint64_t v34 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v8);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v34;
    unsigned int v45 = 2080;
    uint64_t v46 = " ";
    char v47 = 2080;
    int v48 = asString();
    uint64_t v30 = "#W %s%sCannot evaluateIdentity for service %s since protection is None";
    CFBooleanRef v31 = v33;
    int v32 = 32;
    goto LABEL_38;
  }
  if (v14 != 1)
  {
    if (v14 != 2) {
      goto LABEL_39;
    }
    char v42 = 0;
    std::string::size_type v43 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 48));
    BOOL v16 = ServiceMap;
    if (v17 < 0)
    {
      unsigned int v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v17;
    uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
    if (v21)
    {
      uint64_t v23 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v21[3];
      uint64_t v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        BOOL v24 = 0;
LABEL_49:
        (**v23)(&v42, v23, a2);
        if ((v24 & 1) == 0) {
          sub_10004D2C8(v22);
        }
        BOOL v38 = v42;
        if (v42)
        {
          __int16 v39 = *(_DWORD *)(v8 + 132);
          *(_DWORD *)(v8 + 132) = v39 + 1;
          if (!v39)
          {
            long long v40 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              std::string::size_type v41 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v8);
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = v41;
              unsigned int v45 = 2080;
              uint64_t v46 = " ";
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sAsking for WiFi pseudonym update", buf, 0x16u);
              BOOL v38 = v42;
            }
            *(void *)std::string buf = 1;
            uint8_t buf[8] = 1;
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v38 + 472))(v38, buf);
            BOOL v38 = v42;
          }
          *(void *)std::string buf = 1;
          uint8_t buf[8] = 1;
          (*(void (**)(uint64_t, void, unsigned char *))(*(void *)v38 + 456))(v38, 0, buf);
        }
        if (v43) {
          sub_10004D2C8(v43);
        }
        goto LABEL_39;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    uint64_t v22 = 0;
    BOOL v24 = 1;
    goto LABEL_49;
  }
  if (!*(unsigned char *)(v8 + 116))
  {
    int v35 = *(_DWORD *)(v8 + 128);
    *(_DWORD *)(v8 + 128) = v35 + 1;
    if (!v35)
    {
      uint64_t v36 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        int v37 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v8);
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v37;
        unsigned int v45 = 2080;
        uint64_t v46 = " ";
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s%sInvoke update on demand, once", buf, 0x16u);
      }
      *(unsigned char *)(v8 + 116) = 1;
      *(_DWORD *)(v8 + 112) = 0;
      sub_1011A51F4((const void **)a1, v8);
    }
  }
LABEL_39:
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_1011A8CE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011A8D44(const void **a1, uint64_t a2, void **a3, unsigned int a4)
{
  *a1 = 0;
  uint64_t v8 = sub_100046F68(a2 + 336, a3);
  if ((void **)(a2 + 344) != v8)
  {
    uint64_t v9 = v8[7];
    uint64_t v10 = (std::__shared_weak_count *)v8[8];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v9)
    {
      uint64_t v13 = (char **)v9[3];
      unsigned int v11 = (char *)(v9 + 3);
      BOOL v12 = v13;
      if (v13)
      {
        uint64_t v14 = v11;
        do
        {
          unsigned int v15 = *((unsigned __int8 *)v12 + 25);
          BOOL v16 = v15 >= a4;
          if (v15 >= a4) {
            uint64_t v17 = v12;
          }
          else {
            uint64_t v17 = v12 + 1;
          }
          if (v16) {
            uint64_t v14 = (char *)v12;
          }
          BOOL v12 = (char **)*v17;
        }
        while (*v17);
        if (v14 != v11 && v14[25] <= a4 && v14[26] == 2)
        {
          unsigned int v18 = *(void **)(a2 + 296);
          if (v18)
          {
            uint64_t v19 = (void *)(a2 + 296);
            unsigned int v20 = (void *)(a2 + 296);
            do
            {
              char v21 = sub_100046FE8(v18 + 4, a3);
              if (v21 >= 0) {
                uint64_t v22 = v18;
              }
              else {
                uint64_t v22 = v18 + 1;
              }
              if (v21 >= 0) {
                unsigned int v20 = v18;
              }
              unsigned int v18 = (void *)*v22;
            }
            while (*v22);
            if (v20 != v19 && (sub_100046FE8(a3, (void **)v20 + 4) & 0x80) == 0)
            {
              BOOL v24 = (const __CFString **)(v20 + 7);
              if (*((char *)v20 + 79) < 0) {
                BOOL v24 = (const __CFString **)*v24;
              }
              uint64_t v28 = 0;
              uint32_t v29 = 0;
              if (ctu::cf::convert_copy((ctu::cf *)&v29, v24, (const char *)0x8000100, kCFAllocatorDefault, v23))
              {
                CFErrorRef v25 = v28;
                uint64_t v28 = v29;
                uint64_t v30 = v25;
                sub_1000558F4(&v30);
              }
              uint64_t v26 = v28;
              BOOL v27 = v28;
              uint64_t v28 = 0;
              sub_1000558F4(&v28);
              if (&v27 != a1)
              {
                uint64_t v30 = *a1;
                *a1 = v26;
                BOOL v27 = 0;
                sub_1000558F4(&v30);
              }
              sub_1000558F4(&v27);
            }
          }
        }
      }
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

void sub_1011A8EE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000558F4(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1011A8F0C(uint64_t a1, uint64_t a2, char a3)
{
  char v7 = a3;
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = &v7;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1011AED98;
  v8[3] = &unk_101A99F48;
  v8[4] = a1 + 8;
  v8[5] = v6;
  uint64_t v9 = v8;
  uint64_t v4 = a1 + 24;
  CFStringRef v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    unsigned __int8 v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    BOOL v12 = sub_1011AEF3C;
    uint64_t v13 = &unk_10199E470;
    uint64_t v14 = &v16;
    unsigned int v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    unsigned __int8 v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    BOOL v12 = sub_1011AEF00;
    uint64_t v13 = &unk_10199E470;
    uint64_t v14 = &v16;
    unsigned int v15 = &v9;
    dispatch_sync(v3, &block);
  }
  return v16;
}

void sub_1011A9044(uint64_t a1, int a2, char a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  char v8 = a3;
  sub_1011AEF78((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A9190(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011A91A0(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  char v9 = a3;
  v7[0] = a1;
  v7[1] = a2;
  v7[2] = &v9;
  _OWORD v7[3] = &v8;
  uint64_t v8 = a4;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  _DWORD v10[2] = sub_1011AF2A4;
  v10[3] = &unk_101A99F68;
  v10[4] = a1 + 8;
  v10[5] = v7;
  uint64_t v11 = v10;
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(v6 + 8))
  {
    *a5 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    uint64_t v14 = sub_1011AF338;
    unsigned int v15 = &unk_10199E470;
    unsigned __int8 v16 = a5;
    uint64_t v17 = &v11;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    *a5 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 3221225472;
    uint64_t v14 = sub_1011AF2C0;
    unsigned int v15 = &unk_10199E470;
    unsigned __int8 v16 = a5;
    uint64_t v17 = &v11;
    dispatch_sync(v5, &block);
  }
}

void sub_1011A92D4(uint64_t a1, int a2, char a3, CFTypeRef cf, uint64_t a5)
{
  CFTypeRef v11 = cf;
  if (cf)
  {
    CFRetain(cf);
    uint64_t v12 = a1;
    int v13 = a2;
    CFTypeRef v14 = cf;
    CFRetain(cf);
  }
  else
  {
    uint64_t v12 = a1;
    int v13 = a2;
    CFTypeRef v14 = 0;
  }
  char v15 = a3;
  sub_1011AF3B0((uint64_t)&v16, a5);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A9490(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011A94B0(void *a1, uint64_t a2, char a3, const void *a4)
{
  __dst[0] = 0;
  __dst[1] = 0;
  int v13 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    int v13 = *(void **)(a2 + 16);
  }
  CFTypeRef cf = 0;
  CFTypeRef v8 = a4;
  sub_1000C15D8(&cf, &v8);
  CFTypeRef v8 = a1;
  if (SHIBYTE(v13) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    __p[2] = v13;
  }
  __p[3] = (void *)cf;
  if (cf) {
    CFRetain(cf);
  }
  char v10 = a3;
  int v7 = (std::__shared_weak_count *)a1[2];
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A969C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1011A96D4(uint64_t a1, int a2, int a3, CFTypeRef cf)
{
  if (cf)
  {
    CFRetain(cf);
    CFRetain(cf);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A9844(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1011AF844;
  void v6[3] = &unk_101A99F88;
  v6[4] = a1 + 8;
  v6[5] = v5;
  int v7 = v6;
  uint64_t v4 = a1 + 24;
  CFStringRef v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_1011AF8CC;
    CFTypeRef v11 = &unk_10199E470;
    uint64_t v12 = a3;
    int v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_1011AF854;
    CFTypeRef v11 = &unk_10199E470;
    uint64_t v12 = a3;
    int v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_1011A9964(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, void *a4@<X8>)
{
  char v7 = a3;
  v6[0] = a1;
  v6[1] = a2;
  v6[2] = &v7;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1011AF944;
  v8[3] = &unk_101A99F88;
  v8[4] = a1 + 8;
  v8[5] = v6;
  uint64_t v9 = v8;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_1011AF8CC;
    int v13 = &unk_10199E470;
    CFTypeRef v14 = a4;
    char v15 = &v9;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 3221225472;
    uint64_t v12 = sub_1011AF854;
    int v13 = &unk_10199E470;
    CFTypeRef v14 = a4;
    char v15 = &v9;
    dispatch_sync(v4, &block);
  }
}

void sub_1011A9A90(uint64_t a1, int a2, char a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  char v8 = a3;
  sub_100C416C4((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A9BDC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011A9BEC(uint64_t a1, const void **a2, const void **a3, uint64_t a4)
{
  uint64_t v8 = a1;
  sub_100083DA4(&v9, a2);
  sub_100083DA4(&v10, a3);
  sub_1011AFAB0((uint64_t)&v11, a4);
  int v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011A9D70(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011A9D80(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = sub_100046F68(v3 + 336, (void **)(a1 + 56));
        if ((void **)(v3 + 344) != v6)
        {
          uint64_t v8 = (uint64_t)v6[7];
          int v7 = (std::__shared_weak_count *)v6[8];
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v8)
          {
            uint64_t v9 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v10 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v8);
              int v14 = 136315394;
              uint64_t v15 = v10;
              __int16 v16 = 2080;
              uint64_t v17 = " ";
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sTimer expired, updating certificates", (uint8_t *)&v14, 0x16u);
            }
            *(unsigned char *)(v8 + 116) = 1;
            *(_DWORD *)(v8 + 128) = 0;
            *(_DWORD *)(v8 + 112) = 0;
            sub_1011A51F4((const void **)v3, v8);
            uint64_t v11 = *(void *)(v8 + 80);
            if (v11)
            {
              uint64_t v12 = *(NSObject **)(v3 + 40);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v13 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v8);
                int v14 = 136315394;
                uint64_t v15 = v13;
                __int16 v16 = 2080;
                uint64_t v17 = " ";
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%sScheduling next update check", (uint8_t *)&v14, 0x16u);
                uint64_t v11 = *(void *)(v8 + 80);
              }
              sub_100D211E4(v11, 0);
            }
          }
          if (v7) {
            sub_10004D2C8(v7);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1011A9F80(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_1011A9FA0(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_1011AA008(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011AA020(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1011AA074(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 80);
  if (v2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
      int v7 = 136315394;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      uint64_t v10 = " ";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sStopping update timer", (uint8_t *)&v7, 0x16u);
      uint64_t v2 = *(void *)(a2 + 80);
    }
    sub_100D20DC0(v2);
    uint64_t v6 = *(std::__shared_weak_count **)(a2 + 88);
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 88) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
}

void sub_1011AA158(uint64_t a1, uint64_t a2)
{
  sub_1011AFEB0(&v2, a2);
}

void sub_1011AA1A0(uint64_t a1, void *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (!*(void *)(a1 + 40)) {
        goto LABEL_110;
      }
      uint64_t v8 = sub_100046F68(v5 + 336, (void **)(a1 + 56));
      if ((void **)(v5 + 344) == v8) {
        goto LABEL_110;
      }
      __int16 v9 = v8[7];
      uint64_t v10 = (std::__shared_weak_count *)v8[8];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v9)
      {
LABEL_108:
        if (v10) {
          sub_10004D2C8(v10);
        }
LABEL_110:
        sub_10004D2C8(v7);
        return;
      }
      uint64_t v11 = (std::__shared_weak_count *)*((void *)v9 + 13);
      *((void *)v9 + 12) = 0;
      *((void *)v9 + 13) = 0;
      if (v11) {
        sub_10004D2C8(v11);
      }
      uint64_t v12 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v13;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%s_____________<  Received response, or timed out", buf, 0x16u);
      }
      if (!*a2) {
        goto LABEL_43;
      }
      unsigned int v14 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
      uint64_t v15 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v67 = v10;
        uint64_t v66 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v9);
        (*(void (**)(void **__return_ptr))(*(void *)*a2 + 64))(v86);
        if (v87 >= 0) {
          __int16 v16 = v86;
        }
        else {
          __int16 v16 = (void **)v86[0];
        }
        char v65 = v16;
        int v64 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))();
        (*(void (**)(void))(*(void *)*a2 + 16))();
        ctu::Http::asString();
        if (v85 >= 0) {
          unsigned int v18 = v84;
        }
        else {
          unsigned int v18 = (void **)v84[0];
        }
        std::string::size_type v63 = v18;
        ctu::Http::asString((uint64_t *)v92, (ctu::Http *)v14, v17);
        if (v95 >= 0) {
          uint64_t v19 = v92;
        }
        else {
          uint64_t v19 = *(unsigned char **)v92;
        }
        uint64_t v62 = v19;
        (*(void (**)(void **__return_ptr))(*(void *)*a2 + 48))(&v81);
        if (v83 >= 0) {
          unsigned int v20 = &v81;
        }
        else {
          unsigned int v20 = v81;
        }
        std::string::size_type v61 = v20;
        uint64_t v21 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
        (*(void (**)(void))(*(void *)*a2 + 16))();
        (*(void (**)(void))(*(void *)*a2 + 32))();
        ctu::Http::asString();
        if (v80 >= 0) {
          uint64_t v22 = __p;
        }
        else {
          uint64_t v22 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 136317442;
        *(void *)&uint8_t buf[4] = v66;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        CFNumberRef v97 = v65;
        __int16 v98 = 1024;
        int v99 = v64;
        __int16 v100 = 2080;
        std::string v101 = v63;
        __int16 v102 = 1024;
        unsigned int v103 = v14;
        __int16 v104 = 2080;
        CFStringRef v105 = v62;
        __int16 v106 = 2080;
        uint64_t v107 = v61;
        __int16 v108 = 2048;
        uint64_t v109 = v21;
        __int16 v110 = 2080;
        long long v111 = v22;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sResponse: '%s', Result: %d (%s), Status: '%d' (%s), Response: '%s' ErrorCode: '%ld' (%s)", buf, 0x5Eu);
        if (v80 < 0) {
          operator delete(__p[0]);
        }
        uint64_t v10 = v67;
        if (v83 < 0) {
          operator delete(v81);
        }
        if (v95 < 0) {
          operator delete(*(void **)v92);
        }
        if (SHIBYTE(v85) < 0) {
          operator delete(v84[0]);
        }
        if (SHIBYTE(v87) < 0) {
          operator delete(v86[0]);
        }
      }
      if ((*(unsigned int (**)(void))(*(void *)*a2 + 16))() != 1 || v14 != 200)
      {
LABEL_43:
        unsigned int v25 = *((_DWORD *)v9 + 28) + 1;
        *((_DWORD *)v9 + 28) = v25;
        uint64_t v26 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v25;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = 5;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I got %u failure(s) from %u max allowed", buf, 0xEu);
          unsigned int v25 = *((_DWORD *)v9 + 28);
        }
        if (v25 < 5)
        {
          unsigned int v28 = 60 * v25;
          uint32_t v29 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v28;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I schedule update in %u seconds", buf, 8u);
          }
          Registry::getTimerService((uint64_t *)buf, *(Registry **)(v5 + 48));
          uint64_t v30 = *(void *)buf;
          sub_100058DB0(v74, "EncryptedIdentityManagement::backoff");
          CFBooleanRef v31 = *(NSObject **)(v5 + 24);
          dispatch_object_t object = v31;
          if (v31) {
            dispatch_retain(v31);
          }
          v68[0] = _NSConcreteStackBlock;
          v68[1] = 3321888768;
          v68[2] = sub_1011AAF1C;
          v68[3] = &unk_101A99A20;
          uint64_t v33 = *(void *)(a1 + 40);
          int v32 = *(std::__shared_weak_count **)(a1 + 48);
          v68[4] = v5;
          v68[5] = v33;
          uint64_t v69 = v32;
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          if (*(char *)(a1 + 79) < 0)
          {
            sub_10004FC84(&v70, *(void **)(a1 + 56), *(void *)(a1 + 64));
          }
          else
          {
            long long v70 = *(_OWORD *)(a1 + 56);
            uint64_t v71 = *(void *)(a1 + 72);
          }
          int64_t v72 = _Block_copy(v68);
          sub_100118A44(v30, (uint64_t)v74, 1, 1000000 * v28, &object, &v72);
          uint64_t v34 = v86[0];
          v86[0] = 0;
          uint64_t v35 = *((void *)v9 + 15);
          *((void *)v9 + 15) = v34;
          if (v35)
          {
            (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
            uint64_t v36 = v86[0];
            v86[0] = 0;
            if (v36) {
              (*(void (**)(void *))(*(void *)v36 + 8))(v36);
            }
          }
          if (v72) {
            _Block_release(v72);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v75 < 0) {
            operator delete(v74[0]);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
          if (SHIBYTE(v71) < 0) {
            operator delete((void *)v70);
          }
          if (v69) {
            std::__shared_weak_count::__release_weak(v69);
          }
        }
        else
        {
          BOOL v27 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = 5;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I max number of failures reached (%u)", buf, 8u);
          }
        }
        goto LABEL_108;
      }
      *((unsigned char *)v9 + 116) = 0;
      *((_DWORD *)v9 + 28) = 0;
      uint64_t v77 = 0;
      char v78 = 0;
      (*(void (**)(const __CFData **__return_ptr))(*(void *)*a2 + 40))(&v76);
      CFDataRef v23 = v76;
      __p[0] = 0;
      uint64_t v90 = 0;
      CFStringRef v91 = 0;
      ctu::ns::AutoPool::AutoPool((ctu::ns::AutoPool *)&v90);
      if (v23) {
        CFIndex Length = CFDataGetLength(v23);
      }
      else {
        CFIndex Length = 0;
      }
      int v37 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(void *)&uint8_t buf[4] = Length;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Received %zu bytes of data", buf, 0xCu);
      }
      if (Length)
      {
        BOOL v38 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          id v39 = objc_msgSend(objc_msgSend(objc_alloc((Class)NSString), "initWithData:encoding:", v23, 1), "cStringUsingEncoding:", 4);
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v39;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I JSON Response: %s", buf, 0xCu);
        }
        uint64_t v89 = 0;
        CFDictionaryRef v40 = +[NSJSONSerialization JSONObjectWithData:v23 options:0 error:&v89];
        if (v40)
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            CFDictionaryRef theDict = v40;
            CFRetain(v40);
            int Value = CFDictionaryGetValue(theDict, @"key-identifier");
            char v42 = Value;
            if (Value)
            {
              CFTypeID v43 = CFGetTypeID(Value);
              if (v43 == CFStringGetTypeID())
              {
                *(void *)std::string buf = v42;
                sub_100013168((const void **)__p, (CFTypeRef *)buf);
              }
            }
            uint64_t v44 = CFDictionaryGetValue(theDict, @"certificate");
            unsigned int v45 = v44;
            if (v44)
            {
              CFTypeID v46 = CFGetTypeID(v44);
              if (v46 == CFStringGetTypeID())
              {
                *(void *)std::string buf = v45;
                sub_100013168(&v91, (CFTypeRef *)buf);
              }
            }
            char v47 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              memset(buf, 0, sizeof(buf));
              ctu::cf::assign();
              uint64_t v87 = *(void *)&buf[16];
              *(_OWORD *)CFStringRef v86 = *(_OWORD *)buf;
              int v48 = (char)buf[23];
              uint64_t v49 = *(void ***)buf;
              memset(buf, 0, sizeof(buf));
              ctu::cf::assign();
              std::string::size_type v50 = v86;
              if (v48 < 0) {
                std::string::size_type v50 = v49;
              }
              *(_OWORD *)int v84 = *(_OWORD *)buf;
              uint64_t v85 = *(void *)&buf[16];
              char v51 = v84;
              if ((buf[23] & 0x80u) != 0) {
                char v51 = (void **)v84[0];
              }
              *(_DWORD *)uint64_t v92 = 136315394;
              *(void *)&v92[4] = v50;
              __int16 v93 = 2080;
              uint64_t v94 = v51;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I response: [%s] {%s}", v92, 0x16u);
              if (SHIBYTE(v85) < 0) {
                operator delete(v84[0]);
              }
              if (SHIBYTE(v87) < 0) {
                operator delete(v86[0]);
              }
            }
            sub_100057D78((const void **)&theDict);
            goto LABEL_101;
          }
          uint64_t v56 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            id v53 = "#E Unexpected JSON format, should be Dictionary";
            std::string::size_type v54 = v56;
            uint32_t v55 = 2;
            goto LABEL_100;
          }
        }
        else
        {
          long long v52 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 138412290;
            *(void *)&uint8_t buf[4] = v89;
            id v53 = "#E Invalid JSON response, error: %@";
            std::string::size_type v54 = v52;
            uint32_t v55 = 12;
LABEL_100:
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v53, buf, v55);
          }
        }
      }
LABEL_101:
      std::string::size_type v57 = __p[0];
      uint64_t v81 = __p[0];
      if (__p[0]) {
        CFRetain(__p[0]);
      }
      CFNumberRef v58 = v91;
      uint64_t v82 = v91;
      if (v91) {
        CFRetain(v91);
      }
      ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)&v90);
      sub_1000558F4(&v91);
      sub_1000558F4((const void **)__p);
      *(void *)std::string buf = v78;
      char v78 = v57;
      uint64_t v81 = 0;
      std::string v59 = sub_1000558F4((const void **)buf);
      *(void *)std::string buf = v77;
      uint64_t v77 = v58;
      uint64_t v82 = 0;
      sub_1000558F4(v59);
      sub_1000558F4(&v82);
      sub_1000558F4((const void **)&v81);
      sub_100030068((const void **)&v76);
      uint64_t v60 = *(void *)(a1 + 80);
      if (v60) {
        (*(void (**)(uint64_t, void *, const void *, const void *))(v60 + 16))(v60, v9, v78, v77);
      }
      sub_1000558F4(&v77);
      sub_1000558F4(&v78);
      goto LABEL_108;
    }
  }
}

void sub_1011AAD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24,uint64_t a25,uint64_t a26,void *aBlock,dispatch_object_t object,void *__p,uint64_t a30,uint64_t a31,const void *a32,const void *a33,const void *a34,const void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,const void *a49)
{
  sub_100057D78(&a49);
  ctu::ns::AutoPool::~AutoPool((ctu::ns::AutoPool *)(v51 - 256));
  sub_1000558F4((const void **)(v51 - 248));
  sub_1000558F4(&a35);
  sub_100030068(&a32);
  sub_1000558F4(&a33);
  sub_1000558F4(&a34);
  if (v50) {
    sub_10004D2C8(v50);
  }
  sub_10004D2C8(v49);
  _Unwind_Resume(a1);
}

void sub_1011AAF1C(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v6 = sub_100046F68(v3 + 336, (void **)(a1 + 56));
        if ((void **)(v3 + 344) != v6)
        {
          uint64_t v8 = (PersonalityInfo **)v6[7];
          int v7 = (std::__shared_weak_count *)v6[8];
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v8)
          {
            __int16 v9 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v10 = PersonalityInfo::logPrefix(*v8);
              int v12 = 136315394;
              uint64_t v13 = v10;
              __int16 v14 = 2080;
              uint64_t v15 = " ";
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sbackoff timer expired - issuing request if needed", (uint8_t *)&v12, 0x16u);
            }
            uint64_t v11 = v8[15];
            v8[15] = 0;
            if (v11) {
              (*(void (**)(PersonalityInfo *))(*(void *)v11 + 8))(v11);
            }
            sub_1011A51F4(v3, v8);
          }
          if (v7) {
            sub_10004D2C8(v7);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1011AB084(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1011AB0A8(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1 + 7;
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 56);
    a1[9] = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v5 = v6;
  }
  uint64_t result = *(void **)(a2 + 80);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[10] = result;
  return result;
}

void sub_1011AB120(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011AB13C(uint64_t a1)
{
  long long v2 = *(const void **)(a1 + 80);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1011AB1A0(uint64_t a1, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (a4)
  {
    uint64_t v41 = 0;
    char v42 = 0;
    v40[0] = 0;
    v40[1] = 0;
    ctu::cf::assign();
    *(_OWORD *)BOOL v38 = 0u;
    uint64_t v39 = 0;
    memset(__p, 0, sizeof(__p));
    ctu::cf::assign();
    *(_OWORD *)uint64_t v36 = 0u;
    uint64_t v37 = 0;
    sub_1011A68E0((uint64_t)__p, v5, (PersonalityInfo **)a2, (uint64_t)v36, (uint64_t)"updater");
    v35[0] = &v42;
    v35[1] = v40;
    sub_1011ABDA0((uint64_t)v35, (uint64_t)__p);
    if (SHIBYTE(v44) < 0) {
      operator delete(__p[1]);
    }
    sub_100127DDC((const void **)__p);
    if (v42) {
      uint64_t v8 = sub_1008A95D4;
    }
    else {
      uint64_t v8 = 0;
    }
    if (!v8) {
      goto LABEL_35;
    }
    if (*(void *)(a2 + 40)) {
      __int16 v9 = sub_1008A95D4;
    }
    else {
      __int16 v9 = 0;
    }
    if (!v9) {
      goto LABEL_29;
    }
    uint64_t v10 = *(unsigned __int8 *)(a2 + 71);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = (void *)*(unsigned __int8 *)(a2 + 71);
    }
    else {
      uint64_t v11 = *(void **)(a2 + 56);
    }
    int v12 = (void *)HIBYTE(v39);
    if (v39 < 0) {
      int v12 = v38[1];
    }
    if (v11 != v12) {
      goto LABEL_29;
    }
    uint64_t v13 = (const void **)(a2 + 48);
    if (v39 >= 0) {
      __int16 v14 = v38;
    }
    else {
      __int16 v14 = (void **)v38[0];
    }
    if ((v10 & 0x80) != 0)
    {
      if (memcmp(*v13, v14, *(void *)(a2 + 56)))
      {
LABEL_29:
        int v17 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v18 = (void *)PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
          LODWORD(__p[0]) = 136315394;
          *(void **)((char *)__p + 4) = v18;
          WORD2(__p[1]) = 2080;
          *(void **)((char *)&__p[1] + 6) = " ";
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%snew key-identifier received", (uint8_t *)__p, 0x16u);
        }
        goto LABEL_31;
      }
    }
    else if (*(unsigned char *)(a2 + 71))
    {
      while (*(unsigned __int8 *)v13 == *(unsigned __int8 *)v14)
      {
        uint64_t v13 = (const void **)((char *)v13 + 1);
        __int16 v14 = (void **)((char *)v14 + 1);
        if (!--v10) {
          goto LABEL_54;
        }
      }
      goto LABEL_29;
    }
LABEL_54:
    CFStringRef theString1 = 0;
    int v28 = *(_DWORD *)(a2 + 72);
    if (v28)
    {
      if (v28 == 1)
      {
        sub_1011A6F40((uint64_t)__p, v5, (PersonalityInfo **)a2);
        CFStringRef v29 = theString1;
        CFStringRef theString1 = v47;
        v35[0] = v29;
        CFStringRef v47 = 0;
        sub_1000558F4(v35);
        sub_1000558F4((const void **)&v47);
        if (v46 < 0) {
          operator delete(v45[0]);
        }
        if (SHIBYTE(v44) < 0) {
          operator delete(__p[1]);
        }
        sub_100127DDC((const void **)__p);
      }
    }
    else
    {
      sub_1011A6DA8((uint64_t)&v33, v5, a2, @"Certificate");
      sub_100056248(v35, &v33);
      __p[0] = (void *)theString1;
      CFStringRef theString1 = (CFStringRef)v35[0];
      v35[0] = 0;
      sub_1000558F4((const void **)__p);
      sub_1000558F4(v35);
      sub_1000577C4(&v33);
    }
    if (theString1) {
      uint64_t v30 = sub_1000810B8;
    }
    else {
      uint64_t v30 = 0;
    }
    if (v30)
    {
      CFComparisonResult v31 = CFStringCompare(theString1, a4, 1uLL);
      sub_1000558F4((const void **)&theString1);
      if (v31 == kCFCompareEqualTo)
      {
        unsigned int v20 = *(NSObject **)(v5 + 40);
        int v24 = 0;
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_43;
        }
        int v32 = (void *)PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        LODWORD(__p[0]) = 136315394;
        *(void **)((char *)__p + 4) = v32;
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = " ";
        CFDataRef v23 = "#I %s%scertificate is the same - update ignored";
LABEL_34:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)__p, 0x16u);
LABEL_35:
        int v24 = 0;
LABEL_43:
        if (SHIBYTE(v37) < 0) {
          operator delete(v36[0]);
        }
        if (SHIBYTE(v39) < 0) {
          operator delete(v38[0]);
        }
        if (SHIBYTE(v41) < 0) {
          operator delete(v40[0]);
        }
        sub_100127DDC(&v42);
        if (v24)
        {
          sub_1011A621C(v5, a2);
        }
        return;
      }
    }
    else
    {
      sub_1000558F4((const void **)&theString1);
    }
LABEL_31:
    int v19 = (*(uint64_t (**)(void, uint64_t, const __CFString *, const __CFString *, void, void, uint64_t, uint64_t))(**(void **)(v5 + 80) + 16))(*(void *)(v5 + 80), *(void *)a2 + 24, @"identity.encryption.key", a4, 0, 0, 4, a3);
    unsigned int v20 = *(NSObject **)(v5 + 40);
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (!v19)
    {
      if (v21)
      {
        unsigned int v25 = (void *)PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
        uint64_t v26 = v38;
        if (v39 < 0) {
          uint64_t v26 = (void **)v38[0];
        }
        BOOL v27 = v36;
        if (v37 < 0) {
          BOOL v27 = (void **)v36[0];
        }
        LODWORD(__p[0]) = 136315906;
        *(void **)((char *)__p + 4) = v25;
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = " ";
        HIWORD(__p[2]) = 2080;
        uint64_t v44 = v26;
        LOWORD(v45[0]) = 2080;
        *(void **)((char *)v45 + 2) = v27;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%scertificate updated to [%s]: {%s}", (uint8_t *)__p, 0x2Au);
      }
      int v24 = 1;
      goto LABEL_43;
    }
    if (!v21) {
      goto LABEL_35;
    }
    uint64_t v22 = (void *)PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = v22;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    CFDataRef v23 = "#W %s%sfailed to save updated certificate";
    goto LABEL_34;
  }
  uint64_t v15 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v16 = (void *)PersonalityInfo::logPrefix(*(PersonalityInfo **)a2);
    LODWORD(__p[0]) = 136315394;
    *(void **)((char *)__p + 4) = v16;
    WORD2(__p[1]) = 2080;
    *(void **)((char *)&__p[1] + 6) = " ";
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sno update on certificate", (uint8_t *)__p, 0x16u);
  }
}

void sub_1011AB788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,const void *a33,__int16 a34,char a35,char a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_100127DDC(&a33);
  _Unwind_Resume(a1);
}

void sub_1011AB838(uint64_t a1)
{
  long long v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v39 = "EncryptedIdentityManagement";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I | %s:", buf, 0xCu);
    long long v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 360));
    uint64_t v4 = asStringBool(*(unsigned char *)(a1 + 361));
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v39 = (const char *)v3;
    __int16 v40 = 2080;
    uint64_t v41 = (const char *)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I |  fWiFiAvailable %s, fInternetAvailable %s", buf, 0x16u);
  }
  uint64_t v5 = *(void **)(a1 + 336);
  if (v5 != (void *)(a1 + 344))
  {
    do
    {
      uint64_t v6 = v5[7];
      int v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v6);
        if (*(void *)(v6 + 40)) {
          __int16 v9 = sub_1008A95D4;
        }
        else {
          __int16 v9 = 0;
        }
        uint64_t v10 = "not ";
        if (v9) {
          uint64_t v10 = "";
        }
        uint64_t v11 = (const char *)(v6 + 48);
        if (*(char *)(v6 + 71) < 0) {
          uint64_t v11 = *(const char **)v11;
        }
        int v12 = *(_DWORD *)(v6 + 72);
        uint64_t v13 = "???";
        if (v12 == 1) {
          uint64_t v13 = "Update";
        }
        BOOL v14 = v12 == 0;
        *(_DWORD *)std::string buf = 136316162;
        uint64_t v15 = "CB";
        if (!v14) {
          uint64_t v15 = v13;
        }
        uint64_t v39 = (const char *)v8;
        __int16 v40 = 2080;
        uint64_t v41 = " ";
        __int16 v42 = 2080;
        uint64_t v43 = (uint64_t)v10;
        __int16 v44 = 2080;
        unsigned int v45 = v11;
        __int16 v46 = 2080;
        CFStringRef v47 = v15;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s|  fPubKey %spresent, fKeyIdentifier [%s], fPubKeySrc %s", buf, 0x34u);
        int v7 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v6);
        if (*(void *)(v6 + 80)) {
          int v17 = "";
        }
        else {
          int v17 = "not ";
        }
        if (*(void *)(v6 + 96)) {
          unsigned int v18 = "";
        }
        else {
          unsigned int v18 = "not ";
        }
        int v19 = *(_DWORD *)(v6 + 112);
        *(_DWORD *)std::string buf = 136316162;
        uint64_t v39 = (const char *)v16;
        __int16 v40 = 2080;
        uint64_t v41 = " ";
        __int16 v42 = 2080;
        uint64_t v43 = (uint64_t)v17;
        __int16 v44 = 2080;
        unsigned int v45 = v18;
        __int16 v46 = 1024;
        LODWORD(v47) = v19;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s|  fUpdater %spresent, fUpdateRequest %sissued, fUpdateFailures %u", buf, 0x30u);
        int v7 = *(NSObject **)(a1 + 40);
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v6);
        uint64_t v21 = asStringBool(*(unsigned char *)(v6 + 116));
        uint64_t v22 = "";
        if (!*(void *)(v6 + 120)) {
          uint64_t v22 = "not ";
        }
        int v23 = *(_DWORD *)(v6 + 128);
        *(_DWORD *)std::string buf = 136316162;
        uint64_t v39 = (const char *)v20;
        __int16 v40 = 2080;
        uint64_t v41 = " ";
        __int16 v42 = 2080;
        uint64_t v43 = v21;
        __int16 v44 = 2080;
        unsigned int v45 = v22;
        __int16 v46 = 1024;
        LODWORD(v47) = v23;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%s|  fNeedToRefresh %s, fRequestBackoffTimer %sactive, fUpdatesOnDemand %u", buf, 0x30u);
      }
      uint64_t v37 = 0;
      sub_1011A6DA8((uint64_t)buf, a1, v6, @"IncludeIMEI");
      sub_1000057AC(&v37, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      buf[0] = 0;
      ctu::cf::assign((ctu::cf *)buf, v37, v24);
      if (buf[0])
      {
        unsigned int v25 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v6);
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v39 = (const char *)v26;
          __int16 v40 = 2080;
          uint64_t v41 = " ";
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%s|  IncludeIMEI:true", buf, 0x16u);
        }
      }
      BOOL v27 = *(void **)(v6 + 16);
      if (v27 != (void *)(v6 + 24))
      {
        do
        {
          int v28 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v29 = PersonalityInfo::logPrefix(*(PersonalityInfo **)v6);
            uint64_t v30 = asString();
            unint64_t v31 = *((char *)v27 + 26);
            int v32 = "???";
            if (v31 <= 2) {
              int v32 = off_101A9A020[v31];
            }
            *(_DWORD *)std::string buf = 136315906;
            uint64_t v39 = (const char *)v29;
            __int16 v40 = 2080;
            uint64_t v41 = " ";
            __int16 v42 = 2080;
            uint64_t v43 = v30;
            __int16 v44 = 2080;
            unsigned int v45 = v32;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%s|  protection for %s : %s", buf, 0x2Au);
          }
          uint64_t v33 = (void *)v27[1];
          if (v33)
          {
            do
            {
              uint64_t v34 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v34 = (void *)v27[2];
              BOOL v14 = *v34 == (void)v27;
              BOOL v27 = v34;
            }
            while (!v14);
          }
          BOOL v27 = v34;
        }
        while (v34 != (void *)(v6 + 24));
      }
      sub_100062778((const void **)&v37);
      uint64_t v35 = (void *)v5[1];
      if (v35)
      {
        do
        {
          uint64_t v36 = v35;
          uint64_t v35 = (void *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          uint64_t v36 = (void *)v5[2];
          BOOL v14 = *v36 == (void)v5;
          uint64_t v5 = v36;
        }
        while (!v14);
      }
      uint64_t v5 = v36;
    }
    while (v36 != (void *)(a1 + 344));
  }
}

void sub_1011ABD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

__n128 sub_1011ABDA0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const void ***)a1;
  if (*(void *)a1 != a2)
  {
    uint64_t v5 = *v4;
    *uint64_t v4 = 0;
    uint64_t v8 = v5;
    *uint64_t v4 = *(const void **)a2;
    *(void *)a2 = 0;
    sub_100127DDC(&v8);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (*(char *)(v6 + 23) < 0) {
    operator delete(*(void **)v6);
  }
  __n128 result = *(__n128 *)(a2 + 8);
  *(void *)(v6 + 16) = *(void *)(a2 + 24);
  *(__n128 *)uint64_t v6 = result;
  *(unsigned char *)(a2 + 31) = 0;
  *(unsigned char *)(a2 + 8) = 0;
  return result;
}

void sub_1011ABE28(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011ABE60(uint64_t a1)
{
}

uint64_t sub_1011ABE7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011ABEC0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011ABEEC(ServiceManager::Service *this)
{
  *(void *)this = off_101A99BB8;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1011ABF48(ServiceManager::Service *this)
{
  *(void *)this = off_101A99BB8;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1011ABFB8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "EncryptedIdentityManagement");
}

unsigned char *sub_1011ABFC8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  long long v2 = operator new(1uLL);
  *a1 = v2;
  *long long v2 = 0;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1011AC004(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1011A4214(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1011A4214(v4, 0);
}

uint64_t sub_1011AC088()
{
  return 0;
}

uint64_t sub_1011AC090()
{
  return 1;
}

uint64_t sub_1011AC098()
{
  return 0;
}

void sub_1011AC0A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011AC184(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_1011AC298(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 64));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1011AC2E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1011AC2FC(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v3);
      uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
      if (v5)
      {
        if (std::__shared_weak_count::lock(v5))
        {
          uint64_t v6 = *(NSObject **)(v1 + 24);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          dispatch_retain(v6);
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_1011AC8E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25)
{
  if (a2)
  {
    sub_100163BC8(v29 - 128);
    if (a20) {
      (*(void (**)(uint64_t))(*(void *)a20 + 8))(a20);
    }
    std::__shared_weak_count::__release_weak(v27);
    sub_100168C78(v28);
    *(void *)(v29 - 128) = &a24;
    sub_100163C60((void ***)(v29 - 128));
    dispatch_release(v26);
    std::__shared_weak_count::__release_weak(v25);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011ACACC(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)__n128 result = 0;
      return result;
    case 2:
      uint64_t v5 = *(void *)a2;
      if (*(void *)a2)
      {
        dispatch_release(*(dispatch_object_t *)v5);
        uint64_t v6 = *(std::__shared_weak_count **)(v5 + 24);
        if (v6) {
          std::__shared_weak_count::__release_weak(v6);
        }
        operator delete();
      }
      goto LABEL_11;
    case 3:
      __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZZN27EncryptedIdentityManagement22notifyServiceBootstrapEN8d"
                                        "ispatch13group_sessionEENK3$_0clEvEUlbRKNSt3__16vectorINS5_12basic_stringIcNS5_1"
                                        "1char_traitsIcEENS5_9allocatorIcEEEENSA_ISC_EEEEE_EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZZN27EncryptedIdentityManagement22notifyServiceBootstrapEN8dispatch13group_sessionEENK3$_0clEvEUlbRKNSt3__16vectorINS5_12basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENSA_ISC_EEEEE_EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_11:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_1011ACC1C(void *a1, uint64_t a2, long long **a3)
{
  uint64_t v3 = (void *)*a1;
  memset(v7, 0, 24);
  sub_1000302C0((char *)v7, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  uint64_t v4 = v3[1];
  uint64_t v5 = v3[2];
  uint64_t v6 = (std::__shared_weak_count *)v3[3];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v8 = v5;
    __int16 v9 = v6;
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v6);
    std::__shared_weak_count::__release_weak(v6);
    std::__shared_weak_count::__release_weak(v6);
    std::__shared_weak_count::__release_weak(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    uint64_t v8 = v5;
    __int16 v9 = 0;
  }
  _OWORD v7[3] = off_101A99C48;
  void v7[4] = v4;
  sub_100168470();
}

void sub_1011ACD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  sub_100168C78((uint64_t *)&a13);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  a13 = (void **)&a10;
  sub_100047F64(&a13);
  _Unwind_Resume(a1);
}

void sub_1011ACD50(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    int v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZZN27EncryptedIdentityManagement22notifyServiceBootstrapEN8dispatch13gro"
                                                "up_sessionEENK3$_0clEvEUlbRKNSt3__16vectorINS3_12basic_stringIcNS3_11cha"
                                                "r_traitsIcEENS3_9allocatorIcEEEENS8_ISA_EEEEE_" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZZN27EncryptedIdentityManagement22notifyServiceBootstrapEN8dispatch13group_sessionEENK3$_0clEvEUlbRKNSt3__16vectorINS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEENS8_ISA_EEEEE_" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_1011ACE34(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = *(const void ***)a1;
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (*(void *)(a1 + 8)) {
        sub_1011A433C(v5, a2);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1011ACEB0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1011ACEC4(void *a1)
{
  *a1 = off_101A99C78;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011ACF10(void *a1)
{
  *a1 = off_101A99C78;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1011ACF7C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_1011AD02C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1011AD044(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_1011AD064()
{
}

void *sub_1011AD0D0(void *a1)
{
  *a1 = off_101A99CC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011AD11C(void *a1)
{
  *a1 = off_101A99CC8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1011AD188()
{
}

void sub_1011AD1F8()
{
}

__n128 sub_1011AD20C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A99D08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1011AD260(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A99D08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011AD298(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1011AD2E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011AD320()
{
}

void *sub_1011AD32C(void *a1)
{
  *a1 = off_101A99D88;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011AD378(void *a1)
{
  *a1 = off_101A99D88;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011AD3E4(uint64_t a1)
{
  __n128 result = (char *)operator new(0x28uLL);
  *(void *)__n128 result = off_101A99D88;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011AD448(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A99D88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011AD488(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011AD498(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011AD4D8(uint64_t *a1, xpc_object_t *a2)
{
  sub_1005BEA0C(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3])
      {
        int v7 = *(void **)(v4 + 264);
        if (v7 == (void *)(v4 + 272))
        {
          if (*(unsigned char *)(v4 + 361)) {
            *(unsigned char *)(v4 + 361) = 0;
          }
        }
        else
        {
          char v8 = 0;
          do
          {
            char v9 = ConnectionAvailabilityContainer::available();
            if (v9)
            {
              if (*(unsigned char *)(v4 + 361)) {
                goto LABEL_28;
              }
              *(unsigned char *)(v4 + 361) = 1;
              goto LABEL_21;
            }
            uint64_t v10 = (void *)v7[1];
            if (v10)
            {
              do
              {
                uint64_t v11 = v10;
                uint64_t v10 = (void *)*v10;
              }
              while (v10);
            }
            else
            {
              do
              {
                uint64_t v11 = (void *)v7[2];
                BOOL v12 = *v11 == (void)v7;
                int v7 = v11;
              }
              while (!v12);
            }
            v8 |= v9;
            int v7 = v11;
          }
          while (v11 != (void *)(v4 + 272));
          if (*(unsigned char *)(v4 + 361) == (v8 & 1)) {
            goto LABEL_28;
          }
          *(unsigned char *)(v4 + 361) = v8 & 1;
          if ((v8 & 1) == 0) {
            goto LABEL_28;
          }
LABEL_21:
          uint64_t v13 = *(void **)(v4 + 336);
          if (v13 != (void *)(v4 + 344))
          {
            do
            {
              sub_1011A51F4((const void **)v4, v13[7]);
              BOOL v14 = (void *)v13[1];
              if (v14)
              {
                do
                {
                  uint64_t v15 = v14;
                  BOOL v14 = (void *)*v14;
                }
                while (v14);
              }
              else
              {
                do
                {
                  uint64_t v15 = (void *)v13[2];
                  BOOL v12 = *v15 == (void)v13;
                  uint64_t v13 = v15;
                }
                while (!v12);
              }
              uint64_t v13 = v15;
            }
            while (v15 != (void *)(v4 + 344));
          }
        }
      }
LABEL_28:
      sub_10004D2C8(v6);
    }
  }
}

void sub_1011AD648(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011AD660(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011AD6A0()
{
}

void *sub_1011AD6AC(void *a1)
{
  *a1 = off_101A99E08;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011AD6F8(void *a1)
{
  *a1 = off_101A99E08;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011AD764(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A99E08;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011AD7C8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A99E08;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011AD808(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011AD818(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011AD858(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (!v4) {
    return;
  }
  uint64_t v6 = a1[1];
  int v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  char v8 = v7;
  if (a1[2])
  {
    char v9 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      asString();
      uint64_t v10 = v50 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I event: %s", buf, 0xCu);
      if (SHIBYTE(v50) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v11 = *(void *)(v6 + 248);
    BOOL v12 = *(void **)v11;
    uint64_t v13 = *(void **)(v11 + 8);
    if (*(void **)v11 == v13) {
      goto LABEL_21;
    }
    while (!sub_10001D294((unsigned __int8 *)(*v12 + 24), (unsigned __int8 *)a3))
    {
      v12 += 2;
      if (v12 == v13)
      {
        BOOL v12 = v13;
        break;
      }
    }
    if (v12 == *(void **)(v11 + 8))
    {
LABEL_21:
      uint64_t v15 = 0;
      BOOL v14 = 0;
    }
    else
    {
      uint64_t v15 = *v12;
      BOOL v14 = (std::__shared_weak_count *)v12[1];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v15)
      {
        if (*(unsigned char *)(v15 + 49))
        {
LABEL_132:
          if (v14) {
            sub_10004D2C8(v14);
          }
          goto LABEL_134;
        }
        int v16 = 0;
LABEL_23:
        int v17 = (void **)(v6 + 336);
        unsigned int v18 = sub_100046F68(v6 + 336, (void **)a3);
        int v19 = (char **)(v6 + 344);
        if ((void **)(v6 + 344) == v18)
        {
          BOOL v22 = 0;
          uint64_t v21 = 0;
          uint64_t v20 = 0;
        }
        else
        {
          uint64_t v20 = v18[7];
          uint64_t v21 = (std::__shared_weak_count *)v18[8];
          if (v21) {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          BOOL v22 = v20 != 0;
          if (v20) {
            char v23 = v16;
          }
          else {
            char v23 = 1;
          }
          if ((v23 & 1) == 0)
          {
            if (v14) {
              atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            CFBooleanRef v24 = (std::__shared_weak_count *)v20[1];
            *uint64_t v20 = v15;
            v20[1] = v14;
            if (v24) {
              sub_10004D2C8(v24);
            }
            BOOL v22 = 1;
          }
        }
        switch(*(unsigned char *)(a3 + 24))
        {
          case 0:
            if (((v16 | v22) & 1) == 0)
            {
              int v48 = v21;
              unint64_t v31 = (char *)operator new(0xA0uLL);
              int v32 = (std::__shared_weak_count *)v31;
              *((void *)v31 + 1) = 0;
              *((void *)v31 + 2) = 0;
              *(void *)unint64_t v31 = off_101A99F08;
              if (v14)
              {
                atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
                atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *((void *)v31 + 6) = 0;
              *((void *)v31 + 3) = v15;
              *((void *)v31 + 4) = v14;
              *((void *)v31 + 7) = 0;
              *((void *)v31 + 5) = v31 + 48;
              *((_OWORD *)v31 + 4) = 0u;
              *((_OWORD *)v31 + 5) = 0u;
              *((_DWORD *)v31 + 24) = 0;
              *(_OWORD *)(v31 + 104) = 0u;
              *(_OWORD *)(v31 + 120) = 0u;
              *(void *)(v31 + 133) = 0;
              *((void *)v31 + 18) = 0;
              *((void *)v31 + 19) = 0;
              if (v14) {
                sub_10004D2C8(v14);
              }
              if (*(char *)(a3 + 23) < 0)
              {
                sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)a3;
                uint64_t v50 = *(void *)(a3 + 16);
              }
              *(void *)&long long v51 = v32 + 1;
              *((void *)&v51 + 1) = v32;
              atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v33 = *v19;
              uint64_t v34 = (char **)(v6 + 344);
              uint64_t v35 = (char **)(v6 + 344);
              if (!*v19) {
                goto LABEL_74;
              }
              uint64_t v34 = (char **)(v6 + 344);
              while (1)
              {
                while (1)
                {
                  uint64_t v35 = (char **)v33;
                  uint64_t v36 = v33 + 32;
                  if ((sub_100046FE8(__p, (void **)v33 + 4) & 0x80) == 0) {
                    break;
                  }
                  uint64_t v33 = *v35;
                  uint64_t v34 = v35;
                  if (!*v35) {
                    goto LABEL_74;
                  }
                }
                if ((sub_100046FE8(v36, __p) & 0x80) == 0) {
                  break;
                }
                uint64_t v34 = v35 + 1;
                uint64_t v33 = v35[1];
                if (!v33) {
                  goto LABEL_74;
                }
              }
              if (!*v34)
              {
LABEL_74:
                uint64_t v66 = 0;
                uint64_t v37 = (char *)operator new(0x48uLL);
                *(void *)std::string buf = v37;
                *(void *)&uint8_t buf[8] = v6 + 344;
                BOOL v38 = v37 + 32;
                if (SHIBYTE(v50) < 0)
                {
                  sub_10004FC84(v38, __p[0], (unint64_t)__p[1]);
                }
                else
                {
                  *(_OWORD *)BOOL v38 = *(_OWORD *)__p;
                  *((void *)v37 + 6) = v50;
                }
                *(_OWORD *)(v37 + 56) = v51;
                long long v51 = 0uLL;
                LOBYTE(v66) = 1;
                *(void *)uint64_t v37 = 0;
                *((void *)v37 + 1) = 0;
                *((void *)v37 + 2) = v35;
                void *v34 = v37;
                uint64_t v39 = (void *)**v17;
                if (v39)
                {
                  *int v17 = v39;
                  uint64_t v37 = *v34;
                }
                sub_100046C90(*(uint64_t **)(v6 + 344), (uint64_t *)v37);
                ++*(void *)(v6 + 352);
                *(void *)std::string buf = 0;
                sub_1001FEBC4((uint64_t)buf);
              }
              if (*((void *)&v51 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v51 + 1));
              }
              uint64_t v21 = v48;
              if (SHIBYTE(v50) < 0) {
                operator delete(__p[0]);
              }
              v60[0] = 0;
              v60[1] = 0;
              uint64_t v61 = 0;
              v58[0] = 0;
              v58[1] = 0;
              uint64_t v59 = 0;
              if (!sub_1000BF7B4(v6 + 48, @"identity.encryption.key"))
              {
                sub_1000C0E74(v6 + 48, @"identity.encryption.key");
                uint64_t v40 = *(void *)(v6 + 80);
                if (SHIBYTE(v59) < 0)
                {
                  sub_10004FC84(__dst, v58[0], (unint64_t)v58[1]);
                }
                else
                {
                  *(_OWORD *)long long __dst = *(_OWORD *)v58;
                  uint64_t v56 = v59;
                }
                if (SHIBYTE(v56) < 0)
                {
                  sub_10004FC84(buf, __dst[0], (unint64_t)__dst[1]);
                }
                else
                {
                  *(_OWORD *)std::string buf = *(_OWORD *)__dst;
                  uint64_t v66 = v56;
                }
                std::string::size_type v63 = 0;
                if (SHIBYTE(v66) < 0)
                {
                  sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  *(_OWORD *)std::string __p = *(_OWORD *)buf;
                  uint64_t v50 = v66;
                }
                int v64 = 0;
                if (ctu::cf::convert_copy())
                {
                  __int16 v44 = v63;
                  std::string::size_type v63 = v64;
                  v52[0] = v44;
                  sub_1000558F4((const void **)v52);
                }
                if (SHIBYTE(v50) < 0) {
                  operator delete(__p[0]);
                }
                std::string::size_type v57 = v63;
                std::string::size_type v63 = 0;
                sub_1000558F4((const void **)&v63);
                if (SHIBYTE(v66) < 0) {
                  operator delete(*(void **)buf);
                }
                unsigned int v45 = v57;
                if (SHIBYTE(v61) < 0)
                {
                  sub_10004FC84(v52, v60[0], (unint64_t)v60[1]);
                }
                else
                {
                  *(_OWORD *)long long v52 = *(_OWORD *)v60;
                  uint64_t v53 = v61;
                }
                if (SHIBYTE(v53) < 0)
                {
                  sub_10004FC84(buf, v52[0], (unint64_t)v52[1]);
                }
                else
                {
                  *(_OWORD *)std::string buf = *(_OWORD *)v52;
                  uint64_t v66 = v53;
                }
                uint64_t v62 = 0;
                if (SHIBYTE(v66) < 0)
                {
                  sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  *(_OWORD *)std::string __p = *(_OWORD *)buf;
                  uint64_t v50 = v66;
                }
                std::string::size_type v63 = 0;
                if (ctu::cf::convert_copy())
                {
                  __int16 v46 = v62;
                  uint64_t v62 = v63;
                  int v64 = v46;
                  sub_1000558F4((const void **)&v64);
                }
                if (SHIBYTE(v50) < 0) {
                  operator delete(__p[0]);
                }
                CFStringRef v47 = v62;
                std::string::size_type v54 = v62;
                uint64_t v62 = 0;
                sub_1000558F4((const void **)&v62);
                if (SHIBYTE(v66) < 0) {
                  operator delete(*(void **)buf);
                }
                (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, void, void, uint64_t, const void *))(*(void *)v40 + 16))(v40, a3, @"identity.encryption.key", v45, 0, 0, 4, v47);
                sub_1000558F4(&v54);
                if (SHIBYTE(v53) < 0) {
                  operator delete(v52[0]);
                }
                sub_1000558F4(&v57);
                if (SHIBYTE(v56) < 0) {
                  operator delete(__dst[0]);
                }
              }
              if (SHIBYTE(v59) < 0) {
                operator delete(v58[0]);
              }
              if (SHIBYTE(v61) < 0) {
                operator delete(v60[0]);
              }
              sub_10004D2C8(v32);
            }
            break;
          case 1:
            if (v22) {
              goto LABEL_63;
            }
            break;
          case 4:
            if (v22)
            {
              (*(void (**)(void, uint64_t, const __CFString *, void, void, uint64_t))(**(void **)(v6 + 80) + 32))(*(void *)(v6 + 80), a3, @"identity.encryption.key", 0, 0, 4);
              sub_1011A43CC(v6, (uint64_t)v20);
            }
            break;
          case 5:
            if (v22) {
LABEL_63:
            }
              sub_1011A43CC(v6, (uint64_t)v20);
            break;
          case 6:
          case 7:
            if (v22)
            {
              unsigned int v25 = *v19;
              if (*v19)
              {
                uint64_t v26 = v6 + 344;
                do
                {
                  char v27 = sub_100046FE8((void *)v25 + 4, (void **)a3);
                  if (v27 >= 0) {
                    int v28 = (char **)v25;
                  }
                  else {
                    int v28 = (char **)(v25 + 8);
                  }
                  if (v27 >= 0) {
                    uint64_t v26 = (uint64_t)v25;
                  }
                  unsigned int v25 = *v28;
                }
                while (*v28);
                if ((char **)v26 != v19 && (sub_100046FE8((void *)a3, (void **)(v26 + 32)) & 0x80) == 0)
                {
                  uint64_t v29 = *(void **)(v26 + 8);
                  if (v29)
                  {
                    do
                    {
                      uint64_t v30 = v29;
                      uint64_t v29 = (void *)*v29;
                    }
                    while (v29);
                  }
                  else
                  {
                    uint64_t v41 = (void *)v26;
                    do
                    {
                      uint64_t v30 = (void *)v41[2];
                      BOOL v42 = *v30 == (void)v41;
                      uint64_t v41 = v30;
                    }
                    while (!v42);
                  }
                  if (*v17 == (void *)v26) {
                    *int v17 = v30;
                  }
                  uint64_t v43 = *(uint64_t **)(v6 + 344);
                  --*(void *)(v6 + 352);
                  sub_10005EE6C(v43, (uint64_t *)v26);
                  sub_1001FEC1C(v26 + 32);
                  operator delete((void *)v26);
                }
              }
            }
            break;
          default:
            break;
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
        goto LABEL_132;
      }
    }
    int v16 = 1;
    goto LABEL_23;
  }
LABEL_134:

  sub_10004D2C8(v8);
}

void sub_1011AE0A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,const void *a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_1000558F4((const void **)(v49 - 152));
  if (*(char *)(v49 - 105) < 0) {
    operator delete(*(void **)(v49 - 128));
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a34);
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  sub_10004D2C8(v48);
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v47) {
    sub_10004D2C8(v47);
  }
  sub_10004D2C8(v46);
  _Unwind_Resume(a1);
}

uint64_t sub_1011AE224(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011AE264()
{
}

void *sub_1011AE270(void *a1)
{
  *a1 = off_101A99E88;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011AE2BC(void *a1)
{
  *a1 = off_101A99E88;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011AE328(uint64_t a1)
{
  __n128 result = (char *)operator new(0x28uLL);
  *(void *)__n128 result = off_101A99E88;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011AE38C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A99E88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011AE3CC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011AE3DC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011AE41C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  xpc_object_t v4 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v4);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  sub_10010C0E0(v3, *(void **)(v3 + 8));
  *(void *)uint64_t v3 = v3 + 8;
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 8) = 0;
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v24, object, 0);
    xpc_release(object[0]);
    object[0] = v4;
    if (v4) {
      xpc_retain(v4);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v4);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v23, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v25; ; uint64_t i = ++v25)
    {
      if (i == v23[1] && v24 == v23[0])
      {
        xpc_release(v24);
        xpc_release(v24);
        goto LABEL_44;
      }
      xpc_object_t v22 = 0;
      object[0] = &v24;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v22);
      if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_42:
      xpc_release(v22);
    }
    memset(__p, 0, sizeof(__p));
    *(_OWORD *)dispatch_object_t object = 0u;
    xpc_object_t v7 = v22;
    if (v22)
    {
      xpc_retain(v22);
      xpc_object_t v28 = v7;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v28 = v7;
      if (!v7)
      {
        xpc_object_t v8 = xpc_null_create();
        xpc_object_t v7 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v7);
      xpc_object_t v8 = v7;
LABEL_27:
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        unint64_t v31 = &v28;
        int v32 = "first";
        sub_100048BAC((uint64_t)&v31, v29);
        read_rest_value();
        xpc_release(v29[0]);
        v26[0] = &v28;
        v26[1] = "second";
        sub_100048BAC((uint64_t)v26, &v27);
        unint64_t v31 = 0;
        int v32 = 0;
        uint64_t v33 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v33) < 0) {
          operator delete(v31);
        }
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
        *(_OWORD *)&__p[1] = *(_OWORD *)v29;
        __p[3] = v30;
        xpc_release(v27);
        xpc_object_t v8 = v28;
      }
      xpc_release(v8);
      xpc_release(v7);
      v29[0] = 0;
      char v9 = (uint64_t **)sub_100046ED4(v3, v29, object);
      if (!*v9)
      {
        uint64_t v33 = 0;
        uint64_t v10 = (char *)operator new(0x50uLL);
        unint64_t v31 = (xpc_object_t *)v10;
        int v32 = (const char *)(v3 + 8);
        LOBYTE(v33) = 0;
        uint64_t v11 = v10 + 32;
        if (SHIBYTE(__p[0]) < 0)
        {
          sub_10004FC84(v11, object[0], (unint64_t)object[1]);
          BOOL v12 = (uint64_t *)v31;
        }
        else
        {
          *(_OWORD *)uint64_t v11 = *(_OWORD *)object;
          *((void **)v10 + 6) = __p[0];
          BOOL v12 = (uint64_t *)v10;
        }
        *(_OWORD *)(v10 + 56) = *(_OWORD *)&__p[1];
        *((void **)v10 + 9) = __p[3];
        memset(&__p[1], 0, 24);
        LOBYTE(v33) = 1;
        sub_100046C38((uint64_t **)v3, (uint64_t)v29[0], v9, v12);
        unint64_t v31 = 0;
        sub_10010E764((uint64_t)&v31, 0);
      }
      if (SHIBYTE(__p[3]) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_42;
    }
    xpc_object_t v8 = xpc_null_create();
LABEL_26:
    xpc_object_t v28 = v8;
    goto LABEL_27;
  }
LABEL_44:
  xpc_release(v4);
  uint64_t v13 = (std::__shared_weak_count *)a1[4];
  if (v13)
  {
    uint64_t v14 = a1[2];
    uint64_t v15 = std::__shared_weak_count::lock(v13);
    if (v15)
    {
      if (a1[3])
      {
        int v16 = *(void **)(v14 + 336);
        if (v16 != (void *)(v14 + 344))
        {
          do
          {
            *(_DWORD *)(v16[7] + 132) = 0;
            int v17 = (void *)v16[1];
            if (v17)
            {
              do
              {
                unsigned int v18 = v17;
                int v17 = (void *)*v17;
              }
              while (v17);
            }
            else
            {
              do
              {
                unsigned int v18 = (void *)v16[2];
                BOOL v19 = *v18 == (void)v16;
                int v16 = v18;
              }
              while (!v19);
            }
            int v16 = v18;
          }
          while (v18 != (void *)(v14 + 344));
        }
      }
      sub_10004D2C8(v15);
    }
  }
}

void sub_1011AE87C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,xpc_object_t a21,xpc_object_t a22,uint64_t a23,xpc_object_t a24,uint64_t a25,uint64_t a26,uint64_t a27,xpc_object_t a28,xpc_object_t a29,xpc_object_t a30)
{
  xpc_release(object);
  xpc_release(a24);
  xpc_release(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_1011AE9A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011AE9E0()
{
}

void sub_1011AE9EC(uint64_t **a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v14 = a1;
  uint64_t v2 = **a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(v2 + 48));
  xpc_object_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, v15);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
  memset(v15, 0, sizeof(v15));
  sub_1011A433C((const void **)v2, v13);
  int v16 = (void **)v15;
  sub_100047F64(&v16);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  operator delete();
}

void sub_1011AEB44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_100047F64(&a14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  operator delete();
}

void sub_1011AEBA0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A99F08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011AEBC0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A99F08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011AEC14(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 128);
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 112);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  sub_100127DDC((const void **)(a1 + 64));
  sub_10005D144(*(void **)(a1 + 48));
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void *sub_1011AECC4(uint64_t **a1, unsigned __int8 a2, unsigned char *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = (unsigned __int8 *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unsigned int v8 = v5[25];
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = (unsigned __int8 *)*v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = (unsigned __int8 *)v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    char v9 = v7;
    uint64_t v7 = operator new(0x20uLL);
    *((unsigned char *)v7 + 25) = *a3;
    *((unsigned char *)v7 + 26) = 0;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    unsigned __int8 *v6 = v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t sub_1011AED98(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = sub_100046F68(*v1 + 336, (void **)v1[1]);
  if ((void **)(v2 + 344) == v3)
  {
    unint64_t v5 = 0;
LABEL_19:
    char v15 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = (const char *)v1[1];
      uint64_t v17 = *((unsigned __int8 *)v16 + 23);
      BOOL v18 = (v17 & 0x80u) != 0;
      if ((v17 & 0x80u) != 0) {
        uint64_t v17 = *((void *)v16 + 1);
      }
      if (v18) {
        int v16 = *(const char **)v16;
      }
      if (!v17) {
        int v16 = "<invalid>";
      }
      int v20 = 136315138;
      uint64_t v21 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E No model for %s", (uint8_t *)&v20, 0xCu);
    }
    goto LABEL_27;
  }
  xpc_object_t v4 = v3[7];
  unint64_t v5 = (std::__shared_weak_count *)v3[8];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v4) {
    goto LABEL_19;
  }
  unsigned int v8 = (char **)v4[3];
  uint64_t v6 = (char *)(v4 + 3);
  uint64_t v7 = v8;
  if (v8)
  {
    unsigned int v9 = *(unsigned __int8 *)v1[2];
    uint64_t v10 = v6;
    do
    {
      unsigned int v11 = *((unsigned __int8 *)v7 + 25);
      BOOL v12 = v11 >= v9;
      if (v11 >= v9) {
        int v13 = v7;
      }
      else {
        int v13 = v7 + 1;
      }
      if (v12) {
        uint64_t v10 = (char *)v7;
      }
      uint64_t v7 = (char **)*v13;
    }
    while (*v13);
    if (v10 != v6 && v10[25] <= v9)
    {
      uint64_t v14 = v10[26];
      if (!v5) {
        return v14;
      }
      goto LABEL_28;
    }
  }
LABEL_27:
  uint64_t v14 = 0;
  if (v5) {
LABEL_28:
  }
    sub_10004D2C8(v5);
  return v14;
}

uint64_t sub_1011AEF00(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1011AEF3C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1011AEF78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_1011AEFF8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v27 = a1;
  uint64_t v28 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 248);
  uint64_t v4 = *(void **)v3;
  unint64_t v5 = *(void **)(v3 + 8);
  if (v4 != v5)
  {
    while (*(unsigned char *)(*v4 + 49) || *(_DWORD *)(*v4 + 52) != *(_DWORD *)(v1 + 8))
    {
      v4 += 2;
      if (v4 == v5) {
        goto LABEL_26;
      }
    }
  }
  if (v4 == v5)
  {
LABEL_26:
    uint64_t v6 = 0;
LABEL_27:
    uint8_t v19 = 0;
    goto LABEL_28;
  }
  uint64_t v7 = *v4;
  uint64_t v6 = (std::__shared_weak_count *)v4[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v7) {
    goto LABEL_27;
  }
  unsigned int v8 = sub_100046F68(v2 + 336, (void **)(v7 + 24));
  if ((void **)(v2 + 344) == v8)
  {
    uint64_t v10 = 0;
LABEL_33:
    xpc_object_t v22 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(unsigned __int8 *)(v7 + 47);
      BOOL v24 = (v23 & 0x80u) != 0;
      if ((v23 & 0x80u) != 0) {
        uint64_t v23 = *(void *)(v7 + 32);
      }
      if (v24) {
        unsigned int v25 = *(const char **)(v7 + 24);
      }
      else {
        unsigned int v25 = (const char *)(v7 + 24);
      }
      if (v23) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v30 = v26;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#E supportsIdentityProtection, No model for %s", buf, 0xCu);
    }
    goto LABEL_43;
  }
  unsigned int v9 = v8[7];
  uint64_t v10 = (std::__shared_weak_count *)v8[8];
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v9) {
    goto LABEL_33;
  }
  int v13 = (char **)v9[3];
  unsigned int v11 = (char *)(v9 + 3);
  BOOL v12 = v13;
  if (v13)
  {
    unsigned int v14 = *(unsigned __int8 *)(v1 + 12);
    char v15 = v11;
    do
    {
      unsigned int v16 = *((unsigned __int8 *)v12 + 25);
      BOOL v17 = v16 >= v14;
      if (v16 >= v14) {
        BOOL v18 = v12;
      }
      else {
        BOOL v18 = v12 + 1;
      }
      if (v17) {
        char v15 = (char *)v12;
      }
      BOOL v12 = (char **)*v18;
    }
    while (*v18);
    if (v15 != v11 && v15[25] <= v14)
    {
      uint8_t v19 = v15[26];
      goto LABEL_44;
    }
  }
LABEL_43:
  uint8_t v19 = 0;
LABEL_44:
  if (v10) {
    sub_10004D2C8(v10);
  }
LABEL_28:
  uint64_t v20 = *(void *)(v1 + 40);
  buf[0] = v19;
  if (!v20) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v20 + 48))(v20, buf);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_1011AF254(&v28);
  return sub_100046B58((uint64_t *)&v27);
}

void sub_1011AF22C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1011AF254(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011AF254(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100DAFF9C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_1011AF2A4(uint64_t a1@<X0>, const void **a2@<X8>)
{
}

const void **sub_1011AF2C0(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    unint64_t v5 = 0;
    sub_100030068(&v6);
  }
  return sub_100030068(&v5);
}

const void **sub_1011AF338(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    unint64_t v5 = 0;
    sub_100030068(&v6);
  }
  return sub_100030068(&v5);
}

uint64_t sub_1011AF3B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_1011AF430(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  unsigned int v16 = 0;
  BOOL v17 = 0;
  uint64_t v3 = *(void *)(v2 + 248);
  uint64_t v4 = *(void **)v3;
  unint64_t v5 = *(void **)(v3 + 8);
  if (v4 != v5)
  {
    while (*(unsigned char *)(*v4 + 49) || *(_DWORD *)(*v4 + 52) != *(_DWORD *)(v1 + 8))
    {
      v4 += 2;
      if (v4 == v5) {
        goto LABEL_11;
      }
    }
  }
  if (v4 == v5)
  {
LABEL_11:
    unsigned int v11 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = (const void *)*v4;
    uint64_t v7 = (std::__shared_weak_count *)v4[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      uint64_t v8 = (uint64_t)v6 + 24;
      sub_1011A79D0(&v18, v2, (uint64_t)v6 + 24, *(unsigned __int8 *)(v1 + 24), *(const __CFString **)(v1 + 16));
      unsigned int v9 = v17;
      BOOL v17 = v18;
      BOOL v18 = 0;
      uint8_t v19 = v9;
      sub_100030068(&v19);
      sub_100030068(&v18);
      sub_1011A86E8(&v18, v2, v8);
      uint64_t v10 = v16;
      unsigned int v16 = v18;
      BOOL v18 = 0;
      uint8_t v19 = v10;
      sub_1000558F4(&v19);
      sub_1000558F4(&v18);
      unsigned int v11 = v16;
      uint64_t v6 = v17;
    }
    else
    {
      unsigned int v11 = 0;
    }
  }
  uint64_t v12 = *(void *)(v1 + 56);
  BOOL v18 = v11;
  uint8_t v19 = v6;
  if (!v12) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **, const void **))(*(void *)v12 + 48))(v12, &v19, &v18);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_1000558F4(&v16);
  sub_100030068(&v17);
  sub_1011AF5F8(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_1011AF5B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_1000558F4(&a11);
  sub_100030068(&a12);
  sub_1011AF5F8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011AF5F8(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100DB04A4((void *)(v1 + 32));
    sub_1000558F4((const void **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_1011AF650(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_1011A8864(*(void *)v1, v1 + 8, *(unsigned __int8 *)(v1 + 40));
  sub_1011AF6B8(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1011AF69C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1011AF6B8(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100030068((const void **)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1011AF718(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 248);
  uint64_t v4 = *(void **)v3;
  unint64_t v5 = *(void **)(v3 + 8);
  if (v4 != v5)
  {
    while (*(unsigned char *)(*v4 + 49) || *(_DWORD *)(*v4 + 52) != *(_DWORD *)(v1 + 8))
    {
      v4 += 2;
      if (v4 == v5) {
        goto LABEL_13;
      }
    }
  }
  if (v4 != v5)
  {
    uint64_t v6 = *v4;
    uint64_t v7 = (std::__shared_weak_count *)v4[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      sub_1011A8864(v2, v6 + 24, *(unsigned __int8 *)(v1 + 24));
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
LABEL_13:
  sub_1011AF7F4(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1011AF7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1011AF7F4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011AF7F4(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1000577C4((const void **)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_1011AF844(uint64_t a1@<X0>, void *a2@<X8>)
{
}

const void **sub_1011AF854(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    unint64_t v5 = 0;
    sub_1000558F4(&v6);
  }
  return sub_1000558F4(&v5);
}

const void **sub_1011AF8CC(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    uint64_t v6 = v3;
    *uint64_t v2 = v5;
    unint64_t v5 = 0;
    sub_1000558F4(&v6);
  }
  return sub_1000558F4(&v5);
}

void sub_1011AF944(uint64_t a1@<X0>, const void **a2@<X8>)
{
}

uint64_t *sub_1011AF95C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 248);
  uint64_t v4 = *(void **)v3;
  unint64_t v5 = *(void **)(v3 + 8);
  if (v4 != v5)
  {
    while (*(unsigned char *)(*v4 + 49) || *(_DWORD *)(*v4 + 52) != *(_DWORD *)(v1 + 8))
    {
      v4 += 2;
      if (v4 == v5) {
        goto LABEL_13;
      }
    }
  }
  if (v4 != v5)
  {
    uint64_t v6 = *v4;
    uint64_t v7 = (std::__shared_weak_count *)v4[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      sub_1011A8D44((const void **)&v11, v2, (void **)(v6 + 24), *(unsigned __int8 *)(v1 + 12));
      sub_100C423A4(v1 + 16, v11);
      sub_1000558F4((const void **)&v11);
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
LABEL_13:
  sub_1011AFA60(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1011AFA28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  sub_1000558F4((const void **)va2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1011AFA60((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011AFA60(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1007F0208((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_1011AFAB0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_1011AFB30(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  unsigned int v9 = v1;
  uint64_t v2 = *v1;
  unsigned int v16 = 0;
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  uint64_t v3 = (char *)operator new(0x80uLL);
  *((void *)v3 + 1) = 0;
  *((void *)v3 + 2) = 0;
  *(void *)uint64_t v3 = off_1019C7410;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *((void *)v3 + 14) = 0;
  *((void *)v3 + 15) = 0;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *((_DWORD *)v3 + 20) = -1;
  v3[88] = 1;
  *((void *)v3 + 12) = 0;
  *((void *)v3 + 13) = 0;
  v3[120] = 0;
  uint64_t v4 = (char *)operator new(0xA0uLL);
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *(void *)uint64_t v4 = off_101A99F08;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
  *((void *)v4 + 3) = v3 + 24;
  *((void *)v4 + 7) = 0;
  *((void *)v4 + 6) = 0;
  *((void *)v4 + 4) = v3;
  *((void *)v4 + 5) = v4 + 48;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_DWORD *)v4 + 24) = 0;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(void *)(v4 + 133) = 0;
  *((void *)v4 + 18) = 0;
  *((void *)v4 + 19) = 0;
  sub_10004D2C8((std::__shared_weak_count *)v3);
  long long v17 = 0uLL;
  uint64_t v18 = 0;
  ctu::cf::assign();
  *(_OWORD *)uint64_t v10 = 0uLL;
  uint64_t v11 = 0;
  sub_1011A68E0((uint64_t)cf, v2, (PersonalityInfo **)v4 + 3, (uint64_t)v10, (uint64_t)"CB");
  *(void *)&long long v17 = &v16;
  *((void *)&v17 + 1) = v14;
  sub_1011ABDA0((uint64_t)&v17, (uint64_t)cf);
  if (v13 < 0) {
    operator delete((void *)cf[1]);
  }
  sub_100127DDC(cf);
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
  cf[0] = 0;
  CFStringRef v5 = (const __CFString *)v1[1];
  *(void *)&long long v17 = v16;
  if (v16) {
    CFRetain(v16);
  }
  sub_1011A73D4((const __CFData **)cf, v2, (PersonalityInfo **)v4 + 3, v5, (SecKeyRef *)&v17);
  sub_100127DDC((const void **)&v17);
  v10[0] = (void *)cf[0];
  if (cf[0]) {
    CFRetain(cf[0]);
  }
  uint64_t v6 = v1[6];
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v6 + 48))(v6, v10);
  sub_100030068((const void **)v10);
  sub_100030068(cf);
  sub_10004D2C8((std::__shared_weak_count *)v4);
  sub_10004D2C8((std::__shared_weak_count *)v3);
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  sub_100127DDC(&v16);
  sub_1011AFE50((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1011AFDAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_100127DDC((const void **)(v30 - 72));
  sub_10004D2C8(v29);
  sub_10004D2C8(v28);
  if (a28 < 0) {
    operator delete(__p);
  }
  sub_100127DDC((const void **)(v30 - 80));
  sub_1011AFE50(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011AFE50(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1003399AC((void *)(v1 + 24));
    sub_1000558F4((const void **)(v1 + 16));
    sub_1000558F4((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_1011AFEB0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1011AFF20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_1011AFFC8((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011AFF44(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011AFF7C(uint64_t a1)
{
}

uint64_t sub_1011AFF84(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1011AFFC8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v2;
      operator delete(v2);
    }
    operator delete();
  }
}

void sub_1011B0024(uint64_t a1@<X0>, uint64_t a2@<X2>, dispatch_object_t *a3@<X3>, int a4@<W4>, uint64_t *a5@<X8>)
{
  switch(a4)
  {
    case 0:
      uint64_t v23 = *(void *)(a1 + 8);
      if (v23) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 1:
      uint64_t v24 = *(void *)(a1 + 8);
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 2:
      uint64_t v20 = *(void *)(a1 + 8);
      if (v20) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 3:
      uint64_t v21 = *(void *)(a1 + 8);
      if (v21) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 4:
      uint64_t v18 = *(void *)(a1 + 8);
      if (v18) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 5:
      uint64_t v27 = *(void *)(a1 + 8);
      if (v27) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 6:
      uint64_t v28 = *(void *)(a1 + 8);
      if (v28) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2648(buf);
    case 7:
      uint64_t v22 = *(void *)(a1 + 8);
      if (v22) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 8:
      uint64_t v31 = *(void *)(a1 + 8);
      if (v31) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 9:
      uint64_t v19 = *(void *)(a1 + 8);
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 10:
      uint64_t v30 = *(void *)(a1 + 8);
      if (v30) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 11:
      uint64_t v17 = *(void *)(a1 + 8);
      if (v17) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 12:
    case 13:
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 14:
      uint64_t v16 = *(void *)(a1 + 8);
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 15:
      uint64_t v29 = *(void *)(a1 + 8);
      if (v29) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2430(buf);
    case 16:
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 17:
    case 26:
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 18:
      uint64_t v14 = *(void *)(a1 + 8);
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 19:
      uint64_t v32 = *(void *)(a1 + 8);
      if (v32) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 20:
      uint64_t v33 = *(void *)(a1 + 8);
      if (v33) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v33 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 21:
      uint64_t v34 = *(void *)(a1 + 8);
      if (v34) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 22:
      uint64_t v37 = *(void *)(a1 + 8);
      if (v37) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 23:
      uint64_t v26 = *(void *)(a1 + 8);
      if (v26) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_1011B2648(buf);
    case 24:
      uint64_t v25 = *(void *)(a1 + 8);
      if (v25) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      sub_10052765C(buf);
    case 25:
      uint64_t v12 = *(void *)(a1 + 8);
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 27:
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      if (*a3) {
        dispatch_retain(*a3);
      }
      operator new();
    case 28:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 29:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 30:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 31:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 32:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 33:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 34:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
      goto LABEL_177;
    case 35:
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 8);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = *a3;
      if (*a3) {
        dispatch_retain(v11);
      }
LABEL_177:
      sub_10037FDCC(a2, buf);
      uint64_t v35 = *(void *)&buf[8];
      if (*(void *)buf) {
        uint64_t v36 = *(void *)buf + 64;
      }
      else {
        uint64_t v36 = 0;
      }
      *a5 = v36;
      a5[1] = v35;
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      if (v11) {
        dispatch_release(v11);
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
      return;
    case 36:
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "Wrong Connection type: Total";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataConnectionInterface.cpp";
        __int16 v39 = 1024;
        int v40 = 76;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT false\n %s\n at %s:%d\n**********", buf, 0x1Cu);
      }
      __TUAssertTrigger();
      goto LABEL_20;
    default:
LABEL_20:
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a4;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Wrong Connection type: %d", buf, 8u);
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "Wrong Connection type: Unknown";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/CoreTelephony/CSI/Modules/Data/Source/DataConnectionInterface.cpp";
        __int16 v39 = 1024;
        int v40 = 81;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "\n**********\n   ASSERT false\n %s\n at %s:%d\n**********", buf, 0x1Cu);
      }
      __TUAssertTrigger();
      *a5 = 0;
      a5[1] = 0;
      return;
  }
}

void sub_1011B1D20(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  if (v3) {
    dispatch_release(v3);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_1011B2430(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1011B25B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12)
{
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_1011B2648(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1011B27BC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011B286C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B28A4(uint64_t a1)
{
}

uint64_t sub_1011B28C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2904(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2934(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B296C(uint64_t a1)
{
}

uint64_t sub_1011B2988(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B29CC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B29FC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2A34(uint64_t a1)
{
}

uint64_t sub_1011B2A50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2A94(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2AC4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2AFC(uint64_t a1)
{
}

uint64_t sub_1011B2B18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2B5C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2B8C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2BC4(uint64_t a1)
{
}

uint64_t sub_1011B2BE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2C24(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2C54(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2C8C(uint64_t a1)
{
}

uint64_t sub_1011B2CA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2CEC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2D1C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2D54(uint64_t a1)
{
}

uint64_t sub_1011B2D70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2DB4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2DE4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2E1C(uint64_t a1)
{
}

uint64_t sub_1011B2E38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2E7C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2EAC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2EE4(uint64_t a1)
{
}

uint64_t sub_1011B2F00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B2F44(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B2F74(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B2FAC(uint64_t a1)
{
}

uint64_t sub_1011B2FC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B300C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B303C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B3074(uint64_t a1)
{
}

uint64_t sub_1011B3090(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B30D4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B3104(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B313C(uint64_t a1)
{
}

uint64_t sub_1011B3158(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B319C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B31CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B3204(uint64_t a1)
{
}

uint64_t sub_1011B3220(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B3264(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B3294(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B32CC(uint64_t a1)
{
}

uint64_t sub_1011B32E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B332C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B335C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B3394(uint64_t a1)
{
}

uint64_t sub_1011B33B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B33F4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B3424(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B345C(uint64_t a1)
{
}

uint64_t sub_1011B3478(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B34BC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B34EC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011B3524(uint64_t a1)
{
}

uint64_t sub_1011B3540(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011B3584(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011B35B0(uint64_t a1, uint64_t a2, char a3)
{
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    if (*(void *)(a1 + 136))
    {
      uint64_t v9 = _NSConcreteStackBlock;
      uint64_t v10 = 0x40000000;
      uint64_t v11 = sub_1011B37E8;
      uint64_t v12 = &unk_101A9A6C0;
      uint64_t v13 = a1;
      char v14 = a3;
      SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)a1);
      uint64_t v4 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800F7u);
      if (v4)
      {
        CFStringRef v5 = (wis::MetricContainer *)v4;
        uint64_t v6 = sub_10001C8F4(8);
        uint64_t v8 = *v6;
        uint64_t v7 = (std::__shared_weak_count *)v6[1];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8) {
          operator new();
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
        wis::MetricContainer::~MetricContainer(v5);
        operator delete();
      }
    }
  }
}

void sub_1011B3748(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011B37E8(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 32);
  CFStringRef v5 = *(void **)(v4 + 120);
  uint64_t v6 = (void *)(v4 + 128);
  if (v5 != (void *)(v4 + 128))
  {
    do
    {
      unint64_t v7 = *((char *)v5 + 32);
      if (v7 <= 0xA)
      {
        unsigned int v8 = dword_1015D269C[v7];
        uint64_t result = awd::metrics::CommCenterFileType_IsValid((awd::metrics *)v8, a2);
        if ((result & 1) == 0) {
          __assert_rtn("add_pushed_files", "CCMetricsCarrierBundle.pb.h", 3588, "::awd::metrics::CommCenterFileType_IsValid(value)");
        }
        int v9 = *(_DWORD *)(a2 + 72);
        if (v9 == *(_DWORD *)(a2 + 76))
        {
          uint64_t result = sub_1008A4E70(a2 + 64, v9 + 1);
          int v9 = *(_DWORD *)(a2 + 72);
        }
        uint64_t v10 = *(void *)(a2 + 64);
        *(_DWORD *)(a2 + 72) = v9 + 1;
        *(_DWORD *)(v10 + 4 * v9) = v8;
      }
      uint64_t v11 = (void *)v5[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v5[2];
          BOOL v13 = *v12 == (void)v5;
          CFStringRef v5 = v12;
        }
        while (!v13);
      }
      CFStringRef v5 = v12;
    }
    while (v12 != v6);
  }
  char v14 = (awd::metrics *)*(unsigned __int8 *)(v3 + 40);
  if (v14 < 3)
  {
    uint64_t result = awd::metrics::CommCenterFilePushReason_IsValid(v14, a2);
    if ((result & 1) == 0) {
      __assert_rtn("set_push_reason", "CCMetricsCarrierBundle.pb.h", 3618, "::awd::metrics::CommCenterFilePushReason_IsValid(value)");
    }
    *(_DWORD *)(a2 + 88) |= 0x10u;
    *(_DWORD *)(a2 + 80) = v14;
  }
  return result;
}

void sub_1011B392C()
{
}

void sub_1011B39A0(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_101020664();
}

void sub_1011B3A18(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011B3A30(QMICDMASettingsFactoryInterface *this)
{
  *(void *)this = off_101A9A6F0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  QMICDMASettingsFactoryInterface::~QMICDMASettingsFactoryInterface(this);
}

void sub_1011B3A8C(QMICDMASettingsFactoryInterface *this)
{
  *(void *)this = off_101A9A6F0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  QMICDMASettingsFactoryInterface::~QMICDMASettingsFactoryInterface(this);

  operator delete();
}

void _StartCSINotificationThread()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  InternetAssertion::create();
}

void sub_1011B3E1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,uint64_t a32)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }
  if (a30) {
    sub_10004D2C8(a30);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v32 - 168);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint64_t v35 = *(std::__shared_weak_count **)(v32 - 136);
  if (v35) {
    sub_10004D2C8(v35);
  }
  uint64_t v36 = *(std::__shared_weak_count **)(v32 - 104);
  if (v36) {
    sub_10004D2C8(v36);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011B3F4C()
{
}

void sub_1011B4704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_10004D2C8(v29);
  sub_100160AF8(v30);
  sub_100215144((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t _StopCSINotificationThread(void)
{
  if (qword_101B14180)
  {
    sub_10021848C(qword_101B14180);
    while (qword_101B14180)
      pthread_cond_wait(&stru_101B0B990, &stru_101B0B950);
  }
  pthread_mutex_unlock(&stru_101B0B950);
  return 1;
}

void sub_1011B496C(int a1, int **a2)
{
  if (!a1) {
    return;
  }
  long long v89 = 0u;
  long long v88 = 0u;
  long long v87 = 0u;
  long long v86 = 0u;
  long long v85 = 0u;
  long long v84 = 0u;
  long long v83 = 0u;
  long long v82 = 0u;
  uint64_t v3 = *a2;
  if ((unint64_t)(a2[1] - *a2) >= 0x10) {
    uint64_t v4 = 16;
  }
  else {
    uint64_t v4 = a2[1] - *a2;
  }
  if (v4)
  {
    uint64_t v5 = 4 * v4;
    uint64_t v6 = &v82;
    do
    {
      uint64_t v7 = *v3++;
      *(void *)uint64_t v6 = v7;
      uint64_t v6 = (long long *)((char *)v6 + 8);
      v5 -= 4;
    }
    while (v5);
  }
  memset(__dst, 0, sizeof(__dst));
  memset(v80, 0, sizeof(v80));
  bzero(v79, 0x400uLL);
  if (a1 > 146)
  {
    if (a1 > 168)
    {
      if (a1 == 169)
      {
        *(void *)&buf.var0 = 0;
        buf.var2.__r_.__value_.var0.var1.__data_ = 0;
        sub_1003BEF68(v8, &buf);
        uint64_t v37 = *(void *)&buf.var0;
        if (*(void *)&buf.var0)
        {
          uint64_t v38 = (*(uint64_t (**)(void))(**(void **)&buf.var0 + 776))(*(void *)&buf.var0);
          sub_100058DB0(__p, "Data provisioning context deactivate");
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, void, void))(*(void *)v37 + 80))(v37, v38, 64, 0, __p, 0, 0);
          if (v66 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 776))(v37);
          sub_100058DB0(v63, "Data provisioning secondary context deactivate");
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, void, void))(*(void *)v37 + 80))(v37, v39, 0x800000, 0, v63, 0, 0);
          if (v64 < 0) {
            operator delete(v63[0]);
          }
        }
        int data = (std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_;
        if (buf.var2.__r_.__value_.var0.var1.__data_) {
          goto LABEL_140;
        }
        return;
      }
      if (a1 == 183)
      {
        uint64_t v22 = 123;
LABEL_118:
        sub_1011B55D4((Registry *)v22, v4, (int64_t *)&v82, __dst, v80, v79);
        return;
      }
      if (a1 != 202 || !v4) {
        return;
      }
      --v4;
      uint64_t v22 = *((void *)&v82 + v4);
    }
    else
    {
      if (a1 != 147)
      {
        if (a1 == 150)
        {
          ++v4;
          uint64_t v20 = 3;
        }
        else
        {
          if (a1 != 151) {
            return;
          }
          ++v4;
          uint64_t v20 = 2;
        }
        *((void *)&v82 + 1) = v20;
        uint64_t v22 = 99;
        goto LABEL_118;
      }
      *(void *)&buf.var0 = 0;
      buf.var2.__r_.__value_.var0.var1.__data_ = 0;
      sub_1003BEF68(v8, &buf);
      if (*(void *)&buf.var0)
      {
        uint64_t v4 = (*(uint64_t (**)(void, void, long long *))(**(void **)&buf.var0 + 320))(*(void *)&buf.var0, 0, &v82);
        uint64_t v22 = 44;
      }
      else
      {
        uint64_t v22 = 0;
      }
      if (buf.var2.__r_.__value_.var0.var1.__data_) {
        sub_10004D2C8((std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_);
      }
    }
    if (!v22) {
      return;
    }
    goto LABEL_118;
  }
  if (a1 > 70)
  {
    if ((a1 - 71) >= 3) {
      return;
    }
    *(void *)&long long v82 = 11;
    if (a1 == 72) {
      unsigned int v21 = 55;
    }
    else {
      unsigned int v21 = 56;
    }
    if (a1 == 71) {
      uint64_t v22 = 54;
    }
    else {
      uint64_t v22 = v21;
    }
    pthread_mutex_lock(&stru_101B0AC18);
    char v23 = dword_101B13E54;
    pthread_mutex_unlock(&stru_101B0AC18);
    if ((v23 & 4) != 0)
    {
      pthread_mutex_lock(&stru_101B0AC18);
      dword_101B13E54 &= ~4u;
      pthread_mutex_unlock(&stru_101B0AC18);
      sub_1011B55D4((Registry *)v22, 1, (int64_t *)&v82, __dst, v80, v79);
      uint64_t v4 = 0;
      uint64_t v22 = 13;
    }
    else
    {
      uint64_t v4 = 1;
    }
    goto LABEL_118;
  }
  if (a1 != 9)
  {
    if (a1 != 69)
    {
      if (a1 != 70) {
        return;
      }
      *(void *)&long long v82 = 11;
      uint64_t v78 = 0;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v73 = 0u;
      memset(&buf, 0, sizeof(buf));
      CSIPhoneNumber::CSIPhoneNumber(&buf);
      Registry::get((uint64_t *)&v67, v9);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v67);
      uint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        BOOL v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      long long v70 = (const void *)v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v70);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_83;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
LABEL_83:
      int v54 = (*(uint64_t (**)(uint64_t, CSIPhoneNumber *, uint64_t))(*(void *)v18 + 288))(v18, &buf, 2);
      if ((v19 & 1) == 0) {
        sub_10004D2C8(v17);
      }
      if (v68) {
        sub_10004D2C8(v68);
      }
      if (v54)
      {
        CSIPhoneNumber::getFullNumber((uint64_t *)&v67, &buf);
        uint32_t v55 = v69 >= 0 ? (const char *)&v67 : (const char *)v67;
        strlcpy((char *)__dst, v55, 0x100uLL);
        if (v69 < 0) {
          operator delete(v67);
        }
      }
      pthread_mutex_lock(&stru_101B0AC18);
      char v56 = dword_101B13E54;
      pthread_mutex_unlock(&stru_101B0AC18);
      if ((v56 & 4) != 0)
      {
LABEL_109:
        pthread_mutex_lock(&stru_101B0AC18);
        dword_101B13E54 &= ~4u;
        pthread_mutex_unlock(&stru_101B0AC18);
        sub_1011B55D4((Registry *)0x35, 1, (int64_t *)&v82, __dst, v80, v79);
        uint64_t v4 = 0;
        uint64_t v22 = 13;
        goto LABEL_110;
      }
LABEL_108:
      uint64_t v22 = 53;
      uint64_t v4 = 1;
LABEL_110:
      if (SHIBYTE(v76) < 0) {
        operator delete(*((void **)&v75 + 1));
      }
      if (SBYTE7(v75) < 0) {
        operator delete((void *)v74);
      }
      if (SBYTE7(v73) < 0) {
        operator delete(*(void **)&buf.var2.__r_.var0);
      }
      if (*((char *)&buf.var2.__r_.__value_.var0.var1 + 23) < 0) {
        operator delete(buf.var2.__r_.__value_.var0.var1.__data_);
      }
      goto LABEL_118;
    }
    *(void *)&long long v82 = 11;
    uint64_t v78 = 0;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v73 = 0u;
    memset(&buf, 0, sizeof(buf));
    CSIPhoneNumber::CSIPhoneNumber(&buf);
    Registry::get((uint64_t *)&v67, v26);
    uint64_t v27 = (std::mutex *)Registry::getServiceMap(v67);
    uint64_t v28 = v27;
    if (v29 < 0)
    {
      uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v31 = 5381;
      do
      {
        uint64_t v29 = v31;
        unsigned int v32 = *v30++;
        uint64_t v31 = (33 * v31) ^ v32;
      }
      while (v32);
    }
    std::mutex::lock(v27);
    long long v70 = (const void *)v29;
    uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)&v70);
    if (v33)
    {
      uint64_t v35 = v33[3];
      uint64_t v34 = (std::__shared_weak_count *)v33[4];
      if (v34)
      {
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v28);
        atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        char v36 = 0;
        goto LABEL_97;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v28);
    uint64_t v34 = 0;
    char v36 = 1;
LABEL_97:
    int v57 = (*(uint64_t (**)(uint64_t, CSIPhoneNumber *, uint64_t))(*(void *)v35 + 288))(v35, &buf, 1);
    if ((v36 & 1) == 0) {
      sub_10004D2C8(v34);
    }
    if (v68) {
      sub_10004D2C8(v68);
    }
    if (v57)
    {
      CSIPhoneNumber::getFullNumber((uint64_t *)&v67, &buf);
      CFNumberRef v58 = v69 >= 0 ? (const char *)&v67 : (const char *)v67;
      strlcpy((char *)__dst, v58, 0x100uLL);
      if (v69 < 0) {
        operator delete(v67);
      }
    }
    pthread_mutex_lock(&stru_101B0AC18);
    char v59 = dword_101B13E54;
    pthread_mutex_unlock(&stru_101B0AC18);
    if ((v59 & 4) != 0) {
      goto LABEL_109;
    }
    goto LABEL_108;
  }
  uint64_t v67 = 0;
  char v68 = 0;
  Registry::get((uint64_t *)&v67, v8);
  uint64_t v24 = (const void **)v82;
  if ((void)v82 == -1)
  {
    BOOL v25 = 0;
  }
  else
  {
    long long v70 = 0;
    covertIntegersToUuid((uint64_t *)&v70, v82, DWORD2(v82), v83, DWORD2(v83));
    sub_100224000(v67, &buf);
    BOOL v25 = CallController::hasCallWithUuid(*(uint64_t *)&buf.var0, (uint64_t)&v70);
    if (buf.var2.__r_.__value_.var0.var1.__data_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_);
    }
    uint64_t v24 = sub_10012577C(&v70);
  }
  long long v70 = 0;
  uint64_t v71 = 0;
  sub_1003BEF68((Registry *)v24, &v70);
  if (!v25)
  {
    long long v52 = v70;
    if (!v70) {
      goto LABEL_137;
    }
    uint64_t v53 = 34;
    goto LABEL_136;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B132F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_101B132F0))
  {
    __cxa_atexit((void (*)(void *))sub_10072B500, &xmmword_101B13300, (void *)&_mh_execute_header);
    __cxa_guard_release(qword_101B132F0);
  }
  sub_100224000(v67, &buf);
  char v41 = CallController::activeOrHeldCalls(*(CallController **)&buf.var0);
  if (buf.var2.__r_.__value_.var0.var1.__data_) {
    sub_10004D2C8((std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_);
  }
  if ((v41 & 1) == 0)
  {
    if ((void)xmmword_101B13300)
    {
      uint64_t v60 = (std::__shared_weak_count *)*((void *)&xmmword_101B13300 + 1);
      xmmword_101B13300 = 0uLL;
      if (v60) {
        sub_10004D2C8(v60);
      }
    }
    goto LABEL_134;
  }
  if (!(void)xmmword_101B13300)
  {
    BOOL v42 = (std::mutex *)Registry::getServiceMap(v67);
    uint64_t v43 = v42;
    if (v44 < 0)
    {
      unsigned int v45 = (unsigned __int8 *)(v44 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v46 = 5381;
      do
      {
        uint64_t v44 = v46;
        unsigned int v47 = *v45++;
        uint64_t v46 = (33 * v46) ^ v47;
      }
      while (v47);
    }
    std::mutex::lock(v42);
    *(void *)&buf.var0 = v44;
    int v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)&buf);
    if (v48)
    {
      uint64_t v50 = v48[3];
      uint64_t v49 = (std::__shared_weak_count *)v48[4];
      if (v49)
      {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v43);
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v49);
        char v51 = 0;
        goto LABEL_125;
      }
    }
    else
    {
      uint64_t v50 = 0;
    }
    std::mutex::unlock(v43);
    uint64_t v49 = 0;
    char v51 = 1;
LABEL_125:
    if (v50)
    {
      (*(void (**)(CSIPhoneNumber *__return_ptr, uint64_t, const char *, void))(*(void *)v50 + 8))(&buf, v50, "com.apple.commcenter", 0);
      long long v61 = *(_OWORD *)&buf.var0;
      *(void *)&buf.var0 = 0;
      buf.var2.__r_.__value_.var0.var1.__data_ = 0;
      uint64_t v62 = (std::__shared_weak_count *)*((void *)&xmmword_101B13300 + 1);
      xmmword_101B13300 = v61;
      if (v62)
      {
        sub_10004D2C8(v62);
        if (buf.var2.__r_.__value_.var0.var1.__data_) {
          sub_10004D2C8((std::__shared_weak_count *)buf.var2.__r_.__value_.var0.var1.__data_);
        }
      }
    }
    if ((v51 & 1) == 0) {
      sub_10004D2C8(v49);
    }
    if (!(void)xmmword_101B13300 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      buf.var0 = 136315138;
      *(void *)&buf.var1 = "com.apple.commcenter";
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "Could not create power assertion: %s", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_134:
  long long v52 = v70;
  if (!v70) {
    goto LABEL_137;
  }
  uint64_t v53 = 35;
LABEL_136:
  (*(void (**)(const void *, uint64_t, uint64_t, void))(*(void *)v52 + 160))(v52, 3, v53, 0);
LABEL_137:
  if (v71) {
    sub_10004D2C8(v71);
  }
  int data = v68;
  if (v68) {
LABEL_140:
  }
    sub_10004D2C8(data);
}

void sub_1011B5498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,std::__shared_weak_count *a23,int a24,__int16 a25,char a26,char a27,char a28,std::__shared_weak_count *a29,char a30,uint64_t a31)
{
  char v33 = v31;
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  if (a29) {
    sub_10004D2C8(a29);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011B55D4(Registry *a1, uint64_t a2, int64_t *a3, unsigned char *a4, unsigned char *a5, unsigned char *a6)
{
  char v23 = 0;
  uint64_t v24 = 0;
  Registry::get((uint64_t *)&v23, a1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v23);
  BOOL v13 = ServiceMap;
  if ((v14 & 0x8000000000000000) != 0)
  {
    unsigned int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      unint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v25 = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, &v25);
  if (!v18)
  {
    uint64_t v20 = 0;
LABEL_9:
    std::mutex::unlock(v13);
    char v19 = 0;
    char v21 = 1;
    if (!v20) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v20 = v18[3];
  char v19 = (std::__shared_weak_count *)v18[4];
  if (!v19) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  char v21 = 0;
  if (v20)
  {
LABEL_10:
    BYTE2(v22) = 0;
    LOWORD(v22) = 0;
    (*(void (**)(uint64_t, Registry *, uint64_t, int64_t *, void, void, unsigned char *, unsigned char *, unsigned char *, int))(*(void *)v20 + 32))(v20, a1, a2, a3, 0, 0, a4, a5, a6, v22);
  }
LABEL_11:
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
  sub_100DD66C4((int)a1, a2, a3, 0, 0, a4, a5, a6, 0, 0, 0);
  if (v24) {
    sub_10004D2C8(v24);
  }
}

void sub_1011B5774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011B57A8(uint64_t a1)
{
  sub_1011B5D90((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_1011B57EC(uint64_t a1)
{
  sub_1011B5B38(a1);

  operator delete();
}

BOOL sub_1011B5824(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_100A01930((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_100A01930((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_1011B595C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011B59A0(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_1011B59CC(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_1011B59F8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

uint64_t sub_1011B5A54(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_1011B5D90((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_1011B5AB4()
{
}

uint64_t sub_1011B5AC8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1011B5D90((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_1011B5B20()
{
  return 0;
}

uint64_t sub_1011B5B28()
{
  return 0;
}

uint64_t sub_1011B5B30()
{
  return 0;
}

uint64_t sub_1011B5B38(uint64_t a1)
{
  *(void *)a1 = off_101A9A750;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1011B5BAC()
{
}

uint64_t sub_1011B5BC0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1011B5BF0()
{
  return 0;
}

uint64_t sub_1011B5BF8()
{
  return 0;
}

uint64_t sub_1011B5C00()
{
  return 0;
}

uint64_t sub_1011B5C08(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf1Iv18EventSenderAdapterRKN5event8CSIEventEEENS0_5"
                                        "list2INS0_5valueIPS4_EENS_3argILi1EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost3_bi6bind_tIvNS_4_mfi3mf1Iv18EventSenderAdapterRKN5event8CSIEventEEENS0_5list2INS0_5valueIPS4_EENS_3argILi1EEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_1011B5CA8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  uint64_t v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_1011B5CD0(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_1011B5D6C(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_1011B5D7C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1011B5D90(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_1011B5DE4()
{
  if ((byte_101B09D70 & 1) == 0)
  {
    byte_101B09D70 = 1;
    return __cxa_atexit((void (*)(void *))sub_100160564, &stru_101B09D20, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_1011B5E20(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint64_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v12 = "DATA.Connection.Internet.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    uint64_t v12 = "DATA.Connection.Internet.2";
  }
  unint64_t v14 = "Internet.X";
  if (v13 == 2) {
    unint64_t v14 = "Internet.2";
  }
  if (v13 == 1) {
    unsigned int v15 = "DATA.Connection.Internet.1";
  }
  else {
    unsigned int v15 = v12;
  }
  if (v13 == 1) {
    uint64_t v16 = "Internet.1";
  }
  else {
    uint64_t v16 = v14;
  }
  sub_10129653C(a1, (uint64_t *)&off_101A9B2E8, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *(void *)a1 = off_101A9A8B0;
  *(void *)(a1 + 64) = off_101A9AE00;
  *(void *)(a1 + 72) = off_101A9B090;
  *(void *)(a1 + 80) = off_101A9B280;
  *(_DWORD *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = "";
  *(void *)(a1 + 408) = "";
  *(_DWORD *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 420) = 0;
  *(_DWORD *)(a1 + 424) = 2;
  *(void *)(a1 + 456) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 436) = 0;
  *(void *)(a1 + 428) = 0;
  *(void *)(a1 + 441) = 0;
  return a1;
}

void sub_1011B5FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1011B6014(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, NSObject **a6, int a7, const char *a8, uint64_t a9)
{
  unsigned int v15 = (std::__shared_weak_count *)a3[1];
  uint64_t v20 = *a3;
  char v21 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v16 = *a6;
  dispatch_object_t object = v16;
  if (v16) {
    dispatch_retain(v16);
  }
  sub_10129653C(a1, a2 + 1, &v20, a4, a5, &object, a8, a9, a7);
  if (object) {
    dispatch_release(object);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v17 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v17 - 56)) = a2[11];
  *(void *)(a1 + 64) = a2[12];
  *(void *)(a1 + 72) = off_101A9B090;
  *(void *)(a1 + 80) = a2[13];
  *(_DWORD *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = "";
  *(void *)(a1 + 408) = "";
  *(_DWORD *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 420) = 0;
  *(_DWORD *)(a1 + 424) = 2;
  *(void *)(a1 + 456) = 0;
  *(unsigned char *)(a1 + 464) = 0;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 436) = 0;
  *(void *)(a1 + 428) = 0;
  *(void *)(a1 + 441) = 0;
  return a1;
}

void sub_1011B6220(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011B6244(uint64_t a1)
{
}

void sub_1011B62C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  block[6] = _NSConcreteStackBlock;
  block[7] = 0x40000000;
  block[8] = sub_1011B66CC;
  block[9] = &unk_101A9B370;
  block[10] = v1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1011B7784;
  block[3] = &unk_101A9B390;
  block[4] = v1;
  block[5] = network_config_cellular_failed_observer_create();
  dispatch_async(v2, block);
}

void sub_1011B639C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a1 = *a2;
  *(uint64_t *)((char *)a1 + *(void *)(v4 - 56)) = a2[11];
  a1[8] = a2[12];
  a1[9] = (uint64_t)off_101A9B090;
  a1[10] = a2[13];
  sub_1011B6528((uint64_t)a1);
  uint64_t v5 = a1[59];
  a1[59] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[55];
  if (v6) {
    sub_10004D2C8(v6);
  }

  sub_101296BD8((uint64_t)a1, a2 + 1);
}

void sub_1011B6528(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 456);
  if (v1)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_1011B7870;
    block[3] = &unk_101A9B3B0;
    block[4] = v1;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  }
}

void sub_1011B65A4(uint64_t *a1)
{
  sub_1011B639C(a1, (uint64_t *)off_101A9B2E0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1011B65D4(uint64_t a1)
{
  sub_1011B639C((uint64_t *)(a1 - 64), (uint64_t *)off_101A9B2E0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1011B6608(uint64_t a1)
{
  sub_1011B639C((uint64_t *)(a1 - 72), (uint64_t *)off_101A9B2E0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1011B663C(uint64_t a1)
{
  sub_1011B639C((uint64_t *)(a1 - 80), (uint64_t *)off_101A9B2E0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1011B6670(uint64_t *a1)
{
  sub_1011B639C(a1, (uint64_t *)off_101A9B2E0);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_1011B66B4(uint64_t a1)
{
}

void sub_1011B66BC(uint64_t a1)
{
}

void sub_1011B66C4(uint64_t a1)
{
}

void sub_1011B66CC(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v4 + 227))
  {
    if (*(void *)(v4 + 216))
    {
      int v7 = PersonalitySpecificImpl::simSlot(*(PersonalitySpecificImpl **)(a1 + 32));
      if (v7 == (*(unsigned int (**)(void))(**(void **)(v4 + 216) + 288))(*(void *)(v4 + 216)))
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v79 = 0;
        if (a2)
        {
          if (xpc_get_type(a2) == (xpc_type_t)&_xpc_type_uint64)
          {
            LODWORD(a2) = xpc_uint64_get_value(a2);
            if (!a4) {
              goto LABEL_15;
            }
            goto LABEL_9;
          }
          LODWORD(a2) = 0;
        }
        if (!a4) {
          goto LABEL_15;
        }
LABEL_9:
        if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
        {
          string_ptr = (char *)xpc_string_get_string_ptr(a4);
          if (string_ptr)
          {
            sub_100058DB0(buf, string_ptr);
            if (SHIBYTE(v79) < 0) {
              operator delete(__p[0]);
            }
            *(_OWORD *)std::string __p = *(_OWORD *)buf;
            uint64_t v79 = *(void *)&buf[16];
          }
        }
LABEL_15:
        int v9 = (void *)HIBYTE(v79);
        if (v79 < 0) {
          int v9 = __p[1];
        }
        if (!v9 && (int)a2 >= 1)
        {
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(v4 + 216) + 496))(buf);
          if (SHIBYTE(v79) < 0) {
            operator delete(__p[0]);
          }
          *(_OWORD *)std::string __p = *(_OWORD *)buf;
          uint64_t v79 = *(void *)&buf[16];
        }
        uint64_t v10 = *(NSObject **)(v4 + 56);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = __p;
          if (v79 < 0) {
            uint64_t v11 = (void **)__p[0];
          }
          *(_DWORD *)CSIPhoneNumber buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = a2;
          *(_WORD *)&uint8_t buf[8] = 2080;
          *(void *)&buf[10] = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I network_config_cellular_failed_observer: pid=%d, bundle=%s", buf, 0x12u);
        }
        if (((*(uint64_t (**)(void, void **))(**(void **)(v4 + 216) + 224))(*(void *)(v4 + 216), __p) & 1) == 0)
        {
          uint64_t v18 = *(NSObject **)(v4 + 56);
          if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_184;
          }
          uint64_t v19 = __p;
          if (v79 < 0) {
            uint64_t v19 = (void **)__p[0];
          }
          *(_DWORD *)CSIPhoneNumber buf = 136315138;
          *(void *)&uint8_t buf[4] = v19;
          unsigned int v15 = "#I network_config_cellular_failed_observer: %s is not a screen app, ignoring";
          uint64_t v16 = v18;
          uint32_t v17 = 12;
LABEL_34:
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
LABEL_184:
          if (SHIBYTE(v79) < 0) {
            operator delete(__p[0]);
          }
          return;
        }
        uint64_t v12 = *(void *)(v4 + 216);
        uint64_t v13 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)v4);
        if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v12 + 216))(v12, v13))
        {
          unint64_t v14 = *(NSObject **)(v4 + 56);
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_184;
          }
          *(_WORD *)CSIPhoneNumber buf = 0;
          unsigned int v15 = "#I network_config_cellular_failed_observer: baseband is refreshing, ignoring";
          uint64_t v16 = v14;
          uint32_t v17 = 2;
          goto LABEL_34;
        }
        long long v77 = 0;
        *(_OWORD *)long long v75 = 0u;
        long long v76 = 0u;
        long long v74 = 0u;
        sub_10129793C((PersonalitySpecificImpl *)v4, 0, (uint64_t)&v74);
        BOOL v20 = v75[12];
        char v21 = *(NSObject **)(v4 + 56);
        BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
        if (v20)
        {
          if (!v22) {
            goto LABEL_58;
          }
          if (v74) {
            char v23 = "f";
          }
          else {
            char v23 = "t";
          }
          if (v74) {
            uint64_t v24 = (const char *)asString();
          }
          else {
            uint64_t v24 = "OK";
          }
          uint64_t v28 = (const char *)*((void *)&v74 + 1);
          uint64_t v27 = *(void *)v75;
          uint64_t v29 = asStringBool(v75[8]);
          uint64_t v30 = asStringBool(v75[9]);
          uint64_t v31 = asStringBool(v75[10]);
          uint64_t v32 = asStringBool(v75[11]);
          *(_DWORD *)CSIPhoneNumber buf = 136317442;
          *(void *)&uint8_t buf[4] = "connectionFailureAlertHandler";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "network_config_cellular_failed_observer canactivate";
          *(_WORD *)&unsigned char buf[22] = 2080;
          __int16 v100 = v23;
          __int16 v101 = 2080;
          __int16 v102 = v24;
          __int16 v103 = 2080;
          __int16 v104 = v28;
          __int16 v105 = 2080;
          uint64_t v106 = v27;
          __int16 v107 = 2080;
          uint64_t v108 = v29;
          __int16 v109 = 2080;
          uint64_t v110 = v30;
          __int16 v111 = 2080;
          uint64_t v112 = v31;
          __int16 v113 = 2080;
          uint64_t v114 = v32;
          char v33 = "#I %s: %s: %s(%s{%s %s [ allowed=%s blocked=%s netAvailable=%s home=%s ]})";
          uint64_t v34 = v21;
          uint32_t v35 = 102;
          goto LABEL_57;
        }
        if (!v22) {
          goto LABEL_58;
        }
        if (v74) {
          unint64_t v25 = "f";
        }
        else {
          unint64_t v25 = "t";
        }
        if (v74) {
          uint64_t v26 = (const char *)asString();
        }
        else {
          uint64_t v26 = "OK";
        }
        if (*((void *)&v74 + 1))
        {
          uint64_t v36 = *(void *)v75;
          if (**((unsigned char **)&v74 + 1))
          {
            uint64_t v37 = "}";
            uint64_t v38 = "{";
LABEL_56:
            *(_DWORD *)CSIPhoneNumber buf = 136316930;
            *(void *)&uint8_t buf[4] = "connectionFailureAlertHandler";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "network_config_cellular_failed_observer canactivate";
            *(_WORD *)&unsigned char buf[22] = 2080;
            __int16 v100 = v25;
            __int16 v101 = 2080;
            __int16 v102 = v26;
            __int16 v103 = 2080;
            __int16 v104 = v38;
            __int16 v105 = 2080;
            uint64_t v106 = *((void *)&v74 + 1);
            __int16 v107 = 2080;
            uint64_t v108 = v36;
            __int16 v109 = 2080;
            uint64_t v110 = (uint64_t)v37;
            char v33 = "#I %s: %s: %s(%s%s%s %s%s)";
            uint64_t v34 = v21;
            uint32_t v35 = 82;
LABEL_57:
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, buf, v35);
LABEL_58:
            if (qword_101B14190)
            {
              uint64_t v39 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
              if (v39) {
                uint64_t v40 = DataPlanManagerBootstrap::sInstance;
              }
              else {
                uint64_t v40 = 0;
              }
            }
            else
            {
              uint64_t v40 = 0;
              uint64_t v39 = 0;
            }
            if (v40) {
              uint64_t v41 = v40 + 8;
            }
            else {
              uint64_t v41 = 0;
            }
            int v42 = (*(uint64_t (**)(void))(**(void **)(v4 + 216) + 88))(*(void *)(v4 + 216));
            if (v74 == 0 || v74 >= 0xFFFFFFF7)
            {
              int v43 = 1 << (v74 + 9);
              if ((v43 & 0x205) != 0) {
                goto LABEL_180;
              }
              if ((v43 & 0x50) != 0)
              {
                if (v40) {
                  int v44 = v42;
                }
                else {
                  int v44 = 0;
                }
                if (v44 == 1) {
                  (*(void (**)(uint64_t))(*(void *)v41 + 112))(v41);
                }
                goto LABEL_180;
              }
            }
            if (v74 != 105)
            {
              int v45 = v40 ? v42 : 0;
              if (v45 != 1 || ((*(uint64_t (**)(uint64_t))(*(void *)v41 + 112))(v41) & 1) == 0)
              {
                (*(void (**)(void, void **))(**(void **)(v4 + 216) + 504))(*(void *)(v4 + 216), __p);
                int64_t v46 = (int)v74;
                xpc_object_t v98 = 0;
                xpc_object_t v47 = xpc_dictionary_create(0, 0, 0);
                xpc_object_t v48 = v47;
                if (v47)
                {
                  xpc_object_t v98 = v47;
                }
                else
                {
                  xpc_object_t v48 = xpc_null_create();
                  xpc_object_t v98 = v48;
                  if (!v48)
                  {
                    xpc_object_t v49 = xpc_null_create();
                    xpc_object_t v48 = 0;
                    goto LABEL_87;
                  }
                }
                if (xpc_get_type(v48) == (xpc_type_t)&_xpc_type_dictionary)
                {
                  xpc_retain(v48);
                  goto LABEL_88;
                }
                xpc_object_t v49 = xpc_null_create();
LABEL_87:
                xpc_object_t v98 = v49;
LABEL_88:
                xpc_release(v48);
                int v50 = sub_101299E6C(v4);
                xpc_object_t v96 = xpc_int64_create(v50);
                if (!v96) {
                  xpc_object_t v96 = xpc_null_create();
                }
                memset(buf, 0, sizeof(buf));
                ctu::cf::assign();
                *(_OWORD *)uint64_t v94 = *(_OWORD *)buf;
                uint64_t v95 = *(void *)&buf[16];
                char v51 = *(void ***)buf;
                if ((buf[23] & 0x80u) == 0) {
                  char v51 = v94;
                }
                v86[0] = &v98;
                v86[1] = v51;
                sub_100035E70((uint64_t)v86, &v96, &v97);
                xpc_release(v97);
                xpc_object_t v97 = 0;
                if (SHIBYTE(v95) < 0) {
                  operator delete(v94[0]);
                }
                xpc_release(v96);
                xpc_object_t v96 = 0;
                xpc_object_t v92 = xpc_int64_create(v46);
                if (!v92) {
                  xpc_object_t v92 = xpc_null_create();
                }
                memset(buf, 0, sizeof(buf));
                ctu::cf::assign();
                *(_OWORD *)uint64_t v94 = *(_OWORD *)buf;
                uint64_t v95 = *(void *)&buf[16];
                long long v52 = *(void ***)buf;
                if ((buf[23] & 0x80u) == 0) {
                  long long v52 = v94;
                }
                v86[0] = &v98;
                v86[1] = v52;
                sub_100035E70((uint64_t)v86, &v92, &object);
                xpc_release(object);
                xpc_object_t object = 0;
                if (SHIBYTE(v95) < 0) {
                  operator delete(v94[0]);
                }
                xpc_release(v92);
                xpc_object_t v92 = 0;
                if (v46 >= 0x43) {
                  uint64_t v53 = (CFTypeRef *)&kCTReturnUnknownError;
                }
                else {
                  uint64_t v53 = (CFTypeRef *)&off_1019E71D0[v46];
                }
                if (!CFEqual(*v53, kCTReturnUnknownError))
                {
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  *(_OWORD *)uint64_t v94 = *(_OWORD *)buf;
                  uint64_t v95 = *(void *)&buf[16];
                  if ((buf[23] & 0x80u) == 0) {
                    int v54 = v94;
                  }
                  else {
                    int v54 = (void **)v94[0];
                  }
                  xpc_object_t v90 = xpc_string_create((const char *)v54);
                  if (!v90) {
                    xpc_object_t v90 = xpc_null_create();
                  }
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  *(_OWORD *)long long v86 = *(_OWORD *)buf;
                  uint64_t v87 = *(void *)&buf[16];
                  uint32_t v55 = *(xpc_object_t **)buf;
                  if ((buf[23] & 0x80u) == 0) {
                    uint32_t v55 = v86;
                  }
                  xpc_object_t v88 = &v98;
                  long long v89 = v55;
                  sub_100035E70((uint64_t)&v88, &v90, &v91);
                  xpc_release(v91);
                  xpc_object_t v91 = 0;
                  if (SHIBYTE(v87) < 0) {
                    operator delete(v86[0]);
                  }
                  xpc_release(v90);
                  xpc_object_t v90 = 0;
                  if (SHIBYTE(v95) < 0) {
                    operator delete(v94[0]);
                  }
                }
                v94[0] = 0;
                v94[1] = 0;
                uint64_t v95 = 0;
                memset(buf, 0, sizeof(buf));
                ctu::cf::assign();
                *(_OWORD *)uint64_t v94 = *(_OWORD *)buf;
                uint64_t v95 = *(void *)&buf[16];
                if (v46 == -4)
                {
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  *(_OWORD *)long long v86 = *(_OWORD *)buf;
                  uint64_t v87 = *(void *)&buf[16];
                  if ((buf[23] & 0x80u) == 0) {
                    char v59 = v86;
                  }
                  else {
                    char v59 = (xpc_object_t *)v86[0];
                  }
                  xpc_object_t v84 = xpc_string_create((const char *)v59);
                  if (!v84) {
                    xpc_object_t v84 = xpc_null_create();
                  }
                  uint64_t v60 = v94;
                  if (v95 < 0) {
                    uint64_t v60 = (void **)v94[0];
                  }
                  *(void *)CSIPhoneNumber buf = &v98;
                  *(void *)&uint8_t buf[8] = v60;
                  sub_100035E70((uint64_t)buf, &v84, &v85);
                  xpc_release(v85);
                  xpc_object_t v85 = 0;
                  xpc_release(v84);
                  xpc_object_t v84 = 0;
                  if (SHIBYTE(v87) < 0) {
                    operator delete(v86[0]);
                  }
                  xpc_object_t v82 = xpc_BOOL_create(1);
                  if (!v82) {
                    xpc_object_t v82 = xpc_null_create();
                  }
                  memset(buf, 0, sizeof(buf));
                  ctu::cf::assign();
                  *(_OWORD *)long long v86 = *(_OWORD *)buf;
                  uint64_t v87 = *(void *)&buf[16];
                  long long v61 = *(xpc_object_t **)buf;
                  if ((buf[23] & 0x80u) == 0) {
                    long long v61 = v86;
                  }
                  xpc_object_t v88 = &v98;
                  long long v89 = v61;
                  sub_100035E70((uint64_t)&v88, &v82, &v83);
                  xpc_release(v83);
                  xpc_object_t v83 = 0;
                  if (SHIBYTE(v87) < 0) {
                    operator delete(v86[0]);
                  }
                  xpc_release(v82);
                  xpc_object_t v82 = 0;
                }
                else
                {
                  if (v46 == -2)
                  {
                    memset(buf, 0, sizeof(buf));
                    ctu::cf::assign();
                    *(_OWORD *)long long v86 = *(_OWORD *)buf;
                    uint64_t v87 = *(void *)&buf[16];
                    if ((buf[23] & 0x80u) == 0) {
                      CFNumberRef v58 = v86;
                    }
                    else {
                      CFNumberRef v58 = (xpc_object_t *)v86[0];
                    }
                    xpc_object_t v85 = xpc_string_create((const char *)v58);
                    if (!v85) {
                      xpc_object_t v85 = xpc_null_create();
                    }
                    int v57 = v94;
                    if (v95 < 0) {
                      int v57 = (void **)v94[0];
                    }
                  }
                  else
                  {
                    if (v46 != -1) {
                      goto LABEL_151;
                    }
                    memset(buf, 0, sizeof(buf));
                    ctu::cf::assign();
                    *(_OWORD *)long long v86 = *(_OWORD *)buf;
                    uint64_t v87 = *(void *)&buf[16];
                    if ((buf[23] & 0x80u) == 0) {
                      char v56 = v86;
                    }
                    else {
                      char v56 = (xpc_object_t *)v86[0];
                    }
                    xpc_object_t v85 = xpc_string_create((const char *)v56);
                    if (!v85) {
                      xpc_object_t v85 = xpc_null_create();
                    }
                    int v57 = v94;
                    if (v95 < 0) {
                      int v57 = (void **)v94[0];
                    }
                  }
                  *(void *)CSIPhoneNumber buf = &v98;
                  *(void *)&uint8_t buf[8] = v57;
                  sub_100035E70((uint64_t)buf, &v85, &v88);
                  xpc_release(v88);
                  xpc_object_t v88 = 0;
                  xpc_release(v85);
                  xpc_object_t v85 = 0;
                  if (SHIBYTE(v87) < 0) {
                    operator delete(v86[0]);
                  }
                }
LABEL_151:
                xpc_object_t v81 = xpc_BOOL_create(*(unsigned char *)(v4 + 387));
                if (!v81) {
                  xpc_object_t v81 = xpc_null_create();
                }
                *(void *)CSIPhoneNumber buf = &v98;
                *(void *)&uint8_t buf[8] = kDataActivateFailureSatelliteSystemKey;
                sub_100035E70((uint64_t)buf, &v81, v86);
                xpc_release(v86[0]);
                v86[0] = 0;
                xpc_release(v81);
                xpc_object_t v80 = 0;
                xpc_object_t v81 = 0;
                xpc_object_t v62 = xpc_dictionary_create(0, 0, 0);
                if (v62 || (xpc_object_t v62 = xpc_null_create()) != 0)
                {
                  if (xpc_get_type(v62) == (xpc_type_t)&_xpc_type_dictionary)
                  {
                    xpc_retain(v62);
                    xpc_object_t v63 = v62;
                  }
                  else
                  {
                    xpc_object_t v63 = xpc_null_create();
                  }
                }
                else
                {
                  xpc_object_t v63 = xpc_null_create();
                  xpc_object_t v62 = 0;
                }
                xpc_release(v62);
                xpc_object_t v80 = v63;
                if (v63) {
                  xpc_retain(v63);
                }
                else {
                  xpc_object_t v80 = xpc_null_create();
                }
                xpc_release(v63);
                ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 88));
                char v65 = ServiceMap;
                if (v66 < 0)
                {
                  uint64_t v67 = (unsigned __int8 *)(v66 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v68 = 5381;
                  do
                  {
                    uint64_t v66 = v68;
                    unsigned int v69 = *v67++;
                    uint64_t v68 = (33 * v68) ^ v69;
                  }
                  while (v69);
                }
                std::mutex::lock(ServiceMap);
                *(void *)CSIPhoneNumber buf = v66;
                long long v70 = sub_10004D37C(&v65[1].__m_.__sig, (unint64_t *)buf);
                if (v70)
                {
                  uint64_t v71 = v70[3];
                  int64_t v72 = (std::__shared_weak_count *)v70[4];
                  if (v72)
                  {
                    atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v65);
                    atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v72);
                    char v73 = 0;
LABEL_170:
                    if (v71)
                    {
                      *(void *)CSIPhoneNumber buf = v98;
                      if (v98) {
                        xpc_retain(v98);
                      }
                      else {
                        *(void *)CSIPhoneNumber buf = xpc_null_create();
                      }
                      (*(void (**)(uint64_t, uint64_t, uint8_t *, xpc_object_t *))(*(void *)v71 + 40))(v71, 52, buf, &v80);
                      xpc_release(*(xpc_object_t *)buf);
                    }
                    if ((v73 & 1) == 0) {
                      sub_10004D2C8(v72);
                    }
                    xpc_release(v80);
                    if (SHIBYTE(v95) < 0) {
                      operator delete(v94[0]);
                    }
                    xpc_release(v98);
                    goto LABEL_180;
                  }
                }
                else
                {
                  uint64_t v71 = 0;
                }
                std::mutex::unlock(v65);
                int64_t v72 = 0;
                char v73 = 1;
                goto LABEL_170;
              }
            }
LABEL_180:
            if (v39) {
              sub_10004D2C8(v39);
            }
            if (v77) {
              sub_10004D2C8(v77);
            }
            goto LABEL_184;
          }
        }
        else
        {
          uint64_t v36 = *(void *)v75;
        }
        uint64_t v38 = "";
        uint64_t v37 = "";
        goto LABEL_56;
      }
    }
  }
}

void sub_1011B7534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,xpc_object_t a24,uint64_t a25,xpc_object_t object,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,xpc_object_t a36,uint64_t a37,xpc_object_t a38,uint64_t a39,char a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011B7784(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    *(void *)(v1 + 456) = v2;
    uint64_t v3 = *(NSObject **)(v1 + 56);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v5 = 136315138;
    uint64_t v6 = "connectionFailureAlertRegister_block_invoke";
    uint64_t v4 = "#I %s: network_config_cellular_failed_observer_create succeeded";
  }
  else
  {
    uint64_t v3 = *(NSObject **)(v1 + 56);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v5 = 136315138;
    uint64_t v6 = "connectionFailureAlertRegister_block_invoke_2";
    uint64_t v4 = "#I %s: network_config_cellular_failed_observer_create failed";
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v5, 0xCu);
}

uint64_t sub_1011B7870(uint64_t a1)
{
  return _network_config_cellular_blocked_observer_cancel(*(void *)(a1 + 32));
}

uint64_t sub_1011B7878(uint64_t a1, _DWORD *a2)
{
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 216) + 392))(*(void *)(a1 + 216))) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 440))(*(void *)(a1 + 216));
  if (result)
  {
    *a2 = -2;
    return 1;
  }
  return result;
}

uint64_t sub_1011B7918(uint64_t a1)
{
  if (capabilities::ct::supportsDataPlanNotifications((capabilities::ct *)a1))
  {
    if (qword_101B14190)
    {
      uint64_t v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
      if (v2)
      {
        uint64_t v3 = v2;
        if (DataPlanManagerBootstrap::sInstance)
        {
          uint64_t v4 = DataPlanManagerBootstrap::sInstance + 8;
          if (((*(uint64_t (**)(uint64_t))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 96))(DataPlanManagerBootstrap::sInstance + 8) & 1) == 0
            || (*(unsigned int (**)(uint64_t))(*(void *)v4 + 88))(v4)
            && ((*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 120))(v4, *(unsigned int *)(a1 + 392)) & 1) != 0)
          {
            *(unsigned char *)(a1 + 464) = 0;
            sub_10004D2C8(v3);
            return 0;
          }
        }
        sub_10004D2C8(v3);
      }
    }
  }
  if (*(void *)(a1 + 104) != *(void *)(a1 + 112))
  {
    uint64_t v6 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      int v7 = "#I This data connection was asserted internally.";
LABEL_16:
      unsigned int v8 = v6;
      uint32_t v9 = 2;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v12, v9);
      goto LABEL_18;
    }
    goto LABEL_18;
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 216) + 104))(*(void *)(a1 + 216)))
  {
    uint64_t v6 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      int v7 = "#I internet PDP asserted";
      goto LABEL_16;
    }
LABEL_18:
    uint64_t result = 1;
    *(unsigned char *)(a1 + 464) = 1;
    return result;
  }
  if (*(unsigned char *)(a1 + 448))
  {
    if (*(unsigned char *)(a1 + 464)) {
      goto LABEL_18;
    }
    uint64_t v10 = *(NSObject **)(a1 + 56);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    int v12 = 136315138;
    uint64_t v13 = "hasDataAssertionsLegacy";
    int v7 = "#I %s: no pdp assertions but permanently asserted";
    unsigned int v8 = v10;
    uint32_t v9 = 12;
    goto LABEL_17;
  }
  if (*(unsigned char *)(a1 + 464))
  {
    uint64_t v11 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136315138;
      uint64_t v13 = "hasDataAssertionsLegacy";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s: Internet is not asserted", (uint8_t *)&v12, 0xCu);
    }
  }
  *(unsigned char *)(a1 + 464) = 0;
  return 1;
}

void sub_1011B7BB0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011B7BC4(uint64_t a1, double a2)
{
  *(unsigned char *)(a1 + 448) = a2 == 1.79769313e308;
  uint64_t v3 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315394;
    int v5 = "updateInactivityTimeout";
    __int16 v6 = 2080;
    uint64_t v7 = asStringBool(a2 == 1.79769313e308);
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: PermanentlyAsserted %s", (uint8_t *)&v4, 0x16u);
  }
}

void sub_1011B7CA4(uint64_t a1, double a2)
{
}

uint64_t sub_1011B7CAC(uint64_t a1, void *a2)
{
  if (!qword_101B14190) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
  if (!v3) {
    return 0;
  }
  int v4 = v3;
  uint64_t v5 = DataPlanManagerBootstrap::sInstance;
  if (DataPlanManagerBootstrap::sInstance)
  {
    *a2 = 1;
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(v5 + 8) + 168))();
  }
  else
  {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_1011B7D48(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011B7D5C()
{
  return 16842752;
}

uint64_t sub_1011B7D6C()
{
  return 16842752;
}

uint64_t sub_1011B7D7C(Registry **a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  (*((void (**)(uint64_t *__return_ptr))*a1 + 17))(&v6);
  if (v6)
  {
    uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 144))(v6);
  }
  else
  {
    uint64_t v3 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v2 = suspendInternetOnBBCall(a1 + 11, v3);
  }
  uint64_t v4 = v2;
  if (v7) {
    sub_10004D2C8(v7);
  }
  return v4;
}

void sub_1011B7E2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011B7E44(uint64_t a1)
{
  return sub_1011B7D7C((Registry **)(a1 - 64));
}

uint64_t sub_1011B7E4C()
{
  return 1;
}

uint64_t sub_1011B7E54()
{
  return 1;
}

uint64_t sub_1011B7E5C()
{
  return 1;
}

BOOL sub_1011B7E64(PersonalitySpecificImpl *a1)
{
  int v2 = (*(uint64_t (**)(void *))(**((void **)a1 + 27) + 288))(*((void **)a1 + 27));
  return v2 != PersonalitySpecificImpl::simSlot(a1);
}

uint64_t sub_1011B7EC8(PersonalitySpecificImpl *a1, uint64_t a2)
{
  if (sub_1012A547C(a1))
  {
    uint64_t v4 = *((void *)a1 + 27);
    uint64_t v5 = PersonalitySpecificImpl::simSlot(a1);
    int v6 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v4 + 168))(v4, 0, v5);
    uint64_t result = 0;
    if (!v6) {
      return result;
    }
    *(_DWORD *)a2 = 18;
    unsigned int v8 = "We do not allow Internet data during a BB Call";
  }
  else
  {
    *(_DWORD *)a2 = 105;
    unsigned int v8 = "iRAT insists on using WiFi for Internet";
  }
  *(void *)(a2 + 8) = v8;
  *(void *)(a2 + 16) = "";
  *(_DWORD *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 28) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint32_t v9 = *(std::__shared_weak_count **)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  if (v9) {
    sub_10004D2C8(v9);
  }
  return 1;
}

uint64_t sub_1011B7F94(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (qword_101B14190)
  {
    int v6 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v6 && DataPlanManagerBootstrap::sInstance) {
      (*(void (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 192))();
    }
  }
  else
  {
    int v6 = 0;
  }
  long long v7 = *a4;
  long long v8 = a4[1];
  *(void *)(a1 + 424) = *((void *)a4 + 4);
  *(_OWORD *)(a1 + 392) = v7;
  *(_OWORD *)(a1 + 408) = v8;
  uint64_t v10 = *((void *)a4 + 5);
  uint32_t v9 = (std::__shared_weak_count *)*((void *)a4 + 6);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 440);
  *(void *)(a1 + 432) = v10;
  *(void *)(a1 + 440) = v9;
  if (v11)
  {
    sub_10004D2C8(v11);
    uint64_t v10 = *(void *)(a1 + 432);
    uint32_t v9 = *(std::__shared_weak_count **)(a1 + 440);
  }
  uint64_t v12 = *(void *)(a1 + 216);
  long long v13 = *(_OWORD *)(a1 + 408);
  v15[0] = *(_OWORD *)(a1 + 392);
  v15[1] = v13;
  uint64_t v16 = *(void *)(a1 + 424);
  uint64_t v17 = v10;
  uint64_t v18 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, _OWORD *))(*(void *)v12 + 120))(v12, v15);
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return 0;
}

void sub_1011B80C4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011B80F0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = "activatedTrigger";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: Initiating public DNS wait", (uint8_t *)&buf, 0xCu);
  }
  if (sub_1011B8358((PersonalitySpecificImpl *)a1))
  {
    Registry::getTimerService((uint64_t *)&buf, *(Registry **)(a1 + 88));
    uint64_t v3 = buf;
    sub_100058DB0(__p, "public DNS wait timer");
    uint64_t v4 = *(NSObject **)(a1 + 40);
    dispatch_object_t object = v4;
    if (v4) {
      dispatch_retain(v4);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_1011B83D4;
    aBlock[3] = &unk_101A9B3D0;
    aBlock[4] = a1;
    uint32_t v9 = _Block_copy(aBlock);
    sub_100118A44(v3, (uint64_t)__p, 0, 1000000, &object, &v9);
    uint64_t v5 = v13;
    uint64_t v13 = 0;
    uint64_t v6 = *(void *)(a1 + 472);
    *(void *)(a1 + 472) = v5;
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      uint64_t v7 = v13;
      uint64_t v13 = 0;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
    }
    if (v9) {
      _Block_release(v9);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
  }
  else
  {
    sub_1011B851C(a1);
  }
}

void sub_1011B82F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011B8358(PersonalitySpecificImpl *a1)
{
  uint64_t result = sub_1012A547C(a1);
  if (result)
  {
    if (*((void *)a1 + 27))
    {
      int v3 = PersonalitySpecificImpl::simSlot(a1);
      return v3 == (*(unsigned int (**)(void *))(**((void **)a1 + 27) + 288))(*((void **)a1 + 27));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1011B83D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(NSObject **)(v1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N public DNS wait timer: timeout", v4, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 472);
  *(void *)(v1 + 472) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1011B8470(v1);
}

void sub_1011B8470(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    uint64_t v4 = "processDnsReady_sync";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: Public DNS wait period completion", (uint8_t *)&v3, 0xCu);
  }
  sub_1011B851C(a1);
}

void sub_1011B851C(uint64_t a1)
{
  if (qword_101B14190)
  {
    int v2 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v2)
    {
      int v3 = v2;
      if (DataPlanManagerBootstrap::sInstance)
      {
        uint64_t v4 = DataPlanManagerBootstrap::sInstance + 8;
        uint64_t v5 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = 136315138;
          uint64_t v7 = "dataPlanManagerActivatedInternetTrigger_sync";
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s: passing to data plan", (uint8_t *)&v6, 0xCu);
        }
        (*(void (**)(uint64_t))(*(void *)v4 + 176))(v4);
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_1011B8620(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011B8634(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 472);
  if (v2)
  {
    *(void *)(a1 + 472) = 0;
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    sub_1011B8470(a1);
  }
}

void sub_1011B86A4(uint64_t a1)
{
}

void sub_1011B86AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 472);
  *(void *)(a1 + 472) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (qword_101B14190)
  {
    int v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v3)
    {
      uint64_t v4 = v3;
      if (DataPlanManagerBootstrap::sInstance)
      {
        uint64_t v5 = DataPlanManagerBootstrap::sInstance + 8;
        int v6 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = 136315138;
          long long v8 = "deactivatedTrigger";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: passing to data plan", (uint8_t *)&v7, 0xCu);
        }
        (*(void (**)(uint64_t))(*(void *)v5 + 184))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1011B87E0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011B87F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 472);
  *(void *)(a1 + 472) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  if (qword_101B14190)
  {
    uint32_t v9 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v9)
    {
      uint64_t v10 = v9;
      if (DataPlanManagerBootstrap::sInstance)
      {
        uint64_t v11 = DataPlanManagerBootstrap::sInstance + 8;
        char v12 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136315138;
          unint64_t v14 = "deactivatedOnNetworkDisconnectTrigger";
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: passing to data plan", (uint8_t *)&v13, 0xCu);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 200))(v11, a2, a3, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_1011B8948(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011B895C(uint64_t a1)
{
  sub_1012A3D10(a1);
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 448));
    int v5 = 136315138;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fPermanentlyAsserted = %s", (uint8_t *)&v5, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 56);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asStringBool(*(void *)(a1 + 472) != 0);
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t fWaitingForDnsTimer = %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1011B8A60(uint64_t a1)
{
}

uint64_t sub_1011B8A68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!qword_101B14190) {
    return 0;
  }
  uint64_t v6 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
  if (!v6) {
    return 0;
  }
  int v7 = v6;
  uint64_t v8 = DataPlanManagerBootstrap::sInstance;
  if (DataPlanManagerBootstrap::sInstance)
  {
    uint64_t v9 = sub_101299E6C(a1);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v8 + 8) + 240))(v8 + 8, v9, a2, a3);
  }
  else
  {
    uint64_t v10 = 0;
  }
  sub_10004D2C8(v7);
  return v10;
}

void sub_1011B8B20(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011B8B34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1011B8A68(a1 - 72, a2, a3);
}

void sub_1011B8B3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_101B14190)
  {
    uint64_t v6 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v6)
    {
      int v7 = v6;
      if (DataPlanManagerBootstrap::sInstance)
      {
        uint64_t v8 = DataPlanManagerBootstrap::sInstance + 8;
        uint64_t v9 = *(NSObject **)(a1 + 56);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136315138;
          uint64_t v11 = "pcoTrigger";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s: passing to data plan", (uint8_t *)&v10, 0xCu);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 208))(v8, a2, a3);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1011B8C58(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1011B8C6C@<Q0>(capabilities::ct *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(_DWORD *)a2 && capabilities::ct::getBasebandBootStrategy(a1) == 2)
  {
    int v6 = (*(uint64_t (**)(capabilities::ct *))(*(void *)a1 + 1216))(a1);
    if (v6)
    {
      int v7 = v6;
      uint64_t v8 = asString();
      uint64_t v9 = "";
      if (v8) {
        uint64_t v9 = (const char *)v8;
      }
      *(_DWORD *)a2 = -1;
      *(void *)(a2 + 8) = "Cellular is not the preferred context type";
      *(void *)(a2 + 16) = v9;
      *(_DWORD *)(a2 + 24) = 0;
      *(unsigned char *)(a2 + 28) = 0;
      *(_DWORD *)(a2 + 32) = v7;
      *(_DWORD *)(a2 + 36) = 0;
      int v10 = *(std::__shared_weak_count **)(a2 + 48);
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      if (v10) {
        sub_10004D2C8(v10);
      }
    }
  }
  long long v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(_OWORD *)(a3 + 16) = v11;
  *(void *)(a3 + 32) = *(void *)(a2 + 32);
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a3 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

uint64_t sub_1011B8D48(PersonalitySpecificImpl *a1)
{
  uint64_t v2 = 1;
  if (sub_1011B8358(a1))
  {
    if ((*(unsigned int (**)(PersonalitySpecificImpl *))(*(void *)a1 + 520))(a1) == 5) {
      return 2;
    }
    else {
      return 1;
    }
  }
  return v2;
}

uint64_t sub_1011B8DB0(uint64_t a1)
{
  return sub_1011B8D48((PersonalitySpecificImpl *)(a1 - 72));
}

BOOL sub_1011B8DB8(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 28);
  if (v2 != *(unsigned __int8 *)(a2 + 28)) {
    return v2 != 0;
  }
  int v3 = *(_DWORD *)(a1 + 24);
  int v4 = *(_DWORD *)(a2 + 24);
  BOOL v6 = __OFSUB__(v3, v4);
  BOOL v5 = v3 - v4 < 0;
  if (v3 == v4)
  {
    char v7 = sub_100046FE8((void *)a1, (void **)a2);
    BOOL v6 = 0;
    BOOL v5 = v7 < 0;
  }
  return v5 != v6;
}

uint64_t sub_1011B8E08(uint64_t a1, dispatch_object_t *a2, void *a3, void *a4, void *a5, void *a6)
{
  *(void *)a1 = off_101A3E520;
  *(void *)(a1 + 8) = off_101A464A0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v23, kCtLoggingSystemName, "cp.s.tr.ctr");
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  char v12 = *a2;
  *(void *)(a1 + 32) = *a2;
  if (v12) {
    dispatch_retain(v12);
  }
  *(void *)(a1 + 40) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v24, &v23);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 48), (const ctu::OsLogLogger *)v24);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v24);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v23);
  *(void *)a1 = off_101A9C118;
  *(void *)(a1 + 8) = off_101A9C298;
  *(void *)(a1 + 56) = *a4;
  uint64_t v13 = a4[1];
  *(void *)(a1 + 64) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *a3;
  uint64_t v14 = a3[1];
  *(void *)(a1 + 80) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = *a5;
  uint64_t v15 = a5[1];
  *(void *)(a1 + 96) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 104) = *a6;
  uint64_t v16 = a6[1];
  *(void *)(a1 + 112) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  *(void *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(void *)(a1 + 344) = a1 + 352;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 472) = 0;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(void *)(a1 + 536) = a1 + 544;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 568) = 0;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 552) = 0;
  *(void *)(a1 + 560) = a1 + 568;
  *(void *)(a1 + 664) = 0;
  *(void *)(a1 + 672) = 0;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(void *)(a1 + 648) = 0;
  *(void *)(a1 + 656) = a1 + 664;
  *(unsigned char *)(a1 + 680) = 0;
  *(unsigned char *)(a1 + 704) = 0;
  *(void *)(a1 + 800) = 0;
  *(void *)(a1 + 792) = 0;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(void *)(a1 + 776) = 0;
  *(void *)(a1 + 784) = a1 + 792;
  sub_100058DB0(&__p, "CellularPlanSourceTransferFlowController");
  BOOL v20 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v17 = *(NSObject **)(a1 + 40);
  dispatch_object_t object = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    dispatch_release(v20);
  }
  if (v22 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 864) = 0;
  *(void *)(a1 + 856) = 0;
  *(void *)(a1 + 848) = a1 + 856;
  *(unsigned char *)(a1 + 872) = 0;
  return a1;
}

void sub_1011B9100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, _Unwind_Exception *exception_object, dispatch_object_t object, dispatch_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23)
{
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    dispatch_release(a14);
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1011C7EA4(*(void **)(v23 + 792));
  uint64_t v29 = *(std::__shared_weak_count **)(v23 + 776);
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v23 + 760);
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (*(char *)(v23 + 751) < 0) {
    operator delete(*(void **)(v23 + 728));
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v23 + 720);
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (*(unsigned char *)(v23 + 704) && *(char *)(v23 + 703) < 0) {
    operator delete(*(void **)(v23 + 680));
  }
  sub_1000886C0(v26 + 488, *(char **)(v23 + 664));
  if (*(char *)(v23 + 655) < 0) {
    operator delete(*(void **)(v23 + 632));
  }
  a21 = v26 + 440;
  sub_10008A88C((void ***)&a21);
  a21 = v26 + 416;
  sub_1000C56F4((void ***)&a21);
  sub_10005CD2C(v26 + 392, *(char **)(v23 + 568));
  sub_10010C0E0(v26 + 368, *(void **)(v23 + 544));
  if (*(char *)(v23 + 535) < 0) {
    operator delete(*(void **)(v23 + 512));
  }
  sub_100313814((void *)(v26 + 312));
  sub_10010E020((void *)(v26 + 280));
  uint64_t v32 = *(std::__shared_weak_count **)(v23 + 440);
  if (v32) {
    sub_10004D2C8(v32);
  }
  sub_1011C7B3C(v28);
  sub_10030AAD0(v27, *(void **)(v23 + 200));
  sub_10005CD2C(v26, *(char **)(v23 + 176));
  char v33 = *(std::__shared_weak_count **)(v23 + 160);
  if (v33) {
    sub_10004D2C8(v33);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v23 + 144);
  if (v34) {
    sub_10004D2C8(v34);
  }
  uint32_t v35 = *(std::__shared_weak_count **)(v23 + 128);
  if (v35) {
    sub_10004D2C8(v35);
  }
  uint64_t v36 = *(std::__shared_weak_count **)(v23 + 112);
  if (v36) {
    sub_10004D2C8(v36);
  }
  uint64_t v37 = *(std::__shared_weak_count **)(v23 + 96);
  if (v37) {
    std::__shared_weak_count::__release_weak(v37);
  }
  uint64_t v38 = *(std::__shared_weak_count **)(v23 + 80);
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  uint64_t v39 = *(std::__shared_weak_count **)(v23 + 64);
  if (v39) {
    sub_10004D2C8(v39);
  }
  ctu::OsLogLogger::~OsLogLogger(v25);
  sub_100087E88(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_1011B92E4(uint64_t a1)
{
  *(void *)a1 = off_101A9C118;
  *(void *)(a1 + 8) = off_101A9C298;
  sub_1011B94C8(a1);
  sub_10010C0E0(a1 + 848, *(void **)(a1 + 856));
  int v2 = *(std::__shared_weak_count **)(a1 + 832);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1011C7EA4(*(void **)(a1 + 792));
  int v3 = *(std::__shared_weak_count **)(a1 + 776);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 760);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 751) < 0) {
    operator delete(*(void **)(a1 + 728));
  }
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 720);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*(unsigned char *)(a1 + 704) && *(char *)(a1 + 703) < 0) {
    operator delete(*(void **)(a1 + 680));
  }
  sub_1000886C0(a1 + 656, *(char **)(a1 + 664));
  if (*(char *)(a1 + 655) < 0) {
    operator delete(*(void **)(a1 + 632));
  }
  uint64_t v15 = (void **)(a1 + 608);
  sub_10008A88C(&v15);
  uint64_t v15 = (void **)(a1 + 584);
  sub_1000C56F4(&v15);
  sub_10005CD2C(a1 + 560, *(char **)(a1 + 568));
  sub_10010C0E0(a1 + 536, *(void **)(a1 + 544));
  if (*(char *)(a1 + 535) < 0) {
    operator delete(*(void **)(a1 + 512));
  }
  sub_100313814((void *)(a1 + 480));
  sub_10010E020((void *)(a1 + 448));
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 440);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_1011C7B3C(a1 + 216);
  sub_10030AAD0(a1 + 192, *(void **)(a1 + 200));
  sub_10005CD2C(a1 + 168, *(char **)(a1 + 176));
  char v7 = *(std::__shared_weak_count **)(a1 + 160);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 144);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 128);
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v10 = *(std::__shared_weak_count **)(a1 + 112);
  if (v10) {
    sub_10004D2C8(v10);
  }
  long long v11 = *(std::__shared_weak_count **)(a1 + 96);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  char v12 = *(std::__shared_weak_count **)(a1 + 80);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 64);
  if (v13) {
    sub_10004D2C8(v13);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  return a1;
}

void sub_1011B94C8(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v2)
  {
    int v3 = 0;
    goto LABEL_8;
  }
  int v3 = std::__shared_weak_count::lock(v2);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 72)) == 0)
  {
LABEL_8:
    BOOL v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "invalid delegate", buf, 2u);
      if (!v3) {
        return;
      }
    }
    else if (!v3)
    {
      return;
    }
    goto LABEL_10;
  }
  (*(void (**)(void, void, uint64_t))(*(void *)v4 + 200))(*(void *)(a1 + 72), 0, 1);
  BOOL v5 = (void **)(a1 + 728);
  if (*(char *)(a1 + 751) < 0)
  {
    unint64_t v7 = *(void *)(a1 + 736);
    if (v7)
    {
      sub_10004FC84(__p, *v5, v7);
      goto LABEL_14;
    }
  }
  else if (*(unsigned char *)(a1 + 751))
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v5;
    uint64_t v9 = *(void *)(a1 + 744);
LABEL_14:
    (*(void (**)(uint64_t, void **, void))(*(void *)v4 + 160))(v4, __p, 0);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
    if (*(char *)(a1 + 751) < 0)
    {
      **(unsigned char **)(a1 + 728) = 0;
      *(void *)(a1 + 736) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 728) = 0;
      *(unsigned char *)(a1 + 751) = 0;
    }
  }
LABEL_10:
  sub_10004D2C8(v3);
}

void sub_1011B9634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1011B9664(uint64_t a1)
{
  return sub_1011B92E4(a1 - 8);
}

void sub_1011B966C(uint64_t a1)
{
  sub_1011B92E4(a1);

  operator delete();
}

void sub_1011B96A4(uint64_t a1)
{
  sub_1011B92E4(a1 - 8);

  operator delete();
}

void sub_1011B96E0(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, const std::string *a6, uint64_t a7, const std::string *a8, uint64_t a9, uint64_t a10, uint64_t *a11)
{
  sub_1011B9A74((void *)a1, a2);
  sub_1011B9AE4((void *)a1, a3);
  std::string::operator=((std::string *)(a1 + 632), a8);
  if (a1 + 656 != a5) {
    sub_100429B2C((uint64_t **)(a1 + 656), *(void **)a5, (void *)(a5 + 8));
  }
  sub_100179AF8((std::string *)(a1 + 680), a6);
  if (a1 + 168 != a9) {
    sub_1011C7F78((uint64_t *)(a1 + 168), *(void **)a9, (void *)(a9 + 8));
  }
  uint64_t v16 = *(void *)(a1 + 56);
  uint64_t v17 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  (*(void (**)(Registry **__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v16 + 416))(v37, v16, &object);
  long long v18 = *(_OWORD *)v37;
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 128);
  *(_OWORD *)(a1 + 120) = v18;
  if (v19)
  {
    sub_10004D2C8(v19);
    if (v37[1]) {
      sub_10004D2C8((std::__shared_weak_count *)v37[1]);
    }
  }
  if (object) {
    dispatch_release(object);
  }
  uint64_t v20 = *(void *)(a1 + 56);
  char v21 = *(NSObject **)(a1 + 32);
  dispatch_object_t v31 = v21;
  if (v21) {
    dispatch_retain(v21);
  }
  char v22 = *(std::__shared_weak_count **)(a1 + 128);
  uint64_t v29 = *(void *)(a1 + 120);
  uint64_t v30 = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(Registry **__return_ptr, uint64_t, dispatch_object_t *, uint64_t *))(*(void *)v20 + 528))(v37, v20, &v31, &v29);
  long long v23 = *(_OWORD *)v37;
  v37[0] = 0;
  v37[1] = 0;
  uint64_t v24 = *(std::__shared_weak_count **)(a1 + 144);
  *(_OWORD *)(a1 + 136) = v23;
  if (v24)
  {
    sub_10004D2C8(v24);
    if (v37[1]) {
      sub_10004D2C8((std::__shared_weak_count *)v37[1]);
    }
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (v31) {
    dispatch_release(v31);
  }
  uint64_t v26 = *a11;
  uint64_t v25 = a11[1];
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 712) = v26;
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 720);
  *(void *)(a1 + 720) = v25;
  if (v27) {
    sub_10004D2C8(v27);
  }
  (***(void (****)(Registry **__return_ptr))(a1 + 56))(v37);
  Registry::createRestModuleOneTimeUseConnection(&v33, v37[0]);
  ctu::RestModule::connect();
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (v37[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v37[1]);
  }
  sub_100058DB0(&__p, "/cc/requests/transfer_secure_intent");
  uint64_t v28 = operator new(0x20uLL);
  *uint64_t v28 = off_101A9CF58;
  v28[1] = a1;
  v28[2] = sub_1011C77B8;
  v28[3] = 0;
  uint64_t v38 = v28;
  ctu::RestModule::registerAsRequestSink();
  sub_1001F23E0(v37);
  if (v36 < 0) {
    operator delete(__p);
  }
  sub_100AA61BC(a1 + 848);
  sub_1000DDC20(a1 + 872);
}

void sub_1011B99E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1011B9A74(void *a1, uint64_t *a2)
{
  uint64_t v3 = (uint64_t)(a1 + 73);
  if ((uint64_t *)v3 != a2) {
    sub_1003DB294(v3, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3));
  }
  sub_1011C7158(a1);

  sub_1011C724C(a1);
}

void sub_1011B9AE4(void *a1, uint64_t *a2)
{
  uint64_t v3 = (uint64_t)(a1 + 76);
  if ((uint64_t *)v3 != a2) {
    sub_1003DB990(v3, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
  sub_1011C7158(a1);
  sub_1011C724C(a1);
  uint64_t v4 = a1[76];
  uint64_t v5 = a1[77];
  if (v4 != v5)
  {
    BOOL v6 = (uint64_t **)(a1 + 67);
    uint64_t v7 = v4 + 72;
    do
    {
      if (*(char *)(v7 + 23) < 0)
      {
        if (!*(void *)(v7 + 8)) {
          goto LABEL_12;
        }
      }
      else if (!*(unsigned char *)(v7 + 23))
      {
        goto LABEL_12;
      }
      if (*(char *)(v7 + 47) < 0)
      {
        if (!*(void *)(v7 + 32)) {
          goto LABEL_12;
        }
LABEL_11:
        int v10 = (long long *)v7;
        uint64_t v8 = sub_100366370(v6, (void **)v7, (uint64_t)&unk_10144E20E, &v10);
        std::string::operator=((std::string *)(v8 + 7), (const std::string *)(v7 + 24));
        goto LABEL_12;
      }
      if (*(unsigned char *)(v7 + 47)) {
        goto LABEL_11;
      }
LABEL_12:
      uint64_t v9 = v7 + 96;
      v7 += 168;
    }
    while (v9 != v5);
  }
}

void sub_1011B9BF8(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 360);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Iccid set size: %d", buf, 8u);
    int v2 = *(NSObject **)(a1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v40 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)uint64_t v28 = 0u;
    long long v29 = 0u;
    memset(v27, 0, sizeof(v27));
    *(_OWORD *)long long buf = 0u;
    sub_10004BD84((uint64_t)buf);
    uint64_t v4 = sub_10004B96C(v27, (uint64_t)"iccid set: (", 12);
    uint64_t v5 = *(void **)(a1 + 344);
    BOOL v6 = (void *)(a1 + 352);
    memset(&__p, 0, sizeof(__p));
    if (v5 != (void *)(a1 + 352))
    {
      if (*((char *)v5 + 55) < 0) {
        sub_10004FC84(&__s, (void *)v5[4], v5[5]);
      }
      else {
        std::string __s = *(std::string *)(v5 + 4);
      }
      std::string __p = __s;
      uint64_t v7 = (void *)v5[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v5[2];
          BOOL v9 = *v8 == (void)v5;
          uint64_t v5 = v8;
        }
        while (!v9);
      }
      if (v8 != v6)
      {
        do
        {
          *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
          strcpy((char *)&__s, ", ");
          std::string::append(&__p, (const std::string::value_type *)&__s, 2uLL);
          if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__s.__r_.__value_.__l.__data_);
          }
          if (*((char *)v8 + 55) < 0) {
            sub_10004FC84(&__s, (void *)v8[4], v8[5]);
          }
          else {
            std::string __s = *(std::string *)(v8 + 4);
          }
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_s = &__s;
          }
          else {
            p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
          }
          if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = __s.__r_.__value_.__l.__size_;
          }
          std::string::append(&__p, (const std::string::value_type *)p_s, size);
          if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__s.__r_.__value_.__l.__data_);
          }
          char v12 = (void *)v8[1];
          if (v12)
          {
            do
            {
              uint64_t v13 = v12;
              char v12 = (void *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              uint64_t v13 = (void *)v8[2];
              BOOL v9 = *v13 == (void)v8;
              uint64_t v8 = v13;
            }
            while (!v9);
          }
          uint64_t v8 = v13;
        }
        while (v13 != v6);
      }
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v15 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v16 = sub_10004B96C(v4, (uint64_t)p_p, v15);
    sub_10004B96C(v16, (uint64_t)")", 1);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v17 = sub_10004B96C(v27, (uint64_t)", iccid awaiting persona: (", 27);
    int v18 = *(char *)(a1 + 423);
    if (v18 >= 0) {
      uint64_t v19 = a1 + 400;
    }
    else {
      uint64_t v19 = *(void *)(a1 + 400);
    }
    if (v18 >= 0) {
      uint64_t v20 = *(unsigned __int8 *)(a1 + 423);
    }
    else {
      uint64_t v20 = *(void *)(a1 + 408);
    }
    char v21 = sub_10004B96C(v17, v19, v20);
    sub_10004B96C(v21, (uint64_t)")", 1);
    sub_10004BC98((uint64_t)v27 + 8, &__s);
    *(void *)&v27[0] = v22;
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    long long v23 = &__s;
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v23 = (std::string *)__s.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Transfer context: %s", buf, 0xCu);
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1011BA074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,xpc_object_t a23,uint64_t a24,uint64_t a25,void (__cdecl **a26)(std::stringbuf *__hidden this),uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  *(xpc_object_t *)((char *)&a23
  a25 = (uint64_t)v40;
  if (a39 < 0) {
    operator delete(a34);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  _Unwind_Resume(a1);
}

void sub_1011BA1D0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = a2;
  xpc_object_t v88 = 0;
  long long v89 = 0;
  uint64_t v90 = 0;
  long long v86 = 0;
  uint64_t v87 = 0;
  xpc_object_t v85 = &v86;
  uint64_t v5 = *(void ***)(a1 + 168);
  BOOL v6 = (void **)(a1 + 176);
  if (v5 == (void **)(a1 + 176))
  {
    long long v89 = 0;
    uint64_t v90 = 0;
    xpc_object_t v88 = (uint64_t *)&v89;
    goto LABEL_40;
  }
  uint64_t v7 = 0;
  uint64_t v8 = &v86;
  while (1)
  {
    *(void *)&long long __p = 0;
    if (v8 == &v86)
    {
      int v10 = &v86;
      if (v7) {
        goto LABEL_11;
      }
    }
    else
    {
      BOOL v9 = &v86;
      if (v7)
      {
        do
        {
          int v10 = (uint64_t **)v7;
          uint64_t v7 = (uint64_t *)v7[1];
        }
        while (v7);
      }
      else
      {
        do
        {
          int v10 = (uint64_t **)v9[2];
          BOOL v11 = *v10 == (uint64_t *)v9;
          BOOL v9 = v10;
        }
        while (v11);
      }
      if ((sub_100046FE8(v10 + 4, v5 + 4) & 0x80) == 0)
      {
        char v12 = (uint64_t **)sub_100046ED4((uint64_t)&v85, &__p, v5 + 4);
        goto LABEL_12;
      }
      if (v86)
      {
LABEL_11:
        *(void *)&long long __p = v10;
        char v12 = v10 + 1;
LABEL_12:
        if (*v12) {
          goto LABEL_19;
        }
        goto LABEL_16;
      }
    }
    *(void *)&long long __p = &v86;
    char v12 = &v86;
LABEL_16:
    long long buf = 0uLL;
    *(void *)&long long v102 = 0;
    sub_1011C813C(&buf, (uint64_t)&v85, (uint64_t)(v5 + 4));
    uint64_t v13 = __p;
    uint64_t v14 = (uint64_t *)buf;
    *(void *)long long buf = 0;
    v14[1] = 0;
    v14[2] = v13;
    *char v12 = v14;
    if (*v85)
    {
      xpc_object_t v85 = (uint64_t **)*v85;
      uint64_t v14 = *v12;
    }
    sub_100046C90(v86, v14);
    ++v87;
LABEL_19:
    std::string::size_type v15 = (void **)v5[1];
    if (v15)
    {
      do
      {
        uint64_t v16 = v15;
        std::string::size_type v15 = (void **)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        uint64_t v16 = (void **)v5[2];
        BOOL v11 = *v16 == v5;
        uint64_t v5 = v16;
      }
      while (!v11);
    }
    if (v16 == v6) {
      break;
    }
    uint64_t v8 = v85;
    uint64_t v7 = v86;
    uint64_t v5 = v16;
  }
  uint64_t v17 = v85;
  long long v89 = 0;
  uint64_t v90 = 0;
  xpc_object_t v88 = (uint64_t *)&v89;
  if (v85 != &v86)
  {
    do
    {
      if (*((_DWORD *)v17 + 14) != 2)
      {
        int v18 = v17 + 4;
        *(void *)&long long buf = v17 + 4;
        *((_WORD *)sub_10032FE40(&v88, (void **)v17 + 4, (uint64_t)&unk_10144E20E, (long long **)&buf) + 40) = 272;
        *(void *)&long long buf = v17 + 4;
        *((unsigned char *)sub_10032FE40(&v88, (void **)v17 + 4, (uint64_t)&unk_10144E20E, (long long **)&buf) + 250) = 1;
        uint64_t v19 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v17 + 55) < 0) {
            int v18 = (void *)*v18;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v18;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I iccid %s is not entitlement allowed", (uint8_t *)&buf, 0xCu);
        }
      }
      uint64_t v20 = v17[1];
      if (v20)
      {
        do
        {
          char v21 = (uint64_t **)v20;
          uint64_t v20 = (uint64_t *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          char v21 = (uint64_t **)v17[2];
          BOOL v11 = *v21 == (uint64_t *)v17;
          uint64_t v17 = v21;
        }
        while (!v11);
      }
      uint64_t v17 = v21;
    }
    while (v21 != &v86);
    uint64_t v3 = a2;
  }
LABEL_40:
  xpc_object_t v22 = (uint64_t *)v3[16];
  if (v22 != v3 + 17)
  {
    do
    {
      *(void *)&long long buf = v22 + 4;
      long long v23 = sub_10032FE40(&v88, (void **)v22 + 4, (uint64_t)&unk_10144E20E, (long long **)&buf);
      std::string::operator=((std::string *)(v23 + 7), (const std::string *)(v22 + 8));
      *((_WORD *)v23 + 40) = *((_WORD *)v22 + 44);
      sub_100179AF8((std::string *)(v23 + 11), (const std::string *)v22 + 4);
      sub_100179AF8((std::string *)v23 + 5, (const std::string *)(v22 + 16));
      sub_100179AF8((std::string *)(v23 + 19), (const std::string *)(v22 + 20));
      sub_100179AF8((std::string *)(v23 + 23), (const std::string *)v22 + 8);
      *((_WORD *)v23 + 108) = *((_WORD *)v22 + 112);
      std::string::operator=((std::string *)(v23 + 28), (const std::string *)(v22 + 29));
      __int16 v24 = *((_WORD *)v22 + 128);
      *((unsigned char *)v23 + 250) = *((unsigned char *)v22 + 258);
      *((_WORD *)v23 + 124) = v24;
      sub_100179AF8((std::string *)(v23 + 32), (const std::string *)v22 + 11);
      long long v25 = *(_OWORD *)(v22 + 37);
      *((_WORD *)v23 + 152) = *((_WORD *)v22 + 156);
      *((_OWORD *)v23 + 18) = v25;
      LOWORD(v23) = sub_100CDD060((NSObject **)(a1 + 48), a1 + 192, (uint64_t)(v22 + 4));
      *(void *)&long long buf = v22 + 4;
      *((_WORD *)sub_10032FE40(&v88, (void **)v22 + 4, (uint64_t)&unk_10144E20E, (long long **)&buf) + 152) = (_WORD)v23;
      uint64_t v26 = (uint64_t *)v22[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          uint64_t v26 = (uint64_t *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (uint64_t *)v22[2];
          BOOL v11 = *v27 == (void)v22;
          xpc_object_t v22 = v27;
        }
        while (!v11);
      }
      xpc_object_t v22 = v27;
    }
    while (v27 != v3 + 17);
  }
  long long v93 = 0uLL;
  unint64_t v94 = 0;
  uint64_t v28 = *(void *)(a1 + 584);
  uint64_t v29 = *(void *)(a1 + 592);
  while (2)
  {
    if (v28 != v29)
    {
      if (!*(unsigned char *)(v28 + 80))
      {
LABEL_65:
        v28 += 88;
        continue;
      }
      uint64_t v30 = *(void *)(v28 + 56);
      uint64_t v31 = *(void *)(v28 + 64);
      while (2)
      {
        if (v30 == v31) {
          goto LABEL_65;
        }
        if (*(char *)(v30 + 39) < 0)
        {
          if (!*(void *)(v30 + 24))
          {
LABEL_64:
            v30 += 216;
            continue;
          }
        }
        else if (!*(unsigned char *)(v30 + 39))
        {
          goto LABEL_64;
        }
        break;
      }
      if (((*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 56)
                                                                                           + 240))(*(void *)(a1 + 56), v30 + 96, v30 + 120, v30 + 144, v30 + 168, v30 + 16) & 1) == 0)
      {
        long long v32 = (_OWORD *)*((void *)&v93 + 1);
        if (*((void *)&v93 + 1) >= v94)
        {
          uint64_t v34 = sub_10030E9EC((uint64_t *)&v93, (long long *)(v30 + 16));
        }
        else
        {
          if (*(char *)(v30 + 39) < 0)
          {
            sub_10004FC84(*((unsigned char **)&v93 + 1), *(void **)(v30 + 16), *(void *)(v30 + 24));
          }
          else
          {
            long long v33 = *(_OWORD *)(v30 + 16);
            *(void *)(*((void *)&v93 + 1) + 16) = *(void *)(v30 + 32);
            _OWORD *v32 = v33;
          }
          uint64_t v34 = (uint64_t)v32 + 24;
        }
        *((void *)&v93 + 1) = v34;
      }
      goto LABEL_64;
    }
    break;
  }
  long long v35 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v35 || (long long v36 = std::__shared_weak_count::lock(v35)) == 0)
  {
    uint64_t v79 = 0;
LABEL_90:
    int64_t v46 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Delegate not available", (uint8_t *)&buf, 2u);
    }
    goto LABEL_92;
  }
  long long v37 = v36;
  uint64_t v38 = *(void *)(a1 + 72);
  uint64_t v79 = v37;
  if (!v38) {
    goto LABEL_90;
  }
  long long __p = 0uLL;
  *(void *)&long long v97 = 0;
  (*(void (**)(long long *__return_ptr))(*(void *)v38 + 184))(&__p);
  uint64_t v39 = *(void *)(a1 + 608);
  uint64_t v40 = *(void *)(a1 + 616);
  if (v39 != v40)
  {
    uint64_t v41 = v39 + 64;
    while ((subscriber::isEsimCapable() & 1) != 0)
    {
LABEL_87:
      uint64_t v45 = v41 + 104;
      v41 += 168;
      if (v45 == v40) {
        goto LABEL_88;
      }
    }
    *(void *)&long long v109 = 0;
    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    long long v103 = 0u;
    long long v104 = 0u;
    long long buf = 0u;
    long long v102 = 0u;
    sub_100CDB320((os_log_t *)(a1 + 48), v41 + 8, (uint64_t *)(a1 + 608), (uint64_t)&__p, (uint64_t)&buf);
    if (!(_BYTE)v109) {
      goto LABEL_86;
    }
    if (((*(uint64_t (**)(void, long long *, char *, long long *, char *, uint64_t))(**(void **)(a1 + 56)
                                                                                             + 240))(*(void *)(a1 + 56), &v103, (char *)&v104 + 8, &v106, (char *)&v107 + 8, v41 + 8) & 1) != 0)
    {
      if (!(_BYTE)v109
        || ((*(uint64_t (**)(void, long long *, char *, long long *, char *, uint64_t))(**(void **)(a1 + 56)
                                                                                               + 256))(*(void *)(a1 + 56), &v103, (char *)&v104 + 8, &v106, (char *)&v107 + 8, v41 + 8) & 1) != 0)
      {
        goto LABEL_86;
      }
      uint64_t v42 = *((void *)&v93 + 1);
      if (*((void *)&v93 + 1) < v94)
      {
        if (*(char *)(v41 + 31) < 0)
        {
LABEL_83:
          sub_10004FC84(*((unsigned char **)&v93 + 1), *(void **)(v41 + 8), *(void *)(v41 + 16));
LABEL_84:
          uint64_t v44 = v42 + 24;
LABEL_85:
          *((void *)&v93 + 1) = v44;
LABEL_86:
          sub_10010B788((uint64_t)&buf);
          goto LABEL_87;
        }
LABEL_81:
        long long v43 = *(_OWORD *)(v41 + 8);
        *(void *)(v42 + 16) = *(void *)(v41 + 24);
        *(_OWORD *)uint64_t v42 = v43;
        goto LABEL_84;
      }
    }
    else
    {
      uint64_t v42 = *((void *)&v93 + 1);
      if (*((void *)&v93 + 1) < v94)
      {
        if (*(char *)(v41 + 31) < 0) {
          goto LABEL_83;
        }
        goto LABEL_81;
      }
    }
    uint64_t v44 = sub_10030E9EC((uint64_t *)&v93, (long long *)(v41 + 8));
    goto LABEL_85;
  }
LABEL_88:
  sub_10010E37C((uint64_t)&__p, *((void **)&__p + 1));
LABEL_92:
  if (v79) {
    sub_10004D2C8(v79);
  }
  xpc_object_t v48 = (long long *)*((void *)&v93 + 1);
  for (uint64_t i = (long long *)v93; i != v48; uint64_t i = (long long *)((char *)i + 24))
  {
    xpc_object_t v49 = v89;
    if (v89)
    {
      int v50 = &v89;
      do
      {
        char v51 = v50;
        long long v52 = v49 + 4;
        int v53 = (char)sub_100046FE8(v49 + 4, (void **)i);
        if (v53 >= 0) {
          int v54 = v49;
        }
        else {
          int v54 = v49 + 1;
        }
        if (v53 >= 0) {
          int v50 = (void **)v49;
        }
        else {
          int v50 = v51;
        }
        xpc_object_t v49 = (void *)*v54;
      }
      while (*v54);
      if (v50 != &v89)
      {
        uint32_t v55 = (void **)(v53 >= 0 ? v52 : v51 + 4);
        if ((sub_100046FE8(i, v55) & 0x80) == 0) {
          continue;
        }
      }
    }
    long long buf = 0uLL;
    *(void *)&long long v102 = 0;
    WORD4(v102) = 262;
    LOBYTE(v103) = 0;
    BYTE8(v104) = 0;
    LOBYTE(v105) = 0;
    BYTE8(v106) = 0;
    LOBYTE(v107) = 0;
    BYTE8(v108) = 0;
    if (*((char *)i + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)i, *((void *)i + 1));
    }
    else
    {
      long long v56 = *i;
      uint64_t v92 = *((void *)i + 2);
      *(_OWORD *)long long __dst = v56;
    }
    sub_1011BB094((uint64_t)&__p, a1, __dst);
    long long v109 = __p;
    uint64_t v110 = v97;
    *(void *)&long long v97 = 0;
    uint64_t v95 = i;
    long long __p = 0uLL;
    char v111 = 1;
    __int16 v112 = 0;
    uint64_t v114 = 0;
    uint64_t v115 = 0;
    uint64_t v113 = 0;
    __int16 v116 = 0;
    char v117 = 1;
    char v118 = 0;
    char v119 = 0;
    char v120 = 0;
    char v121 = 0;
    __int16 v122 = 0;
    int v57 = sub_10032FE40(&v88, (void **)i, (uint64_t)&unk_10144E20E, &v95);
    sub_100B62F98((uint64_t)(v57 + 7), &buf);
    sub_1000C5578((uint64_t)&buf);
    if (SBYTE7(v97) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v92) < 0) {
      operator delete(__dst[0]);
    }
  }
  *(void *)&long long buf = &v93;
  sub_100047F64((void ***)&buf);
  sub_10005CD2C((uint64_t)&v85, (char *)v86);
  CFNumberRef v58 = (std::string *)a2[12];
  uint64_t v59 = a2[13];
  if (v58 != (std::string *)v59)
  {
    uint64_t v60 = v58 + 4;
    do
    {
      long long buf = 0uLL;
      *(void *)&long long v102 = 0;
      if (SHIBYTE(v60[-1].__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(v83, v60[-1].__r_.__value_.__l.__data_, v60[-1].__r_.__value_.__l.__size_);
      }
      else
      {
        long long v61 = *(_OWORD *)&v60[-1].__r_.__value_.__l.__data_;
        std::string::size_type v84 = v60[-1].__r_.__value_.__r.__words[2];
        *(_OWORD *)xpc_object_t v83 = v61;
      }
      sub_1011BB094((uint64_t)&buf, a1, v83);
      if (SHIBYTE(v84) < 0) {
        operator delete(v83[0]);
      }
      uint64_t v62 = BYTE7(v102);
      char v63 = BYTE7(v102);
      if (SBYTE7(v102) < 0) {
        uint64_t v62 = *((void *)&buf + 1);
      }
      if (v62)
      {
        std::string::operator=(v60, (const std::string *)&buf);
        char v63 = BYTE7(v102);
      }
      if (v63 < 0) {
        operator delete((void *)buf);
      }
      char v64 = v60 + 3;
      v60 += 7;
    }
    while (v64 != (std::string *)v59);
  }
  char v65 = v88;
  if (v88 != (uint64_t *)&v89)
  {
    do
    {
      sub_100CDB240((uint64_t)(v65 + 7));
      uint64_t v66 = (uint64_t *)v65[1];
      if (v66)
      {
        do
        {
          uint64_t v67 = v66;
          uint64_t v66 = (uint64_t *)*v66;
        }
        while (v66);
      }
      else
      {
        do
        {
          uint64_t v67 = (uint64_t *)v65[2];
          BOOL v11 = *v67 == (void)v65;
          char v65 = v67;
        }
        while (!v11);
      }
      char v65 = v67;
    }
    while (v67 != (uint64_t *)&v89);
  }
  uint64_t v110 = 0;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long buf = 0u;
  sub_1008A1A04((uint64_t)&buf, a2 + 9, a2 + 12, a1 + 656, (long long *)(a1 + 680), (long long *)(a1 + 632), (uint64_t)&v88);
  *((void *)&v93 + 1) = 0;
  unint64_t v94 = 0;
  *(void *)&long long v93 = (char *)&v93 + 8;
  uint64_t v68 = *(std::__shared_weak_count **)(a1 + 80);
  if (v68)
  {
    unsigned int v69 = std::__shared_weak_count::lock(v68);
    if (v69)
    {
      long long v70 = v69;
      uint64_t v71 = *(void *)(a1 + 72);
      if (v71)
      {
        (*(void (**)(long long *__return_ptr))(*(void *)v71 + 184))(&__p);
        sub_10010E37C((uint64_t)&v93, *((void **)&v93 + 1));
        int64_t v72 = (void *)*((void *)&__p + 1);
        long long v93 = __p;
        unint64_t v94 = v97;
        if ((void)v97)
        {
          *(void *)(*((void *)&__p + 1) + 16) = (char *)&v93 + 8;
          *(void *)&long long __p = (char *)&__p + 8;
          *((void *)&__p + 1) = 0;
          *(void *)&long long v97 = 0;
          int64_t v72 = 0;
        }
        else
        {
          *(void *)&long long v93 = (char *)&v93 + 8;
        }
        sub_10010E37C((uint64_t)&__p, v72);
      }
      sub_10004D2C8(v70);
    }
  }
  __dst[1] = 0;
  uint64_t v92 = 0;
  __dst[0] = &__dst[1];
  char v73 = *(std::__shared_weak_count **)(a1 + 96);
  if (v73)
  {
    long long v74 = std::__shared_weak_count::lock(v73);
    if (v74)
    {
      long long v75 = v74;
      uint64_t v76 = *(void *)(a1 + 88);
      if (v76)
      {
        (*(void (**)(long long *__return_ptr))(*(void *)v76 + 224))(&__p);
        sub_10005CD2C((uint64_t)__dst, (char *)__dst[1]);
        long long v77 = (char *)*((void *)&__p + 1);
        *(_OWORD *)long long __dst = __p;
        uint64_t v92 = v97;
        if ((void)v97)
        {
          *(void *)(*((void *)&__p + 1) + 16) = &__dst[1];
          *(void *)&long long __p = (char *)&__p + 8;
          *((void *)&__p + 1) = 0;
          *(void *)&long long v97 = 0;
          long long v77 = 0;
        }
        else
        {
          __dst[0] = &__dst[1];
        }
        sub_10005CD2C((uint64_t)&__p, v77);
      }
      sub_10004D2C8(v75);
    }
  }
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long __p = 0u;
  sub_100CD40B4((uint64_t)&buf, (void *)(a1 + 56), (os_log_t *)(a1 + 48), (const std::string **)(a1 + 712), (uint64_t)__dst, (uint64_t)&v93, (uint64_t)&__p);
  if (*(void *)(a3 + 24))
  {
    sub_100CCC8C8((uint64_t *)&__p, &v82);
    uint64_t v78 = *(void *)(a3 + 24);
    if (!v78) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, const void **))(*(void *)v78 + 48))(v78, &v82);
    sub_100057D78(&v82);
  }
  if (SHIBYTE(v98) < 0) {
    operator delete(*((void **)&v97 + 1));
  }
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  sub_10005CD2C((uint64_t)__dst, (char *)__dst[1]);
  sub_10010E37C((uint64_t)&v93, *((void **)&v93 + 1));
  sub_100330068((uint64_t)&v109, *((void **)&v109 + 1));
  if (SHIBYTE(v108) < 0) {
    operator delete(*((void **)&v107 + 1));
  }
  if ((_BYTE)v107 && SHIBYTE(v106) < 0) {
    operator delete(*((void **)&v105 + 1));
  }
  sub_1000886C0((uint64_t)&v104, *((char **)&v104 + 1));
  *(void *)&long long __p = (char *)&v102 + 8;
  sub_10008A88C((void ***)&__p);
  *(void *)&long long __p = &buf;
  sub_1000C56F4((void ***)&__p);
  sub_100330068((uint64_t)&v88, v89);
}

void sub_1011BAEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47)
{
  a47 = &a32;
  sub_100047F64((void ***)&a47);
  sub_100330068((uint64_t)&a26, (void *)a27);
  sub_10005CD2C((uint64_t)&a23, (char *)a24);
  _Unwind_Resume(a1);
}

void **sub_1011BB094(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v5 = a2 + 536;
  __n128 result = (void **)sub_10010E128(a2 + 536, a3);
  if (result)
  {
    __n128 result = (void **)sub_10005DDEC(v5, a3);
    if (*((char *)result + 23) < 0)
    {
      uint64_t v8 = *result;
      unint64_t v9 = (unint64_t)result[1];
      return (void **)sub_10004FC84((unsigned char *)a1, v8, v9);
    }
    else
    {
      long long v7 = *(_OWORD *)result;
      *(void *)(a1 + 16) = result[2];
      *(_OWORD *)a1 = v7;
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  return result;
}

void sub_1011BB12C(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *a2;
  if (*a2)
  {
    uint64_t v7 = a2[1];
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = (std::__shared_weak_count *)a1[55];
    a1[54] = v6;
    a1[55] = v7;
    if (v8)
    {
      sub_10004D2C8(v8);
      uint64_t v6 = a1[54];
    }
    sub_100058DB0(buf, "kTransferPlanListReq");
    __int16 v24 = 0;
    long long v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = &v24;
    uint64_t v28 = 0;
    __int16 v24 = (char *)operator new(0x18uLL);
    long long v25 = v24;
    uint64_t v26 = v24 + 24;
    long long v25 = sub_1000D8A18((uint64_t)&v26, (long long *)buf, &v35, v24);
    unint64_t v9 = (std::__shared_weak_count *)a1[3];
    if (!v9 || (uint64_t v10 = a1[2], (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
      sub_100088B9C();
    }
    char v12 = v11;
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    long long v32 = 0;
    uint64_t v13 = operator new(0x20uLL);
    *uint64_t v13 = off_101A9C418;
    v13[1] = a1;
    v13[2] = v10;
    v13[3] = v12;
    long long v32 = v13;
    (*(void (**)(uint64_t, char **, void *))(*(void *)v6 + 32))(v6, &v24, v31);
    sub_10010E0A4(v31);
    uint64_t v27 = &v24;
    sub_100047F64((void ***)&v27);
    if (v34 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v14 = a1[54];
    sub_100058DB0(buf, "kTransferPlanTransferReq");
    char v21 = 0;
    xpc_object_t v22 = 0;
    long long v23 = 0;
    uint64_t v27 = &v21;
    uint64_t v28 = 0;
    char v21 = (char *)operator new(0x18uLL);
    xpc_object_t v22 = v21;
    long long v23 = v21 + 24;
    xpc_object_t v22 = sub_1000D8A18((uint64_t)&v23, (long long *)buf, &v35, v21);
    std::string::size_type v15 = (std::__shared_weak_count *)a1[3];
    if (!v15 || (uint64_t v16 = a1[2], (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
      sub_100088B9C();
    }
    int v18 = v17;
    atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
    uint64_t v30 = 0;
    uint64_t v19 = operator new(0x20uLL);
    void *v19 = off_101A9C518;
    v19[1] = a1;
    _DWORD v19[2] = v16;
    v19[3] = v18;
    uint64_t v30 = v19;
    (*(void (**)(uint64_t, char **, void *))(*(void *)v14 + 32))(v14, &v21, v29);
    sub_10010E0A4(v29);
    uint64_t v27 = &v21;
    sub_100047F64((void ***)&v27);
    if (v34 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10024924C(a4, 0);
  }
  else
  {
    sub_10024924C(a4, 6);
    uint64_t v20 = a1[6];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid message session handler", buf, 2u);
    }
  }
}

void sub_1011BB43C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
}

uint64_t sub_1011BB4E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "unexpected call", v6, 2u);
  }
  return sub_10024924C(a3, 5);
}

void sub_1011BB560(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[55];
  a1[54] = 0;
  a1[55] = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_1011BB5A8(a1, 0);
}

void sub_1011BB5A8(void *a1, int a2)
{
  if (a1[54]) {
    BOOL v2 = a2 == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    uint64_t v4 = a1[96];
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      uint64_t v5 = (std::__shared_weak_count *)a1[97];
      *((_OWORD *)a1 + 48) = 0u;
      if (v5)
      {
        sub_10004D2C8(v5);
      }
    }
  }
}

const void **sub_1011BB634(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "unexpected call", buf, 2u);
  }
  uint64_t v5 = 0;
  sub_10031F910(a2, (uint64_t)&v5, 17);
  return sub_100044D00(&v5);
}

void sub_1011BB6B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011BB6CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "unexpected call", v6, 2u);
  }
  return sub_1000607A8(a3, 0);
}

uint64_t sub_1011BB740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "unexpected call", v8, 2u);
  }
  return sub_1002EB2F8(a5, 0, 5);
}

uint64_t sub_1011BB7B8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v3, 2u);
  }
  return 0;
}

uint64_t sub_1011BB820(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v3, 2u);
  }
  return 0;
}

void sub_1011BB888(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011BB8EC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011BB950(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011BB9B4(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 24);
  if (v4 != 7)
  {
    if (v4 != 1) {
      return;
    }
    if (*(void *)(a1 + 360))
    {
      uint64_t v5 = *(void *)(a1 + 336);
      if (v5 != a1 + 352)
      {
        uint64_t v6 = (uint64_t *)(v5 + 32);
        uint64_t v7 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
          BOOL v9 = (v8 & 0x80u) != 0;
          if ((v8 & 0x80u) != 0) {
            uint64_t v8 = *(void *)(a2 + 8);
          }
          if (v9) {
            uint64_t v10 = *(const char **)a2;
          }
          else {
            uint64_t v10 = (const char *)a2;
          }
          if (v8) {
            BOOL v11 = v10;
          }
          else {
            BOOL v11 = "<invalid>";
          }
          uint64_t v12 = v5 + 32;
          if (*(char *)(v5 + 55) < 0) {
            uint64_t v12 = *v6;
          }
          uint64_t v13 = (void *)(a1 + 400);
          if (*(char *)(a1 + 423) < 0) {
            uint64_t v13 = (void *)*v13;
          }
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v11;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v12;
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v26 = v13;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Personality is ready - [%s] - current Iccid: [%s], awaiting.iccid:[%s]", buf, 0x20u);
        }
        uint64_t v14 = (void **)(a1 + 400);
        if (*(char *)(a1 + 423) < 0)
        {
          unint64_t v20 = *(void *)(a1 + 408);
          if (!v20) {
            goto LABEL_55;
          }
          sub_10004FC84(buf, *v14, v20);
        }
        else
        {
          if (!*(unsigned char *)(a1 + 423)) {
            goto LABEL_55;
          }
          *(_OWORD *)long long buf = *(_OWORD *)v14;
          *(void *)&uint8_t buf[16] = *(void *)(a1 + 416);
        }
        BOOL v21 = sub_10001D294((unsigned __int8 *)a2, buf);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (v21)
        {
          if (*(char *)(a1 + 423) < 0)
          {
            **(unsigned char **)(a1 + 400) = 0;
            *(void *)(a1 + 408) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 400) = 0;
            *(unsigned char *)(a1 + 423) = 0;
          }
        }
LABEL_55:
        if (*(char *)(v5 + 55) < 0)
        {
          sub_10004FC84(buf, *(void **)(v5 + 32), *(void *)(v5 + 40));
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)v6;
          *(void *)&uint8_t buf[16] = *(void *)(v5 + 48);
        }
        if (sub_10001D294((unsigned __int8 *)a2, buf))
        {
          BOOL v24 = sub_1011BBD88(v5 + 32, a1 + 168);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          if (v24)
          {
LABEL_62:
            sub_1011BBE34(a1);
            return;
          }
          return;
        }
LABEL_63:
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        return;
      }
    }
    uint64_t v17 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      int v18 = (const char *)a2;
    }
    else {
      int v18 = *(const char **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I no ongoing transfer plan for iccid: %s", buf, 0xCu);
    return;
  }
  if (!*(void *)(a1 + 360) || (uint64_t v15 = *(void *)(a1 + 336), v15 == a1 + 352))
  {
    uint64_t v17 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v19 = (const char *)a2;
    }
    else {
      uint64_t v19 = *(const char **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v19;
    goto LABEL_36;
  }
  uint64_t v16 = (_OWORD *)(v15 + 32);
  if (*(char *)(v15 + 55) < 0)
  {
    sub_10004FC84(buf, *(void **)(v15 + 32), *(void *)(v15 + 40));
  }
  else
  {
    *(_OWORD *)long long buf = *v16;
    *(void *)&uint8_t buf[16] = *(void *)(v15 + 48);
  }
  if (!sub_10001D294((unsigned __int8 *)a2, buf)) {
    goto LABEL_63;
  }
  int v22 = *(unsigned __int8 *)(*(void *)(a1 + 336) + 62);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  if (v22 == 1)
  {
    *(void *)long long buf = v15 + 32;
    *((_DWORD *)sub_10030B10C((uint64_t **)(a1 + 168), (void **)(v15 + 32), (uint64_t)&unk_10144E20E, (long long **)buf)
    + 14) = 1;
    long long v23 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v15 + 55) < 0) {
        uint64_t v16 = *(_OWORD **)v16;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v16;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I DONOT allow expired plan transfer [%s]", buf, 0xCu);
    }
    goto LABEL_62;
  }
}

BOOL sub_1011BBD88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a1 + 8);
  }
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (void **)(a2 + 8);
  int v4 = *(void **)(a2 + 8);
  if (!v4) {
    return 0;
  }
  uint64_t v6 = (void **)(a2 + 8);
  do
  {
    char v7 = sub_100046FE8(v4 + 4, (void **)a1);
    if (v7 >= 0) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = v4 + 1;
    }
    if (v7 >= 0) {
      uint64_t v6 = (void **)v4;
    }
    int v4 = (void *)*v8;
  }
  while (*v8);
  return v6 != v3 && (sub_100046FE8((void *)a1, v6 + 4) & 0x80) == 0 && ((*((_DWORD *)v6 + 14) - 1) & 0xFFFFFFFA) == 0;
}

void sub_1011BBE34(uint64_t a1)
{
  uint64_t v2 = a1 + 352;
  uint64_t v3 = *(void *)(a1 + 336);
  if (v3 == a1 + 352)
  {
    if (*(void *)(a1 + 392)) {
      sub_1000607A8(a1 + 368, 1);
    }
    uint64_t v8 = (void **)(a1 + 216);
    uint64_t v98 = 0;
    uint64_t v99 = 0;
    memset(buf, 0, sizeof(buf));
    long long v93 = 0u;
    memset(v94, 0, sizeof(v94));
    long long v95 = 0u;
    long long v96 = 0u;
    long long v97 = &v98;
    memset(&v100[3], 0, 32);
    int v101 = 0;
    if (*(char *)(a1 + 239) < 0) {
      operator delete(*v8);
    }
    *(_OWORD *)uint64_t v8 = *(_OWORD *)buf;
    *(void *)(a1 + 232) = *(void *)&buf[16];
    uint8_t buf[23] = 0;
    buf[0] = 0;
    BOOL v9 = (void **)(a1 + 240);
    if (*(char *)(a1 + 263) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)BOOL v9 = *(_OWORD *)&buf[24];
    *(void *)(a1 + 256) = *(void *)&buf[40];
    buf[47] = 0;
    unsigned char buf[24] = 0;
    uint64_t v10 = (void **)(a1 + 264);
    if (*(char *)(a1 + 287) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)uint64_t v10 = v93;
    *(void *)(a1 + 280) = *(void *)&v94[0];
    BYTE7(v94[0]) = 0;
    LOBYTE(v93) = 0;
    sub_1003DB434((void **)(a1 + 288));
    *(_OWORD *)(a1 + 288) = *(_OWORD *)((char *)v94 + 8);
    *(void *)(a1 + 304) = *((void *)&v94[1] + 1);
    memset((char *)v94 + 8, 0, 24);
    sub_1003DBB30((void **)(a1 + 312));
    *(_OWORD *)(a1 + 312) = v95;
    long long v11 = v96;
    *(void *)&long long v96 = 0;
    long long v95 = 0uLL;
    *(_OWORD *)(a1 + 328) = v11;
    sub_1011C7BD8(*(void **)(a1 + 352));
    uint64_t v12 = v98;
    *(void *)(a1 + 344) = v97;
    *(void *)(a1 + 352) = v12;
    uint64_t v13 = v99;
    *(void *)(a1 + 360) = v99;
    if (v13)
    {
      *(void *)(v12 + 16) = v2;
      long long v97 = &v98;
      uint64_t v98 = 0;
      uint64_t v99 = 0;
    }
    else
    {
      *(void *)(a1 + 344) = v2;
    }
    sub_100555EB4((void *)(a1 + 368), (uint64_t)v100);
    long long v35 = (void **)(a1 + 400);
    if (*(char *)(a1 + 423) < 0) {
      operator delete(*v35);
    }
    *(_OWORD *)long long v35 = *(_OWORD *)&v100[4];
    *(void *)(a1 + 416) = v100[6];
    HIBYTE(v100[6]) = 0;
    LOBYTE(v100[4]) = 0;
    *(_DWORD *)(a1 + 424) = v101;
    sub_1011C7B3C((uint64_t)buf);
    *(void *)(a1 + 336) = v2;
    sub_1011BB5A8((void *)a1, 0);
    return;
  }
  int v4 = (const void **)(v3 + 32);
  unint64_t v5 = sub_100CCD974((unsigned __int8 **)(v3 + 32), (uint64_t *)(a1 + 608));
  int v6 = v5;
  int v79 = v5;
  if ((v5 & 0xFF00000000) != 0)
  {
    char v7 = &v79;
  }
  else
  {
    char v7 = (int *)(v3 + 56);
    int v6 = *(_DWORD *)(v3 + 56);
  }
  for (uint64_t i = *(void *)(a1 + 584); ; i += 88)
  {
    if (i == *(void *)(a1 + 592))
    {
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      goto LABEL_21;
    }
    if (*(_DWORD *)(i + 4) == v6) {
      break;
    }
  }
  uint64_t v15 = *(void *)(i + 16);
  uint64_t v16 = *(void *)(i + 24);
LABEL_21:
  uint64_t v17 = *(NSObject **)(a1 + 48);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  uint64_t v19 = v3;
  if (v18)
  {
    unint64_t v20 = (const void *)(v3 + 32);
    if (*(char *)(v3 + 55) < 0) {
      unint64_t v20 = *v4;
    }
    uint64_t v21 = subscriber::asString();
    unint64_t v22 = *(char *)(v3 + 62);
    if (v22 > 4) {
      long long v23 = "???";
    }
    else {
      long long v23 = off_101A9D0A8[v22];
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v21;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v23;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Iccid: [%s], Slot: [%s], State: [%s]", buf, 0x20u);
    uint64_t v19 = *(void *)(a1 + 336);
  }
  int v24 = *(unsigned __int8 *)(v19 + 61);
  if (v24 != 1) {
    goto LABEL_66;
  }
  (***(void (****)(long long *__return_ptr))(a1 + 56))(&v80);
  long long v25 = (std::__shared_weak_count *)*((void *)&v80 + 1);
  *(_OWORD *)long long buf = v80;
  long long v80 = 0uLL;
  uint64_t v26 = *(void *)(a1 + 608);
  uint64_t v27 = *(void *)(a1 + 616);
  if (v26 == v27)
  {
    int v34 = 0;
    if (v25) {
      goto LABEL_58;
    }
    goto LABEL_59;
  }
  while (1)
  {
    if (!subscriber::isValidSimSlot() || !subscriber::isSimReady()) {
      goto LABEL_48;
    }
    uint64_t v28 = *(unsigned __int8 *)(v3 + 55);
    if ((v28 & 0x80u) == 0) {
      uint64_t v29 = *(unsigned __int8 *)(v3 + 55);
    }
    else {
      uint64_t v29 = *(void *)(v3 + 40);
    }
    uint64_t v30 = *(unsigned __int8 *)(v26 + 95);
    int v31 = (char)v30;
    if ((v30 & 0x80u) != 0) {
      uint64_t v30 = *(void *)(v26 + 80);
    }
    if (v29 != v30) {
      goto LABEL_48;
    }
    long long v32 = v31 >= 0 ? (unsigned __int8 *)(v26 + 72) : *(unsigned __int8 **)(v26 + 72);
    if ((v28 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v3 + 55)) {
      goto LABEL_56;
    }
    long long v33 = (unsigned __int8 *)(v3 + 32);
    while (*v33 == *v32)
    {
      ++v33;
      ++v32;
      if (!--v28) {
        goto LABEL_56;
      }
    }
LABEL_48:
    v26 += 168;
    if (v26 == v27)
    {
      int v34 = 0;
      goto LABEL_57;
    }
  }
  if (memcmp(*v4, v32, *(void *)(v3 + 40))) {
    goto LABEL_48;
  }
LABEL_56:
  int v34 = sub_1011C15B8(a1, *v7) ^ 1;
LABEL_57:
  long long v25 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]) {
LABEL_58:
  }
    sub_10004D2C8(v25);
LABEL_59:
  if (*((void *)&v80 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v80 + 1));
  }
  if (v34)
  {
    long long v36 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      LOBYTE(v24) = 2;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I secure intent not supported, retrieve token instead", buf, 2u);
    }
    else
    {
      LOBYTE(v24) = 2;
    }
  }
  else
  {
    LOBYTE(v24) = 1;
  }
LABEL_66:
  switch(*(unsigned char *)(v3 + 62))
  {
    case 0:
      *(unsigned char *)(v3 + 62) = 1;
      (***(void (****)(long long *__return_ptr))(a1 + 56))(&v80);
      *(_OWORD *)long long buf = v80;
      long long v80 = 0uLL;
      uint64_t v37 = *(void *)(a1 + 608);
      uint64_t v38 = *(void *)(a1 + 616);
      while (2)
      {
        if (v37 == v38)
        {
          int v50 = 0;
        }
        else
        {
          if (!subscriber::isValidSimSlot() || !subscriber::isSimReady()) {
            goto LABEL_87;
          }
          uint64_t v39 = *(unsigned __int8 *)(v3 + 55);
          if ((v39 & 0x80u) == 0) {
            uint64_t v40 = *(unsigned __int8 *)(v3 + 55);
          }
          else {
            uint64_t v40 = *(void *)(v3 + 40);
          }
          uint64_t v41 = *(unsigned __int8 *)(v37 + 95);
          int v42 = (char)v41;
          if ((v41 & 0x80u) != 0) {
            uint64_t v41 = *(void *)(v37 + 80);
          }
          if (v40 != v41) {
            goto LABEL_87;
          }
          if (v42 >= 0) {
            long long v43 = (unsigned __int8 *)(v37 + 72);
          }
          else {
            long long v43 = *(unsigned __int8 **)(v37 + 72);
          }
          if ((v39 & 0x80) != 0)
          {
            if (memcmp(*v4, v43, *(void *)(v3 + 40))) {
              goto LABEL_87;
            }
          }
          else if (*(unsigned char *)(v3 + 55))
          {
            uint64_t v44 = (unsigned __int8 *)(v3 + 32);
            while (*v44 == *v43)
            {
              ++v44;
              ++v43;
              if (!--v39) {
                goto LABEL_107;
              }
            }
LABEL_87:
            v37 += 168;
            continue;
          }
LABEL_107:
          int v50 = 1;
        }
        break;
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (*((void *)&v80 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v80 + 1));
      }
      if (v50)
      {
        char v51 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          long long v52 = (const void *)(v3 + 32);
          if (*(char *)(v3 + 55) < 0) {
            long long v52 = *v4;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v52;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I transfer active SIM plan : %s", buf, 0xCu);
        }
        *(void *)long long buf = v3 + 32;
        sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(v3 + 32), (long long **)buf)[112] = 1;
        if (*(char *)(a1 + 423) < 0)
        {
          **(unsigned char **)(a1 + 400) = 0;
          *(void *)(a1 + 408) = 0;
        }
        else
        {
          *(unsigned char *)(a1 + 400) = 0;
          *(unsigned char *)(a1 + 423) = 0;
        }
        goto LABEL_160;
      }
      *(void *)long long buf = v3 + 32;
      sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(v3 + 32), (long long **)buf)[112] = 0;
      int v53 = *(std::__shared_weak_count **)(a1 + 80);
      if (!v53)
      {
        int v54 = 0;
        goto LABEL_162;
      }
      int v54 = std::__shared_weak_count::lock(v53);
      if (!v54 || (uint64_t v55 = *(void *)(a1 + 72)) == 0)
      {
LABEL_162:
        int64_t v72 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "invalid delegate", buf, 2u);
        }
        goto LABEL_164;
      }
      uint64_t v56 = *(unsigned __int8 *)(v3 + 55);
      if ((v56 & 0x80u) != 0) {
        uint64_t v56 = *(void *)(v3 + 40);
      }
      if (!v56)
      {
        char v73 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "invalid iccid to enable", buf, 2u);
        }
        goto LABEL_165;
      }
      (***(void (****)(long long *__return_ptr))(a1 + 56))(&v80);
      int v57 = (std::__shared_weak_count *)*((void *)&v80 + 1);
      *(_OWORD *)long long buf = v80;
      long long v80 = 0uLL;
      uint64_t v58 = *(void *)(a1 + 608);
      uint64_t v59 = *(void *)(a1 + 616);
      if (v58 == v59)
      {
        int v66 = 0;
        goto LABEL_173;
      }
      while (2)
      {
        if (!subscriber::isValidSimSlot() || !subscriber::isSimReady()) {
          goto LABEL_144;
        }
        uint64_t v60 = *(unsigned __int8 *)(v3 + 55);
        if ((v60 & 0x80u) == 0) {
          uint64_t v61 = *(unsigned __int8 *)(v3 + 55);
        }
        else {
          uint64_t v61 = *(void *)(v3 + 40);
        }
        uint64_t v62 = *(unsigned __int8 *)(v58 + 95);
        int v63 = (char)v62;
        if ((v62 & 0x80u) != 0) {
          uint64_t v62 = *(void *)(v58 + 80);
        }
        if (v61 != v62) {
          goto LABEL_144;
        }
        if (v63 >= 0) {
          char v64 = (unsigned __int8 *)(v58 + 72);
        }
        else {
          char v64 = *(unsigned __int8 **)(v58 + 72);
        }
        if ((v60 & 0x80) == 0)
        {
          if (!*(unsigned char *)(v3 + 55)) {
            break;
          }
          char v65 = (unsigned __int8 *)(v3 + 32);
          while (*v65 == *v64)
          {
            ++v65;
            ++v64;
            if (!--v60) {
              goto LABEL_171;
            }
          }
          goto LABEL_144;
        }
        if (memcmp(*v4, v64, *(void *)(v3 + 40)))
        {
LABEL_144:
          v58 += 168;
          if (v58 == v59)
          {
            int v66 = 0;
            goto LABEL_172;
          }
          continue;
        }
        break;
      }
LABEL_171:
      int v66 = 1;
LABEL_172:
      int v57 = *(std::__shared_weak_count **)&buf[8];
LABEL_173:
      if (v57) {
        sub_10004D2C8(v57);
      }
      if (*((void *)&v80 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v80 + 1));
      }
      if (v66)
      {
        long long v74 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(v3 + 55) >= 0) {
            uint64_t v75 = v3 + 32;
          }
          else {
            uint64_t v75 = *(void *)(v3 + 32);
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v75;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I plan [%s] already enabled", buf, 0xCu);
        }
      }
      else
      {
        std::string::operator=((std::string *)(a1 + 400), (const std::string *)(v3 + 32));
        std::string::operator=((std::string *)(a1 + 728), (const std::string *)(v3 + 32));
        if (*(char *)(v3 + 55) < 0)
        {
          sub_10004FC84(buf, *(void **)(v3 + 32), *(void *)(v3 + 40));
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)v4;
          *(void *)&uint8_t buf[16] = *(void *)(v3 + 48);
        }
        (*(void (**)(uint64_t, uint8_t *, uint64_t))(*(void *)v55 + 160))(v55, buf, 1);
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
      }
LABEL_164:
      if (v54) {
LABEL_165:
      }
        sub_10004D2C8(v54);
      return;
    case 1:
      *(unsigned char *)(*(void *)(a1 + 336) + 62) = 2;
      if ((v24 & 1) == 0) {
        goto LABEL_160;
      }
      if (*(char *)(v3 + 55) < 0)
      {
        sub_10004FC84(&v89, *(void **)(v3 + 32), *(void *)(v3 + 40));
        int v67 = *(char *)(v3 + 55);
        char v91 = 1;
        *(void *)uint64_t v76 = a1;
        *(_DWORD *)&v76[8] = *v7;
        v76[12] = v24;
        if (v67 < 0)
        {
          sub_10004FC84(&__p, *(void **)(v3 + 32), *(void *)(v3 + 40));
LABEL_148:
          uint64_t v87 = 0;
          uint64_t v68 = operator new(0x30uLL);
          *uint64_t v68 = off_101A9C918;
          v68[1] = *(void *)v76;
          *(void *)((char *)v68 + 13) = *(void *)&v76[5];
          unsigned int v69 = v68 + 3;
          if (SHIBYTE(v78) < 0)
          {
            sub_10004FC84(v69, (void *)__p, *((unint64_t *)&__p + 1));
          }
          else
          {
            long long v70 = __p;
            v68[5] = v78;
            *(_OWORD *)unsigned int v69 = v70;
          }
          uint64_t v87 = v68;
          sub_1011C18B4(a1, v15, v16, (uint64_t)v88, v86);
          sub_100313814(v86);
          if (SHIBYTE(v78) < 0) {
            operator delete((void *)__p);
          }
          if (SHIBYTE(v90) < 0)
          {
            uint64_t v71 = (void *)v89;
            goto LABEL_158;
          }
          return;
        }
      }
      else
      {
        long long v89 = *(_OWORD *)v4;
        uint64_t v90 = *(void *)(v3 + 48);
        char v91 = 1;
        *(void *)uint64_t v76 = a1;
        *(_DWORD *)&v76[8] = *v7;
        v76[12] = v24;
      }
      long long __p = *(_OWORD *)v4;
      uint64_t v78 = *(void *)(v3 + 48);
      goto LABEL_148;
    case 2:
      *(unsigned char *)(*(void *)(a1 + 336) + 62) = 3;
      if ((v24 & 2) == 0) {
        goto LABEL_160;
      }
      if (*(char *)(v3 + 55) < 0)
      {
        sub_10004FC84(&v83, *(void **)(v3 + 32), *(void *)(v3 + 40));
      }
      else
      {
        long long v83 = *(_OWORD *)v4;
        uint64_t v84 = *(void *)(v3 + 48);
      }
      char v85 = 1;
      v81[0] = off_101A9CAD8;
      v81[1] = a1;
      v81[3] = v81;
      sub_1011C26B0(a1, v15, v16, (uint64_t)v82, v81);
      sub_100313814(v81);
      if (SHIBYTE(v84) < 0)
      {
        uint64_t v71 = (void *)v83;
LABEL_158:
        operator delete(v71);
      }
      return;
    case 3:
      uint64_t v45 = *(void **)(a1 + 336);
      *((unsigned char *)v45 + 62) = 4;
      if (v45 != (void *)v2)
      {
        int64_t v46 = (void *)v45[1];
        if (v46)
        {
          do
          {
            xpc_object_t v47 = v46;
            int64_t v46 = (void *)*v46;
          }
          while (v46);
        }
        else
        {
          do
          {
            xpc_object_t v47 = (void *)v45[2];
            BOOL v48 = *v47 == (void)v45;
            uint64_t v45 = v47;
          }
          while (!v48);
        }
        *(void *)(a1 + 336) = v47;
      }
LABEL_160:
      sub_1011BBE34(a1);
      return;
    default:
      xpc_object_t v49 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Unhandled state", buf, 2u);
      }
      return;
  }
}

void sub_1011BCA40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a51 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v51);
  _Unwind_Resume(a1);
}

void sub_1011BCB48(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v5 = (void *)(a1 + 168);
  int v6 = (void *)(a1 + 176);
  uint64_t v7 = *(void *)(a1 + 176);
  unint64_t v20 = *(char ***)(a1 + 168);
  uint64_t v21 = (char *)v7;
  if (*(void *)(a1 + 184))
  {
    *(void *)(v7 + 16) = &v21;
    *unint64_t v5 = v6;
    void *v6 = 0;
    *(void *)(a1 + 184) = 0;
  }
  else
  {
    unint64_t v20 = &v21;
  }
  if (v5 != a3) {
    sub_1011C7F78((uint64_t *)(a1 + 168), (void *)*a3, a3 + 1);
  }
  if (a1 + 192 != a2) {
    sub_100429020((uint64_t **)(a1 + 192), *(long long **)a2, (long long *)(a2 + 8));
  }
  memset(&__s1, 0, sizeof(__s1));
  if (*(void *)(a1 + 360))
  {
    uint64_t v8 = *(void *)(a1 + 336);
    if (v8 != a1 + 352)
    {
      std::string::operator=(&__s1, (const std::string *)(v8 + 32));
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0)
      {
        size_t size = __s1.__r_.__value_.__l.__size_;
        if (!__s1.__r_.__value_.__l.__size_) {
          goto LABEL_39;
        }
      }
      else
      {
        if (!*((unsigned char *)&__s1.__r_.__value_.__s + 23)) {
          goto LABEL_41;
        }
        size_t size = __s1.__r_.__value_.__l.__size_;
      }
      if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v10 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
      }
      else {
        size_t v10 = size;
      }
      uint64_t v11 = *(unsigned __int8 *)(a1 + 423);
      int v12 = (char)v11;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a1 + 408);
      }
      if (v10 == v11)
      {
        if (v12 >= 0) {
          uint64_t v13 = (unsigned __int8 *)(a1 + 400);
        }
        else {
          uint64_t v13 = *(unsigned __int8 **)(a1 + 400);
        }
        if ((*((unsigned char *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          p_s1 = (std::string *)__s1.__r_.__value_.__r.__words[0];
          if (!memcmp(__s1.__r_.__value_.__l.__data_, v13, size))
          {
            uint64_t v15 = *(NSObject **)(a1 + 48);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
LABEL_38:
              *(_DWORD *)long long buf = 136315138;
              int v24 = p_s1;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Transfer: Entitled info becomes ready for %s. waiting personality ready", buf, 0xCu);
            }
            goto LABEL_39;
          }
        }
        else
        {
          uint64_t v14 = 0;
          while (__s1.__r_.__value_.__s.__data_[v14] == v13[v14])
          {
            if (HIBYTE(__s1.__r_.__value_.__r.__words[2]) == ++v14)
            {
              uint64_t v15 = *(NSObject **)(a1 + 48);
              if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_39;
              }
              p_s1 = &__s1;
              goto LABEL_38;
            }
          }
        }
      }
      if (!sub_1011BBD88((uint64_t)&__s1, (uint64_t)&v20) && sub_1011BBD88((uint64_t)&__s1, (uint64_t)v5))
      {
        uint64_t v17 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v18 = &__s1;
          if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            BOOL v18 = (std::string *)__s1.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long buf = 136315138;
          int v24 = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Transfer: Entitled info becomes ready for %s", buf, 0xCu);
        }
        sub_1011BBE34(a1);
      }
LABEL_39:
      if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__s1.__r_.__value_.__l.__data_);
      }
    }
  }
LABEL_41:
  sub_10005CD2C((uint64_t)&v20, v21);
}

void sub_1011BCDD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, char *a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005CD2C((uint64_t)&a15, a16);
  _Unwind_Resume(a1);
}

void sub_1011BCE04(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011BCE6C(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v4 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "unexpected call", v4, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

void sub_1011BCEDC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

BOOL sub_1011BCF40(uint64_t a1)
{
  return *(void *)(a1 + 360) != 0;
}

BOOL sub_1011BCF50(uint64_t a1)
{
  return *(void *)(a1 + 360) != 0;
}

uint64_t sub_1011BCF60(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v3, 2u);
  }
  return 0;
}

void sub_1011BCFC8(void *a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[55];
    a1[54] = 0;
    a1[55] = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
    sub_1011BB5A8(a1, 0);
  }
  else
  {
    unint64_t v5 = a1[6];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = "kUnknown";
      if (a2 == 2) {
        int v6 = "kTarget";
      }
      int v7 = 136315138;
      uint64_t v8 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Source finishTransferSession mismatched end point: %s", (uint8_t *)&v7, 0xCu);
    }
  }
}

uint64_t sub_1011BD0DC(uint64_t a1, void **a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, std::string::size_type a9, char a10)
{
  if (*(void *)(a1 + 360))
  {
    uint64_t v16 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      std::string::size_type v17 = a4 + 16;
      if (*(char *)(a4 + 39) < 0) {
        std::string::size_type v17 = *(void *)(a4 + 16);
      }
      if (*((char *)a2 + 23) >= 0) {
        BOOL v18 = a2;
      }
      else {
        BOOL v18 = *a2;
      }
      if (*(char *)(a7 + 23) >= 0) {
        uint64_t v19 = (const char *)a7;
      }
      else {
        uint64_t v19 = *(const char **)a7;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v17;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      xpc_object_t v81 = v19;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N there is an ongoing request. new token request for (%s), uuid:%{public}s, target imei:%s", (uint8_t *)&buf, 0x20u);
    }
  }
  unint64_t v20 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v21 = a4 + 16;
    if (*(char *)(a4 + 39) < 0) {
      std::string::size_type v21 = *(void *)(a4 + 16);
    }
    if (*(char *)(a9 + 23) >= 0) {
      std::string::size_type v22 = a9;
    }
    else {
      std::string::size_type v22 = *(void *)a9;
    }
    long long v23 = "false";
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
    if (a10) {
      long long v23 = "true";
    }
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v21;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v22;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
    xpc_object_t v81 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I handle transfer request for %s from %s. local conversion: %s", (uint8_t *)&buf, 0x20u);
  }
  sub_1011BB5A8((void *)a1, 1);
  int v24 = *(std::__shared_weak_count **)(a1 + 80);
  if (v24)
  {
    long long v25 = std::__shared_weak_count::lock(v24);
    if (v25)
    {
      int v67 = a3;
      uint64_t v26 = *(void *)(a1 + 72);
      if (v26)
      {
        buf.__r_.__value_.__r.__words[0] = a4 + 16;
        uint64_t v68 = (void **)(a4 + 16);
        *((unsigned char *)sub_1000ED870((uint64_t **)(a1 + 560), (void **)(a4 + 16), (uint64_t)&unk_10144E20E, (long long **)&buf)
        + 56) = a10;
        int v66 = a6;
        if (a10)
        {
          memset(&buf, 0, sizeof(buf));
          LODWORD(v81) = 0;
          sub_100058DB0(&v82, "local");
          *(_WORD *)uint64_t v84 = 257;
          *(void *)&v84[2] = 0;
          int v27 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 208))(v26);
          int v28 = *(unsigned __int8 *)(a1 + 872);
          if (v28 == 2)
          {
            if (v27) {
              LOBYTE(v28) = 3;
            }
          }
          else if (*(unsigned char *)(a1 + 872))
          {
            LOBYTE(v28) = 1;
          }
          else if (v27)
          {
            LOBYTE(v28) = 3;
          }
          else
          {
            LOBYTE(v28) = 0;
          }
          v84[10] = v28;
          __p.n128_u8[0] = 0;
          char v87 = 0;
          *(void *)&v88[0] = CFAbsoluteTimeGetCurrent();
          memset((char *)v88 + 8, 0, 128);
          uint64_t v71 = (long long *)(a4 + 16);
          uint64_t v40 = sub_1011C81F0((uint64_t **)(a1 + 784), v68, &v71);
          uint64_t v41 = (void **)(v40 + 56);
          if (v40[79] < 0) {
            operator delete(*v41);
          }
          *(_OWORD *)uint64_t v41 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *((void *)v40 + 9) = *((void *)&buf.__r_.__value_.__l + 2);
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
          buf.__r_.__value_.__s.__data_[0] = 0;
          *((_DWORD *)v40 + 20) = v81;
          int v42 = (void **)(v40 + 88);
          if (v40[111] < 0) {
            operator delete(*v42);
          }
          *(_OWORD *)int v42 = v82;
          *((void *)v40 + 13) = v83;
          HIBYTE(v83) = 0;
          LOBYTE(v82) = 0;
          *((void *)v40 + 14) = *(void *)v84;
          *(_DWORD *)(v40 + 119) = *(_DWORD *)&v84[7];
          sub_100179CB0((uint64_t)(v40 + 128), &__p);
          long long v44 = v88[7];
          *((_OWORD *)v40 + 16) = v88[6];
          *((_OWORD *)v40 + 17) = v44;
          uint64_t v45 = *(void *)&v88[8];
          long long v47 = v88[4];
          long long v46 = v88[5];
          long long v48 = v88[3];
          *((_OWORD *)v40 + 12) = v88[2];
          *((_OWORD *)v40 + 13) = v48;
          *((void *)v40 + 36) = v45;
          *((_OWORD *)v40 + 14) = v47;
          *((_OWORD *)v40 + 15) = v46;
          long long v49 = v88[1];
          *((_OWORD *)v40 + 10) = v88[0];
          *((_OWORD *)v40 + 11) = v49;
          if (v87 && v86 < 0) {
            operator delete((void *)__p.n128_u64[0]);
          }
          if (SHIBYTE(v83) < 0) {
            operator delete((void *)v82);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          memset(&buf, 0, sizeof(buf));
          if (*(char *)(a4 + 39) < 0)
          {
            long long v43 = (capabilities::ct *)sub_10004FC84(__dst, *(void **)(a4 + 16), *(void *)(a4 + 24));
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)v68;
            uint64_t v79 = *(void *)(a4 + 32);
          }
          char v50 = capabilities::ct::supportsHydra(v43);
          sub_1011BDB2C(&buf, (unsigned __int8 **)__dst, (uint64_t *)(a1 + 608), (void *)(a1 + 656), v50);
          if (SHIBYTE(v79) < 0) {
            operator delete(__dst[0]);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v76, *a2, (unint64_t)a2[1]);
          }
          else
          {
            *(_OWORD *)uint64_t v76 = *(_OWORD *)a2;
            long long v77 = a2[2];
          }
          if (*(char *)(a4 + 39) < 0)
          {
            sub_10004FC84(v74, *(void **)(a4 + 16), *(void *)(a4 + 24));
          }
          else
          {
            *(_OWORD *)long long v74 = *(_OWORD *)v68;
            uint64_t v75 = *(void *)(a4 + 32);
          }
          uint64_t v51 = *v67;
          uint64_t v52 = v67[1];
          uint64_t v53 = *v66;
          uint64_t v54 = v66[1];
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v73, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
          }
          else {
            std::string v73 = buf;
          }
          sub_1011BDC6C(a1, v76, v74, v51, v52, v53, v54, &v73, 1u, 0);
          if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v73.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v75) < 0) {
            operator delete(v74[0]);
          }
          if (SHIBYTE(v77) < 0) {
            operator delete(v76[0]);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          uint64_t v30 = 1;
        }
        else
        {
          if (*(void *)(a1 + 752)) {
            goto LABEL_46;
          }
          int v31 = *(std::__shared_weak_count **)(a1 + 24);
          if (!v31
            || (uint64_t v32 = *(void *)(a1 + 56),
                uint64_t v33 = *(void *)(a1 + 16),
                (int v34 = std::__shared_weak_count::lock(v31)) == 0))
          {
            sub_100088B9C();
          }
          long long v35 = (long long *)(v33 + 8);
          if (!v33) {
            long long v35 = 0;
          }
          uint64_t v71 = v35;
          int64_t v72 = v34;
          (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t, long long **))(*(void *)v32 + 440))(&buf, v32, a1 + 32, &v71);
          long long v36 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
          uint64_t v37 = *(std::__shared_weak_count **)(a1 + 760);
          *(_OWORD *)(a1 + 752) = v36;
          if (v37)
          {
            sub_10004D2C8(v37);
            if (buf.__r_.__value_.__l.__size_) {
              sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
            }
          }
          if (v72) {
            sub_10004D2C8(v72);
          }
          if (*(void *)(a1 + 752))
          {
LABEL_46:
            memset(&buf, 0, sizeof(buf));
            LODWORD(v81) = 0;
            sub_100058DB0(&v82, "iCloud");
            v84[0] = 1;
            *(void *)&v84[1] = 0;
            v84[9] = 0;
            int v38 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 208))(v26);
            int v39 = *(unsigned __int8 *)(a1 + 872);
            if (v39 == 2)
            {
              if (v38) {
                LOBYTE(v39) = 3;
              }
            }
            else if (*(unsigned char *)(a1 + 872))
            {
              LOBYTE(v39) = 1;
            }
            else if (v38)
            {
              LOBYTE(v39) = 3;
            }
            else
            {
              LOBYTE(v39) = 0;
            }
            v84[10] = v39;
            __p.n128_u8[0] = 0;
            char v87 = 0;
            *(void *)&v88[0] = CFAbsoluteTimeGetCurrent();
            memset((char *)v88 + 8, 0, 96);
            *(_OWORD *)((char *)&v88[6] + 8) = COERCE_UNSIGNED_INT64(CFAbsoluteTimeGetCurrent());
            *(_OWORD *)((char *)&v88[7] + 8) = 0uLL;
            uint64_t v71 = (long long *)(a4 + 16);
            uint64_t v55 = sub_1011C81F0((uint64_t **)(a1 + 784), v68, &v71);
            uint64_t v56 = (void **)(v55 + 56);
            if (v55[79] < 0) {
              operator delete(*v56);
            }
            *(_OWORD *)uint64_t v56 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
            *((void *)v55 + 9) = *((void *)&buf.__r_.__value_.__l + 2);
            *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
            buf.__r_.__value_.__s.__data_[0] = 0;
            *((_DWORD *)v55 + 20) = v81;
            int v57 = (void **)(v55 + 88);
            if (v55[111] < 0) {
              operator delete(*v57);
            }
            *(_OWORD *)int v57 = v82;
            *((void *)v55 + 13) = v83;
            HIBYTE(v83) = 0;
            LOBYTE(v82) = 0;
            *((void *)v55 + 14) = *(void *)v84;
            *(_DWORD *)(v55 + 119) = *(_DWORD *)&v84[7];
            sub_100179CB0((uint64_t)(v55 + 128), &__p);
            long long v58 = v88[7];
            *((_OWORD *)v55 + 16) = v88[6];
            *((_OWORD *)v55 + 17) = v58;
            uint64_t v59 = *(void *)&v88[8];
            long long v61 = v88[4];
            long long v60 = v88[5];
            long long v62 = v88[3];
            *((_OWORD *)v55 + 12) = v88[2];
            *((_OWORD *)v55 + 13) = v62;
            *((void *)v55 + 36) = v59;
            *((_OWORD *)v55 + 14) = v61;
            *((_OWORD *)v55 + 15) = v60;
            long long v63 = v88[1];
            *((_OWORD *)v55 + 10) = v88[0];
            *((_OWORD *)v55 + 11) = v63;
            if (v87 && v86 < 0) {
              operator delete((void *)__p.n128_u64[0]);
            }
            if (SHIBYTE(v83) < 0) {
              operator delete((void *)v82);
            }
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            uint64_t v64 = *(void *)(a1 + 752);
            sub_1011BEAD4(&buf, a1, (uint64_t)v68);
            uint64_t v30 = (*(uint64_t (**)(uint64_t, void **, uint64_t *, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, std::string::size_type, char, std::string *))(*(void *)v64 + 16))(v64, a2, v67, a4, a5, v66, a7, a8, a9, 1, &buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
          else
          {
            uint64_t v30 = 0;
          }
        }
LABEL_107:
        sub_10004D2C8(v25);
        return v30;
      }
    }
  }
  else
  {
    long long v25 = 0;
  }
  uint64_t v29 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "invalid delegate", (uint8_t *)&buf, 2u);
  }
  uint64_t v30 = 0;
  if (v25) {
    goto LABEL_107;
  }
  return v30;
}

void sub_1011BD988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  sub_10004D2C8(v48);
  _Unwind_Resume(a1);
}

uint64_t sub_1011BDAD0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96) && *(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

std::string *sub_1011BDB2C(std::string *a1, unsigned __int8 **a2, uint64_t *a3, void *a4, char a5)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  __n128 result = (std::string *)sub_100CCD974(a2, a3);
  unint64_t v9 = a4[2];
  if (v9 < 2)
  {
    if (v9 == 1) {
      return std::string::operator=(a1, (const std::string *)(*a4 + 40));
    }
  }
  else if (((unint64_t)result & 0xFF00000000) != 0)
  {
    int v12 = (void *)*a4;
    uint64_t v11 = a4 + 1;
    size_t v10 = v12;
    if (v12 != v11)
    {
      do
      {
        if (*((_DWORD *)v10 + 8) == result)
        {
          if (a5) {
            return std::string::operator=(a1, (const std::string *)(v10 + 5));
          }
        }
        else if ((a5 & 1) == 0)
        {
          return std::string::operator=(a1, (const std::string *)(v10 + 5));
        }
        uint64_t v13 = (void *)v10[1];
        if (v13)
        {
          do
          {
            uint64_t v14 = v13;
            uint64_t v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            uint64_t v14 = (void *)v10[2];
            BOOL v15 = *v14 == (void)v10;
            size_t v10 = v14;
          }
          while (!v15);
        }
        size_t v10 = v14;
      }
      while (v14 != v11);
    }
  }
  else
  {
    BOOL v18 = (void *)a4[1];
    std::string::size_type v17 = a4 + 1;
    uint64_t v16 = v18;
    if (v18)
    {
      do
      {
        size_t v10 = v16;
        uint64_t v16 = (void *)v16[1];
      }
      while (v16);
    }
    else
    {
      do
      {
        size_t v10 = (void *)v17[2];
        BOOL v15 = *v10 == (void)v17;
        std::string::size_type v17 = v10;
      }
      while (v15);
    }
    return std::string::operator=(a1, (const std::string *)(v10 + 5));
  }
  return result;
}

void sub_1011BDC48(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011BDC6C(uint64_t a1, void **a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const std::string *a8, unsigned __int8 a9, char a10)
{
  *(void *)&long long v137 = a6;
  *((void *)&v137 + 1) = a7;
  *(void *)&long long v49 = a4;
  *((void *)&v49 + 1) = a5;
  *(void *)(a1 + 808) = a4;
  *(void *)(a1 + 816) = a5;
  uint64_t v13 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (a9 - 2 > 2) {
      uint64_t v14 = "kAccepted";
    }
    else {
      uint64_t v14 = off_101A9D0D0[(char)(a9 - 2)];
    }
    BOOL v15 = a8;
    uint64_t v16 = a3;
    if (*((char *)a3 + 23) < 0) {
      uint64_t v16 = *a3;
    }
    std::string::size_type v17 = a2;
    if (*((char *)a2 + 23) < 0) {
      std::string::size_type v17 = *a2;
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v16;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = v17;
    LOWORD(v99) = 2080;
    *(void *)((char *)&v99 + 2) = asString();
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I transfer consent update. state:%s, iccid:%s, uuid:%s, error:%s", buf, 0x2Au);
    a8 = v15;
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(void *)std::string buf = a3;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), a3, (long long **)buf) + 34) = Current;
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 80);
  if (v19)
  {
    unint64_t v20 = std::__shared_weak_count::lock(v19);
    if (v20)
    {
      uint64_t v21 = *(void *)(a1 + 72);
      if (v21)
      {
        if (a10)
        {
          *(void *)std::string buf = a3;
          *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), a3, (long long **)buf) + 20) = 70034;
          *(void *)&long long v127 = v21;
          *((void *)&v127 + 1) = v20;
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v128, *a2, (unint64_t)a2[1]);
          }
          else
          {
            long long v128 = *(_OWORD *)a2;
            std::string::size_type v129 = a2[2];
          }
          if (*((char *)a3 + 23) < 0)
          {
            sub_10004FC84(&__p, *a3, (unint64_t)a3[1]);
          }
          else
          {
            long long __p = *(_OWORD *)a3;
            uint64_t v131 = a3[2];
          }
          long long v132 = v49;
          long long v133 = v137;
          char v134 = a10;
          v136 = 0;
          int v31 = (char *)operator new(0x70uLL);
          *(void *)int v31 = off_101A9CCD8;
          *(_OWORD *)(v31 + 8) = v127;
          long long v127 = 0uLL;
          *(_OWORD *)(v31 + 24) = v128;
          *((void *)v31 + 5) = v129;
          long long v128 = 0uLL;
          std::string::size_type v129 = 0;
          *((_OWORD *)v31 + 3) = __p;
          *((void *)v31 + 8) = v131;
          long long __p = 0uLL;
          uint64_t v131 = 0;
          long long v32 = v132;
          long long v33 = v133;
          v31[104] = v134;
          *(_OWORD *)(v31 + 88) = v33;
          *(_OWORD *)(v31 + 72) = v32;
          v136 = v31;
          sub_1011C5690(a1, a3, (uint64_t)v135);
          sub_1000DBADC(v135);
          if (SHIBYTE(v131) < 0) {
            operator delete((void *)__p);
          }
          if (SHIBYTE(v129) < 0) {
            operator delete((void *)v128);
          }
          int v34 = (std::__shared_weak_count *)*((void *)&v127 + 1);
          if (!*((void *)&v127 + 1)) {
            goto LABEL_19;
          }
        }
        else
        {
          if (a9 - 2 < 2)
          {
            long long v111 = 0u;
            long long v112 = 0u;
            long long v109 = 0u;
            long long v110 = 0u;
            long long v107 = 0u;
            long long v108 = 0u;
            long long v105 = 0u;
            long long v106 = 0u;
            long long v103 = 0u;
            long long v104 = 0u;
            long long v101 = 0u;
            long long v102 = 0u;
            long long v99 = 0u;
            long long v100 = 0u;
            memset(buf, 0, sizeof(buf));
            std::string::operator=((std::string *)buf, (const std::string *)a3);
            LOWORD(v107) = 258;
            long long v35 = *(std::__shared_weak_count **)(a1 + 760);
            *(_OWORD *)(a1 + 752) = 0u;
            if (v35) {
              sub_10004D2C8(v35);
            }
            *(void *)&long long __dst = a3;
            *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), a3, (long long **)&__dst) + 20) = 70035;
            *(void *)&long long v64 = v21;
            *((void *)&v64 + 1) = v20;
            atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
            if (*((char *)a2 + 23) < 0)
            {
              sub_10004FC84(&v65, *a2, (unint64_t)a2[1]);
            }
            else
            {
              long long v65 = *(_OWORD *)a2;
              int v66 = a2[2];
            }
            if (*((char *)a3 + 23) < 0)
            {
              sub_10004FC84(&v67, *a3, (unint64_t)a3[1]);
            }
            else
            {
              long long v67 = *(_OWORD *)a3;
              uint64_t v68 = a3[2];
            }
            long long v69 = v49;
            long long v70 = v137;
            sub_10030DA1C((char *)&v71, (long long *)buf);
            long long v97 = 0;
            uint64_t v37 = (char *)operator new(0x168uLL);
            *(void *)uint64_t v37 = off_101A9CE58;
            *(_OWORD *)(v37 + 8) = v64;
            long long v64 = 0uLL;
            *(_OWORD *)(v37 + 24) = v65;
            *((void *)v37 + 5) = v66;
            long long v65 = 0uLL;
            int v66 = 0;
            *((_OWORD *)v37 + 3) = v67;
            *((void *)v37 + 8) = v68;
            long long v67 = 0uLL;
            uint64_t v68 = 0;
            long long v38 = v69;
            *(_OWORD *)(v37 + 88) = v70;
            *(_OWORD *)(v37 + 72) = v38;
            long long v39 = v71;
            *((void *)v37 + 15) = v72;
            *(_OWORD *)(v37 + 104) = v39;
            long long v71 = 0uLL;
            uint64_t v72 = 0;
            __int16 v40 = v73;
            v37[136] = 0;
            *((_WORD *)v37 + 64) = v40;
            v37[160] = 0;
            if (v76)
            {
              *(_OWORD *)(v37 + 136) = v74;
              *((void *)v37 + 19) = v75;
              uint64_t v75 = 0;
              long long v74 = 0uLL;
              v37[160] = 1;
            }
            v37[168] = 0;
            v37[192] = 0;
            if (v79)
            {
              *(_OWORD *)(v37 + 168) = v77;
              *((void *)v37 + 23) = v78;
              uint64_t v78 = 0;
              long long v77 = 0uLL;
              v37[192] = 1;
            }
            v37[200] = 0;
            v37[224] = 0;
            if (v82)
            {
              *(_OWORD *)(v37 + 200) = v80;
              *((void *)v37 + 27) = v81;
              uint64_t v81 = 0;
              long long v80 = 0uLL;
              v37[224] = 1;
            }
            v37[232] = 0;
            v37[256] = 0;
            if (v85)
            {
              *(_OWORD *)(v37 + 232) = v83;
              *((void *)v37 + 31) = v84;
              uint64_t v84 = 0;
              long long v83 = 0uLL;
              v37[256] = 1;
            }
            *((_WORD *)v37 + 132) = v86;
            *((void *)v37 + 36) = v88;
            *((_OWORD *)v37 + 17) = v87;
            uint64_t v88 = 0;
            long long v87 = 0uLL;
            *((_WORD *)v37 + 148) = v89;
            v37[298] = v90;
            v37[304] = 0;
            v37[328] = 0;
            if (v93)
            {
              *((void *)v37 + 40) = v92;
              *((_OWORD *)v37 + 19) = v91;
              uint64_t v92 = 0;
              long long v91 = 0uLL;
              v37[328] = 1;
            }
            *((_WORD *)v37 + 176) = v95;
            *((_OWORD *)v37 + 21) = v94;
            long long v97 = v37;
            sub_1011C5690(a1, a3, (uint64_t)v96);
            sub_1000DBADC(v96);
            sub_1000C5578((uint64_t)&v71);
            if (SHIBYTE(v68) < 0) {
              operator delete((void *)v67);
            }
            if (SHIBYTE(v66) < 0) {
              operator delete((void *)v65);
            }
            if (*((void *)&v64 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v64 + 1));
            }
            sub_1000C5578((uint64_t)buf);
            goto LABEL_19;
          }
          if (a9 != 4)
          {
            if (a9 == 1)
            {
              if (*(void *)(a1 + 360))
              {
                long long v23 = *(NSObject **)(a1 + 48);
                if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                {
                  int v24 = a3;
                  if (*((char *)a3 + 23) < 0) {
                    int v24 = *a3;
                  }
                  *(_DWORD *)std::string buf = 136315138;
                  *(void *)&uint8_t buf[4] = v24;
                  _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#N there is an ongoing request. consent accept for %s", buf, 0xCu);
                }
              }
              unint64_t v25 = sub_100CCD974((unsigned __int8 **)a3, (uint64_t *)(a1 + 608));
              *(void *)std::string buf = a3;
              uint64_t v26 = (capabilities::ct *)sub_1011C81F0((uint64_t **)(a1 + 784), a3, (long long **)buf);
              if (!*((unsigned char *)v26 + 113) && (v25 & 0xFF00000000) != 0)
              {
                uint64_t v26 = (capabilities::ct *)sub_1011C15B8(a1, v25);
                if (v26)
                {
                  *(void *)&uint8_t buf[8] = 0;
                  *(void *)std::string buf = 0;
                  (***(void (****)(long long *__return_ptr))(a1 + 56))(&__dst);
                  sub_1011C7620((Registry *)__dst, buf, v27);
                  if (*((void *)&__dst + 1)) {
                    sub_10004D2C8(*((std::__shared_weak_count **)&__dst + 1));
                  }
                  if (*(void *)buf) {
                    (*(void (**)(void))(**(void **)buf + 80))(*(void *)buf);
                  }
                  uint64_t v26 = *(capabilities::ct **)&buf[8];
                  if (*(void *)&buf[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                  }
                }
              }
              if (capabilities::ct::supportsSIMTransferWithSecureIntent(v26)) {
                char v29 = 3;
              }
              else {
                char v29 = 2;
              }
              ctu::hex((uint64_t *)buf, (ctu *)&v137, (const void *)0x10, v28);
              uint64_t v30 = v20;
              if (*((char *)a3 + 23) < 0)
              {
                sub_10004FC84(&__dst, *a3, (unint64_t)a3[1]);
              }
              else
              {
                long long __dst = *(_OWORD *)a3;
                v125 = a3[2];
              }
              uint64_t v51 = 0;
              uint64_t v52 = 0;
              uint64_t v53 = 0;
              v54[0] = (void **)&v51;
              v54[1] = 0;
              uint64_t v51 = (std::string *)operator new(0x18uLL);
              uint64_t v52 = v51;
              uint64_t v53 = v51 + 1;
              uint64_t v52 = (std::string *)sub_1000D8A18((uint64_t)&v53, &__dst, (long long *)&v126, (char *)v51);
              *(void *)&long long v113 = a1;
              long long v43 = *(std::__shared_weak_count **)(a1 + 24);
              if (!v43 || (v44 = *(void *)(a1 + 16), (uint64_t v45 = std::__shared_weak_count::lock(v43)) == 0)) {
                sub_100088B9C();
              }
              *((void *)&v113 + 1) = v44;
              uint64_t v114 = v45;
              atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v45);
              if (*((char *)a3 + 23) < 0)
              {
                unint64_t v20 = v30;
                sub_10004FC84(&v115, *a3, (unint64_t)a3[1]);
              }
              else
              {
                long long v115 = *(_OWORD *)a3;
                __int16 v116 = a3[2];
                unint64_t v20 = v30;
              }
              *(void *)&long long v117 = v21;
              *((void *)&v117 + 1) = v20;
              atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
              if (*((char *)a2 + 23) < 0)
              {
                sub_10004FC84(&v118, *a2, (unint64_t)a2[1]);
              }
              else
              {
                long long v118 = *(_OWORD *)a2;
                char v119 = a2[2];
              }
              long long v120 = v49;
              long long v121 = v137;
              char v123 = 0;
              long long v46 = (char *)operator new(0x80uLL);
              *(void *)long long v46 = off_101A9CD58;
              *(_OWORD *)(v46 + 8) = v113;
              *((void *)v46 + 3) = v114;
              *((void *)&v113 + 1) = 0;
              uint64_t v114 = 0;
              *((_OWORD *)v46 + 2) = v115;
              *((void *)v46 + 6) = v116;
              long long v115 = 0uLL;
              __int16 v116 = 0;
              *(_OWORD *)(v46 + 56) = v117;
              long long v117 = 0uLL;
              long long v47 = v118;
              *((void *)v46 + 11) = v119;
              *(_OWORD *)(v46 + 72) = v47;
              long long v118 = 0uLL;
              char v119 = 0;
              long long v48 = v121;
              *((_OWORD *)v46 + 6) = v120;
              *((_OWORD *)v46 + 7) = v48;
              char v123 = v46;
              sub_1011BF38C(a1, v29, (const std::string *)a2, (const std::string *)buf, a8, -1, &v51, (uint64_t)v122);
              sub_100060644(v122);
              if (SHIBYTE(v119) < 0) {
                operator delete((void *)v118);
              }
              if (*((void *)&v117 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v117 + 1));
              }
              if (SHIBYTE(v116) < 0) {
                operator delete((void *)v115);
              }
              if (v114) {
                std::__shared_weak_count::__release_weak(v114);
              }
              v54[0] = (void **)&v51;
              sub_100047F64(v54);
              if (SHIBYTE(v125) < 0) {
                operator delete((void *)__dst);
              }
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
            goto LABEL_19;
          }
          long long v36 = *(std::__shared_weak_count **)(a1 + 760);
          *(_OWORD *)(a1 + 752) = 0u;
          if (v36) {
            sub_10004D2C8(v36);
          }
          *(void *)std::string buf = a3;
          *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), a3, (long long **)buf) + 20) = 70034;
          *(void *)&long long v55 = v21;
          *((void *)&v55 + 1) = v20;
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v56, *a2, (unint64_t)a2[1]);
          }
          else
          {
            long long v56 = *(_OWORD *)a2;
            int v57 = a2[2];
          }
          if (*((char *)a3 + 23) < 0)
          {
            sub_10004FC84(&v58, *a3, (unint64_t)a3[1]);
          }
          else
          {
            long long v58 = *(_OWORD *)a3;
            uint64_t v59 = a3[2];
          }
          long long v60 = v49;
          long long v61 = v137;
          long long v63 = 0;
          uint64_t v41 = (char *)operator new(0x68uLL);
          *(void *)uint64_t v41 = off_101A9CED8;
          *(_OWORD *)(v41 + 8) = v55;
          long long v55 = 0uLL;
          *(_OWORD *)(v41 + 24) = v56;
          *((void *)v41 + 5) = v57;
          long long v56 = 0uLL;
          int v57 = 0;
          *((_OWORD *)v41 + 3) = v58;
          *((void *)v41 + 8) = v59;
          long long v58 = 0uLL;
          uint64_t v59 = 0;
          long long v42 = v60;
          *(_OWORD *)(v41 + 88) = v61;
          *(_OWORD *)(v41 + 72) = v42;
          long long v63 = v41;
          sub_1011C5690(a1, a3, (uint64_t)v62);
          sub_1000DBADC(v62);
          if (SHIBYTE(v59) < 0) {
            operator delete((void *)v58);
          }
          if (SHIBYTE(v57) < 0) {
            operator delete((void *)v56);
          }
          int v34 = (std::__shared_weak_count *)*((void *)&v55 + 1);
          if (!*((void *)&v55 + 1)) {
            goto LABEL_19;
          }
        }
        sub_10004D2C8(v34);
LABEL_19:
        sub_10004D2C8(v20);
        return;
      }
    }
  }
  else
  {
    unint64_t v20 = 0;
  }
  std::string::size_type v22 = *(NSObject **)(a1 + 48);
  if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (!v20) {
      return;
    }
    goto LABEL_19;
  }
  *(_WORD *)std::string buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "invalid delegate", buf, 2u);
  if (v20) {
    goto LABEL_19;
  }
}

void sub_1011BE89C(_Unwind_Exception *a1)
{
  if (STACK[0x248]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x248]);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011BEAD4(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v5 = *(std::__shared_weak_count **)(a2 + 80);
  if (v5)
  {
    int v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = *(void *)(a2 + 72);
      if (v8)
      {
        uint64_t v22 = 0;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v16 = 0u;
        long long v17 = 0u;
        *(_OWORD *)std::string buf = 0u;
        long long v15 = 0u;
        (*(void (**)(long long *__return_ptr))(*(void *)v8 + 184))(&v12);
        unint64_t v9 = (os_log_t *)(a2 + 48);
        sub_100CDB320((os_log_t *)(a2 + 48), a3, (uint64_t *)(a2 + 608), (uint64_t)&v12, (uint64_t)buf);
        sub_10010E37C((uint64_t)&v12, *((void **)&v12 + 1));
        if ((_BYTE)v22)
        {
          (*(void (**)(long long *__return_ptr))(**(void **)(a2 + 56) + 160))(&v12);
          *(_OWORD *)a1 = v12;
          a1[2] = v13;
        }
        else
        {
          uint64_t v11 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v12) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "carrier descriptors not available", (uint8_t *)&v12, 2u);
          }
        }
        sub_10010B788((uint64_t)buf);
LABEL_14:
        sub_10004D2C8(v7);
        return;
      }
    }
  }
  else
  {
    int v7 = 0;
  }
  size_t v10 = *(NSObject **)(a2 + 48);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Delegate not available", buf, 2u);
  }
  if (v7) {
    goto LABEL_14;
  }
}

void sub_1011BECA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10010B788((uint64_t)va);
  sub_10004D2C8(v5);
  _Unwind_Resume(a1);
}

void sub_1011BECDC(uint64_t a1, std::string::size_type a2, uint64_t a3)
{
  if (*(void *)(a1 + 360))
  {
    int v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        int v7 = (void *)a2;
      }
      else {
        int v7 = *(void **)a2;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N there is an ongoing request. new request. new token generation request for %s", (uint8_t *)&buf, 0xCu);
    }
  }
  sub_1011BB5A8((void *)a1, 1);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8)
  {
    unint64_t v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      uint64_t v10 = *(void *)(a1 + 72);
      if (v10)
      {
        memset(&buf, 0, sizeof(buf));
        int v53 = 0;
        sub_100058DB0(&v54, "qrcode");
        v56[0] = 1;
        *(void *)&v56[1] = 0;
        v56[9] = 0;
        int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 208))(v10);
        if (v11) {
          char v12 = 3;
        }
        else {
          char v12 = 2;
        }
        if (v11) {
          char v13 = 3;
        }
        else {
          char v13 = 0;
        }
        if (*(unsigned char *)(a1 + 872)) {
          char v14 = 1;
        }
        else {
          char v14 = v13;
        }
        if (*(unsigned char *)(a1 + 872) == 2) {
          char v15 = v12;
        }
        else {
          char v15 = v14;
        }
        v56[10] = v15;
        __p.n128_u8[0] = 0;
        char v59 = 0;
        *(void *)&v60[0] = CFAbsoluteTimeGetCurrent();
        memset((char *)v60 + 8, 0, 128);
        v38.__r_.__value_.__r.__words[0] = a2;
        long long v16 = sub_1011C81F0((uint64_t **)(a1 + 784), (void **)a2, (long long **)&v38);
        long long v17 = (void **)(v16 + 56);
        if (v16[79] < 0) {
          operator delete(*v17);
        }
        *(_OWORD *)long long v17 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
        *((void *)v16 + 9) = *((void *)&buf.__r_.__value_.__l + 2);
        *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
        buf.__r_.__value_.__s.__data_[0] = 0;
        *((_DWORD *)v16 + 20) = v53;
        long long v18 = (void **)(v16 + 88);
        if (v16[111] < 0) {
          operator delete(*v18);
        }
        *(_OWORD *)long long v18 = v54;
        *((void *)v16 + 13) = v55;
        HIBYTE(v55) = 0;
        LOBYTE(v54) = 0;
        *((void *)v16 + 14) = *(void *)v56;
        *(_DWORD *)(v16 + 119) = *(_DWORD *)&v56[7];
        sub_100179CB0((uint64_t)(v16 + 128), &__p);
        long long v20 = v60[7];
        *((_OWORD *)v16 + 16) = v60[6];
        *((_OWORD *)v16 + 17) = v20;
        uint64_t v21 = *(void *)&v60[8];
        long long v23 = v60[4];
        long long v22 = v60[5];
        long long v24 = v60[3];
        *((_OWORD *)v16 + 12) = v60[2];
        *((_OWORD *)v16 + 13) = v24;
        *((void *)v16 + 36) = v21;
        *((_OWORD *)v16 + 14) = v23;
        *((_OWORD *)v16 + 15) = v22;
        long long v25 = v60[1];
        *((_OWORD *)v16 + 10) = v60[0];
        *((_OWORD *)v16 + 11) = v25;
        if (v59 && v58 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        if (SHIBYTE(v55) < 0) {
          operator delete((void *)v54);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if (capabilities::ct::supportsSIMTransferWithSecureIntent(v19)) {
          char v26 = 3;
        }
        else {
          char v26 = 2;
        }
        memset(&buf, 0, sizeof(buf));
        memset(&v38, 0, sizeof(v38));
        memset(&v37, 0, sizeof(v37));
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)a2;
          uint64_t v50 = *(void *)(a2 + 16);
        }
        int v34 = 0;
        long long v35 = 0;
        long long v36 = 0;
        v41[0] = (void **)&v34;
        v41[1] = 0;
        int v34 = (std::string *)operator new(0x18uLL);
        long long v35 = v34;
        long long v36 = v34 + 1;
        long long v35 = (std::string *)sub_1000D8A18((uint64_t)&v36, (long long *)__dst, (long long *)&v51, (char *)v34);
        uint64_t v42 = a1;
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(&v43, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          long long v43 = *(_OWORD *)a2;
          uint64_t v44 = *(void *)(a2 + 16);
        }
        sub_1011CC5FC((uint64_t)v45, a3);
        unint64_t v28 = *(std::__shared_weak_count **)(a1 + 24);
        if (!v28 || (char v29 = *(std::__shared_weak_count **)(a1 + 16), (v30 = std::__shared_weak_count::lock(v28)) == 0)) {
          sub_100088B9C();
        }
        v46[0] = v29;
        v46[1] = v30;
        atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v30);
        long long v48 = 0;
        int v31 = (char *)operator new(0x58uLL);
        uint64_t v32 = v42;
        *(void *)int v31 = off_101A9C6E8;
        *((void *)v31 + 1) = v32;
        long long v33 = v31 + 16;
        if (SHIBYTE(v44) < 0)
        {
          sub_10004FC84(v33, (void *)v43, *((unint64_t *)&v43 + 1));
        }
        else
        {
          *(_OWORD *)long long v33 = v43;
          *((void *)v31 + 4) = v44;
        }
        sub_1011CC5FC((uint64_t)(v31 + 40), (uint64_t)v45);
        *(_OWORD *)(v31 + 72) = *(_OWORD *)v46;
        v46[0] = 0;
        v46[1] = 0;
        long long v48 = v31;
        sub_1011BF38C(a1, v26, &buf, &v38, &v37, -1, &v34, (uint64_t)v47);
        sub_100060644(v47);
        if (v46[1]) {
          std::__shared_weak_count::__release_weak(v46[1]);
        }
        sub_10033022C(v45);
        if (SHIBYTE(v44) < 0) {
          operator delete((void *)v43);
        }
        v41[0] = (void **)&v34;
        sub_100047F64(v41);
        if (SHIBYTE(v50) < 0) {
          operator delete(__dst[0]);
        }
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v37.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v38.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
LABEL_66:
        sub_10004D2C8(v9);
        return;
      }
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  int v27 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "invalid delegate", (uint8_t *)&buf, 2u);
  }
  v39[0] = 0;
  char v40 = 0;
  sub_100B4CB0C(a3, (uint64_t)v39, 4);
  if (v40) {
    sub_1000C5578((uint64_t)v39);
  }
  if (v9) {
    goto LABEL_66;
  }
}

void sub_1011BF234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,void *a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  operator delete(v75);
  sub_1011BFAC0((uint64_t)&a59);
  a57 = (uint64_t)&a9;
  sub_100047F64((void ***)&a57);
  if (a73 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (SLOBYTE(STACK[0x207]) < 0) {
    operator delete(a74);
  }
  sub_10004D2C8(v74);
  _Unwind_Resume(a1);
}

void sub_1011BF38C(uint64_t a1, char a2, const std::string *a3, const std::string *a4, const std::string *a5, int a6, std::string **a7, uint64_t a8)
{
  sub_1003DB990(a1 + 312, *(void *)(a1 + 608), *(void *)(a1 + 616), 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 616) - *(void *)(a1 + 608)) >> 3));
  sub_1003DB294(a1 + 288, *(void *)(a1 + 584), *(void *)(a1 + 592), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 592) - *(void *)(a1 + 584)) >> 3));
  char v14 = *(std::__shared_weak_count **)(a1 + 80);
  uint64_t v51 = a8;
  if (v14)
  {
    char v15 = std::__shared_weak_count::lock(v14);
    if (v15)
    {
      uint64_t v16 = *(void *)(a1 + 72);
      if (v16)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 200))(v16, 1, 1);
LABEL_9:
        sub_10004D2C8(v15);
        goto LABEL_10;
      }
    }
  }
  else
  {
    char v15 = 0;
  }
  long long v17 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long v62 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "invalid delegate", v62, 2u);
  }
  if (v15) {
    goto LABEL_9;
  }
LABEL_10:
  std::string::operator=((std::string *)(a1 + 240), a4);
  std::string::operator=((std::string *)(a1 + 216), a3);
  std::string::operator=((std::string *)(a1 + 264), a5);
  *(_DWORD *)(a1 + 424) = a6;
  long long v54 = (uint64_t **)(a1 + 344);
  long long v18 = (void *)a1;
  sub_1011C7BD8(*(void **)(a1 + 352));
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 344) = a1 + 352;
  uint64_t v19 = *(void *)(a1 + 608);
  uint64_t v52 = v18;
  uint64_t v20 = v18[77];
  if (v19 == v20) {
    goto LABEL_34;
  }
  do
  {
    if (subscriber::isEsimCapable()) {
      goto LABEL_33;
    }
    uint64_t v21 = *a7;
    long long v22 = a7[1];
    if (*a7 == v22) {
      goto LABEL_33;
    }
    uint64_t v23 = *(unsigned __int8 *)(v19 + 95);
    size_t v24 = *(void *)(v19 + 80);
    if ((v23 & 0x80u) == 0) {
      uint64_t v25 = *(unsigned __int8 *)(v19 + 95);
    }
    else {
      uint64_t v25 = *(void *)(v19 + 80);
    }
    while (1)
    {
      std::string::size_type size = HIBYTE(v21->__r_.__value_.__r.__words[2]);
      int v27 = (char)size;
      if ((size & 0x80u) != 0) {
        std::string::size_type size = v21->__r_.__value_.__l.__size_;
      }
      if (v25 != size) {
        goto LABEL_29;
      }
      unint64_t v28 = v27 >= 0 ? v21 : (std::string *)v21->__r_.__value_.__r.__words[0];
      if ((v23 & 0x80) != 0) {
        break;
      }
      if (!v23) {
        goto LABEL_31;
      }
      uint64_t v29 = 0;
      while (*(unsigned __int8 *)(v19 + v29 + 72) == v28->__r_.__value_.__s.__data_[v29])
      {
        if (v23 == ++v29) {
          goto LABEL_31;
        }
      }
LABEL_29:
      if (++v21 == v22) {
        goto LABEL_33;
      }
    }
    if (memcmp(*(const void **)(v19 + 72), v28, v24)) {
      goto LABEL_29;
    }
LABEL_31:
    long long v76 = 0u;
    long long v77 = 0u;
    long long v75 = 0u;
    long long v73 = 0uLL;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v64 = 0u;
    memset(v62, 0, sizeof(v62));
    v62[29] = 3;
    BYTE8(v77) = 0;
    *(void *)&long long v64 = 0;
    long long v63 = 0uLL;
    WORD4(v64) = 0;
    memset(v74, 0, sizeof(v74));
    std::string::operator=((std::string *)v62, (const std::string *)(v19 + 72));
    *(_DWORD *)&v62[24] = *(_DWORD *)v19;
    v62[28] = subscriber::isSimReady();
    v62[29] = a2;
    sub_1011D1A94(v54, (uint64_t)v62, (uint64_t)v62);
    sub_1000C5578((uint64_t)&v63);
    if ((v62[23] & 0x80000000) != 0) {
      operator delete(*(void **)v62);
    }
LABEL_33:
    v19 += 168;
  }
  while (v19 != v20);
LABEL_34:
  uint64_t v30 = v52[73];
  uint64_t v53 = v52[74];
  if (v30 != v53)
  {
    while (1)
    {
      uint64_t v56 = v30;
      if (*(unsigned char *)(v30 + 80)) {
        break;
      }
LABEL_64:
      uint64_t v30 = v56 + 88;
      if (v56 + 88 == v53) {
        goto LABEL_65;
      }
    }
    uint64_t v32 = *(void *)(v30 + 56);
    uint64_t v31 = *(void *)(v30 + 64);
LABEL_37:
    if (v32 == v31) {
      goto LABEL_64;
    }
    uint64_t v33 = *(unsigned __int8 *)(v32 + 39);
    if (*(char *)(v32 + 39) < 0)
    {
      if (!*(void *)(v32 + 24)) {
        goto LABEL_63;
      }
    }
    else if (!*(unsigned char *)(v32 + 39))
    {
      goto LABEL_63;
    }
    long long v35 = *a7;
    int v34 = a7[1];
    if (*a7 == v34) {
      goto LABEL_63;
    }
    size_t v36 = *(void *)(v32 + 24);
    if ((v33 & 0x80u) == 0) {
      uint64_t v37 = *(unsigned __int8 *)(v32 + 39);
    }
    else {
      uint64_t v37 = *(void *)(v32 + 24);
    }
    while (1)
    {
      std::string::size_type v38 = HIBYTE(v35->__r_.__value_.__r.__words[2]);
      int v39 = (char)v38;
      if ((v38 & 0x80u) != 0) {
        std::string::size_type v38 = v35->__r_.__value_.__l.__size_;
      }
      if (v37 == v38)
      {
        if (v39 >= 0) {
          char v40 = v35;
        }
        else {
          char v40 = (std::string *)v35->__r_.__value_.__r.__words[0];
        }
        if ((v33 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v32 + 16), v40, v36))
          {
LABEL_61:
            long long v76 = 0u;
            long long v77 = 0u;
            long long v75 = 0u;
            long long v73 = 0uLL;
            long long v71 = 0u;
            long long v72 = 0u;
            long long v69 = 0u;
            long long v70 = 0u;
            long long v67 = 0u;
            long long v68 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            long long v64 = 0u;
            memset(v62, 0, sizeof(v62));
            v62[29] = 3;
            BYTE8(v77) = 0;
            *(void *)&long long v64 = 0;
            long long v63 = 0uLL;
            WORD4(v64) = 0;
            memset(v74, 0, sizeof(v74));
            std::string::operator=((std::string *)v62, (const std::string *)(v32 + 16));
            *(_DWORD *)&v62[24] = *(_DWORD *)(v56 + 4);
            v62[28] = *(unsigned char *)(v32 + 89);
            v62[29] = a2;
            sub_1011D1A94(v54, (uint64_t)v62, (uint64_t)v62);
            sub_1000C5578((uint64_t)&v63);
            if ((v62[23] & 0x80000000) != 0) {
              operator delete(*(void **)v62);
            }
LABEL_63:
            v32 += 216;
            goto LABEL_37;
          }
        }
        else
        {
          if (!v33) {
            goto LABEL_61;
          }
          uint64_t v41 = 0;
          while (*(unsigned __int8 *)(v32 + v41 + 16) == v40->__r_.__value_.__s.__data_[v41])
          {
            if (v33 == ++v41) {
              goto LABEL_61;
            }
          }
        }
      }
      if (++v35 == v34) {
        goto LABEL_63;
      }
    }
  }
LABEL_65:
  uint64_t v42 = v52;
  v52[42] = v52[43];
  if (v52[45])
  {
    uint64_t v44 = v52[2];
    long long v43 = (std::__shared_weak_count *)v52[3];
    *(void *)std::string buf = v52;
    *(void *)&uint8_t buf[8] = v44;
    if (!v43 || (char v59 = std::__shared_weak_count::lock(v43)) == 0) {
      sub_100088B9C();
    }
    sub_100023950((uint64_t)v60, v51);
    *(_OWORD *)long long v62 = *(_OWORD *)buf;
    *(void *)&v62[16] = v59;
    *(void *)&uint8_t buf[8] = 0;
    char v59 = 0;
    sub_100023950((uint64_t)&v62[24], (uint64_t)v60);
    uint64_t v45 = (char *)operator new(0x40uLL);
    *(void *)uint64_t v45 = off_101A9C868;
    *(_OWORD *)(v45 + 8) = *(_OWORD *)v62;
    *((void *)v45 + 3) = *(void *)&v62[16];
    *(_OWORD *)&v62[8] = 0uLL;
    sub_100023950((uint64_t)(v45 + 32), (uint64_t)&v62[24]);
    v61[3] = v45;
    sub_10033A6B8(v61, v52 + 46);
    sub_100060644(v61);
    sub_100060644(&v62[24]);
    if (*(void *)&v62[16]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v62[16]);
    }
    sub_100060644(v60);
    if (v59) {
      sub_10004D2C8(v59);
    }
    sub_1011BBE34((uint64_t)v52);
  }
  else
  {
    long long v46 = v52[6];
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      sub_100062B40(*a7, a7[1], ",", 1uLL, (std::string *)v62);
      if (v62[23] >= 0) {
        uint64_t v50 = v62;
      }
      else {
        uint64_t v50 = *(unsigned char **)v62;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v50;
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "No plans to transfer for : [%s]", buf, 0xCu);
      if ((v62[23] & 0x80000000) != 0) {
        operator delete(*(void **)v62);
      }
      uint64_t v42 = v52;
    }
    long long v48 = *a7;
    long long v47 = a7[1];
    if (*a7 != v47)
    {
      long long v49 = (uint64_t **)(v42 + 98);
      do
      {
        *(void *)long long v62 = v48;
        *((_DWORD *)sub_1011C81F0(v49, (void **)&v48->__r_.__value_.__l.__data_, (long long **)v62) + 20) = 70028;
        ++v48;
      }
      while (v48 != v47);
    }
    sub_1000607A8(v51, 0);
  }
}

void sub_1011BFA78(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011BFAC0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10033022C((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1011BFB08(uint64_t a1, std::string::size_type a2, const std::string *a3, uint64_t a4)
{
  int v6 = *(std::__shared_weak_count **)(a1 + 80);
  if (v6)
  {
    unint64_t v9 = std::__shared_weak_count::lock(v6);
    if (v9)
    {
      uint64_t v10 = *(void *)(a1 + 72);
      if (v10)
      {
        memset(&v42, 0, sizeof(v42));
        int v43 = 0;
        sub_100058DB0(&v44, "internal-tools");
        *(_WORD *)long long v46 = 1;
        v46[2] = 1;
        *(_DWORD *)&v46[3] = 0;
        *(_DWORD *)&v46[6] = 0;
        int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 208))(v10);
        if (v11) {
          char v12 = 3;
        }
        else {
          char v12 = 2;
        }
        if (v11) {
          char v13 = 3;
        }
        else {
          char v13 = 0;
        }
        if (*(unsigned char *)(a1 + 872)) {
          char v14 = 1;
        }
        else {
          char v14 = v13;
        }
        if (*(unsigned char *)(a1 + 872) == 2) {
          char v15 = v12;
        }
        else {
          char v15 = v14;
        }
        v46[10] = v15;
        __p.n128_u8[0] = 0;
        char v49 = 0;
        long long v35 = a3;
        *(void *)&v50[0] = CFAbsoluteTimeGetCurrent();
        *(_OWORD *)((char *)v50 + 8) = 0u;
        *(_OWORD *)((char *)&v50[1] + 8) = 0u;
        *(_OWORD *)((char *)&v50[2] + 8) = 0u;
        *(_OWORD *)((char *)&v50[3] + 8) = 0u;
        *(_OWORD *)((char *)&v50[4] + 8) = 0u;
        *(_OWORD *)((char *)&v50[5] + 8) = 0u;
        *(_OWORD *)((char *)&v50[6] + 8) = 0u;
        *(_OWORD *)((char *)&v50[7] + 8) = 0u;
        buf.__r_.__value_.__r.__words[0] = a2;
        uint64_t v16 = sub_1011C81F0((uint64_t **)(a1 + 784), (void **)a2, (long long **)&buf);
        long long v17 = (void **)(v16 + 56);
        if (v16[79] < 0) {
          operator delete(*v17);
        }
        *(_OWORD *)long long v17 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
        *((void *)v16 + 9) = *((void *)&v42.__r_.__value_.__l + 2);
        *((unsigned char *)&v42.__r_.__value_.__s + 23) = 0;
        v42.__r_.__value_.__s.__data_[0] = 0;
        *((_DWORD *)v16 + 20) = v43;
        long long v18 = (void **)(v16 + 88);
        if (v16[111] < 0) {
          operator delete(*v18);
        }
        *(_OWORD *)long long v18 = v44;
        *((void *)v16 + 13) = v45;
        HIBYTE(v45) = 0;
        LOBYTE(v44) = 0;
        *((void *)v16 + 14) = *(void *)v46;
        *(_DWORD *)(v16 + 119) = *(_DWORD *)&v46[7];
        sub_100179CB0((uint64_t)(v16 + 128), &__p);
        long long v20 = v50[7];
        *((_OWORD *)v16 + 16) = v50[6];
        *((_OWORD *)v16 + 17) = v20;
        uint64_t v21 = *(void *)&v50[8];
        long long v23 = v50[4];
        long long v22 = v50[5];
        long long v24 = v50[3];
        *((_OWORD *)v16 + 12) = v50[2];
        *((_OWORD *)v16 + 13) = v24;
        *((void *)v16 + 36) = v21;
        *((_OWORD *)v16 + 14) = v23;
        *((_OWORD *)v16 + 15) = v22;
        long long v25 = v50[1];
        *((_OWORD *)v16 + 10) = v50[0];
        *((_OWORD *)v16 + 11) = v25;
        if (v49 && v48 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        if (SHIBYTE(v45) < 0) {
          operator delete((void *)v44);
        }
        if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v42.__r_.__value_.__l.__data_);
        }
        memset(&v42, 0, sizeof(v42));
        if (*(char *)(a2 + 23) < 0)
        {
          uint64_t v19 = (capabilities::ct *)sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)a2;
          uint64_t v41 = *(void *)(a2 + 16);
        }
        char v27 = capabilities::ct::supportsHydra(v19);
        sub_1011BDB2C(&v42, (unsigned __int8 **)__dst, (uint64_t *)(a1 + 608), (void *)(a1 + 656), v27);
        if (SHIBYTE(v41) < 0) {
          operator delete(__dst[0]);
        }
        if (*(void *)(a1 + 360))
        {
          unint64_t v28 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N there is an ongoing request. new transfer type request", (uint8_t *)&buf, 2u);
          }
        }
        memset(&buf, 0, sizeof(buf));
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(&v61, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          long long v61 = *(_OWORD *)a2;
          uint64_t v62 = *(void *)(a2 + 16);
        }
        size_t v36 = 0;
        uint64_t v37 = 0;
        std::string::size_type v38 = 0;
        v53[0] = (void **)&v36;
        v53[1] = 0;
        size_t v36 = (std::string *)operator new(0x18uLL);
        uint64_t v37 = v36;
        std::string::size_type v38 = v36 + 1;
        uint64_t v37 = (std::string *)sub_1000D8A18((uint64_t)&v38, &v61, &v63, (char *)v36);
        uint64_t v54 = a1;
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(&v55, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          long long v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
        }
        sub_1011CC5FC((uint64_t)v57, a4);
        uint64_t v29 = *(std::__shared_weak_count **)(a1 + 24);
        if (!v29 || (v30 = *(void *)(a1 + 16), (uint64_t v31 = std::__shared_weak_count::lock(v29)) == 0)) {
          sub_100088B9C();
        }
        *(void *)&long long v58 = v30;
        *((void *)&v58 + 1) = v31;
        atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v31);
        long long v60 = 0;
        uint64_t v32 = (char *)operator new(0x58uLL);
        uint64_t v33 = v54;
        *(void *)uint64_t v32 = off_101A9C768;
        *((void *)v32 + 1) = v33;
        int v34 = v32 + 16;
        if (SHIBYTE(v56) < 0)
        {
          sub_10004FC84(v34, (void *)v55, *((unint64_t *)&v55 + 1));
        }
        else
        {
          *(_OWORD *)int v34 = v55;
          *((void *)v32 + 4) = v56;
        }
        sub_1011CC5FC((uint64_t)(v32 + 40), (uint64_t)v57);
        *(_OWORD *)(v32 + 72) = v58;
        long long v58 = 0uLL;
        long long v60 = v32;
        sub_1011BF38C(a1, 1, &buf, v35, &v42, -1, &v36, (uint64_t)v59);
        sub_100060644(v59);
        if (*((void *)&v58 + 1)) {
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v58 + 1));
        }
        sub_10033022C(v57);
        if (SHIBYTE(v56) < 0) {
          operator delete((void *)v55);
        }
        v53[0] = (void **)&v36;
        sub_100047F64(v53);
        if (SHIBYTE(v62) < 0) {
          operator delete((void *)v61);
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v42.__r_.__value_.__l.__data_);
        }
LABEL_63:
        sub_10004D2C8(v9);
        return;
      }
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  char v26 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v42.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "invalid delegate", (uint8_t *)&v42, 2u);
  }
  v51[0] = 0;
  char v52 = 0;
  sub_100B4CB0C(a4, (uint64_t)v51, 4);
  if (v52) {
    sub_1000C5578((uint64_t)v51);
  }
  if (v9) {
    goto LABEL_63;
  }
}

void sub_1011C0074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  operator delete(v30);
  sub_1011BFAC0(v31 - 240);
  *(void *)(v31 - 256) = &a10;
  sub_100047F64((void ***)(v31 - 256));
  if (*(char *)(v31 - 105) < 0) {
    operator delete(*(void **)(v31 - 128));
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_10004D2C8(v29);
  _Unwind_Resume(a1);
}

uint64_t sub_1011C01C4(uint64_t a1, ctu *this, unint64_t a3)
{
  __n128 __p = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  ctu::hex((uint64_t *)&__p, this, (const void *)0x10, a3);
  int v6 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = a3 + 16;
    if (*(char *)(a3 + 39) < 0) {
      unint64_t v7 = *(void *)(a3 + 16);
    }
    p_p = &__p;
    if (v33 < 0) {
      p_p = __p;
    }
    *(_DWORD *)std::string buf = 136315394;
    long long v35 = (const void **)v7;
    __int16 v36 = 2080;
    uint64_t v37 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I cancel transfer token generation for - iccid:%s eid[target]:%s", buf, 0x16u);
  }
  uint64_t v9 = *(void *)(a1 + 752);
  if (!v9) {
    goto LABEL_45;
  }
  if (((*(uint64_t (**)(uint64_t, unint64_t, ctu *))(*(void *)v9 + 24))(v9, a3 + 16, this) & 1) == 0) {
    goto LABEL_45;
  }
  if (!*(void *)(a1 + 360)) {
    goto LABEL_45;
  }
  uint64_t v10 = *(void *)(a1 + 336);
  if (v10 == a1 + 352) {
    goto LABEL_45;
  }
  int v11 = (const void **)(v10 + 32);
  uint64_t v12 = *(unsigned __int8 *)(v10 + 55);
  size_t v13 = *(void *)(v10 + 40);
  if ((v12 & 0x80u) == 0) {
    uint64_t v14 = *(unsigned __int8 *)(v10 + 55);
  }
  else {
    uint64_t v14 = *(void *)(v10 + 40);
  }
  uint64_t v15 = *(unsigned __int8 *)(a3 + 39);
  int v16 = (char)v15;
  if ((v15 & 0x80u) != 0) {
    uint64_t v15 = *(void *)(a3 + 24);
  }
  if (v14 != v15) {
    goto LABEL_44;
  }
  if (v16 >= 0) {
    long long v17 = (unsigned __int8 *)(a3 + 16);
  }
  else {
    long long v17 = *(unsigned __int8 **)(a3 + 16);
  }
  if ((v12 & 0x80) != 0)
  {
    long long v20 = (const void **)*v11;
    if (memcmp(*v11, v17, v13))
    {
      uint64_t v21 = *(NSObject **)(a1 + 48);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
LABEL_45:
        uint64_t v27 = 0;
        goto LABEL_46;
      }
      int v11 = v20;
LABEL_54:
      uint64_t v30 = (void *)(a1 + 240);
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v30 = (void *)*v30;
      }
      *(_DWORD *)std::string buf = 136315394;
      long long v35 = v11;
      __int16 v36 = 2080;
      uint64_t v37 = v30;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "cannot cancel not ongoing request. ongoing iccid:%s eid[target]:%s", buf, 0x16u);
      goto LABEL_45;
    }
  }
  else if (v12)
  {
    long long v18 = v11;
    uint64_t v19 = v12;
    while (*(unsigned __int8 *)v18 == *v17)
    {
      long long v18 = (const void **)((char *)v18 + 1);
      ++v17;
      if (!--v19) {
        goto LABEL_29;
      }
    }
    goto LABEL_44;
  }
LABEL_29:
  uint64_t v22 = *(unsigned __int8 *)(a1 + 263);
  if ((v22 & 0x80u) == 0) {
    uint64_t v23 = *(unsigned __int8 *)(a1 + 263);
  }
  else {
    uint64_t v23 = *(void *)(a1 + 248);
  }
  uint64_t v24 = HIBYTE(v33);
  if (v33 < 0) {
    uint64_t v24 = v32;
  }
  if (v23 != v24) {
    goto LABEL_44;
  }
  long long v25 = (const void **)(a1 + 240);
  if (v33 >= 0) {
    char v26 = (unsigned __int8 *)&__p;
  }
  else {
    char v26 = (unsigned __int8 *)__p;
  }
  if ((v22 & 0x80) != 0)
  {
    if (!memcmp(*v25, v26, *(void *)(a1 + 248))) {
      goto LABEL_49;
    }
LABEL_44:
    uint64_t v21 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      goto LABEL_45;
    }
    if ((v12 & 0x80) != 0) {
      int v11 = (const void **)*v11;
    }
    goto LABEL_54;
  }
  if (*(unsigned char *)(a1 + 263))
  {
    while (*(unsigned __int8 *)v25 == *v26)
    {
      long long v25 = (const void **)((char *)v25 + 1);
      ++v26;
      if (!--v22) {
        goto LABEL_49;
      }
    }
    goto LABEL_44;
  }
LABEL_49:
  uint64_t v29 = *(void *)(a1 + 768);
  if (v29) {
    (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v29 + 40))(v29, v26);
  }
  uint64_t v27 = 1;
LABEL_46:
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  return v27;
}

void sub_1011C04F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011C0514(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011C057C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011C05E0(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v4 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "unexpected call", v4, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

void sub_1011C0650(uint64_t a1, char *a2, uint64_t a3)
{
  void (***v18)(uint64_t *__return_ptr, void, void **);
  char v19;
  unint64_t v20;
  NSObject *v21;
  uint64_t v22;
  std::string *v23;
  long long *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  atomic_ullong *p_shared_weak_owners;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  void *v37;
  int v38;
  char v39;
  uint8_t v40[16];
  void *v41[2];
  long long v42;
  void *v43[2];
  long long v44;
  uint64_t v45;
  uint8_t buf[16];
  _OWORD v47[2];
  long long v48;
  long long v49;
  std::string v50[4];
  long long v51;
  unsigned char v52[32];
  long long v53;
  uint64_t v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  void *__dst[2];
  uint64_t v58;
  long long v59;
  long long v60;
  long long v61;
  uint64_t v62;
  void v63[6];
  std::__shared_weak_count *v64;
  void v65[4];

  if (*(void *)(a3 + 24))
  {
    unint64_t v5 = a2;
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    char v59 = 0u;
    if (a2[23] < 0)
    {
      if (*((void *)a2 + 1))
      {
        __dst[0] = 0;
        __dst[1] = 0;
        long long v58 = 0;
        a2 = *(char **)a2;
LABEL_9:
        sub_100058DB0(buf, a2);
        if (SBYTE7(v47[0]) < 0)
        {
          sub_10004FC84(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
          if (SBYTE7(v47[0]) < 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)buf;
          long long v58 = *(void *)&v47[0];
        }
        long long v55 = 0;
        uint64_t v56 = 0;
        (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)buf);
        int v11 = ServiceMap;
        if (v12 < 0)
        {
          size_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v14 = 5381;
          do
          {
            uint64_t v12 = v14;
            unsigned int v15 = *v13++;
            uint64_t v14 = (33 * v14) ^ v15;
          }
          while (v15);
        }
        std::mutex::lock(ServiceMap);
        *(void *)char v40 = v12;
        int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v40);
        if (v16)
        {
          long long v18 = (void (***)(uint64_t *__return_ptr, void, void **))v16[3];
          long long v17 = (std::__shared_weak_count *)v16[4];
          if (v17)
          {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v11);
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v17);
            uint64_t v19 = 0;
LABEL_25:
            (**v18)(&v55, v18, __dst);
            if ((v19 & 1) == 0) {
              sub_10004D2C8(v17);
            }
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
            if (v55)
            {
              uint64_t v54 = 0;
              uint64_t v53 = 0u;
              uint64_t v51 = 0u;
              memset(v52, 0, sizeof(v52));
              memset(v50, 0, sizeof(v50));
              char v48 = 0u;
              char v49 = 0u;
              memset(v47, 0, sizeof(v47));
              *(_OWORD *)std::string buf = 0u;
              std::string::operator=((std::string *)buf, (const std::string *)v5);
              ctu::hex((uint64_t *)v40, (ctu *)(v5 + 48), (const void *)0x10, v20);
              if ((_BYTE)v48)
              {
                if (SHIBYTE(v47[1]) < 0) {
                  operator delete(*((void **)&v47[0] + 1));
                }
                *(_OWORD *)((char *)v47 + 8) = *(_OWORD *)v40;
                *((void **)&v47[1] + 1) = v41[0];
              }
              else
              {
                *(_OWORD *)((char *)v47 + 8) = *(_OWORD *)v40;
                *((void **)&v47[1] + 1) = v41[0];
                LOBYTE(v48) = 1;
              }
              uint64_t v23 = (std::string *)*((void *)v5 + 3);
              uint64_t v24 = (long long *)*((void *)v5 + 4);
              long long v25 = (char *)v24 - (char *)v23;
              if (v24 != (long long *)v23)
              {
                if (v50[0].__r_.__value_.__s.__data_[0])
                {
                  if ((char *)&v48 + 8 != v5 + 24) {
                    sub_10005CA3C((uint64_t)&v48 + 8, v23, v24, 0xAAAAAAAAAAAAAAABLL * (v25 >> 3));
                  }
                }
                else
                {
                  *((void *)&v48 + 1) = 0;
                  char v49 = 0uLL;
                  sub_1000302C0((char *)&v48 + 8, (long long *)v23, v24, 0xAAAAAAAAAAAAAAABLL * (v25 >> 3));
                  v50[0].__r_.__value_.__s.__data_[0] = 1;
                }
              }
              sub_100093B44((std::string *)&v50[0].__r_.__value_.__r.__words[1], (const std::string *)(v5 + 64));
              char v26 = v5[111];
              if ((v26 & 0x80u) != 0) {
                char v26 = *((void *)v5 + 12);
              }
              if (v26) {
                sub_100093B44((std::string *)&v50[1].__r_.__value_.__r.__words[2], (const std::string *)(v5 + 88));
              }
              sub_100093B44(&v50[3], (const std::string *)(v5 + 112));
              DWORD2(v51) = 2;
              BYTE12(v51) = 1;
              sub_100093B44((std::string *)v52, (const std::string *)(v5 + 160));
              if (*((_DWORD *)v5 + 47))
              {
                uint64_t v27 = *((_DWORD *)v5 + 46);
                if (v27)
                {
                  DWORD2(v53) = *((_DWORD *)v5 + 47);
                  BYTE12(v53) = 1;
                  LODWORD(v53) = v27;
                  BYTE4(v53) = 1;
                }
              }
              unint64_t v28 = BYTE7(v47[0]);
              if (SBYTE7(v47[0]) < 0) {
                unint64_t v28 = *(void *)&buf[8];
              }
              if (v28)
              {
                uint64_t v29 = *(std::__shared_weak_count **)(a1 + 24);
                if (!v29 || (v30 = *(void *)(a1 + 16), (uint64_t v31 = std::__shared_weak_count::lock(v29)) == 0)) {
                  sub_100088B9C();
                }
                uint64_t v32 = v31;
                p_shared_weak_owners = &v31->__shared_weak_owners_;
                atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v31);
                *(_OWORD *)char v40 = 0u;
                *(_OWORD *)uint64_t v41 = 0u;
                *(_OWORD *)int v43 = 0u;
                long long v44 = 0u;
                std::string v42 = 0u;
                v40[3] = 1;
                uint64_t v45 = 0;
                int v34 = v55;
                std::string::size_type v38 = 16;
                int v39 = 1;
                v63[0] = _NSConcreteStackBlock;
                v63[1] = 1174405120;
                v63[2] = sub_1011C0E9C;
                v63[3] = &unk_101A9C2C0;
                void v63[4] = a1;
                v63[5] = v30;
                long long v64 = v32;
                atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
                sub_1011CD760((uint64_t)v65, a3);
                uint64_t v37 = v63;
                (*(void (**)(uint64_t, void, uint8_t *, int *, uint8_t *, uint64_t, void **))(*(void *)v34 + 160))(v34, 0, v40, &v38, buf, a1 + 32, &v37);
                sub_10034CA60(v65);
                if (v64) {
                  std::__shared_weak_count::__release_weak(v64);
                }
                if ((_BYTE)v45 && SHIBYTE(v44) < 0) {
                  operator delete(v43[1]);
                }
                if (LOBYTE(v43[0]) && SHIBYTE(v42) < 0) {
                  operator delete(v41[1]);
                }
                std::__shared_weak_count::__release_weak(v32);
              }
              else
              {
                long long v35 = *(NSObject **)(a1 + 48);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)char v40 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "signUpForSIMServic request arg is not valid", v40, 2u);
                }
                LOBYTE(v59) = 6;
                sub_1011C7C7C((uint64_t)v40, (uint64_t)&v59);
                __int16 v36 = *(void *)(a3 + 24);
                if (!v36) {
                  sub_10007B600();
                }
                (*(void (**)(uint64_t, uint8_t *))(*(void *)v36 + 48))(v36, v40);
                sub_1000C636C((uint64_t)v40);
              }
              sub_10019F1F4((uint64_t)buf);
            }
            else
            {
              uint64_t v21 = *(NSObject **)(a1 + 48);
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find carrier controller.", buf, 2u);
              }
              LOBYTE(v59) = 1;
              sub_1011C7C7C((uint64_t)buf, (uint64_t)&v59);
              uint64_t v22 = *(void *)(a3 + 24);
              if (!v22) {
                sub_10007B600();
              }
              (*(void (**)(uint64_t, uint8_t *))(*(void *)v22 + 48))(v22, buf);
              sub_1000C636C((uint64_t)buf);
            }
            if (v56) {
              sub_10004D2C8(v56);
            }
            if (SHIBYTE(v58) < 0) {
              operator delete(__dst[0]);
            }
            if (SHIBYTE(v62) < 0) {
              operator delete((void *)v61);
            }
LABEL_76:
            if (SHIBYTE(v60) < 0) {
              operator delete(*((void **)&v59 + 1));
            }
            return;
          }
        }
        else
        {
          long long v18 = 0;
        }
        std::mutex::unlock(v11);
        long long v17 = 0;
        uint64_t v19 = 1;
        goto LABEL_25;
      }
    }
    else if (a2[23])
    {
      __dst[0] = 0;
      __dst[1] = 0;
      long long v58 = 0;
      goto LABEL_9;
    }
    unint64_t v7 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No iccid was found.", buf, 2u);
    }
    LOBYTE(v59) = 6;
    sub_1011C7C7C((uint64_t)buf, (uint64_t)&v59);
    uint64_t v8 = *(void *)(a3 + 24);
    if (!v8) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v8 + 48))(v8, buf);
    sub_1000C636C((uint64_t)buf);
    goto LABEL_76;
  }
  int v6 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invalid callback.", buf, 2u);
  }
}

void sub_1011C0D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  sub_10019F1F4((uint64_t)&a23);
  if (a56) {
    sub_10004D2C8((std::__shared_weak_count *)a56);
  }
  if (a62 < 0) {
    operator delete(__p);
  }
  sub_100087784(v62 - 240);
  _Unwind_Resume(a1);
}

void sub_1011C0E9C(void *a1, uint64_t a2, int a3)
{
  int v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    uint64_t v7 = a1[4];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (a1[5])
      {
        long long v24 = 0u;
        memset(v23, 0, sizeof(v23));
        memset(__str, 0, sizeof(__str));
        long long v20 = 0u;
        memset(&__p, 0, sizeof(__p));
        *(_OWORD *)uint64_t v19 = 0u;
        if (!*(void *)a2 || ((uint64_t v10 = *(long long **)(*(void *)a2 + 8)) != 0 ? (v11 = a3 == 0) : (v11 = 1), v11))
        {
          uint64_t v12 = *(NSObject **)(v7 + 48);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long v18 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "SignUpForSIMService failure for AddOn plan purchase", v18, 2u);
          }
          LOBYTE(v13) = 7;
        }
        else
        {
          if (*((char *)v10 + 23) < 0)
          {
            sub_10004FC84(__str, *(void **)v10, *((void *)v10 + 1));
          }
          else
          {
            long long v14 = *v10;
            __str[0].__r_.__value_.__r.__words[2] = *((void *)v10 + 2);
            *(_OWORD *)&__str[0].__r_.__value_.__l.__data_ = v14;
          }
          if (*((char *)v10 + 47) < 0)
          {
            sub_10004FC84(&__str[1], *((void **)v10 + 3), *((void *)v10 + 4));
          }
          else
          {
            long long v15 = *(long long *)((char *)v10 + 24);
            __str[1].__r_.__value_.__r.__words[2] = *((void *)v10 + 5);
            *(_OWORD *)&__str[1].__r_.__value_.__l.__data_ = v15;
          }
          sub_1000593FC((uint64_t)v23, v10 + 3);
          LOWORD(v24) = *((_WORD *)v10 + 40);
          BYTE8(v24) = 1;
          std::string::size_type size = __str[0].__r_.__value_.__l.__size_;
          if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
          }
          if (size) {
            std::string::operator=((std::string *)&v19[1], __str);
          }
          std::string::size_type v13 = HIBYTE(__str[1].__r_.__value_.__r.__words[2]);
          if ((__str[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v13 = __str[1].__r_.__value_.__l.__size_;
          }
          if (v13)
          {
            std::string::operator=(&__p, &__str[1]);
            LOBYTE(v13) = 0;
          }
        }
        LOBYTE(v19[0]) = v13;
        sub_1011C7C7C((uint64_t)v18, (uint64_t)v19);
        uint64_t v17 = a1[10];
        if (!v17) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v17 + 48))(v17, v18);
        sub_1000C636C((uint64_t)v18);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v20) < 0) {
          operator delete(v19[1]);
        }
        sub_1005594C0((uint64_t)__str);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1011C10C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_100087784((uint64_t)&a17);
  sub_1005594C0((uint64_t)&__p);
  sub_10004D2C8(v36);
  _Unwind_Resume(a1);
}

uint64_t sub_1011C1130(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_1011CD760(a1 + 56, a2 + 56);
}

void sub_1011C1174(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011C118C(uint64_t a1)
{
  sub_10034CA60((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_1011C11D8(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef theDict = 0;
  (***(void (****)(long long *__return_ptr))(a1 + 56))(&buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, (Registry *)buf);
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  value = (void *)v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&value);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v13 + 80))(&v29, v13, a2, 1, @"PhoneAccountTransfer", 0, 0);
  sub_10004EFE4(&theDict, &v29);
  sub_1000577C4(&v29);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (theDict) {
    long long v15 = sub_100080778;
  }
  else {
    long long v15 = 0;
  }
  if (!v15)
  {
    uint64_t v22 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Get kCBPhoneAccountTransfer bundle value failed. slot:%s", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_28;
  }
  value = 0;
  if (!CFDictionaryGetValueIfPresent(theDict, @"SupportsFallbackToLegacyFlow", (const void **)&value))
  {
    uint64_t v19 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v24;
      uint64_t v21 = "#I SupportsFallbackToLegacyFlow not found in bundle. slot:%s";
      goto LABEL_27;
    }
LABEL_28:
    uint64_t v25 = 1;
    goto LABEL_29;
  }
  int v16 = (BOOL *)value;
  LOBYTE(buf) = 1;
  if (!value
    || (CFTypeID v17 = CFGetTypeID(value), v17 != CFBooleanGetTypeID())
    || (ctu::cf::assign((ctu::cf *)&buf, v16, v18), (_BYTE)buf))
  {
    uint64_t v19 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v20;
      uint64_t v21 = "#I SupportsFallbackToLegacyFlow value true. slot:%s";
LABEL_27:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&buf, 0xCu);
      goto LABEL_28;
    }
    goto LABEL_28;
  }
  uint64_t v27 = *(NSObject **)(a1 + 48);
  uint64_t v25 = 0;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = subscriber::asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I SupportsFallbackToLegacyFlow value false. slot:%s", (uint8_t *)&buf, 0xCu);
    uint64_t v25 = 0;
  }
LABEL_29:
  sub_100057D78((const void **)&theDict);
  return v25;
}

void sub_1011C1544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011C15B8(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)buf);
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v23 = v7;
  BOOL v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v23);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 8))(&v21, v13, a2);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v21)
  {
    *(_OWORD *)long long buf = 0uLL;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v21 + 64))(buf);
    if (*(void *)buf)
    {
      uint64_t v15 = sub_100CEBB54(*(uint64_t *)buf);
      if (v15)
      {
        uint64_t v16 = capabilities::ct::supportsSIMTransferWithSecureIntent((capabilities::ct *)v15);
        goto LABEL_23;
      }
    }
    else
    {
      CFBooleanRef v18 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v23 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "missing EntSettings for transfer", v23, 2u);
      }
    }
    uint64_t v16 = 0;
LABEL_23:
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    goto LABEL_25;
  }
  CFTypeID v17 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    uint64_t v20 = subscriber::asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "failed to find CarrierEntitlements for slot:%s", buf, 0xCu);
  }
  uint64_t v16 = 0;
LABEL_25:
  if (v22) {
    sub_10004D2C8(v22);
  }
  return v16;
}

void sub_1011C1848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011C18B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v92 = a2;
  uint64_t v93 = a3;
  uint64_t v8 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    sCardSerialNumberAsString();
    p_p = (long long *)__p;
    if (v72 >= 0) {
      p_p = &__p;
    }
    unsigned int v10 = (void *)(a4 + 16);
    if (*(char *)(a4 + 39) < 0) {
      unsigned int v10 = (void *)*v10;
    }
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "type";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = p_p;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Retrieve transfer %{public}s - csn: [%s] iccid: [%s]", buf, 0x20u);
    if (SHIBYTE(v72) < 0) {
      operator delete((void *)__p);
    }
  }
  if (a5[3]) {
    sub_1011CDD80((void *)(a1 + 480), a5);
  }
  if (!*(void *)(a1 + 504))
  {
    uint64_t v25 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "No callback available", buf, 2u);
    }
    return;
  }
  BOOL v11 = (uint64_t *)(a4 + 16);
  unint64_t v12 = sub_100CCD974((unsigned __int8 **)(a4 + 16), (uint64_t *)(a1 + 608));
  if ((v12 & 0xFF00000000) == 0)
  {
    char v26 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = a4 + 16;
      if (*(char *)(a4 + 39) < 0) {
        uint64_t v27 = *v11;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I cannot find iccid[%s] from sim_on_device. skip transfer", buf, 0xCu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70028;
    v67[0] = 0;
    char v68 = 0;
    sub_1011C39E0(a1, (uint64_t)v67);
    if (!v68) {
      return;
    }
    uint64_t v28 = v67;
LABEL_72:
    sub_1000C5578((uint64_t)v28);
    return;
  }
  uint64_t v13 = v12;
  char v14 = *(NSObject **)(a1 + 48);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (!v13)
  {
    if (v15)
    {
      uint64_t v29 = a4 + 16;
      if (*(char *)(a4 + 39) < 0) {
        uint64_t v29 = *v11;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v29;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I transfer plan [%s] is not enabled", buf, 0xCu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70029;
    v69[0] = 0;
    char v70 = 0;
    sub_1011C39E0(a1, (uint64_t)v69);
    if (!v70) {
      return;
    }
    uint64_t v28 = v69;
    goto LABEL_72;
  }
  if (v15)
  {
    uint64_t v16 = subscriber::asString();
    uint64_t v17 = a4 + 16;
    if (*(char *)(a4 + 39) < 0) {
      uint64_t v17 = *v11;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I transfer plan from slot: %{public}s. iccid: %s", buf, 0x16u);
  }
  sub_1011BEAD4(buf, a1, a4 + 16);
  *(void *)&long long __p = a4 + 16;
  CFBooleanRef v18 = sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)&__p);
  uint64_t v19 = v18 + 56;
  if (v18[79] < 0) {
    operator delete(*(void **)v19);
  }
  *(_OWORD *)uint64_t v19 = *(_OWORD *)buf;
  *((void *)v19 + 2) = *(void *)&buf[16];
  uint64_t v20 = sub_100046F68(a1 + 168, (void **)(a4 + 16));
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 56) + 640))(buf);
  char v21 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 104))(*(void *)buf, v13);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if ((v21 & 1) == 0)
  {
    uint64_t v30 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v40 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v40;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Transfer unsupported for carrier. slot:%s", buf, 0xCu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70036;
    long long v91 = 0u;
    long long v90 = 0u;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    long long v86 = 0u;
    long long v85 = 0u;
    long long v84 = 0u;
    long long v83 = 0u;
    long long v82 = 0u;
    long long v81 = 0u;
    long long v80 = 0u;
    long long v79 = 0u;
    long long v78 = 0u;
    memset(buf, 0, sizeof(buf));
    *(_WORD *)&uint8_t buf[24] = 262;
    BYTE8(v81) = 0;
    if (*(char *)(a4 + 39) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a4 + 16), *(void *)(a4 + 24));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v11;
      uint64_t v66 = *(void *)(a4 + 32);
    }
    sub_1011BB094((uint64_t)&__p, a1, __dst);
    long long v84 = __p;
    *(void *)&long long v85 = v72;
    uint64_t v72 = 0;
    long long __p = 0uLL;
    BYTE8(v85) = 1;
    LOWORD(v86) = 0;
    *((void *)&v86 + 1) = 0;
    long long v87 = 0uLL;
    LOWORD(v88) = 0;
    BYTE2(v88) = 1;
    BYTE8(v88) = 0;
    LOBYTE(v90) = 0;
    BYTE8(v90) = 0;
    LOBYTE(v91) = 0;
    WORD4(v91) = 0;
    if (SHIBYTE(v66) < 0) {
      operator delete(__dst[0]);
    }
    sub_10030DA1C(v63, (long long *)buf);
    char v64 = 1;
    sub_1011C39E0(a1, (uint64_t)v63);
    if (!v64) {
      goto LABEL_71;
    }
    uint64_t v32 = v63;
    goto LABEL_70;
  }
  unsigned int v22 = sub_1011C6BA4(a1, v13);
  unsigned int v23 = *(_DWORD *)(a1 + 424);
  if (v23 < v22)
  {
    uint64_t v24 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v22;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "minimal support version is %x, target version: %x", buf, 0xEu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70027;
    long long v91 = 0u;
    long long v90 = 0u;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    long long v86 = 0u;
    long long v85 = 0u;
    long long v84 = 0u;
    long long v83 = 0u;
    long long v82 = 0u;
    long long v81 = 0u;
    long long v80 = 0u;
    long long v79 = 0u;
    long long v78 = 0u;
    memset(buf, 0, sizeof(buf));
    *(_WORD *)&uint8_t buf[24] = 385;
    BYTE8(v81) = 0;
    if (*(char *)(a4 + 39) < 0)
    {
      sub_10004FC84(v61, *(void **)(a4 + 16), *(void *)(a4 + 24));
    }
    else
    {
      *(_OWORD *)long long v61 = *(_OWORD *)v11;
      uint64_t v62 = *(void *)(a4 + 32);
    }
    sub_1011BB094((uint64_t)&__p, a1, v61);
    long long v84 = __p;
    *(void *)&long long v85 = v72;
    uint64_t v72 = 0;
    long long __p = 0uLL;
    BYTE8(v85) = 1;
    LOWORD(v86) = 0;
    *((void *)&v86 + 1) = 0;
    long long v87 = 0uLL;
    LOWORD(v88) = 0;
    BYTE2(v88) = 1;
    BYTE8(v88) = 0;
    LOBYTE(v90) = 0;
    BYTE8(v90) = 0;
    LOBYTE(v91) = 0;
    WORD4(v91) = 0;
    if (SHIBYTE(v62) < 0) {
      operator delete(v61[0]);
    }
    sub_10030DA1C(v59, (long long *)buf);
    char v60 = 1;
    sub_1011C39E0(a1, (uint64_t)v59);
    if (!v60) {
      goto LABEL_71;
    }
    uint64_t v32 = v59;
LABEL_70:
    sub_1000C5578((uint64_t)v32);
LABEL_71:
    uint64_t v28 = buf;
    goto LABEL_72;
  }
  if ((void **)(a1 + 176) == v20)
  {
    uint64_t v33 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
LABEL_63:
      *(void *)long long buf = a4 + 16;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70016;
      long long v91 = 0u;
      long long v90 = 0u;
      long long v89 = 0u;
      long long v88 = 0u;
      long long v87 = 0u;
      long long v86 = 0u;
      long long v85 = 0u;
      long long v84 = 0u;
      long long v83 = 0u;
      long long v82 = 0u;
      long long v81 = 0u;
      long long v80 = 0u;
      long long v79 = 0u;
      long long v78 = 0u;
      memset(buf, 0, sizeof(buf));
      *(_WORD *)&uint8_t buf[24] = 272;
      BYTE8(v81) = 0;
      if (*(char *)(a4 + 39) < 0)
      {
        sub_10004FC84(v57, *(void **)(a4 + 16), *(void *)(a4 + 24));
      }
      else
      {
        *(_OWORD *)int v57 = *(_OWORD *)v11;
        uint64_t v58 = *(void *)(a4 + 32);
      }
      sub_1011BB094((uint64_t)&__p, a1, v57);
      long long v84 = __p;
      *(void *)&long long v85 = v72;
      uint64_t v72 = 0;
      long long __p = 0uLL;
      BYTE8(v85) = 1;
      LOWORD(v86) = 0;
      *((void *)&v86 + 1) = 0;
      long long v87 = 0uLL;
      LOWORD(v88) = 0;
      BYTE2(v88) = 1;
      BYTE8(v88) = 0;
      LOBYTE(v90) = 0;
      BYTE8(v90) = 0;
      LOBYTE(v91) = 0;
      WORD4(v91) = 0;
      if (SHIBYTE(v58) < 0) {
        operator delete(v57[0]);
      }
      sub_10030DA1C(v55, (long long *)buf);
      char v56 = 1;
      sub_1011C39E0(a1, (uint64_t)v55);
      if (!v56) {
        goto LABEL_71;
      }
      uint64_t v32 = v55;
      goto LABEL_70;
    }
    uint64_t v34 = subscriber::asString();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v34;
    long long v35 = "No entitlement for slot:%{public}s";
    __int16 v36 = v33;
    uint32_t v37 = 12;
LABEL_105:
    _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    goto LABEL_63;
  }
  int v31 = *((_DWORD *)v20 + 14);
  if (v31 != 2)
  {
    std::string::size_type v38 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_63;
    }
    if ((v31 - 1) > 5) {
      long long v47 = "???";
    }
    else {
      long long v47 = off_101A9D0E8[v31 - 1];
    }
    uint64_t v48 = subscriber::asString();
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v47;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v48;
    long long v35 = "entitlement [%{public}s] unsupported. slot:%{public}s";
    __int16 v36 = v38;
    uint32_t v37 = 22;
    goto LABEL_105;
  }
  if (sub_1011C15B8(a1, v13))
  {
    if (*(char *)(a4 + 39) < 0)
    {
      sub_10004FC84(v51, *(void **)(a4 + 16), *(void *)(a4 + 24));
    }
    else
    {
      *(_OWORD *)uint64_t v51 = *(_OWORD *)v11;
      uint64_t v52 = *(void *)(a4 + 32);
    }
    sub_1011BB094((uint64_t)buf, a1, v51);
    uint64_t v41 = (void **)(a1 + 512);
    if (*(char *)(a1 + 535) < 0) {
      operator delete(*v41);
    }
    *(_OWORD *)uint64_t v41 = *(_OWORD *)buf;
    *(void *)(a1 + 528) = *(void *)&buf[16];
    uint8_t buf[23] = 0;
    buf[0] = 0;
    if (SHIBYTE(v52) < 0) {
      operator delete(v51[0]);
    }
    std::string v42 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 535) < 0) {
        uint64_t v41 = (void **)*v41;
      }
      uint64_t v43 = a4 + 16;
      if (*(char *)(a4 + 39) < 0) {
        uint64_t v43 = *v11;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v41;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v43;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Cache IMSI: [%s] for Iccid: [%s]", buf, 0x16u);
    }
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 56) + 640))(buf);
    if ((*(unsigned int (**)(void, uint64_t))(**(void **)buf + 96))(*(void *)buf, v13))
    {
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      *(void *)long long buf = a4 + 16;
      *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 21) = Current;
      buf[0] = 0;
      uint64_t v45 = *(void *)(a1 + 136);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 1174405120;
      aBlock[2] = sub_1011CEA34;
      aBlock[3] = &unk_101A9C8D8;
      aBlock[4] = a1;
      int v76 = v13;
      sub_10010DD9C((uint64_t)v74, a4);
      char v49 = _Block_copy(aBlock);
      (*(void (**)(uint64_t, uint64_t, uint8_t *, void **))(*(void *)v45 + 16))(v45, v13, buf, &v49);
      if (v49) {
        _Block_release(v49);
      }
      if (v75 < 0)
      {
        long long v46 = (void *)v74[2];
LABEL_100:
        operator delete(v46);
      }
    }
    else
    {
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      memset(&v50, 0, sizeof(v50));
      sub_1011CE090(a1, v13, &v50);
      if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
      {
        long long v46 = (void *)v50.__r_.__value_.__r.__words[0];
        goto LABEL_100;
      }
    }
  }
  else
  {
    int v39 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I skip preflight due to secure intent not enabled in CB", buf, 2u);
    }
    v53[0] = 0;
    char v54 = 0;
    sub_1011C39E0(a1, (uint64_t)v53);
    if (v54)
    {
      uint64_t v28 = v53;
      goto LABEL_72;
    }
  }
}

void sub_1011C2538(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011C26B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v90 = a2;
  uint64_t v91 = a3;
  uint64_t v8 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    sCardSerialNumberAsString();
    p_p = (long long *)__p;
    if (v70 >= 0) {
      p_p = &__p;
    }
    unsigned int v10 = (void *)(a4 + 16);
    if (*(char *)(a4 + 39) < 0) {
      unsigned int v10 = (void *)*v10;
    }
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "token";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = p_p;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Retrieve transfer %{public}s - csn: [%s] iccid: [%s]", buf, 0x20u);
    if (SHIBYTE(v70) < 0) {
      operator delete((void *)__p);
    }
  }
  if (a5[3]) {
    sub_1011CDD80((void *)(a1 + 480), a5);
  }
  if (!*(void *)(a1 + 504))
  {
    uint64_t v25 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "No callback available", buf, 2u);
    }
    return;
  }
  BOOL v11 = (uint64_t *)(a4 + 16);
  unint64_t v12 = sub_100CCD974((unsigned __int8 **)(a4 + 16), (uint64_t *)(a1 + 608));
  if ((v12 & 0xFF00000000) == 0)
  {
    char v26 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = a4 + 16;
      if (*(char *)(a4 + 39) < 0) {
        uint64_t v27 = *v11;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I cannot find iccid[%s] from sim_on_device. skip transfer", buf, 0xCu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70028;
    v65[0] = 0;
    char v66 = 0;
    sub_1011C39E0(a1, (uint64_t)v65);
    if (!v66) {
      return;
    }
    uint64_t v28 = v65;
LABEL_71:
    sub_1000C5578((uint64_t)v28);
    return;
  }
  uint64_t v13 = v12;
  char v14 = *(NSObject **)(a1 + 48);
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (!v13)
  {
    if (v15)
    {
      uint64_t v29 = a4 + 16;
      if (*(char *)(a4 + 39) < 0) {
        uint64_t v29 = *v11;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v29;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I transfer plan [%s] is not enabled", buf, 0xCu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70029;
    v67[0] = 0;
    char v68 = 0;
    sub_1011C39E0(a1, (uint64_t)v67);
    if (!v68) {
      return;
    }
    uint64_t v28 = v67;
    goto LABEL_71;
  }
  if (v15)
  {
    uint64_t v16 = subscriber::asString();
    uint64_t v17 = a4 + 16;
    if (*(char *)(a4 + 39) < 0) {
      uint64_t v17 = *v11;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I transfer plan from slot: %{public}s. iccid: %s", buf, 0x16u);
  }
  sub_1011BEAD4(buf, a1, a4 + 16);
  *(void *)&long long __p = a4 + 16;
  CFBooleanRef v18 = sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)&__p);
  uint64_t v19 = v18 + 56;
  if (v18[79] < 0) {
    operator delete(*(void **)v19);
  }
  *(_OWORD *)uint64_t v19 = *(_OWORD *)buf;
  *((void *)v19 + 2) = *(void *)&buf[16];
  uint64_t v20 = sub_100046F68(a1 + 168, (void **)(a4 + 16));
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 56) + 640))(buf);
  char v21 = (*(uint64_t (**)(void, uint64_t))(**(void **)buf + 104))(*(void *)buf, v13);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if ((v21 & 1) == 0)
  {
    uint64_t v30 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v39 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v39;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Transfer unsupported for carrier. slot:%s", buf, 0xCu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70036;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    long long v86 = 0u;
    long long v85 = 0u;
    long long v84 = 0u;
    long long v83 = 0u;
    long long v82 = 0u;
    long long v81 = 0u;
    long long v80 = 0u;
    long long v79 = 0u;
    long long v78 = 0u;
    long long v77 = 0u;
    long long v76 = 0u;
    memset(buf, 0, sizeof(buf));
    *(_WORD *)&uint8_t buf[24] = 262;
    BYTE8(v79) = 0;
    if (*(char *)(a4 + 39) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a4 + 16), *(void *)(a4 + 24));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v11;
      uint64_t v64 = *(void *)(a4 + 32);
    }
    sub_1011BB094((uint64_t)&__p, a1, __dst);
    long long v82 = __p;
    *(void *)&long long v83 = v70;
    uint64_t v70 = 0;
    long long __p = 0uLL;
    BYTE8(v83) = 1;
    LOWORD(v84) = 0;
    *((void *)&v84 + 1) = 0;
    long long v85 = 0uLL;
    LOWORD(v86) = 0;
    BYTE2(v86) = 1;
    BYTE8(v86) = 0;
    LOBYTE(v88) = 0;
    BYTE8(v88) = 0;
    LOBYTE(v89) = 0;
    WORD4(v89) = 0;
    if (SHIBYTE(v64) < 0) {
      operator delete(__dst[0]);
    }
    sub_10030DA1C(v61, (long long *)buf);
    char v62 = 1;
    sub_1011C39E0(a1, (uint64_t)v61);
    if (!v62) {
      goto LABEL_70;
    }
    uint64_t v32 = v61;
    goto LABEL_69;
  }
  unsigned int v22 = sub_1011C6BA4(a1, v13);
  unsigned int v23 = *(_DWORD *)(a1 + 424);
  if (v23 < v22)
  {
    uint64_t v24 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v22;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "minimal support version is %x, target version: %x", buf, 0xEu);
    }
    *(void *)long long buf = a4 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70027;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    long long v86 = 0u;
    long long v85 = 0u;
    long long v84 = 0u;
    long long v83 = 0u;
    long long v82 = 0u;
    long long v81 = 0u;
    long long v80 = 0u;
    long long v79 = 0u;
    long long v78 = 0u;
    long long v77 = 0u;
    long long v76 = 0u;
    memset(buf, 0, sizeof(buf));
    *(_WORD *)&uint8_t buf[24] = 385;
    BYTE8(v79) = 0;
    if (*(char *)(a4 + 39) < 0)
    {
      sub_10004FC84(v59, *(void **)(a4 + 16), *(void *)(a4 + 24));
    }
    else
    {
      *(_OWORD *)char v59 = *(_OWORD *)v11;
      uint64_t v60 = *(void *)(a4 + 32);
    }
    sub_1011BB094((uint64_t)&__p, a1, v59);
    long long v82 = __p;
    *(void *)&long long v83 = v70;
    uint64_t v70 = 0;
    long long __p = 0uLL;
    BYTE8(v83) = 1;
    LOWORD(v84) = 0;
    *((void *)&v84 + 1) = 0;
    long long v85 = 0uLL;
    LOWORD(v86) = 0;
    BYTE2(v86) = 1;
    BYTE8(v86) = 0;
    LOBYTE(v88) = 0;
    BYTE8(v88) = 0;
    LOBYTE(v89) = 0;
    WORD4(v89) = 0;
    if (SHIBYTE(v60) < 0) {
      operator delete(v59[0]);
    }
    sub_10030DA1C(v57, (long long *)buf);
    char v58 = 1;
    sub_1011C39E0(a1, (uint64_t)v57);
    if (!v58) {
      goto LABEL_70;
    }
    uint64_t v32 = v57;
LABEL_69:
    sub_1000C5578((uint64_t)v32);
LABEL_70:
    uint64_t v28 = buf;
    goto LABEL_71;
  }
  if ((void **)(a1 + 176) == v20)
  {
    uint64_t v33 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
LABEL_62:
      *(void *)long long buf = a4 + 16;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 20) = 70016;
      long long v89 = 0u;
      long long v88 = 0u;
      long long v87 = 0u;
      long long v86 = 0u;
      long long v85 = 0u;
      long long v84 = 0u;
      long long v83 = 0u;
      long long v82 = 0u;
      long long v81 = 0u;
      long long v80 = 0u;
      long long v79 = 0u;
      long long v78 = 0u;
      long long v77 = 0u;
      long long v76 = 0u;
      memset(buf, 0, sizeof(buf));
      *(_WORD *)&uint8_t buf[24] = 272;
      BYTE8(v79) = 0;
      if (*(char *)(a4 + 39) < 0)
      {
        sub_10004FC84(v55, *(void **)(a4 + 16), *(void *)(a4 + 24));
      }
      else
      {
        *(_OWORD *)long long v55 = *(_OWORD *)v11;
        uint64_t v56 = *(void *)(a4 + 32);
      }
      sub_1011BB094((uint64_t)&__p, a1, v55);
      long long v82 = __p;
      *(void *)&long long v83 = v70;
      uint64_t v70 = 0;
      long long __p = 0uLL;
      BYTE8(v83) = 1;
      LOWORD(v84) = 0;
      *((void *)&v84 + 1) = 0;
      long long v85 = 0uLL;
      LOWORD(v86) = 0;
      BYTE2(v86) = 1;
      BYTE8(v86) = 0;
      LOBYTE(v88) = 0;
      BYTE8(v88) = 0;
      LOBYTE(v89) = 0;
      WORD4(v89) = 0;
      if (SHIBYTE(v56) < 0) {
        operator delete(v55[0]);
      }
      sub_10030DA1C(v53, (long long *)buf);
      char v54 = 1;
      sub_1011C39E0(a1, (uint64_t)v53);
      if (!v54) {
        goto LABEL_70;
      }
      uint64_t v32 = v53;
      goto LABEL_69;
    }
    uint64_t v34 = subscriber::asString();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v34;
    long long v35 = "No entitlement for slot:%{public}s";
    __int16 v36 = v33;
    uint32_t v37 = 12;
LABEL_100:
    _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    goto LABEL_62;
  }
  int v31 = *((_DWORD *)v20 + 14);
  if (v31 != 2)
  {
    std::string::size_type v38 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      goto LABEL_62;
    }
    if ((v31 - 1) > 5) {
      long long v46 = "???";
    }
    else {
      long long v46 = off_101A9D0E8[v31 - 1];
    }
    uint64_t v47 = subscriber::asString();
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v46;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v47;
    long long v35 = "entitlement [%{public}s] unsupported. slot:%{public}s";
    __int16 v36 = v38;
    uint32_t v37 = 22;
    goto LABEL_100;
  }
  if (*(char *)(a4 + 39) < 0)
  {
    sub_10004FC84(v51, *(void **)(a4 + 16), *(void *)(a4 + 24));
  }
  else
  {
    *(_OWORD *)uint64_t v51 = *(_OWORD *)v11;
    uint64_t v52 = *(void *)(a4 + 32);
  }
  sub_1011BB094((uint64_t)buf, a1, v51);
  uint64_t v40 = (void **)(a1 + 512);
  if (*(char *)(a1 + 535) < 0) {
    operator delete(*v40);
  }
  *(_OWORD *)uint64_t v40 = *(_OWORD *)buf;
  *(void *)(a1 + 528) = *(void *)&buf[16];
  uint8_t buf[23] = 0;
  buf[0] = 0;
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
  uint64_t v41 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 535) < 0) {
      uint64_t v40 = (void **)*v40;
    }
    uint64_t v42 = a4 + 16;
    if (*(char *)(a4 + 39) < 0) {
      uint64_t v42 = *v11;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v40;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v42;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Cache IMSI: [%s] for Iccid: [%s]", buf, 0x16u);
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 56) + 640))(buf);
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)buf + 96))(*(void *)buf, v13))
  {
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(void *)long long buf = a4 + 16;
    *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(a4 + 16), (long long **)buf) + 27) = Current;
    buf[0] = 0;
    uint64_t v44 = *(void *)(a1 + 136);
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_1011D055C;
    aBlock[3] = &unk_101A9C998;
    aBlock[4] = a1;
    int v74 = v13;
    sub_10010DD9C((uint64_t)v72, a4);
    uint64_t v48 = _Block_copy(aBlock);
    (*(void (**)(uint64_t, uint64_t, uint8_t *, void **))(*(void *)v44 + 16))(v44, v13, buf, &v48);
    if (v48) {
      _Block_release(v48);
    }
    if (v73 < 0)
    {
      uint64_t v45 = (void *)v72[2];
LABEL_95:
      operator delete(v45);
    }
  }
  else
  {
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v50 = 0;
    long long v49 = 0uLL;
    sub_1011CF674(a1, v13, &v49);
    if (SHIBYTE(v50) < 0)
    {
      uint64_t v45 = (void *)v49;
      goto LABEL_95;
    }
  }
}

void sub_1011C32C4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011C3428(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 256))
  {
    sub_10030DA1C((char *)&v4, (long long *)a2);
    if (*(void *)(a1 + 360))
    {
      uint64_t v3 = *(void *)(a1 + 336);
      if (a1 + 352 != v3)
      {
        if (!HIBYTE(v5) && *(unsigned char *)(v3 + 89)) {
          __int16 v5 = *(_WORD *)(v3 + 88);
        }
        sub_100B62F98(v3 + 64, &v4);
      }
    }
    sub_1000C5578((uint64_t)&v4);
  }
  sub_1011BBE34(a1);
}

uint64_t sub_1011C34AC(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1011C34E8(uint64_t a1, uint64_t a2, const std::string *a3, uint64_t a4, int a5)
{
  if (!*(void *)(a1 + 360) || (uint64_t v6 = *(void *)(a1 + 336), v6 == a1 + 352))
  {
    uint64_t v13 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "invalid iterator. skip token generation request", (uint8_t *)&buf, 2u);
    }
  }
  else
  {
    if (a5 > 0)
    {
      *(void *)&long long v42 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long buf = 0u;
      WORD3(v31) = 257;
      int v11 = capabilities::ct::supportsSIMTransferWithSecureIntent((capabilities::ct *)a1);
      uint64_t v12 = 2;
      if (v11) {
        uint64_t v12 = 3;
      }
      *((void *)&v41 + 1) = v12;
      LOBYTE(v42) = 1;
      if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
      {
        if (!a3->__r_.__value_.__l.__size_)
        {
LABEL_17:
          BOOL v15 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v16 = v6 + 32;
            if (*(char *)(v6 + 55) < 0) {
              uint64_t v16 = *(void *)(v6 + 32);
            }
            *(_DWORD *)uint64_t v45 = 136315138;
            *(void *)&v45[4] = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [req][tap] perform TransferAuthorization request for token. iccid : %s", v45, 0xCu);
          }
          uint64_t v17 = *(void *)(a1 + 136);
          aBlock[0] = _NSConcreteStackBlock;
          aBlock[1] = 1174405120;
          aBlock[2] = sub_1011C3B94;
          aBlock[3] = &unk_101A9C2F0;
          aBlock[4] = a1;
          int v23 = a5;
          int v24 = a2;
          if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(&__p, a3->__r_.__value_.__l.__data_, a3->__r_.__value_.__l.__size_);
          }
          else
          {
            long long __p = *(_OWORD *)&a3->__r_.__value_.__l.__data_;
            std::string::size_type v21 = a3->__r_.__value_.__r.__words[2];
          }
          char v25 = a4;
          uint64_t v22 = v6 + 32;
          char v26 = _Block_copy(aBlock);
          (*(void (**)(uint64_t, uint64_t, long long *, uint64_t, void **))(*(void *)v17 + 32))(v17, a2, &buf, a4, &v26);
          if (v26) {
            _Block_release(v26);
          }
          if (SHIBYTE(v21) < 0) {
            operator delete((void *)__p);
          }
          sub_1001A0540((uint64_t)&v31 + 8);
          if (BYTE8(v30))
          {
            if (SBYTE7(v30) < 0) {
              operator delete((void *)buf);
            }
          }
          return;
        }
      }
      else if (!*((unsigned char *)&a3->__r_.__value_.__s + 23))
      {
        goto LABEL_17;
      }
      sub_100093B44((std::string *)&buf, a3);
      goto LABEL_17;
    }
    char v14 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Transfer Auth failed. Retries exhausted", (uint8_t *)&buf, 2u);
    }
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long buf = 0u;
    long long v30 = 0u;
    WORD4(v30) = 272;
    BYTE8(v34) = 0;
    if (*(char *)(a1 + 535) < 0)
    {
      sub_10004FC84(&v37, *(void **)(a1 + 512), *(void *)(a1 + 520));
    }
    else
    {
      long long v37 = *(_OWORD *)(a1 + 512);
      *(void *)&long long v38 = *(void *)(a1 + 528);
    }
    BYTE8(v38) = 1;
    LOWORD(v39) = 0;
    *((void *)&v39 + 1) = 0;
    long long v40 = 0uLL;
    LOWORD(v41) = 0;
    BYTE2(v41) = 3;
    BYTE8(v41) = 0;
    LOBYTE(v43) = 0;
    BYTE8(v43) = 0;
    LOBYTE(v44) = 0;
    WORD4(v44) = 0;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(void *)uint64_t v45 = v6 + 32;
    *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(v6 + 32), (long long **)v45) + 30) = Current;
    *(void *)uint64_t v45 = v6 + 32;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)(v6 + 32), (long long **)v45) + 20) = 70048;
    sub_10030DA1C(__dst, &buf);
    char v28 = 1;
    sub_1011C39E0(a1, (uint64_t)__dst);
    if (v28) {
      sub_1000C5578((uint64_t)__dst);
    }
    sub_1000C5578((uint64_t)&buf);
  }
}

void sub_1011C3904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *aBlock,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,uint64_t a61,void *a62,uint64_t a63)
{
  if (a76 && a75 < 0) {
    operator delete(__p);
  }
  if (a73 && a72 < 0) {
    operator delete(a69);
  }
  if (a68 && a67 < 0) {
    operator delete(a62);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

void *sub_1011C39E0(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)(a1 + 504);
  if (result)
  {
    uint64_t v5 = a1 + 480;
    long long v8 = 0u;
    long long v9 = 0u;
    if (result == (void *)(a1 + 480))
    {
      *((void *)&v9 + 1) = &v8;
      (*(void (**)(void *, long long *))(*result + 24))(result, &v8);
      uint64_t v6 = *(void *)(a1 + 504);
      *(void *)(a1 + 504) = 0;
      if (v6 == v5)
      {
        (*(void (**)(uint64_t))(*(void *)v5 + 32))(a1 + 480);
      }
      else if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
      }
    }
    else
    {
      *((void *)&v9 + 1) = result;
      *(void *)(a1 + 504) = 0;
    }
    sub_10030D9BC(__dst, a2);
    if (!*((void *)&v9 + 1)) {
      sub_10007B600();
    }
    (*(void (**)(void, char *))(**((void **)&v9 + 1) + 48))(*((void *)&v9 + 1), __dst);
    if (__dst[256]) {
      sub_1000C5578((uint64_t)__dst);
    }
    return sub_100313814(&v8);
  }
  return result;
}

void sub_1011C3B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011C3B94(uint64_t a1, uint64_t a2, char a3, int a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (a4)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(void *)long long buf = *(void *)(a1 + 64);
    *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v5 + 784), *(void ***)buf, (long long **)buf) + 30) = Current;
    if (a3)
    {
      if (*(unsigned char *)(a2 + 1))
      {
        __int16 v9 = sub_1008A1FE0(*(unsigned char *)a2);
        __int16 v10 = 1;
      }
      else
      {
        __int16 v9 = 0;
        __int16 v10 = 0;
      }
      *(_OWORD *)long long __dst = 0u;
      *(_OWORD *)__src = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      if (*(unsigned char *)(a2 + 32)) {
        sub_100093B44((std::string *)__dst, (const std::string *)(a2 + 8));
      }
      if (*(unsigned char *)(a2 + 64)) {
        sub_100093B44((std::string *)&v59, (const std::string *)(a2 + 40));
      }
      if (!*(unsigned char *)(a2 + 544)) {
        goto LABEL_55;
      }
      uint64_t v22 = *(unsigned __int8 *)(a2 + 543);
      if ((v22 & 0x80u) != 0) {
        uint64_t v22 = *(void *)(a2 + 528);
      }
      if (v22)
      {
        if (LOBYTE(__src[1]))
        {
          if (SHIBYTE(__src[0]) < 0) {
            operator delete(__dst[0]);
          }
          LOBYTE(__src[1]) = 0;
        }
        if (BYTE8(v60))
        {
          if (SBYTE7(v60) < 0) {
            operator delete((void *)v59);
          }
          BYTE8(v60) = 0;
        }
        *(void *)long long buf = *(void *)(a1 + 64);
        *((_DWORD *)sub_1011C81F0((uint64_t **)(v5 + 784), *(void ***)buf, (long long **)buf) + 20) = 70050;
        if (!*(unsigned char *)(a2 + 544)) {
          sub_10016C840();
        }
        *(void *)long long buf = *(void *)(a1 + 64);
        int v23 = sub_1011C81F0((uint64_t **)(v5 + 784), *(void ***)buf, (long long **)buf);
        sub_100093B44((std::string *)(v23 + 128), (const std::string *)(a2 + 520));
        char v24 = 7;
        __int16 v10 = 1;
        __int16 v9 = 16;
      }
      else
      {
LABEL_55:
        char v24 = 0;
      }
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      *(_OWORD *)long long v32 = 0u;
      *(_OWORD *)long long buf = 0u;
      *(_OWORD *)long long __p = 0u;
      LOWORD(__p[1]) = v9 | (v10 << 8);
      sub_1000593FC((uint64_t)&v31, (long long *)__dst);
      sub_1000593FC((uint64_t)&v33, &v59);
      sub_1000593FC((uint64_t)&v35, (long long *)(a2 + 232));
      if (*(char *)(v5 + 535) < 0)
      {
        sub_10004FC84(&v37, *(void **)(v5 + 512), *(void *)(v5 + 520));
      }
      else
      {
        long long v37 = *(_OWORD *)(v5 + 512);
        *(void *)&long long v38 = *(void *)(v5 + 528);
      }
      BYTE8(v38) = 1;
      LOWORD(v39) = 0;
      *((void *)&v39 + 1) = 0;
      long long v40 = 0uLL;
      LOWORD(v41) = 0;
      BYTE2(v41) = v24;
      sub_1000593FC((uint64_t)&v41 + 8, (long long *)(a2 + 520));
      BYTE8(v43) = 0;
      LOBYTE(v44) = 0;
      WORD4(v44) = 0;
      sub_10030DA1C(v25, (long long *)buf);
      char v26 = 1;
      sub_1011C39E0(v5, (uint64_t)v25);
      if (v26) {
        sub_1000C5578((uint64_t)v25);
      }
      sub_1000C5578((uint64_t)buf);
      if (BYTE8(v60) && SBYTE7(v60) < 0) {
        operator delete((void *)v59);
      }
      if (LOBYTE(__src[1]))
      {
        if (SHIBYTE(__src[0]) < 0) {
          operator delete(__dst[0]);
        }
      }
    }
    else
    {
      uint64_t v12 = *(NSObject **)(v5 + 48);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Transfer Auth failed by carrier", buf, 2u);
      }
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      *(_OWORD *)long long v32 = 0u;
      *(_OWORD *)long long buf = 0u;
      *(_OWORD *)long long __p = 0u;
      LOWORD(__p[1]) = 272;
      BYTE8(v34) = 0;
      if (*(char *)(v5 + 535) < 0)
      {
        sub_10004FC84(&v37, *(void **)(v5 + 512), *(void *)(v5 + 520));
      }
      else
      {
        long long v37 = *(_OWORD *)(v5 + 512);
        *(void *)&long long v38 = *(void *)(v5 + 528);
      }
      BYTE8(v38) = 1;
      LOWORD(v39) = 0;
      *((void *)&v39 + 1) = 0;
      long long v40 = 0uLL;
      LOWORD(v41) = 0;
      BYTE2(v41) = 2;
      BYTE8(v41) = 0;
      LOBYTE(v43) = 0;
      BYTE8(v43) = 0;
      LOBYTE(v44) = 0;
      WORD4(v44) = 0;
      __dst[0] = *(void **)(a1 + 64);
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v5 + 784), (void **)__dst[0], (long long **)__dst) + 20) = 70032;
      sub_10030DA1C(v27, (long long *)buf);
      char v28 = 1;
      sub_1011C39E0(v5, (uint64_t)v27);
      if (v28) {
        sub_1000C5578((uint64_t)v27);
      }
      sub_1000C5578((uint64_t)buf);
    }
  }
  else
  {
    (***(void (****)(Registry **__return_ptr))(v5 + 56))(&v53);
    Registry::getTimerService(&v55, v53);
    uint64_t v11 = v55;
    sub_100058DB0(&v51, "ent.retry.timer");
    __dst[0] = (void *)v5;
    LODWORD(__dst[1]) = *(_DWORD *)(a1 + 76);
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(__src, *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)__src = *(_OWORD *)(a1 + 40);
      uint64_t v47 = *(void *)(a1 + 56);
    }
    LOBYTE(v48) = *(unsigned char *)(a1 + 80);
    HIDWORD(v48) = *(_DWORD *)(a1 + 72) - 1;
    uint64_t v13 = *(std::__shared_weak_count **)(v5 + 24);
    if (!v13 || (char v14 = *(std::__shared_weak_count **)(v5 + 16), (v15 = std::__shared_weak_count::lock(v13)) == 0)) {
      sub_100088B9C();
    }
    long long v49 = v14;
    uint64_t v50 = v15;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    long long v57 = v51;
    uint64_t v58 = v52;
    long long v51 = 0uLL;
    uint64_t v52 = 0;
    *(void **)long long buf = __dst[0];
    *(_DWORD *)&uint8_t buf[8] = __dst[1];
    if (SHIBYTE(v47) < 0)
    {
      sub_10004FC84(__p, __src[0], (unint64_t)__src[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)__src;
      *(void *)&long long v31 = v47;
    }
    uint64_t v16 = v48;
    uint64_t v17 = v49;
    *((void *)&v31 + 1) = v48;
    v32[0] = v49;
    CFBooleanRef v18 = v50;
    v32[1] = v50;
    long long v49 = 0;
    uint64_t v50 = 0;
    *((void *)&v60 + 1) = 0;
    uint64_t v19 = (char *)operator new(0x48uLL);
    uint64_t v20 = *(void *)buf;
    *(void *)uint64_t v19 = off_101A9CB58;
    *((void *)v19 + 1) = v20;
    *((_DWORD *)v19 + 4) = *(_DWORD *)&buf[8];
    std::string::size_type v21 = v19 + 24;
    if (SBYTE7(v31) < 0)
    {
      sub_10004FC84(v21, __p[0], (unint64_t)__p[1]);
      uint64_t v16 = *((void *)&v31 + 1);
      uint64_t v17 = v32[0];
      CFBooleanRef v18 = v32[1];
    }
    else
    {
      *(_OWORD *)std::string::size_type v21 = *(_OWORD *)__p;
      *((void *)v19 + 5) = v31;
    }
    *((void *)v19 + 6) = v16;
    *((void *)v19 + 7) = v17;
    *((void *)v19 + 8) = v18;
    v32[0] = 0;
    v32[1] = 0;
    *((void *)&v60 + 1) = v19;
    (*(void (**)(uint64_t, long long *, uint64_t, uint64_t, long long *))(*(void *)v11 + 32))(v11, &v57, 2, 1000000, &v59);
    sub_10003B34C(&v59);
    if (v32[1]) {
      std::__shared_weak_count::__release_weak(v32[1]);
    }
    if (SBYTE7(v31) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v58) < 0) {
      operator delete((void *)v57);
    }
    if (v50) {
      std::__shared_weak_count::__release_weak(v50);
    }
    if (SHIBYTE(v47) < 0) {
      operator delete(__src[0]);
    }
    if (SHIBYTE(v52) < 0) {
      operator delete((void *)v51);
    }
    if (v56) {
      sub_10004D2C8(v56);
    }
    if (v54) {
      sub_10004D2C8(v54);
    }
  }
}

void sub_1011C424C(_Unwind_Exception *a1)
{
  if (LOBYTE(STACK[0x288]) && SLOBYTE(STACK[0x287]) < 0) {
    operator delete((void *)STACK[0x270]);
  }
  if (LOBYTE(STACK[0x268]) && SLOBYTE(STACK[0x267]) < 0) {
    operator delete((void *)STACK[0x250]);
  }
  if (LOBYTE(STACK[0x248]) && SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  if (SLOBYTE(STACK[0x227]) < 0) {
    operator delete((void *)STACK[0x210]);
  }
  if (*(unsigned char *)(v1 - 104) && *(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  if (LOBYTE(STACK[0x328]))
  {
    if (SLOBYTE(STACK[0x327]) < 0) {
      operator delete((void *)STACK[0x310]);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011C4490(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1011C44D0(uint64_t a1, uint64_t a2, char a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 32);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  __int16 v10 = (uint64_t **)(v8 + 784);
  uint64_t v11 = (void **)(a1 + 40);
  *(void *)&long long buf = a1 + 40;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v8 + 784), (void **)(a1 + 40), (long long **)&buf) + 24) = Current;
  if ((a3 & 1) == 0)
  {
    char v26 = *(NSObject **)(v8 + 48);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      if ((a4 - 1) > 2) {
        long long v36 = "RequestCanceled";
      }
      else {
        long long v36 = off_101A9D118[a4 - 1];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v36;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "TA for type request failed. EventCause: [%s]", (uint8_t *)&buf, 0xCu);
      char v26 = *(NSObject **)(v8 + 48);
    }
    BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    if (a4 == 3)
    {
      if (v27)
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "request transfer type failed due to carrier error", (uint8_t *)&buf, 2u);
      }
      *(void *)&long long buf = a1 + 40;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v8 + 784), (void **)(a1 + 40), (long long **)&buf) + 20) = 70030;
      long long buf = 0uLL;
      *(void *)&long long v113 = 0;
      WORD4(v113) = 256;
      LOBYTE(v114) = 0;
      BYTE8(v115) = 0;
      LOBYTE(v116) = 0;
      BYTE8(v117) = 0;
      LOBYTE(v118) = 0;
      BYTE8(v119) = 0;
      if (*(char *)(v8 + 535) < 0)
      {
        sub_10004FC84(&v120, *(void **)(v8 + 512), *(void *)(v8 + 520));
      }
      else
      {
        long long v120 = *(_OWORD *)(v8 + 512);
        *(void *)&long long v121 = *(void *)(v8 + 528);
      }
      BYTE8(v121) = 1;
      LOWORD(v122) = 0;
      *((void *)&v122 + 1) = 0;
      long long v123 = 0uLL;
      LOWORD(v124) = 0;
      BYTE2(v124) = 4;
      BYTE8(v124) = 0;
      LOBYTE(v126) = 0;
      BYTE8(v126) = 0;
      LOBYTE(v127) = 0;
      WORD4(v127) = 0;
      sub_1011C7D34((uint64_t)v84, &buf);
      sub_1011C39E0(v8, (uint64_t)v84);
      if (!v84[256]) {
        goto LABEL_64;
      }
      char v28 = v84;
    }
    else
    {
      if (v27)
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Transfer Auth for type failed due to internal error", (uint8_t *)&buf, 2u);
      }
      *(void *)&long long buf = a1 + 40;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v8 + 784), (void **)(a1 + 40), (long long **)&buf) + 20) = 70047;
      long long buf = 0uLL;
      *(void *)&long long v113 = 0;
      WORD4(v113) = 256;
      LOBYTE(v114) = 0;
      BYTE8(v115) = 0;
      LOBYTE(v116) = 0;
      BYTE8(v117) = 0;
      LOBYTE(v118) = 0;
      BYTE8(v119) = 0;
      if (*(char *)(v8 + 535) < 0)
      {
        sub_10004FC84(&v120, *(void **)(v8 + 512), *(void *)(v8 + 520));
      }
      else
      {
        long long v120 = *(_OWORD *)(v8 + 512);
        *(void *)&long long v121 = *(void *)(v8 + 528);
      }
      BYTE8(v121) = 1;
      LOWORD(v122) = 0;
      *((void *)&v122 + 1) = 0;
      long long v123 = 0uLL;
      LOWORD(v124) = 0;
      BYTE2(v124) = 5;
      BYTE8(v124) = 0;
      LOBYTE(v126) = 0;
      BYTE8(v126) = 0;
      LOBYTE(v127) = 0;
      WORD4(v127) = 0;
      sub_1011C7D34((uint64_t)v83, &buf);
      sub_1011C39E0(v8, (uint64_t)v83);
      if (!v83[256]) {
        goto LABEL_64;
      }
      char v28 = v83;
    }
    goto LABEL_63;
  }
  int v12 = *(unsigned __int8 *)(a2 + 1);
  if (!*(unsigned char *)(a2 + 1) || *(unsigned char *)a2 || !*(unsigned char *)(a2 + 480))
  {
LABEL_49:
    if (!v12)
    {
      __int16 v31 = 0;
LABEL_52:
      long long v32 = (long long *)(a2 + 520);
      if (!*(unsigned char *)(a2 + 544)) {
        goto LABEL_57;
      }
      uint64_t v33 = *(unsigned __int8 *)(a2 + 543);
      if ((v33 & 0x80u) != 0) {
        uint64_t v33 = *(void *)(a2 + 528);
      }
      if (v33)
      {
        *(void *)&long long buf = v11;
        *((_DWORD *)sub_1011C81F0(v10, v11, (long long **)&buf) + 20) = 70051;
        *(void *)&long long buf = v11;
        long long v34 = sub_1011C81F0(v10, v11, (long long **)&buf);
        sub_100179AF8((std::string *)(v34 + 128), (const std::string *)(a2 + 520));
        char v35 = 8;
        __int16 v31 = 16;
      }
      else
      {
LABEL_57:
        char v35 = 0;
      }
      *(void *)&long long buf = v11;
      *((_WORD *)sub_1011C81F0(v10, v11, (long long **)&buf) + 60) = v31 | 0x100;
      long long v126 = 0u;
      long long v127 = 0u;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v122 = 0u;
      long long v123 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      long long v114 = 0u;
      long long v115 = 0u;
      long long buf = 0u;
      long long v113 = 0u;
      BYTE8(v113) = v31;
      BYTE9(v113) = 1;
      BYTE8(v117) = 0;
      if (*(char *)(v8 + 535) < 0)
      {
        sub_10004FC84(&v120, *(void **)(v8 + 512), *(void *)(v8 + 520));
      }
      else
      {
        long long v120 = *(_OWORD *)(v8 + 512);
        *(void *)&long long v121 = *(void *)(v8 + 528);
      }
      BYTE8(v121) = 1;
      LOWORD(v122) = 0;
      *((void *)&v122 + 1) = 0;
      long long v123 = 0uLL;
      LOWORD(v124) = 0;
      BYTE2(v124) = v35;
      sub_1000593FC((uint64_t)&v124 + 8, v32);
      BYTE8(v126) = 0;
      LOBYTE(v127) = 0;
      WORD4(v127) = 0;
      sub_10030DA1C(v71, &buf);
      char v72 = 1;
      sub_1011C39E0(v8, (uint64_t)v71);
      if (!v72) {
        goto LABEL_64;
      }
      char v28 = v71;
      goto LABEL_63;
    }
LABEL_50:
    __int16 v31 = sub_1008A1FE0(*(unsigned char *)a2);
    goto LABEL_52;
  }
  uint64_t v13 = *(unsigned __int8 *)(a2 + 479);
  if ((v13 & 0x80u) != 0) {
    uint64_t v13 = *(void *)(a2 + 464);
  }
  if (!v13 || !*(unsigned char *)(a2 + 512)) {
    goto LABEL_50;
  }
  uint64_t v14 = *(unsigned int *)(a1 + 64);
  long long buf = 0uLL;
  (***(void (****)(long long *__return_ptr))(v8 + 56))(&v87);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v15, (Registry *)v87);
  uint64_t v17 = ServiceMap;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long __dst = v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&__dst);
  if (v22)
  {
    uint64_t v24 = v22[3];
    int v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      __int16 v10 = (uint64_t **)(v8 + 784);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  int v23 = 0;
  char v25 = 1;
LABEL_33:
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v24 + 8))(&buf, v24, v14);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (*((void *)&v87 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v87 + 1));
  }
  if ((void)buf)
  {
    char v29 = (*(uint64_t (**)(void, uint64_t, const __CFString *))(*(void *)buf + 88))(buf, 8, @"EntitlementRequestViaWebService");
  }
  else
  {
    long long v30 = *(NSObject **)(v8 + 48);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v69 = subscriber::asString();
      LODWORD(v87) = 136315138;
      *(void *)((char *)&v87 + 4) = v69;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "failed to find CarrierEntitlements for slot:%s", (uint8_t *)&v87, 0xCu);
    }
    char v29 = 0;
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if ((v29 & 1) == 0)
  {
    int v12 = *(unsigned __int8 *)(a2 + 1);
    goto LABEL_49;
  }
  if (!*(void *)(v8 + 152))
  {
    uint64_t v37 = *(void *)(v8 + 56);
    if (!v37) {
      goto LABEL_134;
    }
    (*(void (**)(long long *__return_ptr))(*(void *)v37 + 592))(&buf);
    long long v38 = buf;
    long long buf = 0uLL;
    long long v39 = *(std::__shared_weak_count **)(v8 + 160);
    *(_OWORD *)(v8 + 152) = v38;
    if (v39)
    {
      sub_10004D2C8(v39);
      if (*((void *)&buf + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
      }
      uint64_t v40 = *(void *)(v8 + 152);
    }
    else
    {
      uint64_t v40 = v38;
    }
    if (!v40)
    {
LABEL_134:
      char v68 = *(NSObject **)(v8 + 48);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "invalid webservice delegate", (uint8_t *)&buf, 2u);
      }
      *(void *)&long long buf = a1 + 40;
      *((_DWORD *)sub_1011C81F0(v10, (void **)(a1 + 40), (long long **)&buf) + 20) = 70013;
      long long buf = 0uLL;
      *(void *)&long long v113 = 0;
      WORD4(v113) = 256;
      LOBYTE(v114) = 0;
      BYTE8(v115) = 0;
      LOBYTE(v116) = 0;
      BYTE8(v117) = 0;
      LOBYTE(v118) = 0;
      BYTE8(v119) = 0;
      if (*(char *)(v8 + 535) < 0)
      {
        sub_10004FC84(&v120, *(void **)(v8 + 512), *(void *)(v8 + 520));
      }
      else
      {
        long long v120 = *(_OWORD *)(v8 + 512);
        *(void *)&long long v121 = *(void *)(v8 + 528);
      }
      BYTE8(v121) = 1;
      LOWORD(v122) = 0;
      *((void *)&v122 + 1) = 0;
      long long v123 = 0uLL;
      LOWORD(v124) = 0;
      BYTE2(v124) = 5;
      BYTE8(v124) = 0;
      LOBYTE(v126) = 0;
      BYTE8(v126) = 0;
      LOBYTE(v127) = 0;
      WORD4(v127) = 0;
      sub_1011C7D34((uint64_t)v82, &buf);
      sub_1011C39E0(v8, (uint64_t)v82);
      if (!v82[256]) {
        goto LABEL_64;
      }
      char v28 = v82;
LABEL_63:
      sub_1000C5578((uint64_t)v28);
LABEL_64:
      sub_1000C5578((uint64_t)&buf);
      return;
    }
  }
  long long __dst = 0uLL;
  uint64_t v81 = 0;
  if (*(char *)(a2 + 479) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a2 + 456), *(void *)(a2 + 464));
  }
  else
  {
    long long __dst = *(_OWORD *)(a2 + 456);
    uint64_t v81 = *(void *)(a2 + 472);
  }
  memset(&v79, 0, sizeof(v79));
  if (*(char *)(a2 + 511) < 0) {
    sub_10004FC84(&v79, *(void **)(a2 + 488), *(void *)(a2 + 496));
  }
  else {
    std::string v79 = *(std::string *)(a2 + 488);
  }
  long long v41 = *(NSObject **)(v8 + 48);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    long long v42 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      long long v42 = *v11;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v42;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I [req][tapost] perform TransferAuthorization post request for type. iccid : %s", (uint8_t *)&buf, 0xCu);
  }
  CFAbsoluteTime v43 = CFAbsoluteTimeGetCurrent();
  *(void *)&long long buf = a1 + 40;
  *((CFAbsoluteTime *)sub_1011C81F0(v10, (void **)(a1 + 40), (long long **)&buf) + 25) = v43;
  int v78 = 0;
  uint64_t v44 = *(unsigned int *)(a1 + 64);
  long long buf = 0uLL;
  (***(void (****)(long long *__return_ptr))(v8 + 56))(&v87);
  long long v46 = (std::mutex *)Registry::getServiceMap(v45, (Registry *)v87);
  uint64_t v47 = v46;
  if (v48 < 0)
  {
    long long v49 = (unsigned __int8 *)(v48 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v50 = 5381;
    do
    {
      uint64_t v48 = v50;
      unsigned int v51 = *v49++;
      uint64_t v50 = (33 * v50) ^ v51;
    }
    while (v51);
  }
  std::mutex::lock(v46);
  *(void *)long long v86 = v48;
  uint64_t v52 = sub_10004D37C(&v47[1].__m_.__sig, (unint64_t *)v86);
  if (!v52)
  {
    uint64_t v54 = 0;
    goto LABEL_88;
  }
  uint64_t v54 = v52[3];
  uint64_t v53 = (std::__shared_weak_count *)v52[4];
  if (!v53)
  {
LABEL_88:
    std::mutex::unlock(v47);
    uint64_t v53 = 0;
    char v55 = 1;
    goto LABEL_89;
  }
  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v47);
  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v44 = v44;
  sub_10004D2C8(v53);
  char v55 = 0;
LABEL_89:
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v54 + 8))(&buf, v54, v44);
  if ((v55 & 1) == 0) {
    sub_10004D2C8(v53);
  }
  if (*((void *)&v87 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v87 + 1));
  }
  if ((void)buf)
  {
    long long v87 = 0uLL;
    (*(void (**)(long long *__return_ptr))(*(void *)buf + 64))(&v87);
    if ((void)v87)
    {
      int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v87 + 64), @"TransferWebservicesTimeout");
      long long v57 = Value;
      *(void *)long long v86 = Value;
      if (Value)
      {
        CFRetain(Value);
        int v85 = 0;
        CFTypeID v58 = CFGetTypeID(v57);
        if (v58 == CFNumberGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)&v85, (unsigned int *)v57, v59);
          int v60 = v85;
        }
        else
        {
          int v60 = 0;
        }
      }
      else
      {
        int v60 = 60;
      }
      sub_1000577C4((const void **)v86);
    }
    else
    {
      char v62 = *(NSObject **)(v8 + 48);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v86 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "missing EntSettings for transfer", v86, 2u);
      }
      int v60 = 60;
    }
    if (*((void *)&v87 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v87 + 1));
    }
  }
  else
  {
    long long v61 = *(NSObject **)(v8 + 48);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      uint64_t v70 = subscriber::asString();
      LODWORD(v87) = 136315138;
      *(void *)((char *)&v87 + 4) = v70;
      _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "failed to find CarrierEntitlements for slot:%s", (uint8_t *)&v87, 0xCu);
    }
    int v60 = 60;
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  int v78 = v60;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v122 = 0u;
  long long v123 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long buf = 0u;
  long long v113 = 0u;
  sub_100093B44((std::string *)&buf, &v79);
  uint64_t v63 = *(void *)(v8 + 152);
  uint64_t v74 = v8;
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    long long __p = *(_OWORD *)v11;
    uint64_t v76 = *(void *)(a1 + 56);
  }
  sub_100B63100((uint64_t)v77, a2);
  long long v111 = 0;
  uint64_t v64 = operator new(0x278uLL);
  long long v65 = v64;
  uint64_t v66 = v74;
  *uint64_t v64 = off_101A9CBD8;
  v64[1] = v66;
  if (SHIBYTE(v76) < 0)
  {
    sub_10004FC84((unsigned char *)v64 + 16, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *((_OWORD *)v64 + 1) = __p;
    v64[4] = v76;
  }
  sub_100B63100((uint64_t)(v65 + 5), (uint64_t)v77);
  long long v111 = v65;
  char v67 = (*(uint64_t (**)(uint64_t, long long *, long long *, int *, void *))(*(void *)v63 + 16))(v63, &__dst, &buf, &v78, v110);
  sub_100777F50(v110);
  sub_1008C2D48((uint64_t)v77);
  if (SHIBYTE(v76) < 0) {
    operator delete((void *)__p);
  }
  if ((v67 & 1) == 0)
  {
    *(void *)&long long v87 = a1 + 40;
    *((_DWORD *)sub_1011C81F0(v10, v11, (long long **)&v87) + 20) = 70047;
    long long v87 = 0uLL;
    uint64_t v88 = 0;
    __int16 v89 = 272;
    char v90 = 0;
    char v91 = 0;
    char v92 = 0;
    char v93 = 0;
    char v94 = 0;
    char v95 = 0;
    if (*(char *)(v8 + 535) < 0)
    {
      sub_10004FC84(&v96, *(void **)(v8 + 512), *(void *)(v8 + 520));
    }
    else
    {
      long long v96 = *(_OWORD *)(v8 + 512);
      uint64_t v97 = *(void *)(v8 + 528);
    }
    char v98 = 1;
    __int16 v99 = 0;
    uint64_t v102 = 0;
    uint64_t v100 = 0;
    uint64_t v101 = 0;
    __int16 v103 = 0;
    char v104 = 5;
    char v105 = 0;
    char v106 = 0;
    char v107 = 0;
    char v108 = 0;
    __int16 v109 = 0;
    sub_1011C7D34((uint64_t)v73, &v87);
    sub_1011C39E0(v8, (uint64_t)v73);
    if (v73[256]) {
      sub_1000C5578((uint64_t)v73);
    }
    sub_1000C5578((uint64_t)&v87);
  }
  sub_100B632F8((uint64_t)&buf);
  if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v79.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v81) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_1011C5374(_Unwind_Exception *a1)
{
  if (LOBYTE(STACK[0x998]) && SLOBYTE(STACK[0x997]) < 0) {
    operator delete((void *)STACK[0x980]);
  }
  if (LOBYTE(STACK[0x978]) && SLOBYTE(STACK[0x977]) < 0) {
    operator delete((void *)STACK[0x960]);
  }
  if (LOBYTE(STACK[0x958]) && SLOBYTE(STACK[0x957]) < 0) {
    operator delete((void *)STACK[0x940]);
  }
  if (SLOBYTE(STACK[0x937]) < 0) {
    operator delete((void *)STACK[0x920]);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011C5654(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1011C5690(uint64_t a1, void **a2, uint64_t a3)
{
  if (!*(void *)(a3 + 24))
  {
    *(void *)&long long buf = off_101A9CC58;
    *((void *)&v133 + 1) = &buf;
    if (&buf != (long long *)a3)
    {
      *(void *)a3 = off_101A9CC58;
      *((void *)&v133 + 1) = 0;
      *(void *)(a3 + 24) = a3;
    }
    sub_1000DBADC(&buf);
  }
  uint64_t v6 = *(void ***)(a1 + 792);
  if (!v6)
  {
LABEL_11:
    __int16 v9 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a2 + 23) >= 0) {
        uint64_t v16 = (uint64_t *)a2;
      }
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid iccid for submit CA metric : %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v130 = 0;
    long long __p = 0;
    sub_10033F214(a3, 0);
    return;
  }
  uint64_t v7 = (void *)(a1 + 784);
  uint64_t v8 = (void *)(a1 + 792);
  while ((sub_100046FE8(a2, v6 + 4) & 0x80) != 0)
  {
LABEL_10:
    uint64_t v6 = (void **)*v6;
    if (!v6) {
      goto LABEL_11;
    }
  }
  if ((sub_100046FE8(v6 + 4, a2) & 0x80) != 0)
  {
    ++v6;
    goto LABEL_10;
  }
  __int16 v10 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v10)
  {
    uint64_t v11 = 0;
LABEL_19:
    BOOL v15 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "invalid delegate", (uint8_t *)&buf, 2u);
    }
    uint64_t v127 = 0;
    uint64_t v126 = 0;
    uint64_t v128 = 0;
    sub_10033F214(a3, 0);
    goto LABEL_219;
  }
  uint64_t v11 = std::__shared_weak_count::lock(v10);
  if (!v11) {
    goto LABEL_19;
  }
  uint64_t v12 = *(void *)(a1 + 72);
  if (!v12) {
    goto LABEL_19;
  }
  long long v135 = 0u;
  memset(v136, 0, sizeof(v136));
  long long v133 = 0u;
  memset(v134, 0, sizeof(v134));
  long long buf = 0u;
  v74[0] = (Registry *)a2;
  uint64_t v13 = sub_1011C81F0((uint64_t **)(a1 + 784), a2, (long long **)v74);
  uint64_t v14 = v13;
  if (v13[79] < 0)
  {
    sub_10004FC84(&buf, *((void **)v13 + 7), *((void *)v13 + 8));
  }
  else
  {
    long long buf = *(_OWORD *)(v13 + 56);
    *(void *)&long long v133 = *((void *)v13 + 9);
  }
  DWORD2(v133) = *((_DWORD *)v14 + 20);
  if (v14[111] < 0)
  {
    sub_10004FC84(v134, *((void **)v14 + 11), *((void *)v14 + 12));
  }
  else
  {
    v134[0] = *(_OWORD *)(v14 + 88);
    *(void *)&v134[1] = *((void *)v14 + 13);
  }
  *((void *)&v134[1] + 1) = *((void *)v14 + 14);
  *(_DWORD *)((char *)&v134[1] + 15) = *(_DWORD *)(v14 + 119);
  sub_1000593FC((uint64_t)&v134[2] + 8, (long long *)v14 + 8);
  long long v17 = *((_OWORD *)v14 + 16);
  *(_OWORD *)&v136[11] = *((_OWORD *)v14 + 15);
  *(_OWORD *)&v136[13] = v17;
  *(_OWORD *)&v136[15] = *((_OWORD *)v14 + 17);
  v136[17] = *((void *)v14 + 36);
  long long v18 = *((_OWORD *)v14 + 12);
  *(_OWORD *)&v136[3] = *((_OWORD *)v14 + 11);
  *(_OWORD *)&v136[5] = v18;
  long long v19 = *((_OWORD *)v14 + 14);
  *(_OWORD *)&v136[7] = *((_OWORD *)v14 + 13);
  *(_OWORD *)&v136[9] = v19;
  *(_OWORD *)&v136[1] = *((_OWORD *)v14 + 10);
  uint64_t v20 = (void *)*v8;
  if (*v8)
  {
    unsigned int v21 = (void *)(a1 + 792);
    do
    {
      char v22 = sub_100046FE8(v20 + 4, a2);
      if (v22 >= 0) {
        int v23 = v20;
      }
      else {
        int v23 = v20 + 1;
      }
      if (v22 >= 0) {
        unsigned int v21 = v20;
      }
      uint64_t v20 = (void *)*v23;
    }
    while (*v23);
    if (v21 != v8 && (sub_100046FE8(a2, (void **)v21 + 4) & 0x80) == 0)
    {
      uint64_t v24 = (void *)v21[1];
      if (v24)
      {
        do
        {
          char v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        char v26 = v21;
        do
        {
          char v25 = (void *)v26[2];
          BOOL v27 = *v25 == (void)v26;
          char v26 = v25;
        }
        while (!v27);
      }
      if ((void *)*v7 == v21) {
        *uint64_t v7 = v25;
      }
      --*(void *)(a1 + 800);
      sub_10005EE6C(*(uint64_t **)(a1 + 792), v21);
      sub_1011C7EF8((uint64_t)(v21 + 4));
      operator delete(v21);
    }
  }
  if (!BYTE10(v134[1]) || DWORD2(v133) != 70036)
  {
    xpc_object_t v122 = 0;
    xpc_object_t v28 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v29 = v28;
    if (v28)
    {
      xpc_object_t v122 = v28;
    }
    else
    {
      xpc_object_t v29 = xpc_null_create();
      xpc_object_t v122 = v29;
      if (!v29)
      {
        xpc_object_t v30 = xpc_null_create();
        xpc_object_t v29 = 0;
        goto LABEL_60;
      }
    }
    if (xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v29);
      goto LABEL_61;
    }
    xpc_object_t v30 = xpc_null_create();
LABEL_60:
    xpc_object_t v122 = v30;
LABEL_61:
    xpc_release(v29);
    xpc_object_t v120 = xpc_int64_create(BYTE2(v134[2]));
    if (!v120) {
      xpc_object_t v120 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"internetTransport";
    sub_100035E70((uint64_t)v74, &v120, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v120);
    xpc_object_t v120 = 0;
    if ((SBYTE7(v133) & 0x80u) == 0) {
      p_long long buf = (const char *)&buf;
    }
    else {
      p_long long buf = (const char *)buf;
    }
    xpc_object_t v118 = xpc_string_create(p_buf);
    if (!v118) {
      xpc_object_t v118 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"carrierName";
    sub_100035E70((uint64_t)v74, &v118, &v119);
    xpc_release(v119);
    xpc_object_t v119 = 0;
    xpc_release(v118);
    xpc_object_t v118 = 0;
    xpc_object_t v116 = xpc_int64_create(DWORD2(v133));
    if (!v116) {
      xpc_object_t v116 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"error";
    sub_100035E70((uint64_t)v74, &v116, &v117);
    xpc_release(v117);
    xpc_object_t v117 = 0;
    xpc_release(v116);
    xpc_object_t v116 = 0;
    if (HIBYTE(v134[1]))
    {
      xpc_object_t v114 = xpc_BOOL_create(SBYTE14(v134[1]));
      if (!v114) {
        xpc_object_t v114 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"isTrustFlagSucceed";
      sub_100035E70((uint64_t)v74, &v114, &v115);
      xpc_release(v115);
      xpc_object_t v115 = 0;
      xpc_release(v114);
      xpc_object_t v114 = 0;
    }
    xpc_object_t v112 = xpc_BOOL_create(SBYTE8(v134[1]));
    if (!v112) {
      xpc_object_t v112 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"isActive";
    sub_100035E70((uint64_t)v74, &v112, &v113);
    xpc_release(v113);
    xpc_object_t v113 = 0;
    xpc_release(v112);
    xpc_object_t v112 = 0;
    xpc_object_t v110 = xpc_BOOL_create(SBYTE9(v134[1]));
    if (!v110) {
      xpc_object_t v110 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"isLocal";
    sub_100035E70((uint64_t)v74, &v110, &v111);
    xpc_release(v111);
    xpc_object_t v111 = 0;
    xpc_release(v110);
    xpc_object_t v110 = 0;
    xpc_object_t v108 = xpc_BOOL_create(SBYTE10(v134[1]));
    if (!v108) {
      xpc_object_t v108 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"isPreflight";
    sub_100035E70((uint64_t)v74, &v108, &v109);
    xpc_release(v109);
    xpc_object_t v109 = 0;
    xpc_release(v108);
    xpc_object_t v108 = 0;
    if (BYTE13(v134[1]))
    {
      xpc_object_t v106 = xpc_BOOL_create(SBYTE12(v134[1]));
      if (!v106) {
        xpc_object_t v106 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"isSecureAuthSucceed";
      sub_100035E70((uint64_t)v74, &v106, &v107);
      xpc_release(v107);
      xpc_object_t v107 = 0;
      xpc_release(v106);
      xpc_object_t v106 = 0;
    }
    xpc_object_t v104 = xpc_BOOL_create(SBYTE11(v134[1]));
    if (!v104) {
      xpc_object_t v104 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"isSecuredFlow";
    sub_100035E70((uint64_t)v74, &v104, &v105);
    xpc_release(v105);
    xpc_object_t v105 = 0;
    xpc_release(v104);
    xpc_object_t v104 = 0;
    if ((SBYTE7(v134[1]) & 0x80u) == 0) {
      long long v32 = (const char *)v134;
    }
    else {
      long long v32 = *(const char **)&v134[0];
    }
    xpc_object_t v102 = xpc_string_create(v32);
    if (!v102) {
      xpc_object_t v102 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"eSIMTransferFlow";
    sub_100035E70((uint64_t)v74, &v102, &v103);
    xpc_release(v103);
    xpc_object_t v103 = 0;
    xpc_release(v102);
    xpc_object_t v102 = 0;
    if (BYTE1(v134[2]))
    {
      xpc_object_t v100 = xpc_int64_create(LOBYTE(v134[2]));
      if (!v100) {
        xpc_object_t v100 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"transferType";
      sub_100035E70((uint64_t)v74, &v100, &v101);
      xpc_release(v101);
      xpc_object_t v101 = 0;
      xpc_release(v100);
      xpc_object_t v100 = 0;
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    xpc_object_t v98 = xpc_int64_create((Current - *(double *)&v136[1]));
    if (!v98) {
      xpc_object_t v98 = xpc_null_create();
    }
    v74[0] = (Registry *)&v122;
    v74[1] = (Registry *)"totalDuration";
    sub_100035E70((uint64_t)v74, &v98, &v99);
    xpc_release(v99);
    xpc_object_t v99 = 0;
    xpc_release(v98);
    xpc_object_t v98 = 0;
    if (*(double *)&v136[3] > 1.0)
    {
      xpc_object_t v96 = xpc_int64_create((*(double *)&v136[3] - *(double *)&v136[2]));
      if (!v96) {
        xpc_object_t v96 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"trustFlagForTypeDuration";
      sub_100035E70((uint64_t)v74, &v96, &v97);
      xpc_release(v97);
      xpc_object_t v97 = 0;
      xpc_release(v96);
      xpc_object_t v96 = 0;
    }
    if (*(double *)&v136[9] > 1.0)
    {
      xpc_object_t v94 = xpc_int64_create((*(double *)&v136[9] - *(double *)&v136[8]));
      if (!v94) {
        xpc_object_t v94 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"trustFlagForTokenDuration";
      sub_100035E70((uint64_t)v74, &v94, &v95);
      xpc_release(v95);
      xpc_object_t v95 = 0;
      xpc_release(v94);
      xpc_object_t v94 = 0;
    }
    if (*(double *)&v136[5] > 1.0)
    {
      xpc_object_t v92 = xpc_int64_create((*(double *)&v136[5] - *(double *)&v136[4]));
      if (!v92) {
        xpc_object_t v92 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"transferAuthorizationForTypeDuration";
      sub_100035E70((uint64_t)v74, &v92, &v93);
      xpc_release(v93);
      xpc_object_t v93 = 0;
      xpc_release(v92);
      xpc_object_t v92 = 0;
    }
    if (*(double *)&v136[11] > 1.0)
    {
      xpc_object_t v90 = xpc_int64_create((*(double *)&v136[11] - *(double *)&v136[10]));
      if (!v90) {
        xpc_object_t v90 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"transferAuthorizationForTokenDuration";
      sub_100035E70((uint64_t)v74, &v90, &v91);
      xpc_release(v91);
      xpc_object_t v91 = 0;
      xpc_release(v90);
      xpc_object_t v90 = 0;
    }
    if (*(double *)&v136[7] > 1.0)
    {
      xpc_object_t v88 = xpc_int64_create((*(double *)&v136[7] - *(double *)&v136[6]));
      if (!v88) {
        xpc_object_t v88 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"transferAuthorizationWebServiceDuration";
      sub_100035E70((uint64_t)v74, &v88, &v89);
      xpc_release(v89);
      xpc_object_t v89 = 0;
      xpc_release(v88);
      xpc_object_t v88 = 0;
    }
    if (*(double *)&v136[13] > 1.0)
    {
      xpc_object_t v86 = xpc_int64_create((*(double *)&v136[13] - *(double *)&v136[12]));
      if (!v86) {
        xpc_object_t v86 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"secureAuthDuration";
      sub_100035E70((uint64_t)v74, &v86, &v87);
      xpc_release(v87);
      xpc_object_t v87 = 0;
      xpc_release(v86);
      xpc_object_t v86 = 0;
    }
    if (*(double *)&v136[14] > 1.0)
    {
      xpc_object_t v84 = xpc_int64_create((*(double *)&v136[15] - *(double *)&v136[14]));
      if (!v84) {
        xpc_object_t v84 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"consentDuration";
      sub_100035E70((uint64_t)v74, &v84, &v85);
      xpc_release(v85);
      xpc_object_t v85 = 0;
      xpc_release(v84);
      xpc_object_t v84 = 0;
    }
    v34.n128_u64[0] = v136[17];
    if (*(double *)&v136[17] > 1.0)
    {
      xpc_object_t v82 = xpc_int64_create((*(double *)&v136[17] - *(double *)&v136[16]));
      if (!v82) {
        xpc_object_t v82 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"secureIntentDuration";
      sub_100035E70((uint64_t)v74, &v82, &v83);
      xpc_release(v83);
      xpc_object_t v83 = 0;
      xpc_release(v82);
      xpc_object_t v82 = 0;
    }
    if (LOBYTE(v136[0]))
    {
      if (v135 >= 0) {
        char v35 = (char *)&v134[2] + 8;
      }
      else {
        char v35 = (const char *)*((void *)&v134[2] + 1);
      }
      xpc_object_t v80 = xpc_string_create(v35);
      if (!v80) {
        xpc_object_t v80 = xpc_null_create();
      }
      v74[0] = (Registry *)&v122;
      v74[1] = (Registry *)"carrierErrorCode";
      sub_100035E70((uint64_t)v74, &v80, &v81);
      xpc_release(v81);
      xpc_object_t v81 = 0;
      xpc_release(v80);
      xpc_object_t v80 = 0;
    }
    (***(void (****)(Registry **__return_ptr, __n128))(a1 + 56))(v74, v34);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v36, v74[0]);
    long long v38 = ServiceMap;
    if (v39 < 0)
    {
      uint64_t v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v41 = 5381;
      do
      {
        uint64_t v39 = v41;
        unsigned int v42 = *v40++;
        uint64_t v41 = (33 * v41) ^ v42;
      }
      while (v42);
    }
    std::mutex::lock(ServiceMap);
    v72[0] = (void *)v39;
    CFAbsoluteTime v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)v72);
    if (v43)
    {
      uint64_t v45 = v43[3];
      uint64_t v44 = (std::__shared_weak_count *)v43[4];
      if (v44)
      {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v38);
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v44);
        char v46 = 0;
        goto LABEL_144;
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
    std::mutex::unlock(v38);
    uint64_t v44 = 0;
    char v46 = 1;
LABEL_144:
    if (v74[1]) {
      sub_10004D2C8((std::__shared_weak_count *)v74[1]);
    }
    if (v45)
    {
      xpc_object_t v79 = v122;
      if (v122) {
        xpc_retain(v122);
      }
      else {
        xpc_object_t v79 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v45 + 16))(v45, "commCenterSourceTransferDetail", &v79);
      xpc_release(v79);
      xpc_object_t v79 = 0;
    }
    if ((v46 & 1) == 0) {
      sub_10004D2C8(v44);
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v12 + 120))(v12, &buf);
    if (!DWORD2(v133) || BYTE10(v134[1]))
    {
      uint64_t v76 = 0;
      uint64_t v77 = 0;
      uint64_t v78 = 0;
      sub_10033F214(a3, 0);
      if ((SHIBYTE(v78) & 0x80000000) == 0)
      {
LABEL_211:
        xpc_release(v122);
        goto LABEL_212;
      }
      long long v49 = v76;
    }
    else
    {
      v74[0] = 0;
      v74[1] = 0;
      uint64_t v75 = 0;
      sub_100058DB0(v74, "eSIM iOS");
      uint64_t v47 = *(void *)(a1 + 712);
      if (v47)
      {
        if (*(char *)(v47 + 167) < 0 ? *(void *)(v47 + 152) : *(unsigned __int8 *)(v47 + 167))
        {
          std::operator+<char>();
          if (SHIBYTE(v75) < 0) {
            operator delete(v74[0]);
          }
          *(_OWORD *)uint64_t v74 = *(_OWORD *)v72;
          uint64_t v75 = v73;
        }
      }
      v72[0] = 0;
      v72[1] = 0;
      uint64_t v73 = 0;
      if (BYTE10(v134[1])) {
        uint64_t v50 = "preflightOnSource";
      }
      else {
        uint64_t v50 = "generateTransferTokenOnSource";
      }
      sub_100058DB0(v72, v50);
      memset(&v71, 0, sizeof(v71));
      std::to_string(&v71, DWORD2(v133));
      if ((DWORD2(v133) - 70000) <= 0x48)
      {
        unsigned int v51 = (char *)sub_1008A2254(SDWORD2(v133));
        sub_10003ED78(&v71, v51);
      }
      v69[0] = 0;
      v69[1] = 0;
      std::string::size_type v70 = 0;
      if ((SBYTE7(v133) & 0x80u) == 0) {
        size_t v52 = BYTE7(v133);
      }
      else {
        size_t v52 = *((void *)&buf + 1);
      }
      memset(&v66, 0, sizeof(v66));
      uint64_t v53 = &v66;
      sub_1000C140C((uint64_t)&v66, v52 + 12);
      if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v53 = (std::string *)v66.__r_.__value_.__r.__words[0];
      }
      if (v52)
      {
        if ((SBYTE7(v133) & 0x80u) == 0) {
          uint64_t v54 = &buf;
        }
        else {
          uint64_t v54 = (long long *)buf;
        }
        memmove(v53, v54, v52);
      }
      strcpy((char *)v53 + v52, ", errorCode:");
      if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v55 = &v71;
      }
      else {
        char v55 = (std::string *)v71.__r_.__value_.__r.__words[0];
      }
      if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v71.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v71.__r_.__value_.__l.__size_;
      }
      long long v57 = std::string::append(&v66, (const std::string::value_type *)v55, size);
      long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = v58;
      v57->__r_.__value_.__l.__size_ = 0;
      v57->__r_.__value_.__r.__words[2] = 0;
      v57->__r_.__value_.__r.__words[0] = 0;
      CFNumberRef v59 = std::string::append(&v67, ", onDeviceConversion:", 0x15uLL);
      long long v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
      v68.__r_.__value_.__r.__words[2] = v59->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v60;
      v59->__r_.__value_.__l.__size_ = 0;
      v59->__r_.__value_.__r.__words[2] = 0;
      v59->__r_.__value_.__r.__words[0] = 0;
      if (BYTE9(v134[1])) {
        long long v61 = "True";
      }
      else {
        long long v61 = "False";
      }
      if (BYTE9(v134[1])) {
        std::string::size_type v62 = 4;
      }
      else {
        std::string::size_type v62 = 5;
      }
      uint64_t v63 = std::string::append(&v68, v61, v62);
      long long v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
      std::string::size_type v70 = v63->__r_.__value_.__r.__words[2];
      *(_OWORD *)uint64_t v69 = v64;
      v63->__r_.__value_.__l.__size_ = 0;
      v63->__r_.__value_.__r.__words[2] = 0;
      v63->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v68.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v67.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v66.__r_.__value_.__l.__data_);
      }
      sub_100058DB0(&v68, "Cellular");
      int v65 = BYTE9(v134[1]);
      memset(&v67, 0, sizeof(v67));
      sub_10033ECA0((uint64_t)v131, a3);
      (*(void (**)(uint64_t, std::string *, Registry **, void **, void **, BOOL, std::string *, void *))(*(void *)v12 + 192))(v12, &v68, v74, v72, v69, v65 == 0, &v67, v131);
      sub_1000DBADC(v131);
      if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v67.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v68.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v70) < 0) {
        operator delete(v69[0]);
      }
      if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v71.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v73) < 0) {
        operator delete(v72[0]);
      }
      if ((SHIBYTE(v75) & 0x80000000) == 0) {
        goto LABEL_211;
      }
      long long v49 = v74[0];
    }
    operator delete(v49);
    goto LABEL_211;
  }
  uint64_t v124 = 0;
  long long v123 = 0;
  uint64_t v125 = 0;
  sub_10033F214(a3, 0);
  if (SHIBYTE(v125) < 0) {
    operator delete(v123);
  }
LABEL_212:
  if (LOBYTE(v136[0]) && SHIBYTE(v135) < 0) {
    operator delete(*((void **)&v134[2] + 1));
  }
  if (SBYTE7(v134[1]) < 0) {
    operator delete(*(void **)&v134[0]);
  }
  if (SBYTE7(v133) < 0) {
    operator delete((void *)buf);
  }
LABEL_219:
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_1011C67D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  xpc_release((xpc_object_t)STACK[0x238]);
  sub_1011BDAD0((uint64_t)&STACK[0x2B0]);
  if (v36) {
    sub_10004D2C8(v36);
  }
  _Unwind_Resume(a1);
}

const void **sub_1011C6B28(const void **result, const void **a2)
{
  uint64_t v2 = result[96];
  if (v2)
  {
    sub_10002FD9C(&v3, a2);
    (*(void (**)(const void *, const void **))(*(void *)v2 + 56))(v2, &v3);
    return sub_100030068(&v3);
  }
  return result;
}

void sub_1011C6B90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100030068((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011C6BA4(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef theDict = 0;
  (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)buf);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  value = (void *)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&value);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v13 + 80))(&v31, v13, a2, 1, @"PhoneAccountTransfer", 0, 0);
  sub_10004EFE4(&theDict, &v31);
  sub_1000577C4(&v31);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (theDict) {
    BOOL v15 = sub_100080778;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15)
  {
    char v22 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = subscriber::asString();
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = @"PhoneAccountTransfer";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Get %@ bundle value failed. slot:%s", buf, 0x16u);
    }
    goto LABEL_27;
  }
  value = 0;
  int ValueIfPresent = CFDictionaryGetValueIfPresent(theDict, @"MinCompatibleOS", (const void **)&value);
  long long v17 = *(NSObject **)(a1 + 48);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (!ValueIfPresent)
  {
    if (v18)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I MinCompatibleOS doesn't exist, always allow SIM transfer", buf, 2u);
    }
LABEL_27:
    uint64_t v24 = 0;
    goto LABEL_38;
  }
  if (v18)
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = value;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I MinCompatibleOS : %@", buf, 0xCu);
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(value))
  {
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    uint64_t v20 = *(void **)buf;
    LODWORD(v31) = *(_DWORD *)&buf[16];
    *(_DWORD *)((char *)&v31 + 3) = *(_DWORD *)&buf[19];
    int v21 = (char)buf[23];
    if ((char)buf[23] < 0)
    {
      sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      __p[0] = *(void **)buf;
      __p[1] = *(void **)&buf[8];
      *(_DWORD *)xpc_object_t v29 = v31;
      *(_DWORD *)&void v29[3] = *(_DWORD *)((char *)&v31 + 3);
      signed __int8 v30 = buf[23];
    }
    uint64_t v24 = sub_100CD1928((const char *)__p);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    char v26 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v24;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I minimum supported version is %x", buf, 8u);
    }
    if (v21 < 0) {
      operator delete(v20);
    }
  }
  else
  {
    char v25 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "invalid format of MinCompatibleOS", buf, 2u);
    }
    uint64_t v24 = 0xFFFFFFFFLL;
  }
LABEL_38:
  sub_100057D78((const void **)&theDict);
  return v24;
}

void sub_1011C6FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  operator delete(v21);
  sub_100057D78(&a14);
  _Unwind_Resume(a1);
}

void sub_1011C702C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011C7090(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011C70F4(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_1011C7158(void *a1)
{
  uint64_t v2 = a1[13];
  if (v2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    (*(void (**)(void ***__return_ptr))(*(void *)v2 + 40))(&v7);
    uint64_t v3 = v7;
    long long v4 = v8;
    v6[0] = 0;
    v6[1] = 0;
    uint64_t v5 = v6;
    while (v3 != v4)
    {
      sub_1000C6CC0((uint64_t **)&v5, (uint64_t)v6, v3, (uint64_t)v3);
      v3 += 3;
    }
    sub_1011C7320(a1, (uint64_t)&v5);
    sub_10005CD2C((uint64_t)&v5, v6[0]);
    uint64_t v5 = (char **)&v7;
    sub_100047F64((void ***)&v5);
  }
}

void sub_1011C7220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, char *a10, uint64_t a11, char a12)
{
  a9 = (void **)&a12;
  sub_100047F64(&a9);
  _Unwind_Resume(a1);
}

void sub_1011C724C(void *a1)
{
  if (a1[108])
  {
    v8[0] = 0;
    v8[1] = 0;
    uint64_t v7 = v8;
    uint64_t v2 = (void **)a1[106];
    uint64_t v3 = (void **)(a1 + 107);
    if (v2 != a1 + 107)
    {
      do
      {
        sub_100046BAC((uint64_t **)&v7, v2 + 7, (uint64_t)(v2 + 7));
        long long v4 = (void **)v2[1];
        if (v4)
        {
          do
          {
            uint64_t v5 = v4;
            long long v4 = (void **)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            uint64_t v5 = (void **)v2[2];
            BOOL v6 = *v5 == v2;
            uint64_t v2 = v5;
          }
          while (!v6);
        }
        uint64_t v2 = v5;
      }
      while (v5 != v3);
    }
    sub_1011C7320(a1, (uint64_t)&v7);
    sub_10005CD2C((uint64_t)&v7, v8[0]);
  }
}

void sub_1011C7304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1011C7320(void *a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t)(a1 + 76);
  uint64_t v5 = a1[76];
  uint64_t v6 = a1[77];
  if (v5 != v6)
  {
    while (!sub_10010E128(a2, (void **)(v5 + 72)))
    {
      v5 += 168;
      if (v5 == v6)
      {
        uint64_t v5 = v6;
        goto LABEL_5;
      }
    }
    if (v5 != v6)
    {
      for (uint64_t i = v5 + 168; i != v6; i += 168)
      {
        if (!sub_10010E128(a2, (void **)(i + 72)))
        {
          sub_10032FAFC(v5, i);
          v5 += 168;
        }
      }
    }
  }
LABEL_5:
  uint64_t result = sub_10032F9B8(v4, v5, a1[77]);
  uint64_t v8 = a1[73];
  uint64_t v9 = a1[74];
  while (v8 != v9)
  {
    if (*(unsigned char *)(v8 + 80))
    {
      uint64_t v10 = *(void *)(v8 + 56);
      uint64_t v11 = *(void *)(v8 + 64);
      if (v10 != v11)
      {
        while (!sub_10010E128(a2, (void **)(v10 + 16)))
        {
          v10 += 216;
          if (v10 == v11)
          {
            uint64_t v10 = v11;
            goto LABEL_18;
          }
        }
        if (v10 != v11)
        {
          for (uint64_t j = v10 + 216; j != v11; j += 216)
          {
            if (!sub_10010E128(a2, (void **)(j + 16)))
            {
              sub_10032FC84(v10, j);
              v10 += 216;
            }
          }
        }
      }
LABEL_18:
      uint64_t result = sub_10032FA2C(v8 + 56, v10, *(void *)(v8 + 64));
    }
    v8 += 88;
  }
  return result;
}

void sub_1011C7470(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = a1[9];
      if (v4)
      {
        (*(void (**)(uint64_t))(*(void *)v4 + 168))(v4);
LABEL_9:
        sub_10004D2C8(v3);
        return;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v5 = a1[6];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "invalid delegate", v6, 2u);
  }
  if (v3) {
    goto LABEL_9;
  }
}

void sub_1011C752C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011C7540(uint64_t a1)
{
}

void sub_1011C7548(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = a1[9];
      if (v4)
      {
        (*(void (**)(uint64_t))(*(void *)v4 + 176))(v4);
LABEL_9:
        sub_10004D2C8(v3);
        return;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v5 = a1[6];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "invalid delegate", v6, 2u);
  }
  if (v3) {
    goto LABEL_9;
  }
}

void sub_1011C7604(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1011C7618(uint64_t a1)
{
}

void sub_1011C7620(Registry *this@<X1>, void *a2@<X0>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, this);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v13);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  *a2 = v12;
  a2[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
}

uint64_t sub_1011C76EC(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t sub_1011C7748(uint64_t a1)
{
  sub_1000C5578(a1 + 96);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011C77A0(uint64_t a1, void **a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const std::string *a8, unsigned __int8 a9, char a10)
{
}

void sub_1011C77B8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v6 = (char *)operator new(0x60uLL);
  uint64_t v7 = (std::__shared_weak_count *)v6;
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)unint64_t v6 = off_101A9CFD8;
  v6[24] = 0;
  uint64_t v8 = v6 + 24;
  v6[48] = 0;
  if (*((unsigned char *)a3 + 24))
  {
    uint64_t v9 = *a3;
    uint64_t v10 = a3 + 1;
    uint64_t v11 = a3[1];
    *((void *)v6 + 4) = v11;
    uint64_t v12 = v6 + 32;
    *((void *)v6 + 3) = v9;
    uint64_t v13 = a3[2];
    *((void *)v6 + 5) = v13;
    if (v13)
    {
      *(void *)(v11 + 16) = v12;
      *a3 = (uint64_t)v10;
      *uint64_t v10 = 0;
      a3[2] = 0;
    }
    else
    {
      void *v8 = v12;
    }
    v6[48] = 1;
  }
  *(_OWORD *)(v6 + 56) = *((_OWORD *)a3 + 2);
  *((void *)v6 + 9) = a3[6];
  a3[4] = 0;
  a3[5] = 0;
  *((_OWORD *)v6 + 5) = *(_OWORD *)(a3 + 7);
  a3[6] = 0;
  a3[7] = 0;
  a3[8] = 0;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v6 + 1, 1uLL, memory_order_relaxed);
  sub_10004D2C8((std::__shared_weak_count *)v6);
  if (!*(void *)(a1 + 768))
  {
    BOOL v15 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v16 = "invalid secure intent controller";
    goto LABEL_15;
  }
  if (!*(void *)(a1 + 360) || (uint64_t v14 = *(void *)(a1 + 336), v14 == a1 + 352))
  {
    BOOL v15 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v16 = "invalid iterator. ignore transfer secure intent request";
LABEL_15:
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v16, buf, 2u);
    goto LABEL_24;
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v24 = 0;
  if (*(char *)(v14 + 55) < 0)
  {
    sub_10004FC84(buf, *(void **)(v14 + 32), *(void *)(v14 + 40));
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)(v14 + 32);
    uint64_t v24 = *(void *)(v14 + 48);
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  char v25 = buf;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)buf, (long long **)&v25) + 31) = Current;
  uint64_t v18 = *(void *)(a1 + 768);
  *(void *)&long long v20 = a1;
  *((void *)&v20 + 1) = v8;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(&__p, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    long long __p = *(_OWORD *)buf;
    uint64_t v22 = v24;
  }
  BOOL v27 = 0;
  long long v19 = (char *)operator new(0x38uLL);
  *(void *)long long v19 = off_101A9D028;
  *(_OWORD *)(v19 + 8) = v20;
  *((void *)v19 + 3) = v7;
  *((void *)v19 + 6) = v22;
  *((_OWORD *)v19 + 2) = __p;
  long long __p = 0uLL;
  uint64_t v22 = 0;
  BOOL v27 = v19;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v18 + 48))(v18, a2, v26);
  sub_10050D2AC(v26);
  if (SHIBYTE(v22) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_24:
  sub_10004D2C8(v7);
}

void sub_1011C7AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_1011C7B34()
{
  return 1;
}

uint64_t sub_1011C7B3C(uint64_t a1)
{
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  sub_100060644((void *)(a1 + 152));
  sub_1011C7BD8(*(void **)(a1 + 136));
  uint64_t v3 = (void **)(a1 + 96);
  sub_10008A88C(&v3);
  uint64_t v3 = (void **)(a1 + 72);
  sub_1000C56F4(&v3);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1011C7BD8(void *a1)
{
  if (a1)
  {
    sub_1011C7BD8(*a1);
    sub_1011C7BD8(a1[1]);
    sub_1011C7C2C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1011C7C2C(uint64_t a1)
{
  sub_1000C5578(a1 + 32);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_1011C7C7C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(unsigned char *)(a1 + 56) = 1;
  return a1;
}

void sub_1011C7D18(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1011C7D34(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  __int16 v3 = *((_WORD *)a2 + 12);
  *(unsigned char *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 24) = v3;
  *(unsigned char *)(a1 + 56) = 0;
  if (*((unsigned char *)a2 + 56))
  {
    long long v4 = a2[2];
    *(void *)(a1 + 48) = *((void *)a2 + 6);
    *(_OWORD *)(a1 + 32) = v4;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 4) = 0;
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  if (*((unsigned char *)a2 + 88))
  {
    long long v5 = a2[4];
    *(void *)(a1 + 80) = *((void *)a2 + 10);
    *(_OWORD *)(a1 + 64) = v5;
    *((void *)a2 + 9) = 0;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 8) = 0;
    *(unsigned char *)(a1 + 88) = 1;
  }
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  if (*((unsigned char *)a2 + 120))
  {
    long long v6 = a2[6];
    *(void *)(a1 + 112) = *((void *)a2 + 14);
    *(_OWORD *)(a1 + 96) = v6;
    *((void *)a2 + 13) = 0;
    *((void *)a2 + 14) = 0;
    *((void *)a2 + 12) = 0;
    *(unsigned char *)(a1 + 120) = 1;
  }
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  if (*((unsigned char *)a2 + 152))
  {
    long long v7 = a2[8];
    *(void *)(a1 + 144) = *((void *)a2 + 18);
    *(_OWORD *)(a1 + 128) = v7;
    *((void *)a2 + 17) = 0;
    *((void *)a2 + 18) = 0;
    *((void *)a2 + 16) = 0;
    *(unsigned char *)(a1 + 152) = 1;
  }
  *(_WORD *)(a1 + 160) = *((_WORD *)a2 + 80);
  long long v8 = *(long long *)((char *)a2 + 168);
  *(void *)(a1 + 184) = *((void *)a2 + 23);
  *(_OWORD *)(a1 + 168) = v8;
  *((void *)a2 + 22) = 0;
  *((void *)a2 + 23) = 0;
  *((void *)a2 + 21) = 0;
  char v9 = *((unsigned char *)a2 + 194);
  __int16 v10 = *((_WORD *)a2 + 96);
  *(unsigned char *)(a1 + 200) = 0;
  *(_WORD *)(a1 + 192) = v10;
  *(unsigned char *)(a1 + 194) = v9;
  *(unsigned char *)(a1 + 224) = 0;
  if (*((unsigned char *)a2 + 224))
  {
    long long v11 = *(long long *)((char *)a2 + 200);
    *(void *)(a1 + 216) = *((void *)a2 + 27);
    *(_OWORD *)(a1 + 200) = v11;
    *((void *)a2 + 26) = 0;
    *((void *)a2 + 27) = 0;
    *((void *)a2 + 25) = 0;
    *(unsigned char *)(a1 + 224) = 1;
  }
  __n128 result = *(__n128 *)((char *)a2 + 232);
  *(_WORD *)(a1 + 248) = *((_WORD *)a2 + 124);
  *(__n128 *)(a1 + 232) = result;
  *(unsigned char *)(a1 + 256) = 1;
  return result;
}

void sub_1011C7EA4(void *a1)
{
  if (a1)
  {
    sub_1011C7EA4(*a1);
    sub_1011C7EA4(a1[1]);
    sub_1011C7EF8((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1011C7EF8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    long long v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t *sub_1011C7F78(uint64_t *result, void *a2, void *a3)
{
  long long v5 = (uint64_t **)result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    void *result = (uint64_t)(result + 1);
    *(void *)(v7 + 16) = 0;
    result[1] = 0;
    result[2] = 0;
    if (*(void *)(v6 + 8)) {
      long long v8 = *(void **)(v6 + 8);
    }
    else {
      long long v8 = (void *)v6;
    }
    uint64_t v18 = result;
    long long v19 = v8;
    long long v20 = v8;
    if (v8)
    {
      long long v19 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        char v9 = a2;
        do
        {
          std::string::operator=((std::string *)(v8 + 4), (const std::string *)(v9 + 4));
          *((_DWORD *)v8 + 14) = *((_DWORD *)v9 + 14);
          __int16 v10 = v20;
          uint64_t v17 = 0;
          long long v11 = (uint64_t **)sub_1000EA518((uint64_t)v5, &v17, v20 + 4);
          sub_100046C38(v5, v17, v11, v10);
          long long v8 = v19;
          long long v20 = v19;
          if (v19) {
            long long v19 = sub_1000EA590((uint64_t)v19);
          }
          uint64_t v12 = (void *)v9[1];
          if (v12)
          {
            do
            {
              a2 = v12;
              uint64_t v12 = (void *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v13 = *a2 == (void)v9;
              char v9 = a2;
            }
            while (!v13);
          }
          if (!v8) {
            break;
          }
          char v9 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t *)sub_1000EA5E4((uint64_t)&v18);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v18 = 0;
      long long v19 = 0;
      long long v20 = 0;
      sub_1011C813C(&v18, (uint64_t)v5, (uint64_t)(a2 + 4));
      uint64_t v17 = 0;
      uint64_t v14 = (uint64_t **)sub_1000EA518((uint64_t)v5, &v17, v18 + 4);
      __n128 result = sub_100046C38(v5, v17, v14, v18);
      BOOL v15 = (void *)a2[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)a2[2];
          BOOL v13 = *v16 == (void)a2;
          a2 = v16;
        }
        while (!v13);
      }
      a2 = v16;
    }
    while (v16 != a3);
  }
  return result;
}

void sub_1011C8128(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000EA5E4((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned char *sub_1011C813C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[2] = 0;
  a1[1] = 0;
  uint64_t v6 = a1 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a1 = v7;
  void *v6 = v5;
  *((unsigned char *)a1 + 16) = 0;
  __n128 result = v7 + 32;
  if (*(char *)(a3 + 23) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
  }
  *((_DWORD *)v7 + 14) = *(_DWORD *)(a3 + 24);
  *((unsigned char *)a1 + 16) = 1;
  return result;
}

void sub_1011C81D4(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

char *sub_1011C81F0(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  uint64_t v7 = (char **)(a1 + 1);
  long long v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      long long v8 = (char **)v5;
      __int16 v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  long long v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    uint64_t v12 = *a3;
    uint64_t v19 = 0;
    BOOL v13 = (char *)operator new(0x128uLL);
    v18[0] = v13;
    v18[1] = v6;
    uint64_t v14 = v13 + 32;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      *((void *)v13 + 6) = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v14 = v15;
    }
    *(_OWORD *)(v13 + 104) = 0u;
    *(_OWORD *)(v13 + 120) = 0u;
    *((void *)v13 + 19) = 0;
    *(_OWORD *)(v13 + 136) = 0u;
    *(_OWORD *)(v13 + 88) = 0u;
    *(_OWORD *)(v13 + 72) = 0u;
    *(_OWORD *)(v13 + 56) = 0u;
    v13[112] = 1;
    *(void *)(v13 + 113) = 0;
    *(_WORD *)(v13 + 121) = 0;
    *((_OWORD *)v13 + 10) = 0u;
    *((_OWORD *)v13 + 11) = 0u;
    *((_OWORD *)v13 + 12) = 0u;
    *((_OWORD *)v13 + 13) = 0u;
    *((_OWORD *)v13 + 14) = 0u;
    *((_OWORD *)v13 + 15) = 0u;
    *((_OWORD *)v13 + 16) = 0u;
    *((_OWORD *)v13 + 17) = 0u;
    *((void *)v13 + 36) = 0;
    LOBYTE(v19) = 1;
    *(void *)BOOL v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v8;
    *uint64_t v7 = v13;
    uint64_t v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      BOOL v13 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    long long v11 = (char *)v18[0];
    v18[0] = 0;
    sub_1011C838C((uint64_t)v18);
  }
  return v11;
}

void sub_1011C8378(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1011C838C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1011C838C(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1011C7EF8((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void *sub_1011C83E4(void *a1)
{
  *a1 = off_101A9C418;
  long long v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011C8430(void *a1)
{
  *a1 = off_101A9C418;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011C849C(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A9C418;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011C8500(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A9C418;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011C8540(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011C8550(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011C8590(void *a1, uint64_t a2, id *a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v14, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    uint64_t v15 = *(void *)(a2 + 16);
  }
  sub_10010DFA0((uint64_t)v21, a4);
  uint64_t v7 = (std::__shared_weak_count *)a1[3];
  if (v7)
  {
    uint64_t v8 = a1[1];
    char v9 = std::__shared_weak_count::lock(v7);
    if (v9 && a1[2])
    {
      memset(v20, 0, sizeof(v20));
      *(_OWORD *)uint64_t v19 = 0u;
      memset(v18, 0, sizeof(v18));
      sub_100CD7EFC(a3, (uint64_t)v18);
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v17 = 0;
      if (SHIBYTE(v18[3]) < 0)
      {
        sub_10004FC84(__dst, v18[1], (unint64_t)v18[2]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)&v18[1];
        uint64_t v17 = v18[3];
      }
      __int16 v10 = (void *)HIBYTE(v17);
      if (SHIBYTE(v17) < 0) {
        __int16 v10 = __dst[1];
      }
      if (!v10)
      {
        if (SHIBYTE(v17) < 0)
        {
          __dst[1] = (void *)6;
          long long v11 = (char *)__dst[0];
        }
        else
        {
          HIBYTE(v17) = 6;
          long long v11 = (char *)__dst;
        }
        strcpy(v11, "iPhone");
      }
      *(void *)long long buf = v8;
      if (SHIBYTE(v15) < 0)
      {
        sub_10004FC84(&buf[8], v14[0], (unint64_t)v14[1]);
      }
      else
      {
        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v14;
        uint64_t v24 = v15;
      }
      if (SHIBYTE(v17) < 0)
      {
        sub_10004FC84(v25, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)char v25 = *(_OWORD *)__dst;
        v25[2] = v17;
      }
      if (SHIBYTE(v20[0]) < 0)
      {
        sub_10004FC84(v26, v19[0], (unint64_t)v19[1]);
      }
      else
      {
        *(_OWORD *)char v26 = *(_OWORD *)v19;
        void v26[2] = v20[0];
      }
      if (SHIBYTE(v20[3]) < 0)
      {
        sub_10004FC84(__p, v20[1], (unint64_t)v20[2]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)&v20[1];
        __p[2] = v20[3];
      }
      int v28 = (int)v18[0];
      sub_10010DFA0((uint64_t)&v29, (uint64_t)v21);
      BOOL v13 = *(std::__shared_weak_count **)(v8 + 24);
      if (v13)
      {
        if (std::__shared_weak_count::lock(v13)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    char v9 = 0;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = v14;
    if (v15 < 0) {
      uint64_t v12 = (void **)v14[0];
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "invalid cp.s.tr.ctr to handle %{public}s", buf, 0xCu);
  }
  *(void *)long long buf = 0;
  if (!v22) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v22 + 48))(v22, buf);
  sub_100057D78((const void **)buf);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10010E020(v21);
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

void sub_1011C8A94(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    if (*(char *)(v2 + 79) < 0) {
      operator delete(*v3);
    }
    if (*(char *)(v2 + 55) < 0) {
      operator delete(*(void **)(v2 + 32));
    }
    if (*(char *)(v2 + 31) < 0) {
      operator delete(*(void **)(v2 + 8));
    }
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011C8BD8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011C8C18()
{
}

uint64_t *sub_1011C8C24(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v133 = a1;
  uint64_t v134 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 360))
  {
    uint64_t v3 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N there is an ongoing request. new request is kTransferPlanListReq", (uint8_t *)&buf, 2u);
    }
  }
  long long v4 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(v2 + 56) + 40))(*(void *)(v2 + 56));
  if (v4 && (capabilities::ct::defaultVinylCardTypeToGSMA(v4) & 1) == 0)
  {
    buf.__r_.__value_.__r.__words[0] = 0;
    uint64_t v16 = *(void *)(v1 + 136);
    if (!v16) {
      sub_10007B600();
    }
    goto LABEL_44;
  }
  uint64_t v5 = (const void **)(v1 + 32);
  uint64_t v6 = *(void *)(v2 + 712);
  uint64_t v7 = (unsigned __int8 *)(v6 + 144);
  char v8 = *(unsigned char *)(v1 + 55);
  if (v8 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(v1 + 55);
  }
  else {
    uint64_t v9 = *(void *)(v1 + 40);
  }
  uint64_t v10 = *(unsigned __int8 *)(v6 + 167);
  int v11 = (char)v10;
  uint64_t v12 = *(void *)(v6 + 152);
  if ((v10 & 0x80u) == 0) {
    uint64_t v12 = v10;
  }
  if (v9 != v12)
  {
LABEL_24:
    uint64_t v17 = *(NSObject **)(v2 + 48);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_28;
    }
    if (v11 < 0)
    {
      uint64_t v7 = *(unsigned __int8 **)v7;
      if ((v8 & 0x80) == 0) {
        goto LABEL_27;
      }
    }
    else if ((v8 & 0x80) == 0)
    {
LABEL_27:
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v5;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I incompatible product. local: %s, remote: %s", (uint8_t *)&buf, 0x16u);
LABEL_28:
      buf.__r_.__value_.__r.__words[0] = 0;
      uint64_t v16 = *(void *)(v1 + 136);
      if (!v16) {
        sub_10007B600();
      }
      goto LABEL_44;
    }
    uint64_t v5 = (const void **)*v5;
    goto LABEL_27;
  }
  if ((v10 & 0x80u) == 0) {
    BOOL v13 = v7;
  }
  else {
    BOOL v13 = *(unsigned __int8 **)v7;
  }
  if ((*(unsigned char *)(v1 + 55) & 0x80) != 0)
  {
    if (memcmp(*v5, v13, *(void *)(v1 + 40))) {
      goto LABEL_24;
    }
  }
  else if (*(unsigned char *)(v1 + 55))
  {
    uint64_t v14 = (unsigned __int8 *)(v1 + 32);
    uint64_t v15 = *(unsigned __int8 *)(v1 + 55);
    while (*v14 == *v13)
    {
      ++v14;
      ++v13;
      if (!--v15) {
        goto LABEL_30;
      }
    }
    goto LABEL_24;
  }
LABEL_30:
  uint64_t v18 = *(unsigned __int8 *)(v1 + 31);
  int v19 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    uint64_t v18 = *(void *)(v1 + 16);
  }
  if (v18 != 20
    || (v19 >= 0 ? (uint64_t v20 = v1 + 8) : (uint64_t v20 = *(void *)(v1 + 8)),
        (uint64_t v21 = *(void *)v20,
         uint64_t v22 = *(void *)(v20 + 8),
         uint64_t v23 = *(unsigned int *)(v20 + 16),
         v21 == *(void *)"kTransferPlanListReq")
      ? (BOOL v24 = v22 == *(void *)"rPlanListReq")
      : (BOOL v24 = 0),
        v24 ? (BOOL v25 = v23 == *(unsigned int *)"tReq") : (BOOL v25 = 0),
        !v25))
  {
    buf.__r_.__value_.__r.__words[0] = 0;
    uint64_t v16 = *(void *)(v1 + 136);
    if (!v16) {
      sub_10007B600();
    }
LABEL_44:
    (*(void (**)(uint64_t, std::string *))(*(void *)v16 + 48))(v16, &buf);
    sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
    goto LABEL_45;
  }
  sub_1011C7158((void *)v2);
  sub_1011C724C((void *)v2);
  long long v135 = 0;
  memset(v136, 0, sizeof(v136));
  __int16 v139 = 0;
  long long v140 = 0uLL;
  BOOL v27 = *(unsigned int **)(v2 + 608);
  int v28 = *(unsigned int **)(v2 + 616);
  if (v27 == v28) {
    goto LABEL_134;
  }
  do
  {
    if ((subscriber::isEsimCapable() & 1) != 0 || !subscriber::isSimReady()) {
      goto LABEL_133;
    }
    (*(void (**)(std::string *__return_ptr))(**(void **)(v2 + 56) + 640))(&buf);
    char v29 = (*(uint64_t (**)(std::string::size_type, void))(*(void *)buf.__r_.__value_.__l.__data_ + 104))(buf.__r_.__value_.__r.__words[0], *v27);
    if (buf.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    if ((v29 & 1) == 0)
    {
      uint64_t v39 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = subscriber::asString();
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v40;
        uint64_t v41 = v39;
        unsigned int v42 = "#I sim plan from slot (%s) does not support transfer";
        goto LABEL_128;
      }
      goto LABEL_133;
    }
    if (!(*(unsigned int (**)(void))(**(void **)(v2 + 56) + 40))(*(void *)(v2 + 56))) {
      goto LABEL_89;
    }
    (***(void (****)(std::string *__return_ptr))(v2 + 56))(&v138);
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)&v138.__r_.__value_.__l.__data_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = 0uLL;
    signed __int8 v30 = (const void **)(v27 + 18);
    uint64_t v31 = *(void *)(v2 + 608);
    uint64_t v32 = *(void *)(v2 + 616);
    while (1)
    {
      if (v31 == v32)
      {
        int v43 = 1;
        goto LABEL_80;
      }
      if (!subscriber::isValidSimSlot() || !subscriber::isSimReady()) {
        goto LABEL_75;
      }
      uint64_t v33 = *((unsigned __int8 *)v27 + 95);
      if ((v33 & 0x80u) == 0) {
        uint64_t v34 = *((unsigned __int8 *)v27 + 95);
      }
      else {
        uint64_t v34 = *((void *)v27 + 10);
      }
      uint64_t v35 = *(unsigned __int8 *)(v31 + 95);
      int v36 = (char)v35;
      if ((v35 & 0x80u) != 0) {
        uint64_t v35 = *(void *)(v31 + 80);
      }
      if (v34 != v35) {
        goto LABEL_75;
      }
      uint64_t v37 = v36 >= 0 ? (unsigned __int8 *)(v31 + 72) : *(unsigned __int8 **)(v31 + 72);
      if ((v33 & 0x80) != 0) {
        break;
      }
      if (!*((unsigned char *)v27 + 95)) {
        goto LABEL_79;
      }
      uint64_t v38 = 0;
      while (*((unsigned __int8 *)v27 + v38 + 72) == v37[v38])
      {
        if (v33 == ++v38) {
          goto LABEL_79;
        }
      }
LABEL_75:
      v31 += 168;
    }
    if (memcmp(*v30, v37, *((void *)v27 + 10))) {
      goto LABEL_75;
    }
LABEL_79:
    int v43 = 0;
LABEL_80:
    if (buf.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    if (v138.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)v138.__r_.__value_.__l.__size_);
    }
    if (v43)
    {
      uint64_t v44 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v27 + 95) < 0) {
          signed __int8 v30 = (const void **)*v30;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
        uint64_t v41 = v44;
        unsigned int v42 = "#I psim plan [%s] is not enabled on iPad";
        goto LABEL_128;
      }
      goto LABEL_133;
    }
LABEL_89:
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = 0uLL;
    (***(void (****)(std::string *__return_ptr))(v2 + 56))(&buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v45, (Registry *)buf.__r_.__value_.__l.__data_);
    uint64_t v47 = ServiceMap;
    if (v48 < 0)
    {
      long long v49 = (unsigned __int8 *)(v48 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v50 = 5381;
      do
      {
        uint64_t v48 = v50;
        unsigned int v51 = *v49++;
        uint64_t v50 = (33 * v50) ^ v51;
      }
      while (v51);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v142 = v48;
    size_t v52 = sub_10004D37C(&v47[1].__m_.__sig, (unint64_t *)&v142);
    if (v52)
    {
      uint64_t v53 = v52[3];
      uint64_t v54 = (std::__shared_weak_count *)v52[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v47);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
        char v55 = 0;
        goto LABEL_97;
      }
    }
    else
    {
      uint64_t v53 = 0;
    }
    std::mutex::unlock(v47);
    uint64_t v54 = 0;
    char v55 = 1;
LABEL_97:
    (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v53 + 8))(&v138, v53, *v27);
    if ((v55 & 1) == 0) {
      sub_10004D2C8(v54);
    }
    if (buf.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
    if (v138.__r_.__value_.__r.__words[0])
    {
      long long v142 = 0uLL;
      (*(void (**)(long long *__return_ptr))(*(void *)v138.__r_.__value_.__l.__data_ + 64))(&v142);
      if ((void)v142)
      {
        int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v142 + 64), @"SupportPhysicalSIMtoESIMTransfer");
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)Value;
        if (Value
          && (CFRetain(Value),
              long long v57 = (BOOL *)buf.__r_.__value_.__r.__words[0],
              LOBYTE(v137) = 0,
              buf.__r_.__value_.__r.__words[0])
          && (CFTypeID v58 = CFGetTypeID(buf.__r_.__value_.__l.__data_), v58 == CFBooleanGetTypeID()))
        {
          ctu::cf::assign((ctu::cf *)&v137, v57, v59);
          int v60 = v137;
        }
        else
        {
          int v60 = 0;
        }
        BOOL v62 = v60 != 0;
        sub_1000577C4((const void **)&buf.__r_.__value_.__l.__data_);
        uint64_t v63 = *(NSObject **)(v2 + 48);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = subscriber::asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109378;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v60;
          LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v64;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I SupportPhysicalSIMtoESIMTransfer is set to %d for slot:%s", (uint8_t *)&buf, 0x12u);
        }
      }
      else
      {
        int v65 = *(NSObject **)(v2 + 48);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          uint64_t v73 = subscriber::asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"TransferSIMService";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v73;
          _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "No CarrierEntitlements settings for task %s at slot:%s", (uint8_t *)&buf, 0x16u);
        }
        BOOL v62 = 0;
      }
      if (*((void *)&v142 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v142 + 1));
      }
    }
    else
    {
      long long v61 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        uint64_t v72 = subscriber::asString();
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v72;
        _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "No CarrierEntitlements controller for slot:%s", (uint8_t *)&buf, 0xCu);
      }
      BOOL v62 = 0;
    }
    if (v138.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)v138.__r_.__value_.__l.__size_);
    }
    if (v62)
    {
      std::string v66 = (long long *)(v27 + 18);
      std::string v67 = (long long *)v140;
      if ((unint64_t)v140 >= *((void *)&v140 + 1))
      {
        uint64_t v71 = sub_100048008((uint64_t *)&v139, v66);
      }
      else
      {
        if (*((char *)v27 + 95) < 0)
        {
          sub_10004FC84((unsigned char *)v140, *((void **)v27 + 9), *((void *)v27 + 10));
        }
        else
        {
          long long v68 = *v66;
          *(void *)(v140 + 16) = *((void *)v27 + 11);
          long long *v67 = v68;
        }
        uint64_t v71 = (uint64_t)v67 + 24;
      }
      *(void *)&long long v140 = v71;
    }
    else
    {
      uint64_t v69 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v70 = v27 + 18;
        if (*((char *)v27 + 95) < 0) {
          std::string::size_type v70 = (void *)*v70;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v70;
        uint64_t v41 = v69;
        unsigned int v42 = "#I Physical to ESIM transfer not supported by the carrier for iccid: [%s]";
LABEL_128:
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v42, (uint8_t *)&buf, 0xCu);
      }
    }
LABEL_133:
    v27 += 42;
  }
  while (v27 != v28);
LABEL_134:
  memset(&v138, 0, sizeof(v138));
  uint64_t v74 = *(void *)(v2 + 584);
  key = *(void **)(v2 + 592);
  if ((void *)v74 != key)
  {
    while (!*(unsigned char *)(v74 + 80))
    {
      xpc_object_t v104 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_ERROR, "No profiles present", (uint8_t *)&buf, 2u);
      }
LABEL_213:
      v74 += 88;
      if ((void *)v74 == key)
      {
        xpc_object_t v105 = (std::string *)v138.__r_.__value_.__r.__words[0];
        goto LABEL_216;
      }
    }
    uint64_t v75 = *(void *)(v74 + 56);
    uint64_t v76 = *(void *)(v74 + 64);
LABEL_137:
    if (v75 == v76) {
      goto LABEL_213;
    }
    char v77 = *(unsigned char *)(v75 + 39);
    if (v77 < 0)
    {
      if (!*(void *)(v75 + 24)) {
        goto LABEL_187;
      }
    }
    else if (!*(unsigned char *)(v75 + 39))
    {
      goto LABEL_187;
    }
    uint64_t v78 = (const void **)(v75 + 16);
    if (!*(unsigned char *)(v75 + 89))
    {
      xpc_object_t v89 = *(NSObject **)(v2 + 48);
      if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_187;
      }
      if (v77 < 0) {
        uint64_t v78 = (const void **)*v78;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
      xpc_object_t v90 = v89;
      xpc_object_t v91 = "#I ignore inactive plan: %s";
      goto LABEL_186;
    }
    if (!(*(unsigned int (**)(void))(**(void **)(v2 + 56) + 40))(*(void *)(v2 + 56))) {
      goto LABEL_181;
    }
    (***(void (****)(long long *__return_ptr))(v2 + 56))(&v142);
    std::string::size_type size = (std::__shared_weak_count *)*((void *)&v142 + 1);
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v142;
    long long v142 = 0uLL;
    uint64_t v80 = *(void *)(v2 + 608);
    uint64_t v81 = *(void *)(v2 + 616);
    if (v80 == v81)
    {
      int v88 = 1;
      if (size) {
        goto LABEL_173;
      }
      goto LABEL_174;
    }
    while (1)
    {
      if (subscriber::isValidSimSlot() && subscriber::isSimReady())
      {
        uint64_t v82 = *(unsigned __int8 *)(v75 + 39);
        if ((v82 & 0x80u) == 0) {
          uint64_t v83 = *(unsigned __int8 *)(v75 + 39);
        }
        else {
          uint64_t v83 = *(void *)(v75 + 24);
        }
        uint64_t v84 = *(unsigned __int8 *)(v80 + 95);
        int v85 = (char)v84;
        if ((v84 & 0x80u) != 0) {
          uint64_t v84 = *(void *)(v80 + 80);
        }
        if (v83 == v84)
        {
          if (v85 >= 0) {
            xpc_object_t v86 = (unsigned __int8 *)(v80 + 72);
          }
          else {
            xpc_object_t v86 = *(unsigned __int8 **)(v80 + 72);
          }
          if ((v82 & 0x80) != 0)
          {
            if (!memcmp(*v78, v86, *(void *)(v75 + 24)))
            {
LABEL_171:
              int v88 = 0;
LABEL_172:
              std::string::size_type size = (std::__shared_weak_count *)buf.__r_.__value_.__l.__size_;
              if (buf.__r_.__value_.__l.__size_) {
LABEL_173:
              }
                sub_10004D2C8(size);
LABEL_174:
              if (*((void *)&v142 + 1)) {
                sub_10004D2C8(*((std::__shared_weak_count **)&v142 + 1));
              }
              if (!v88)
              {
LABEL_181:
                if (*(unsigned char *)(v75 + 88))
                {
                  xpc_object_t v93 = *(NSObject **)(v2 + 48);
                  if (!os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_187;
                  }
                  if (*(char *)(v75 + 39) < 0) {
                    uint64_t v78 = (const void **)*v78;
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
                  xpc_object_t v90 = v93;
                  xpc_object_t v91 = "#I ignore bootstrap plan: %s";
                }
                else
                {
                  unint64_t v94 = sub_100CCD974((unsigned __int8 **)(v75 + 16), (uint64_t *)(v2 + 608));
                  if ((v94 & 0xFF00000000) == 0)
                  {
                    xpc_object_t v102 = *(NSObject **)(v2 + 48);
                    if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
                    {
                      if (*(char *)(v75 + 39) < 0) {
                        uint64_t v78 = (const void **)*v78;
                      }
                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
                      _os_log_error_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "cannot find sim instance for plan: %s", (uint8_t *)&buf, 0xCu);
                    }
                    goto LABEL_187;
                  }
                  unint64_t v95 = v94;
                  (*(void (**)(std::string *__return_ptr))(**(void **)(v2 + 56) + 640))(&buf);
                  char v96 = (*(uint64_t (**)(std::string::size_type, unint64_t))(*(void *)buf.__r_.__value_.__l.__data_
                                                                                            + 104))(buf.__r_.__value_.__r.__words[0], v95);
                  if (buf.__r_.__value_.__l.__size_) {
                    sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
                  }
                  xpc_object_t v97 = *(NSObject **)(v2 + 48);
                  BOOL v98 = os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT);
                  if (v96)
                  {
                    if (v98)
                    {
                      std::string::size_type v99 = v75 + 16;
                      if (*(char *)(v75 + 39) < 0) {
                        std::string::size_type v99 = (std::string::size_type)*v78;
                      }
                      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v99;
                      _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I Adding enabled ICCID for preflight: [%s]", (uint8_t *)&buf, 0xCu);
                    }
                    xpc_object_t v100 = (_OWORD *)v138.__r_.__value_.__l.__size_;
                    if (v138.__r_.__value_.__l.__size_ >= v138.__r_.__value_.__r.__words[2])
                    {
                      std::string::size_type v103 = sub_10030E9EC((uint64_t *)&v138, (long long *)(v75 + 16));
                    }
                    else
                    {
                      if (*(char *)(v75 + 39) < 0)
                      {
                        sub_10004FC84((unsigned char *)v138.__r_.__value_.__l.__size_, *(void **)(v75 + 16), *(void *)(v75 + 24));
                      }
                      else
                      {
                        long long v101 = *(_OWORD *)v78;
                        *(void *)(v138.__r_.__value_.__l.__size_ + 16) = *(void *)(v75 + 32);
                        _OWORD *v100 = v101;
                      }
                      std::string::size_type v103 = (std::string::size_type)v100 + 24;
                    }
                    v138.__r_.__value_.__l.__size_ = v103;
                    goto LABEL_187;
                  }
                  if (!v98) {
                    goto LABEL_187;
                  }
                  if (*(char *)(v75 + 39) < 0) {
                    uint64_t v78 = (const void **)*v78;
                  }
                  LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
                  xpc_object_t v90 = v97;
                  xpc_object_t v91 = "#I Active eSIM doesnt support transfer. iccid: %s";
                }
LABEL_186:
                _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, v91, (uint8_t *)&buf, 0xCu);
                goto LABEL_187;
              }
              xpc_object_t v92 = *(NSObject **)(v2 + 48);
              if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(v75 + 39) < 0) {
                  uint64_t v78 = (const void **)*v78;
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v78;
                xpc_object_t v90 = v92;
                xpc_object_t v91 = "#I ignore inactive plan for iPad: %s";
                goto LABEL_186;
              }
LABEL_187:
              v75 += 216;
              goto LABEL_137;
            }
          }
          else
          {
            if (!*(unsigned char *)(v75 + 39)) {
              goto LABEL_171;
            }
            uint64_t v87 = 0;
            while (*(unsigned __int8 *)(v75 + v87 + 16) == v86[v87])
            {
              if (v82 == ++v87) {
                goto LABEL_171;
              }
            }
          }
        }
      }
      v80 += 168;
      if (v80 == v81)
      {
        int v88 = 1;
        goto LABEL_172;
      }
    }
  }
  xpc_object_t v105 = 0;
LABEL_216:
  xpc_object_t v106 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
  {
    sub_100062B40(v105, (std::string *)v138.__r_.__value_.__l.__size_, ",", 1uLL, &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v142) = 136315138;
    *(void *)((char *)&v142 + 4) = p_buf;
    _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "#I active eSIMs:[%s]", (uint8_t *)&v142, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    xpc_object_t v105 = (std::string *)v138.__r_.__value_.__r.__words[0];
  }
  long long v135 = v139;
  *(_OWORD *)v136 = v140;
  long long v140 = 0uLL;
  __int16 v139 = 0;
  sub_100807108((uint64_t *)&v135, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)v136 - (void)v135) >> 3)- 0x5555555555555555 * ((uint64_t)(v138.__r_.__value_.__l.__size_ - (void)v105) >> 3));
  sub_1010B8E28((uint64_t *)&v135, *(std::string **)v136, (std::string *)v138.__r_.__value_.__l.__data_, (long long *)v138.__r_.__value_.__l.__size_, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v138.__r_.__value_.__l.__size_ - v138.__r_.__value_.__r.__words[0]) >> 3));
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v138;
  sub_100047F64((void ***)&buf);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v139;
  sub_100047F64((void ***)&buf);
  xpc_object_t v108 = *(std::__shared_weak_count **)(v2 + 80);
  if (v108)
  {
    xpc_object_t v109 = (capabilities::ct *)std::__shared_weak_count::lock(v108);
    xpc_object_t v110 = (std::__shared_weak_count *)v109;
    if (v109)
    {
      uint64_t v111 = *(void *)(v2 + 72);
      if (v111)
      {
        uint64_t v130 = v109;
        xpc_object_t v112 = v135;
        for (uint64_t i = *(long long **)v136; v112 != i; v112 = (long long *)((char *)v112 + 24))
        {
          memset(&buf, 0, sizeof(buf));
          LODWORD(v145) = 0;
          sub_100058DB0(&v146, "proximity");
          LOWORD(v148) = 1;
          BYTE2(v148) = 1;
          *(_DWORD *)((char *)&v148 + 3) = 0;
          *(_DWORD *)((char *)&v148 + 6) = 0;
          int v113 = (*(uint64_t (**)(uint64_t))(*(void *)v111 + 208))(v111);
          int v114 = *(unsigned __int8 *)(v2 + 872);
          if (v114 == 2)
          {
            if (v113) {
              LOBYTE(v114) = 3;
            }
          }
          else if (*(unsigned char *)(v2 + 872))
          {
            LOBYTE(v114) = 1;
          }
          else if (v113)
          {
            LOBYTE(v114) = 3;
          }
          else
          {
            LOBYTE(v114) = 0;
          }
          BYTE10(v148) = v114;
          __p.n128_u8[0] = 0;
          char v151 = 0;
          *(void *)&v152[0] = CFAbsoluteTimeGetCurrent();
          *(_OWORD *)((char *)v152 + 8) = 0u;
          *(_OWORD *)((char *)&v152[1] + 8) = 0u;
          *(_OWORD *)((char *)&v152[2] + 8) = 0u;
          *(_OWORD *)((char *)&v152[3] + 8) = 0u;
          *(_OWORD *)((char *)&v152[4] + 8) = 0u;
          *(_OWORD *)((char *)&v152[5] + 8) = 0u;
          *(_OWORD *)((char *)&v152[6] + 8) = 0u;
          *(_OWORD *)((char *)&v152[7] + 8) = 0u;
          __int16 v139 = v112;
          xpc_object_t v115 = sub_1011C81F0((uint64_t **)(v2 + 784), (void **)v112, &v139);
          xpc_object_t v116 = (void **)(v115 + 56);
          if (v115[79] < 0) {
            operator delete(*v116);
          }
          *(_OWORD *)xpc_object_t v116 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
          *((void *)v115 + 9) = *((void *)&buf.__r_.__value_.__l + 2);
          *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
          buf.__r_.__value_.__s.__data_[0] = 0;
          *((_DWORD *)v115 + 20) = v145;
          xpc_object_t v117 = (void **)(v115 + 88);
          if (v115[111] < 0) {
            operator delete(*v117);
          }
          *(_OWORD *)xpc_object_t v117 = v146;
          *((void *)v115 + 13) = v147;
          HIBYTE(v147) = 0;
          LOBYTE(v146) = 0;
          *((void *)v115 + 14) = v148;
          *(_DWORD *)(v115 + 119) = *(_DWORD *)((char *)&v148 + 7);
          sub_100179CB0((uint64_t)(v115 + 128), &__p);
          long long v118 = v152[7];
          *((_OWORD *)v115 + 16) = v152[6];
          *((_OWORD *)v115 + 17) = v118;
          uint64_t v119 = *(void *)&v152[8];
          long long v121 = v152[4];
          long long v120 = v152[5];
          long long v122 = v152[3];
          *((_OWORD *)v115 + 12) = v152[2];
          *((_OWORD *)v115 + 13) = v122;
          *((void *)v115 + 36) = v119;
          *((_OWORD *)v115 + 14) = v121;
          *((_OWORD *)v115 + 15) = v120;
          long long v123 = v152[1];
          *((_OWORD *)v115 + 10) = v152[0];
          *((_OWORD *)v115 + 11) = v123;
          if (v151 && v150 < 0) {
            operator delete((void *)__p.n128_u64[0]);
          }
          if (SHIBYTE(v147) < 0) {
            operator delete((void *)v146);
          }
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        if (capabilities::ct::supportsSIMTransferWithSecureIntent(v109)) {
          char v124 = 1;
        }
        else {
          char v124 = 2;
        }
        memset(&v138, 0, sizeof(v138));
        int v125 = *(_DWORD *)(v1 + 104);
        uint64_t v143 = 0;
        long long v142 = 0uLL;
        sub_1000302C0((char *)&v142, v135, *(long long **)v136, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)v136 - (void)v135) >> 3));
        buf.__r_.__value_.__r.__words[0] = v2;
        uint64_t v126 = *(std::__shared_weak_count **)(v2 + 24);
        buf.__r_.__value_.__l.__size_ = *(void *)(v2 + 16);
        if (v126)
        {
          buf.__r_.__value_.__r.__words[2] = (std::string::size_type)std::__shared_weak_count::lock(v126);
          if (buf.__r_.__value_.__r.__words[2])
          {
            sub_10062B11C((uint64_t)&v145, v1 + 112);
            long long v148 = 0uLL;
            __p.n128_u64[0] = 0;
            sub_1000302C0((char *)&v148, v135, *(long long **)v136, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)v136 - (void)v135) >> 3));
            v141 = 0;
            uint64_t v127 = (char *)operator new(0x58uLL);
            *(void *)uint64_t v127 = off_101A9C488;
            *(std::string *)(v127 + 8) = buf;
            *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
            sub_10010DFA0((uint64_t)(v127 + 32), (uint64_t)&v145);
            *((_OWORD *)v127 + 4) = v148;
            *((void *)v127 + 10) = __p.n128_u64[0];
            __p.n128_u64[0] = 0;
            long long v148 = 0uLL;
            v141 = v127;
            sub_1011BF38C(v2, v124, &v138, (const std::string *)(v1 + 56), (const std::string *)(v1 + 80), v125, (std::string **)&v142, (uint64_t)&v139);
            sub_100060644(&v139);
            long long v137 = (void **)&v148;
            sub_100047F64(&v137);
            sub_10010E020(&v145);
            xpc_object_t v110 = (std::__shared_weak_count *)v130;
            if (buf.__r_.__value_.__r.__words[2]) {
              sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__r.__words[2]);
            }
            long long v137 = (void **)&v142;
            sub_100047F64(&v137);
            if (SHIBYTE(v138.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v138.__r_.__value_.__l.__data_);
            }
            goto LABEL_262;
          }
        }
        else
        {
          buf.__r_.__value_.__r.__words[2] = 0;
        }
        sub_100088B9C();
      }
    }
  }
  else
  {
    xpc_object_t v110 = 0;
  }
  uint64_t v128 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_ERROR, "invalid delegate", (uint8_t *)&buf, 2u);
  }
  buf.__r_.__value_.__r.__words[0] = 0;
  uint64_t v129 = *(void *)(v1 + 136);
  if (!v129) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v129 + 48))(v129, &buf);
  sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
LABEL_262:
  if (v110) {
    sub_10004D2C8(v110);
  }
  v138.__r_.__value_.__r.__words[0] = (std::string::size_type)&v135;
  sub_100047F64((void ***)&v138);
LABEL_45:
  sub_1011CA278(&v134);
  return sub_100046B58((uint64_t *)&v133);
}

void sub_1011C9FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  a33 = (uint64_t)&a29;
  sub_100047F64((void ***)&a33);
  sub_1011CA278(&a20);
  sub_100046B58(&a19);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011CA278(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10010E020((void *)(v1 + 112));
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1011CA308(uint64_t a1)
{
  *(void *)a1 = off_101A9C488;
  long long v4 = (void **)(a1 + 64);
  sub_100047F64(&v4);
  sub_10010E020((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011CA374(uint64_t a1)
{
  *(void *)a1 = off_101A9C488;
  uint64_t v3 = (void **)(a1 + 64);
  sub_100047F64(&v3);
  sub_10010E020((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

void *sub_1011CA3F4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A9C488;
  sub_1011CA5F8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011CA448(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CA45C(uint64_t a1, void *a2)
{
  *a2 = off_101A9C488;
  return sub_1011CA5F8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011CA488(uint64_t a1)
{
}

void sub_1011CA490(void *a1)
{
  sub_1011CA6A8((uint64_t)a1 + 8);

  operator delete(a1);
}

void *sub_1011CA4CC(void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = (void **)a1[8];
  long long v4 = (void **)a1[9];
  while (v3 != v4)
  {
    _OWORD v7[3] = 0;
    sub_1011C5690(v2, v3, (uint64_t)v7);
    sub_1000DBADC(v7);
    v3 += 3;
  }
  sub_10062B11C((uint64_t)v6, (uint64_t)(a1 + 4));
  sub_1011BA1D0(v2, (uint64_t *)(v2 + 216), (uint64_t)v6);
  return sub_10010E020(v6);
}

void sub_1011CA580(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010E020(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CA5AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CA5EC()
{
}

uint64_t sub_1011CA5F8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10062B11C(a1 + 24, a2 + 24);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1000302C0((char *)(a1 + 56), *(long long **)(a2 + 56), *(long long **)(a2 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3));
  return a1;
}

void sub_1011CA680(_Unwind_Exception *a1)
{
  sub_10010E020(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_1011CA6A8(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 56);
  sub_100047F64(&v3);
  sub_10010E020((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void *sub_1011CA6F4(void *a1)
{
  *a1 = off_101A9C518;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011CA740(void *a1)
{
  *a1 = off_101A9C518;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011CA7AC(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A9C518;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011CA810(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A9C518;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011CA850(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011CA860(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011CA8A0(void *a1, uint64_t a2, const void **a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  sub_10010DFA0((uint64_t)v14, a4);
  uint64_t v7 = (std::__shared_weak_count *)a1[3];
  if (v7)
  {
    uint64_t v8 = a1[1];
    uint64_t v9 = std::__shared_weak_count::lock(v7);
    if (v9 && a1[2])
    {
      *(void *)std::string buf = v8;
      if (SHIBYTE(v13) < 0)
      {
        sub_10004FC84(&buf[8], v12[0], (unint64_t)v12[1]);
      }
      else
      {
        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v12;
        uint64_t v17 = v13;
      }
      sub_100058198(&v18, a3);
      sub_10062B11C((uint64_t)&v19, (uint64_t)v14);
      uint64_t v10 = *(std::__shared_weak_count **)(v8 + 24);
      if (v10)
      {
        if (std::__shared_weak_count::lock(v10)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    int v11 = v12;
    if (v13 < 0) {
      int v11 = (void **)v12[0];
    }
    *(_DWORD *)std::string buf = 136446210;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "invalid cp.s.tr.ctr to handle %{public}s", buf, 0xCu);
  }
  *(void *)std::string buf = 0;
  if (!v15) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v15 + 48))(v15, buf);
  sub_100057D78((const void **)buf);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10010E020(v14);
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
}

void sub_1011CAB94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_10004D2C8(v28);
  sub_10010E020(&a18);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011CAC10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CAC50()
{
}

uint64_t *sub_1011CAC5C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v37 = a1;
  uint64_t v38 = v1;
  uint64_t v2 = *(unsigned __int8 *)(v1 + 31);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(v1 + 16);
  }
  if (v2 != 24
    || (v3 >= 0 ? (uint64_t v4 = (uint64_t *)(v1 + 8)) : (uint64_t v4 = *(uint64_t **)(v1 + 8)),
        (uint64_t v5 = *v4, v6 = v4[1], v7 = v4[2], v5 == *(void *)"kTransferPlanTransferReq")
      ? (BOOL v8 = v6 == *(void *)"rPlanTransferReq")
      : (BOOL v8 = 0),
        v8 ? (BOOL v9 = v7 == *(void *)"nsferReq") : (BOOL v9 = 0),
        !v9))
  {
    *(void *)&long long buf = 0;
    uint64_t v10 = *(void *)(v1 + 64);
    if (!v10) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v10 + 48))(v10, &buf);
    sub_100057D78((const void **)&buf);
    goto LABEL_16;
  }
  uint64_t v12 = *(void *)v1;
  if (*(void *)(*(void *)v1 + 360))
  {
    uint64_t v13 = *(NSObject **)(v12 + 48);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#N there is an ongoing request. new request is kTransferPlanTransferReq", (uint8_t *)&buf, 2u);
    }
  }
  sub_1011C7158((void *)v12);
  sub_1011C724C((void *)v12);
  sub_100058198(&v41, (const void **)(v1 + 32));
  sub_100CCCE14((id *)&v41, (uint64_t)&v42);
  sub_100057D78(&v41);
  uint64_t v14 = *(std::__shared_weak_count **)(v12 + 80);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_55:
    uint64_t v33 = *(NSObject **)(v12 + 48);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "invalid delegate", (uint8_t *)&buf, 2u);
    }
    *(void *)&long long buf = 0;
    uint64_t v34 = *(void *)(v1 + 64);
    if (!v34) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v34 + 48))(v34, &buf);
    sub_100057D78((const void **)&buf);
    goto LABEL_59;
  }
  uint64_t v15 = (capabilities::ct *)std::__shared_weak_count::lock(v14);
  uint64_t v16 = (std::__shared_weak_count *)v15;
  if (!v15) {
    goto LABEL_55;
  }
  uint64_t v17 = *(void *)(v12 + 72);
  if (!v17) {
    goto LABEL_55;
  }
  uint64_t v35 = v15;
  uint64_t v18 = v42;
  for (i = v43; v18 != i; uint64_t v18 = (long long *)((char *)v18 + 24))
  {
    long long buf = 0uLL;
    LODWORD(v51) = 0;
    uint64_t v50 = 0;
    sub_100058DB0(&v52, "proximity");
    LOBYTE(v54) = 1;
    *(void *)((char *)&v54 + 1) = 0;
    BYTE9(v54) = 0;
    int v19 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 208))(v17);
    int v20 = *(unsigned __int8 *)(v12 + 872);
    if (v20 == 2)
    {
      if (v19) {
        LOBYTE(v20) = 3;
      }
    }
    else if (*(unsigned char *)(v12 + 872))
    {
      LOBYTE(v20) = 1;
    }
    else if (v19)
    {
      LOBYTE(v20) = 3;
    }
    else
    {
      LOBYTE(v20) = 0;
    }
    BYTE10(v54) = v20;
    __p.n128_u8[0] = 0;
    char v57 = 0;
    *(void *)&v58[0] = CFAbsoluteTimeGetCurrent();
    *(_OWORD *)((char *)v58 + 8) = 0u;
    *(_OWORD *)((char *)&v58[1] + 8) = 0u;
    *(_OWORD *)((char *)&v58[2] + 8) = 0u;
    *(_OWORD *)((char *)&v58[3] + 8) = 0u;
    *(_OWORD *)((char *)&v58[4] + 8) = 0u;
    *(_OWORD *)((char *)&v58[5] + 8) = 0u;
    *(_OWORD *)((char *)&v58[6] + 8) = 0u;
    *(_OWORD *)((char *)&v58[7] + 8) = 0u;
    v47[0] = v18;
    uint64_t v21 = sub_1011C81F0((uint64_t **)(v12 + 784), (void **)v18, v47);
    uint64_t v22 = (void **)(v21 + 56);
    if (v21[79] < 0) {
      operator delete(*v22);
    }
    *(_OWORD *)uint64_t v22 = buf;
    *((void *)v21 + 9) = v50;
    HIBYTE(v50) = 0;
    LOBYTE(buf) = 0;
    *((_DWORD *)v21 + 20) = v51;
    uint64_t v23 = (void **)(v21 + 88);
    if (v21[111] < 0) {
      operator delete(*v23);
    }
    *(_OWORD *)uint64_t v23 = v52;
    *((void *)v21 + 13) = v53;
    HIBYTE(v53) = 0;
    LOBYTE(v52) = 0;
    *((void *)v21 + 14) = v54;
    *(_DWORD *)(v21 + 119) = *(_DWORD *)((char *)&v54 + 7);
    sub_100179CB0((uint64_t)(v21 + 128), &__p);
    long long v24 = v58[7];
    *((_OWORD *)v21 + 16) = v58[6];
    *((_OWORD *)v21 + 17) = v24;
    uint64_t v25 = *(void *)&v58[8];
    long long v27 = v58[4];
    long long v26 = v58[5];
    long long v28 = v58[3];
    *((_OWORD *)v21 + 12) = v58[2];
    *((_OWORD *)v21 + 13) = v28;
    *((void *)v21 + 36) = v25;
    *((_OWORD *)v21 + 14) = v27;
    *((_OWORD *)v21 + 15) = v26;
    long long v29 = v58[1];
    *((_OWORD *)v21 + 10) = v58[0];
    *((_OWORD *)v21 + 11) = v29;
    if (v57 && v56 < 0) {
      operator delete((void *)__p.n128_u64[0]);
    }
    if (SHIBYTE(v53) < 0) {
      operator delete((void *)v52);
    }
    if (SHIBYTE(v50) < 0) {
      operator delete((void *)buf);
    }
  }
  if (capabilities::ct::supportsSIMTransferWithSecureIntent(v15)) {
    char v30 = 3;
  }
  else {
    char v30 = 2;
  }
  memset(&v40, 0, sizeof(v40));
  memset(v39, 0, sizeof(v39));
  sub_1000302C0((char *)v39, v42, v43, 0xAAAAAAAAAAAAAAABLL * (((char *)v43 - (char *)v42) >> 3));
  *(void *)&long long buf = v12;
  uint64_t v31 = *(std::__shared_weak_count **)(v12 + 24);
  *((void *)&buf + 1) = *(void *)(v12 + 16);
  if (!v31)
  {
    uint64_t v50 = 0;
LABEL_69:
    sub_100088B9C();
  }
  uint64_t v50 = std::__shared_weak_count::lock(v31);
  if (!v50) {
    goto LABEL_69;
  }
  sub_10062B11C((uint64_t)&v51, v1 + 40);
  long long v54 = 0uLL;
  __p.n128_u64[0] = 0;
  sub_1000302C0((char *)&v54, v42, v43, 0xAAAAAAAAAAAAAAABLL * (((char *)v43 - (char *)v42) >> 3));
  uint64_t v48 = 0;
  uint64_t v32 = (char *)operator new(0x58uLL);
  *(void *)uint64_t v32 = off_101A9C588;
  *(_OWORD *)(v32 + 8) = buf;
  *((void *)v32 + 3) = v50;
  *((void *)&buf + 1) = 0;
  uint64_t v50 = 0;
  sub_10010DFA0((uint64_t)(v32 + 32), (uint64_t)&v51);
  *((void *)v32 + 8) = 0;
  *((void *)v32 + 9) = 0;
  *((void *)v32 + 10) = 0;
  sub_1000302C0(v32 + 64, (long long *)v54, *((long long **)&v54 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v54 + 1) - v54) >> 3));
  uint64_t v48 = v32;
  sub_1011BF38C(v12, v30, &v40, &v44, &v45, -1, v39, (uint64_t)v47);
  sub_100060644(v47);
  char v46 = (std::string **)&v54;
  sub_100047F64((void ***)&v46);
  sub_10010E020(&v51);
  uint64_t v16 = (std::__shared_weak_count *)v35;
  if (v50) {
    sub_10004D2C8(v50);
  }
  char v46 = v39;
  sub_100047F64((void ***)&v46);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
LABEL_59:
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  v40.__r_.__value_.__r.__words[0] = (std::string::size_type)&v42;
  sub_100047F64((void ***)&v40);
LABEL_16:
  sub_1011CB3FC(&v38);
  return sub_100046B58((uint64_t *)&v37);
}

void sub_1011CB270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, __int16 a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,__int16 a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  sub_100060644(&a42);
  sub_100047F64((void ***)&a41);
  sub_10010E020(v48);
  if (a48) {
    sub_10004D2C8((std::__shared_weak_count *)a48);
  }
  a41 = (uint64_t)&a16;
  sub_100047F64((void ***)&a41);
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a9) {
    sub_10004D2C8(a9);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  __n128 __p = &a26;
  sub_100047F64((void ***)&__p);
  sub_1011CB3FC(&a15);
  sub_100046B58(&a14);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011CB3FC(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_10010E020((void *)(v1 + 40));
    sub_100057D78((const void **)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1011CB464(uint64_t a1)
{
  *(void *)a1 = off_101A9C588;
  uint64_t v4 = (void **)(a1 + 64);
  sub_100047F64(&v4);
  sub_10010E020((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011CB4D0(uint64_t a1)
{
  *(void *)a1 = off_101A9C588;
  int v3 = (void **)(a1 + 64);
  sub_100047F64(&v3);
  sub_10010E020((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

void *sub_1011CB550(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A9C588;
  sub_1011CBDCC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011CB5A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CB5B8(uint64_t a1, void *a2)
{
  *a2 = off_101A9C588;
  return sub_1011CBDCC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011CB5E4(uint64_t a1)
{
}

void sub_1011CB5EC(void *a1)
{
  sub_1011CA6A8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011CB628(void *a1)
{
  uint64_t v1 = a1[1];
  uint64_t v34 = dispatch_group_create();
  uint64_t v2 = (char *)operator new(0xF0uLL);
  int v3 = v2;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)uint64_t v2 = off_101A9C5F8;
  uint64_t v4 = v2 + 24;
  if (*(char *)(v1 + 239) < 0)
  {
    sub_10004FC84(v2 + 24, *(void **)(v1 + 216), *(void *)(v1 + 224));
  }
  else
  {
    long long v5 = *(_OWORD *)(v1 + 216);
    *((void *)v2 + 5) = *(void *)(v1 + 232);
    *(_OWORD *)uint64_t v4 = v5;
  }
  uint64_t v33 = v4;
  if (*(char *)(v1 + 263) < 0)
  {
    sub_10004FC84(v3 + 48, *(void **)(v1 + 240), *(void *)(v1 + 248));
  }
  else
  {
    long long v6 = *(_OWORD *)(v1 + 240);
    *((void *)v3 + 8) = *(void *)(v1 + 256);
    *((_OWORD *)v3 + 3) = v6;
  }
  if (*(char *)(v1 + 287) < 0)
  {
    sub_10004FC84(v3 + 72, *(void **)(v1 + 264), *(void *)(v1 + 272));
  }
  else
  {
    long long v7 = *(_OWORD *)(v1 + 264);
    *((void *)v3 + 11) = *(void *)(v1 + 280);
    *(_OWORD *)(v3 + 72) = v7;
  }
  *((void *)v3 + 12) = 0;
  *((void *)v3 + 13) = 0;
  *((void *)v3 + 14) = 0;
  sub_100311ED8((void *)v3 + 12, *(void *)(v1 + 288), *(void *)(v1 + 296), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v1 + 296) - *(void *)(v1 + 288)) >> 3));
  *((void *)v3 + 15) = 0;
  *((void *)v3 + 16) = 0;
  *((void *)v3 + 17) = 0;
  sub_10010CB7C((void *)v3 + 15, *(void *)(v1 + 312), *(void *)(v1 + 320), 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(v1 + 320) - *(void *)(v1 + 312)) >> 3));
  uint64_t v8 = *(void *)(v1 + 336);
  *((void *)v3 + 20) = 0;
  BOOL v9 = v3 + 160;
  *((void *)v3 + 19) = v3 + 160;
  *((void *)v3 + 18) = v8;
  *((void *)v3 + 21) = 0;
  uint64_t v10 = *(void **)(v1 + 344);
  if (v10 == (void *)(v1 + 352))
  {
LABEL_33:
    sub_1000DFC90((uint64_t)(v3 + 176), v1 + 368);
    uint64_t v22 = v3 + 208;
    if (*(char *)(v1 + 423) < 0)
    {
      sub_10004FC84(v22, *(void **)(v1 + 400), *(void *)(v1 + 408));
    }
    else
    {
      long long v23 = *(_OWORD *)(v1 + 400);
      *((void *)v3 + 28) = *(void *)(v1 + 416);
      *(_OWORD *)uint64_t v22 = v23;
    }
    *((_DWORD *)v3 + 58) = *(_DWORD *)(v1 + 424);
    uint64_t v25 = (long long *)a1[8];
    for (i = (long long *)a1[9]; v25 != i; uint64_t v25 = (long long *)((char *)v25 + 24))
    {
      int v36 = (void *)v1;
      if (*((char *)v25 + 23) < 0)
      {
        sub_10004FC84(&__p, *(void **)v25, *((void *)v25 + 1));
      }
      else
      {
        long long v26 = *v25;
        uint64_t v38 = *((void *)v25 + 2);
        long long __p = v26;
      }
      *(void *)&long long v39 = v33;
      *((void *)&v39 + 1) = v3;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
      dispatch_group_t group = v34;
      if (v34)
      {
        dispatch_retain(v34);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      uint64_t v47 = 0;
      long long v27 = (char *)operator new(0x40uLL);
      uint64_t v28 = (uint64_t)v36;
      *(void *)long long v27 = off_101A9C648;
      *((void *)v27 + 1) = v28;
      long long v29 = v27 + 16;
      if (SHIBYTE(v38) < 0)
      {
        sub_10004FC84(v29, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        *(_OWORD *)long long v29 = __p;
        *((void *)v27 + 4) = v38;
      }
      *(_OWORD *)(v27 + 40) = v39;
      long long v39 = 0uLL;
      *((void *)v27 + 7) = group;
      dispatch_group_t group = 0;
      uint64_t v47 = v27;
      sub_1011C5690(v1, (void **)v25, (uint64_t)v46);
      sub_1000DBADC(v46);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      if (*((void *)&v39 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v39 + 1));
      }
      if (SHIBYTE(v38) < 0) {
        operator delete((void *)__p);
      }
    }
    uint64_t v41 = (unsigned char *)v1;
    unsigned int v42 = v33;
    int v43 = v3;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
    sub_10062B11C((uint64_t)&v44, (uint64_t)(a1 + 4));
    char v30 = *(std::__shared_weak_count **)(v1 + 24);
    if (v30)
    {
      uint64_t v31 = *(std::__shared_weak_count **)(v1 + 16);
      uint64_t v32 = std::__shared_weak_count::lock(v30);
      if (v32)
      {
        v45[0] = v31;
        v45[1] = v32;
        atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        operator new();
      }
    }
    sub_100088B9C();
  }
  while (1)
  {
    int v36 = 0;
    int v11 = (void *)*v9;
    if (*((void **)v3 + 19) == v9) {
      break;
    }
    uint64_t v12 = v3 + 160;
    if (v11)
    {
      do
      {
        uint64_t v13 = v11;
        int v11 = (void *)v11[1];
      }
      while (v11);
    }
    else
    {
      do
      {
        uint64_t v13 = (void *)v12[2];
        BOOL v14 = *v13 == (void)v12;
        uint64_t v12 = v13;
      }
      while (v14);
    }
    if (sub_1011B8DB8((uint64_t)(v13 + 4), (uint64_t)(v10 + 4)))
    {
      if (!*v9) {
        goto LABEL_18;
      }
LABEL_20:
      int v36 = v13;
      uint64_t v15 = (uint64_t **)(v13 + 1);
      goto LABEL_22;
    }
    uint64_t v15 = (uint64_t **)sub_1011CBEFC((uint64_t)(v3 + 152), &v36, (uint64_t)(v10 + 4));
LABEL_22:
    if (!*v15) {
      goto LABEL_23;
    }
LABEL_27:
    int v20 = (void *)v10[1];
    if (v20)
    {
      do
      {
        uint64_t v21 = v20;
        int v20 = (void *)*v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        uint64_t v21 = (void *)v10[2];
        BOOL v14 = *v21 == (void)v10;
        uint64_t v10 = v21;
      }
      while (!v14);
    }
    uint64_t v10 = v21;
    if (v21 == (void *)(v1 + 352)) {
      goto LABEL_33;
    }
  }
  uint64_t v13 = v3 + 160;
  if (!v11)
  {
LABEL_18:
    int v36 = v3 + 160;
    uint64_t v15 = (uint64_t **)(v3 + 160);
LABEL_23:
    int v43 = 0;
    uint64_t v16 = operator new(0x140uLL);
    uint64_t v17 = v16;
    uint64_t v41 = v16;
    unsigned int v42 = v3 + 160;
    if (*((char *)v10 + 55) < 0)
    {
      sub_10004FC84(v16 + 32, (void *)v10[4], v10[5]);
    }
    else
    {
      long long v18 = *((_OWORD *)v10 + 2);
      *((void *)v16 + 6) = v10[6];
      *((_OWORD *)v16 + 2) = v18;
    }
    int v19 = *((_DWORD *)v10 + 14);
    *(_DWORD *)(v17 + 59) = *(_DWORD *)((char *)v10 + 59);
    *((_DWORD *)v17 + 14) = v19;
    sub_10030DA1C(v17 + 64, (long long *)v10 + 4);
    LOBYTE(v43) = 1;
    sub_100046C38((uint64_t **)v3 + 19, (uint64_t)v36, v15, (uint64_t *)v17);
    uint64_t v41 = 0;
    sub_1011CBF90((uint64_t)&v41);
    goto LABEL_27;
  }
  goto LABEL_20;
}

void sub_1011CBBE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, uint64_t a12, uint64_t a13, void **a14, dispatch_object_t object, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,dispatch_group_t group,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  sub_100060644(v37);
  sub_1011C7BD8(*v36);
  *(void *)(v39 - 128) = a12;
  sub_10008A88C((void ***)(v39 - 128));
  *(void *)(v39 - 128) = a13;
  sub_1000C56F4((void ***)(v39 - 128));
  if (*(char *)(v38 + 95) < 0) {
    operator delete(*a10);
  }
  if (*(char *)(v38 + 71) < 0) {
    operator delete(*a11);
  }
  if (*(char *)(v38 + 47) < 0) {
    operator delete(*a14);
  }
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v38);
  operator delete(v41);
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011CBD80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CBDC0()
{
}

uint64_t sub_1011CBDCC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10062B11C(a1 + 24, a2 + 24);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1000302C0((char *)(a1 + 56), *(long long **)(a2 + 56), *(long long **)(a2 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3));
  return a1;
}

void sub_1011CBE54(_Unwind_Exception *a1)
{
  sub_10010E020(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_1011CBE7C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9C5F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011CBE9C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9C5F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011CBEF0(uint64_t a1)
{
  return sub_1011C7B3C(a1 + 24);
}

void *sub_1011CBEFC(uint64_t a1, void *a2, uint64_t a3)
{
  long long v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        long long v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1011B8DB8(a3, (uint64_t)(v4 + 4))) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        long long v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1011B8DB8(v8, a3)) {
        break;
      }
      long long v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    long long v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void sub_1011CBF90(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1011C7C2C((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t sub_1011CBFE8(uint64_t a1)
{
  *(void *)a1 = off_101A9C648;
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    int v3 = *(NSObject **)(a1 + 56);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1011CC05C(uint64_t a1)
{
  *(void *)a1 = off_101A9C648;
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (v2)
  {
    dispatch_group_leave(v2);
    int v3 = *(NSObject **)(a1 + 56);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1011CC0F0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A9C648;
  sub_1011CC3B8(v2 + 1, v1);
  return v2;
}

void sub_1011CC144(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1011CC158(uint64_t a1, void *a2)
{
  *a2 = off_101A9C648;
  return sub_1011CC3B8(a2 + 1, a1 + 8);
}

void sub_1011CC184(uint64_t a1)
{
}

void sub_1011CC18C(void *a1)
{
  sub_1011CC444((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011CC1C8(uint64_t a1, uint64_t a2, std::string *a3)
{
  std::string v18 = *a3;
  unint64_t v3 = v18.__r_.__value_.__r.__words[2];
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  unint64_t size = HIBYTE(v3);
  char v5 = size;
  if ((size & 0x80u) != 0) {
    unint64_t size = v18.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    long long v7 = *(void **)(v6 + 128);
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 16);
      uint64_t v20 = *(void *)(a1 + 32);
    }
    uint64_t v8 = (void *)(v6 + 136);
    char v9 = HIBYTE(v20);
    if (v7 != (void *)(v6 + 136))
    {
      if (v20 >= 0) {
        uint64_t v10 = (void *)HIBYTE(v20);
      }
      else {
        uint64_t v10 = __p[1];
      }
      if (v20 >= 0) {
        int v11 = __p;
      }
      else {
        int v11 = (void **)__p[0];
      }
      do
      {
        uint64_t v12 = *((unsigned __int8 *)v7 + 55);
        if ((v12 & 0x80u) == 0) {
          uint64_t v13 = (void *)*((unsigned __int8 *)v7 + 55);
        }
        else {
          uint64_t v13 = (void *)v7[5];
        }
        if (v13 == v10)
        {
          if ((v12 & 0x80) != 0)
          {
            if (!memcmp((const void *)v7[4], v11, v7[5])) {
              goto LABEL_32;
            }
          }
          else
          {
            if (!*((unsigned char *)v7 + 55)) {
              goto LABEL_32;
            }
            uint64_t v14 = 0;
            while (*((unsigned __int8 *)v7 + v14 + 32) == *((unsigned __int8 *)v11 + v14))
            {
              if (v12 == ++v14) {
                goto LABEL_32;
              }
            }
          }
        }
        uint64_t v15 = (void *)v7[1];
        if (v15)
        {
          do
          {
            uint64_t v16 = v15;
            uint64_t v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            uint64_t v16 = (void *)v7[2];
            BOOL v17 = *v16 == (void)v7;
            long long v7 = v16;
          }
          while (!v17);
        }
        long long v7 = v16;
      }
      while (v16 != v8);
      long long v7 = v8;
    }
LABEL_32:
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    if (v7 != v8)
    {
      std::string::operator=((std::string *)(v7 + 29), &v18);
      char v5 = HIBYTE(v18.__r_.__value_.__r.__words[2]);
    }
  }
  if (v5 < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
}

void sub_1011CC350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011CC36C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9C6A8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011CC3AC()
{
  return &off_101A9C6A8;
}

void *sub_1011CC3B8(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  uint64_t v4 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    v4[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }
  uint64_t v6 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  long long v7 = *(NSObject **)(a2 + 48);
  a1[6] = v7;
  if (v7)
  {
    dispatch_retain(v7);
    uint64_t v8 = a1[6];
    if (v8) {
      dispatch_group_enter(v8);
    }
  }
  return a1;
}

void sub_1011CC444(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (v2)
  {
    dispatch_group_leave(v2);
    unint64_t v3 = *(NSObject **)(a1 + 48);
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 31) < 0)
  {
    long long v5 = *(void **)(a1 + 8);
    operator delete(v5);
  }
}

void *sub_1011CC4B0(void *result)
{
  uint64_t v1 = (void *)*result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[8];
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    sub_10010E020(v1 + 3);
    unint64_t v3 = (std::__shared_weak_count *)v1[2];
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

void *sub_1011CC518(uint64_t *a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (a1[7])
      {
        uint64_t v6 = (uint64_t *)a1[1];
        sub_10062B11C((uint64_t)v9, (uint64_t)(a1 + 3));
        sub_1011BA1D0(v3, v6, (uint64_t)v9);
        sub_10010E020(v9);
      }
      sub_10004D2C8(v5);
    }
  }
  return sub_1011CC4B0(&v8);
}

void sub_1011CC5D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10010E020(&a10);
  sub_10004D2C8(v10);
  sub_1011CC4B0(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CC5FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_1011CC67C(uint64_t a1)
{
  *(void *)a1 = off_101A9C6E8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10033022C((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1011CC6E0(uint64_t a1)
{
  *(void *)a1 = off_101A9C6E8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10033022C((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1011CC764(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A9C6E8;
  sub_1011CCAB0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011CC7B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CC7CC(uint64_t a1, void *a2)
{
  *a2 = off_101A9C6E8;
  return sub_1011CCAB0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011CC7F8(uint64_t a1)
{
}

void sub_1011CC800(void *a1)
{
  sub_1011CCBF0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011CC83C(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v22 = 0;
  memset(__dst, 0, sizeof(__dst));
  long long v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v5)
  {
    uint64_t v6 = 0;
LABEL_31:
    sub_10030D9BC(v20, (uint64_t)__dst);
    sub_100B4CB0C(a1 + 40, (uint64_t)v20, 5);
    goto LABEL_32;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v5);
  if (!v6 || !v3 || !*(void *)(a1 + 72)) {
    goto LABEL_31;
  }
  long long v7 = *(void **)(v4 + 344);
  uint64_t v8 = (void *)(v4 + 352);
  if (v7 == (void *)(v4 + 352))
  {
LABEL_29:
    char v19 = 5;
    goto LABEL_40;
  }
  int v9 = *(char *)(a1 + 39);
  if (v9 >= 0) {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 39);
  }
  else {
    uint64_t v10 = *(void *)(a1 + 24);
  }
  if (v9 >= 0) {
    int v11 = (unsigned __int8 *)(a1 + 16);
  }
  else {
    int v11 = *(unsigned __int8 **)(a1 + 16);
  }
  while (1)
  {
    uint64_t v12 = *((unsigned __int8 *)v7 + 55);
    if ((v12 & 0x80u) == 0) {
      uint64_t v13 = *((unsigned __int8 *)v7 + 55);
    }
    else {
      uint64_t v13 = v7[5];
    }
    if (v13 != v10) {
      goto LABEL_23;
    }
    uint64_t v14 = (const void **)(v7 + 4);
    if ((v12 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v7 + 55)) {
      goto LABEL_39;
    }
    uint64_t v15 = v11;
    while (*(unsigned __int8 *)v14 == *v15)
    {
      uint64_t v14 = (const void **)((char *)v14 + 1);
      ++v15;
      if (!--v12) {
        goto LABEL_39;
      }
    }
LABEL_23:
    uint64_t v16 = (void *)v7[1];
    if (v16)
    {
      do
      {
        BOOL v17 = v16;
        uint64_t v16 = (void *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        BOOL v17 = (void *)v7[2];
        BOOL v18 = *v17 == (void)v7;
        long long v7 = v17;
      }
      while (!v18);
    }
    long long v7 = v17;
    if (v17 == v8) {
      goto LABEL_29;
    }
  }
  if (memcmp(*v14, v11, v7[5])) {
    goto LABEL_23;
  }
LABEL_39:
  sub_100B53774(__dst, (std::string *)(v7 + 8));
  char v19 = 0;
LABEL_40:
  sub_10030D9BC(v20, (uint64_t)__dst);
  sub_100B4CB0C(a1 + 40, (uint64_t)v20, v19);
LABEL_32:
  if (v20[256]) {
    sub_1000C5578((uint64_t)v20);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  if ((_BYTE)v22) {
    sub_1000C5578((uint64_t)__dst);
  }
}

void sub_1011CCA1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,__int16 a43)
{
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (LOBYTE(STACK[0x210])) {
    sub_1000C5578((uint64_t)&a43);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011CCA64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CCAA4()
{
}

uint64_t sub_1011CCAB0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1011CCB58(a1 + 32, a2 + 32);
  uint64_t v5 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1011CCB3C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011CCB58(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1011CCBF0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10033022C((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 8);
    operator delete(v3);
  }
}

uint64_t sub_1011CCC4C(uint64_t a1)
{
  *(void *)a1 = off_101A9C768;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10033022C((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1011CCCB0(uint64_t a1)
{
  *(void *)a1 = off_101A9C768;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_10033022C((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1011CCD34(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  *uint64_t v2 = off_101A9C768;
  sub_1011CD200((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011CCD88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CCD9C(uint64_t a1, void *a2)
{
  *a2 = off_101A9C768;
  return sub_1011CD200((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011CCDC8(uint64_t a1)
{
}

void sub_1011CCDD0(void *a1)
{
  sub_1011CCBF0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011CCE0C(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v5)
  {
    uint64_t v6 = 0;
LABEL_31:
    LOBYTE(__dst[0]) = 0;
    char v26 = 0;
    sub_100B4CB0C(a1 + 40, (uint64_t)__dst, 5);
    goto LABEL_32;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v5);
  if (!v6 || !v3 || !*(void *)(a1 + 72)) {
    goto LABEL_31;
  }
  long long v7 = *(void **)(v4 + 344);
  if (v7 == (void *)(v4 + 352))
  {
LABEL_29:
    char v18 = 5;
    goto LABEL_40;
  }
  int v8 = *(char *)(a1 + 39);
  if (v8 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(a1 + 39);
  }
  else {
    uint64_t v9 = *(void *)(a1 + 24);
  }
  if (v8 >= 0) {
    uint64_t v10 = (unsigned __int8 *)(a1 + 16);
  }
  else {
    uint64_t v10 = *(unsigned __int8 **)(a1 + 16);
  }
  while (1)
  {
    uint64_t v11 = *((unsigned __int8 *)v7 + 55);
    if ((v11 & 0x80u) == 0) {
      uint64_t v12 = *((unsigned __int8 *)v7 + 55);
    }
    else {
      uint64_t v12 = v7[5];
    }
    if (v12 != v9) {
      goto LABEL_23;
    }
    uint64_t v13 = (const void **)(v7 + 4);
    if ((v11 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v7 + 55)) {
      goto LABEL_39;
    }
    uint64_t v14 = v10;
    while (*(unsigned __int8 *)v13 == *v14)
    {
      uint64_t v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v11) {
        goto LABEL_39;
      }
    }
LABEL_23:
    uint64_t v15 = (void *)v7[1];
    if (v15)
    {
      do
      {
        uint64_t v16 = v15;
        uint64_t v15 = (void *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        uint64_t v16 = (void *)v7[2];
        BOOL v17 = *v16 == (void)v7;
        long long v7 = v16;
      }
      while (!v17);
    }
    long long v7 = v16;
    if (v16 == (void *)(v4 + 352)) {
      goto LABEL_29;
    }
  }
  if (memcmp(*v13, v10, v7[5])) {
    goto LABEL_23;
  }
LABEL_39:
  sub_100B53774((char *)v23, (std::string *)(v7 + 8));
  char v18 = 0;
LABEL_40:
  sub_10030D9BC((char *)__dst, (uint64_t)v23);
  char v19 = (void **)(a1 + 16);
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    long long __p = *(_OWORD *)v19;
    uint64_t v28 = *(void *)(a1 + 32);
  }
  char v29 = v18;
  sub_1011CCB58((uint64_t)v30, a1 + 40);
  uint64_t v32 = 0;
  uint64_t v20 = operator new(0x150uLL);
  uint64_t v21 = v20;
  *(void *)uint64_t v20 = off_101A9C7D8;
  unsigned char v20[8] = 0;
  char v20[264] = 0;
  if (v26)
  {
    sub_1003300C4((uint64_t)(v20 + 8), __dst);
    v21[264] = 1;
  }
  uint64_t v22 = v21 + 272;
  if (SHIBYTE(v28) < 0)
  {
    sub_10004FC84(v22, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)uint64_t v22 = __p;
    *((void *)v21 + 36) = v28;
  }
  v21[296] = v29;
  sub_1011CC5FC((uint64_t)(v21 + 304), (uint64_t)v30);
  uint64_t v32 = v21;
  sub_1011C5690(v4, v19, (uint64_t)v31);
  sub_1000DBADC(v31);
  sub_10033022C(v30);
  if (SHIBYTE(v28) < 0) {
    operator delete((void *)__p);
  }
LABEL_32:
  if (v26) {
    sub_1000C5578((uint64_t)__dst);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  if ((_BYTE)v24) {
    sub_1000C5578((uint64_t)v23);
  }
}

void sub_1011CD114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,char a43)
{
  if (v44[264]) {
    sub_1000C5578(v46);
  }
  operator delete(v44);
  sub_10033022C(v45);
  if (SLOBYTE(STACK[0x22F]) < 0) {
    operator delete((void *)STACK[0x218]);
  }
  if (LOBYTE(STACK[0x210])) {
    sub_1000C5578((uint64_t)&a43);
  }
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (a41) {
    sub_1000C5578((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011CD1B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CD1F4()
{
}

uint64_t sub_1011CD200(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1011CCB58(a1 + 32, a2 + 32);
  uint64_t v5 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1011CD28C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011CD2A8(uint64_t a1)
{
  *(void *)a1 = off_101A9C7D8;
  sub_10033022C((void *)(a1 + 304));
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  if (*(unsigned char *)(a1 + 264)) {
    sub_1000C5578(a1 + 8);
  }
  return a1;
}

void sub_1011CD310(uint64_t a1)
{
  *(void *)a1 = off_101A9C7D8;
  sub_10033022C((void *)(a1 + 304));
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  if (*(unsigned char *)(a1 + 264)) {
    sub_1000C5578(a1 + 8);
  }

  operator delete();
}

char *sub_1011CD398(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (char *)operator new(0x150uLL);
  *(void *)uint64_t v2 = off_101A9C7D8;
  sub_1011CD60C(v2 + 8, v1);
  return v2;
}

void sub_1011CD3EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1011CD400(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9C7D8;
  return sub_1011CD60C((char *)(a2 + 8), a1 + 8);
}

void sub_1011CD42C(uint64_t a1)
{
}

void sub_1011CD434(void *a1)
{
  sub_1011CD6B8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011CD470(uint64_t a1, uint64_t a2, std::string *a3)
{
  long long v4 = (std::string *)(a1 + 8);
  std::string __p = *a3;
  unint64_t v5 = __p.__r_.__value_.__r.__words[2];
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  unint64_t size = HIBYTE(v5);
  if ((size & 0x80u) != 0) {
    unint64_t size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    if (!*(unsigned char *)(a1 + 264))
    {
      memset(__dst, 0, sizeof(__dst));
      sub_1011CD718(a1 + 8, __dst);
      sub_1000C5578((uint64_t)__dst);
      std::string::operator=(v4, (const std::string *)(a1 + 272));
    }
    std::string::operator=((std::string *)(a1 + 176), &__p);
    sub_10030D9BC((char *)__dst, (uint64_t)v4);
    sub_100B4CB0C(a1 + 304, (uint64_t)__dst, *(unsigned char *)(a1 + 296));
  }
  else
  {
    sub_10030D9BC((char *)__dst, (uint64_t)v4);
    sub_100B4CB0C(a1 + 304, (uint64_t)__dst, *(unsigned char *)(a1 + 296));
  }
  if (v9) {
    sub_1000C5578((uint64_t)__dst);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1011CD588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  if (a48) {
    sub_1000C5578((uint64_t)&a16);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011CD5C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CD600()
{
}

char *sub_1011CD60C(char *a1, uint64_t a2)
{
  long long v4 = sub_10030D9BC(a1, a2);
  if (*(char *)(a2 + 287) < 0)
  {
    sub_10004FC84(v4 + 264, *(void **)(a2 + 264), *(void *)(a2 + 272));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 264);
    *((void *)v4 + 35) = *(void *)(a2 + 280);
    *(_OWORD *)(v4 + 264) = v5;
  }
  a1[288] = *(unsigned char *)(a2 + 288);
  sub_1011CCB58((uint64_t)(a1 + 296), a2 + 296);
  return a1;
}

void sub_1011CD684(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 256)) {
    sub_1000C5578(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011CD6B8(uint64_t a1)
{
  sub_10033022C((void *)(a1 + 296));
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  if (*(unsigned char *)(a1 + 256))
  {
    sub_1000C5578(a1);
  }
}

uint64_t sub_1011CD718(uint64_t a1, long long *a2)
{
  if (*(unsigned char *)(a1 + 256))
  {
    sub_100B62F98(a1, a2);
  }
  else
  {
    sub_1003300C4(a1, a2);
    *(unsigned char *)(a1 + 256) = 1;
  }
  return a1;
}

uint64_t sub_1011CD760(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_1011CD7F8(void *a1)
{
  *a1 = off_101A9C868;
  sub_100060644(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011CD848(void *a1)
{
  *a1 = off_101A9C868;
  sub_100060644(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011CD8B8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A9C868;
  sub_1011CDC60((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011CD90C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011CD920(uint64_t a1, void *a2)
{
  *a2 = off_101A9C868;
  return sub_1011CDC60((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011CD94C(uint64_t a1)
{
}

void sub_1011CD954(void *a1)
{
  sub_100322E6C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011CD990(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v17 = 0;
  char v18 = 0;
  (***(void (****)(Registry **__return_ptr))(v4 + 56))(&v13);
  Registry::getNotificationSenderFactory((uint64_t *)&v15, v13);
  long long v5 = v15;
  (***(void (****)(Registry **__return_ptr))(v4 + 56))(&v9);
  Registry::getTimerService(&v11, v9);
  (*(void (**)(uint64_t *__return_ptr, Registry *, uint64_t *, uint64_t))(*(void *)v5 + 160))(&v17, v5, &v11, v4 + 32);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v17)
  {
    uint64_t v13 = 0;
    CFMutableDictionaryRef Mutable = (Registry *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      long long v7 = v13;
      uint64_t v13 = Mutable;
      uint64_t v15 = v7;
      sub_10005717C((const void **)&v15);
    }
    sub_1011CDCC8((__CFDictionary *)v13, @"kTransferInformationSent", 1, kCFAllocatorDefault);
    uint64_t v8 = v17;
    sub_10004EFE4(&v15, (CFTypeRef *)&v13);
    (*(void (**)(uint64_t, Registry **))(*(void *)v8 + 40))(v8, &v15);
    sub_100057D78((const void **)&v15);
    sub_10005717C((const void **)&v13);
  }
  sub_1011B94C8(v4);
  sub_1000607A8(a1 + 32, v3 != 0);
  if (v18) {
    sub_10004D2C8(v18);
  }
}

void sub_1011CDB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, const void *);
  uint64_t v10 = va_arg(va1, void);
  sub_100057D78((const void **)va1);
  sub_10005717C((const void **)va);
  long long v7 = *(std::__shared_weak_count **)(v5 - 40);
  if (v7) {
    sub_10004D2C8(v7);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011CDC14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CDC54()
{
}

uint64_t sub_1011CDC60(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 24, a2 + 24);
  return a1;
}

void sub_1011CDCB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011CDCC8(__CFDictionary *a1, void *cf, int a3, CFAllocatorRef allocator)
{
  key = cf;
  if (cf) {
    CFRetain(cf);
  }
  int valuePtr = a3;
  CFNumberRef v7 = CFNumberCreate(allocator, kCFNumberIntType, &valuePtr);
  CFNumberRef v11 = v7;
  if (key) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  uint64_t v9 = !v8;
  if (!v8) {
    CFDictionaryAddValue(a1, key, v7);
  }
  sub_10010F494((const void **)&v11);
  sub_10010F494((const void **)&key);
  return v9;
}

void sub_1011CDD5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

void *sub_1011CDD80(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      BOOL v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      BOOL v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    BOOL v8 = 0;
  }
  if (v7 != a1)
  {
    uint64_t v4 = v8;
    uint64_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        BOOL v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        BOOL v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        BOOL v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      BOOL v8 = v7;
    }
    else
    {
      BOOL v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100313814(v7);
  return a1;
}

void sub_1011CE084(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1011CE090(uint64_t a1, uint64_t a2, std::string *a3)
{
  memset(&v53, 0, sizeof(v53));
  if (*(void *)(a1 + 360))
  {
    uint64_t v4 = a1 + 352;
    uint64_t v5 = *(void *)(a1 + 336);
    if (v5 != a1 + 352)
    {
      std::string::operator=(&v53, (const std::string *)(v5 + 32));
      BOOL v8 = *(std::__shared_weak_count **)(a1 + 80);
      if (v8)
      {
        uint64_t v9 = std::__shared_weak_count::lock(v8);
        if (v9)
        {
          uint64_t v10 = v9;
          uint64_t v11 = *(void *)(a1 + 72);
          if (v11)
          {
            int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 208))(v11);
            if (v12) {
              char v13 = 3;
            }
            else {
              char v13 = 2;
            }
            if (v12) {
              char v14 = 3;
            }
            else {
              char v14 = 0;
            }
            if (*(unsigned char *)(a1 + 872)) {
              char v15 = 1;
            }
            else {
              char v15 = v14;
            }
            if (*(unsigned char *)(a1 + 872) == 2) {
              char v16 = v13;
            }
            else {
              char v16 = v15;
            }
            *(void *)long long buf = &v53;
            sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v53.__r_.__value_.__l.__data_, (long long **)buf)[122] = v16;
          }
          sub_10004D2C8(v10);
        }
      }
      *(void *)long long buf = &v53;
      sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v53.__r_.__value_.__l.__data_, (long long **)buf)[115] = 1;
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      *(void *)long long buf = &v53;
      char v18 = sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v53.__r_.__value_.__l.__data_, (long long **)buf);
      *((CFAbsoluteTime *)v18 + 23) = Current;
      std::string v52 = *a3;
      a3->__r_.__value_.__l.__size_ = 0;
      a3->__r_.__value_.__r.__words[2] = 0;
      a3->__r_.__value_.__r.__words[0] = 0;
      if (!*(void *)(a1 + 360) || *(void *)(a1 + 336) == v4)
      {
        uint64_t v21 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid iterator. skip perform transfer type request", buf, 2u);
        }
        goto LABEL_108;
      }
      uint64_t v58 = 0;
      long long v57 = 0u;
      long long v55 = 0u;
      memset(v56, 0, sizeof(v56));
      *(_OWORD *)long long buf = 0u;
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v19 = *(void *)(a1 + 248);
      }
      else {
        uint64_t v19 = *(unsigned __int8 *)(a1 + 263);
      }
      if (!v19)
      {
LABEL_83:
        WORD2(v56[0]) = 257;
        int v45 = capabilities::ct::supportsSIMTransferWithSecureIntent((capabilities::ct *)v18);
        uint64_t v46 = 2;
        if (v45) {
          uint64_t v46 = 3;
        }
        *((void *)&v57 + 1) = v46;
        LOBYTE(v58) = 1;
        std::string::size_type size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
        if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = v52.__r_.__value_.__l.__size_;
        }
        if (size) {
          sub_100093B44((std::string *)buf, &v52);
        }
        memset(__dst, 0, sizeof(__dst));
        v63[0] = 0;
        uint64_t v48 = *(void *)(a1 + 336);
        if (*(char *)(v48 + 55) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v48 + 32), *(void *)(v48 + 40));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)(v48 + 32);
          v63[0] = *(void **)(v48 + 48);
        }
        long long v49 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v50 = __dst;
          if (SHIBYTE(v63[0]) < 0) {
            uint64_t v50 = *(uint8_t **)__dst;
          }
          *(_DWORD *)aBlock = 136315138;
          *(void *)&aBlock[4] = v50;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I [req][ta] perform TransferAuthorization for type request. iccid : %s", aBlock, 0xCu);
        }
        uint64_t v51 = *(void *)(a1 + 136);
        *(void *)aBlock = _NSConcreteStackBlock;
        *(void *)&aBlock[8] = 1174405120;
        *(void *)&aBlock[16] = sub_1011C44D0;
        *(void *)&aBlock[24] = &unk_101A9C320;
        *(void *)&aBlock[32] = a1;
        if (SHIBYTE(v63[0]) < 0)
        {
          sub_10004FC84(&aBlock[40], *(void **)__dst, *(unint64_t *)&__dst[8]);
        }
        else
        {
          *(_OWORD *)&aBlock[40] = *(_OWORD *)__dst;
          *(void **)&aBlock[56] = v63[0];
        }
        LODWORD(v69) = a2;
        value = _Block_copy(aBlock);
        (*(void (**)(uint64_t, uint64_t, uint8_t *, void, void **))(*(void *)v51 + 32))(v51, a2, buf, 0, &value);
        if (value) {
          _Block_release(value);
        }
        if ((aBlock[63] & 0x80000000) != 0) {
          operator delete(*(void **)&aBlock[40]);
        }
        if (SHIBYTE(v63[0]) < 0) {
          operator delete(*(void **)__dst);
        }
        sub_1001A0540((uint64_t)v56 + 8);
        if (BYTE8(v55) && SBYTE7(v55) < 0) {
          operator delete(*(void **)buf);
        }
LABEL_108:
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v52.__r_.__value_.__l.__data_);
        }
        goto LABEL_110;
      }
      uint64_t v74 = 0;
      long long v72 = 0uLL;
      long long v73 = 0uLL;
      long long v70 = 0uLL;
      long long v71 = 0uLL;
      long long v69 = 0uLL;
      memset(aBlock, 0, sizeof(aBlock));
      std::string::operator=((std::string *)aBlock, (const std::string *)(a1 + 240));
      if (*(char *)(a1 + 287) < 0)
      {
        if (!*(void *)(a1 + 272)) {
          goto LABEL_72;
        }
      }
      else if (!*(unsigned char *)(a1 + 287))
      {
LABEL_72:
        sub_1008C26DC((std::string *)((char *)v56 + 8), (std::string *)aBlock);
        if ((_BYTE)v74 && SHIBYTE(v73) < 0) {
          operator delete(*((void **)&v72 + 1));
        }
        if ((_BYTE)v72 && SHIBYTE(v71) < 0) {
          operator delete(*((void **)&v70 + 1));
        }
        if (BYTE8(v69) && SBYTE7(v69) < 0) {
          operator delete(*(void **)&aBlock[48]);
        }
        *(void *)long long __dst = &aBlock[24];
        sub_1001A010C((void ***)__dst);
        if ((aBlock[23] & 0x80000000) != 0) {
          operator delete(*(void **)aBlock);
        }
        goto LABEL_83;
      }
      CFDictionaryRef theDict = 0;
      (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(__dst);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *(Registry **)__dst);
      uint64_t v24 = ServiceMap;
      if (v25 < 0)
      {
        char v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v27 = 5381;
        do
        {
          uint64_t v25 = v27;
          unsigned int v28 = *v26++;
          uint64_t v27 = (33 * v27) ^ v28;
        }
        while (v28);
      }
      std::mutex::lock(ServiceMap);
      value = (void *)v25;
      char v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)&value);
      if (v29)
      {
        uint64_t v31 = v29[3];
        char v30 = (std::__shared_weak_count *)v29[4];
        if (v30)
        {
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v24);
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v30);
          char v32 = 0;
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v31 = 0;
      }
      std::mutex::unlock(v24);
      char v30 = 0;
      char v32 = 1;
LABEL_42:
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v31 + 80))(&v59, v31, a2, 1, @"PhoneAccountTransfer", 0, 0);
      sub_10004EFE4(&theDict, &v59);
      sub_1000577C4(&v59);
      if ((v32 & 1) == 0) {
        sub_10004D2C8(v30);
      }
      if (*(void *)&__dst[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&__dst[8]);
      }
      if (theDict) {
        uint64_t v33 = sub_100080778;
      }
      else {
        uint64_t v33 = 0;
      }
      if (!v33)
      {
        std::string v40 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          uint64_t v41 = subscriber::asString();
          *(_DWORD *)long long __dst = 136315138;
          *(void *)&__dst[4] = v41;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Get kCBPhoneAccountTransfer bundle value failed. slot:%s", __dst, 0xCu);
        }
        goto LABEL_61;
      }
      value = 0;
      if (CFDictionaryGetValueIfPresent(theDict, @"SendTargetIMEIInTransferAuthorizationForTypeRequest", (const void **)&value))
      {
        uint64_t v34 = (BOOL *)value;
        __dst[0] = 1;
        if (value)
        {
          CFTypeID v35 = CFGetTypeID(value);
          if (v35 == CFBooleanGetTypeID())
          {
            ctu::cf::assign((ctu::cf *)__dst, v34, v36);
            if (!__dst[0])
            {
              sub_100057D78((const void **)&theDict);
              goto LABEL_72;
            }
          }
        }
        uint64_t v37 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = subscriber::asString();
          *(_DWORD *)long long __dst = 136315138;
          *(void *)&__dst[4] = v38;
          uint64_t v39 = "#I kCBSendTargetIMEIInTransferAuthorizationForTypeRequest value true. slot:%s";
LABEL_60:
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v39, __dst, 0xCu);
        }
      }
      else
      {
        uint64_t v37 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = subscriber::asString();
          *(_DWORD *)long long __dst = 136315138;
          *(void *)&__dst[4] = v42;
          uint64_t v39 = "#I kCBSendTargetIMEIInTransferAuthorizationForTypeRequest not found in bundle. slot:%s";
          goto LABEL_60;
        }
      }
LABEL_61:
      sub_100057D78((const void **)&theDict);
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      *(_OWORD *)std::string __p = 0u;
      *(_OWORD *)long long __dst = 0u;
      *(_OWORD *)uint64_t v63 = 0u;
      sub_100093B44((std::string *)&v63[1], (const std::string *)(a1 + 264));
      uint64_t v43 = *(void *)&aBlock[32];
      if (*(void *)&aBlock[32] >= *(void *)&aBlock[40])
      {
        uint64_t v44 = sub_100D15584((uint64_t *)&aBlock[24], (long long *)__dst);
      }
      else
      {
        sub_10019FFDC(*(void **)&aBlock[32], (long long *)__dst);
        uint64_t v44 = v43 + 96;
      }
      *(void *)&aBlock[32] = v44;
      if ((_BYTE)v67 && SHIBYTE(v66) < 0) {
        operator delete(__p[1]);
      }
      if (LOBYTE(__p[0]) && SHIBYTE(v64) < 0) {
        operator delete(v63[1]);
      }
      if (SHIBYTE(v63[0]) < 0) {
        operator delete(*(void **)__dst);
      }
      goto LABEL_72;
    }
  }
  uint64_t v20 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 16777472;
    uint8_t buf[4] = 1;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid iterator. skip request_type:%hhu", buf, 5u);
  }
LABEL_110:
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
}

void sub_1011CE908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,int a49,const void *a50,void *aBlock,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  sub_100057D78(&a50);
  sub_10019FD98(v57 - 256);
  sub_100B56FB8((uint64_t)&a21);
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void sub_1011CEA34(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v7 = v5;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)BOOL v8 = *(_OWORD *)a2;
    v8[2] = *(void **)(a2 + 16);
  }
  int v9 = *(_DWORD *)(a1 + 88);
  char v10 = a3;
  long long v11 = *(_OWORD *)(a1 + 40);
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 56);
    __p[2] = *(void **)(a1 + 72);
  }
  char v13 = *(unsigned char *)(a1 + 80);
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 24);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011CEC78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a2)
  {
    if (*(char *)(v17 + 31) < 0) {
      operator delete(*v18);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1011CECD0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  __n128 result = (void *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    result[2] = *(void *)(a2 + 72);
    *(_OWORD *)__n128 result = v5;
  }
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
  return result;
}

void sub_1011CED30(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
}

uint64_t *sub_1011CED44(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  if (!*(unsigned char *)(v1 + 36))
  {
    uint64_t v3 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Authenticate Trust Score failed", (uint8_t *)&buf, 2u);
    }
  }
  if (*(char *)(v1 + 31) < 0)
  {
    if (*(void *)(v1 + 16)) {
      goto LABEL_10;
    }
  }
  else if (*(unsigned char *)(v1 + 31))
  {
    goto LABEL_10;
  }
  uint64_t v4 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No authenticate token available", (uint8_t *)&buf, 2u);
  }
LABEL_10:
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v6 = (std::string::size_type *)(v1 + 56);
  buf.__r_.__value_.__r.__words[0] = v1 + 56;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v2 + 784), (void **)(v1 + 56), (long long **)&buf) + 22) = Current;
  if (*(char *)(v1 + 31) < 0) {
    uint64_t v7 = *(void *)(v1 + 16);
  }
  else {
    uint64_t v7 = *(unsigned __int8 *)(v1 + 31);
  }
  buf.__r_.__value_.__r.__words[0] = v1 + 56;
  *((_WORD *)sub_1011C81F0((uint64_t **)(v2 + 784), (void **)(v1 + 56), (long long **)&buf) + 59) = (v7 != 0) | 0x100;
  if (*(void *)(v2 + 360))
  {
    uint64_t v8 = *(void *)(v2 + 336);
    if (v8 != v2 + 352)
    {
      uint64_t v9 = *(unsigned __int8 *)(v8 + 55);
      size_t v10 = *(void *)(v8 + 40);
      if ((v9 & 0x80u) == 0) {
        uint64_t v11 = *(unsigned __int8 *)(v8 + 55);
      }
      else {
        uint64_t v11 = *(void *)(v8 + 40);
      }
      uint64_t v12 = *(unsigned __int8 *)(v1 + 79);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(v1 + 64);
      }
      if (v11 == v12)
      {
        char v14 = (const void **)(v8 + 32);
        if (v13 >= 0) {
          char v15 = (unsigned __int8 *)(v1 + 56);
        }
        else {
          char v15 = (unsigned __int8 *)*v6;
        }
        if ((v9 & 0x80) == 0)
        {
          if (v9)
          {
            while (*(unsigned __int8 *)v14 == *v15)
            {
              char v14 = (const void **)((char *)v14 + 1);
              ++v15;
              if (!--v9) {
                goto LABEL_33;
              }
            }
            goto LABEL_30;
          }
LABEL_33:
          uint64_t v18 = *(unsigned int *)(v1 + 32);
          if (*(char *)(v1 + 31) < 0)
          {
            sub_10004FC84(&buf, *(void **)(v1 + 8), *(void *)(v1 + 16));
          }
          else
          {
            long long v19 = *(_OWORD *)(v1 + 8);
            buf.__r_.__value_.__r.__words[2] = *(void *)(v1 + 24);
            *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v19;
          }
          sub_1011CE090(v2, v18, &buf);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
          goto LABEL_32;
        }
        if (!memcmp(*v14, v15, v10)) {
          goto LABEL_33;
        }
      }
    }
  }
LABEL_30:
  char v16 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    std::string::size_type v20 = v1 + 56;
    if (*(char *)(v1 + 79) < 0) {
      std::string::size_type v20 = *v6;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v20;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "carrier auth attempt for %s has timed out", (uint8_t *)&buf, 0xCu);
  }
  buf.__r_.__value_.__r.__words[0] = v1 + 56;
  *((_DWORD *)sub_1011C81F0((uint64_t **)(v2 + 784), (void **)(v1 + 56), (long long **)&buf) + 20) = 70072;
  uint64_t v24 = 0;
  sub_1011C5690(v2, (void **)(v1 + 56), (uint64_t)&buf);
  sub_1000DBADC(&buf);
LABEL_32:
  sub_1011CF08C(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_1011CF048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011CF08C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011CF08C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1011CF0F4(uint64_t a1)
{
  *(void *)a1 = off_101A9C918;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1011CF144(uint64_t a1)
{
  *(void *)a1 = off_101A9C918;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void *sub_1011CF1B4(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = off_101A9C918;
  v2[1] = v3;
  *(void *)((char *)v2 + 13) = *(void *)(a1 + 13);
  uint64_t v4 = v2 + 3;
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)uint64_t v4 = *(_OWORD *)(a1 + 24);
    v2[5] = *(void *)(a1 + 40);
  }
  return v2;
}

void sub_1011CF238(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1011CF24C(char *result, void *a2)
{
  *a2 = off_101A9C918;
  uint64_t v2 = *((void *)result + 1);
  *(void *)((char *)a2 + 13) = *(void *)(result + 13);
  a2[1] = v2;
  uint64_t v3 = a2 + 3;
  if (result[47] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 3), *((void *)result + 4));
  }
  long long v4 = *(_OWORD *)(result + 24);
  a2[5] = *((void *)result + 5);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_1011CF2A8(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void sub_1011CF2BC(void **__p)
{
  if (*((char *)__p + 47) < 0) {
    operator delete(__p[3]);
  }

  operator delete(__p);
}

void sub_1011CF300(uint64_t a1, uint64_t a2)
{
  v22[0] = 0;
  char v26 = 0;
  if (!*(unsigned char *)(a2 + 256))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    goto LABEL_35;
  }
  sub_1003300C4((uint64_t)v22, (long long *)a2);
  char v26 = 1;
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = *(unsigned char *)(a1 + 20);
  if (!v24 || (int v5 = v23, !sub_1008A200C(v23)) && v5 != 3)
  {
    if ((v4 & 2) == 0)
    {
      int v6 = v25;
      if ((v25 & 0xFE) != 4) {
        goto LABEL_35;
      }
      uint64_t v7 = *(NSObject **)(v3 + 48);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
LABEL_27:
        sub_1000C5578((uint64_t)v22);
        char v26 = 0;
        goto LABEL_35;
      }
      uint64_t v8 = "kNoError";
      if (v6 == 4) {
        uint64_t v8 = "kTransferAuthorizationForTypeFailedByCarrier";
      }
      if (v6 == 5) {
        uint64_t v8 = "kTransferAuthorizationForTypeFailedDueToInternalError";
      }
      *(_DWORD *)std::string buf = 136315138;
      char v29 = v8;
      uint64_t v9 = "#I TA for type failed during listing with error: %s";
      size_t v10 = v7;
      uint32_t v11 = 12;
      goto LABEL_25;
    }
    char v12 = sub_1011C11D8(v3, *(unsigned int *)(a1 + 16));
    if (!v26) {
      sub_10016C840();
    }
    char v13 = v12;
    int v14 = v25;
    int v15 = v25 & 0xFE;
    char v16 = *(NSObject **)(v3 + 48);
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (v15 == 4)
    {
      if (v17)
      {
        uint64_t v18 = "kNoError";
        if (v14 == 4) {
          uint64_t v18 = "kTransferAuthorizationForTypeFailedByCarrier";
        }
        if (v14 == 5) {
          uint64_t v18 = "kTransferAuthorizationForTypeFailedDueToInternalError";
        }
        *(_DWORD *)std::string buf = 136315138;
        char v29 = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I TA for type failed during transfer with error: %s", buf, 0xCu);
      }
      char v19 = sub_1011C15B8(v3, *(unsigned int *)(a1 + 16)) ^ 1 | v13;
      std::string::size_type v20 = *(NSObject **)(v3 + 48);
      BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      if (v19)
      {
        if (!v21) {
          goto LABEL_26;
        }
        *(_WORD *)std::string buf = 0;
        uint64_t v9 = "#I Continue with token generation";
        size_t v10 = v20;
        uint32_t v11 = 2;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
LABEL_26:
        if (!v26) {
          goto LABEL_35;
        }
        goto LABEL_27;
      }
      if (v21)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Finish transfer before TA for token", buf, 2u);
      }
      goto LABEL_34;
    }
    if (v17)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Transfer type returned by carrier during transfer not one-click or websheet", buf, 2u);
    }
    if ((v13 & 1) == 0) {
LABEL_34:
    }
      *(unsigned char *)(*(void *)(v3 + 336) + 62) = 3;
  }
LABEL_35:
  sub_10030D9BC(__dst, (uint64_t)v22);
  sub_1011C3428(v3, (uint64_t)__dst);
  if (__dst[256]) {
    sub_1000C5578((uint64_t)__dst);
  }
  if (v26) {
    sub_1000C5578((uint64_t)v22);
  }
}

void sub_1011CF5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,int a42,__int16 a43)
{
  if (LOBYTE(STACK[0x208])) {
    sub_1000C5578((uint64_t)&a43);
  }
  if (a41) {
    sub_1000C5578((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011CF628(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011CF668()
{
}

void sub_1011CF674(uint64_t a1, unsigned int a2, long long *a3)
{
  memset(&v68, 0, sizeof(v68));
  if (*(void *)(a1 + 360))
  {
    uint64_t v4 = *(void *)(a1 + 336);
    if (v4 != a1 + 352)
    {
      std::string::operator=(&v68, (const std::string *)(v4 + 32));
      int v6 = *(std::__shared_weak_count **)(a1 + 80);
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = *(void *)(a1 + 72);
          if (v9)
          {
            int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 208))(v9);
            if (v10) {
              char v11 = 3;
            }
            else {
              char v11 = 2;
            }
            if (v10) {
              char v12 = 3;
            }
            else {
              char v12 = 0;
            }
            if (*(unsigned char *)(a1 + 872)) {
              char v13 = 1;
            }
            else {
              char v13 = v12;
            }
            if (*(unsigned char *)(a1 + 872) == 2) {
              char v14 = v11;
            }
            else {
              char v14 = v13;
            }
            *(void *)std::string buf = &v68;
            sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v68.__r_.__value_.__l.__data_, (long long **)buf)[122] = v14;
          }
          sub_10004D2C8(v8);
        }
      }
      uint64_t v15 = *(void *)(a1 + 336);
      if (*(unsigned char *)(v15 + 89)) {
        unsigned int v16 = *(unsigned __int8 *)(v15 + 88);
      }
      else {
        unsigned int v16 = 0;
      }
      if (sub_1008A200C(v16)) {
        int v18 = sub_1011C15B8(a1, a2);
      }
      else {
        int v18 = 0;
      }
      char v19 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v20 = sub_1008A1E44(v16);
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v20;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v18;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I tranfer-type:%s, secure-intent:%d", buf, 0x12u);
      }
      long long v94 = 0uLL;
      sub_100CCD2E8();
      memset(v93, 0, sizeof(v93));
      uint64_t v92 = a1;
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(v93, v68.__r_.__value_.__l.__data_, v68.__r_.__value_.__l.__size_);
      }
      else {
        *(std::string *)xpc_object_t v93 = v68;
      }
      *(_OWORD *)&v93[24] = *(_OWORD *)(a1 + 808);
      *(_OWORD *)&v93[40] = v94;
      if (*(char *)(a1 + 239) < 0)
      {
        sub_10004FC84(&v93[56], *(void **)(a1 + 216), *(void *)(a1 + 224));
      }
      else
      {
        *(_OWORD *)&v93[56] = *(_OWORD *)(a1 + 216);
        *(void *)&v93[72] = *(void *)(a1 + 232);
      }
      if ((v18 & 1) == 0)
      {
        sub_1011D07F8((uint64_t)&v92);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        *(void *)std::string buf = &v68;
        *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v68.__r_.__value_.__l.__data_, (long long **)buf)+ 29) = Current;
        *(void *)std::string buf = &v68;
        if (!sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v68.__r_.__value_.__l.__data_, (long long **)buf)[113])
        {
          *(void *)std::string buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          (***(void (****)(Registry **__return_ptr))(a1 + 56))(v75);
          Registry::getNotificationSenderFactory((uint64_t *)__p, v75[0]);
          char v24 = __p[0];
          (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v72);
          Registry::getTimerService(&v66, v72);
          (*(void (**)(uint8_t *__return_ptr, void *, uint64_t *, uint64_t))(*(void *)v24 + 160))(buf, v24, &v66, a1 + 32);
          if (v67) {
            sub_10004D2C8(v67);
          }
          if (v73) {
            sub_10004D2C8(v73);
          }
          if (__p[1]) {
            sub_10004D2C8((std::__shared_weak_count *)__p[1]);
          }
          if (v75[1]) {
            sub_10004D2C8((std::__shared_weak_count *)v75[1]);
          }
          if (*(void *)buf)
          {
            v75[0] = 0;
            CFMutableDictionaryRef Mutable = (Registry *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              char v26 = v75[0];
              v75[0] = Mutable;
              __p[0] = v26;
              sub_10005717C((const void **)__p);
            }
            sub_1011CDCC8((__CFDictionary *)v75[0], @"kTransferWebsheet", 1, kCFAllocatorDefault);
            uint64_t v27 = *(void *)buf;
            sub_10004EFE4(&v65, (CFTypeRef *)v75);
            (*(void (**)(uint64_t, const void **))(*(void *)v27 + 40))(v27, &v65);
            sub_100057D78(&v65);
            sub_10005717C((const void **)v75);
          }
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        std::string v64 = *(std::string *)a3;
        *((void *)a3 + 1) = 0;
        *((void *)a3 + 2) = 0;
        *(void *)a3 = 0;
        sub_1011C34E8(a1, a2, &v64, 0, 3);
        if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_143;
        }
        unsigned int v28 = (void *)v64.__r_.__value_.__r.__words[0];
        goto LABEL_142;
      }
      CFAbsoluteTime v21 = CFAbsoluteTimeGetCurrent();
      *(void *)std::string buf = &v68;
      *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(a1 + 784), (void **)&v68.__r_.__value_.__l.__data_, (long long **)buf)+ 35) = v21;
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v63 = 0;
      v75[0] = 0;
      v75[1] = 0;
      uint64_t v76 = 0;
      sub_1011BEAD4(v75, a1, (uint64_t)&v68);
      if (capabilities::ct::supportsSequoia(v22))
      {
        if (SHIBYTE(v76) < 0)
        {
          sub_10004FC84(__dst, v75[0], (unint64_t)v75[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)v75;
          uint64_t v63 = v76;
        }
        goto LABEL_113;
      }
      (***(void (****)(uint8_t *__return_ptr))(a1 + 56))(buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v29, *(Registry **)buf);
      uint64_t v31 = ServiceMap;
      if (v32 < 0)
      {
        uint64_t v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v34 = 5381;
        do
        {
          uint64_t v32 = v34;
          unsigned int v35 = *v33++;
          uint64_t v34 = (33 * v34) ^ v35;
        }
        while (v35);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v32;
      CFBooleanRef v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)__p);
      if (v36)
      {
        uint64_t v37 = a3;
        uint64_t v39 = v36[3];
        uint64_t v38 = (std::__shared_weak_count *)v36[4];
        if (v38)
        {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v31);
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          int v60 = v38;
          sub_10004D2C8(v38);
          char v40 = 0;
          a3 = v37;
          goto LABEL_67;
        }
        a3 = v37;
      }
      else
      {
        uint64_t v39 = 0;
      }
      std::mutex::unlock(v31);
      int v60 = 0;
      char v40 = 1;
LABEL_67:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (!v39)
      {
        uint64_t v41 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "invalid personalityshop", buf, 2u);
        }
        if (SHIBYTE(v76) < 0)
        {
          sub_10004FC84(__dst, v75[0], (unint64_t)v75[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)v75;
          uint64_t v63 = v76;
        }
        goto LABEL_111;
      }
      uint64_t v103 = 0;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      memset(buf, 0, sizeof(buf));
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(__p, v68.__r_.__value_.__l.__data_, v68.__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
        v96[0] = (void *)v68.__r_.__value_.__r.__words[2];
      }
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v39 + 168))(buf, v39, __p);
      if (SHIBYTE(v96[0]) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v42 = BYTE7(v101);
      if (SBYTE7(v101) < 0) {
        uint64_t v42 = *((void *)&v100 + 1);
      }
      if (v42)
      {
        uint64_t v43 = HIBYTE(v103);
        if (v103 < 0) {
          uint64_t v43 = *((void *)&v102 + 1);
        }
        if (v43)
        {
          long long v72 = 0;
          long long v73 = 0;
          uint64_t v74 = 0;
          if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&v71, v68.__r_.__value_.__l.__data_, v68.__r_.__value_.__l.__size_);
          }
          else {
            std::string v71 = v68;
          }
          sub_1011BB094((uint64_t)&v72, a1, (void **)&v71.__r_.__value_.__l.__data_);
          if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v71.__r_.__value_.__l.__data_);
          }
          *(_OWORD *)char v96 = 0u;
          long long v97 = 0u;
          *(_OWORD *)std::string __p = 0u;
          sub_100E63EA4((uint64_t)__p);
          (***(void (****)(Registry **__return_ptr))(a1 + 56))(&v69);
          sub_100CD69E4(&v69, (const void **)&v102, (uint64_t)__p, (uint64_t)__dst);
          if (v70) {
            sub_10004D2C8(v70);
          }
          if (SHIBYTE(v97) < 0) {
            operator delete(v96[1]);
          }
          if (SHIBYTE(v96[0]) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v74) < 0) {
            operator delete(v72);
          }
          goto LABEL_103;
        }
      }
      else
      {
        uint64_t v44 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          CFBooleanRef v59 = &v68;
          if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            CFBooleanRef v59 = (std::string *)v68.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v59;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "invalid label for %s", (uint8_t *)__p, 0xCu);
        }
      }
      if (SHIBYTE(v76) < 0)
      {
        sub_10004FC84(__dst, v75[0], (unint64_t)v75[1]);
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)v75;
        uint64_t v63 = v76;
      }
LABEL_103:
      if (SHIBYTE(v103) < 0) {
        operator delete((void *)v102);
      }
      if (SBYTE7(v101) < 0) {
        operator delete((void *)v100);
      }
      if (SHIBYTE(v99) < 0) {
        operator delete(*(void **)&buf[24]);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
LABEL_111:
      if ((v40 & 1) == 0) {
        sub_10004D2C8(v60);
      }
LABEL_113:
      if (SHIBYTE(v76) < 0) {
        operator delete(v75[0]);
      }
      *(void *)std::string buf = &v68;
      int v45 = *((unsigned __int8 *)sub_1000ED870((uint64_t **)(a1 + 560), (void **)&v68.__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)buf)+ 56);
      uint64_t v77 = a1;
      if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v78, v68.__r_.__value_.__l.__data_, v68.__r_.__value_.__l.__size_);
      }
      else {
        std::string v78 = v68;
      }
      unsigned int v79 = a2;
      if (*((char *)a3 + 23) < 0)
      {
        sub_10004FC84(&v80, *(void **)a3, *((void *)a3 + 1));
      }
      else
      {
        long long v80 = *a3;
        uint64_t v81 = *((void *)a3 + 2);
      }
      long long v84 = *(_OWORD *)v93;
      long long v86 = *(_OWORD *)&v93[24];
      char v82 = v18;
      uint64_t v46 = v92;
      uint64_t v83 = v92;
      uint64_t v85 = *(void *)&v93[16];
      memset(v93, 0, 24);
      long long v87 = *(_OWORD *)&v93[40];
      long long v88 = *(_OWORD *)&v93[56];
      uint64_t v89 = *(void *)&v93[72];
      memset(&v93[56], 0, 24);
      xpc_object_t v91 = 0;
      uint64_t v47 = (char *)operator new(0xA8uLL);
      uint64_t v48 = v77;
      *(void *)uint64_t v47 = off_101A9CA58;
      *((void *)v47 + 1) = v48;
      *(std::string *)(v47 + 16) = v78;
      memset(&v78, 0, sizeof(v78));
      *((_DWORD *)v47 + 10) = v79;
      *((_OWORD *)v47 + 3) = v80;
      *((void *)v47 + 8) = v81;
      uint64_t v81 = 0;
      long long v80 = 0uLL;
      v47[72] = v18;
      *((void *)v47 + 10) = v46;
      long long v49 = v84;
      *((void *)v47 + 13) = v85;
      *(_OWORD *)(v47 + 88) = v49;
      long long v84 = 0uLL;
      uint64_t v85 = 0;
      long long v50 = *(_OWORD *)&v93[40];
      *((_OWORD *)v47 + 7) = *(_OWORD *)&v93[24];
      *((_OWORD *)v47 + 8) = v50;
      long long v51 = v88;
      *((void *)v47 + 20) = v89;
      *((_OWORD *)v47 + 9) = v51;
      long long v88 = 0uLL;
      uint64_t v89 = 0;
      xpc_object_t v91 = v47;
      uint64_t v52 = *(void *)(a1 + 768);
      if (!v52)
      {
        uint64_t v53 = *(void *)(a1 + 56);
        long long v54 = *(NSObject **)(a1 + 32);
        __p[0] = v54;
        if (v54) {
          dispatch_retain(v54);
        }
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v53 + 936))(buf, v53, __p);
        long long v55 = *(_OWORD *)buf;
        *(void *)std::string buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        char v56 = *(std::__shared_weak_count **)(a1 + 776);
        *(_OWORD *)(a1 + 768) = v55;
        if (v56)
        {
          sub_10004D2C8(v56);
          if (*(void *)&buf[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
          }
        }
        if (__p[0]) {
          dispatch_release((dispatch_object_t)__p[0]);
        }
        uint64_t v57 = *(void *)(a1 + 768);
        if (!v57)
        {
          uint64_t v58 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "create SecureIntentController failed", buf, 2u);
          }
          sub_10024924C((uint64_t)v90, 4);
          goto LABEL_132;
        }
        (*(void (**)(uint64_t))(*(void *)v57 + 16))(v57);
        uint64_t v52 = *(void *)(a1 + 768);
      }
      sub_10032CA08((uint64_t)buf, (uint64_t)v90);
      (*(void (**)(uint64_t, BOOL, void **, uint8_t *))(*(void *)v52 + 32))(v52, v45 != 0, __dst, buf);
      sub_100313668(buf);
LABEL_132:
      sub_100313668(v90);
      if (SHIBYTE(v89) < 0) {
        operator delete((void *)v88);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete((void *)v84);
      }
      if (SHIBYTE(v81) < 0) {
        operator delete((void *)v80);
      }
      if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v78.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(v63) & 0x80000000) == 0) {
        goto LABEL_143;
      }
      unsigned int v28 = __dst[0];
LABEL_142:
      operator delete(v28);
LABEL_143:
      if ((v93[79] & 0x80000000) != 0) {
        operator delete(*(void **)&v93[56]);
      }
      if ((v93[23] & 0x80000000) != 0) {
        operator delete(*(void **)v93);
      }
      goto LABEL_147;
    }
  }
  BOOL v17 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 16777472;
    uint8_t buf[4] = 2;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "invalid iterator. skip request_type:%hhu", buf, 5u);
  }
LABEL_147:
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
}

void sub_1011D0324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1001A7138(v67 - 224);
  if ((v66 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  if (a41 < 0) {
    operator delete(__p);
  }
  sub_1011D0C7C((uint64_t)&a66);
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(a1);
}

void sub_1011D055C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v7 = v5;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
    v8[2] = *(void **)(a2 + 16);
  }
  int v9 = *(_DWORD *)(a1 + 88);
  char v10 = a3;
  long long v11 = *(_OWORD *)(a1 + 40);
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 56);
    __p[2] = *(void **)(a1 + 72);
  }
  char v13 = *(unsigned char *)(a1 + 80);
  int v6 = *(std::__shared_weak_count **)(v5 + 24);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011D07A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a2)
  {
    if (*(char *)(v17 + 31) < 0) {
      operator delete(*v18);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D07F8(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  uint64_t v4 = (uint64_t **)(*(void *)a1 + 784);
  __p[0] = (void *)(a1 + 8);
  uint64_t v5 = sub_1011C81F0(v4, (void **)(a1 + 8), (long long **)__p);
  uint64_t v6 = v5[111];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)v5 + 12);
  }
  if (v6 == 9
    && ((char v10 = (char *)*((void *)v5 + 11), v8 = v5 + 88, v9 = v10, v7 >= 0) ? (v11 = v8) : (v11 = v9),
        (v12 = *(void *)v11, int v13 = v11[8], v12 == 0x74696D69786F7270)
      ? (BOOL v14 = v13 == 121)
      : (BOOL v14 = 0),
        v14))
  {
    if (v3[54])
    {
      __p[0] = v2;
      if (!sub_1011C81F0(v4, (void **)v2, (long long **)__p)[114])
      {
        uint64_t v41 = 0;
        sub_100CD8904(1u, &v41);
        if (v41) {
          char v29 = sub_100080778;
        }
        else {
          char v29 = 0;
        }
        if (v29)
        {
          uint64_t v30 = v3[54];
          sub_100058DB0(__p, "kTransferConsentStatusUpdate");
          uint64_t v38 = v41;
          if (v41) {
            CFRetain(v41);
          }
          uint64_t v37 = 20;
          v42[0] = off_101A9C9D8;
          v42[1] = v3;
          v42[3] = v42;
          (*(void (**)(uint64_t, void **, const void **, void *, uint64_t *, void *))(*(void *)v30 + 16))(v30, __p, &v38, v3 + 4, &v37, v42);
          sub_100B202F4(v42);
          sub_100057D78(&v38);
          if (v40 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          uint64_t v32 = v3[6];
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          {
            LOWORD(__p[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "encode consent state failed", (uint8_t *)__p, 2u);
          }
        }
        sub_100057D78(&v41);
      }
    }
    else
    {
      uint64_t v31 = v3[6];
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "invalid message session handler", (uint8_t *)__p, 2u);
      }
    }
  }
  else
  {
    __p[0] = v2;
    uint64_t v15 = sub_1011C81F0(v4, (void **)v2, (long long **)__p);
    uint64_t v16 = v15[111];
    int v17 = (char)v16;
    if ((v16 & 0x80u) != 0) {
      uint64_t v16 = *((void *)v15 + 12);
    }
    if (v16 == 6)
    {
      std::string::size_type v20 = (char *)*((void *)v15 + 11);
      int v18 = v15 + 88;
      char v19 = v20;
      CFAbsoluteTime v21 = v17 >= 0 ? v18 : v19;
      int v22 = *(_DWORD *)v21;
      int v23 = *((unsigned __int16 *)v21 + 2);
      if (v22 == 1869366121 && v23 == 25717)
      {
        unsigned __int8 v25 = (std::__shared_weak_count *)v3[10];
        if (v25)
        {
          char v26 = std::__shared_weak_count::lock(v25);
          if (v26)
          {
            uint64_t v27 = v26;
            uint64_t v28 = v3[9];
            if (v28)
            {
              if (*(char *)(a1 + 87) < 0)
              {
                sub_10004FC84(__dst, *(void **)(a1 + 64), *(void *)(a1 + 72));
              }
              else
              {
                *(_OWORD *)long long __dst = *(_OWORD *)(a1 + 64);
                uint64_t v36 = *(void *)(a1 + 80);
              }
              if (*(char *)(a1 + 31) < 0)
              {
                sub_10004FC84(v33, *(void **)(a1 + 8), *(void *)(a1 + 16));
              }
              else
              {
                *(_OWORD *)uint64_t v33 = *(_OWORD *)v2;
                uint64_t v34 = v2[2];
              }
              (*(void (**)(uint64_t, void **, void **, void, void, void, void, uint64_t))(*(void *)v28 + 152))(v28, __dst, v33, *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 32), *(void *)(a1 + 40), 1);
              if (SHIBYTE(v34) < 0) {
                operator delete(v33[0]);
              }
              if (SHIBYTE(v36) < 0) {
                operator delete(__dst[0]);
              }
            }
            sub_10004D2C8(v27);
          }
        }
      }
    }
  }
}

void sub_1011D0B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D0C18(uint64_t a1)
{
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_1011D0C7C(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1011D0CC4()
{
}

void *sub_1011D0CD8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A9C9D8;
  result[1] = v3;
  return result;
}

uint64_t sub_1011D0D20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A9C9D8;
  a2[1] = v2;
  return result;
}

const void **sub_1011D0D4C(uint64_t a1, unsigned __int8 *a2, const void **a3)
{
  int v3 = *a2;
  uint64_t v6 = *a3;
  *a3 = 0;
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "send transfer consent status failed", buf, 2u);
    }
  }
  return sub_100057D78(&v6);
}

uint64_t sub_1011D0DD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D0E10()
{
}

uint64_t sub_1011D0E1C(uint64_t a1)
{
  *(void *)a1 = off_101A9CA58;
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1011D0E9C(uint64_t a1)
{
  *(void *)a1 = off_101A9CA58;
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1011D0F3C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xA8uLL);
  *uint64_t v2 = off_101A9CA58;
  sub_1011D13D4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D0F90(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D0FA4(uint64_t a1, void *a2)
{
  *a2 = off_101A9CA58;
  return sub_1011D13D4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D0FD0(uint64_t a1)
{
}

void sub_1011D0FD8(void *a1)
{
  sub_1011D1544((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D1014(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  __p[0].__r_.__value_.__r.__words[0] = a1 + 16;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v4 + 784), (void **)(a1 + 16), (long long **)__p) + 36) = Current;
  if (v3 == 48 || v3 == 45)
  {
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    memset(v12, 0, sizeof(v12));
    std::string::operator=((std::string *)v12, (const std::string *)(a1 + 16));
    LOWORD(v21) = 258;
    __p[0].__r_.__value_.__r.__words[0] = a1 + 16;
    *((_DWORD *)sub_1011C81F0((uint64_t **)(v4 + 784), (void **)(a1 + 16), (long long **)__p) + 20) = 70033;
    sub_10030DA1C((char *)__p, (long long *)v12);
    char v11 = 1;
    sub_1011C39E0(v4, (uint64_t)__p);
LABEL_4:
    if (v11) {
      sub_1000C5578((uint64_t)__p);
    }
    sub_1000C5578((uint64_t)v12);
    return;
  }
  BOOL v6 = *(unsigned char *)(a1 + 72) != 0;
  if (v3)
  {
    int v7 = *(NSObject **)(v4 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "invalid transfer signature and certificate", (uint8_t *)__p, 2u);
    }
    if ((sub_1011C11D8(v4, *(unsigned int *)(a1 + 40)) & 1) == 0)
    {
      __p[0].__r_.__value_.__r.__words[0] = a1 + 16;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v4 + 784), (void **)(a1 + 16), (long long **)__p) + 20) = 70049;
      memset(v12, 0, 24);
      *(_WORD *)&v12[24] = 257;
      LOBYTE(v13) = 0;
      BYTE8(v14) = 0;
      LOBYTE(v15) = 0;
      BYTE8(v16) = 0;
      LOBYTE(v17) = 0;
      BYTE8(v18) = 0;
      if (*(char *)(v4 + 535) < 0)
      {
        sub_10004FC84(&v19, *(void **)(v4 + 512), *(void *)(v4 + 520));
      }
      else
      {
        long long v19 = *(_OWORD *)(v4 + 512);
        *(void *)&long long v20 = *(void *)(v4 + 528);
      }
      BYTE8(v20) = 1;
      LOWORD(v21) = 0;
      long long v22 = 0uLL;
      *((void *)&v21 + 1) = 0;
      LOWORD(v23) = 0;
      BYTE2(v23) = 6;
      BYTE8(v23) = 0;
      LOBYTE(v25) = 0;
      BYTE8(v25) = 0;
      LOBYTE(v26) = 0;
      WORD4(v26) = 0;
      sub_1011C7D34((uint64_t)__p, (long long *)v12);
      sub_1011C39E0(v4, (uint64_t)__p);
      goto LABEL_4;
    }
    BOOL v6 = 0;
  }
  sub_1011D07F8(a1 + 80);
  CFAbsoluteTime v8 = CFAbsoluteTimeGetCurrent();
  __p[0].__r_.__value_.__r.__words[0] = a1 + 16;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v4 + 784), (void **)(a1 + 16), (long long **)__p) + 29) = v8;
  uint64_t v9 = *(unsigned int *)(a1 + 40);
  if (*(char *)(a1 + 71) < 0) {
    sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else {
    __p[0] = *(std::string *)(a1 + 48);
  }
  sub_1011C34E8(v4, v9, __p, v6, 3);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
}

void sub_1011D12E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,char a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,char a63)
{
  if (a70 && a69 < 0) {
    operator delete(__p);
  }
  if (a63 && a62 < 0) {
    operator delete(a57);
  }
  if (a56 && a55 < 0) {
    operator delete(a50);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D1388(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D13C8()
{
}

uint64_t sub_1011D13D4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v5;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 80), *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)(a1 + 80) = v6;
  }
  long long v7 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v7;
  CFAbsoluteTime v8 = (unsigned char *)(a1 + 136);
  if (*(char *)(a2 + 159) < 0)
  {
    sub_10004FC84(v8, *(void **)(a2 + 136), *(void *)(a2 + 144));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 136);
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(_OWORD *)CFAbsoluteTime v8 = v9;
  }
  return a1;
}

void sub_1011D14F8(_Unwind_Exception *exception_object)
{
  if (v1[103] < 0) {
    operator delete(*v4);
  }
  if (v1[63] < 0) {
    operator delete(*v3);
  }
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D1544(uint64_t a1)
{
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

uint64_t *sub_1011D15BC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v21 = a1;
  uint64_t v22 = v1;
  uint64_t v2 = *(void *)v1;
  if (!*(unsigned char *)(v1 + 36))
  {
    int v3 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Authenticate Trust Score failed", buf, 2u);
    }
  }
  if (*(char *)(v1 + 31) < 0)
  {
    if (*(void *)(v1 + 16)) {
      goto LABEL_10;
    }
  }
  else if (*(unsigned char *)(v1 + 31))
  {
    goto LABEL_10;
  }
  long long v4 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No authenticate token available", buf, 2u);
  }
LABEL_10:
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  long long v6 = (uint64_t *)(v1 + 56);
  *(void *)std::string buf = v1 + 56;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v2 + 784), (void **)(v1 + 56), (long long **)buf) + 28) = Current;
  if (*(char *)(v1 + 31) < 0) {
    uint64_t v7 = *(void *)(v1 + 16);
  }
  else {
    uint64_t v7 = *(unsigned __int8 *)(v1 + 31);
  }
  *(void *)std::string buf = v1 + 56;
  *((_WORD *)sub_1011C81F0((uint64_t **)(v2 + 784), (void **)(v1 + 56), (long long **)buf) + 59) = (v7 != 0) | 0x100;
  if (*(void *)(v2 + 360))
  {
    uint64_t v8 = *(void *)(v2 + 336);
    if (v8 != v2 + 352)
    {
      uint64_t v9 = *(unsigned __int8 *)(v8 + 55);
      size_t v10 = *(void *)(v8 + 40);
      if ((v9 & 0x80u) == 0) {
        uint64_t v11 = *(unsigned __int8 *)(v8 + 55);
      }
      else {
        uint64_t v11 = *(void *)(v8 + 40);
      }
      uint64_t v12 = *(unsigned __int8 *)(v1 + 79);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(v1 + 64);
      }
      if (v11 == v12)
      {
        long long v14 = (const void **)(v8 + 32);
        if (v13 >= 0) {
          long long v15 = (unsigned __int8 *)(v1 + 56);
        }
        else {
          long long v15 = (unsigned __int8 *)*v6;
        }
        if ((v9 & 0x80) == 0)
        {
          if (v9)
          {
            while (*(unsigned __int8 *)v14 == *v15)
            {
              long long v14 = (const void **)((char *)v14 + 1);
              ++v15;
              if (!--v9) {
                goto LABEL_33;
              }
            }
            goto LABEL_30;
          }
LABEL_33:
          unsigned int v18 = *(_DWORD *)(v1 + 32);
          if (*(char *)(v1 + 31) < 0)
          {
            sub_10004FC84(buf, *(void **)(v1 + 8), *(void *)(v1 + 16));
          }
          else
          {
            long long v19 = *(_OWORD *)(v1 + 8);
            uint64_t v24 = *(void *)(v1 + 24);
            *(_OWORD *)std::string buf = v19;
          }
          sub_1011CF674(v2, v18, (long long *)buf);
          if (SHIBYTE(v24) < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_32;
        }
        if (!memcmp(*v14, v15, v10)) {
          goto LABEL_33;
        }
      }
    }
  }
LABEL_30:
  long long v16 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    uint64_t v20 = v1 + 56;
    if (*(char *)(v1 + 79) < 0) {
      uint64_t v20 = *v6;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "carrier auth attempt for %s has timed out", buf, 0xCu);
  }
  *(void *)std::string buf = v1 + 56;
  *((_DWORD *)sub_1011C81F0((uint64_t **)(v2 + 784), (void **)(v1 + 56), (long long **)buf) + 20) = 70072;
  uint64_t v25 = 0;
  sub_1011C5690(v2, (void **)(v1 + 56), (uint64_t)buf);
  sub_1000DBADC(buf);
LABEL_32:
  sub_1011CF08C(&v22);
  return sub_100046B58((uint64_t *)&v21);
}

void sub_1011D18C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011CF08C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1011D1908()
{
}

void *sub_1011D191C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A9CAD8;
  result[1] = v3;
  return result;
}

uint64_t sub_1011D1964(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A9CAD8;
  a2[1] = v2;
  return result;
}

void sub_1011D1990(uint64_t a1, uint64_t a2)
{
  v4[0] = 0;
  char v5 = 0;
  if (*(unsigned char *)(a2 + 256))
  {
    sub_1003300C4((uint64_t)v4, (long long *)a2);
    char v5 = 1;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  sub_10030D9BC(__dst, (uint64_t)v4);
  sub_1011C3428(v3, (uint64_t)__dst);
  if (__dst[256]) {
    sub_1000C5578((uint64_t)__dst);
  }
  if (v5) {
    sub_1000C5578((uint64_t)v4);
  }
}

void sub_1011D1A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,int a42,__int16 a43)
{
  if (LOBYTE(STACK[0x208])) {
    sub_1000C5578((uint64_t)&a43);
  }
  if (a41) {
    sub_1000C5578((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D1A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D1A88()
{
}

void sub_1011D1A94(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  char v5 = (uint64_t **)sub_1011CBEFC((uint64_t)a1, &v10, a2);
  if (!*v5)
  {
    long long v6 = v5;
    uint64_t v9 = 0;
    uint64_t v7 = (char *)operator new(0x140uLL);
    v8[1] = a1 + 1;
    *((_OWORD *)v7 + 2) = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *((_DWORD *)v7 + 14) = *(_DWORD *)(a3 + 24);
    *(_DWORD *)(v7 + 59) = *(_DWORD *)(a3 + 27);
    *((void *)v7 + 10) = *(void *)(a3 + 48);
    *((_OWORD *)v7 + 4) = *(_OWORD *)(a3 + 32);
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = 0;
    *(void *)(a3 + 32) = 0;
    *((_WORD *)v7 + 44) = *(_WORD *)(a3 + 56);
    v7[96] = 0;
    v7[120] = 0;
    if (*(unsigned char *)(a3 + 88))
    {
      *((_OWORD *)v7 + 6) = *(_OWORD *)(a3 + 64);
      *((void *)v7 + 14) = *(void *)(a3 + 80);
      *(void *)(a3 + 72) = 0;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 64) = 0;
      v7[120] = 1;
    }
    v7[128] = 0;
    v7[152] = 0;
    if (*(unsigned char *)(a3 + 120))
    {
      *((_OWORD *)v7 + 8) = *(_OWORD *)(a3 + 96);
      *((void *)v7 + 18) = *(void *)(a3 + 112);
      *(void *)(a3 + 104) = 0;
      *(void *)(a3 + 112) = 0;
      *(void *)(a3 + 96) = 0;
      v7[152] = 1;
    }
    v7[160] = 0;
    v7[184] = 0;
    if (*(unsigned char *)(a3 + 152))
    {
      *((_OWORD *)v7 + 10) = *(_OWORD *)(a3 + 128);
      *((void *)v7 + 22) = *(void *)(a3 + 144);
      *(void *)(a3 + 136) = 0;
      *(void *)(a3 + 144) = 0;
      *(void *)(a3 + 128) = 0;
      v7[184] = 1;
    }
    v7[192] = 0;
    v7[216] = 0;
    if (*(unsigned char *)(a3 + 184))
    {
      *((_OWORD *)v7 + 12) = *(_OWORD *)(a3 + 160);
      *((void *)v7 + 26) = *(void *)(a3 + 176);
      *(void *)(a3 + 168) = 0;
      *(void *)(a3 + 176) = 0;
      *(void *)(a3 + 160) = 0;
      v7[216] = 1;
    }
    *((_WORD *)v7 + 112) = *(_WORD *)(a3 + 192);
    *(_OWORD *)(v7 + 232) = *(_OWORD *)(a3 + 200);
    *((void *)v7 + 31) = *(void *)(a3 + 216);
    *(void *)(a3 + 200) = 0;
    *(void *)(a3 + 208) = 0;
    *(void *)(a3 + 216) = 0;
    *((_WORD *)v7 + 128) = *(_WORD *)(a3 + 224);
    v7[258] = *(unsigned char *)(a3 + 226);
    v7[264] = 0;
    v7[288] = 0;
    if (*(unsigned char *)(a3 + 256))
    {
      *(_OWORD *)(v7 + 264) = *(_OWORD *)(a3 + 232);
      *((void *)v7 + 35) = *(void *)(a3 + 248);
      *(void *)(a3 + 240) = 0;
      *(void *)(a3 + 248) = 0;
      *(void *)(a3 + 232) = 0;
      v7[288] = 1;
    }
    *((_WORD *)v7 + 156) = *(_WORD *)(a3 + 280);
    *(_OWORD *)(v7 + 296) = *(_OWORD *)(a3 + 264);
    LOBYTE(v9) = 1;
    sub_100046C38(a1, v10, v6, (uint64_t *)v7);
    v8[0] = 0;
    sub_1011CBF90((uint64_t)v8);
  }
}

uint64_t sub_1011D1CB4(uint64_t a1)
{
  *(void *)a1 = off_101A9CB58;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1011D1D10(uint64_t a1)
{
  *(void *)a1 = off_101A9CB58;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void *sub_1011D1D8C(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A9CB58;
  sub_1011D20F8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D1DE0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D1DF4(uint64_t a1, void *a2)
{
  *a2 = off_101A9CB58;
  return sub_1011D20F8((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void sub_1011D1E20(uint64_t a1)
{
}

void sub_1011D1E28(void *a1)
{
  sub_1011D2178((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D1E64(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(a1 + 56))
      {
        char v5 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = *(_DWORD *)(a1 + 52);
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Retrying transfer authorization: %d", buf, 8u);
        }
        *(void *)std::string buf = v3;
        int v9 = *(_DWORD *)(a1 + 16);
        if (*(char *)(a1 + 47) < 0)
        {
          sub_10004FC84(__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 24);
          __p[2] = *(void **)(a1 + 40);
        }
        char v11 = *(unsigned char *)(a1 + 48);
        int v12 = *(_DWORD *)(a1 + 52);
        uint64_t v7 = *(std::__shared_weak_count **)(v3 + 24);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1011D2080(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D20AC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9CBB8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011D20EC()
{
  return &off_101A9CBB8;
}

uint64_t sub_1011D20F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v4;
  uint64_t v5 = a1 + 16;
  if (*((char *)a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)v5, (void *)a2[2], a2[3]);
  }
  else
  {
    long long v6 = *((_OWORD *)a2 + 1);
    *(void *)(v5 + 16) = a2[4];
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(void *)(a1 + 40) = a2[5];
  uint64_t v7 = a2[7];
  *(void *)(a1 + 48) = a2[6];
  *(void *)(a1 + 56) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1011D2178(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 16);
    operator delete(v3);
  }
}

uint64_t *sub_1011D21CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  if (*(char *)(v1 + 39) < 0) {
    sub_10004FC84(&__p, *(void **)(v1 + 16), *(void *)(v1 + 24));
  }
  else {
    std::string __p = *(std::string *)(v1 + 16);
  }
  sub_1011C34E8(v2, v3, &__p, *(unsigned __int8 *)(v1 + 40), *(_DWORD *)(v1 + 44));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1011D22A0(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1011D226C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t *sub_1011D22A0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1011D22F8(uint64_t a1)
{
  *(void *)a1 = off_101A9CBD8;
  sub_1008C2D48(a1 + 40);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1011D234C(uint64_t a1)
{
  *(void *)a1 = off_101A9CBD8;
  sub_1008C2D48(a1 + 40);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1011D23C0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x278uLL);
  *uint64_t v2 = off_101A9CBD8;
  sub_1011D2CA8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D2414(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D2428(uint64_t a1, void *a2)
{
  *a2 = off_101A9CBD8;
  return sub_1011D2CA8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D2454(uint64_t a1)
{
}

void sub_1011D245C(void *a1)
{
  sub_1011D2D38((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_1011D2498(uint64_t a1, uint64_t a2, int *a3)
{
  LOBYTE(v23[0]) = 0;
  char v26 = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    sub_100B7302C((uint64_t)v23, a2);
    char v26 = 1;
  }
  int v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 8);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = (void **)(a1 + 16);
  buf[0].__r_.__value_.__r.__words[0] = a1 + 16;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v6 + 784), (void **)(a1 + 16), (long long **)buf) + 26) = Current;
  if (v26)
  {
    int v9 = *(NSObject **)(v6 + 48);
    if (HIBYTE(v23[0]))
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = *(char *)(a1 + 39);
        char v11 = *(void ***)(a1 + 16);
        uint64_t v12 = entitlements::asString();
        std::string::size_type v13 = (std::string::size_type)(v10 >= 0 ? v8 : v11);
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v13;
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I plan(%s) got transfer type from post request : %s", (uint8_t *)buf, 0x16u);
        if (!HIBYTE(v23[0])) {
          sub_10016C840();
        }
      }
    }
    else
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No preflight-state in post response", (uint8_t *)buf, 2u);
      }
      v23[0] = 256;
    }
    char v16 = entitlements::convert();
    __int16 v17 = sub_1008A1FE0(v16);
    long long __p = 0u;
    long long v28 = 0u;
    if (v25)
    {
      std::to_string(buf, __val);
      long long __p = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
      *(void *)&long long v28 = *((void *)&buf[0].__r_.__value_.__l + 2);
      BYTE8(v28) = 1;
      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v6 + 784), v8, (long long **)buf) + 20) = 70052;
      if (!v25) {
        sub_10016C840();
      }
      std::to_string(buf, __val);
      *(void *)&long long v29 = v8;
      unsigned int v18 = sub_1011C81F0((uint64_t **)(v6 + 784), v8, (long long **)&v29);
      sub_10008BE4C((uint64_t)(v18 + 128), (long long *)buf);
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf[0].__r_.__value_.__l.__data_);
      }
      char v19 = 8;
      __int16 v20 = 16;
    }
    else
    {
      __int16 v20 = v17;
      char v19 = 0;
    }
    buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    *((_WORD *)sub_1011C81F0((uint64_t **)(v6 + 784), v8, (long long **)buf) + 60) = v20 | 0x100;
    long long v42 = 0u;
    long long v43 = 0u;
    memset(v41, 0, sizeof(v41));
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    BYTE8(v30) = v20;
    BYTE9(v30) = 1;
    if (*(char *)(v6 + 535) < 0)
    {
      sub_10004FC84(&v37, *(void **)(v6 + 512), *(void *)(v6 + 520));
    }
    else
    {
      long long v37 = *(_OWORD *)(v6 + 512);
      *(void *)&long long v38 = *(void *)(v6 + 528);
    }
    BYTE8(v38) = 1;
    LOWORD(v39) = 0;
    long long v40 = 0uLL;
    *((void *)&v39 + 1) = 0;
    v41[0] = 0;
    LOBYTE(v41[1]) = v19;
    sub_1000593FC((uint64_t)&v41[4], &__p);
    BYTE8(v42) = 0;
    LOBYTE(v43) = 0;
    WORD4(v43) = 0;
    sub_10030DA1C((char *)buf, &v29);
    char v45 = 1;
    sub_1011C39E0(v6, (uint64_t)buf);
    if (v45) {
      sub_1000C5578((uint64_t)buf);
    }
    sub_1000C5578((uint64_t)&v29);
    if (BYTE8(v28) && SBYTE7(v28) < 0) {
      operator delete((void *)__p);
    }
  }
  else
  {
    long long v14 = *(NSObject **)(v6 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if ((v5 - 1) > 2) {
        uint64_t v22 = "RequestCanceled";
      }
      else {
        uint64_t v22 = off_101A9D118[v5 - 1];
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "TA webservice request failed. EventCause: [%s]", (uint8_t *)buf, 0xCu);
      long long v14 = *(NSObject **)(v6 + 48);
    }
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (v5 == 3)
    {
      if (v15)
      {
        LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "transfer authorization via web service failure due to carrier error", (uint8_t *)buf, 2u);
      }
      buf[0].__r_.__value_.__r.__words[0] = a1 + 16;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v6 + 784), (void **)(a1 + 16), (long long **)buf) + 20) = 70031;
      long long v29 = 0uLL;
      *(void *)&long long v30 = 0;
      WORD4(v30) = 256;
      LOBYTE(v31) = 0;
      BYTE8(v32) = 0;
      LOBYTE(v33) = 0;
      BYTE8(v34) = 0;
      LOBYTE(v35) = 0;
      BYTE8(v36) = 0;
      if (*(char *)(v6 + 535) < 0)
      {
        sub_10004FC84(&v37, *(void **)(v6 + 512), *(void *)(v6 + 520));
      }
      else
      {
        long long v37 = *(_OWORD *)(v6 + 512);
        *(void *)&long long v38 = *(void *)(v6 + 528);
      }
      BYTE8(v38) = 1;
      LOWORD(v39) = 0;
      long long v40 = 0uLL;
      *((void *)&v39 + 1) = 0;
      v41[0] = 0;
      LOBYTE(v41[1]) = 4;
      LOBYTE(v41[4]) = 0;
      LOBYTE(v42) = 0;
      BYTE8(v42) = 0;
      LOBYTE(v43) = 0;
      WORD4(v43) = 0;
      sub_1011C7D34((uint64_t)buf, &v29);
      sub_1011C39E0(v6, (uint64_t)buf);
    }
    else
    {
      if (v15)
      {
        LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "transfer authorization via web service failure due to internal error", (uint8_t *)buf, 2u);
      }
      buf[0].__r_.__value_.__r.__words[0] = a1 + 16;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v6 + 784), (void **)(a1 + 16), (long long **)buf) + 20) = 70046;
      long long v29 = 0uLL;
      *(void *)&long long v30 = 0;
      WORD4(v30) = 256;
      LOBYTE(v31) = 0;
      BYTE8(v32) = 0;
      LOBYTE(v33) = 0;
      BYTE8(v34) = 0;
      LOBYTE(v35) = 0;
      BYTE8(v36) = 0;
      if (*(char *)(v6 + 535) < 0)
      {
        sub_10004FC84(&v37, *(void **)(v6 + 512), *(void *)(v6 + 520));
      }
      else
      {
        long long v37 = *(_OWORD *)(v6 + 512);
        *(void *)&long long v38 = *(void *)(v6 + 528);
      }
      BYTE8(v38) = 1;
      LOWORD(v39) = 0;
      long long v40 = 0uLL;
      *((void *)&v39 + 1) = 0;
      v41[0] = 0;
      LOBYTE(v41[1]) = 5;
      LOBYTE(v41[4]) = 0;
      LOBYTE(v42) = 0;
      BYTE8(v42) = 0;
      LOBYTE(v43) = 0;
      WORD4(v43) = 0;
      sub_1011C7D34((uint64_t)buf, &v29);
      sub_1011C39E0(v6, (uint64_t)buf);
    }
    if (v45) {
      sub_1000C5578((uint64_t)buf);
    }
    sub_1000C5578((uint64_t)&v29);
  }
  return sub_100777C48((uint64_t)v23);
}

void sub_1011D2AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,char a62,void *a63)
{
  if (a73 && a72 < 0) {
    operator delete(__p);
  }
  if (a69 && a68 < 0) {
    operator delete(a63);
  }
  if (a62 && a61 < 0) {
    operator delete(a56);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  sub_100777C48((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D2C5C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9CC38)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011D2C9C()
{
  return &off_101A9CC38;
}

uint64_t sub_1011D2CA8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_100B63100(a1 + 32, a2 + 32);
  return a1;
}

void sub_1011D2D1C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D2D38(uint64_t a1)
{
  sub_1008C2D48(a1 + 32);
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

void sub_1011D2D8C()
{
}

void *sub_1011D2DA0()
{
  __n128 result = operator new(0x10uLL);
  void *result = off_101A9CC58;
  return result;
}

void sub_1011D2DD8(uint64_t a1, void *a2)
{
  *a2 = off_101A9CC58;
}

void sub_1011D2E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)a3;
  int v4 = *(char *)(a3 + 23);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (v4 < 0) {
    operator delete(v3);
  }
}

uint64_t sub_1011D2E1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D2E5C()
{
}

uint64_t sub_1011D2E68(uint64_t a1)
{
  *(void *)a1 = off_101A9CCD8;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011D2ED4(uint64_t a1)
{
  *(void *)a1 = off_101A9CCD8;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011D2F60(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x70uLL);
  *uint64_t v2 = off_101A9CCD8;
  sub_1011D33D0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D2FB4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D2FC8(uint64_t a1, void *a2)
{
  *a2 = off_101A9CCD8;
  return sub_1011D33D0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D2FF4(uint64_t a1)
{
}

void sub_1011D2FFC(void *a1)
{
  sub_1011D34B4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D3038(uint64_t a1, uint64_t a2, std::string *a3)
{
  std::string __str = *a3;
  unint64_t v4 = __str.__r_.__value_.__r.__words[2];
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  unint64_t size = HIBYTE(v4);
  if ((size & 0x80u) != 0) {
    unint64_t size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v6 = (_OWORD *)(a1 + 48);
    memset(v29, 0, sizeof(v29));
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    memset(v20, 0, sizeof(v20));
    std::string::operator=((std::string *)v20, (const std::string *)(a1 + 48));
    std::string::operator=((std::string *)((char *)v29 + 8), &__str);
    uint64_t v7 = *(void *)(a1 + 8);
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 24);
      uint64_t v33 = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *v6;
      uint64_t v19 = *(void *)(a1 + 64);
    }
    uint64_t v9 = *(void *)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 80);
    uint64_t v11 = *(void *)(a1 + 88);
    uint64_t v12 = *(void *)(a1 + 96);
    sub_10030DA1C(v30, (long long *)v20);
    char v31 = 1;
    (*(void (**)(uint64_t, long long *, void **, uint64_t, uint64_t, uint64_t, uint64_t, char *, _BYTE))(*(void *)v7 + 144))(v7, &__dst, __p, v9, v10, v11, v12, v30, *(unsigned char *)(a1 + 104));
    if (v31) {
      sub_1000C5578((uint64_t)v30);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)__dst);
    }
    sub_1000C5578((uint64_t)v20);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 8);
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(v20, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)__int16 v20 = *(_OWORD *)(a1 + 24);
      *(void *)&v20[16] = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 48);
      uint64_t v33 = *(void *)(a1 + 64);
    }
    uint64_t v13 = *(void *)(a1 + 72);
    uint64_t v14 = *(void *)(a1 + 80);
    uint64_t v15 = *(void *)(a1 + 88);
    uint64_t v16 = *(void *)(a1 + 96);
    v30[0] = 0;
    char v31 = 0;
    (*(void (**)(uint64_t, unsigned char *, long long *, uint64_t, uint64_t, uint64_t, uint64_t, char *, _BYTE))(*(void *)v8 + 144))(v8, v20, &__dst, v13, v14, v15, v16, v30, *(unsigned char *)(a1 + 104));
    if (v31) {
      sub_1000C5578((uint64_t)v30);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)__dst);
    }
    if ((v20[23] & 0x80000000) != 0) {
      operator delete(*(void **)v20);
    }
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1011D32D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D3384(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D33C4()
{
}

uint64_t sub_1011D33D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)uint64_t v6 = v7;
  }
  long long v8 = *(_OWORD *)(a2 + 64);
  long long v9 = *(_OWORD *)(a2 + 80);
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 80) = v9;
  return a1;
}

void sub_1011D3484(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D34B4(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_1011D3518(uint64_t a1)
{
  *(void *)a1 = off_101A9CD58;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1011D3590(uint64_t a1)
{
  *(void *)a1 = off_101A9CD58;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1011D3628(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x80uLL);
  *uint64_t v2 = off_101A9CD58;
  sub_1011D3B30((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D367C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D3690(uint64_t a1, void *a2)
{
  *a2 = off_101A9CD58;
  return sub_1011D3B30((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D36BC(uint64_t a1)
{
}

void sub_1011D36C4(void *a1)
{
  sub_1011D3C40((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D3700(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  long long v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      long long v7 = v6;
      if (*(void *)(a1 + 16))
      {
        if (v3)
        {
          long long v8 = *(void **)(v4 + 344);
          if (v8 != (void *)(v4 + 352))
          {
            int v9 = *(char *)(a1 + 55);
            if (v9 >= 0) {
              uint64_t v10 = *(unsigned __int8 *)(a1 + 55);
            }
            else {
              uint64_t v10 = *(void *)(a1 + 40);
            }
            if (v9 >= 0) {
              uint64_t v11 = (unsigned __int8 *)(a1 + 32);
            }
            else {
              uint64_t v11 = *(unsigned __int8 **)(a1 + 32);
            }
            do
            {
              uint64_t v12 = *((unsigned __int8 *)v8 + 55);
              if ((v12 & 0x80u) == 0) {
                uint64_t v13 = *((unsigned __int8 *)v8 + 55);
              }
              else {
                uint64_t v13 = v8[5];
              }
              if (v13 == v10)
              {
                uint64_t v14 = (const void **)(v8 + 4);
                if ((v12 & 0x80) != 0)
                {
                  if (!memcmp(*v14, v11, v8[5]))
                  {
LABEL_30:
                    sub_100B53774((char *)v25, (std::string *)(v8 + 8));
                    break;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v8 + 55)) {
                    goto LABEL_30;
                  }
                  uint64_t v15 = v11;
                  while (*(unsigned __int8 *)v14 == *v15)
                  {
                    uint64_t v14 = (const void **)((char *)v14 + 1);
                    ++v15;
                    if (!--v12) {
                      goto LABEL_30;
                    }
                  }
                }
              }
              uint64_t v16 = (void *)v8[1];
              if (v16)
              {
                do
                {
                  __int16 v17 = v16;
                  uint64_t v16 = (void *)*v16;
                }
                while (v16);
              }
              else
              {
                do
                {
                  __int16 v17 = (void *)v8[2];
                  BOOL v18 = *v17 == (void)v8;
                  long long v8 = v17;
                }
                while (!v18);
              }
              long long v8 = v17;
            }
            while (v17 != (void *)(v4 + 352));
          }
        }
        uint64_t v19 = *(std::__shared_weak_count **)(v4 + 760);
        *(_OWORD *)(v4 + 752) = 0u;
        if (v19) {
          sub_10004D2C8(v19);
        }
        uint64_t v20 = *(void *)(a1 + 64);
        *(void *)&long long v27 = *(void *)(a1 + 56);
        *((void *)&v27 + 1) = v20;
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        if (*(char *)(a1 + 95) < 0)
        {
          sub_10004FC84(&v28, *(void **)(a1 + 72), *(void *)(a1 + 80));
        }
        else
        {
          long long v28 = *(_OWORD *)(a1 + 72);
          uint64_t v29 = *(void *)(a1 + 88);
        }
        long long v21 = (void **)(a1 + 32);
        if (*(char *)(a1 + 55) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
        }
        else
        {
          long long __p = *(_OWORD *)v21;
          uint64_t v31 = *(void *)(a1 + 48);
        }
        long long v22 = *(_OWORD *)(a1 + 112);
        long long v32 = *(_OWORD *)(a1 + 96);
        long long v33 = v22;
        sub_10030D9BC((char *)v34, (uint64_t)v25);
        long long v37 = 0;
        long long v23 = (char *)operator new(0x170uLL);
        *(void *)long long v23 = off_101A9CDC8;
        *(_OWORD *)(v23 + 8) = v27;
        long long v27 = 0uLL;
        *(_OWORD *)(v23 + 24) = v28;
        *((void *)v23 + 5) = v29;
        long long v28 = 0uLL;
        uint64_t v29 = 0;
        *((_OWORD *)v23 + 3) = __p;
        *((void *)v23 + 8) = v31;
        long long __p = 0uLL;
        uint64_t v31 = 0;
        long long v24 = v32;
        *(_OWORD *)(v23 + 88) = v33;
        *(_OWORD *)(v23 + 72) = v24;
        v23[104] = 0;
        v23[360] = 0;
        if (v35)
        {
          sub_1003300C4((uint64_t)(v23 + 104), v34);
          v23[360] = 1;
        }
        long long v37 = v23;
        sub_1011C5690(v4, v21, (uint64_t)v36);
        sub_1000DBADC(v36);
        if (v35) {
          sub_1000C5578((uint64_t)v34);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v29) < 0) {
          operator delete((void *)v28);
        }
        if (*((void *)&v27 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v27 + 1));
        }
      }
      sub_10004D2C8(v7);
      if ((_BYTE)v26) {
        sub_1000C5578((uint64_t)v25);
      }
    }
  }
}

void sub_1011D3A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a50 < 0) {
    operator delete(__p);
  }
  if (a44) {
    sub_10004D2C8((std::__shared_weak_count *)a44);
  }
  sub_10004D2C8(v50);
  if (a41) {
    sub_1000C5578((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D3AE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D3B24()
{
}

uint64_t sub_1011D3B30(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  long long v7 = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84(v7, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)long long v7 = v8;
  }
  long long v9 = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v9;
  return a1;
}

void sub_1011D3C04(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  long long v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D3C40(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_1011D3CB0(uint64_t a1)
{
  *(void *)a1 = off_101A9CDC8;
  if (*(unsigned char *)(a1 + 360)) {
    sub_1000C5578(a1 + 104);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011D3D2C(uint64_t a1)
{
  *(void *)a1 = off_101A9CDC8;
  if (*(unsigned char *)(a1 + 360)) {
    sub_1000C5578(a1 + 104);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011D3DC8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x170uLL);
  *uint64_t v2 = off_101A9CDC8;
  sub_1011D412C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D3E1C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D3E30(uint64_t a1, void *a2)
{
  *a2 = off_101A9CDC8;
  return sub_1011D412C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D3E5C(uint64_t a1)
{
}

void sub_1011D3E64(void *a1)
{
  sub_1011D4230((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D3EA0(uint64_t a1, uint64_t a2, std::string *a3)
{
  std::string __str = *a3;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  uint64_t v4 = (std::string *)(a1 + 104);
  if (!*(unsigned char *)(a1 + 360))
  {
    memset(v12, 0, sizeof(v12));
    sub_1011CD718(a1 + 104, v12);
    sub_1000C5578((uint64_t)v12);
    std::string::operator=(v4, (const std::string *)(a1 + 48));
  }
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size) {
    std::string::operator=((std::string *)(a1 + 272), &__str);
  }
  if (!*(unsigned char *)(a1 + 360)) {
    sub_10016C840();
  }
  sub_100CDB240((uint64_t)v4);
  uint64_t v6 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 24);
    uint64_t v17 = *(void *)(a1 + 40);
  }
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(&v14, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    long long v14 = *(_OWORD *)(a1 + 48);
    uint64_t v15 = *(void *)(a1 + 64);
  }
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 88);
  uint64_t v9 = *(void *)(a1 + 96);
  sub_10030D9BC((char *)v12, (uint64_t)v4);
  (*(void (**)(uint64_t, long long *, long long *, uint64_t, uint64_t, uint64_t, uint64_t, long long *, _BYTE))(*(void *)v6 + 144))(v6, &__dst, &v14, v7, v8, v10, v9, v12, 0);
  if (v13) {
    sub_1000C5578((uint64_t)v12);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)v14);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1011D407C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  if (*(char *)(v50 - 73) < 0) {
    operator delete(*(void **)(v50 - 96));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011D40E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D4120()
{
}

uint64_t sub_1011D412C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v5;
  }
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v6;
  }
  long long v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v7;
  sub_10030D9BC((char *)(a1 + 96), a2 + 96);
  return a1;
}

void sub_1011D41E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D4230(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 352)) {
    sub_1000C5578(a1 + 96);
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_1011D42A4(uint64_t a1)
{
  *(void *)a1 = off_101A9CE58;
  sub_1000C5578(a1 + 104);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011D4314(uint64_t a1)
{
  *(void *)a1 = off_101A9CE58;
  sub_1000C5578(a1 + 104);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011D43A4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x168uLL);
  *uint64_t v2 = off_101A9CE58;
  sub_1011D4688((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D43F8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D440C(uint64_t a1, void *a2)
{
  *a2 = off_101A9CE58;
  return sub_1011D4688((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D4438(uint64_t a1)
{
}

void sub_1011D4440(void *a1)
{
  sub_1011D478C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D447C(uint64_t a1, uint64_t a2, std::string *a3)
{
  std::string __str = *a3;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  std::string::operator=((std::string *)(a1 + 272), &__str);
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 24);
    uint64_t v16 = *(void *)(a1 + 40);
  }
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(&v13, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    long long v13 = *(_OWORD *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 64);
  }
  long long v5 = (long long *)(a1 + 104);
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 96);
  sub_10030DA1C(v11, v5);
  char v12 = 1;
  (*(void (**)(uint64_t, long long *, long long *, uint64_t, uint64_t, uint64_t, uint64_t, char *, _BYTE))(*(void *)v4 + 144))(v4, &__dst, &v13, v6, v7, v9, v8, v11, 0);
  if (v12) {
    sub_1000C5578((uint64_t)v11);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)v13);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1011D45D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  if (*(char *)(v49 - 57) < 0) {
    operator delete(*(void **)(v49 - 80));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011D463C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D467C()
{
}

uint64_t sub_1011D4688(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v5;
  }
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v6;
  }
  long long v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v7;
  sub_10030DA1C((char *)(a1 + 96), (long long *)(a2 + 96));
  return a1;
}

void sub_1011D4744(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D478C(uint64_t a1)
{
  sub_1000C5578(a1 + 96);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_1011D47F8(uint64_t a1)
{
  *(void *)a1 = off_101A9CED8;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011D4864(uint64_t a1)
{
  *(void *)a1 = off_101A9CED8;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011D48F0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  *uint64_t v2 = off_101A9CED8;
  sub_1011D4D58((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D4944(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D4958(uint64_t a1, void *a2)
{
  *a2 = off_101A9CED8;
  return sub_1011D4D58((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D4984(uint64_t a1)
{
}

void sub_1011D498C(void *a1)
{
  sub_1011D34B4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D49C8(uint64_t a1, uint64_t a2, std::string *a3)
{
  std::string __str = *a3;
  unint64_t v4 = __str.__r_.__value_.__r.__words[2];
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  a3->__r_.__value_.__r.__words[0] = 0;
  unint64_t size = HIBYTE(v4);
  if ((size & 0x80u) != 0) {
    unint64_t size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    long long v6 = (_OWORD *)(a1 + 48);
    memset(v29, 0, sizeof(v29));
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    memset(v20, 0, sizeof(v20));
    std::string::operator=((std::string *)v20, (const std::string *)(a1 + 48));
    std::string::operator=((std::string *)((char *)v29 + 8), &__str);
    uint64_t v7 = *(void *)(a1 + 8);
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 24);
      uint64_t v33 = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *v6;
      uint64_t v19 = *(void *)(a1 + 64);
    }
    uint64_t v9 = *(void *)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 80);
    uint64_t v12 = *(void *)(a1 + 88);
    uint64_t v11 = *(void *)(a1 + 96);
    sub_10030DA1C(v30, (long long *)v20);
    char v31 = 1;
    (*(void (**)(uint64_t, long long *, void **, uint64_t, uint64_t, uint64_t, uint64_t, char *, char))(*(void *)v7 + 144))(v7, &__dst, __p, v9, v10, v12, v11, v30, 5);
    if (v31) {
      sub_1000C5578((uint64_t)v30);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)__dst);
    }
    sub_1000C5578((uint64_t)v20);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 8);
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(v20, *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)uint64_t v20 = *(_OWORD *)(a1 + 24);
      *(void *)&v20[16] = *(void *)(a1 + 40);
    }
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 48);
      uint64_t v33 = *(void *)(a1 + 64);
    }
    uint64_t v13 = *(void *)(a1 + 72);
    uint64_t v14 = *(void *)(a1 + 80);
    uint64_t v15 = *(void *)(a1 + 88);
    uint64_t v16 = *(void *)(a1 + 96);
    v30[0] = 0;
    char v31 = 0;
    (*(void (**)(uint64_t, unsigned char *, long long *, uint64_t, uint64_t, uint64_t, uint64_t, char *, char))(*(void *)v8 + 144))(v8, v20, &__dst, v13, v14, v15, v16, v30, 5);
    if (v31) {
      sub_1000C5578((uint64_t)v30);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)__dst);
    }
    if ((v20[23] & 0x80000000) != 0) {
      operator delete(*(void **)v20);
    }
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1011D4C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D4D0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D4D4C()
{
}

uint64_t sub_1011D4D58(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)long long v6 = v7;
  }
  long long v8 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v8;
  return a1;
}

void sub_1011D4E04(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D4E38()
{
}

__n128 sub_1011D4E4C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A9CF58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1011D4EA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9CF58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011D4ED8(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  *a3 = 0;
  a3[1] = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  *(_OWORD *)BOOL v18 = 0u;
  *(_OWORD *)uint64_t v15 = 0u;
  *(_OWORD *)uint64_t v16 = 0u;
  rest::read_rest_value();
  long long v6 = (void (*)(void *, void **, unsigned char *))a1[2];
  uint64_t v7 = a1[3];
  long long v8 = (void *)(a1[1] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void **, unsigned char *))(*v8 + v6);
  }
  v9[0] = 0;
  v9[24] = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = v5;
  uint64_t v14 = v4;
  v6(v8, v15, v9);
  sub_1011D50CC((uint64_t)v9);
  if (*((void *)&v19 + 1))
  {
    *(void *)&long long v20 = *((void *)&v19 + 1);
    operator delete(*((void **)&v19 + 1));
  }
  if (v18[0])
  {
    v18[1] = v18[0];
    operator delete(v18[0]);
  }
  if (v16[1])
  {
    *(void **)&long long v17 = v16[1];
    operator delete(v16[1]);
  }
  if (SHIBYTE(v16[0]) < 0) {
    operator delete(v15[0]);
  }
}

void sub_1011D4FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32)
{
  if (__p)
  {
    a32 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a28)
  {
    a29 = (uint64_t)a28;
    operator delete(a28);
  }
  if (a25)
  {
    a26 = (uint64_t)a25;
    operator delete(a25);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D5080(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D50C0()
{
}

uint64_t sub_1011D50CC(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    rest::write_rest_value();
    uint64_t v2 = *(void ***)(a1 + 56);
    int v3 = *v2;
    *uint64_t v2 = v7;
    xpc_release(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void **)(a1 + 32);
  if (v5)
  {
    *(void *)(a1 + 40) = v5;
    operator delete(v5);
  }
  if (*(unsigned char *)(a1 + 24)) {
    sub_10026CF54(a1, *(void **)(a1 + 8));
  }
  return a1;
}

void sub_1011D5160(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9CFD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011D5180(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9CFD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011D51D4(uint64_t a1)
{
  return sub_1011D50CC(a1 + 24);
}

uint64_t sub_1011D51E0(uint64_t a1)
{
  *(void *)a1 = off_101A9D028;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1011D523C(uint64_t a1)
{
  *(void *)a1 = off_101A9D028;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1011D52B8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = off_101A9D028;
  sub_1011D5780((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1011D530C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D5320(uint64_t a1, void *a2)
{
  *a2 = off_101A9D028;
  return sub_1011D5780((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1011D534C(uint64_t a1)
{
}

void sub_1011D5354(void *a1)
{
  sub_100B74688((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D5390(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  LOBYTE(v14) = 0;
  unsigned __int8 v17 = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v4 = (void *)(a2 + 8);
    uint64_t v5 = *(void **)(a2 + 8);
    uint64_t v14 = *(uint64_t **)a2;
    uint64_t v15 = v5;
    if (*(void *)(a2 + 16))
    {
      void v5[2] = &v15;
      *(void *)a2 = v4;
      *uint64_t v4 = 0;
      *(void *)(a2 + 16) = 0;
    }
    else
    {
      uint64_t v14 = (uint64_t *)&v15;
    }
    unsigned __int8 v17 = 1;
  }
  *(_OWORD *)long long __p = *(_OWORD *)(a2 + 32);
  uint64_t v19 = *(void *)(a2 + 48);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  int v6 = *a3;
  uint64_t v7 = *(void *)(a1 + 8);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v9 = (void **)(a1 + 32);
  *(void *)std::string buf = a1 + 32;
  *((CFAbsoluteTime *)sub_1011C81F0((uint64_t **)(v7 + 784), (void **)(a1 + 32), (long long **)buf) + 32) = Current;
  *(void *)std::string buf = a1 + 32;
  *((_WORD *)sub_1011C81F0((uint64_t **)(v7 + 784), (void **)(a1 + 32), (long long **)buf) + 58) = (v6 == 0) | 0x100;
  if (v6)
  {
    uint64_t v10 = *(NSObject **)(v7 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "invalid transfer signature and certificate", buf, 2u);
    }
    unint64_t v11 = sub_100CCD974((unsigned __int8 **)(*(void *)(v7 + 336) + 32), (uint64_t *)(v7 + 608));
    if ((v11 & 0xFF00000000) != 0 && (sub_1011C11D8(v7, v11) & 1) == 0)
    {
      *(void *)std::string buf = v9;
      *((_DWORD *)sub_1011C81F0((uint64_t **)(v7 + 784), v9, (long long **)buf) + 20) = 70049;
      long long v20 = 0uLL;
      uint64_t v21 = 0;
      __int16 v22 = 257;
      char v23 = 0;
      char v24 = 0;
      char v25 = 0;
      char v26 = 0;
      char v27 = 0;
      char v28 = 0;
      if (*(char *)(v7 + 535) < 0)
      {
        sub_10004FC84(&v29, *(void **)(v7 + 512), *(void *)(v7 + 520));
      }
      else
      {
        long long v29 = *(_OWORD *)(v7 + 512);
        uint64_t v30 = *(void *)(v7 + 528);
      }
      char v31 = 1;
      __int16 v32 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      uint64_t v33 = 0;
      __int16 v36 = 0;
      char v37 = 6;
      char v38 = 0;
      char v39 = 0;
      char v40 = 0;
      char v41 = 0;
      __int16 v42 = 0;
      sub_1011C7D34((uint64_t)buf, &v20);
      sub_1011C39E0(v7, (uint64_t)buf);
      if (v44) {
        sub_1000C5578((uint64_t)buf);
      }
      sub_1000C5578((uint64_t)&v20);
    }
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    if (*(unsigned __int8 *)(v12 + 24) == v17)
    {
      if ((uint64_t **)v12 != &v14 && *(unsigned char *)(v12 + 24)) {
        sub_100C77378(*(uint64_t ***)(a1 + 16), v14, (uint64_t *)&v15);
      }
    }
    else
    {
      if (*(unsigned char *)(v12 + 24))
      {
        sub_10026CF54(*(void *)(a1 + 16), *(void **)(v12 + 8));
        char v13 = 0;
      }
      else
      {
        sub_10026E7F8(*(uint64_t **)(a1 + 16), (uint64_t)&v14);
        char v13 = 1;
      }
      *(unsigned char *)(v12 + 24) = v13;
    }
    if ((uint64_t **)v12 != &v14) {
      sub_10006E4A8((void *)(v12 + 32), (char *)__p[0], (char *)__p[1], (char *)__p[1] - (char *)__p[0]);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v17) {
    sub_10026CF54((uint64_t)&v14, v15);
  }
}

void sub_1011D5684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  if (a44 && a43 < 0) {
    operator delete(__p);
  }
  if (a37 && a36 < 0) {
    operator delete(a31);
  }
  if (a30 && a29 < 0) {
    operator delete(a24);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a14)
  {
    a15 = (uint64_t)a14;
    operator delete(a14);
  }
  if (a13) {
    sub_10026CF54((uint64_t)&a10, (void *)a11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D5734(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D5774()
{
}

uint64_t sub_1011D5780(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_1011D57F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1011D580C@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  __n128 result = operator new(0x30uLL);
  result[1] = 0;
  result[2] = 0;
  void *result = off_101A9D180;
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  result[3] = off_101A9D140;
  result[4] = v6;
  result[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = off_101A9D1D0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

double sub_1011D58B0@<D0>(long long *a1@<X1>, _OWORD *a2@<X8>)
{
  sub_10012A994(a1, (std::__shared_weak_count **)&v4);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_1011D58EC(KeychainStoreFactoryInterface *this)
{
  *(void *)this = off_101A9D140;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);
}

void sub_1011D5948(KeychainStoreFactoryInterface *this)
{
  *(void *)this = off_101A9D140;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);

  operator delete();
}

void sub_1011D59B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D180;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011D59D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D180;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011D5A2C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1011D5A54(KeychainStoreFactoryInterface *this)
{
  *(void *)this = off_101A9D140;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);
}

void sub_1011D5AB0(KeychainStoreFactoryInterface *this)
{
  *(void *)this = off_101A9D140;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  KeychainStoreFactoryInterface::~KeychainStoreFactoryInterface(this);

  operator delete();
}

void sub_1011D5B28(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1011D5BFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D5C5C(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 48) + 40))(v2);
  sub_1003464A0(a1 + 112, (uint64_t)v2);
  if (LOBYTE(v2[0]) && v3 < 0) {
    operator delete(v2[1]);
  }
  if (*(unsigned char *)(a1 + 112)) {
    *(unsigned char *)(a1 + 145) = 1;
  }
}

void sub_1011D5D14(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D5D20(uint64_t a1, dispatch_object_t *a2, void *a3)
{
  *(void *)a1 = off_101A9D300;
  uint64_t v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "cp.w.sim");
  void *v6 = 0;
  v6[1] = 0;
  uint64_t v7 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *(void *)a1 = off_101A9D210;
  *(void *)(a1 + 48) = *a3;
  uint64_t v8 = a3[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CellularPlanSimCommandOperations");
  uint64_t v10 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  ctu::RestModule::RestModule();
  if (v10) {
    dispatch_release(v10);
  }
  if (v12 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  return a1;
}

void sub_1011D5E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  char v23 = *(std::__shared_weak_count **)(v19 + 56);
  if (v23) {
    sub_10004D2C8(v23);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D5F1C(uint64_t a1)
{
  *(void *)a1 = off_101A9D210;
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  uint64_t v2 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1011D6014(uint64_t a1)
{
  sub_1011D5F1C(a1);

  operator delete();
}

void sub_1011D604C(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 48) + 56))(&v1);
  ctu::RestModule::connect();
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_1011D60B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011D60D0(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

uint64_t sub_1011D60D8(uint64_t a1)
{
  *(_WORD *)(a1 + 145) = 0;
  *(unsigned char *)(a1 + 147) = 0;
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  v4[0] = 0;
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 32))(v2, v4);
  if (v4[0] && v6 < 0) {
    operator delete(__p);
  }
  uint64_t result = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1011D61C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a10)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D61EC(uint64_t a1, unsigned __int8 *a2)
{
  long long v4 = (unsigned char *)(a1 + 112);
  int v5 = *a2;
  if (*(unsigned char *)(a1 + 112)) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if ((*(unsigned char *)(a1 + 112) != 0) != (v5 == 0)) {
      return;
    }
  }
  else
  {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 143);
    if ((v7 & 0x80u) == 0) {
      uint64_t v8 = *(unsigned __int8 *)(a1 + 143);
    }
    else {
      uint64_t v8 = *(void *)(a1 + 128);
    }
    uint64_t v9 = a2[31];
    int v10 = (char)v9;
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *((void *)a2 + 2);
    }
    if (v8 == v9)
    {
      unint64_t v11 = (const void **)(a1 + 120);
      if (v10 >= 0) {
        char v12 = a2 + 8;
      }
      else {
        char v12 = (unsigned __int8 *)*((void *)a2 + 1);
      }
      if ((v7 & 0x80) != 0)
      {
        if (!memcmp(*v11, v12, *(void *)(a1 + 128))) {
          return;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 143)) {
          return;
        }
        while (*(unsigned __int8 *)v11 == *v12)
        {
          unint64_t v11 = (const void **)((char *)v11 + 1);
          ++v12;
          if (!--v7) {
            return;
          }
        }
      }
    }
  }
  sub_1003DC1E4((uint64_t)v4, (uint64_t)a2);
  if (*v4)
  {
    OsLogContext v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I new sim selected setting reset as required", buf, 2u);
    }
    (*(void (**)(void, unsigned char *))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v4);
    *(_WORD *)(a1 + 144) = 256;
    if (*(void *)(a1 + 80))
    {
      uint64_t v14 = *(void *)(a1 + 96);
      *(void *)(a1 + 96) = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
      uint64_t v15 = *(std::__shared_weak_count **)(a1 + 88);
      *(void *)(a1 + 80) = 0;
      *(void *)(a1 + 88) = 0;
      if (v15) {
        sub_10004D2C8(v15);
      }
    }
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I acquiring online assertion", buf, 2u);
    }
    sub_100058DB0(buf, "/cc/assertions/baseband_online");
    ctu::rest::AssertionHandle::create();
    if (SHIBYTE(v42) < 0) {
      operator delete(*(void **)buf);
    }
    long long v17 = aBlock;
    long long aBlock = 0uLL;
    BOOL v18 = *(std::__shared_weak_count **)(a1 + 88);
    *(_OWORD *)(a1 + 80) = v17;
    if (v18)
    {
      sub_10004D2C8(v18);
      if (*((void *)&aBlock + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&aBlock + 1));
      }
    }
    uint64_t v19 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v19 || (uint64_t v20 = *(void *)(a1 + 8), (v21 = std::__shared_weak_count::lock(v19)) == 0)) {
      sub_100088B9C();
    }
    __int16 v22 = v21;
    p_shared_weak_owners = &v21->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v21);
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v41 = 1174405120;
    __int16 v42 = sub_1011D6EB0;
    long long v43 = &unk_101A9D280;
    uint64_t v44 = a1;
    uint64_t v45 = v20;
    uint64_t v46 = v22;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    char v24 = _Block_copy(buf);
    char v25 = v24;
    if (v24) {
      char v26 = _Block_copy(v24);
    }
    else {
      char v26 = 0;
    }
    *(void *)&long long aBlock = off_101A8DB30;
    *((void *)&aBlock + 1) = v26;
    p_long long aBlock = &aBlock;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&aBlock);
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 48) + 48))(&v37);
    uint64_t v27 = v37;
    sub_100058DB0(__p, "online on sim select");
    uint64_t v28 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 64))(*(void *)(a1 + 48));
    long long v29 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v29;
    if (v29) {
      dispatch_retain(v29);
    }
    *(void *)&long long aBlock = _NSConcreteStackBlock;
    *((void *)&aBlock + 1) = 1174405120;
    uint64_t v48 = sub_1011D6FAC;
    p_long long aBlock = (long long *)&unk_101A9D2B0;
    uint64_t v50 = a1;
    uint64_t v51 = v20;
    uint64_t v52 = v22;
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v33 = _Block_copy(&aBlock);
    sub_100118A44(v27, (uint64_t)__p, 1, 1000000 * v28, &object, &v33);
    uint64_t v30 = v39;
    uint64_t v39 = 0;
    uint64_t v31 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = v30;
    if (v31)
    {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
      uint64_t v32 = v39;
      uint64_t v39 = 0;
      if (v32) {
        (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
      }
    }
    if (v33) {
      _Block_release(v33);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v36 < 0) {
      operator delete(__p[0]);
    }
    if (v38) {
      sub_10004D2C8(v38);
    }
    if (v52) {
      std::__shared_weak_count::__release_weak(v52);
    }
    if (v25) {
      _Block_release(v25);
    }
    if (v46) {
      std::__shared_weak_count::__release_weak(v46);
    }
    std::__shared_weak_count::__release_weak(v22);
  }
}

void sub_1011D6718(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,std::__shared_weak_count *a37)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1011D67F4(uint64_t a1)
{
  return *(void *)(a1 + 80) != 0;
}

void sub_1011D6804(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 144) != a2)
  {
    int v2 = a2;
    *(unsigned char *)(a1 + 144) = a2;
    long long v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 67109120;
      v7[1] = v2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I sim state ready changed : %d", (uint8_t *)v7, 8u);
      int v2 = *(unsigned __int8 *)(a1 + 144);
    }
    if (v2) {
      goto LABEL_11;
    }
    uint64_t v5 = *(void *)(a1 + 104);
    if (!v5) {
      goto LABEL_11;
    }
    BOOL v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I reset camp timer on sim going not ready", (uint8_t *)v7, 2u);
      uint64_t v5 = *(void *)(a1 + 104);
      *(void *)(a1 + 104) = 0;
      if (!v5) {
        goto LABEL_11;
      }
    }
    else
    {
      *(void *)(a1 + 104) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
LABEL_11:
    sub_1011D694C(a1);
  }
}

void sub_1011D694C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 145) && *(unsigned char *)(a1 + 144))
  {
    if (!(*(unsigned int (**)(void))(**(void **)(a1 + 48) + 72))(*(void *)(a1 + 48)))
    {
      if (!*(unsigned char *)(a1 + 146)) {
        return;
      }
      long long v4 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v5 = "#I no reset is required clearing";
      goto LABEL_14;
    }
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I need to reset and sim is ready", buf, 2u);
    }
    if (*(unsigned char *)(a1 + 147))
    {
      uint64_t v3 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending sim reset", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
      long long v4 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      *(_WORD *)std::string buf = 0;
      uint64_t v5 = "#I reset saved iccid";
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
LABEL_15:
      sub_1011D60D8(a1);
      return;
    }
    if (!*(void *)(a1 + 104))
    {
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I start wait for camp timer", buf, 2u);
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 48) + 48))(buf);
      uint64_t v7 = *(void *)buf;
      sub_100058DB0(__p, "wait for camp timer");
      uint64_t v8 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v8;
      if (v8) {
        dispatch_retain(v8);
      }
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = sub_1011D6D54;
      v12[3] = &unk_101A9D260;
      v12[4] = a1;
      long long aBlock = _Block_copy(v12);
      sub_100118A44(v7, (uint64_t)__p, 1, 20000000, &object, &aBlock);
      uint64_t v9 = v19;
      uint64_t v19 = 0;
      uint64_t v10 = *(void *)(a1 + 104);
      *(void *)(a1 + 104) = v9;
      if (v10)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        uint64_t v11 = v19;
        uint64_t v19 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v16 < 0) {
        operator delete(__p[0]);
      }
      if (v18) {
        sub_10004D2C8(v18);
      }
    }
  }
}

void sub_1011D6C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  char v23 = *(std::__shared_weak_count **)(v21 - 40);
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D6CD0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 145) && !*(unsigned char *)(a1 + 146))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I cb setup calculate reset", v3, 2u);
    }
    *(unsigned char *)(a1 + 146) = 1;
    sub_1011D694C(a1);
  }
}

uint64_t sub_1011D6D54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 147) = 1;
  int v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I attempt reset on timer expiry", v4, 2u);
  }
  sub_1011D694C(v1);
  uint64_t result = *(void *)(v1 + 104);
  *(void *)(v1 + 104) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t sub_1011D6DF8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 80))(*(void *)(a1 + 48));
  if (result)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending sim reprovision", v4, 2u);
    }
    return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48));
  }
  return result;
}

void sub_1011D6EB0(void *a1, int a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    BOOL v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[5])
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v9[0] = 67109120;
          v9[1] = a2;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I bb online granted: %d", (uint8_t *)v9, 8u);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

uint64_t sub_1011D6F80(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011D6F9C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011D6FAC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        BOOL v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I assertion timer expired", v9, 2u);
        }
        uint64_t v7 = (std::__shared_weak_count *)v3[11];
        v3[10] = 0;
        v3[11] = 0;
        if (v7) {
          sub_10004D2C8(v7);
        }
        uint64_t v8 = v3[12];
        v3[12] = 0;
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_1011D7080(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))();
}

void sub_1011D70A8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1011D7174(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1011D724C);
  __cxa_rethrow();
}

void sub_1011D719C(_Unwind_Exception *a1)
{
}

void sub_1011D71B4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011D71EC(uint64_t a1)
{
}

uint64_t sub_1011D7208(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011D724C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1011D7278(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1011D7378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  char v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011D73FC(capabilities::ct *a1)
{
  capabilities::ct::supportsExclusiveAssertions(a1);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 1);
  if (v2)
  {
    if (std::__shared_weak_count::lock(v2)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1011D74F0(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "rest");
  sub_1011D75C8((void *)a1, "CCRestServer", QOS_CLASS_UTILITY, &v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  uint64_t v3 = *(NSObject **)(a1 + 16);
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  ctu::RestDispatchListener::create((ctu::RestDispatchListener *)&object, v2);
  if (object) {
    dispatch_release(object);
  }
  *(unsigned char *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  return a1;
}

void sub_1011D7590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, char a11)
{
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v11 + 4));
  sub_100087E88(v11);
  _Unwind_Resume(a1);
}

void *sub_1011D75C8(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_10058A678(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  return a1;
}

void sub_1011D7630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_1011D7668(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011D7768(void *a1, NSObject **a2)
{
  long long v4 = (uint64_t *)a1[4];
  if (!*((unsigned char *)v4 + 56))
  {
    uint64_t v5 = v4[4];
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CCRestServer::stop_sync called without calling start?", buf, 2u);
    }
  }
  OsLogContext v6 = v4[4];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#N XPC listener halted", buf, 2u);
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  v14[2] = sub_1011D7960;
  void v14[3] = &unk_101A9D468;
  uint64_t v7 = *a2;
  v14[4] = v4;
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(group);
  }
  uint64_t v8 = (std::__shared_weak_count *)a1[6];
  uint64_t v16 = a1[5];
  long long v17 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (std::__shared_weak_count *)v4[1];
  if (!v9 || (uint64_t v10 = *v4, (v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  char v12 = v11;
  OsLogContext v13 = v4[2];
  *(void *)std::string buf = _NSConcreteStackBlock;
  uint64_t v19 = 1174405120;
  uint64_t v20 = sub_1011D95D0;
  uint64_t v21 = &unk_101A9D7A0;
  uint64_t v23 = v10;
  char v24 = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  __int16 v22 = v14;
  dispatch_async(v13, buf);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10004D2C8(v12);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
}

void sub_1011D7960(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)queue v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#N CCRestServer shut down all XPC services", v2, 2u);
  }
}

void sub_1011D79C4(void *a1, void *a2)
{
  long long v4 = a2[5];
  a1[5] = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = a1[5];
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  uint64_t v6 = a2[7];
  a1[6] = a2[6];
  a1[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_1011D7A1C(uint64_t a1)
{
  queue v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_group_leave(v3);
    long long v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_release(v4);
    }
  }
}

uint64_t sub_1011D7A78(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011D7A94(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1011D7AA4(uint64_t a1)
{
  sub_10003F684((void **)(a1 + 72));
  sub_10003F600((void *)(a1 + 40));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3) {
    dispatch_release(v3);
  }

  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)a1);
}

void sub_1011D7B00(uint64_t a1, xpc_object_t object)
{
  if (object)
  {
    xpc_object_t v3 = object;
    xpc_retain(object);
    xpc_object_t objecta = v3;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t objecta = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  xpc_object_t objecta = v4;
LABEL_9:
  xpc_release(v3);
  xpc_object_t v5 = objecta;
  if (xpc_get_type(objecta) == (xpc_type_t)&_xpc_type_dictionary)
  {
    ctu::rest::getReplyValue((uint64_t *)&v9, (ctu::rest *)&objecta, v6);
    uint64_t v7 = *(void ***)(a1 + 32);
    uint64_t v8 = *v7;
    *uint64_t v7 = v9;
    uint64_t v9 = v8;
    xpc_release(v8);
    uint64_t v9 = 0;
    xpc_object_t v5 = objecta;
  }
  xpc_release(v5);
}

void sub_1011D7BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_1011D7C0C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011D7C28(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1011D7C38(uint64_t *a1, long long *a2, void **a3, uint64_t a4)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_1011D7DC8;
  v13[3] = &unk_101A9D500;
  v13[5] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v15 = *((void *)a2 + 2);
  }
  uint64_t v7 = *a3;
  xpc_object_t object = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  void v13[4] = a4;
  uint64_t v8 = (std::__shared_weak_count *)a1[1];
  if (!v8 || (v9 = *a1, (uint64_t v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v11 = v10;
  char v12 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1011D95D0;
  block[3] = &unk_101A9D7A0;
  void block[5] = v9;
  BOOL v18 = v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v13;
  dispatch_async(v12, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10004D2C8(v11);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__p);
  }
}

void sub_1011D7DC8(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  xpc_object_t v11 = 0;
  v7[0] = xpc_string_create("get");
  if (!v7[0]) {
    v7[0] = xpc_null_create();
  }
  object[0] = xpc_string_create("internal");
  if (!object[0]) {
    object[0] = xpc_null_create();
  }
  if (*(char *)(a1 + 71) < 0) {
    xpc_object_t v3 = *(const char **)(a1 + 48);
  }
  else {
    xpc_object_t v3 = (const char *)(a1 + 48);
  }
  v10.fObuint64_t j = (dispatch_object_s *)xpc_string_create(v3);
  if (!v10.fObj) {
    v10.fObuint64_t j = (dispatch_object_s *)xpc_null_create();
  }
  ctu::rest::createRestMessage((uint64_t *)&v11, (ctu::rest *)v7, (const object *)object, &v10, (const object *)(a1 + 72), v4);
  xpc_release(v10.fObj);
  xpc_release(object[0]);
  xpc_release(v7[0]);
  uint64_t v9 = 0;
  *(_OWORD *)uint64_t v7 = 0u;
  long long v8 = 0u;
  sub_1011D7FA0(v7, v2, (uint64_t)&v11, *(void **)(a1 + 32));
  uint64_t v5 = v2[8];
  ctu::PathView::PathView();
  (*(void (**)(uint64_t, xpc_object_t *, xpc_object_t *))(*(void *)v5 + 16))(v5, v7, object);
  if (v9) {
    sub_10004D2C8(v9);
  }
  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)v7);
  xpc_release(v11);
}

void sub_1011D7F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13)
{
  xpc_release(*(xpc_object_t *)(v13 - 40));
  _Unwind_Resume(a1);
}

void *sub_1011D7FA0(void *a1, uint64_t *a2, uint64_t a3, void *aBlock)
{
  *a1 = &off_101A9D578;
  a1[1] = a3;
  a1[2] = a2;
  if (aBlock) {
    uint64_t v6 = _Block_copy(aBlock);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  if (!v7 || (uint64_t v8 = *a2, (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  object v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  xpc_object_t v11 = operator new(0x20uLL);
  void *v11 = off_101A9D648;
  v11[1] = v6;
  v11[2] = v8;
  v11[3] = v10;
  void v14[3] = v11;
  char v12 = (std::__shared_weak_count *)operator new(0x40uLL);
  v12->__shared_owners_ = 0;
  v12->__shared_weak_owners_ = 0;
  v12->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D5F8;
  sub_10003F6B8((uint64_t)&v12[1], (uint64_t)v14);
  v12[2].__shared_owners_ = (uint64_t)xpc_null_create();
  a1[3] = (char *)v12 + 56;
  a1[4] = v12;
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  sub_10003F600(v14);
  return a1;
}

void sub_1011D80FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1011D816C(ctu::RestResourceContext *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ctu::RestResourceContext::~RestResourceContext(this);
}

xpc_object_t sub_1011D81AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 48;
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)v4, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 48);
    *(void *)(v4 + 16) = *(void *)(a2 + 64);
    *(_OWORD *)uint64_t v4 = v5;
  }
  uint64_t v6 = *(void **)(a2 + 72);
  *(void *)(a1 + 72) = v6;
  if (v6) {
    return xpc_retain(v6);
  }
  xpc_object_t result = xpc_null_create();
  *(void *)(a1 + 72) = result;
  return result;
}

void sub_1011D821C(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(void *)(a1 + 72) = 0;
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    operator delete(v2);
  }
}

void sub_1011D8274(uint64_t *a1, long long *a2, void **a3, uint64_t a4)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_1011D8404;
  v13[3] = &unk_101A9D538;
  v13[5] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v15 = *((void *)a2 + 2);
  }
  uint64_t v7 = *a3;
  xpc_object_t object = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  void v13[4] = a4;
  uint64_t v8 = (std::__shared_weak_count *)a1[1];
  if (!v8 || (v9 = *a1, (object v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  xpc_object_t v11 = v10;
  char v12 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_1011D95D0;
  block[3] = &unk_101A9D7A0;
  void block[5] = v9;
  BOOL v18 = v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v13;
  dispatch_async(v12, block);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_10004D2C8(v11);
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__p);
  }
}

void sub_1011D8404(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  xpc_object_t v11 = 0;
  v7[0] = xpc_string_create("set");
  if (!v7[0]) {
    v7[0] = xpc_null_create();
  }
  object[0] = xpc_string_create("internal");
  if (!object[0]) {
    object[0] = xpc_null_create();
  }
  if (*(char *)(a1 + 71) < 0) {
    xpc_object_t v3 = *(const char **)(a1 + 48);
  }
  else {
    xpc_object_t v3 = (const char *)(a1 + 48);
  }
  v10.fObuint64_t j = (dispatch_object_s *)xpc_string_create(v3);
  if (!v10.fObj) {
    v10.fObuint64_t j = (dispatch_object_s *)xpc_null_create();
  }
  ctu::rest::createRestMessage((uint64_t *)&v11, (ctu::rest *)v7, (const object *)object, &v10, (const object *)(a1 + 72), v4);
  xpc_release(v10.fObj);
  xpc_release(object[0]);
  xpc_release(v7[0]);
  uint64_t v9 = 0;
  *(_OWORD *)uint64_t v7 = 0u;
  long long v8 = 0u;
  sub_1011D7FA0(v7, v2, (uint64_t)&v11, *(void **)(a1 + 32));
  uint64_t v5 = v2[8];
  ctu::PathView::PathView();
  (*(void (**)(uint64_t, xpc_object_t *, xpc_object_t *))(*(void *)v5 + 16))(v5, v7, object);
  if (v9) {
    sub_10004D2C8(v9);
  }
  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)v7);
  xpc_release(v11);
}

void sub_1011D8570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t a13)
{
  xpc_release(*(xpc_object_t *)(v13 - 40));
  _Unwind_Resume(a1);
}

void sub_1011D85DC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_1011D85E4(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  uint64_t v4 = *(void ***)(a1 + 24);
  uint64_t v5 = *v4;
  *uint64_t v4 = v3;
  xpc_release(v5);
  return 1;
}

__n128 sub_1011D863C@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)(a1 + 24);
  *a2 = result;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  return result;
}

uint64_t sub_1011D864C(int a1, uint64_t a2, ctu::rest *this, object *a4, object *a5)
{
  xpc_object_t object = 0;
  ctu::rest::createNotify((uint64_t *)&object, this, a4, a5, a4);
  xpc_object_t v7 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v7 = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(*(void *)a2 + 16))(a2, &v7);
  xpc_release(v7);
  xpc_object_t v7 = 0;
  xpc_release(object);
  return 1;
}

void sub_1011D86F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10)
{
}

uint64_t sub_1011D8720(uint64_t a1, uint64_t a2, const object *a3, const object *a4, const object *a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a1 + 16);
  char v12 = *(void **)a6;
  xpc_object_t v11 = *(std::__shared_weak_count **)(a6 + 8);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_object_t v19 = 0;
  object[0] = xpc_string_create("get");
  if (!object[0]) {
    object[0] = xpc_null_create();
  }
  ctu::rest::createRestMessage((uint64_t *)&v19, (ctu::rest *)object, a3, a4, a5, v13);
  xpc_release(object[0]);
  xpc_object_t v18 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v18 = xpc_null_create();
  }
  uint64_t v14 = *(void *)(v10 + 16);
  object[0] = _NSConcreteStackBlock;
  object[1] = (xpc_object_t)1174405120;
  xpc_object_t object[2] = sub_1011D7B00;
  object[3] = &unk_101A9D4C8;
  xpc_object_t object[4] = v12;
  long long v17 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, xpc_object_t *, uint64_t, xpc_object_t *))(*(void *)a2 + 24))(a2, &v18, v14, object);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  if (v17) {
    sub_10004D2C8(v17);
  }
  xpc_release(v19);
  if (v11) {
    sub_10004D2C8(v11);
  }
  return 1;
}

void sub_1011D88A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, xpc_object_t object, xpc_object_t a16)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  xpc_release(object);
  xpc_release(a16);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011D8908(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 16) + 64);
  ctu::PathView::PathView();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v2 + 16))(v2, a1, &v4);
}

void sub_1011D8988(ctu::RestResourceContext *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::RestResourceContext::~RestResourceContext(this);

  operator delete();
}

void sub_1011D89DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D5F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011D89FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D5F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1011D8A50(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    xpc_object_t object = *(xpc_object_t *)(a1 + 56);
    *(void *)(a1 + 56) = xpc_null_create();
    uint64_t v2 = *(void *)(a1 + 48);
    if (!v2) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v2 + 48))(v2, &object);
    xpc_release(object);
    xpc_object_t object = 0;
  }
  xpc_release(*(xpc_object_t *)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  return sub_10003F600((void *)(a1 + 24));
}

void *sub_1011D8AFC(void *a1)
{
  *a1 = off_101A9D648;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  xpc_object_t v3 = (const void *)a1[1];
  if (v3) {
    _Block_release(v3);
  }
  return a1;
}

void sub_1011D8B58(void *a1)
{
  *a1 = off_101A9D648;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  xpc_object_t v3 = (const void *)a1[1];
  if (v3) {
    _Block_release(v3);
  }

  operator delete();
}

void *sub_1011D8BD4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = off_101A9D648;
  sub_1011D8DB0(v2 + 1, v1);
  return v2;
}

void *sub_1011D8C28(uint64_t a1, void *a2)
{
  *a2 = off_101A9D648;
  return sub_1011D8DB0(a2 + 1, a1 + 8);
}

void sub_1011D8C54(uint64_t a1)
{
}

void sub_1011D8C5C(void *a1)
{
  sub_1011D8E04((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011D8C98(uint64_t a1, void **a2)
{
  xpc_object_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  (*(void (**)(uint64_t, xpc_object_t *))(v4 + 16))(v4, &object);
  xpc_release(object);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  xpc_release(v3);
}

void sub_1011D8D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1011D8D64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011D8DA4()
{
}

void *sub_1011D8DB0(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2) {
    uint64_t v4 = _Block_copy(v4);
  }
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  *a1 = v4;
  a1[1] = v6;
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1011D8E04(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
}

void sub_1011D8E40(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1011D8F0C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)sub_1011D8FE4);
  __cxa_rethrow();
}

void sub_1011D8F34(_Unwind_Exception *a1)
{
}

void sub_1011D8F4C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1011D8F84(uint64_t a1)
{
}

uint64_t sub_1011D8FA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011D8FE4(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = *(std::__shared_weak_count **)(result + 88);
    if (v2) {
      sub_10004D2C8(v2);
    }
    xpc_object_t v3 = (std::__shared_weak_count *)v1[9];
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[6];
    if (v4) {
      sub_10004D2C8(v4);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 4));
    sub_100087E88(v1);
    operator delete();
  }
  return result;
}

void sub_1011D9060(ServiceManager::Service *this)
{
  *(void *)this = off_101A9D728;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1011D90BC(ServiceManager::Service *this)
{
  *(void *)this = off_101A9D728;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1011D912C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "CCRestServer");
}

unsigned char *sub_1011D913C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1011D917C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  xpc_object_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1011D7668(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1011D7668(v4, 0);
}

uint64_t sub_1011D9200()
{
  return 0;
}

uint64_t sub_1011D9208()
{
  return 1;
}

uint64_t sub_1011D9210()
{
  return 0;
}

void sub_1011D9220(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  dispatch_object_t object = 0;
  ServiceStage::holdOffStage((uint64_t *)&object, this);
  uint64_t v4 = object;
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 8);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011D93F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, dispatch_group_t group)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v17);
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(a1);
}

void sub_1011D9438(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 32);
  if (*(unsigned char *)(v2 + 56))
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "CCRestServer::start_sync called twice?", buf, 2u);
    }
  }
  else
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Starting XPC listener", v6, 2u);
    }
    *(unsigned char *)(v2 + 56) = 1;
  }
  uint64_t v4 = v1[1];
  if (v4)
  {
    dispatch_group_leave(v4);
    uint64_t v5 = v1[1];
    if (v5) {
      dispatch_release(v5);
    }
  }
  operator delete();
}

void sub_1011D952C(uint64_t *a1)
{
  uint64_t v5 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = *(NSObject **)(*(void *)*a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Flush of all incoming requests complete. (could be more, but oh well)", buf, 2u);
  }
  uint64_t v3 = *(NSObject **)(v1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(v1 + 8);
    if (v4) {
      dispatch_release(v4);
    }
  }
  operator delete();
}

uint64_t sub_1011D95D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1011D95E0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011D95FC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1011D960C(uint64_t a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *(std::__shared_weak_count **)(**(void **)a1 + 8);
  if (v1)
  {
    uint64_t v2 = std::__shared_weak_count::lock(v1);
    if (v2)
    {
      atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v2);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011D9D6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  operator delete();
}

void sub_1011D9E44(ctu::RestListenerDelegateBase *this)
{
  *(void *)this = off_101A9D7E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  ctu::RestListenerDelegateBase::~RestListenerDelegateBase(this);
}

void sub_1011D9EA0(ctu::RestListenerDelegateBase *this)
{
  *(void *)this = off_101A9D7E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::RestListenerDelegateBase::~RestListenerDelegateBase(this);

  operator delete();
}

void sub_1011D9F10(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    xpc_object_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *a3;
        *a3 = xpc_null_create();
        long long v17 = 0u;
        *(_OWORD *)uint64_t v15 = 0u;
        memset(v16, 0, sizeof(v16));
        long long v14 = 0u;
        object[0] = xpc_null_create();
        v13[3] = 0;
        ctu::ReplyCallbackRestResourceContext::ReplyCallbackRestResourceContext();
        sub_10003F600(v13);
        xpc_release(object[0]);
        uint64_t v11 = *(void *)(v9 + 64);
        ctu::PathView::PathView();
        (*(void (**)(uint64_t, long long *, xpc_object_t *, uint64_t))(*(void *)v11 + 32))(v11, &v14, object, a2);
        sub_10003F684((void **)&v17 + 1);
        sub_10003F600((void *)v16 + 1);
        if (*(void *)&v16[0]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v16[0]);
        }
        if (v15[0]) {
          dispatch_release(v15[0]);
        }
        ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)&v14);
        xpc_release(v10);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1011DA0B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1011DA118(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D830;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DA138(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D830;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DA18C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1011DA1B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DA1D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D880;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DA228(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1011DA250(uint64_t *a1)
{
  uint64_t v2 = operator new(0x40uLL);
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = off_101A9D8D0;
  uint64_t result = ctu::AssertionRestResource::AssertionRestResource((ctu::AssertionRestResource *)(v2 + 3));
  *a1 = result;
  a1[1] = (uint64_t)v2;
  return result;
}

void sub_1011DA2A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1011DA2BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D8D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DA2DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D8D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DA330(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1011DA358(uint64_t *a1, char a2)
{
  uint64_t v4 = operator new(0x70uLL);
  v4[1] = 0;
  v4[2] = 0;
  *uint64_t v4 = off_101A9D920;
  uint64_t result = ctu::PropertyRestResource::PropertyRestResource((ctu::PropertyRestResource *)(v4 + 3), a2 != 0);
  *a1 = result;
  a1[1] = (uint64_t)v4;
  return result;
}

void sub_1011DA3C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1011DA3D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DA3F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D920;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DA44C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1011DA474(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DA494(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9D970;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DA4E8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1011DA514(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DA54C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1011DA57C(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_1011DA6F8()
{
}

void sub_1011DA7DC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1011DA7F8(uint64_t a1, void *a2)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained registerOfferCategory:v5];
  }
}

void sub_1011DA85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1011DAC78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (v18) {
    sub_10004D2C8(v18);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1011DAD54(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 identifier];
  unsigned int v5 = [v4 isEqualToString:a1[4]];

  if (v5)
  {
    uint64_t v6 = sub_100200FB4(*(id **)(a1[5] + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[4];
      int v13 = 138412290;
      uint64_t v14 = v7;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I '%@' notification category is already registered, removing it", (uint8_t *)&v13, 0xCu);
    }
  }
  else
  {
    long long v8 = [v3 identifier];
    unsigned int v9 = [v8 isEqualToString:a1[6]];

    if (!v9)
    {
      uint64_t v11 = 1;
      goto LABEL_10;
    }
    uint64_t v6 = sub_100200FB4(*(id **)(a1[5] + 8));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = a1[6];
      int v13 = 138412290;
      uint64_t v14 = v10;
      goto LABEL_7;
    }
  }

  uint64_t v11 = 0;
LABEL_10:

  return v11;
}

void sub_1011DAEBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1011DB104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1011DB13C(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    id v3 = [(NSError *)v2 localizedDescription];
    int v4 = 138412290;
    unsigned int v5 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "addNotificationRequest error: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1011DB200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1011DB308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1011DB410(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1011DB48C(uint64_t a1)
{
  *(void *)a1 = off_101A9DA90;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_1004FDE68(a1 + 8);
  return a1;
}

void sub_1011DB504(uint64_t a1)
{
  sub_1011DB48C(a1);

  operator delete();
}

void sub_1011DB53C(uint64_t a1@<X0>, int a2@<W1>, id *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v9 = *(void *)(a1 + 48);
  switch(a2)
  {
    case 2:
      CFBooleanRef v59 = a3;
      *(void *)std::string buf = 0;
      uint64_t v18 = kBifrostLocalizationTable;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v9 + 40))(&buf[8], v9, kBifrostLocalizationTable, @"BIFROST_MESSAGING_ALERT_CONNECT_OFFER_BODY", 0);
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v9 + 40))(&v66, v9, v18, @"BIFROST_MESSAGING_ALERT_CONNECT_OFFER_ACCEPT", 0);
      *((void *)&v66 + 1) = @"ConnectionAssistant-OTG-Accept-SatelliteConnection";
      CFRetain(@"ConnectionAssistant-OTG-Accept-SatelliteConnection");
      uint64_t v58 = a4;
      CFStringRef v67 = @"OffGridModeOfferAlert";
      CFRetain(@"OffGridModeOfferAlert");
      LOWORD(v68) = 0;
      long long v17 = (char *)operator new(0x48uLL);
LABEL_11:
      uint64_t v11 = v17;
      long long v19 = v66;
      *(_OWORD *)(v17 + 24) = *(_OWORD *)buf;
      int v13 = (const void **)(v17 + 24);
      *(_OWORD *)(v17 + 8) = 0u;
      *(void *)long long v17 = off_101A9DBA8;
      *(_OWORD *)(v17 + 40) = v19;
      *(_OWORD *)std::string buf = 0u;
      long long v66 = 0u;
      *((void *)v17 + 7) = v67;
      CFStringRef v67 = 0;
      *((_WORD *)v17 + 32) = (_WORD)v68;
      sub_1000558F4((const void **)&v67);
      sub_1000558F4((const void **)&v66 + 1);
      sub_1000558F4((const void **)&v66);
      sub_1000558F4((const void **)&buf[8]);
      sub_1000558F4((const void **)buf);
      if (*((void *)v11 + 4)) {
        uint64_t v20 = sub_1000810B8;
      }
      else {
        uint64_t v20 = 0;
      }
      if (v20)
      {
        uint64_t v15 = *((void *)v11 + 5);
LABEL_16:
        if (v15) {
          uint64_t v21 = sub_1000810B8;
        }
        else {
          uint64_t v21 = 0;
        }
        if (v21)
        {
          char v22 = SBSIsSystemApertureAvailable();
          if (a2) {
            char v23 = v22;
          }
          else {
            char v23 = 0;
          }
          if ((v23 & 1) == 0)
          {
            long long v29 = *(std::__shared_weak_count **)(a1 + 16);
            if (v29)
            {
              uint64_t v30 = *(void *)(a1 + 8);
              uint64_t v31 = std::__shared_weak_count::lock(v29);
              if (v31)
              {
                uint64_t v32 = v31;
                p_shared_weak_owners = &v31->__shared_weak_owners_;
                atomic_fetch_add_explicit(&v31->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v31);
                uint64_t v34 = (char *)operator new(0x58uLL);
                *((void *)v34 + 1) = 0;
                *((void *)v34 + 2) = 0;
                *(void *)uint64_t v34 = off_101A9DBF8;
                sub_100083DA4((const void **)buf, v13 + 3);
                *((void *)v34 + 3) = off_101A9DC48;
                *((void *)v34 + 4) = v30;
                *((void *)v34 + 5) = v32;
                atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
                *((_DWORD *)v34 + 12) = a2;
                *((void *)v34 + 7) = 0;
                sub_100083DA4((const void **)v34 + 8, (const void **)buf);
                *((void *)v34 + 9) = 0;
                *((void *)v34 + 10) = 0;
                sub_1000558F4((const void **)buf);
                std::__shared_weak_count::__release_weak(v32);
                if ((a2 - 1) <= 1)
                {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)v34 + 2, 1uLL, memory_order_relaxed);
                  sub_100058DB0(__p, "DismissNotificationTracker");
                  uint64_t v64 = 7000;
                  *(void *)&long long v70 = v34 + 24;
                  *((void *)&v70 + 1) = v34;
                  atomic_fetch_add_explicit((atomic_ullong *volatile)v34 + 2, 1uLL, memory_order_relaxed);
                  id v71 = *v59;
                  sub_1011DCE48((uint64_t)v72, v58);
                  *((void *)&v66 + 1) = 0;
                  uint64_t v35 = (char *)operator new(0x40uLL);
                  *(void *)uint64_t v35 = off_101A9DC90;
                  *(_OWORD *)(v35 + 8) = v70;
                  long long v70 = 0uLL;
                  id v36 = v71;
                  *((void *)v35 + 3) = v36;
                  id v71 = 0;

                  sub_1011DCE48((uint64_t)(v35 + 32), (uint64_t)v72);
                  *((void *)&v66 + 1) = v35;
                  AutoStartTimer::create();
                  long long v37 = v63;
                  long long v63 = 0uLL;
                  char v38 = (std::__shared_weak_count *)*((void *)v34 + 10);
                  *(_OWORD *)(v34 + 72) = v37;
                  if (v38)
                  {
                    sub_10004D2C8(v38);
                    if (*((void *)&v63 + 1)) {
                      sub_10004D2C8(*((std::__shared_weak_count **)&v63 + 1));
                    }
                  }
                  sub_10003B34C(buf);
                  sub_100C0015C(v72);
                  id v39 = v71;
                  id v71 = 0;

                  if (*((void *)&v70 + 1)) {
                    std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v70 + 1));
                  }
                  if (v62 < 0) {
                    operator delete(__p[0]);
                  }
                  std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v34);
                }
                *(void *)std::string buf = *(id *)(a1 + 80);
                *(void *)&uint8_t buf[8] = v34 + 24;
                *(void *)&long long v66 = v34;
                *((void *)&v66 + 1) = v13;
                atomic_fetch_add_explicit((atomic_ullong *volatile)v34 + 1, 1uLL, memory_order_relaxed);
                CFStringRef v67 = (const __CFString *)v11;
                atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
                id v68 = *v59;
                sub_1011DCE48((uint64_t)&v69, v58);
                char v40 = *(std::__shared_weak_count **)(a1 + 16);
                if (v40 && std::__shared_weak_count::lock(v40)) {
                  operator new();
                }
                sub_100088B9C();
              }
            }
            sub_100088B9C();
          }
          CFTypeRef cf = 0;
          char v24 = +[NSMutableDictionary dictionary];
          char v25 = v24;
          if (*v13) {
            char v26 = sub_1000810B8;
          }
          else {
            char v26 = 0;
          }
          if (v13[1]) {
            uint64_t v27 = sub_1000810B8;
          }
          else {
            uint64_t v27 = 0;
          }
          if (v26)
          {
            if (v27) {
              objc_msgSend(v24, "setObject:forKeyedSubscript:");
            }
          }
          else if (!v27)
          {
LABEL_53:
            if (v13[2]) {
              uint64_t v41 = sub_1000810B8;
            }
            else {
              uint64_t v41 = 0;
            }
            if (v41) {
              objc_msgSend(v25, "setObject:forKeyedSubscript:");
            }
            [v25 setObject:&__kCFBooleanTrue forKeyedSubscript:kCFUserNotificationAlertTopMostKey];
            [v25 setObject:&__kCFBooleanTrue forKeyedSubscript:SBUserNotificationDismissOnLock];
            uint64_t v57 = +[BSColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];
            __int16 v42 = +[SBSUserNotificationColorDefinition definitionWithColor:](SBSUserNotificationColorDefinition, "definitionWithColor:");
            long long v43 = +[SBSUserNotificationImageDefinition definitionWithSystemImageName:@"satellite.wave.2.fill" tintColorDefinition:v42];
            uint64_t v44 = objc_opt_new();
            [v44 setLeadingAssetDefinition:v43];
            if (*v13) {
              uint64_t v45 = sub_1000810B8;
            }
            else {
              uint64_t v45 = 0;
            }
            if (v45) {
              objc_msgSend(v44, "setAlertHeader:");
            }
            [v44 setPreventsAutomaticDismissal:1];
            [v44 setDefaultButtonTitle:v13[2]];
            [v25 setObject:&__kCFBooleanTrue forKeyedSubscript:SBUserNotificationSystemAperturePresentationKey];
            uint64_t v46 = [v44 build];
            [v25 setObject:v46 forKeyedSubscript:SBUserNotificationSystemApertureContentDefinitionKey];

            LODWORD(__p[0]) = 0;
            CFUserNotificationRef v47 = CFUserNotificationCreate(0, 0.0, 3uLL, (SInt32 *)__p, (CFDictionaryRef)v25);
            *(void *)std::string buf = v47;
            if (!LODWORD(__p[0]) && (v47 ? (uint64_t v48 = sub_1001D8360) : (uint64_t v48 = 0), v48))
            {
              CFTypeRef cf = v47;
              *(void *)std::string buf = 0;
            }
            else
            {
              CFTypeRef cf = 0;
            }
            sub_1001D88DC((const void **)buf);

            if (cf) {
              uint64_t v49 = sub_1001D8360;
            }
            else {
              uint64_t v49 = 0;
            }
            if (v49)
            {
              uint64_t v50 = *(std::__shared_weak_count **)(a1 + 16);
              if (v50)
              {
                uint64_t v51 = *(void *)(a1 + 8);
                uint64_t v52 = std::__shared_weak_count::lock(v50);
                if (v52)
                {
                  uint64_t v53 = v52;
                  atomic_fetch_add_explicit(&v52->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v52);
                  long long v54 = (char *)operator new(0x58uLL);
                  *((void *)v54 + 1) = 0;
                  *((void *)v54 + 2) = 0;
                  *(void *)long long v54 = off_101A9DBF8;
                  *(void *)std::string buf = cf;
                  if (cf) {
                    CFRetain(cf);
                  }
                  *((void *)v54 + 3) = off_101A9DC48;
                  *((void *)v54 + 4) = v51;
                  *((void *)v54 + 5) = v53;
                  atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  *((_DWORD *)v54 + 12) = a2;
                  sub_1001D89F0((const void **)v54 + 7, (const void **)buf);
                  *((void *)v54 + 8) = 0;
                  *((void *)v54 + 9) = 0;
                  *((void *)v54 + 10) = 0;
                  sub_1001D88DC((const void **)buf);
                  std::__shared_weak_count::__release_weak(v53);
                  *(void *)std::string buf = v54 + 24;
                  *(void *)&uint8_t buf[8] = v54;
                  atomic_fetch_add_explicit((atomic_ullong *volatile)v54 + 1, 1uLL, memory_order_relaxed);
                  *(void *)&long long v66 = *v59;
                  sub_1011DCE48((uint64_t)&v66 + 8, v58);
                  long long v55 = *(std::__shared_weak_count **)(a1 + 16);
                  if (v55)
                  {
                    if (std::__shared_weak_count::lock(v55)) {
                      operator new();
                    }
                  }
                  sub_100088B9C();
                }
              }
              sub_100088B9C();
            }
            char v56 = sub_100200FB4((id *)(a1 + 40));
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Failed to create a notification alert", buf, 2u);
            }

            *a5 = 0;
            a5[1] = 0;
            sub_1001D88DC(&cf);
            sub_10004D2C8((std::__shared_weak_count *)v11);
            return;
          }
          objc_msgSend(v25, "setObject:forKeyedSubscript:");
          goto LABEL_53;
        }
      }
LABEL_33:
      sub_10004D2C8((std::__shared_weak_count *)v11);
      break;
    case 1:
      CFBooleanRef v59 = a3;
      *(void *)std::string buf = 0;
      uint64_t v16 = kBifrostLocalizationTable;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v9 + 40))(&buf[8], v9, kBifrostLocalizationTable, @"BIFROST_MESSAGING_ALERT_OTG_OFFER_BODY", 0);
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v9 + 40))(&v66, v9, v16, @"BIFROST_MESSAGING_ALERT_OTG_OFFER_ACCEPT", 0);
      *((void *)&v66 + 1) = @"ConnectionAssistant-OTG-Accept";
      CFRetain(@"ConnectionAssistant-OTG-Accept");
      uint64_t v58 = a4;
      CFStringRef v67 = @"OffGridModeOfferAlert";
      CFRetain(@"OffGridModeOfferAlert");
      LOWORD(v68) = 0;
      long long v17 = (char *)operator new(0x48uLL);
      goto LABEL_11;
    case 0:
      CFBooleanRef v59 = a3;
      uint64_t v10 = kBifrostLocalizationTable;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v9 + 40))(buf, v9, kBifrostLocalizationTable, @"BIFROST_MESSAGING_LOCK_SCREEN_OTG_OFFER_TITLE", 0);
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v9 + 40))(&buf[8], v9, v10, @"BIFROST_MESSAGING_LOCK_SCREEN_OTG_OFFER_BODY", 0);
      *(void *)&long long v66 = 0;
      *((void *)&v66 + 1) = @"ConnectionAssistant-OTG";
      CFRetain(@"ConnectionAssistant-OTG");
      uint64_t v58 = a4;
      CFStringRef v67 = @"OffGridModeOffer";
      CFRetain(@"OffGridModeOffer");
      LOWORD(v68) = 257;
      uint64_t v11 = (char *)operator new(0x48uLL);
      long long v12 = v66;
      *(_OWORD *)(v11 + 24) = *(_OWORD *)buf;
      int v13 = (const void **)(v11 + 24);
      *(_OWORD *)(v11 + 8) = 0u;
      *(void *)uint64_t v11 = off_101A9DBA8;
      *(_OWORD *)(v11 + 40) = v12;
      *(_OWORD *)std::string buf = 0u;
      long long v66 = 0u;
      *((void *)v11 + 7) = v67;
      CFStringRef v67 = 0;
      *((_WORD *)v11 + 32) = (_WORD)v68;
      sub_1000558F4((const void **)&v67);
      sub_1000558F4((const void **)&v66 + 1);
      sub_1000558F4((const void **)&v66);
      sub_1000558F4((const void **)&buf[8]);
      sub_1000558F4((const void **)buf);
      if (*((void *)v11 + 3)) {
        uint64_t v14 = sub_1000810B8;
      }
      else {
        uint64_t v14 = 0;
      }
      if (v14)
      {
        uint64_t v15 = *((void *)v11 + 4);
        goto LABEL_16;
      }
      goto LABEL_33;
  }
  uint64_t v28 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to create alert content", buf, 2u);
  }

  *a5 = 0;
  a5[1] = 0;
}

void sub_1011DC2D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  sub_1001D88DC(&a13);
  sub_10004D2C8(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_1011DC448(uint64_t a1)
{
  sub_100C0015C((void *)(a1 + 24));
  uint64_t v2 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0;

  id v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void stewie::ConnectionAssistantAlertInterface::create(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  unsigned int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15.var0 = (char *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v15);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_9;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11)
  {
    std::mutex::unlock(v5);
    if (v12) {
      goto LABEL_11;
    }
LABEL_9:
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  if (!v12)
  {
    *a2 = 0;
    a2[1] = 0;
LABEL_16:
    sub_10004D2C8(v11);
    return;
  }
LABEL_11:
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  Registry::getTimerService(&v13, *a1);
  if (v13) {
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
  if (v14) {
    sub_10004D2C8(v14);
  }
  if (v11) {
    goto LABEL_16;
  }
}

void sub_1011DC834()
{
  unsigned int v5 = *(std::__shared_weak_count **)(v1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger(v4);
  sub_1004FDE68(v3);
  if (v2)
  {
    sub_10004D2C8(v2);
    if (!v0) {
      goto LABEL_7;
    }
  }
  else if (!v0)
  {
    goto LABEL_7;
  }
  sub_10004D2C8(v0);
LABEL_7:
  operator delete();
}

const void **sub_1011DC964(const void **a1)
{
  sub_1000558F4(a1 + 4);
  sub_1000558F4(a1 + 3);
  sub_1000558F4(a1 + 2);
  sub_1000558F4(a1 + 1);

  return sub_1000558F4(a1);
}

void sub_1011DC9B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9DBA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DC9D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9DBA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_1011DCA2C(const void **a1)
{
  uint64_t v2 = a1 + 3;
  sub_1000558F4(a1 + 7);
  sub_1000558F4(a1 + 6);
  sub_1000558F4(a1 + 5);
  sub_1000558F4(a1 + 4);

  return sub_1000558F4(v2);
}

void sub_1011DCA88(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9DBF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011DCAA8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9DBF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DCAFC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1011DCB24(uint64_t a1)
{
  *(void *)a1 = off_101A9DC48;
  sub_1011DCDB0();
  uint64_t v2 = sub_100200FB4(&qword_101B13310);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Destroying alert handle", v6, 2u);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1000558F4((const void **)(a1 + 40));
  sub_1001D88DC((const void **)(a1 + 32));
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1011DCBE8(uint64_t a1)
{
  sub_1011DCB24(a1);

  operator delete();
}

uint64_t sub_1011DCC20(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

void sub_1011DCC28(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    uint64_t v2 = sub_1001D8360;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    sub_1011DCDB0();
    uint64_t v3 = sub_100200FB4(&qword_101B13310);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Dismissing notification alert", buf, 2u);
    }

    CFUserNotificationCancel(*(CFUserNotificationRef *)(a1 + 32));
  }
  else
  {
    int v4 = (const void **)(a1 + 40);
    if (*(void *)(a1 + 40)) {
      unsigned int v5 = sub_1000810B8;
    }
    else {
      unsigned int v5 = 0;
    }
    if (v5)
    {
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = *(void *)(a1 + 8);
          if (v9)
          {
            sub_1011DCDB0();
            uint64_t v10 = sub_100200FB4(&qword_101B13310);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v12 = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Dismissing notification", v12, 2u);
            }

            sub_100083DA4(&v11, v4);
            [*(id *)(v9 + 80) dismissNotification:v11];
            sub_1000558F4(&v11);
          }
          sub_10004D2C8(v8);
        }
      }
    }
  }
}

void sub_1011DCD8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_1011DCDB0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13318, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13318))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&unk_101B13310, kCtLoggingSystemName, "stw.ca.alert");
    __cxa_guard_release(&qword_101B13318);
  }
}

void sub_1011DCE30(_Unwind_Exception *a1)
{
}

uint64_t sub_1011DCE48(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_1011DCEC8(uint64_t a1)
{
  *(void *)a1 = off_101A9DC90;
  sub_100C0015C((void *)(a1 + 32));
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1011DCF2C(uint64_t a1)
{
  *(void *)a1 = off_101A9DC90;
  sub_100C0015C((void *)(a1 + 32));
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1011DCFB0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  *uint64_t v2 = off_101A9DC90;
  sub_1011DD220(v2 + 1, v1);
  return v2;
}

void sub_1011DD004(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1011DD018(uint64_t a1, void *a2)
{
  *a2 = off_101A9DC90;
  return sub_1011DD220(a2 + 1, a1 + 8);
}

void sub_1011DD044(uint64_t a1)
{
}

void sub_1011DD04C(void *a1)
{
  sub_1011DD33C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1011DD088(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  v4[0] = *(std::__shared_weak_count **)(a1 + 8);
  v4[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1011DD2A4((uint64_t)&v5, a1 + 32);
  sub_100200FB4((id *)(a1 + 24));
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  operator new();
}

void sub_1011DD1A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011DD1D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011DD214()
{
}

void *sub_1011DD220(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = *(void *)a2;
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  a1[2] = *(id *)(a2 + 16);
  sub_1011DD2A4((uint64_t)(a1 + 3), a2 + 24);
  return a1;
}

void sub_1011DD278(_Unwind_Exception *a1)
{
  id v3 = *(void **)(v1 + 16);
  *(void *)(v1 + 16) = 0;

  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011DD2A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1011DD33C(uint64_t a1)
{
  sub_100C0015C((void *)(a1 + 24));
  uint64_t v2 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0;

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_1011DD39C(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_100C0015C((void *)(v1 + 16));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1011DD3F8(uint64_t *a1)
{
  uint64_t v6 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*a1) {
        sub_1011DD478(a1[5], *a1, 0);
      }
      sub_10004D2C8(v4);
    }
  }
  return sub_1011DD39C((uint64_t *)&v6);
}

void sub_1011DD45C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10004D2C8(v2);
  sub_1011DD39C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011DD478(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = a2;
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t *sub_1011DD4D0(id **a1)
{
  objc_msgSend(**a1, "postNotification:", (*a1)[3], a1, *a1);
  sub_1011DD534(&v3);
  return sub_100046B58(&v2);
}

void sub_1011DD518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1011DD534(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_100C0015C((void *)(v1 + 48));
    uint64_t v2 = *(void **)(v1 + 40);
    *(void *)(v1 + 40) = 0;

    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 32);
    if (v3) {
      sub_10004D2C8(v3);
    }
    char v4 = *(std::__shared_weak_count **)(v1 + 16);
    if (v4) {
      sub_10004D2C8(v4);
    }

    operator delete();
  }
  return result;
}

void sub_1011DD5B8(id **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  CFOptionFlags responseFlags = 0;
  SInt32 v2 = CFUserNotificationReceiveResponse(*((CFUserNotificationRef *)*v1 + 4), 7.0, &responseFlags);
  sub_1011DCDB0();
  uint64_t v3 = sub_100200FB4(&qword_101B13310);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109376;
    HIDWORD(buf) = v2;
    *(_WORD *)buf_8 = 2048;
    *(void *)&buf_8[2] = responseFlags;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Notification response received: %d, CFOptionFlags responseFlags = %ld", (uint8_t *)&buf, 0x12u);
  }

  char v4 = (atomic_ullong *)v1[1];
  id buf = *v1;
  *(void *)buf_8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(v4 + 1, 1uLL, memory_order_relaxed);
  }
  *(void *)&buf_8[8] = responseFlags;
  SInt32 v11 = v2;
  sub_1011DD2A4((uint64_t)&v12, (uint64_t)(v1 + 3));
  sub_100200FB4(v1 + 2);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  operator new();
}

void sub_1011DD790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1011DD7DC(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_100C0015C((void *)(v1 + 24));
    SInt32 v2 = *(void **)(v1 + 16);
    *(void *)(v1 + 16) = 0;

    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1011DD84C(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_100C0015C((void *)(v1 + 32));
    SInt32 v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1011DD8A8(uint64_t a1)
{
  uint64_t v3 = a1;
  if (*(_DWORD *)(a1 + 24)) {
    char v1 = 0;
  }
  else {
    char v1 = *(void *)(a1 + 16) == 0;
  }
  sub_1011DD478(*(void *)(a1 + 56), *(void *)a1, v1);
  return sub_1011DD84C(&v3);
}

void sub_1011DD900(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1011DD84C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1011DD918(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DD950(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1011DD980(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1011DD9C4(void *a1, uint64_t a2, NSObject **a3, uint64_t a4, char *a5)
{
  uint64_t v9 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, a5);
  sub_1011DDACC(v9, a3, &v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *a1 = &off_101A9DD88;
  uint64_t v10 = *(Registry **)a2;
  a1[6] = *(void *)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  a1[7] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    uint64_t v10 = (Registry *)a1[6];
  }
  Registry::getMobileHelper(v10);
  a1[10] = 0;
  a1[11] = a4;
  return a1;
}

void sub_1011DDA8C(_Unwind_Exception *a1)
{
  char v4 = (std::__shared_weak_count *)v2[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  SuppServicesPreferencesInterface::~SuppServicesPreferencesInterface((SuppServicesPreferencesInterface *)v2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v2 + 5));
  sub_100087E88(v1);
  _Unwind_Resume(a1);
}

void *sub_1011DDACC(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  id v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1011DDB34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

SuppServicesPreferencesInterface *sub_1011DDB58(SuppServicesPreferencesInterface *this)
{
  *(void *)this = &off_101A9DD88;
  uint64_t v2 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v3) {
    sub_10004D2C8(v3);
  }
  char v4 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v4) {
    sub_10004D2C8(v4);
  }
  SuppServicesPreferencesInterface::~SuppServicesPreferencesInterface(this);
  ctu::OsLogLogger::~OsLogLogger((SuppServicesPreferencesInterface *)((char *)this + 40));
  sub_100087E88((void *)this + 1);
  return this;
}

unint64_t sub_1011DDC08@<X0>(uint64_t a1@<X0>, int a2@<W1>, unint64_t *a3@<X8>)
{
  uint64_t v4 = a1 + 64;
  if ((a2 - 1) > 1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()];
  }
  unint64_t result = sub_1011DDCA8(v4, v5);
  *a3 = 0;
  a3[1] = 0;
  if (HIDWORD(result))
  {
    int v7 = result;
    uint64_t v8 = operator new(0x20uLL);
    v8[1] = 0;
    void v8[2] = 0;
    void *v8 = off_101A7CD38;
    a3[1] = (unint64_t)v8;
    *((unsigned char *)v8 + 25) = v7;
    *((unsigned char *)v8 + 24) = BYTE2(v7);
    unint64_t result = (unint64_t)(v8 + 3);
    *a3 = result;
  }
  return result;
}

unint64_t sub_1011DDCA8(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)a1 + 16))(&cf);
    uint64_t v2 = (void *)cf;
  }
  else
  {
    uint64_t v2 = 0;
    CFTypeRef cf = 0;
  }
  if (v2) {
    uint64_t v3 = sub_100080934;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3) {
    goto LABEL_12;
  }
  int v9 = 0;
  if (!v2)
  {
LABEL_13:
    unsigned __int8 v6 = 0;
    int v7 = 0;
    goto LABEL_14;
  }
  CFTypeID v4 = CFGetTypeID(v2);
  if (v4 != CFNumberGetTypeID() || (ctu::cf::assign((ctu::cf *)&v9, (unsigned int *)v2, v5) & 1) == 0)
  {
LABEL_12:
    LODWORD(v2) = 0;
    goto LABEL_13;
  }
  unsigned __int8 v6 = v9;
  LODWORD(v2) = v9 & 0xFFFFFF00;
  int v7 = &_mh_execute_header;
LABEL_14:
  sub_1000577C4(&cf);
  return (unint64_t)v7 & (unint64_t)&_mh_execute_header | v2 & 0xFFFFFF00 | v6;
}

void sub_1011DDDA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011DDDB8(uint64_t a1, int a2, unsigned __int8 **a3)
{
  int v4 = **a3;
  int v5 = (*a3)[1];
  if ((a2 - 1) > 1) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_1011DDE2C((void *)(a1 + 64), v6, v5 | (v4 << 16));
}

uint64_t sub_1011DDE2C(void *a1, uint64_t a2, unsigned int a3)
{
  CFNumberRef v12 = 0;
  unint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v5)
  {
    unint64_t v6 = (unint64_t)v12;
    CFNumberRef v12 = v5;
    unint64_t valuePtr = v6;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v7 = v12;
  CFNumberRef v11 = v12;
  CFNumberRef v12 = 0;
  sub_1000570E8((const void **)&v12);
  uint64_t v8 = 0;
  if (v7) {
    int v9 = sub_100081E58;
  }
  else {
    int v9 = 0;
  }
  if (a2 && v9) {
    uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t, CFNumberRef))(*(void *)*a1 + 24))(*a1, kCommCenterSharedSettingsBundleId, a2, v7);
  }
  sub_1000570E8((const void **)&v11);
  return v8;
}

void sub_1011DDF18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011DDF38(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()]) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 24);

  return v3();
}

const void **sub_1011DDFD0@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  CFDictionaryRef theDict = 0;
  if ((a2 - 1) <= 1
    && *((void *)&kSuppServicesCLIRNetworkStatusKeys + subscriber::simSlotAsInstance()))
  {
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 64) + 16))(&v22);
  }
  else
  {
    char v22 = 0;
  }
  sub_10004EFE4(&theDict, &v22);
  sub_1000577C4(&v22);
  if (theDict) {
    CFNumberRef v5 = sub_100080778;
  }
  else {
    CFNumberRef v5 = 0;
  }
  if (v5)
  {
    int Value = (unsigned int *)CFDictionaryGetValue(theDict, kServiceStatusKey);
    CFNumberRef v7 = Value;
    LODWORD(v22) = 0;
    if (Value && (CFTypeID v8 = CFGetTypeID(Value), v8 == CFNumberGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)&v22, v7, v9);
      char v10 = (char)v22;
    }
    else
    {
      char v10 = 0;
    }
    CFNumberRef v11 = (unsigned int *)CFDictionaryGetValue(theDict, kProvisionStatusKey);
    CFNumberRef v12 = v11;
    LODWORD(v22) = 0;
    if (v11 && (CFTypeID v13 = CFGetTypeID(v11), v13 == CFNumberGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)&v22, v12, v14);
      char v15 = (char)v22;
    }
    else
    {
      char v15 = 0;
    }
    *a3 = 0;
    a3[1] = 0;
    uint64_t v16 = (char *)operator new(0x38uLL);
    *((void *)v16 + 1) = 0;
    *((void *)v16 + 2) = 0;
    *(void *)uint64_t v16 = off_101A7DF08;
    *(void *)(v16 + 26) = 0;
    *(void *)(v16 + 42) = 0;
    *(void *)(v16 + 34) = 0;
    *((void *)v16 + 6) = 0;
    v16[24] = v10;
    *a3 = v16 + 24;
    a3[1] = v16;
    v16[25] = v15;
    CFDictionaryGetValue(theDict, kOperatorBundleIDKey);
    char v22 = 0;
    long long v23 = 0uLL;
    ctu::cf::assign();
    long long v17 = v22;
    v24[0] = v23;
    *(void *)((char *)v24 + 7) = *(void *)((char *)&v23 + 7);
    char v18 = HIBYTE(v23);
    if (v16[55] < 0) {
      operator delete(*((void **)v16 + 4));
    }
    uint64_t v19 = v24[0];
    *((void *)v16 + 4) = v17;
    *((void *)v16 + 5) = v19;
    *(void *)(v16 + 47) = *(void *)((char *)v24 + 7);
    v16[55] = v18;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_1011DE228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t sub_1011DE280(uint64_t a1, int a2, unsigned __int8 **a3)
{
  CFNumberRef v7 = *a3;
  unint64_t v6 = (std::__shared_weak_count *)a3[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v31 = Mutable;
  uint64_t v9 = *v7;
  __p[0] = 0;
  *(void *)&long long valuePtr = v9;
  CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v11 = (const void *)kServiceStatusKey;
  if (v10)
  {
    CFNumberRef v12 = __p[0];
    __p[0] = v10;
    *(void *)&long long valuePtr = v12;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFTypeID v13 = __p[0];
  char v38 = __p[0];
  __p[0] = 0;
  sub_1000570E8((const void **)__p);
  CFDictionarySetValue(Mutable, v11, v13);
  sub_1000570E8((const void **)&v38);
  uint64_t v14 = v7[1];
  __p[0] = 0;
  *(void *)&long long valuePtr = v14;
  CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  uint64_t v16 = (const void *)kProvisionStatusKey;
  if (v15)
  {
    long long v17 = __p[0];
    __p[0] = v15;
    *(void *)&long long valuePtr = v17;
    sub_1000570E8((const void **)&valuePtr);
  }
  char v18 = __p[0];
  char v38 = __p[0];
  __p[0] = 0;
  sub_1000570E8((const void **)__p);
  CFDictionarySetValue(Mutable, v16, v18);
  sub_1000570E8((const void **)&v38);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v19 = v31;
  uint64_t v20 = *a3;
  if ((char)(*a3)[31] < 0)
  {
    sub_10004FC84(v28, *((void **)v20 + 1), *((void *)v20 + 2));
  }
  else
  {
    long long v21 = *(_OWORD *)(v20 + 8);
    uint64_t v29 = *((void *)v20 + 3);
    *(_OWORD *)uint64_t v28 = v21;
  }
  if (SHIBYTE(v29) < 0)
  {
    sub_10004FC84(__p, v28[0], (unint64_t)v28[1]);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v28;
    uint64_t v34 = v29;
  }
  uint64_t v32 = 0;
  if (SHIBYTE(v34) < 0)
  {
    sub_10004FC84(&valuePtr, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long valuePtr = *(_OWORD *)__p;
    uint64_t v36 = v34;
  }
  long long v37 = 0;
  if (ctu::cf::convert_copy())
  {
    char v22 = v32;
    uint64_t v32 = v37;
    char v38 = v22;
    sub_1000558F4((const void **)&v38);
  }
  long long v23 = (const void *)kOperatorBundleIDKey;
  if (SHIBYTE(v36) < 0) {
    operator delete((void *)valuePtr);
  }
  char v24 = v32;
  uint64_t v30 = v32;
  uint64_t v32 = 0;
  sub_1000558F4((const void **)&v32);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p[0]);
  }
  CFDictionarySetValue(v19, v23, v24);
  sub_1000558F4(&v30);
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if ((a2 - 1) <= 1
    && (uint64_t v25 = kSuppServicesCLIRNetworkStatusKeys[subscriber::simSlotAsInstance()]) != 0)
  {
    uint64_t v26 = (*(uint64_t (**)(void, void, uint64_t, __CFDictionary *))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), kCommCenterSharedSettingsBundleId, v25, v31);
  }
  else
  {
    uint64_t v26 = 0;
  }
  sub_10005717C((const void **)&v31);
  return v26;
}

void sub_1011DE594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a17);
  _Unwind_Resume(a1);
}

void sub_1011DE644()
{
  if (!v0) {
    JUMPOUT(0x1011DE63CLL);
  }
  JUMPOUT(0x1011DE634);
}

uint64_t sub_1011DE650(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesCLIRNetworkStatusKeys[subscriber::simSlotAsInstance()]) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 24);

  return v3();
}

uint64_t sub_1011DE6E8(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_1011DE744(a1 + 64, v3);
}

uint64_t sub_1011DE744(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if (a2)
  {
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)a1 + 16))(&cf);
    uint64_t v2 = (void *)cf;
  }
  else
  {
    uint64_t v2 = 0;
    CFTypeRef cf = 0;
  }
  if (v2) {
    uint64_t v3 = sub_100080934;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!v3) {
    goto LABEL_13;
  }
  unsigned __int8 v8 = 0;
  if (!v2)
  {
LABEL_14:
    unsigned __int8 v6 = 0;
    goto LABEL_15;
  }
  CFTypeID v4 = CFGetTypeID(v2);
  if (v4 != CFBooleanGetTypeID())
  {
LABEL_13:
    LODWORD(v2) = 0;
    goto LABEL_14;
  }
  LODWORD(v2) = ctu::cf::assign((ctu::cf *)&v8, (BOOL *)v2, v5);
  if (v2) {
    unsigned __int8 v6 = v8;
  }
  else {
    unsigned __int8 v6 = 0;
  }
LABEL_15:
  sub_1000577C4(&cf);
  return v6 | (v2 << 8);
}

void sub_1011DE830(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011DE844(uint64_t a1, int a2, int a3)
{
  if ((a2 - 1) > 1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_1011DE8A8((void *)(a1 + 64), v5, a3);
}

uint64_t sub_1011DE8A8(void *a1, uint64_t a2, int a3)
{
  uint64_t v5 = &kCFBooleanTrue;
  if (!a3) {
    uint64_t v5 = &kCFBooleanFalse;
  }
  CFBooleanRef v6 = *v5;
  CFNumberRef v11 = 0;
  sub_100062778(&v11);
  CFBooleanRef v10 = v6;
  CFNumberRef v11 = 0;
  sub_100062778(&v11);
  uint64_t v7 = 0;
  if (v6) {
    unsigned __int8 v8 = sub_100084B4C;
  }
  else {
    unsigned __int8 v8 = 0;
  }
  if (a2 && v8) {
    uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t, CFBooleanRef))(*(void *)*a1 + 24))(*a1, kCommCenterSharedSettingsBundleId, a2, v6);
  }
  sub_100062778((const void **)&v10);
  return v7;
}

void sub_1011DE980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_1011DE994(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()]) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 24);

  return v3();
}

uint64_t sub_1011DEA2C(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_1011DE744(a1 + 64, v3);
}

uint64_t sub_1011DEA88(uint64_t a1, int a2, int a3)
{
  if ((a2 - 1) > 1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()];
  }

  return sub_1011DE8A8((void *)(a1 + 64), v5, a3);
}

uint64_t sub_1011DEAEC(uint64_t a1, int a2)
{
  if ((a2 - 1) > 1 || !kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()]) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 24);

  return v3();
}

uint64_t sub_1011DEB84(uint64_t a1)
{
  unsigned int v2 = subscriber::simSlotAsInstance();
  uint64_t v3 = kUserDefaultVoiceSlotKey;

  return sub_1011DDE2C((void *)(a1 + 64), v3, v2);
}

unint64_t sub_1011DEBD0(uint64_t a1)
{
  unint64_t v1 = sub_1011DDCA8(a1 + 64, kUserDefaultVoiceSlotKey);
  if (HIDWORD(v1)) {
    return subscriber::instanceAsSimSlot((subscriber *)v1, v2) | (unint64_t)&_mh_execute_header;
  }
  else {
    return 0;
  }
}

uint64_t sub_1011DEC14()
{
  return 1;
}

void sub_1011DEC1C(uint64_t a1, char *a2)
{
  CFTypeID v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *(char **)a2;
    }
    LODWORD(__p[0]) = 136446210;
    *(void **)((char *)__p + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [: === :] %{public}s [: === :]", (uint8_t *)__p, 0xCu);
  }
  CFBooleanRef v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 48);
      uint64_t v10 = *(void *)(a1 + 64);
    }
    uint64_t v7 = __p;
    if (v10 < 0) {
      uint64_t v7 = (void **)__p[0];
    }
    *(_DWORD *)id buf = 136380675;
    CFNumberRef v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [:destination   :] %{private}s", buf, 0xCu);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
  }
  unsigned __int8 v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [: === :] [: === :] [: === :]", (uint8_t *)__p, 2u);
  }
}

void sub_1011DEE30(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __s[0] = 0;
  __s[1] = 0;
  uint64_t v10 = 0;
  uint64_t v4 = a1 + 48;
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v4;
    uint64_t v8 = *(void *)(a1 + 64);
  }
  sub_100CC7114(__s, (uint64_t)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  if (!sub_100CC7F88(__s))
  {
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(v5, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      *(_OWORD *)uint64_t v5 = *(_OWORD *)v4;
      uint64_t v6 = *(void *)(v4 + 16);
    }
    sub_100CC7114(__p, (uint64_t)v5);
    sub_100CC7BC4();
  }
  if (SHIBYTE(v10) < 0)
  {
    sub_10004FC84((unsigned char *)a2, __s[0], (unint64_t)__s[1]);
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)__s;
    *(void *)(a2 + 16) = v10;
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__s[0]);
  }
}

void sub_1011DEF5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011DEFC4(uint64_t a1)
{
  sub_100B18808(a1);

  operator delete();
}

void sub_1011DEFFC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1011DF1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v12 + 8);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011DF220@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)a1);
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v15);
  if (!v9)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    CFNumberRef v11 = 0;
    char v12 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v9[3];
  CFNumberRef v11 = (std::__shared_weak_count *)v9[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v12 = 0;
  if (v10) {
LABEL_10:
  }
    (*(void (**)(uint64_t, void, void))(*(void *)v10 + 1248))(v10, *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 16));
LABEL_11:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  CFTypeID v13 = *(std::__shared_weak_count **)(a1 + 8);
  if (v13) {
    sub_10004D2C8(v13);
  }
  return a1;
}

void sub_1011DF358(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011DF390@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_1011DF220(result, a2);
    operator delete();
  }
  return result;
}

uint64_t sub_1011DF3D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1011DF41C(uint64_t *a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_1011DF220(result, a1);
    operator delete();
  }
  return result;
}

double sub_1011DF46C(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(_OWORD *)long long __dst = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
  }
  if (*((unsigned char *)a2 + 48))
  {
    if (*((char *)a2 + 47) < 0)
    {
      sub_10004FC84(&v6, *((void **)a2 + 3), *((void *)a2 + 4));
    }
    else
    {
      long long v6 = *(long long *)((char *)a2 + 24);
      uint64_t v7 = *((void *)a2 + 5);
    }
    *(void *)&long long v4 = v6;
    *(_OWORD *)(__dst + 24) = v6;
    *((void *)__dst + 5) = v7;
    __dst[48] = 1;
  }
  else
  {
    uint8_t __dst[24] = 0;
    __dst[48] = 0;
  }
  return *(double *)&v4;
}

void sub_1011DF51C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011DF538@<X0>(_DWORD *a1@<X0>, int *a2@<X8>)
{
  if (*a1 == 1) {
    int v2 = 0;
  }
  else {
    int v2 = -1;
  }
  if (*a1 == 2) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  *a2 = v3;
  uint64_t v4 = a1[56];
  if (v4 == -1) {
    sub_1011E1F9C();
  }
  uint64_t v7 = &v6;
  return ((uint64_t (*)(char **, _DWORD *))off_101A9E018[v4])(&v7, a1 + 2);
}

void sub_1011DF5A0(void *a1@<X0>, uint64_t a2@<X8>)
{
  bzero((void *)a2, 0x2B0uLL);
  v225 = a1;
  if (*((unsigned char *)a1 + 264))
  {
    if (*((unsigned char *)a1 + 96))
    {
      if (*((char *)a1 + 23) < 0)
      {
        sub_10004FC84(__dst, (void *)*a1, a1[1]);
      }
      else
      {
        __dst[0] = *(__n128 *)a1;
        __dst[1].n128_u64[0] = a1[2];
      }
      if (*((char *)a1 + 47) < 0)
      {
        sub_10004FC84(&__dst[1].n128_u8[8], (void *)a1[3], a1[4]);
      }
      else
      {
        *(__n128 *)((char *)&__dst[1] + 8) = *(__n128 *)(a1 + 3);
        __dst[2].n128_u64[1] = a1[5];
      }
      if (*((char *)a1 + 71) < 0)
      {
        sub_10004FC84(&v254, (void *)a1[6], a1[7]);
      }
      else
      {
        long long v254 = *((_OWORD *)a1 + 3);
        uint64_t v255 = a1[8];
      }
      int64x2_t v256 = 0uLL;
      v257[0] = 0;
      uint64_t v3 = a1[10] - a1[9];
      if (v3)
      {
        unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 3);
        if (v4 > 0x666666666666666) {
          sub_1001F7A28();
        }
        v227[1] = v257;
        unint64_t v5 = (char *)sub_10005ED10((uint64_t)v257, v4);
        v226[0] = v5;
        v226[1] = v5;
        uint64_t v7 = &v5[40 * v6];
        v226[2] = v5;
        v227[0] = v7;
        int64x2_t v8 = v256;
        if (v256.i64[1] == v256.i64[0])
        {
          int64x2_t v14 = vdupq_n_s64(v256.u64[1]);
          unint64_t v15 = v5;
        }
        else
        {
          uint64_t v9 = 0;
          do
          {
            uint64_t v10 = &v5[v9];
            v5[v9 - 40] = 0;
            uint64_t v11 = v8.i64[1] + v9;
            v5[v9 - 16] = 0;
            if (*(unsigned char *)(v8.i64[1] + v9 - 16))
            {
              char v12 = (void *)(v11 - 40);
              long long v13 = *(_OWORD *)(v11 - 40);
              *(void *)&v5[v9 - 24] = *(void *)(v11 - 24);
              *(_OWORD *)&v5[v9 - 40] = v13;
              v12[1] = 0;
              v12[2] = 0;
              *char v12 = 0;
              *(v10 - 16) = 1;
            }
            *((void *)v10 - 1) = *(void *)(v11 - 8);
            v9 -= 40;
          }
          while (v8.i64[1] + v9 != v8.i64[0]);
          int64x2_t v14 = v256;
          unint64_t v15 = &v5[v9];
          unint64_t v5 = (char *)v226[2];
          uint64_t v7 = (char *)v227[0];
        }
        v256.i64[0] = (uint64_t)v15;
        v256.i64[1] = (uint64_t)v5;
        *(int64x2_t *)&v226[1] = v14;
        uint64_t v16 = (void *)v257[0];
        v257[0] = v7;
        v227[0] = v16;
        v226[0] = (void *)v14.i64[0];
        sub_1011E33E8((uint64_t)v226);
        uint64_t v18 = a1[9];
        for (uint64_t i = a1[10]; v18 != i; v18 += 40)
        {
          sub_1000593FC((uint64_t)__p, (long long *)v18);
          int32x2_t v19 = *(int32x2_t *)(v18 + 32);
          int8x8_t v20 = vmvn_s8((int8x8_t)vceq_s32(v19, (int32x2_t)0x100000001));
          int32x2_t v21 = vceq_s32(v19, (int32x2_t)0x200000002);
          v260 = (void **)vsub_s32((int32x2_t)vbic_s8(v20, (int8x8_t)v21), v21);
          uint64_t v22 = v256.i64[1];
          if (v256.i64[1] >= v257[0])
          {
            unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((v256.i64[1] - v256.i64[0]) >> 3);
            unint64_t v26 = v25 + 1;
            if (v25 + 1 > 0x666666666666666) {
              sub_1001F7A28();
            }
            if (0x999999999999999ALL * ((v257[0] - v256.i64[0]) >> 3) > v26) {
              unint64_t v26 = 0x999999999999999ALL * ((v257[0] - v256.i64[0]) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((v257[0] - v256.i64[0]) >> 3) >= 0x333333333333333) {
              unint64_t v27 = 0x666666666666666;
            }
            else {
              unint64_t v27 = v26;
            }
            v227[1] = v257;
            if (v27) {
              uint64_t v28 = (char *)sub_10005ED10((uint64_t)v257, v27);
            }
            else {
              uint64_t v28 = 0;
            }
            uint64_t v29 = &v28[40 * v25];
            v226[0] = v28;
            v226[1] = v29;
            v227[0] = &v28[40 * v27];
            *uint64_t v29 = 0;
            v29[24] = 0;
            if ((_BYTE)v259)
            {
              long long v30 = *(_OWORD *)__p;
              *((void **)v29 + 2) = __p[2];
              *(_OWORD *)uint64_t v29 = v30;
              memset(__p, 0, sizeof(__p));
              v29[24] = 1;
            }
            *(void *)&v28[40 * v25 + 32] = v260;
            char v24 = v29 + 40;
            v226[2] = v29 + 40;
            int64x2_t v31 = v256;
            uint64_t v32 = (char *)v226[1];
            if (v256.i64[1] == v256.i64[0])
            {
              int64x2_t v38 = vdupq_n_s64(v256.u64[1]);
            }
            else
            {
              uint64_t v33 = 0;
              do
              {
                uint64_t v34 = &v32[v33];
                v32[v33 - 40] = 0;
                uint64_t v35 = v31.i64[1] + v33;
                v32[v33 - 16] = 0;
                if (*(unsigned char *)(v31.i64[1] + v33 - 16))
                {
                  uint64_t v36 = (void *)(v35 - 40);
                  long long v37 = *(_OWORD *)(v35 - 40);
                  *(void *)&v32[v33 - 24] = *(void *)(v35 - 24);
                  *(_OWORD *)&v32[v33 - 40] = v37;
                  v36[1] = 0;
                  v36[2] = 0;
                  *uint64_t v36 = 0;
                  *(v34 - 16) = 1;
                }
                *((void *)v34 - 1) = *(void *)(v35 - 8);
                v33 -= 40;
              }
              while (v31.i64[1] + v33 != v31.i64[0]);
              int64x2_t v38 = v256;
              char v24 = v226[2];
              v32 += v33;
            }
            v256.i64[0] = (uint64_t)v32;
            v256.i64[1] = (uint64_t)v24;
            *(int64x2_t *)&v226[1] = v38;
            id v39 = (void *)v257[0];
            v257[0] = v227[0];
            v227[0] = v39;
            v226[0] = (void *)v38.i64[0];
            sub_1011E33E8((uint64_t)v226);
          }
          else
          {
            *(unsigned char *)v256.i64[1] = 0;
            *(unsigned char *)(v22 + 24) = 0;
            if ((_BYTE)v259)
            {
              long long v23 = *(_OWORD *)__p;
              *(void **)(v22 + 16) = __p[2];
              *(_OWORD *)uint64_t v22 = v23;
              memset(__p, 0, sizeof(__p));
              *(unsigned char *)(v22 + 24) = 1;
            }
            *(void *)(v22 + 32) = v260;
            char v24 = (void *)(v22 + 40);
          }
          v256.i64[1] = (uint64_t)v24;
          if ((_BYTE)v259 && SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      v226[2] = (void *)__dst[1].n128_u64[0];
      unint64_t v228 = __dst[2].n128_u64[1];
      *(__n128 *)v226 = __dst[0];
      memset(__dst, 0, sizeof(__dst));
      *(__n128 *)v227 = *(__n128 *)((char *)&__dst[1] + 8);
      uint64_t v230 = v255;
      long long v229 = v254;
      uint64_t v255 = 0;
      long long v254 = 0uLL;
      int64x2_t v231 = v256;
      uint64_t v232 = v257[0];
      int64x2_t v256 = 0uLL;
      v257[0] = 0;
      char v233 = 1;
      __p[0] = &v256;
      sub_1001F7B70((void ***)__p);
      if (SHIBYTE(v255) < 0) {
        operator delete((void *)v254);
      }
      if (__dst[2].n128_i8[15] < 0) {
        operator delete((void *)__dst[1].n128_u64[1]);
      }
      if (__dst[1].n128_i8[7] < 0) {
        operator delete((void *)__dst[0].n128_u64[0]);
      }
    }
    else
    {
      LOBYTE(v226[0]) = 0;
      char v233 = 0;
    }
    char v40 = *((unsigned char *)a1 + 128);
    if (v40)
    {
      v250[0] = 0;
      v250[1] = 0;
      v251 = 0;
      uint64_t v41 = a1[14] - a1[13];
      if (v41)
      {
        unint64_t v42 = 0x8E38E38E38E38E39 * (v41 >> 3);
        if (v42 > 0x333333333333333) {
          sub_1001F7A28();
        }
        __dst[2].n128_u64[0] = (unint64_t)&v251;
        long long v43 = sub_1001F7E24((uint64_t)&v251, v42);
        __dst[0].n128_u64[0] = (unint64_t)v43;
        __dst[0].n128_u64[1] = (unint64_t)v43;
        unint64_t v45 = (unint64_t)&v43[20 * v44];
        __dst[1].n128_u64[0] = (unint64_t)v43;
        __dst[1].n128_u64[1] = v45;
        CFUserNotificationRef v47 = (char *)v250[0];
        uint64_t v46 = (char *)v250[1];
        if (v250[1] == v250[0])
        {
          __n128 v50 = (__n128)vdupq_n_s64((unint64_t)v250[1]);
          uint64_t v48 = v43;
        }
        else
        {
          uint64_t v48 = v43;
          do
          {
            int v49 = *((_DWORD *)v46 - 20);
            v46 -= 80;
            *(v48 - 20) = v49;
            v48 -= 20;
            sub_1011E3454((uint64_t)(v48 + 2), (long long *)(v46 + 8));
            v48[18] = *((_DWORD *)v46 + 18);
          }
          while (v46 != v47);
          __n128 v50 = *(__n128 *)v250;
          unint64_t v45 = __dst[1].n128_u64[1];
          long long v43 = (_DWORD *)__dst[1].n128_u64[0];
        }
        v250[0] = v48;
        v250[1] = v43;
        *(__n128 *)((char *)__dst + 8) = v50;
        unint64_t v51 = (unint64_t)v251;
        v251 = (char *)v45;
        __dst[1].n128_u64[1] = v51;
        __dst[0].n128_u64[0] = v50.n128_u64[0];
        sub_1011E34C4((uint64_t)__dst);
        uint64_t v52 = a1[13];
        for (uint64_t j = a1[14]; v52 != j; v52 += 72)
        {
          if (*(_DWORD *)v52) {
            unsigned __int32 v54 = 0;
          }
          else {
            unsigned __int32 v54 = -1;
          }
          __dst[0].n128_u32[0] = v54;
          if (*(char *)(v52 + 31) < 0)
          {
            sub_10004FC84(__p, *(void **)(v52 + 8), *(void *)(v52 + 16));
          }
          else
          {
            long long v55 = *(_OWORD *)(v52 + 8);
            __p[2] = *(void **)(v52 + 24);
            *(_OWORD *)long long __p = v55;
          }
          char v56 = __p[0];
          v277.n128_u64[0] = (unint64_t)__p[1];
          *(unint64_t *)((char *)v277.n128_u64 + 7) = *(unint64_t *)((char *)&__p[1] + 7);
          unsigned __int8 v57 = HIBYTE(__p[2]);
          char v58 = *(unsigned char *)(v52 + 56);
          if (v58)
          {
            int v59 = *(char *)(v52 + 55);
            if (v59 >= 0) {
              int v60 = (char *)(v52 + 32);
            }
            else {
              int v60 = *(char **)(v52 + 32);
            }
            if (v59 >= 0) {
              size_t v61 = *(unsigned __int8 *)(v52 + 55);
            }
            else {
              size_t v61 = *(void *)(v52 + 40);
            }
            memset(__p, 0, sizeof(__p));
            sub_10012C7D0((char *)__p, v60, &v60[v61], v61);
            __dst[0].n128_u64[1] = (unint64_t)v56;
            __dst[1].n128_u64[0] = v277.n128_u64[0];
            *(unint64_t *)((char *)__dst[1].n128_u64 + 7) = *(unint64_t *)((char *)v277.n128_u64 + 7);
            __dst[1].n128_u8[15] = v57;
            __dst[2] = *(__n128 *)__p;
            *(void **)&long long v254 = __p[2];
            char v58 = 1;
          }
          else
          {
            __dst[0].n128_u64[1] = (unint64_t)__p[0];
            __dst[1].n128_u64[0] = v277.n128_u64[0];
            *(unint64_t *)((char *)__dst[1].n128_u64 + 7) = *(unint64_t *)((char *)v277.n128_u64 + 7);
            __dst[1].n128_u8[15] = HIBYTE(__p[2]);
            __dst[2].n128_u8[0] = 0;
          }
          BYTE8(v254) = v58;
          LOBYTE(v255) = 1;
          int v62 = *(_DWORD *)(v52 + 64);
          if (v62 == 1) {
            int v63 = 0;
          }
          else {
            int v63 = -1;
          }
          if (v62 == 2) {
            int v64 = 1;
          }
          else {
            int v64 = v63;
          }
          v256.i32[0] = v64;
          int v65 = (char *)v250[1];
          if (v250[1] >= v251)
          {
            unint64_t v68 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v250[1] - (char *)v250[0]) >> 4);
            unint64_t v69 = v68 + 1;
            if (v68 + 1 > 0x333333333333333) {
              sub_1001F7A28();
            }
            if (0x999999999999999ALL * ((v251 - (char *)v250[0]) >> 4) > v69) {
              unint64_t v69 = 0x999999999999999ALL * ((v251 - (char *)v250[0]) >> 4);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((v251 - (char *)v250[0]) >> 4) >= 0x199999999999999) {
              unint64_t v70 = 0x333333333333333;
            }
            else {
              unint64_t v70 = v69;
            }
            v260 = (void **)&v251;
            id v71 = (char *)sub_1001F7E24((uint64_t)&v251, v70);
            long long v72 = &v71[80 * v68];
            __p[0] = v71;
            __p[1] = v72;
            v259 = &v71[80 * v73];
            *(_DWORD *)long long v72 = __dst[0].n128_u32[0];
            v72[8] = 0;
            v72[64] = 0;
            if ((_BYTE)v255)
            {
              long long v74 = *(long long *)((char *)__dst + 8);
              *((void *)v72 + 3) = __dst[1].n128_u64[1];
              *(_OWORD *)(v72 + 8) = v74;
              memset(&__dst[0].n128_i8[8], 0, 24);
              v72[32] = 0;
              v72[56] = 0;
              if (BYTE8(v254))
              {
                *((void *)v72 + 4) = 0;
                *((void *)v72 + 5) = 0;
                *((void *)v72 + 6) = 0;
                *((__n128 *)v72 + 2) = __dst[2];
                *((void *)v72 + 6) = v254;
                __dst[2] = 0uLL;
                *(void *)&long long v254 = 0;
                v72[56] = 1;
              }
              v72[64] = 1;
            }
            *(_DWORD *)&v71[80 * v68 + 72] = v256.i32[0];
            CFStringRef v67 = v72 + 80;
            __p[2] = v72 + 80;
            uint64_t v75 = (char *)v250[0];
            uint64_t v76 = (char *)v250[1];
            uint64_t v77 = __p[1];
            if (v250[1] == v250[0])
            {
              int64x2_t v79 = vdupq_n_s64((unint64_t)v250[1]);
            }
            else
            {
              do
              {
                int v78 = *((_DWORD *)v76 - 20);
                v76 -= 80;
                *(v77 - 20) = v78;
                v77 -= 20;
                sub_1011E3454((uint64_t)(v77 + 2), (long long *)(v76 + 8));
                v77[18] = *((_DWORD *)v76 + 18);
              }
              while (v76 != v75);
              int64x2_t v79 = *(int64x2_t *)v250;
              CFStringRef v67 = __p[2];
            }
            v250[0] = v77;
            v250[1] = v67;
            *(int64x2_t *)&__p[1] = v79;
            long long v80 = v251;
            v251 = v259;
            v259 = v80;
            __p[0] = (void *)v79.i64[0];
            sub_1011E34C4((uint64_t)__p);
          }
          else
          {
            *(_DWORD *)v250[1] = __dst[0].n128_u32[0];
            v65[8] = 0;
            v65[64] = 0;
            if ((_BYTE)v255)
            {
              long long v66 = *(long long *)((char *)__dst + 8);
              *((void *)v65 + 3) = __dst[1].n128_u64[1];
              *(_OWORD *)(v65 + 8) = v66;
              memset(&__dst[0].n128_i8[8], 0, 24);
              v65[32] = 0;
              v65[56] = 0;
              if (BYTE8(v254))
              {
                *((void *)v65 + 4) = 0;
                *((void *)v65 + 5) = 0;
                *((void *)v65 + 6) = 0;
                *((__n128 *)v65 + 2) = __dst[2];
                *((void *)v65 + 6) = v254;
                __dst[2] = 0uLL;
                *(void *)&long long v254 = 0;
                v65[56] = 1;
              }
              v65[64] = 1;
            }
            *((_DWORD *)v65 + 18) = v256.i32[0];
            CFStringRef v67 = v65 + 80;
          }
          v250[1] = v67;
          sub_1001F807C((uint64_t)&__dst[0].n128_i64[1]);
        }
      }
      long long v234 = *(_OWORD *)v250;
      v235 = v251;
      v250[1] = 0;
      v251 = 0;
      v250[0] = 0;
      __dst[0].n128_u64[0] = (unint64_t)v250;
      sub_1001F80D0((void ***)__dst);
      char v40 = 1;
      a1 = v225;
    }
    else
    {
      LOBYTE(v234) = 0;
    }
    char v236 = v40;
    char v81 = *((unsigned char *)a1 + 160);
    if (v81)
    {
      v250[0] = 0;
      v250[1] = 0;
      v251 = 0;
      uint64_t v82 = a1[18] - a1[17];
      if (v82)
      {
        if (v82 < 0) {
          sub_1001F7A28();
        }
        __dst[2].n128_u64[0] = (unint64_t)&v251;
        uint64_t v83 = (char *)sub_10005ED10((uint64_t)&v251, v82 >> 5);
        __dst[0].n128_u64[0] = (unint64_t)v83;
        __dst[0].n128_u64[1] = (unint64_t)v83;
        unint64_t v85 = (unint64_t)&v83[40 * v84];
        __dst[1].n128_u64[0] = (unint64_t)v83;
        __dst[1].n128_u64[1] = v85;
        long long v87 = (char *)v250[0];
        long long v86 = (char *)v250[1];
        if (v250[1] == v250[0])
        {
          __n128 v93 = (__n128)vdupq_n_s64((unint64_t)v250[1]);
          long long v94 = v83;
        }
        else
        {
          uint64_t v88 = 0;
          do
          {
            uint64_t v89 = &v83[v88];
            v83[v88 - 40] = 0;
            xpc_object_t v90 = &v86[v88];
            v83[v88 - 16] = 0;
            if (v86[v88 - 16])
            {
              xpc_object_t v91 = v90 - 40;
              long long v92 = *(_OWORD *)(v90 - 40);
              *(void *)&v83[v88 - 24] = *((void *)v90 - 3);
              *(_OWORD *)&v83[v88 - 40] = v92;
              *((void *)v91 + 1) = 0;
              *((void *)v91 + 2) = 0;
              *(void *)xpc_object_t v91 = 0;
              *(v89 - 16) = 1;
            }
            *((_DWORD *)v89 - 2) = *((_DWORD *)v90 - 2);
            v88 -= 40;
          }
          while (&v86[v88] != v87);
          __n128 v93 = *(__n128 *)v250;
          long long v94 = &v83[v88];
          unint64_t v85 = __dst[1].n128_u64[1];
          uint64_t v83 = (char *)__dst[1].n128_u64[0];
        }
        v250[0] = v94;
        v250[1] = v83;
        *(__n128 *)((char *)__dst + 8) = v93;
        unint64_t v95 = (unint64_t)v251;
        v251 = (char *)v85;
        __dst[1].n128_u64[1] = v95;
        __dst[0].n128_u64[0] = v93.n128_u64[0];
        sub_1011E33E8((uint64_t)__dst);
        char v96 = (long long *)v225[17];
        for (k = (long long *)v225[18]; v96 != k; v96 += 2)
        {
          if (*((char *)v96 + 23) < 0)
          {
            sub_10004FC84(__p, *(void **)v96, *((void *)v96 + 1));
          }
          else
          {
            long long v98 = *v96;
            __p[2] = *((void **)v96 + 2);
            *(_OWORD *)long long __p = v98;
          }
          LOBYTE(v259) = 1;
          if (*((_DWORD *)v96 + 6)) {
            int v99 = 0;
          }
          else {
            int v99 = -1;
          }
          LODWORD(v260) = v99;
          long long v100 = (void **)v250[1];
          if (v250[1] >= v251)
          {
            unint64_t v103 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v250[1] - (char *)v250[0]) >> 3);
            unint64_t v104 = v103 + 1;
            if (v103 + 1 > 0x666666666666666) {
              sub_1001F7A28();
            }
            if (0x999999999999999ALL * ((v251 - (char *)v250[0]) >> 3) > v104) {
              unint64_t v104 = 0x999999999999999ALL * ((v251 - (char *)v250[0]) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((v251 - (char *)v250[0]) >> 3) >= 0x333333333333333) {
              unint64_t v105 = 0x666666666666666;
            }
            else {
              unint64_t v105 = v104;
            }
            __dst[2].n128_u64[0] = (unint64_t)&v251;
            if (v105) {
              xpc_object_t v106 = sub_10005ED10((uint64_t)&v251, v105);
            }
            else {
              xpc_object_t v106 = 0;
            }
            unint64_t v107 = (unint64_t)&v106[10 * v103];
            __dst[0].n128_u64[0] = (unint64_t)v106;
            __dst[0].n128_u64[1] = v107;
            __dst[1].n128_u64[1] = (unint64_t)&v106[10 * v105];
            *(unsigned char *)unint64_t v107 = 0;
            *(unsigned char *)(v107 + 24) = 0;
            if ((_BYTE)v259)
            {
              long long v108 = *(_OWORD *)__p;
              *(void **)(v107 + 16) = __p[2];
              *(_OWORD *)unint64_t v107 = v108;
              memset(__p, 0, sizeof(__p));
              *(unsigned char *)(v107 + 24) = 1;
            }
            v106[10 * v103 + 8] = v260;
            long long v102 = (void *)(v107 + 40);
            __dst[1].n128_u64[0] = v107 + 40;
            xpc_object_t v110 = (char *)v250[0];
            xpc_object_t v109 = (char *)v250[1];
            uint64_t v111 = (char *)__dst[0].n128_u64[1];
            if (v250[1] == v250[0])
            {
              __n128 v117 = (__n128)vdupq_n_s64((unint64_t)v250[1]);
            }
            else
            {
              uint64_t v112 = 0;
              do
              {
                int v113 = &v111[v112];
                v111[v112 - 40] = 0;
                int v114 = &v109[v112];
                v111[v112 - 16] = 0;
                if (v109[v112 - 16])
                {
                  xpc_object_t v115 = v114 - 40;
                  long long v116 = *(_OWORD *)(v114 - 40);
                  *(void *)&v111[v112 - 24] = *((void *)v114 - 3);
                  *(_OWORD *)&v111[v112 - 40] = v116;
                  *((void *)v115 + 1) = 0;
                  *((void *)v115 + 2) = 0;
                  *(void *)xpc_object_t v115 = 0;
                  *(v113 - 16) = 1;
                }
                *((_DWORD *)v113 - 2) = *((_DWORD *)v114 - 2);
                v112 -= 40;
              }
              while (&v109[v112] != v110);
              __n128 v117 = *(__n128 *)v250;
              long long v102 = (void *)__dst[1].n128_u64[0];
              v111 += v112;
            }
            v250[0] = v111;
            v250[1] = v102;
            *(__n128 *)((char *)__dst + 8) = v117;
            unint64_t v118 = (unint64_t)v251;
            v251 = (char *)__dst[1].n128_u64[1];
            __dst[1].n128_u64[1] = v118;
            __dst[0].n128_u64[0] = v117.n128_u64[0];
            sub_1011E33E8((uint64_t)__dst);
          }
          else
          {
            *(unsigned char *)v250[1] = 0;
            *((unsigned char *)v100 + 24) = 0;
            if ((_BYTE)v259)
            {
              long long v101 = *(_OWORD *)__p;
              v100[2] = __p[2];
              *(_OWORD *)long long v100 = v101;
              memset(__p, 0, sizeof(__p));
              *((unsigned char *)v100 + 24) = 1;
            }
            *((_DWORD *)v100 + 8) = v260;
            long long v102 = v100 + 5;
          }
          v250[1] = v102;
          if ((_BYTE)v259 && SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      long long v237 = *(_OWORD *)v250;
      v238 = v251;
      v250[1] = 0;
      v251 = 0;
      v250[0] = 0;
      __dst[0].n128_u64[0] = (unint64_t)v250;
      sub_1001F7B70((void ***)__dst);
      char v81 = 1;
      a1 = v225;
    }
    else
    {
      LOBYTE(v237) = 0;
    }
    char v239 = v81;
    sub_1000593FC((uint64_t)v250, (long long *)(a1 + 21));
    LOBYTE(v240) = 0;
    char v242 = 0;
    if (v252)
    {
      long long v240 = *(_OWORD *)v250;
      v241 = v251;
      v250[1] = 0;
      v251 = 0;
      v250[0] = 0;
      char v242 = 1;
    }
    char v243 = 1;
    if (*((unsigned char *)a1 + 224))
    {
      memset(__dst, 0, 24);
      sub_1000302C0((char *)__dst, (long long *)a1[25], (long long *)a1[26], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[26] - a1[25]) >> 3));
      __n128 v244 = __dst[0];
      unint64_t v245 = __dst[1].n128_u64[0];
      memset(__dst, 0, 24);
      __p[0] = __dst;
      sub_100047F64((void ***)__p);
      char v119 = 1;
    }
    else
    {
      char v119 = 0;
      v244.n128_u8[0] = 0;
    }
    char v246 = v119;
    char v120 = *((unsigned char *)a1 + 256);
    if (v120)
    {
      __n128 v277 = 0uLL;
      v278 = 0;
      uint64_t v121 = a1[30] - a1[29];
      if (v121)
      {
        unint64_t v122 = 0xAAAAAAAAAAAAAAABLL * (v121 >> 4);
        if (v122 > 0x555555555555555) {
          sub_1001F7A28();
        }
        __dst[2].n128_u64[0] = (unint64_t)&v278;
        long long v123 = (char *)sub_10019F624((uint64_t)&v278, v122);
        unint64_t v125 = v277.n128_u64[1];
        unint64_t v126 = v277.n128_u64[0];
        if (v277.n128_u64[1] == v277.n128_u64[0])
        {
          __n128 v130 = (__n128)vdupq_n_s64(v277.n128_u64[1]);
          uint64_t v127 = v123;
        }
        else
        {
          uint64_t v127 = v123;
          do
          {
            long long v128 = *(_OWORD *)(v125 - 48);
            *((void *)v127 - 4) = *(void *)(v125 - 32);
            *((_OWORD *)v127 - 3) = v128;
            *(void *)(v125 - 40) = 0;
            *(void *)(v125 - 32) = 0;
            *(void *)(v125 - 48) = 0;
            long long v129 = *(_OWORD *)(v125 - 24);
            *((void *)v127 - 1) = *(void *)(v125 - 8);
            *(_OWORD *)(v127 - 24) = v129;
            v127 -= 48;
            *(void *)(v125 - 16) = 0;
            *(void *)(v125 - 8) = 0;
            *(void *)(v125 - 24) = 0;
            v125 -= 48;
          }
          while (v125 != v126);
          __n128 v130 = v277;
        }
        v277.n128_u64[0] = (unint64_t)v127;
        v277.n128_u64[1] = (unint64_t)v123;
        *(__n128 *)((char *)__dst + 8) = v130;
        unint64_t v131 = (unint64_t)v278;
        v278 = &v123[48 * v124];
        __dst[1].n128_u64[1] = v131;
        __dst[0].n128_u64[0] = v130.n128_u64[0];
        sub_100296F50((uint64_t)__dst);
        uint64_t v133 = v225[29];
        for (uint64_t m = v225[30]; v133 != m; v133 += 48)
        {
          if (*(char *)(v133 + 23) < 0)
          {
            sub_10004FC84(__dst, *(void **)v133, *(void *)(v133 + 8));
          }
          else
          {
            __n128 v134 = *(__n128 *)v133;
            __dst[1].n128_u64[0] = *(void *)(v133 + 16);
            __dst[0] = v134;
          }
          if (*(char *)(v133 + 47) < 0)
          {
            sub_10004FC84(&__dst[1].n128_u8[8], *(void **)(v133 + 24), *(void *)(v133 + 32));
          }
          else
          {
            __n128 v135 = *(__n128 *)(v133 + 24);
            __dst[2].n128_u64[1] = *(void *)(v133 + 40);
            *(__n128 *)((char *)&__dst[1] + 8) = v135;
          }
          unint64_t v136 = v277.n128_u64[1];
          if (v277.n128_u64[1] >= (unint64_t)v278)
          {
            unint64_t v139 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v277.n128_u64[1] - v277.n128_u64[0]) >> 4);
            unint64_t v140 = v139 + 1;
            if (v139 + 1 > 0x555555555555555) {
              sub_1001F7A28();
            }
            if (0x5555555555555556 * ((uint64_t)&v278[-v277.n128_u64[0]] >> 4) > v140) {
              unint64_t v140 = 0x5555555555555556 * ((uint64_t)&v278[-v277.n128_u64[0]] >> 4);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v278[-v277.n128_u64[0]] >> 4) >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v141 = 0x555555555555555;
            }
            else {
              unint64_t v141 = v140;
            }
            v260 = (void **)&v278;
            if (v141) {
              long long v142 = (char *)sub_10019F624((uint64_t)&v278, v141);
            }
            else {
              long long v142 = 0;
            }
            uint64_t v143 = &v142[48 * v139];
            __n128 v144 = __dst[0];
            *((void *)v143 + 2) = __dst[1].n128_u64[0];
            *(__n128 *)uint64_t v143 = v144;
            memset(__dst, 0, 24);
            long long v145 = *(long long *)((char *)&__dst[1] + 8);
            *((void *)v143 + 5) = __dst[2].n128_u64[1];
            *(_OWORD *)(v143 + 24) = v145;
            memset(&__dst[1].n128_i8[8], 0, 24);
            unint64_t v146 = v277.n128_u64[1];
            unint64_t v147 = v277.n128_u64[0];
            if (v277.n128_u64[1] == v277.n128_u64[0])
            {
              int64x2_t v151 = vdupq_n_s64(v277.n128_u64[1]);
              long long v148 = &v142[48 * v139];
            }
            else
            {
              long long v148 = &v142[48 * v139];
              do
              {
                long long v149 = *(_OWORD *)(v146 - 48);
                *((void *)v148 - 4) = *(void *)(v146 - 32);
                *((_OWORD *)v148 - 3) = v149;
                *(void *)(v146 - 40) = 0;
                *(void *)(v146 - 32) = 0;
                *(void *)(v146 - 48) = 0;
                long long v150 = *(_OWORD *)(v146 - 24);
                *((void *)v148 - 1) = *(void *)(v146 - 8);
                *(_OWORD *)(v148 - 24) = v150;
                v148 -= 48;
                *(void *)(v146 - 16) = 0;
                *(void *)(v146 - 8) = 0;
                *(void *)(v146 - 24) = 0;
                v146 -= 48;
              }
              while (v146 != v147);
              int64x2_t v151 = (int64x2_t)v277;
            }
            v152 = v143 + 48;
            v277.n128_u64[0] = (unint64_t)v148;
            v277.n128_u64[1] = (unint64_t)(v143 + 48);
            *(int64x2_t *)&__p[1] = v151;
            v153 = v278;
            v278 = &v142[48 * v141];
            v259 = v153;
            __p[0] = (void *)v151.i64[0];
            sub_100296F50((uint64_t)__p);
            v277.n128_u64[1] = (unint64_t)v152;
            if (__dst[2].n128_i8[15] < 0) {
              operator delete((void *)__dst[1].n128_u64[1]);
            }
          }
          else
          {
            __n128 v137 = __dst[0];
            *(void *)(v277.n128_u64[1] + 16) = __dst[1].n128_u64[0];
            *(__n128 *)unint64_t v136 = v137;
            memset(__dst, 0, 24);
            unint64_t v138 = __dst[2].n128_u64[1];
            *(__n128 *)(v136 + 24) = *(__n128 *)((char *)&__dst[1] + 8);
            *(void *)(v136 + 40) = v138;
            memset(&__dst[1].n128_i8[8], 0, 24);
            v277.n128_u64[1] = v136 + 48;
          }
          if (__dst[1].n128_i8[7] < 0) {
            operator delete((void *)__dst[0].n128_u64[0]);
          }
        }
      }
      __n128 v247 = v277;
      v248 = v278;
      v278 = 0;
      __n128 v277 = 0uLL;
      __dst[0].n128_u64[0] = (unint64_t)&v277;
      sub_100155410((void ***)__dst);
      char v120 = 1;
    }
    else
    {
      v247.n128_u8[0] = 0;
    }
    char v249 = v120;
    if (v252 && SHIBYTE(v251) < 0) {
      operator delete(v250[0]);
    }
    sub_10045B4BC(v261, (uint64_t)v226);
    char v265 = 1;
    if (v249)
    {
      __dst[0].n128_u64[0] = (unint64_t)&v247;
      sub_100155410((void ***)__dst);
    }
    a1 = v225;
    if (v246)
    {
      __dst[0].n128_u64[0] = (unint64_t)&v244;
      sub_100047F64((void ***)__dst);
    }
    if (v243 && v242 && SHIBYTE(v241) < 0) {
      operator delete((void *)v240);
    }
    if (v239)
    {
      __dst[0].n128_u64[0] = (unint64_t)&v237;
      sub_1001F7B70((void ***)__dst);
    }
    if (v236)
    {
      __dst[0].n128_u64[0] = (unint64_t)&v234;
      sub_1001F80D0((void ***)__dst);
    }
    sub_1001F7C24((uint64_t)v226);
  }
  else
  {
    v261[0] = 0;
    char v265 = 0;
  }
  sub_1000593FC((uint64_t)&v266, (long long *)a1 + 17);
  sub_1000593FC((uint64_t)&v267, (long long *)a1 + 19);
  sub_1000593FC((uint64_t)&v268, (long long *)a1 + 21);
  sub_1000593FC((uint64_t)&v269, (long long *)a1 + 23);
  sub_1000593FC((uint64_t)&v270, (long long *)a1 + 25);
  sub_1000593FC((uint64_t)&v271, (long long *)a1 + 27);
  sub_1000593FC((uint64_t)&v272, (long long *)a1 + 29);
  sub_1000593FC((uint64_t)&v273, (long long *)a1 + 31);
  char v154 = *((unsigned char *)a1 + 552);
  if (v154)
  {
    memset(__p, 0, sizeof(__p));
    uint64_t v155 = a1[67] - a1[66];
    if (v155)
    {
      unint64_t v156 = 0xAAAAAAAAAAAAAAABLL * (v155 >> 4);
      if (v156 > 0x555555555555555) {
        sub_1001F7A28();
      }
      v227[1] = &__p[2];
      v157 = (char *)sub_10019F624((uint64_t)&__p[2], v156);
      v160 = (char *)__p[0];
      v159 = (char *)__p[1];
      if (__p[1] == __p[0])
      {
        int64x2_t v164 = vdupq_n_s64((unint64_t)__p[1]);
        v161 = v157;
      }
      else
      {
        v161 = v157;
        do
        {
          long long v162 = *((_OWORD *)v159 - 3);
          *((void *)v161 - 4) = *((void *)v159 - 4);
          *((_OWORD *)v161 - 3) = v162;
          *((void *)v159 - 5) = 0;
          *((void *)v159 - 4) = 0;
          *((void *)v159 - 6) = 0;
          long long v163 = *(_OWORD *)(v159 - 24);
          *((void *)v161 - 1) = *((void *)v159 - 1);
          *(_OWORD *)(v161 - 24) = v163;
          v161 -= 48;
          *((void *)v159 - 2) = 0;
          *((void *)v159 - 1) = 0;
          *((void *)v159 - 3) = 0;
          v159 -= 48;
        }
        while (v159 != v160);
        int64x2_t v164 = *(int64x2_t *)__p;
      }
      __p[0] = v161;
      __p[1] = v157;
      *(int64x2_t *)&v226[1] = v164;
      v165 = __p[2];
      __p[2] = &v157[48 * v158];
      v227[0] = v165;
      v226[0] = (void *)v164.i64[0];
      sub_100296F50((uint64_t)v226);
      v166 = (long long *)v225[66];
      for (n = (long long *)v225[67]; v166 != n; v166 += 3)
      {
        if (*((char *)v166 + 23) < 0)
        {
          sub_10004FC84(v226, *(void **)v166, *((void *)v166 + 1));
        }
        else
        {
          long long v168 = *v166;
          v226[2] = *((void **)v166 + 2);
          *(_OWORD *)v226 = v168;
        }
        if (*((char *)v166 + 47) < 0)
        {
          sub_10004FC84(v227, *((void **)v166 + 3), *((void *)v166 + 4));
        }
        else
        {
          long long v169 = *(long long *)((char *)v166 + 24);
          unint64_t v228 = *((void *)v166 + 5);
          *(_OWORD *)v227 = v169;
        }
        v170 = (char *)__p[1];
        if (__p[1] >= __p[2])
        {
          unint64_t v173 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 4);
          unint64_t v174 = v173 + 1;
          if (v173 + 1 > 0x555555555555555) {
            sub_1001F7A28();
          }
          if (0x5555555555555556 * (((char *)__p[2] - (char *)__p[0]) >> 4) > v174) {
            unint64_t v174 = 0x5555555555555556 * (((char *)__p[2] - (char *)__p[0]) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * (((char *)__p[2] - (char *)__p[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v175 = 0x555555555555555;
          }
          else {
            unint64_t v175 = v174;
          }
          __dst[2].n128_u64[0] = (unint64_t)&__p[2];
          if (v175) {
            v176 = (char *)sub_10019F624((uint64_t)&__p[2], v175);
          }
          else {
            v176 = 0;
          }
          v177 = &v176[48 * v173];
          long long v178 = *(_OWORD *)v226;
          *((void **)v177 + 2) = v226[2];
          *(_OWORD *)v177 = v178;
          memset(v226, 0, sizeof(v226));
          long long v179 = *(_OWORD *)v227;
          *((void *)v177 + 5) = v228;
          *(_OWORD *)(v177 + 24) = v179;
          v227[1] = 0;
          unint64_t v228 = 0;
          v227[0] = 0;
          v181 = (char *)__p[0];
          v180 = (char *)__p[1];
          if (__p[1] == __p[0])
          {
            __n128 v185 = (__n128)vdupq_n_s64((unint64_t)__p[1]);
            v182 = &v176[48 * v173];
          }
          else
          {
            v182 = &v176[48 * v173];
            do
            {
              long long v183 = *((_OWORD *)v180 - 3);
              *((void *)v182 - 4) = *((void *)v180 - 4);
              *((_OWORD *)v182 - 3) = v183;
              *((void *)v180 - 5) = 0;
              *((void *)v180 - 4) = 0;
              *((void *)v180 - 6) = 0;
              long long v184 = *(_OWORD *)(v180 - 24);
              *((void *)v182 - 1) = *((void *)v180 - 1);
              *(_OWORD *)(v182 - 24) = v184;
              v182 -= 48;
              *((void *)v180 - 2) = 0;
              *((void *)v180 - 1) = 0;
              *((void *)v180 - 3) = 0;
              v180 -= 48;
            }
            while (v180 != v181);
            __n128 v185 = *(__n128 *)__p;
          }
          v186 = v177 + 48;
          __p[0] = v182;
          __p[1] = v177 + 48;
          *(__n128 *)((char *)__dst + 8) = v185;
          v187 = __p[2];
          __p[2] = &v176[48 * v175];
          __dst[1].n128_u64[1] = (unint64_t)v187;
          __dst[0].n128_u64[0] = v185.n128_u64[0];
          sub_100296F50((uint64_t)__dst);
          __p[1] = v186;
          if (SHIBYTE(v228) < 0) {
            operator delete(v227[0]);
          }
        }
        else
        {
          long long v171 = *(_OWORD *)v226;
          *((void **)__p[1] + 2) = v226[2];
          *(_OWORD *)v170 = v171;
          memset(v226, 0, sizeof(v226));
          unint64_t v172 = v228;
          *(_OWORD *)(v170 + 24) = *(_OWORD *)v227;
          *((void *)v170 + 5) = v172;
          v227[1] = 0;
          unint64_t v228 = 0;
          v227[0] = 0;
          __p[1] = v170 + 48;
        }
        if (SHIBYTE(v226[2]) < 0) {
          operator delete(v226[0]);
        }
      }
    }
    long long v274 = *(_OWORD *)__p;
    v275 = __p[2];
    memset(__p, 0, sizeof(__p));
    v226[0] = __p;
    sub_100155410((void ***)v226);
    char v154 = 1;
    a1 = v225;
  }
  else
  {
    LOBYTE(v274) = 0;
  }
  char v276 = v154;
  sub_10045AFC4((unsigned char *)a2, (uint64_t)v261);
  sub_1001F9FD8((uint64_t)v261);
  unsigned __int8 v188 = *((unsigned char *)a1 + 584);
  if (v188)
  {
    memset(__p, 0, sizeof(__p));
    uint64_t v189 = a1[71] - a1[70];
    if (v189)
    {
      unint64_t v190 = 0xEF7BDEF7BDEF7BDFLL * (v189 >> 3);
      if (v190 > 0x108421084210842) {
        sub_1001F7A28();
      }
      *(void *)&long long v263 = &__p[2];
      v191 = (char *)sub_1001F8B58((uint64_t)&__p[2], v190);
      *(void *)v261 = v191;
      *(void *)&v261[8] = v191;
      v193 = &v191[248 * v192];
      *(void *)&v261[16] = v191;
      v262 = v193;
      v195 = (char *)__p[0];
      v194 = (char *)__p[1];
      if (__p[1] == __p[0])
      {
        int64x2_t v198 = vdupq_n_s64((unint64_t)__p[1]);
        v196 = v191;
      }
      else
      {
        v196 = v191;
        do
        {
          int v197 = *((_DWORD *)v194 - 62);
          v194 -= 248;
          *((_DWORD *)v196 - 62) = v197;
          v196 -= 248;
          sub_1011E3678((uint64_t)(v196 + 8), (uint64_t)(v194 + 8));
        }
        while (v194 != v195);
        int64x2_t v198 = *(int64x2_t *)__p;
        v191 = *(char **)&v261[16];
        v193 = v262;
      }
      __p[0] = v196;
      __p[1] = v191;
      *(int64x2_t *)&v261[8] = v198;
      v199 = (char *)__p[2];
      __p[2] = v193;
      v262 = v199;
      *(void *)v261 = v198.i64[0];
      sub_1011E3730((uint64_t)v261);
      v200 = (_DWORD *)v225[70];
      for (iuint64_t i = (_DWORD *)v225[71]; v200 != ii; v200 += 62)
      {
        if (*v200 == 1) {
          int v202 = 0;
        }
        else {
          int v202 = -1;
        }
        if (*v200 == 2) {
          int v203 = 1;
        }
        else {
          int v203 = v202;
        }
        *(_DWORD *)v261 = v203;
        uint64_t v204 = v200[60];
        if (v204 == -1) {
          sub_1011E1F9C();
        }
        v226[0] = &v277;
        ((void (*)(unsigned char *__return_ptr, void **, _DWORD *))off_101A9E038[v204])(&v261[8], v226, v200 + 2);
        v205 = (char *)__p[1];
        if (__p[1] >= __p[2])
        {
          unint64_t v207 = 0xEF7BDEF7BDEF7BDFLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
          unint64_t v208 = v207 + 1;
          if (v207 + 1 > 0x108421084210842) {
            sub_1001F7A28();
          }
          if (0xDEF7BDEF7BDEF7BELL * (((char *)__p[2] - (char *)__p[0]) >> 3) > v208) {
            unint64_t v208 = 0xDEF7BDEF7BDEF7BELL * (((char *)__p[2] - (char *)__p[0]) >> 3);
          }
          if (0xEF7BDEF7BDEF7BDFLL * (((char *)__p[2] - (char *)__p[0]) >> 3) >= 0x84210842108421) {
            unint64_t v209 = 0x108421084210842;
          }
          else {
            unint64_t v209 = v208;
          }
          v227[1] = &__p[2];
          if (v209) {
            v210 = (char *)sub_1001F8B58((uint64_t)&__p[2], v209);
          }
          else {
            v210 = 0;
          }
          v211 = &v210[248 * v207];
          v226[0] = v210;
          v226[1] = v211;
          v227[0] = &v210[248 * v209];
          uint64_t v212 = (uint64_t)(v211 + 8);
          *(_DWORD *)v211 = *(_DWORD *)v261;
          v206 = v211 + 248;
          sub_1011E3678(v212, (uint64_t)&v261[8]);
          v226[2] = v206;
          v214 = (char *)__p[0];
          v213 = (char *)__p[1];
          v215 = (char *)v226[1];
          if (__p[1] == __p[0])
          {
            int64x2_t v217 = vdupq_n_s64((unint64_t)__p[1]);
          }
          else
          {
            do
            {
              int v216 = *((_DWORD *)v213 - 62);
              v213 -= 248;
              *((_DWORD *)v215 - 62) = v216;
              v215 -= 248;
              sub_1011E3678((uint64_t)(v215 + 8), (uint64_t)(v213 + 8));
            }
            while (v213 != v214);
            int64x2_t v217 = *(int64x2_t *)__p;
            v206 = v226[2];
          }
          __p[0] = v215;
          __p[1] = v206;
          *(int64x2_t *)&v226[1] = v217;
          v218 = __p[2];
          __p[2] = v227[0];
          v227[0] = v218;
          v226[0] = (void *)v217.i64[0];
          sub_1011E3730((uint64_t)v226);
        }
        else
        {
          *(_DWORD *)__p[1] = *(_DWORD *)v261;
          v206 = v205 + 248;
          sub_1011E3678((uint64_t)(v205 + 8), (uint64_t)&v261[8]);
        }
        __p[1] = v206;
        sub_1001F9EA0((uint64_t)&v261[8]);
      }
    }
    __dst[0] = *(__n128 *)__p;
    __dst[1].n128_u64[0] = (unint64_t)__p[2];
    memset(__p, 0, sizeof(__p));
    *(void *)v261 = __p;
    sub_1001F9EFC((void ***)v261);
    unsigned __int8 v188 = 1;
    a1 = v225;
  }
  else
  {
    __dst[0].n128_u8[0] = 0;
  }
  __dst[1].n128_u8[8] = v188;
  sub_10045B6CC(a2 + 568, __dst);
  if (__dst[1].n128_u8[8])
  {
    *(void *)v261 = __dst;
    sub_1001F9EFC((void ***)v261);
  }
  v261[0] = *((unsigned char *)a1 + 592);
  if (*((char *)a1 + 623) < 0)
  {
    sub_10004FC84(&v261[8], (void *)a1[75], a1[76]);
  }
  else
  {
    *(_OWORD *)&v261[8] = *(_OWORD *)(a1 + 75);
    v262 = (char *)a1[77];
  }
  if (*((char *)a1 + 647) < 0)
  {
    sub_10004FC84(&v263, (void *)a1[78], a1[79]);
  }
  else
  {
    long long v263 = *((_OWORD *)a1 + 39);
    uint64_t v264 = a1[80];
  }
  uint64_t v219 = a2;
  v220 = (void **)(a2 + 608);
  *(unsigned char *)(a2 + 600) = v261[0];
  if (*(char *)(a2 + 631) < 0)
  {
    operator delete(*v220);
    uint64_t v219 = a2;
  }
  uint64_t v221 = v219 + 632;
  *(_OWORD *)v220 = *(_OWORD *)&v261[8];
  *(void *)(a2 + 624) = v262;
  HIBYTE(v262) = 0;
  v261[8] = 0;
  if (*(char *)(v219 + 655) < 0)
  {
    operator delete(*(void **)v221);
    int v222 = SHIBYTE(v262);
    *(_OWORD *)uint64_t v221 = v263;
    *(void *)(v221 + 16) = v264;
    HIBYTE(v264) = 0;
    LOBYTE(v263) = 0;
    if (v222 < 0) {
      operator delete(*(void **)&v261[8]);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v221 = v263;
    *(void *)(v219 + 648) = v264;
  }
  if (*((unsigned char *)a1 + 672))
  {
    if (*((char *)a1 + 671) < 0)
    {
      sub_10004FC84(v261, (void *)a1[81], a1[82]);
    }
    else
    {
      *(_OWORD *)v261 = *(_OWORD *)(a1 + 81);
      *(void *)&v261[16] = a1[83];
    }
    v223 = (void **)(a2 + 656);
    if (*(unsigned char *)(a2 + 680))
    {
      if (*(char *)(a2 + 679) < 0) {
        operator delete(*v223);
      }
      *(_OWORD *)v223 = *(_OWORD *)v261;
      *(void *)(a2 + 672) = *(void *)&v261[16];
    }
    else
    {
      *(_OWORD *)v223 = *(_OWORD *)v261;
      *(void *)(a2 + 672) = *(void *)&v261[16];
      *(unsigned char *)(a2 + 680) = 1;
    }
  }
}

void sub_1011E0FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a64 < 0) {
    operator delete(__p);
  }
  if (a58 < 0) {
    operator delete(a53);
  }
  sub_1011E1378(a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1011E1378(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 680) && *(char *)(a1 + 679) < 0) {
    operator delete(*(void **)(a1 + 656));
  }
  if (*(char *)(a1 + 655) < 0) {
    operator delete(*(void **)(a1 + 632));
  }
  if (*(char *)(a1 + 631) < 0) {
    operator delete(*(void **)(a1 + 608));
  }
  if (*(unsigned char *)(a1 + 592))
  {
    uint64_t v3 = (void **)(a1 + 568);
    sub_1001F9EFC(&v3);
  }
  return sub_1001F9FD8(a1);
}

uint64_t sub_1011E13F8@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t result = sub_1011E3784(a2, 0x34F72C234F72C235 * ((uint64_t)(a1[1] - *a1) >> 3));
  unint64_t v5 = (_DWORD *)*a1;
  uint64_t v6 = (_DWORD *)a1[1];
  if ((_DWORD *)*a1 != v6)
  {
    do
    {
      sub_1011DF538(v5, &v9);
      uint64_t v7 = (_DWORD *)a2[1];
      if ((unint64_t)v7 >= a2[2])
      {
        uint64_t v8 = sub_1011E38D8(a2, &v9);
      }
      else
      {
        *uint64_t v7 = v9;
        uint64_t v8 = (uint64_t)(v7 + 58);
        sub_1001FCBB0((uint64_t)(v7 + 2), (uint64_t)v10);
      }
      a2[1] = v8;
      uint64_t result = sub_10015551C((uint64_t)v10);
      v5 += 58;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_1011E1500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

int32x2_t sub_1011E152C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int32x2_t v3 = vceq_s32(*(int32x2_t *)a1, (int32x2_t)0x200000002);
  int32x2_t result = vsub_s32((int32x2_t)vbic_s8(vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)a1, (int32x2_t)0x100000001)), (int8x8_t)v3), v3);
  *(int32x2_t *)a2 = result;
  int v5 = *(unsigned __int8 *)(a1 + 11);
  if (*(unsigned char *)(a1 + 11)) {
    int v5 = *(unsigned __int16 *)(a1 + 8) | (*(unsigned __int8 *)(a1 + 10) << 16) | 0x1000000;
  }
  *(_DWORD *)(a2 + 8) = v5;
  int v6 = *(unsigned __int8 *)(a1 + 15);
  if (*(unsigned char *)(a1 + 15)) {
    int v6 = *(unsigned __int16 *)(a1 + 12) | (*(unsigned __int8 *)(a1 + 14) << 16) | 0x1000000;
  }
  *(_DWORD *)(a2 + 12) = v6;
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(&v7, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      long long v7 = *(_OWORD *)(a1 + 16);
      uint64_t v8 = *(void *)(a1 + 32);
    }
    int32x2_t result = (int32x2_t)v7;
    *(_OWORD *)(a2 + 16) = v7;
    *(void *)(a2 + 32) = v8;
    *(unsigned char *)(a2 + 40) = 1;
  }
  else
  {
    *(unsigned char *)(a2 + 16) = 0;
    *(unsigned char *)(a2 + 40) = 0;
  }
  return result;
}

void sub_1011E160C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_1011E17A4(a2, a1);
  if (*(unsigned char *)(a1 + 208))
  {
    if (*(char *)(a1 + 207) < 0)
    {
      sub_10004FC84(&v5, *(void **)(a1 + 184), *(void *)(a1 + 192));
    }
    else
    {
      long long v5 = *(_OWORD *)(a1 + 184);
      uint64_t v6 = *(void *)(a1 + 200);
    }
    *(_OWORD *)(a2 + 184) = v5;
    *(void *)(a2 + 200) = v6;
    *(unsigned char *)(a2 + 208) = 1;
  }
  else
  {
    *(unsigned char *)(a2 + 184) = 0;
    *(unsigned char *)(a2 + 208) = 0;
  }
  if (*(unsigned char *)(a1 + 240))
  {
    if (*(char *)(a1 + 239) < 0)
    {
      sub_10004FC84(&v5, *(void **)(a1 + 216), *(void *)(a1 + 224));
    }
    else
    {
      long long v5 = *(_OWORD *)(a1 + 216);
      uint64_t v6 = *(void *)(a1 + 232);
    }
    *(_OWORD *)(a2 + 216) = v5;
    *(void *)(a2 + 232) = v6;
    *(unsigned char *)(a2 + 240) = 1;
  }
  else
  {
    *(unsigned char *)(a2 + 216) = 0;
    *(unsigned char *)(a2 + 240) = 0;
  }
  char v4 = *(unsigned char *)(a1 + 272);
  if (v4)
  {
    sub_1011E13F8((void *)(a1 + 248), (uint64_t *)&v5);
    *(_OWORD *)(a2 + 248) = v5;
    *(void *)(a2 + 264) = v6;
    uint64_t v6 = 0;
    long long v5 = 0uLL;
    long long v7 = (void **)&v5;
    sub_100155494(&v7);
    char v4 = 1;
  }
  else
  {
    *(unsigned char *)(a2 + 248) = 0;
  }
  *(unsigned char *)(a2 + 272) = v4;
}

void sub_1011E1758(_Unwind_Exception *a1)
{
  if (v3)
  {
    if (*(char *)(v1 + 207) < 0) {
      operator delete(*v2);
    }
  }
  sub_1004563E8(v1);
  _Unwind_Resume(a1);
}

void sub_1011E17A4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 176))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v11, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
      uint64_t v12 = *(void *)(a2 + 16);
    }
    if (*(char *)(a2 + 47) < 0)
    {
      sub_10004FC84(&v13, *(void **)(a2 + 24), *(void *)(a2 + 32));
    }
    else
    {
      long long v13 = *(_OWORD *)(a2 + 24);
      uint64_t v14 = *(void *)(a2 + 40);
    }
    uint64_t v15 = *(void *)(a2 + 48);
    sub_1000593FC((uint64_t)&v16, (long long *)(a2 + 56));
    sub_1000593FC((uint64_t)&__p, (long long *)(a2 + 88));
    *(void *)&long long v22 = *(void *)(a2 + 120);
    BYTE8(v22) = *(unsigned char *)(a2 + 128);
    unsigned int v4 = *(_DWORD *)(a2 + 136) - 1;
    if (v4 >= 3) {
      unsigned int v4 = -1;
    }
    unsigned int v23 = v4;
    uint64_t v5 = sub_1000593FC((uint64_t)v24, (long long *)(a2 + 144));
    *(_OWORD *)a1 = *(_OWORD *)v11;
    uint64_t v6 = v15;
    *(void *)(a1 + 16) = v12;
    long long v7 = v13;
    uint64_t v8 = v14;
    long long v13 = 0uLL;
    uint64_t v14 = 0;
    v11[1] = 0;
    uint64_t v12 = 0;
    v11[0] = 0;
    *(_OWORD *)(a1 + 24) = v7;
    *(void *)(a1 + 40) = v8;
    *(void *)(a1 + 48) = v6;
    *(unsigned char *)(a1 + 56) = 0;
    *(unsigned char *)(a1 + 80) = 0;
    int v9 = v18;
    if (v18)
    {
      *(_OWORD *)(a1 + 56) = v16;
      *(void *)(a1 + 72) = v17;
      uint64_t v17 = 0;
      long long v16 = 0uLL;
      *(unsigned char *)(a1 + 80) = 1;
    }
    *(unsigned char *)(a1 + 88) = 0;
    *(unsigned char *)(a1 + 112) = 0;
    int v10 = v21;
    if (v21)
    {
      *(_OWORD *)(a1 + 88) = __p;
      *(void *)(a1 + 104) = v20;
      uint64_t v20 = 0;
      long long __p = 0uLL;
      *(unsigned char *)(a1 + 112) = 1;
    }
    *(unsigned char *)(a1 + 144) = 0;
    *(_OWORD *)(a1 + 120) = v22;
    *(_DWORD *)(a1 + 136) = v23;
    *(unsigned char *)(a1 + 168) = 0;
    if (v24[24])
    {
      *(_OWORD *)(a1 + 144) = *(_OWORD *)v5;
      *(void *)(a1 + 160) = *(void *)(v5 + 16);
      *(void *)(v5 + 8) = 0;
      *(void *)(v5 + 16) = 0;
      *(void *)uint64_t v5 = 0;
      *(unsigned char *)(a1 + 168) = 1;
    }
    *(unsigned char *)(a1 + 176) = 1;
    if (v10 && SHIBYTE(v20) < 0)
    {
      operator delete((void *)__p);
      int v9 = v18;
    }
    if (v9 && SHIBYTE(v17) < 0) {
      operator delete((void *)v16);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete((void *)v13);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[0]);
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 176) = 0;
  }
}

void sub_1011E19E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E1A5C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void sub_1011E1A90(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 40))
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
  }
  _Unwind_Resume(exception_object);
}

double sub_1011E1AB4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double result = NAN;
  *(void *)a2 = -1;
  if (*(_DWORD *)a1 == 1) {
    int v4 = 0;
  }
  else {
    int v4 = -1;
  }
  if (*(_DWORD *)a1 == 2) {
    int v5 = 1;
  }
  else {
    int v5 = v4;
  }
  *(_DWORD *)(a2 + 8) = v5;
  int v6 = *(unsigned __int8 *)(a1 + 7);
  if (*(unsigned char *)(a1 + 7)) {
    int v6 = *(unsigned __int16 *)(a1 + 4) | (*(unsigned __int8 *)(a1 + 6) << 16) | 0x1000000;
  }
  *(_DWORD *)(a2 + 12) = v6;
  int v7 = *(unsigned __int8 *)(a1 + 11);
  if (*(unsigned char *)(a1 + 11)) {
    int v7 = *(unsigned __int16 *)(a1 + 8) | (*(unsigned __int8 *)(a1 + 10) << 16) | 0x1000000;
  }
  *(_DWORD *)(a2 + 16) = v7;
  if (*(unsigned char *)(a1 + 40))
  {
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(&v8, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      long long v8 = *(_OWORD *)(a1 + 16);
      uint64_t v9 = *(void *)(a1 + 32);
    }
    double result = *(double *)&v8;
    *(_OWORD *)(a2 + 24) = v8;
    *(void *)(a2 + 40) = v9;
    *(unsigned char *)(a2 + 48) = 1;
  }
  else
  {
    *(unsigned char *)(a2 + 24) = 0;
    *(unsigned char *)(a2 + 48) = 0;
  }
  return result;
}

uint64_t *sub_1011E1B90@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  sub_1011E1AB4(a1, a2);
  double result = sub_1011E1BF0((uint64_t *)(a1 + 48), (uint64_t *)(a2 + 56));
  *(unsigned char *)(a2 + 80) = 0;
  *(unsigned char *)(a2 + 104) = 0;
  return result;
}

void sub_1011E1BCC(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 48))
  {
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1011E1BF0@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = (uint64_t)(a2 + 2);
  uint64_t v4 = *result;
  uint64_t v5 = result[1];
  if (v5 != *result)
  {
    unint64_t v6 = 0xAF8AF8AF8AF8AF8BLL * ((v5 - *result) >> 3);
    if (v6 > 0xEA0EA0EA0EA0EALL) {
      sub_100D65248();
    }
    int v7 = result;
    v21[4] = a2 + 2;
    v21[0] = sub_100D66934(v3, v6);
    v21[1] = v21[0];
    v21[2] = v21[0];
    void v21[3] = v21[0] + 280 * v8;
    sub_1011E39F8(a2, v21);
    double result = (uint64_t *)sub_1011E3B70((uint64_t)v21);
    uint64_t v4 = *v7;
    uint64_t v5 = v7[1];
  }
  for (; v4 != v5; v4 += 280)
  {
    sub_1011E17A4((uint64_t)v21, v4);
    if (*(unsigned char *)(v4 + 208))
    {
      if (*(char *)(v4 + 207) < 0)
      {
        sub_10004FC84(&__dst, *(void **)(v4 + 184), *(void *)(v4 + 192));
      }
      else
      {
        long long v9 = *(_OWORD *)(v4 + 184);
        uint64_t v33 = *(void *)(v4 + 200);
        long long __dst = v9;
      }
      long long v22 = __dst;
      uint64_t v23 = v33;
      char v24 = 1;
    }
    else
    {
      LOBYTE(v22) = 0;
      char v24 = 0;
    }
    if (*(unsigned char *)(v4 + 240))
    {
      if (*(char *)(v4 + 239) < 0)
      {
        sub_10004FC84(&__dst, *(void **)(v4 + 216), *(void *)(v4 + 224));
      }
      else
      {
        long long v10 = *(_OWORD *)(v4 + 216);
        uint64_t v33 = *(void *)(v4 + 232);
        long long __dst = v10;
      }
      long long __p = __dst;
      uint64_t v26 = v33;
      char v27 = 1;
    }
    else
    {
      LOBYTE(__p) = 0;
      char v27 = 0;
    }
    char v11 = *(unsigned char *)(v4 + 272);
    if (v11)
    {
      sub_1011E13F8((void *)(v4 + 248), (uint64_t *)&__dst);
      long long v28 = __dst;
      uint64_t v29 = v33;
      uint64_t v33 = 0;
      p_dst = (void **)&__dst;
      long long __dst = 0uLL;
      sub_100155494(&p_dst);
      char v11 = 1;
    }
    else
    {
      LOBYTE(v28) = 0;
    }
    char v30 = v11;
    unint64_t v12 = a2[1];
    unint64_t v13 = a2[2];
    if (v12 >= v13)
    {
      unint64_t v15 = 0xAF8AF8AF8AF8AF8BLL * ((uint64_t)(v12 - *a2) >> 3);
      unint64_t v16 = v15 + 1;
      if (v15 + 1 > 0xEA0EA0EA0EA0EALL) {
        sub_100D65248();
      }
      unint64_t v17 = 0xAF8AF8AF8AF8AF8BLL * ((uint64_t)(v13 - *a2) >> 3);
      if (2 * v17 > v16) {
        unint64_t v16 = 2 * v17;
      }
      if (v17 >= 0x75075075075075) {
        unint64_t v18 = 0xEA0EA0EA0EA0EALL;
      }
      else {
        unint64_t v18 = v16;
      }
      uint64_t v35 = v3;
      if (v18) {
        int32x2_t v19 = (char *)sub_100D66934(v3, v18);
      }
      else {
        int32x2_t v19 = 0;
      }
      uint64_t v20 = (uint64_t)&v19[280 * v15];
      *(void *)&long long __dst = v19;
      *((void *)&__dst + 1) = v20;
      uint64_t v34 = &v19[280 * v18];
      sub_1011E3A80(v20, (uint64_t)v21);
      uint64_t v33 = v20 + 280;
      sub_1011E39F8(a2, &__dst);
      uint64_t v14 = a2[1];
      sub_1011E3B70((uint64_t)&__dst);
    }
    else
    {
      uint64_t v14 = sub_1011E3A80(v12, (uint64_t)v21) + 280;
    }
    a2[1] = v14;
    if (v30)
    {
      *(void *)&long long __dst = &v28;
      sub_100155494((void ***)&__dst);
    }
    if (v27 && SHIBYTE(v26) < 0) {
      operator delete((void *)__p);
    }
    if (v24)
    {
      if (SHIBYTE(v23) < 0) {
        operator delete((void *)v22);
      }
    }
    double result = (uint64_t *)sub_1004563E8((uint64_t)v21);
  }
  return result;
}

void sub_1011E1F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  *(void *)(v45 - 136) = v44;
  sub_10045647C((void ***)(v45 - 136));
  _Unwind_Resume(a1);
}

void sub_1011E1F9C()
{
  exception = __cxa_allocate_exception(8uLL);
}

double sub_1011E1FEC@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  unsigned int v4 = *(_DWORD *)a1 - 1;
  if (v4 >= 3) {
    unsigned int v4 = -1;
  }
  unsigned int v6 = v4;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_10004FC84(&v7, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    long long v7 = *(_OWORD *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 24);
  }
  if (*(char *)(a1 + 55) < 0)
  {
    sub_10004FC84(&v9, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    long long v9 = *(_OWORD *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 48);
  }
  *(_DWORD *)(a2 + 8) = v6;
  *(_OWORD *)(a2 + 16) = v7;
  *(void *)(a2 + 32) = v8;
  double result = *(double *)&v9;
  *(_OWORD *)(a2 + 40) = v9;
  *(void *)(a2 + 56) = v10;
  *(_DWORD *)(a2 + 144) = 0;
  return result;
}

void sub_1011E20C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1011E20E4@<D0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(&v4, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    long long v4 = *a1;
    uint64_t v5 = *((void *)a1 + 2);
  }
  double result = *(double *)&v4;
  *(_OWORD *)(a2 + 8) = v4;
  *(void *)(a2 + 24) = v5;
  *(_DWORD *)(a2 + 144) = 1;
  return result;
}

double sub_1011E2150@<D0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(&v5, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    long long v5 = *a1;
    uint64_t v6 = *((void *)a1 + 2);
  }
  if (*((char *)a1 + 47) < 0)
  {
    sub_10004FC84(&v7, *((void **)a1 + 3), *((void *)a1 + 4));
  }
  else
  {
    long long v7 = *(long long *)((char *)a1 + 24);
    uint64_t v8 = *((void *)a1 + 5);
  }
  *(_OWORD *)(a2 + 8) = v5;
  *(void *)(a2 + 24) = v6;
  double result = *(double *)&v7;
  *(_OWORD *)(a2 + 32) = v7;
  *(void *)(a2 + 48) = v8;
  *(_DWORD *)(a2 + 144) = 2;
  return result;
}

void sub_1011E2208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1011E2224@<D0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(&v4, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    long long v4 = *a1;
    uint64_t v5 = *((void *)a1 + 2);
  }
  double result = *(double *)&v4;
  *(_OWORD *)(a2 + 8) = v4;
  *(void *)(a2 + 24) = v5;
  *(_DWORD *)(a2 + 144) = 3;
  return result;
}

double sub_1011E2290@<D0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(&v4, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    long long v4 = *a1;
    uint64_t v5 = *((void *)a1 + 2);
  }
  double result = *(double *)&v4;
  *(_OWORD *)(a2 + 8) = v4;
  *(void *)(a2 + 24) = v5;
  *(_DWORD *)(a2 + 144) = 4;
  return result;
}

void sub_1011E22FC(long long *a1@<X1>, uint64_t a2@<X8>)
{
  char v4 = *((unsigned char *)a1 + 16);
  if (v4)
  {
    long long v5 = *a1;
    char v4 = 1;
  }
  else
  {
    LOBYTE(v5) = 0;
  }
  char v6 = v4;
  if (*((unsigned char *)a1 + 48))
  {
    if (*((char *)a1 + 47) < 0)
    {
      sub_10004FC84(&__dst, *((void **)a1 + 3), *((void *)a1 + 4));
    }
    else
    {
      long long __dst = *(long long *)((char *)a1 + 24);
      uint64_t v18 = *((void *)a1 + 5);
    }
    long long v7 = __dst;
    uint64_t v8 = v18;
    char v9 = 1;
    char v10 = 1;
  }
  else
  {
    LOBYTE(v7) = 0;
    char v10 = 0;
  }
  sub_1000593FC((uint64_t)&v11, (long long *)((char *)a1 + 56));
  sub_1000593FC((uint64_t)&__p, (long long *)((char *)a1 + 88));
  sub_1001FBB94((__n128 *)(a2 + 8), (uint64_t)&v5);
  *(_DWORD *)(a2 + 144) = 5;
  if (v16 && v15 < 0) {
    operator delete(__p);
  }
  if (v13 && v12 < 0) {
    operator delete(v11);
  }
  if (v10 && v9 && SHIBYTE(v8) < 0) {
    operator delete((void *)v7);
  }
}

void sub_1011E2434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  if (a29 && a28 < 0) {
    operator delete(__p);
  }
  if ((_BYTE)a20 && a18 && a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E2480(unsigned char *a1@<X1>, uint64_t a2@<X8>)
{
  *(unsigned char *)(a2 + 8) = *a1;
  *(_DWORD *)(a2 + 144) = 6;
}

void sub_1011E2494(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(v4, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)char v4 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
  }
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(&v6, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a1 + 24);
    uint64_t v7 = *(void *)(a1 + 40);
  }
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(&v8, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    long long v8 = *(_OWORD *)(a1 + 48);
    uint64_t v9 = *(void *)(a1 + 64);
  }
  sub_1000593FC((uint64_t)&v10, (long long *)(a1 + 72));
  sub_1000593FC((uint64_t)&__p, (long long *)(a1 + 104));
  sub_1001FBE80(a2 + 8, (long long *)v4);
  *(_DWORD *)(a2 + 144) = 7;
  if (v15 && v14 < 0) {
    operator delete(__p);
  }
  if (v12 && v11 < 0) {
    operator delete(v10);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete((void *)v6);
  }
  if (SHIBYTE(v5) < 0) {
    operator delete(v4[0]);
  }
}

void sub_1011E25E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011E264C@<X0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(&v5, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    long long v5 = *a1;
    uint64_t v6 = *((void *)a1 + 2);
  }
  uint64_t result = sub_1000593FC((uint64_t)v7, (long long *)((char *)a1 + 24));
  *(unsigned char *)(a2 + 32) = 0;
  *(_OWORD *)(a2 + 8) = v5;
  *(void *)(a2 + 24) = v6;
  *(unsigned char *)(a2 + 56) = 0;
  if (v7[24])
  {
    *(_OWORD *)(a2 + 32) = *(_OWORD *)result;
    *(void *)(a2 + 48) = *(void *)(result + 16);
    *(unsigned char *)(a2 + 56) = 1;
  }
  *(_DWORD *)(a2 + 144) = 8;
  return result;
}

void sub_1011E26F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E2710(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a1;
    uint64_t v8 = *(void *)(a1 + 16);
  }
  sub_1000593FC((uint64_t)&__p, (long long *)(a1 + 24));
  uint64_t v4 = sub_1000593FC((uint64_t)v12, (long long *)(a1 + 56));
  long long v5 = *(_OWORD *)v7;
  *(unsigned char *)(a2 + 32) = 0;
  *(_OWORD *)(a2 + 8) = v5;
  *(void *)(a2 + 24) = v8;
  v7[1] = 0;
  uint64_t v8 = 0;
  v7[0] = 0;
  *(unsigned char *)(a2 + 56) = 0;
  int v6 = v11;
  if (v11)
  {
    *(_OWORD *)(a2 + 32) = __p;
    *(void *)(a2 + 48) = v10;
    uint64_t v10 = 0;
    long long __p = 0uLL;
    *(unsigned char *)(a2 + 56) = 1;
  }
  *(unsigned char *)(a2 + 64) = 0;
  *(unsigned char *)(a2 + 88) = 0;
  if (v12[24])
  {
    *(_OWORD *)(a2 + 64) = *(_OWORD *)v4;
    *(void *)(a2 + 80) = *(void *)(v4 + 16);
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    *(void *)uint64_t v4 = 0;
    *(unsigned char *)(a2 + 88) = 1;
  }
  *(_DWORD *)(a2 + 144) = 9;
  if (v6 && SHIBYTE(v10) < 0)
  {
    operator delete((void *)__p);
    if (SHIBYTE(v8) < 0) {
      operator delete(v7[0]);
    }
  }
}

void sub_1011E2838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a21 && a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011E2874@<X0>(long long *a1@<X1>, uint64_t a2@<X8>)
{
  if (*((char *)a1 + 23) < 0)
  {
    sub_10004FC84(&v5, *(void **)a1, *((void *)a1 + 1));
  }
  else
  {
    long long v5 = *a1;
    uint64_t v6 = *((void *)a1 + 2);
  }
  uint64_t result = sub_1000593FC((uint64_t)v7, (long long *)((char *)a1 + 24));
  *(unsigned char *)(a2 + 32) = 0;
  *(_OWORD *)(a2 + 8) = v5;
  *(void *)(a2 + 24) = v6;
  *(unsigned char *)(a2 + 56) = 0;
  if (v7[24])
  {
    *(_OWORD *)(a2 + 32) = *(_OWORD *)result;
    *(void *)(a2 + 48) = *(void *)(result + 16);
    *(unsigned char *)(a2 + 56) = 1;
  }
  *(_DWORD *)(a2 + 144) = 10;
  return result;
}

void sub_1011E291C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E2938(_DWORD *a1@<X1>, uint64_t a2@<X8>)
{
  if (*a1) {
    int v2 = 0;
  }
  else {
    int v2 = -1;
  }
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 144) = 11;
}

void sub_1011E2954(_DWORD *a1@<X1>, uint64_t a2@<X8>)
{
  if (*a1 == 1) {
    int v2 = 0;
  }
  else {
    int v2 = -1;
  }
  if (*a1 == 2) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  *(_DWORD *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 144) = 12;
}

void sub_1011E2978(_DWORD *a1@<X1>, uint64_t a2@<X8>)
{
  int v5 = *a1;
  uint64_t v4 = (long long *)(a1 + 2);
  int v6 = v5 - 1;
  if ((v5 - 1) >= 0xD) {
    int v6 = -1;
  }
  int v11 = v6;
  double v7 = sub_1011DF46C((char *)&v12, v4);
  uint64_t v8 = a1[52];
  if (v8 == -1) {
    sub_1011E1F9C();
  }
  uint64_t v10 = &v9;
  ((void (*)(uint64_t *__return_ptr, char **, _DWORD *, double))off_101A9DFB0[v8])(&v17, &v10, a1 + 18, v7);
  sub_1001FC6CC(a2, (uint64_t)&v11);
  *(_DWORD *)(a2 + 216) = 0;
  sub_100155640((uint64_t)&v18);
  if (v16 && v15 < 0) {
    operator delete(__p);
  }
  if (v13 < 0) {
    operator delete(v12);
  }
}

void sub_1011E2A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
}

void sub_1011E2AB0(long long *a1@<X1>, uint64_t a2@<X8>)
{
  sub_1011DF46C((char *)&__dst, a1);
  *(_OWORD *)a2 = __dst;
  *(void *)(a2 + 16) = v4;
  *(unsigned char *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 48) = 0;
  if (v7)
  {
    *(_OWORD *)(a2 + 24) = v5;
    *(void *)(a2 + 40) = v6;
    *(unsigned char *)(a2 + 48) = 1;
  }
  *(_DWORD *)(a2 + 216) = 1;
}

uint64_t sub_1011E2B24@<X0>(_DWORD *a1@<X1>, _DWORD *a2@<X8>)
{
  sub_1011DF538(a1, &v4);
  *a2 = v4;
  sub_1001FCBB0((uint64_t)(a2 + 2), (uint64_t)v5);
  a2[58] = 0;
  return sub_10015551C((uint64_t)v5);
}

void sub_1011E2BB8(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    uint64_t v32 = *(void *)(a1 + 16);
  }
  int64x2_t v33 = 0uLL;
  v34[0] = 0;
  uint64_t v3 = *(void *)(a1 + 32) - *(void *)(a1 + 24);
  if (v3)
  {
    unint64_t v4 = 0x34F72C234F72C235 * (v3 >> 3);
    if (v4 > 0x11A7B9611A7B961) {
      sub_1001F7A28();
    }
    unint64_t v42 = v34;
    long long v5 = (void **)sub_1001F9DC8((uint64_t)v34, v4);
    id v39 = v5;
    v40.i64[0] = (uint64_t)v5;
    char v7 = &v5[29 * v6];
    v40.i64[1] = (uint64_t)v5;
    uint64_t v41 = v7;
    uint64_t v8 = v33.i64[1];
    uint64_t v9 = v33.i64[0];
    if (v33.i64[1] == v33.i64[0])
    {
      int64x2_t v12 = vdupq_n_s64(v33.u64[1]);
      uint64_t v10 = v5;
    }
    else
    {
      uint64_t v10 = v5;
      do
      {
        int v11 = *(_DWORD *)(v8 - 232);
        v8 -= 232;
        *((_DWORD *)v10 - 58) = v11;
        v10 -= 29;
        sub_1001FCBB0((uint64_t)(v10 + 1), v8 + 8);
      }
      while (v8 != v9);
      int64x2_t v12 = v33;
      long long v5 = (void **)v40.i64[1];
      char v7 = v41;
    }
    v33.i64[0] = (uint64_t)v10;
    v33.i64[1] = (uint64_t)v5;
    int64x2_t v40 = v12;
    char v13 = (void **)v34[0];
    v34[0] = v7;
    uint64_t v41 = v13;
    id v39 = (void **)v12.i64[0];
    sub_1011E3518((uint64_t)&v39);
    char v14 = *(_DWORD **)(a1 + 24);
    for (uint64_t i = *(_DWORD **)(a1 + 32); v14 != i; v14 += 58)
    {
      sub_1011DF538(v14, (int *)&v39);
      uint64_t v16 = v33.i64[1];
      if (v33.i64[1] >= v34[0])
      {
        uint64_t v18 = 0x34F72C234F72C235 * ((v33.i64[1] - v33.i64[0]) >> 3);
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) > 0x11A7B9611A7B961) {
          sub_1001F7A28();
        }
        if (0x69EE58469EE5846ALL * ((v34[0] - v33.i64[0]) >> 3) > v19) {
          unint64_t v19 = 0x69EE58469EE5846ALL * ((v34[0] - v33.i64[0]) >> 3);
        }
        if ((unint64_t)(0x34F72C234F72C235 * ((v34[0] - v33.i64[0]) >> 3)) >= 0x8D3DCB08D3DCB0) {
          unint64_t v20 = 0x11A7B9611A7B961;
        }
        else {
          unint64_t v20 = v19;
        }
        int64x2_t v38 = v34;
        if (v20) {
          unsigned __int8 v21 = (char *)sub_1001F9DC8((uint64_t)v34, v20);
        }
        else {
          unsigned __int8 v21 = 0;
        }
        long long v22 = &v21[232 * v18];
        uint64_t v35 = v21;
        v36.i64[0] = (uint64_t)v22;
        long long v37 = &v21[232 * v20];
        uint64_t v23 = (uint64_t)(v22 + 8);
        *(_DWORD *)long long v22 = v39;
        uint64_t v17 = v22 + 232;
        sub_1001FCBB0(v23, (uint64_t)&v40);
        v36.i64[1] = (uint64_t)v17;
        uint64_t v25 = v33.i64[1];
        uint64_t v24 = v33.i64[0];
        uint64_t v26 = v36.i64[0];
        if (v33.i64[1] == v33.i64[0])
        {
          int64x2_t v28 = vdupq_n_s64(v33.u64[1]);
        }
        else
        {
          do
          {
            int v27 = *(_DWORD *)(v25 - 232);
            v25 -= 232;
            *(_DWORD *)(v26 - 232) = v27;
            v26 -= 232;
            sub_1001FCBB0(v26 + 8, v25 + 8);
          }
          while (v25 != v24);
          int64x2_t v28 = v33;
          uint64_t v17 = (_DWORD *)v36.i64[1];
        }
        v33.i64[0] = v26;
        v33.i64[1] = (uint64_t)v17;
        int64x2_t v36 = v28;
        uint64_t v29 = (char *)v34[0];
        v34[0] = v37;
        long long v37 = v29;
        uint64_t v35 = (char *)v28.i64[0];
        sub_1011E3518((uint64_t)&v35);
      }
      else
      {
        *(_DWORD *)v33.i64[1] = v39;
        uint64_t v17 = (_DWORD *)(v16 + 232);
        sub_1001FCBB0(v16 + 8, (uint64_t)&v40);
      }
      v33.i64[1] = (uint64_t)v17;
      sub_10015551C((uint64_t)&v40);
    }
  }
  *(_OWORD *)a2 = *(_OWORD *)__p;
  *(void *)(a2 + 16) = v32;
  __p[1] = 0;
  uint64_t v32 = 0;
  __p[0] = 0;
  *(int64x2_t *)(a2 + 24) = v33;
  *(void *)(a2 + 40) = v34[0];
  v34[0] = 0;
  int64x2_t v33 = 0uLL;
  *(_DWORD *)(a2 + 232) = 1;
  id v39 = (void **)&v33;
  sub_100155494(&v39);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1011E2F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

uint64_t sub_1011E2F58@<X0>(_DWORD *a1@<X1>, _DWORD *a2@<X8>)
{
  sub_1011DF538(a1, &v4);
  *a2 = v4;
  sub_1001FCBB0((uint64_t)(a2 + 2), (uint64_t)v5);
  a2[58] = 0;
  return sub_10015551C((uint64_t)v5);
}

void sub_1011E2FEC(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a1;
    uint64_t v35 = *(void *)(a1 + 16);
  }
  int64x2_t v36 = 0uLL;
  v37[0] = 0;
  uint64_t v3 = *(void *)(a1 + 32) - *(void *)(a1 + 24);
  if (v3)
  {
    unint64_t v4 = 0xEF7BDEF7BDEF7BDFLL * (v3 >> 3);
    if (v4 > 0x108421084210842) {
      sub_1001F7A28();
    }
    uint64_t v46 = v37;
    long long v5 = (void **)sub_1001F8B58((uint64_t)v37, v4);
    long long v43 = v5;
    v44.i64[0] = (uint64_t)v5;
    char v7 = &v5[31 * v6];
    v44.i64[1] = (uint64_t)v5;
    uint64_t v45 = v7;
    uint64_t v8 = v36.i64[1];
    uint64_t v9 = v36.i64[0];
    if (v36.i64[1] == v36.i64[0])
    {
      int64x2_t v12 = vdupq_n_s64(v36.u64[1]);
      uint64_t v10 = v5;
    }
    else
    {
      uint64_t v10 = v5;
      do
      {
        int v11 = *(_DWORD *)(v8 - 248);
        v8 -= 248;
        *((_DWORD *)v10 - 62) = v11;
        v10 -= 31;
        sub_1011E356C((uint64_t)(v10 + 1), v8 + 8);
      }
      while (v8 != v9);
      int64x2_t v12 = v36;
      long long v5 = (void **)v44.i64[1];
      char v7 = v45;
    }
    v36.i64[0] = (uint64_t)v10;
    v36.i64[1] = (uint64_t)v5;
    int64x2_t v44 = v12;
    char v13 = (void **)v37[0];
    v37[0] = v7;
    uint64_t v45 = v13;
    long long v43 = (void **)v12.i64[0];
    sub_1011E3624((uint64_t)&v43);
    char v14 = *(_DWORD **)(a1 + 24);
    for (uint64_t i = *(_DWORD **)(a1 + 32); v14 != i; v14 += 62)
    {
      if (*v14 == 1) {
        int v16 = 0;
      }
      else {
        int v16 = -1;
      }
      if (*v14 == 2) {
        int v17 = 1;
      }
      else {
        int v17 = v16;
      }
      LODWORD(v43) = v17;
      uint64_t v18 = v14[60];
      if (v18 == -1) {
        sub_1011E1F9C();
      }
      id v39 = &v38;
      ((void (*)(char **, _DWORD *))off_101A9E028[v18])(&v39, v14 + 2);
      uint64_t v19 = v36.i64[1];
      if (v36.i64[1] >= v37[0])
      {
        unint64_t v21 = 0xEF7BDEF7BDEF7BDFLL * ((v36.i64[1] - v36.i64[0]) >> 3);
        unint64_t v22 = v21 + 1;
        if (v21 + 1 > 0x108421084210842) {
          sub_1001F7A28();
        }
        if (0xDEF7BDEF7BDEF7BELL * ((v37[0] - v36.i64[0]) >> 3) > v22) {
          unint64_t v22 = 0xDEF7BDEF7BDEF7BELL * ((v37[0] - v36.i64[0]) >> 3);
        }
        if (0xEF7BDEF7BDEF7BDFLL * ((v37[0] - v36.i64[0]) >> 3) >= 0x84210842108421) {
          unint64_t v23 = 0x108421084210842;
        }
        else {
          unint64_t v23 = v22;
        }
        unint64_t v42 = v37;
        if (v23) {
          uint64_t v24 = (char *)sub_1001F8B58((uint64_t)v37, v23);
        }
        else {
          uint64_t v24 = 0;
        }
        uint64_t v25 = &v24[248 * v21];
        id v39 = v24;
        v40.i64[0] = (uint64_t)v25;
        uint64_t v41 = &v24[248 * v23];
        uint64_t v26 = (uint64_t)(v25 + 8);
        *(_DWORD *)uint64_t v25 = v43;
        unint64_t v20 = v25 + 248;
        sub_1011E356C(v26, (uint64_t)&v44);
        v40.i64[1] = (uint64_t)v20;
        uint64_t v27 = v36.i64[1];
        uint64_t v28 = v36.i64[0];
        uint64_t v29 = v40.i64[0];
        if (v36.i64[1] == v36.i64[0])
        {
          int64x2_t v31 = vdupq_n_s64(v36.u64[1]);
        }
        else
        {
          do
          {
            int v30 = *(_DWORD *)(v27 - 248);
            v27 -= 248;
            *(_DWORD *)(v29 - 248) = v30;
            v29 -= 248;
            sub_1011E356C(v29 + 8, v27 + 8);
          }
          while (v27 != v28);
          int64x2_t v31 = v36;
          unint64_t v20 = (_DWORD *)v40.i64[1];
        }
        v36.i64[0] = v29;
        v36.i64[1] = (uint64_t)v20;
        int64x2_t v40 = v31;
        uint64_t v32 = (char *)v37[0];
        v37[0] = v41;
        uint64_t v41 = v32;
        id v39 = (char *)v31.i64[0];
        sub_1011E3624((uint64_t)&v39);
      }
      else
      {
        *(_DWORD *)v36.i64[1] = v43;
        unint64_t v20 = (_DWORD *)(v19 + 248);
        sub_1011E356C(v19 + 8, (uint64_t)&v44);
      }
      v36.i64[1] = (uint64_t)v20;
      sub_1001F8F60((uint64_t)&v44);
    }
  }
  *(_OWORD *)a2 = *(_OWORD *)__p;
  *(void *)(a2 + 16) = v35;
  __p[1] = 0;
  uint64_t v35 = 0;
  __p[0] = 0;
  *(int64x2_t *)(a2 + 24) = v36;
  *(void *)(a2 + 40) = v37[0];
  v37[0] = 0;
  int64x2_t v36 = 0uLL;
  *(_DWORD *)(a2 + 232) = 1;
  long long v43 = (void **)&v36;
  sub_1001F8ED8(&v43);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1011E3398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
}

uint64_t sub_1011E33E8(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  int v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      unint64_t v4 = v2 - 5;
      *(void *)(a1 + 16) = v2 - 5;
      if (*((unsigned char *)v2 - 16) && *((char *)v2 - 17) < 0)
      {
        operator delete(*v4);
        unint64_t v4 = *(void ***)(a1 + 16);
      }
      int v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1011E3454(uint64_t result, long long *a2)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 56) = 0;
  if (*((unsigned char *)a2 + 56))
  {
    long long v2 = *a2;
    *(void *)(result + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t result = v2;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(unsigned char *)(result + 24) = 0;
    *(unsigned char *)(result + 48) = 0;
    if (*((unsigned char *)a2 + 48))
    {
      *(void *)(result + 24) = 0;
      *(void *)(result + 32) = 0;
      *(void *)(result + 40) = 0;
      *(_OWORD *)(result + 24) = *(long long *)((char *)a2 + 24);
      *(void *)(result + 40) = *((void *)a2 + 5);
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 4) = 0;
      *((void *)a2 + 5) = 0;
      *(unsigned char *)(result + 48) = 1;
    }
    *(unsigned char *)(result + 56) = 1;
  }
  return result;
}

uint64_t sub_1011E34C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    sub_1001F807C(i - 72);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1011E3518(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 232;
    sub_10015551C(i - 224);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1011E356C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 232) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 232);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_101A9E048[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 232) = v3;
  }
  return a1;
}

uint64_t sub_1011E35D4(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
  return sub_1001FCBB0((uint64_t)(a2 + 2), (uint64_t)(a3 + 2));
}

__n128 sub_1011E35E8(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v3;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  __n128 result = *(__n128 *)((char *)a3 + 24);
  *(__n128 *)(a2 + 24) = result;
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *((void *)a3 + 3) = 0;
  *((void *)a3 + 4) = 0;
  *((void *)a3 + 5) = 0;
  return result;
}

uint64_t sub_1011E3624(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 248;
    sub_1001F8F60(i - 240);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1011E3678(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 232) = -1;
  uint64_t v3 = *(unsigned int *)(a2 + 232);
  if (v3 != -1)
  {
    ((void (*)(char *, uint64_t, uint64_t))off_101A9E058[v3])(&v5, a1, a2);
    *(_DWORD *)(a1 + 232) = v3;
  }
  return a1;
}

uint64_t sub_1011E36E0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = *a3;
  return sub_1001FCBB0((uint64_t)(a2 + 2), (uint64_t)(a3 + 2));
}

__n128 sub_1011E36F4(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v3 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v3;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  __n128 result = *(__n128 *)((char *)a3 + 24);
  *(__n128 *)(a2 + 24) = result;
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *((void *)a3 + 3) = 0;
  *((void *)a3 + 4) = 0;
  *((void *)a3 + 5) = 0;
  return result;
}

uint64_t sub_1011E3730(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 248;
    sub_1001F9EA0(i - 240);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1011E3784(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x34F72C234F72C235 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x11A7B9611A7B962) {
      sub_1001F7A28();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_1001F9DC8(result, a2);
    v7[1] = v7[0] + v5;
    xpc_object_t v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 232 * v6;
    sub_1011E3844(a1, v7);
    return sub_1011E3518((uint64_t)v7);
  }
  return result;
}

void sub_1011E3830(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1011E3518((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1011E3844(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    int v7 = *(_DWORD *)(v4 - 232);
    v4 -= 232;
    *(_DWORD *)(v6 - 232) = v7;
    v6 -= 232;
    uint64_t result = (uint64_t *)sub_1001FCBB0(v6 + 8, v4 + 8);
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1011E38D8(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x34F72C234F72C235 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x11A7B9611A7B961) {
    sub_1001F7A28();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x34F72C234F72C235 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x8D3DCB08D3DCB0) {
    unint64_t v9 = 0x11A7B9611A7B961;
  }
  else {
    unint64_t v9 = v5;
  }
  void v14[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_1001F9DC8(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  int v11 = &v10[232 * v4];
  v14[0] = v10;
  v14[1] = v11;
  void v14[3] = &v10[232 * v9];
  *(_DWORD *)int v11 = *a2;
  sub_1001FCBB0((uint64_t)(v11 + 8), (uint64_t)(a2 + 2));
  v14[2] = v11 + 232;
  sub_1011E3844(a1, v14);
  uint64_t v12 = a1[1];
  sub_1011E3518((uint64_t)v14);
  return v12;
}

void sub_1011E39E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1011E3518((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011E39F8(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 280;
    uint64_t result = sub_1011E3A80(result - 280, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1011E3A80(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 176) = 0;
  if (*(unsigned char *)(a2 + 176))
  {
    sub_1004584A0(a1, (long long *)a2);
    *(unsigned char *)(a1 + 176) = 1;
  }
  *(unsigned char *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  if (*(unsigned char *)(a2 + 208))
  {
    long long v4 = *(_OWORD *)(a2 + 184);
    *(void *)(a1 + 200) = *(void *)(a2 + 200);
    *(_OWORD *)(a1 + 184) = v4;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 200) = 0;
    *(void *)(a2 + 184) = 0;
    *(unsigned char *)(a1 + 208) = 1;
  }
  *(unsigned char *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 240) = 0;
  if (*(unsigned char *)(a2 + 240))
  {
    long long v5 = *(_OWORD *)(a2 + 216);
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    *(_OWORD *)(a1 + 216) = v5;
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 232) = 0;
    *(void *)(a2 + 216) = 0;
    *(unsigned char *)(a1 + 240) = 1;
  }
  *(unsigned char *)(a1 + 248) = 0;
  *(unsigned char *)(a1 + 272) = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    *(void *)(a1 + 248) = 0;
    *(void *)(a1 + 256) = 0;
    *(void *)(a1 + 264) = 0;
    *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
    *(void *)(a1 + 264) = *(void *)(a2 + 264);
    *(void *)(a2 + 248) = 0;
    *(void *)(a2 + 256) = 0;
    *(void *)(a2 + 264) = 0;
    *(unsigned char *)(a1 + 272) = 1;
  }
  return a1;
}

uint64_t sub_1011E3B70(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 280;
    sub_100456500(i - 280);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1011E3BC0(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_NetworkMcc");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E3D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E3DAC(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_NetworkMnc");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E3F30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E3F98(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_CurrentOperatorBundleId");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E411C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4184(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_Roaming");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E4308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4370(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_RAT");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E44F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E455C(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_2_NetworkIso");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E46E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4748(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_2_Sid");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E48CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4934(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_2_Nid");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E4AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4B20(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_2_Roaming");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E4CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4D0C(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_3GPP_2_RAT");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E4E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E4EF8(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_Subscriber_Mcc");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E507C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E50E4(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_Subscriber_Mnc");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E5268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1011E52D0(int a1@<W0>, void *a2@<X8>)
{
  BOOL v3 = a1 != 1;
  if (a1 == 1) {
    long long v4 = "";
  }
  else {
    long long v4 = "_2";
  }
  *a2 = 0;
  sub_100058DB0(&v10, "kOperatorRoamingInfo_Subscriber_CarrierBundleID");
  long long v5 = std::string::append(&v10, v4, 2 * v3);
  uint64_t v7 = (void *)v5->__r_.__value_.__r.__words[0];
  unint64_t size = (void *)v5->__r_.__value_.__l.__size_;
  v11[0] = v5->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v11 + 3) = *(_DWORD *)((char *)&v5->__r_.__value_.__r.__words[2] + 3);
  int v8 = SHIBYTE(v5->__r_.__value_.__r.__words[2]);
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if ((v8 & 0x80000000) == 0)
  {
    __dst[0] = v7;
    __dst[1] = size;
    LODWORD(v14) = v11[0];
    *(_DWORD *)((char *)&v14 + 3) = *(_DWORD *)((char *)v11 + 3);
    HIBYTE(v14) = v8;
    uint64_t v12 = 0;
LABEL_7:
    *(_OWORD *)long long __p = *(_OWORD *)__dst;
    uint64_t v16 = v14;
    goto LABEL_8;
  }
  sub_10004FC84(__dst, v7, (unint64_t)size);
  uint64_t v12 = 0;
  if ((SHIBYTE(v14) & 0x80000000) == 0) {
    goto LABEL_7;
  }
  sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
LABEL_8:
  int v17 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v9 = v12;
    uint64_t v12 = v17;
    uint64_t v18 = v9;
    sub_1000558F4(&v18);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  *a2 = v12;
  uint64_t v12 = 0;
  sub_1000558F4(&v12);
  if (SHIBYTE(v14) < 0)
  {
    operator delete(__dst[0]);
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  else if ((v8 & 0x80000000) == 0)
  {
    goto LABEL_14;
  }
  operator delete(v7);
LABEL_14:
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_1011E5454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_1000558F4(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v29 < 0) {
    operator delete(v28);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1011E54BC(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

const void **resetEnableLTEPreference(Registry **a1, NSObject **a2, int a3, int a4)
{
  unint64_t v21 = sub_1011E5694(a1, @"DataPlanNetworkRejectionCauseToForce3G", a3, a4);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *a1);
  int v8 = ServiceMap;
  if (v9 < 0)
  {
    std::string v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)id buf = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    char v15 = (MaxDataRateInterface *)v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_18;
      }
      goto LABEL_10;
    }
  }
  else
  {
    char v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15) {
    goto LABEL_18;
  }
LABEL_10:
  int UserPreferenceEnableLTE = MaxDataRateInterface::getUserPreferenceEnableLTE(v15);
  if (v21) {
    uint64_t v18 = sub_100081E58;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18 && UserPreferenceEnableLTE == 2)
  {
    uint64_t v19 = *a2;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Enable LTE due to successful account update", buf, 2u);
    }
    sub_100358C28((uint64_t)&event::registration::setLTEToProvisioning, 0);
  }
LABEL_18:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  return sub_1000570E8(&v21);
}

void sub_1011E5668(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

const void *sub_1011E5694(Registry **a1, const void *a2, int a3, int a4)
{
  CFDictionaryRef v6 = (const __CFDictionary *)sub_100916B20(a1, a4);
  CFDictionaryRef v17 = v6;
  if (v6) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7) {
    goto LABEL_19;
  }
  if (a3 != -1)
  {
    CFDictionaryRef v15 = v6;
    CFDictionaryRef theDict = 0;
    if (v6) {
      CFRetain(v6);
    }
    sub_100916790(&v15, a3, (const void **)&theDict);
    sub_100057D78((const void **)&v15);
    if (theDict) {
      int v8 = sub_100080778;
    }
    else {
      int v8 = 0;
    }
    if (v8)
    {
      int Value = CFDictionaryGetValue(theDict, a2);
      std::string v10 = Value;
      if (Value)
      {
        CFTypeID v11 = CFGetTypeID(Value);
        if (v11 == CFNumberGetTypeID())
        {
          sub_100057D78((const void **)&theDict);
LABEL_18:
          CFRetain(v10);
          goto LABEL_20;
        }
      }
    }
    sub_100057D78((const void **)&theDict);
    CFDictionaryRef v6 = v17;
  }
  unsigned int v12 = CFDictionaryGetValue(v6, a2);
  std::string v10 = v12;
  if (v12)
  {
    CFTypeID v13 = CFGetTypeID(v12);
    if (v13 == CFNumberGetTypeID()) {
      goto LABEL_18;
    }
LABEL_19:
    std::string v10 = 0;
  }
LABEL_20:
  sub_100057D78((const void **)&v17);
  return v10;
}

void sub_1011E57C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  char v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1011E57F4()
{
}

void sub_1011E59AC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_1011E5A4C(Registry *this@<X2>, uint64_t a2@<X0>, uint64_t a3@<X1>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, this);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v8;
  unsigned int v12 = sub_10004D37C(&v7[1].__m_.__sig, &v16);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    CFTypeID v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v14 = v12[3];
  CFTypeID v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (v14) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v14 + 40))(v14, 52, a2, a3);
LABEL_11:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_1011E5B70(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E5B8C(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v23, *(Registry **)(a1 + 80));
  ctu::RestModule::connect();
  long long v2 = (capabilities::ct *)v24;
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (capabilities::ct::supportsVoiceCall(v2))
  {
    sub_100058DB0(&__p, "/cc/prefs-nb/user_default_voice_slot");
    *(void *)id buf = off_101A9E760;
    uint64_t v29 = a1;
    int v30 = buf;
    ctu::RestModule::getPropertyOnce();
    sub_10003F600(buf);
    if (v22 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    sub_100058DB0(v25, "/cc/props/network_rejects");
    char v3 = (uint8_t *)operator new(0x28uLL);
    *(void *)char v3 = off_101A9E860;
    *((void *)v3 + 1) = a1 + 560;
    *((void *)v3 + 2) = a1;
    *((void *)v3 + 3) = sub_1011E6ED8;
    *((void *)v3 + 4) = 0;
    int v30 = v3;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (SBYTE7(v26) < 0) {
      operator delete(v25[0]);
    }
    sub_101058EF0(a1 + 584);
  }
  sub_100058DB0(v25, "/cc/props/dataplan_suppressing_indicator");
  *(void *)id buf = off_101A9E8E0;
  uint64_t v29 = a1 + 216;
  int v30 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SBYTE7(v26) < 0) {
    operator delete(v25[0]);
  }
  *(void *)id buf = off_101A9E960;
  uint64_t v29 = a1 + 112;
  int v30 = buf;
  sub_100318874(buf, (void *)(a1 + 128));
  sub_10030AB98(buf);
  uint64_t v4 = *(void *)(a1 + 152);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, a1 + 160);
  }
  sub_100D676F8(a1 + 336);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      unint64_t v8 = v7;
      atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v7);
      sub_100058DB0(v25, "/cc/events/dump_state");
      uint64_t v9 = (uint8_t *)operator new(0x20uLL);
      *(void *)uint64_t v9 = off_101A9E9E0;
      *((void *)v9 + 1) = a1;
      *((void *)v9 + 2) = v6;
      *((void *)v9 + 3) = v8;
      int v30 = v9;
      ctu::RestModule::observeEvent();
      sub_10003F600(buf);
      if (SBYTE7(v26) < 0) {
        operator delete(v25[0]);
      }
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 48);
      if (v10)
      {
        uint64_t v11 = *(void *)(a1 + 40);
        unsigned int v12 = std::__shared_weak_count::lock(v10);
        if (v12)
        {
          CFTypeID v13 = v12;
          atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
          sub_100058DB0(v25, "/cc/props/selected_cellular_plan");
          uint64_t v14 = (uint8_t *)operator new(0x28uLL);
          *(void *)uint64_t v14 = off_101A9EA60;
          *((void *)v14 + 1) = a1 + 248;
          *((void *)v14 + 2) = a1;
          *((void *)v14 + 3) = v11;
          *((void *)v14 + 4) = v13;
          int v30 = v14;
          ctu::RestModule::observeProperty();
          sub_10003F600(buf);
          if (SBYTE7(v26) < 0) {
            operator delete(v25[0]);
          }
          char v15 = *(std::__shared_weak_count **)(a1 + 48);
          if (v15)
          {
            uint64_t v16 = *(void *)(a1 + 40);
            CFDictionaryRef v17 = std::__shared_weak_count::lock(v15);
            if (v17)
            {
              uint64_t v18 = v17;
              atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v17);
              sub_100058DB0(v25, "/cc/props/msim_config_mode");
              uint64_t v19 = (uint8_t *)operator new(0x28uLL);
              *(void *)uint64_t v19 = off_101A9EAE0;
              *((void *)v19 + 1) = a1 + 280;
              *((void *)v19 + 2) = a1;
              *((void *)v19 + 3) = v16;
              *((void *)v19 + 4) = v18;
              int v30 = v19;
              ctu::RestModule::observeProperty();
              sub_10003F600(buf);
              if (SBYTE7(v26) < 0) {
                operator delete(v25[0]);
              }
              unint64_t v20 = *(NSObject **)(a1 + 56);
              if (!v20)
              {
                __TUAssertTrigger();
                unint64_t v20 = *(NSObject **)(a1 + 56);
              }
              dispatch_retain(v20);
              *(_OWORD *)uint64_t v25 = 0u;
              long long v26 = 0u;
              dispatch_retain(v20);
              dispatch_retain(v20);
              dispatch_retain(v20);
              uint64_t v27 = 0;
              dispatch_retain(v20);
              dispatch_retain(v20);
              dispatch_retain(v20);
              dispatch_retain(v20);
              operator new();
            }
          }
          sub_100088B9C();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_1011E6A9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void **a31)
{
}

void sub_1011E6AB4()
{
}

void sub_1011E6B10()
{
  sub_1004F9FB0(v0);
  JUMPOUT(0x1011E6DC4);
}

void sub_1011E6B90(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_1011E6BD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, atomic_uint **a11)
{
}

void sub_1011E6BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    sub_1011F4BF8(v31);
    sub_100163C60((void ***)&a31);
    operator delete();
  }
  _Unwind_Resume(a1);
}

void sub_1011E6C24()
{
  __cxa_end_catch();
  sub_10000A740(v1);
  *(void *)uint64_t v0 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(v0 + 16));
  operator delete();
}

void sub_1011E6CA0()
{
}

void sub_1011E6CA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char *a37)
{
  dispatch_release(v38);
  dispatch_release(v38);
  dispatch_release(v38);
  dispatch_release(v38);
  dispatch_release(v38);
  dispatch_release(v38);
  dispatch_release(v38);
  sub_1011F4BF8(v37);
  a37 = &a23;
  JUMPOUT(0x1011E6DC4);
}

void sub_1011E6CDC()
{
  std::__shared_weak_count::__release_weak(v0);
  JUMPOUT(0x1011E6D20);
}

void sub_1011E6D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1011E6D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(a1);
}

void sub_1011E6D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
}

void sub_1011E6D88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60)
{
  sub_10000A6C8(a60);
  sub_10000A5F8(&a37);
  sub_1011F4BF8(a10);
  a16 = &a23;
  sub_100163C60(&a16);
  dispatch_release(v60);
  JUMPOUT(0x1011E6DECLL);
}

void sub_1011E6DD8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1011E6DF4(uint64_t a1)
{
}

uint64_t sub_1011E6E04(void *a1)
{
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 14));
  uint64_t v2 = a1[93];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 752))(v2);
  }
  uint64_t v3 = a1[95];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t result = a1[97];
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 24);
    return v5();
  }
  return result;
}

uint64_t sub_1011E6ED0(uint64_t a1)
{
  return sub_1011E6E04((void *)(a1 - 8));
}

void sub_1011E6ED8(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)id buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    uint64_t v14 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Missing subscriber utility", buf, 2u);
    }
    goto LABEL_43;
  }
LABEL_11:
  uint64_t v15 = *(void *)(a1 + 568);
  if (v15)
  {
    uint64_t v16 = a1 + 568;
    do
    {
      int v17 = *(_DWORD *)(v15 + 28);
      BOOL v18 = v17 < 1;
      if (v17 >= 1) {
        uint64_t v19 = (uint64_t *)v15;
      }
      else {
        uint64_t v19 = (uint64_t *)(v15 + 8);
      }
      if (!v18) {
        uint64_t v16 = v15;
      }
      uint64_t v15 = *v19;
    }
    while (*v19);
    if (v16 != a1 + 568 && *(int *)(v16 + 28) < 2)
    {
      uint64_t v22 = *(void *)(a2 + 8);
      uint64_t v21 = a2 + 8;
      uint64_t v20 = v22;
      if (!v22) {
        goto LABEL_33;
      }
      uint64_t v23 = v21;
      do
      {
        int v24 = *(_DWORD *)(v20 + 28);
        BOOL v25 = v24 < 1;
        if (v24 >= 1) {
          long long v26 = (uint64_t *)v20;
        }
        else {
          long long v26 = (uint64_t *)(v20 + 8);
        }
        if (!v25) {
          uint64_t v23 = v20;
        }
        uint64_t v20 = *v26;
      }
      while (*v26);
      if (v23 == v21
        || *(int *)(v23 + 28) > 1
        || *(unsigned __int8 *)(v23 + 32) != *(unsigned __int8 *)(v16 + 32)
        || *(_DWORD *)(v23 + 36) != *(_DWORD *)(v16 + 36))
      {
LABEL_33:
        uint64_t v27 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = *(unsigned __int8 *)(v16 + 32);
          int v29 = *(_DWORD *)(v16 + 36);
          *(_DWORD *)id buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v28;
          LOWORD(v39) = 1024;
          *(_DWORD *)((char *)&v39 + 2) = v29;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I rejectCauseCode[%d], inputRAT[%d]", buf, 0xEu);
        }
        MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)(a1 + 584));
        char v30 = MCC::valid((MCC *)buf);
        char v31 = v30;
        if (v40 < 0)
        {
          operator delete(v39);
          if (v31) {
            goto LABEL_37;
          }
        }
        else if (v30)
        {
LABEL_37:
          *(void *)&long long v33 = a1;
          BYTE8(v33) = *(unsigned char *)(v16 + 32);
          HIDWORD(v33) = *(_DWORD *)(v16 + 36);
          MCCAndMNC::getMcc((uint64_t *)buf, (MCCAndMNC *)(a1 + 584));
          MCC::getStringValue((uint64_t *)&__p, (MCC *)buf);
          long long v37 = 0;
          uint64_t v32 = (char *)operator new(0x30uLL);
          *(void *)uint64_t v32 = off_101A9F060;
          *(_OWORD *)(v32 + 8) = v33;
          *(_OWORD *)(v32 + 24) = __p;
          *((void *)v32 + 5) = v35;
          long long __p = 0uLL;
          uint64_t v35 = 0;
          long long v37 = v32;
          (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v12 + 24))(v12, 1, v36);
          sub_10001E914(v36);
          if (SHIBYTE(v35) < 0) {
            operator delete((void *)__p);
          }
          if (v40 < 0) {
            operator delete(v39);
          }
          goto LABEL_43;
        }
        sub_1011F0760(a1, *(unsigned __int8 *)(v16 + 32), *(unsigned __int8 *)(v16 + 36));
      }
    }
  }
LABEL_43:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1011E7248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E72C0(uint64_t a1, int a2)
{
  if (a2 != -1 && *(_DWORD *)(a1 + 672) != a2)
  {
    *(_DWORD *)(a1 + 672) = a2;
    sub_1011E8598((void *)a1, 0, 1);
    uint64_t v3 = *(void *)(a1 + 744);
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 752);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(void *)(a1 + 648) && v3 && (*(unsigned int (**)(uint64_t))(*(void *)v3 + 648))(v3))
    {
      uint64_t v5 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I will put data plan in monitor mode", v6, 2u);
      }
      (*(void (**)(void))(**(void **)(a1 + 648) + 16))(*(void *)(a1 + 648));
    }
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
}

void sub_1011E73DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E73F4(int a1, int a2, dispatch_object_t object, long long *a4)
{
  long long v8 = *a4;
  uint64_t v9 = *((void *)a4 + 2);
  dispatch_retain(object);
  long long v5 = 0u;
  long long v6 = 0u;
  dispatch_retain(object);
  dispatch_retain(object);
  dispatch_retain(object);
  uint64_t v7 = 0;
  dispatch_retain(object);
  dispatch_retain(object);
  dispatch_retain(object);
  dispatch_retain(object);
  operator new();
}

void sub_1011E7564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10097F2DC((uint64_t)&a9);
  dispatch_release(v9);
  _Unwind_Resume(a1);
}

void sub_1011E75E8(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 72);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    long long v6 = "false";
    if (a2) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    if (*(unsigned char *)(a1 + 793)) {
      long long v6 = "true";
    }
    *(_DWORD *)uint64_t v32 = 136315394;
    *(void *)&v32[4] = v7;
    __int16 v33 = 2080;
    uint64_t v34 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I sim provisioning received provisioned: %s, BBEnteredProvisioningMode: %s", v32, 0x16u);
  }
  if (*(void *)(a1 + 648))
  {
    if (a2)
    {
      if (!*(unsigned char *)(a1 + 793) && !capabilities::ct::supportsCambioModeQuery((capabilities::ct *)v5))
      {
LABEL_34:
        (*(void (**)(void, void))(**(void **)(a1 + 648) + 104))(*(void *)(a1 + 648), 0);
        return;
      }
      long long v8 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v32 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Device with hot sim, disabling provisioning mode!", v32, 2u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 80));
      uint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)uint64_t v32 = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v32);
      if (v16)
      {
        uint64_t v18 = v16[3];
        int v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
LABEL_31:
          (*(void (**)(uint64_t, void))(*(void *)v18 + 320))(v18, 0);
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          *(unsigned char *)(a1 + 793) = 0;
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      int v17 = 0;
      char v19 = 1;
      goto LABEL_31;
    }
    if (*(unsigned char *)(a1 + 793)) {
      return;
    }
    uint64_t v20 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v32 = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Device with cold sim, enable provisioning mode!", v32, 2u);
    }
    uint64_t v22 = (std::mutex *)Registry::getServiceMap(v21, *(Registry **)(a1 + 80));
    uint64_t v23 = v22;
    if (v24 < 0)
    {
      BOOL v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v26 = 5381;
      do
      {
        uint64_t v24 = v26;
        unsigned int v27 = *v25++;
        uint64_t v26 = (33 * v26) ^ v27;
      }
      while (v27);
    }
    std::mutex::lock(v22);
    *(void *)uint64_t v32 = v24;
    int v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)v32);
    if (v28)
    {
      uint64_t v30 = v28[3];
      char v29 = (std::__shared_weak_count *)v28[4];
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v23);
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v29);
        char v31 = 0;
LABEL_37:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 320))(v30, 1);
        if ((v31 & 1) == 0) {
          sub_10004D2C8(v29);
        }
        *(unsigned char *)(a1 + 793) = 1;
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 648) + 64))(*(void *)(a1 + 648), 5);
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 648) + 104))(*(void *)(a1 + 648), 1);
        return;
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    std::mutex::unlock(v23);
    char v29 = 0;
    char v31 = 1;
    goto LABEL_37;
  }
}

void sub_1011E79A8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E79E0(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 648);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 104))(v3, 0);
    if (*(void *)(a1 + 648))
    {
      *(unsigned char *)(a1 + 794) = a2;
      BOOL v5 = *(NSObject **)(a1 + 72);
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      if (a2)
      {
        if (v6)
        {
          __int16 v10 = 0;
          uint64_t v7 = "#I Cold Sim removed, waiting for BB to go online before disabling provisioning mode";
          long long v8 = (uint8_t *)&v10;
LABEL_8:
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, v8, 2u);
        }
      }
      else if (v6)
      {
        __int16 v9 = 0;
        uint64_t v7 = "#I Sim Removed but it is not cold";
        long long v8 = (uint8_t *)&v9;
        goto LABEL_8;
      }
      *(unsigned char *)(a1 + 793) = 0;
    }
  }
}

void sub_1011E7AB4(uint64_t a1, int a2)
{
  if ((a2 - 2) < 5 || a2 == 8)
  {
    BOOL v5 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Not processing operating mode %s", (uint8_t *)&buf, 0xCu);
    }
  }
  else if (*(void *)(a1 + 648) && *(unsigned char *)(a1 + 794))
  {
    if ((capabilities::ct::supportsCambioModeQuery((capabilities::ct *)a1) & 1) == 0)
    {
      BOOL v6 = *(NSObject **)(a1 + 72);
      BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
      if (a2)
      {
        if (v7)
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I BB is offline and Cold SIM was removed, disabling provisioning mode now", (uint8_t *)&buf, 2u);
        }
        sub_1002A2348(*(Registry **)(a1 + 80), &buf);
        (*(void (**)(void, void))(*(void *)buf + 328))(buf, 0);
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
      }
      else
      {
        if (v7)
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I BB is online and Cold SIM was removed, disabling provisioning mode with delay", (uint8_t *)&buf, 2u);
        }
        dispatch_time_t v8 = dispatch_time(0, 3000000000);
        __int16 v9 = *(NSObject **)(a1 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1011EAA84;
        block[3] = &unk_1019A1BF8;
        block[4] = a1;
        dispatch_after(v8, v9, block);
      }
    }
    *(_WORD *)(a1 + 793) = 0;
  }
}

void sub_1011E7CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E7CD8(uint64_t a1, int a2)
{
  if ((capabilities::ct::supportsPCOForCambioTrigger((capabilities::ct *)a1) & 1) == 0)
  {
    uint64_t v4 = *(NSObject **)(a1 + 72);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v5)
      {
        LOWORD(v36[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Current provisioning mode is true, disabling it before OTASP", (uint8_t *)v36, 2u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 80));
      dispatch_time_t v8 = ServiceMap;
      if ((v9 & 0x8000000000000000) != 0)
      {
        __int16 v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          unint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      v36[0] = v9;
      char v13 = sub_10004D37C(&v8[1].__m_.__sig, v36);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
LABEL_21:
          (*(void (**)(uint64_t, void))(*(void *)v15 + 328))(v15, 0);
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
      goto LABEL_21;
    }
    if (v5)
    {
      LOWORD(v36[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Current provisioning mode is false, performing OTASP", (uint8_t *)v36, 2u);
    }
    int v17 = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 80));
    uint64_t v18 = v17;
    unint64_t v20 = v19;
    if ((v19 & 0x8000000000000000) != 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        unint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(v17);
    v36[0] = v20;
    uint64_t v24 = sub_10004D37C(&v18[1].__m_.__sig, v36);
    if (v24)
    {
      uint64_t v26 = v24[3];
      BOOL v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v18);
    BOOL v25 = 0;
    char v27 = 1;
LABEL_24:
    (*(void (**)(uint64_t))(*(void *)v26 + 32))(v26);
    if ((v27 & 1) == 0) {
      sub_10004D2C8(v25);
    }
    char v29 = (std::mutex *)Registry::getServiceMap(v28, *(Registry **)(a1 + 80));
    uint64_t v30 = v29;
    if ((v19 & 0x8000000000000000) != 0)
    {
      char v31 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        unint64_t v19 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(v29);
    v36[0] = v19;
    uint64_t v34 = sub_10004D37C(&v30[1].__m_.__sig, v36);
    if (v34)
    {
      uint64_t v35 = v34[3];
      uint64_t v14 = (std::__shared_weak_count *)v34[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
LABEL_34:
        (*(void (**)(uint64_t, void))(*(void *)v35 + 96))(v35, 0);
LABEL_35:
        if ((v16 & 1) == 0) {
          sub_10004D2C8(v14);
        }
        return;
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    std::mutex::unlock(v30);
    uint64_t v14 = 0;
    char v16 = 1;
    goto LABEL_34;
  }
}

void sub_1011E7FF4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E8028(uint64_t a1, uint64_t a2)
{
  char v2 = *(uint64_t **)(a1 + 648);
  if (v2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 80));
    BOOL v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      dispatch_time_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    char v58 = (void *)v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v58);
    if (!v11)
    {
      std::mutex::unlock(v6);
      return;
    }
    uint64_t v13 = v11[3];
    unsigned int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      if (!v13)
      {
LABEL_89:
        sub_10004D2C8(v12);
        return;
      }
    }
    else
    {
      std::mutex::unlock(v6);
      if (!v13) {
        return;
      }
    }
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 776))(v13);
    uint64_t v15 = *(void *)(a1 + 320);
    if (v15)
    {
      uint64_t v16 = a1 + 320;
      do
      {
        int v17 = *(_DWORD *)(v15 + 32);
        BOOL v18 = v17 < v14;
        if (v17 >= v14) {
          unint64_t v19 = (uint64_t *)v15;
        }
        else {
          unint64_t v19 = (uint64_t *)(v15 + 8);
        }
        if (!v18) {
          uint64_t v16 = v15;
        }
        uint64_t v15 = *v19;
      }
      while (*v19);
      if (v16 != a1 + 320 && v14 >= *(_DWORD *)(v16 + 32))
      {
        unint64_t v20 = (unint64_t *)&v58;
        v59[0] = 0;
        v59[1] = 0;
        char v58 = v59;
        uint64_t v23 = *(void *)(a2 + 8);
        uint64_t v22 = a2 + 8;
        uint64_t v21 = v23;
        if (v23)
        {
          uint64_t v24 = v22;
          do
          {
            int v25 = *(_DWORD *)(v21 + 32);
            BOOL v26 = v25 < v14;
            if (v25 >= v14) {
              char v27 = (uint64_t *)v21;
            }
            else {
              char v27 = (uint64_t *)(v21 + 8);
            }
            if (!v26) {
              uint64_t v24 = v21;
            }
            uint64_t v21 = *v27;
          }
          while (*v27);
          unint64_t v20 = (unint64_t *)&v58;
          if (v24 != v22)
          {
            int v28 = *(_DWORD *)(v24 + 32);
            char v29 = (unint64_t *)(v24 + 40);
            if (v14 >= v28) {
              unint64_t v20 = v29;
            }
          }
        }
        uint64_t v30 = *(void **)(v16 + 40);
        char v31 = (void *)(v16 + 48);
        if (v30 != (void *)(v16 + 48))
        {
          uint64_t v32 = v20 + 1;
          while (1)
          {
            unsigned int v33 = (void *)*v32;
            if (!*v32) {
              goto LABEL_75;
            }
            int v34 = *((_DWORD *)v30 + 8);
            uint64_t v35 = v32;
            do
            {
              int64x2_t v36 = v33;
              long long v37 = v35;
              int v38 = *((_DWORD *)v33 + 8);
              id v39 = v33 + 1;
              if (v38 >= v34)
              {
                id v39 = v36;
                uint64_t v35 = v36;
              }
              unsigned int v33 = (void *)*v39;
            }
            while (v33);
            if (v35 == v32 || (v38 >= v34 ? (char v40 = v36) : (char v40 = v37), v34 < *((_DWORD *)v40 + 8)))
            {
LABEL_75:
              uint64_t v53 = *(void *)(a1 + 648);
              uint64_t v42 = *((unsigned int *)v30 + 10);
              uint64_t v45 = *((unsigned int *)v30 + 11);
              uint64_t v54 = ConnectionTypeToMask();
            }
            else
            {
              if (v38 >= v34) {
                uint64_t v41 = v36;
              }
              else {
                uint64_t v41 = v37;
              }
              uint64_t v42 = *((unsigned int *)v30 + 10);
              if (*((_DWORD *)v41 + 10) == v42)
              {
                if (v38 >= v34) {
                  long long v43 = v36;
                }
                else {
                  long long v43 = v37;
                }
                uint64_t v44 = *((unsigned int *)v43 + 11);
                uint64_t v45 = *((unsigned int *)v30 + 11);
                if (v44 == v45)
                {
                  uint64_t v46 = 0;
                  uint64_t v45 = v44;
                  CFUserNotificationRef v47 = v37 + 6;
                  if (v38 >= v34) {
                    CFUserNotificationRef v47 = v36 + 6;
                  }
                  uint64_t v48 = v30 + 6;
                  do
                  {
                    BOOL v49 = LODWORD(v47[v46]) == LODWORD(v48[v46]) && v47[v46 + 1] == v48[v46 + 1];
                    int v50 = v49;
                    BOOL v51 = v50 != 1 || v46 == 2;
                    v46 += 2;
                  }
                  while (!v51);
                  if (v50)
                  {
                    uint64_t v52 = v38 >= v34 ? v36 : v37;
                    if (*((unsigned __int8 *)v52 + 80) == *((unsigned __int8 *)v30 + 80))
                    {
                      if (v38 < v34) {
                        int64x2_t v36 = v37;
                      }
                      if (*((_DWORD *)v36 + 21) == *((_DWORD *)v30 + 21)) {
                        goto LABEL_77;
                      }
                    }
                  }
                }
              }
              else
              {
                uint64_t v45 = *((unsigned int *)v30 + 11);
              }
              uint64_t v53 = *(void *)(a1 + 648);
              uint64_t v54 = ConnectionTypeToMask();
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v53 + 264))(v53, v42, v45, v54);
LABEL_77:
            long long v55 = (void *)v30[1];
            if (v55)
            {
              do
              {
                char v56 = v55;
                long long v55 = (void *)*v55;
              }
              while (v55);
            }
            else
            {
              do
              {
                char v56 = (void *)v30[2];
                BOOL v49 = *v56 == (void)v30;
                uint64_t v30 = v56;
              }
              while (!v49);
            }
            uint64_t v30 = v56;
            if (v56 == v31)
            {
              unsigned __int8 v57 = (void *)v59[0];
              goto LABEL_87;
            }
          }
        }
        unsigned __int8 v57 = 0;
LABEL_87:
        sub_1000346F8((uint64_t)&v58, v57);
      }
    }
    if (!v12) {
      return;
    }
    goto LABEL_89;
  }
}

void sub_1011E83A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011E83DC(uint64_t result, unsigned int a2)
{
  int v2 = *(unsigned __int8 *)(result + 285);
  if (((a2 >> 8) & 1) != v2) {
    return (*(uint64_t (**)(void, BOOL))(**(void **)(result + 720) + 152))(*(void *)(result + 720), v2 != 0);
  }
  return result;
}

void sub_1011E8420(uint64_t a1, int a2)
{
  if (a2 == 2 && *(_DWORD *)(a1 + 220) != 2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Selected profile changed from sid 2", v15, 2u);
    }
    *(unsigned char *)(a1 + 793) = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 80));
    BOOL v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      dispatch_time_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v16 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v16);
    if (v11)
    {
      uint64_t v13 = v11[3];
      unsigned int v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    unsigned int v12 = 0;
    char v14 = 1;
LABEL_13:
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
    if ((v14 & 1) == 0) {
      sub_10004D2C8(v12);
    }
  }
}

void sub_1011E8578(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011E8598(void *a1, int a2, int a3)
{
  uint64_t v5 = a1[81];
  if (v5) {
    unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 80))(v5);
  }
  else {
    unsigned int v6 = 0;
  }
  unint64_t v7 = a1 + 81;
  dispatch_time_t v8 = a1[9];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (v6 > 3) {
      uint64_t v9 = "DataPlanUnknown";
    }
    else {
      uint64_t v9 = off_101A9F0D0[v6];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DataPlanNone";
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Resetting Data Plan - type to use = %s, previous xpc_type_t type = %s", (uint8_t *)&buf, 0x16u);
  }
  if (*v7)
  {
    int v81 = (*(uint64_t (**)(void))(*(void *)*v7 + 96))(*v7);
    if (*v7)
    {
      int v80 = (*(uint64_t (**)(void))(*(void *)*v7 + 88))(*v7);
      if (*v7)
      {
        unsigned int v10 = a1[9];
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Previously had a data plan, comparing", (uint8_t *)&buf, 2u);
        }
        if (v6)
        {
          uint64_t v11 = a1[9];
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Changing data plan types, getting rid of old", (uint8_t *)&buf, 2u);
          }
        }
        else
        {
          if (a2)
          {
            int64x2_t v79 = a1[9];
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I Reseting existing data plan manager", (uint8_t *)&buf, 2u);
            }
            (*(void (**)(void))(*(void *)*v7 + 112))();
          }
          if (*v7) {
            return;
          }
        }
      }
      goto LABEL_19;
    }
  }
  else
  {
    int v81 = 0;
  }
  int v80 = 0;
LABEL_19:
  unsigned int v12 = a1[9];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"DataPlanNone";
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Creating a new data plan manager of type %s", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v13 = (std::__shared_weak_count *)a1[11];
  uint64_t v14 = a1[12];
  uint64_t v88 = a1[10];
  uint64_t v89 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = (std::__shared_weak_count *)a1[6];
  if (!v15 || (uint64_t v16 = a1[5], (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v18 = v16 + 16;
  if (!v16) {
    uint64_t v18 = 0;
  }
  uint64_t v86 = v18;
  long long v87 = v17;
  unint64_t v19 = a1[7];
  dispatch_object_t object = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t *, uint64_t *, dispatch_object_t *, void))(*(void *)v14 + 32))(&buf, v14, &v88, &v86, &object, 0);
  long long v20 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v21 = (std::__shared_weak_count *)a1[82];
  *(_OWORD *)unint64_t v7 = v20;
  if (v21)
  {
    sub_10004D2C8(v21);
    if (buf.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
    }
  }
  if (object) {
    dispatch_release(object);
  }
  if (v87) {
    sub_10004D2C8(v87);
  }
  if (v89) {
    sub_10004D2C8(v89);
  }
  if (!*v7) {
    return;
  }
  memset(&__str, 0, sizeof(__str));
  uint64_t v22 = sub_100365D74();
  sub_100058DB0(&buf, "DataPlanManager::kDataPlanUsed");
  uint64_t v23 = sub_100226284(v22, (void **)&buf.__r_.__value_.__l.__data_, &__str);
  int v24 = v23;
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if (!v24) {
      goto LABEL_149;
    }
  }
  else if (!v23)
  {
    goto LABEL_149;
  }
  int v25 = a1 + 85;
  sub_1011F2D10(a1 + 85);
  unint64_t v26 = 0;
  do
  {
    while (1)
    {
      std::string::size_type v27 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::size_type size = __str.__r_.__value_.__l.__size_;
        if (v26 >= __str.__r_.__value_.__l.__size_) {
          goto LABEL_123;
        }
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      else
      {
        if (v26 >= HIBYTE(__str.__r_.__value_.__r.__words[2])) {
          goto LABEL_123;
        }
        p_str = &__str;
        std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      }
      uint64_t v30 = (char *)p_str + v26;
      char v31 = (char *)p_str + size;
      while (v31 - v30 >= 1)
      {
        uint64_t v32 = memchr(v30, 59, v31 - v30);
        if (!v32) {
          break;
        }
        if (*v32 == 59)
        {
          if (v32 != v31)
          {
            std::string::size_type v33 = v32 - (unsigned char *)p_str;
            if (v32 - (unsigned char *)p_str != -1) {
              goto LABEL_58;
            }
          }
          break;
        }
        uint64_t v30 = v32 + 1;
      }
      std::string::size_type v33 = v27;
      if ((v27 & 0x80) != 0) {
        std::string::size_type v33 = __str.__r_.__value_.__l.__size_;
      }
LABEL_58:
      memset(&__s, 0, sizeof(__s));
      std::string::basic_string(&__s, &__str, v26, v33 - v26, (std::allocator<char> *)&buf);
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
      {
        size_t v34 = __s.__r_.__value_.__l.__size_;
        if ((uint64_t)__s.__r_.__value_.__l.__size_ >= 1)
        {
          p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
          goto LABEL_63;
        }
      }
      else
      {
        size_t v34 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        if (*((unsigned char *)&__s.__r_.__value_.__s + 23))
        {
          p_s = &__s;
LABEL_63:
          int64x2_t v36 = (char *)p_s + v34;
          long long v37 = p_s;
          while (1)
          {
            int v38 = memchr(v37, 58, v34);
            if (!v38) {
              goto LABEL_115;
            }
            if (*v38 == 58) {
              break;
            }
            long long v37 = (std::string *)(v38 + 1);
            size_t v34 = v36 - (unsigned char *)v37;
            if (v36 - (unsigned char *)v37 < 1) {
              goto LABEL_115;
            }
          }
          if (v38 == v36) {
            goto LABEL_115;
          }
          std::string::size_type v39 = v38 - (unsigned char *)p_s;
          if (v38 - (unsigned char *)p_s == -1) {
            goto LABEL_115;
          }
          memset(&v91, 0, sizeof(v91));
          std::string::basic_string(&v91, &__s, 0, v39, (std::allocator<char> *)&buf);
          memset(&v90, 0, sizeof(v90));
          std::string::basic_string(&v90, &__s, v39, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&buf);
          if (!std::string::compare(&v90, ":0"))
          {
            int v42 = 0;
          }
          else if (!std::string::compare(&v90, ":1"))
          {
            int v42 = 1;
          }
          else
          {
            if (std::string::compare(&v90, ":2"))
            {
              int v40 = 0;
              char v41 = 1;
LABEL_111:
              if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v90.__r_.__value_.__l.__data_);
              }
              if ((SHIBYTE(v91.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
                if ((v41 & 1) == 0) {
                  goto LABEL_116;
                }
                goto LABEL_115;
              }
              operator delete(v91.__r_.__value_.__l.__data_);
              if (v41) {
                goto LABEL_115;
              }
              goto LABEL_116;
            }
            int v42 = 2;
          }
          uint64_t v43 = a1[86];
          if ((void *)v43 == v25) {
            goto LABEL_104;
          }
          char v44 = 0;
          std::string::size_type v45 = (v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? HIBYTE(v91.__r_.__value_.__r.__words[2])
              : v91.__r_.__value_.__l.__size_;
          uint64_t v46 = (v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v91
              : (std::string *)v91.__r_.__value_.__r.__words[0];
          do
          {
            uint64_t v47 = *(unsigned __int8 *)(v43 + 39);
            if ((v47 & 0x80u) == 0) {
              uint64_t v48 = *(unsigned __int8 *)(v43 + 39);
            }
            else {
              uint64_t v48 = *(void *)(v43 + 24);
            }
            if (v48 == v45)
            {
              BOOL v49 = (const void **)(v43 + 16);
              if ((v47 & 0x80) != 0)
              {
                BOOL v58 = memcmp(*v49, v46, *(void *)(v43 + 24)) == 0;
              }
              else if (*(unsigned char *)(v43 + 39))
              {
                uint64_t v50 = v47 - 1;
                BOOL v51 = v46;
                do
                {
                  int v53 = *(unsigned __int8 *)v49;
                  BOOL v49 = (const void **)((char *)v49 + 1);
                  int v52 = v53;
                  int v55 = v51->__r_.__value_.__s.__data_[0];
                  BOOL v51 = (std::string *)((char *)v51 + 1);
                  int v54 = v55;
                  BOOL v57 = v50-- != 0;
                  BOOL v58 = v52 == v54;
                }
                while (v58 && v57);
              }
              else
              {
                BOOL v58 = 1;
              }
            }
            else
            {
              BOOL v58 = 0;
            }
            v44 |= v58;
            uint64_t v43 = *(void *)(v43 + 8);
          }
          while ((void *)v43 != v25);
          if ((v44 & 1) == 0)
          {
LABEL_104:
            if (a1[87] > 4uLL)
            {
              char v41 = 0;
              int v40 = 3;
              goto LABEL_111;
            }
            if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&buf, v91.__r_.__value_.__l.__data_, v91.__r_.__value_.__l.__size_);
            }
            else {
              std::string buf = v91;
            }
            int v94 = v42;
            int v59 = (char *)operator new(0x30uLL);
            int v40 = 0;
            *(std::string *)(v59 + 16) = buf;
            *((_DWORD *)v59 + 10) = v42;
            uint64_t v60 = a1[85];
            *(void *)int v59 = v60;
            *((void *)v59 + 1) = v25;
            *(void *)(v60 + 8) = v59;
            a1[85] = v59;
            ++a1[87];
          }
          else
          {
            int v40 = 0;
          }
          char v41 = 1;
          goto LABEL_111;
        }
      }
LABEL_115:
      int v40 = 0;
      unint64_t v26 = v33 + 1;
LABEL_116:
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
        break;
      }
      if (v40) {
        goto LABEL_123;
      }
    }
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  while (!v40);
LABEL_123:
  memset(&buf, 0, sizeof(buf));
  for (uint64_t i = a1[86]; (void *)i != v25; uint64_t i = *(void *)(i + 8))
  {
    if (i != a1[86]) {
      std::string::append(&buf, "; ", 2uLL);
    }
    int v62 = *(char *)(i + 39);
    if (v62 >= 0) {
      int v63 = (const std::string::value_type *)(i + 16);
    }
    else {
      int v63 = *(const std::string::value_type **)(i + 16);
    }
    if (v62 >= 0) {
      std::string::size_type v64 = *(unsigned __int8 *)(i + 39);
    }
    else {
      std::string::size_type v64 = *(void *)(i + 24);
    }
    std::string::append(&buf, v63, v64);
    std::string::append(&buf, ": ", 2uLL);
    unsigned int v65 = *(_DWORD *)(i + 40) + 1;
    long long v66 = "WrongPlanType";
    if (v65 <= 3) {
      long long v66 = off_101A9F0F0[v65];
    }
    size_t v67 = strlen(v66);
    std::string::append(&buf, v66, v67);
  }
  unint64_t v68 = a1[9];
  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
  {
    p_std::string buf = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(__s.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__s.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I DataPlanManagerBootstrap::loadPersistantData_sync:  %s", (uint8_t *)&__s, 0xCu);
  }
  v91.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v70 = sub_100365D74();
  sub_100058DB0(&__s, "DataPlanManager::kDataPlanUsedReported");
  uint64_t v23 = sub_1002260B0(v70, (void **)&__s.__r_.__value_.__l.__data_, (BOOL *)&v91);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  if (!v91.__r_.__value_.__s.__data_[0])
  {
    int v71 = sub_10017B48C();
    v90.__r_.__value_.__s.__data_[0] = v71;
    if (v71 && (void *)a1[86] != v25) {
      sub_1011E57F4();
    }
    long long v72 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&__s, "DataPlanManager::kDataPlanUsedReported");
    uint64_t v23 = sub_1002264FC(v72, &__s, (unsigned __int8 *)&v90);
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
LABEL_149:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (a1[83]) {
    uint64_t v23 = (*(uint64_t (**)(void))(*(void *)*v7 + 120))();
  }
  if (a3)
  {
    if (v80) {
      uint64_t v23 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v7 + 24))(*v7, 1);
    }
    if (v81) {
      uint64_t v23 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v7 + 64))(*v7, 3);
    }
  }
  *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
  sub_1003BEF68((Registry *)v23, &buf);
  std::string::size_type v73 = buf.__r_.__value_.__r.__words[0];
  if (buf.__r_.__value_.__r.__words[0])
  {
    __str.__r_.__value_.__r.__words[0] = 0;
    uint64_t v75 = (std::__shared_weak_count *)a1[11];
    uint64_t v74 = a1[12];
    v83[1] = *((const void **)a1 + 10);
    uint64_t v84 = v75;
    if (v75) {
      atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(std::string *__return_ptr))(*(void *)v74 + 48))(&__str);
    if (v84) {
      sub_10004D2C8(v84);
    }
    if (__str.__r_.__value_.__r.__words[0]) {
      uint64_t v76 = sub_100080778;
    }
    else {
      uint64_t v76 = 0;
    }
    if (v76)
    {
      uint64_t v77 = a1[9];
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__s.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I have provisioning proxy settings", (uint8_t *)&__s, 2u);
      }
    }
    uint64_t v78 = (*(uint64_t (**)(std::string::size_type))(*(void *)v73 + 776))(v73);
    v83[0] = __str.__r_.__value_.__l.__data_;
    if (__str.__r_.__value_.__r.__words[0]) {
      CFRetain(__str.__r_.__value_.__l.__data_);
    }
    (*(void (**)(std::string::size_type, uint64_t, uint64_t, const void **))(*(void *)v73 + 968))(v73, v78, 6, v83);
    sub_100057D78(v83);
    sub_100057D78((const void **)&__str.__r_.__value_.__l.__data_);
  }
  if (buf.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
  }
}

void sub_1011E9120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, dispatch_object_t object, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011E9274(uint64_t a1)
{
  *(void *)a1 = off_101A9E078;
  *(void *)(a1 + 8) = off_101A9E300;
  *(void *)(a1 + 16) = off_101A9E458;
  *(void *)(a1 + 24) = off_101A9E4A8;
  int v2 = (CellularPlanProvisioningMonitorModeDelegate *)(a1 + 32);
  *(void *)(a1 + 32) = off_101A9E548;
  char v3 = *(std::__shared_weak_count **)(a1 + 904);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 888);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 879) < 0) {
    operator delete(*(void **)(a1 + 856));
  }
  if (*(char *)(a1 + 855) < 0) {
    operator delete(*(void **)(a1 + 832));
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 808);
  if (v5) {
    sub_10004D2C8(v5);
  }
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 784);
  if (v6) {
    sub_10004D2C8(v6);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 768);
  if (v7) {
    sub_10004D2C8(v7);
  }
  dispatch_time_t v8 = *(std::__shared_weak_count **)(a1 + 752);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 728);
  if (v9) {
    sub_10004D2C8(v9);
  }
  unsigned int v10 = *(std::__shared_weak_count **)(a1 + 712);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1011F2D10((void *)(a1 + 680));
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 656);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10013C44C(a1 + 584);
  sub_1000346F8(a1 + 560, *(void **)(a1 + 568));
  if (*(unsigned char *)(a1 + 552)) {
    sub_1000C584C(a1 + 336);
  }
  sub_10024D10C(a1 + 312, *(void **)(a1 + 320));
  sub_1000346F8(a1 + 288, *(void **)(a1 + 296));
  if (*(char *)(a1 + 271) < 0) {
    operator delete(*(void **)(a1 + 248));
  }
  uint64_t v16 = (void **)(a1 + 224);
  sub_10008A88C(&v16);
  sub_100600F40((void *)(a1 + 176));
  sub_10030AB98((void *)(a1 + 128));
  unsigned int v12 = *(std::__shared_weak_count **)(a1 + 120);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 88);
  if (v14) {
    sub_10004D2C8(v14);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 72));
  sub_100087E88((void *)(a1 + 40));
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v2);
  return a1;
}

uint64_t sub_1011E9488(uint64_t a1)
{
  return sub_1011E9274(a1 - 8);
}

uint64_t sub_1011E9490(uint64_t a1)
{
  return sub_1011E9274(a1 - 16);
}

uint64_t sub_1011E9498(uint64_t a1)
{
  return sub_1011E9274(a1 - 24);
}

uint64_t sub_1011E94A0(uint64_t a1)
{
  return sub_1011E9274(a1 - 32);
}

void sub_1011E94A8(uint64_t a1)
{
  sub_1011E9274(a1);

  operator delete();
}

void sub_1011E94E0(uint64_t a1)
{
  sub_1011E9274(a1 - 8);

  operator delete();
}

void sub_1011E951C(uint64_t a1)
{
  sub_1011E9274(a1 - 16);

  operator delete();
}

void sub_1011E9558(uint64_t a1)
{
  sub_1011E9274(a1 - 24);

  operator delete();
}

void sub_1011E9594(uint64_t a1)
{
  sub_1011E9274(a1 - 32);

  operator delete();
}

void DataPlanManagerBootstrap::sCreate(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v4 = *a3;
  if (!*a3) {
    __assert_rtn("sCreate", "DataPlanManagerBootstrap.cpp", 347, "\"externalIface is invalid\" && externalIface");
  }
  uint64_t v9 = *a2;
  unsigned int v10 = (char *)operator new(0x3A8uLL);
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  *(void *)unsigned int v10 = off_101A9EF38;
  std::string::size_type v64 = v10 + 24;
  if (v9)
  {
    dispatch_retain(v9);
    uint64_t v4 = *a3;
  }
  uint64_t v11 = (std::__shared_weak_count *)a3[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((void *)v10 + 3) = off_101A67E48;
  *((void *)v10 + 4) = &off_1019DF1A0;
  *((void *)v10 + 5) = off_101A0F5B0;
  *((void *)v10 + 6) = off_1019A37B8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v90, kCtLoggingSystemName, "cdp");
  *((void *)v10 + 8) = 0;
  *((void *)v10 + 9) = 0;
  *((void *)v10 + 10) = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  *((void *)v10 + 11) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v87, &v90);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v10 + 96), (const ctu::OsLogLogger *)&v87);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v87);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v90);
  *((void *)v10 + 3) = off_101A9E078;
  *((void *)v10 + 4) = off_101A9E300;
  *((void *)v10 + 5) = off_101A9E458;
  *((void *)v10 + 6) = off_101A9E4A8;
  *((void *)v10 + 7) = off_101A9E548;
  uint64_t v13 = *(void *)(a1 + 8);
  *((void *)v10 + 13) = *(void *)a1;
  *((void *)v10 + 14) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v10 + 15) = v4;
  *((void *)v10 + 16) = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(v12, "DataPlanManagerBootstrap");
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  v92[0] = 0;
  ctu::RestModule::RestModule();
  if (v92[0]) {
    dispatch_release(v92[0]);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v91 < 0) {
    operator delete(v90.var0);
  }
  int v62 = a4;
  int v63 = a2;
  *(_OWORD *)(v10 + 248) = 0u;
  *((void *)v10 + 22) = 0;
  v10[184] = 0;
  *((_DWORD *)v10 + 48) = 0;
  *((void *)v10 + 28) = 0;
  *((_DWORD *)v10 + 58) = 0;
  *((void *)v10 + 30) = &_mh_execute_header;
  *((_OWORD *)v10 + 20) = 0u;
  *(_OWORD *)(v10 + 264) = 0u;
  *(_OWORD *)(v10 + 280) = 0u;
  *(_OWORD *)(v10 + 296) = 0u;
  *((void *)v10 + 39) = v10 + 320;
  *(_OWORD *)(v10 + 344) = 0u;
  *((void *)v10 + 42) = v10 + 344;
  v10[360] = 0;
  v10[576] = 0;
  *((_OWORD *)v10 + 37) = 0u;
  *((void *)v10 + 73) = v10 + 592;
  MCCAndMNC::MCCAndMNC((MCCAndMNC *)(v10 + 608));
  *((void *)v10 + 86) = 0;
  *((_OWORD *)v10 + 42) = 0u;
  *(void *)(v10 + 693) = 0;
  *((void *)v10 + 88) = v10 + 704;
  *((void *)v10 + 89) = v10 + 704;
  *((void *)v10 + 90) = 0;
  dispatch_object_t v89 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v4 + 16))(v4, &v89);
  if (v89) {
    dispatch_release(v89);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 8);
  uint64_t v87 = *(void *)a1;
  uint64_t v88 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 24))(v4, &v87);
  if (v88) {
    sub_10004D2C8(v88);
  }
  v10[760] = 0;
  *(_WORD *)(v10 + 817) = 0;
  v10[819] = 0;
  *((_OWORD *)v10 + 48) = 0u;
  *((_OWORD *)v10 + 49) = 0u;
  *((_OWORD *)v10 + 50) = 0u;
  Registry::getNotificationSenderFactory((uint64_t *)&v86, *((Registry **)v10 + 13));
  (*(void (**)(char *))(*(void *)v86.var0 + 88))(v86.var0);
  if (v86.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v86.var1.fRef);
  }
  *((void *)v10 + 105) = 0;
  v10[848] = 0;
  *(_OWORD *)(v10 + 856) = 0u;
  *(_OWORD *)(v10 + 872) = 0u;
  *(_OWORD *)(v10 + 888) = 0u;
  uint64_t v15 = *(atomic_ullong **)(a1 + 8);
  v86.var0 = *(char **)a1;
  v86.var1.fRef = (os_log_s *)v15;
  if (v15) {
    atomic_fetch_add_explicit(v15 + 1, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, OsLogContext *))(*(void *)v4 + 40))(v4, &v86);
  if (v86.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v86.var1.fRef);
  }
  *(_OWORD *)(v10 + 920) = 0u;
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v9) {
    dispatch_release(v9);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)v10 + 9);
  if (v16)
  {
    if (v16->__shared_owners_ != -1) {
      goto LABEL_43;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 2, 1uLL, memory_order_relaxed);
    *((void *)v10 + 8) = v64;
    *((void *)v10 + 9) = v10;
    std::__shared_weak_count::__release_weak(v16);
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 2, 1uLL, memory_order_relaxed);
    *((void *)v10 + 8) = v64;
    *((void *)v10 + 9) = v10;
  }
  sub_10004D2C8((std::__shared_weak_count *)v10);
LABEL_43:
  int v17 = (std::__shared_weak_count *)operator new(0x80uLL);
  v17->__shared_owners_ = 0;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EF88;
  uint64_t v18 = v17 + 1;
  CellularPlanSettingsDevice::CellularPlanSettingsDevice((uint64_t)&v17[1], (void *)a1);
  shared_weak_owners = (std::__shared_weak_count *)v17[3].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      goto LABEL_48;
    }
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v17[3].__shared_owners_ = (uint64_t)v18;
    v17[3].__shared_weak_owners_ = (uint64_t)v17;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v17[3].__shared_owners_ = (uint64_t)v18;
    v17[3].__shared_weak_owners_ = (uint64_t)v17;
  }
  sub_10004D2C8(v17);
LABEL_48:
  uint64_t v21 = *(char **)a1;
  long long v20 = *(std::__shared_weak_count **)(a1 + 8);
  uint64_t v22 = (std::__shared_weak_count *)operator new(0x40uLL);
  v22->__shared_owners_ = 0;
  v22->__shared_weak_owners_ = 0;
  v22->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EFD8;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v23 = (std::__shared_weak_count_vtbl *)*((void *)v10 + 93);
  int v24 = (std::__shared_weak_count *)*((void *)v10 + 94);
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A2C140;
  v22[1].__shared_owners_ = (uint64_t)v21;
  v22[1].__shared_weak_owners_ = (uint64_t)v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v22[2].__vftable = v23;
  v22[2].__shared_owners_ = (uint64_t)v24;
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v24);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  unint64_t v85 = *v63;
  int v25 = v85;
  if (v85) {
    dispatch_retain(v85);
  }
  v84[0] = (uint64_t)&v17[1];
  v84[1] = (uint64_t)v17;
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  v83[0] = v22 + 1;
  v83[1] = v22;
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  v82[0] = v10 + 48;
  v82[1] = v10;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 1, 1uLL, memory_order_relaxed);
  unint64_t v26 = *(std::__shared_weak_count **)(a1 + 8);
  v81[0] = *(void *)a1;
  v81[1] = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  InitializeCellularPlan(&v85, v84, (uint64_t)v83, (uint64_t)v82, (uint64_t)v81, &v87);
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_10004D2C8((std::__shared_weak_count *)v10);
  sub_10004D2C8(v22);
  sub_10004D2C8(v17);
  if (v25) {
    dispatch_release(v25);
  }
  uint64_t v28 = v87;
  std::string::size_type v27 = v88;
  if (v88) {
    atomic_fetch_add_explicit(&v88->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((void *)v10 + 96) = v28;
  char v29 = (std::__shared_weak_count *)*((void *)v10 + 97);
  *((void *)v10 + 97) = v27;
  if (v29) {
    sub_10004D2C8(v29);
  }
  v86.var0 = 0;
  v86.var1.fRef = 0;
  dispatch_object_t object = 0;
  int v80 = 0;
  uint64_t v30 = (capabilities::ct *)capabilities::ct::supportsSIMProvisioningAsSignupSource((capabilities::ct *)v29);
  if (!v30)
  {
    if (capabilities::ct::supportsSIMProvisioningAsSignupDestination(v30))
    {
      uint64_t v48 = *v63;
      dispatch_object_t v73 = v48;
      if (v48) {
        dispatch_retain(v48);
      }
      int v71 = v22 + 1;
      long long v72 = v22;
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      ((void (*)(OsLogContext *__return_ptr, std::__shared_weak_count *, dispatch_object_t *, std::__shared_weak_count **))v18->__vftable[12].__on_zero_shared_weak)(&v90, v18, &v73, &v71);
      OsLogContext v49 = v90;
      v90.var0 = 0;
      v90.var1.fRef = 0;
      uint64_t v50 = (std::__shared_weak_count *)*((void *)v10 + 101);
      *((OsLogContext *)v10 + 50) = v49;
      if (v50)
      {
        sub_10004D2C8(v50);
        if (v90.var1.fRef) {
          sub_10004D2C8((std::__shared_weak_count *)v90.var1.fRef);
        }
      }
      if (v72) {
        sub_10004D2C8(v72);
      }
      if (v73) {
        dispatch_release(v73);
      }
    }
    goto LABEL_104;
  }
  char v31 = *v63;
  dispatch_object_t v78 = v31;
  if (v31) {
    dispatch_retain(v31);
  }
  uint64_t v76 = v22 + 1;
  uint64_t v77 = v22;
  atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v74 = v10 + 48;
  uint64_t v75 = (std::__shared_weak_count *)v10;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 1, 1uLL, memory_order_relaxed);
  int v32 = ((uint64_t (*)(std::__shared_weak_count *, dispatch_object_t *, std::__shared_weak_count **, char **, OsLogContext *, dispatch_object_t *))v18->__vftable[12].~__shared_weak_count)(v18, &v78, &v76, &v74, &v86, &object);
  if (v75) {
    sub_10004D2C8(v75);
  }
  if (v77) {
    sub_10004D2C8(v77);
  }
  if (v78) {
    dispatch_release(v78);
  }
  if (!v32) {
    goto LABEL_104;
  }
  var0 = v86.var0;
  fRef = v86.var1.fRef;
  if (v86.var1.fRef) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v86.var1.fRef + 1, 1uLL, memory_order_relaxed);
  }
  *((void *)v10 + 98) = var0;
  uint64_t v35 = (std::__shared_weak_count *)*((void *)v10 + 99);
  *((void *)v10 + 99) = fRef;
  if (v35) {
    sub_10004D2C8(v35);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
  long long v37 = ServiceMap;
  int v38 = "31CellularPlanControllerInterface";
  if (((unint64_t)"31CellularPlanControllerInterface" & 0x8000000000000000) != 0)
  {
    std::string::size_type v39 = (unsigned __int8 *)((unint64_t)"31CellularPlanControllerInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v40 = 5381;
    do
    {
      int v38 = v40;
      unsigned int v41 = *v39++;
      uint64_t v40 = (33 * v40) ^ v41;
    }
    while (v41);
  }
  std::mutex::lock(ServiceMap);
  int v42 = v86.var0;
  uint64_t v43 = v86.var1.fRef;
  OsLogContext v90 = v86;
  if (v86.var1.fRef) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v86.var1.fRef + 1, 1uLL, memory_order_relaxed);
  }
  v92[0] = v38;
  char v44 = v37 + 1;
  if (v42)
  {
    sub_100136784((uint64_t)v44, (unint64_t *)v92, v92, (uint64_t *)&v90);
    char v46 = v45 & 1;
    uint64_t v43 = v90.var1.fRef;
    if (!v90.var1.fRef) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }
  sub_100136C98(v44, (unint64_t *)v92);
  char v46 = 1;
  if (v43) {
LABEL_91:
  }
    sub_10004D2C8((std::__shared_weak_count *)v43);
LABEL_92:
  std::mutex::unlock(v37);
  if ((v46 & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "The given type is already in the map!");
    goto LABEL_144;
  }
LABEL_104:
  BOOL v51 = *(atomic_ullong **)(a1 + 8);
  v90.var0 = *(char **)a1;
  v90.var1.fRef = (os_log_s *)v51;
  if (v51) {
    atomic_fetch_add_explicit(v51 + 1, 1uLL, memory_order_relaxed);
  }
  sub_100EFE570((uint64_t)&v90);
  if (v90.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v90.var1.fRef);
  }
  int v52 = v86.var0;
  if (v28 | (uint64_t)v86.var0)
  {
    uint64_t v69 = v28;
    uint64_t v70 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    size_t v67 = v52;
    unint64_t v68 = (std::__shared_weak_count *)v86.var1.fRef;
    if (v86.var1.fRef) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v86.var1.fRef + 1, 1uLL, memory_order_relaxed);
    }
    dispatch_object_t v65 = object;
    long long v66 = v80;
    if (v80) {
      atomic_fetch_add_explicit(&v80->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100EFE644(&v69, (uint64_t *)&v67, (uint64_t *)&v65);
    if (v66) {
      sub_10004D2C8(v66);
    }
    if (v68) {
      sub_10004D2C8(v68);
    }
    if (v70) {
      sub_10004D2C8(v70);
    }
    if (v28 && *(void *)a1)
    {
      int v53 = (std::mutex *)Registry::getServiceMap(*(Registry **)a1);
      int v54 = v53;
      int v55 = "22CellularPlanController";
      if (((unint64_t)"22CellularPlanController" & 0x8000000000000000) != 0)
      {
        char v56 = (unsigned __int8 *)((unint64_t)"22CellularPlanController" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v57 = 5381;
        do
        {
          int v55 = v57;
          unsigned int v58 = *v56++;
          uint64_t v57 = (33 * v57) ^ v58;
        }
        while (v58);
      }
      std::mutex::lock(v53);
      v90.var0 = (char *)v28;
      v90.var1.fRef = (os_log_s *)v27;
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v92[0] = v55;
      sub_100136784((uint64_t)&v54[1], (unint64_t *)v92, v92, (uint64_t *)&v90);
      char v60 = v59;
      if (v90.var1.fRef) {
        sub_10004D2C8((std::__shared_weak_count *)v90.var1.fRef);
      }
      std::mutex::unlock(v54);
      if ((v60 & 1) == 0)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "The given type is already in the map!");
LABEL_144:
      }
    }
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 2, 1uLL, memory_order_relaxed);
  size_t v61 = (std::__shared_weak_count *)qword_101B14190;
  DataPlanManagerBootstrap::sInstance = (uint64_t)(v10 + 24);
  qword_101B14190 = (uint64_t)v10;
  if (v61) {
    std::__shared_weak_count::__release_weak(v61);
  }
  *int v62 = v10 + 32;
  v62[1] = v10;
  if (v80) {
    sub_10004D2C8(v80);
  }
  if (v86.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v86.var1.fRef);
  }
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_10004D2C8(v22);
  sub_10004D2C8(v17);
}

void sub_1011EA19C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, CellularPlanProvisioningMonitorModeDelegate *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,dispatch_object_t object,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,dispatch_object_t a31,std::__shared_weak_count *a32)
{
  __cxa_free_exception(v32);
  if (a32) {
    sub_10004D2C8(a32);
  }
  std::string::size_type v39 = *(std::__shared_weak_count **)(v37 - 160);
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (v35) {
    sub_10004D2C8(v35);
  }
  sub_10004D2C8(v34);
  sub_10004D2C8(v33);
  sub_10004D2C8(v36);
  _Unwind_Resume(a1);
}

void sub_1011EA4FC(void *a1, char a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011EA618;
  v8[3] = &unk_1019BB378;
  v8[4] = a1;
  char v9 = a2;
  char v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v6 = v5;
  unint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  uint64_t v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_1011EA618(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(v2 + 676) = *(unsigned char *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40)) {
    goto LABEL_30;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 40), *(Registry **)(v2 + 80));
  uint64_t v4 = ServiceMap;
  uint64_t v6 = v5;
  if (v5 < 0)
  {
    unint64_t v7 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v6;
  unsigned int v10 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v11 = 0;
LABEL_10:
  uint64_t v13 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 688))(v12);
  if (v13)
  {
    if (!v11) {
      goto LABEL_30;
    }
LABEL_29:
    sub_10004D2C8(v11);
    goto LABEL_30;
  }
  char v14 = capabilities::ct::supportsGemini(v13);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if ((v14 & 1) == 0)
  {
    uint64_t v15 = *(NSObject **)(v2 + 72);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Enabling cellular data on opening websheet", buf, 2u);
    }
    int v17 = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(v2 + 80));
    uint64_t v18 = v17;
    if (v5 < 0)
    {
      unint64_t v19 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v20 = 5381;
      do
      {
        uint64_t v5 = v20;
        unsigned int v21 = *v19++;
        uint64_t v20 = (33 * v20) ^ v21;
      }
      while (v21);
    }
    std::mutex::lock(v17);
    *(void *)std::string buf = v5;
    uint64_t v22 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
    if (v22)
    {
      uint64_t v23 = v22[3];
      uint64_t v11 = (std::__shared_weak_count *)v22[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v24 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v18);
    uint64_t v11 = 0;
    char v24 = 1;
LABEL_26:
    uint64_t v26 = 0;
    std::string::size_type v27 = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v23 + 72))(v23, 1, 1, &v26);
    if (v27) {
      sub_10004D2C8(v27);
    }
    if ((v24 & 1) == 0) {
      goto LABEL_29;
    }
  }
LABEL_30:
  uint64_t result = *(void *)(v2 + 648);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 72))(result, *(unsigned __int8 *)(a1 + 40));
  }
  return result;
}

void sub_1011EA8A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011EA8DC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 676);
}

uint64_t sub_1011EA8E4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 668);
}

void sub_1011EA8EC(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011EAA04;
  v8[3] = &unk_10199E470;
  v8[4] = a1;
  void v8[5] = a2;
  char v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  unint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  unsigned int v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_1011EAA04(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  v2[83] = *(void *)(a1 + 40);
  uint64_t result = v2[81];
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 120))(result, *(void *)(a1 + 40));
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = v2[102];
  if (v5 != v4 && v4 != 0 && v5 != 0) {
    uint64_t result = __TUAssertTrigger();
  }
  v2[102] = v4;
  return result;
}

void sub_1011EAA84(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)(a1 + 32), *(Registry **)(*(void *)(a1 + 32) + 80));
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v3;
  unint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v11);
  if (v7)
  {
    uint64_t v9 = v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  (*(void (**)(uint64_t, void))(*(void *)v9 + 328))(v9, 0);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_1011EAB94(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EABB4(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011EACCC;
  v8[3] = &unk_101A9E568;
  v8[4] = a2;
  void v8[5] = a1;
  char v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v6 = v5;
  unint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  char v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

void sub_1011EACCC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  memset(v11, 0, 32);
  uint64_t v3 = *(void *)(v2 + 744);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 752);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v3)
  {
    (*(void (**)(void **__return_ptr))(*(void *)v3 + 680))(v9);
    sub_1003464A0((uint64_t)v11, (uint64_t)v9);
    if (LOBYTE(v9[0]) && v10 < 0) {
      operator delete(v9[1]);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    v6[0] = 0;
    if (LOBYTE(v11[0]))
    {
      if (SHIBYTE(v11[3]) < 0)
      {
        sub_10004FC84(&v7, v11[1], (unint64_t)v11[2]);
      }
      else
      {
        long long v7 = *(_OWORD *)&v11[1];
        uint64_t v8 = v11[3];
      }
      v6[0] = 1;
    }
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    v6[0] = 0;
  }
  (*(void (**)(uint64_t, char *))(v5 + 16))(v5, v6);
  if (v6[0])
  {
    if (SHIBYTE(v8) < 0) {
      operator delete((void *)v7);
    }
    v6[0] = 0;
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (LOBYTE(v11[0]))
  {
    if (SHIBYTE(v11[3]) < 0) {
      operator delete(v11[1]);
    }
  }
}

void sub_1011EAE48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (a20)
  {
    if (a26 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EAEB0(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  xpc_object_t v7[2] = sub_1011EAFC8;
  void v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2 || (uint64_t v3 = a1[5], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  unsigned int v6 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_1011EAFC8(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void sub_1011EAFFC(uint64_t a1)
{
}

void sub_1011EB004(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  xpc_object_t v7[2] = sub_1011EB11C;
  void v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2 || (uint64_t v3 = a1[5], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  unsigned int v6 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_1011EB11C(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

void sub_1011EB150(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  xpc_object_t v7[2] = sub_1011EB268;
  void v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2 || (uint64_t v3 = a1[5], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  unsigned int v6 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_1011EB268(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_1011EB29C(uint64_t a1)
{
}

uint64_t sub_1011EB2A4(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1011EB40C;
  v4[3] = &unk_101A9E588;
  v4[4] = a1;
  uint64_t v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1011F5EE0;
  void v6[3] = &unk_1019A11A8;
  void v6[4] = a1 + 40;
  v6[5] = &v5;
  long long v7 = v6;
  uint64_t v2 = a1 + 56;
  char v1 = *(NSObject **)(a1 + 56);
  if (*(void *)(v2 + 8))
  {
    unsigned int v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_1011F5F30;
    unint64_t v11 = &unk_10199E470;
    uint64_t v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    char v10 = sub_1011F5EF4;
    unint64_t v11 = &unk_10199E470;
    uint64_t v12 = &v14;
    uint64_t v13 = &v7;
    dispatch_sync(v1, &block);
  }
  return v14;
}

uint64_t sub_1011EB40C(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 136))();
  }
  return result;
}

void sub_1011EB440(void *a1, NetworkNotification *this)
{
  if (!this)
  {
    char v10 = a1[9];
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(block[0]) = 0;
    unint64_t v11 = "#I Got an empty data plan notification";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)block, 2u);
    return;
  }
  uint64_t v3 = (const void *)NetworkNotification::parsedNotification(this);
  if (!v3)
  {
    char v10 = a1[9];
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(block[0]) = 0;
    unint64_t v11 = "#I Got a data plan notification that could not be parsed properly";
    goto LABEL_12;
  }
  uint64_t v4 = v3;
  unsigned int v14 = v3;
  CFRetain(v3);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3321888768;
  v12[2] = sub_1011EB608;
  v12[3] = &unk_1019FE208;
  v12[4] = a1;
  uint64_t v13 = v4;
  CFRetain(v4);
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (!v5 || (v6 = a1[5], (long long v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  uint64_t v9 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v6;
  uint64_t v16 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v9, block);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10004D2C8(v8);
  sub_100057D78(&v13);
  sub_100057D78(&v14);
}

void sub_1011EB608(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 648);
  uint64_t v4 = *(NSObject **)(v2 + 72);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending data plan notification to the data plan manager", buf, 2u);
      uint64_t v3 = *(void *)(v2 + 648);
    }
    sub_100058198(&v8, (const void **)(a1 + 40));
    char v6 = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v3 + 144))(v3, &v8);
    sub_100057D78(&v8);
    if ((v6 & 1) == 0) {
      sub_1011EB718(v2);
    }
  }
  else if (v5)
  {
    *(_WORD *)long long v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Data plan SMS notification should be ignored because device does not have a valid data plan", v7, 2u);
  }
}

void sub_1011EB704(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1011EB718(uint64_t a1)
{
  uint64_t result = *(const void ***)(a1 + 648);
  if (result)
  {
    CFDataRef data = 0;
    (*((void (**)(CFDataRef *__return_ptr))*result + 24))(&data);
    if (data) {
      uint64_t v3 = sub_10008324C;
    }
    else {
      uint64_t v3 = 0;
    }
    if (!v3)
    {
      unint64_t v11 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(object[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Notification data is null", (uint8_t *)object, 2u);
      }
      return sub_100030068((const void **)&data);
    }
    CFPropertyListFormat format = kCFPropertyListXMLFormat_v1_0;
    CFErrorRef error = 0;
    CFDictionaryRef theDict = 0;
    object[0] = (xpc_object_t)CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, &format, &error);
    sub_100084068(&theDict, (CFTypeRef *)object);
    if (theDict) {
      uint64_t v4 = sub_100080778;
    }
    else {
      uint64_t v4 = 0;
    }
    if (v4)
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
      if (MutableCopy) {
        BOOL v5 = sub_1000C06D0;
      }
      else {
        BOOL v5 = 0;
      }
      if (!v5)
      {
        uint64_t v16 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(object[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Failed to create mutable dictionary from notification dictionary", (uint8_t *)object, 2u);
        }
        goto LABEL_54;
      }
      value = 0;
      sub_1011EC328((const void **)&value, a1);
      if (value) {
        long long v7 = sub_1000810B8;
      }
      else {
        long long v7 = 0;
      }
      if (v7)
      {
        CFDictionarySetValue(MutableCopy, kCTRegistrationCellularDataPlanAccountURL, value);
        sub_100068A94(object);
        int v8 = (*(uint64_t (**)(xpc_object_t))(*(void *)object[0] + 320))(object[0]);
        if (object[1]) {
          sub_10004D2C8((std::__shared_weak_count *)object[1]);
        }
        uint64_t v9 = (const void **)&kCFBooleanTrue;
        if (!v8) {
          uint64_t v9 = (const void **)&kCFBooleanFalse;
        }
        CFDictionarySetValue(MutableCopy, kCTRegistrationCellularDataPlanNewAccount, *v9);
      }
      ctu::cf_to_xpc((uint64_t *)object, MutableCopy, v6);
      xpc_object_t v10 = object[0];
      if (object[0] && xpc_get_type(object[0]) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_retain(v10);
      }
      else {
        xpc_object_t v10 = xpc_null_create();
      }
      xpc_release(object[0]);
      object[0] = v10;
      if (v10)
      {
        xpc_retain(v10);
        xpc_object_t v17 = v10;
      }
      else
      {
        xpc_object_t v17 = xpc_null_create();
        object[0] = v17;
      }
      xpc_object_t v18 = xpc_null_create();
      xpc_object_t v30 = v18;
      sub_1000452AC(95, object, &v30);
      xpc_release(v18);
      xpc_release(v17);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v19, *(Registry **)(a1 + 80));
      unsigned int v21 = ServiceMap;
      if (v22 < 0)
      {
        uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          uint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      object[0] = (xpc_object_t)v22;
      uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, (unint64_t *)object);
      if (v26)
      {
        uint64_t v28 = v26[3];
        std::string::size_type v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v21);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
          if (!v28) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v21);
      std::string::size_type v27 = 0;
      char v29 = 1;
      if (!v28)
      {
LABEL_51:
        if ((v29 & 1) == 0) {
          sub_10004D2C8(v27);
        }
        xpc_release(v10);
        sub_1000558F4((const void **)&value);
LABEL_54:
        sub_10005717C((const void **)&MutableCopy);
        goto LABEL_61;
      }
LABEL_50:
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28 + 464))(v28, 1, 5);
      goto LABEL_51;
    }
    CFMutableDictionaryRef MutableCopy = 0;
    long long v33 = 0uLL;
    if (error)
    {
      CFErrorGetDomain(error);
      memset(object, 0, sizeof(object));
      ctu::cf::assign();
      uint64_t v12 = (CFMutableDictionaryRef *)object[0];
      CFMutableDictionaryRef MutableCopy = (CFMutableDictionaryRef)object[0];
      *(xpc_object_t *)&long long v33 = object[1];
      *(xpc_object_t *)((char *)&v33 + 7) = *(xpc_object_t *)((char *)&object[1] + 7);
      int v13 = SHIBYTE(object[2]);
      HIBYTE(v33) = HIBYTE(object[2]);
      CFRelease(error);
      unsigned int v14 = *(NSObject **)(a1 + 72);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_59;
      }
      if (v13 < 0)
      {
        if ((void)v33) {
          p_CFMutableDictionaryRef MutableCopy = v12;
        }
        else {
          p_CFMutableDictionaryRef MutableCopy = (CFMutableDictionaryRef *)"<null>";
        }
        goto LABEL_58;
      }
      if (v13)
      {
        p_CFMutableDictionaryRef MutableCopy = &MutableCopy;
LABEL_58:
        LODWORD(object[0]) = 136315138;
        *(xpc_object_t *)((char *)object + 4) = p_MutableCopy;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Failed to created the dictionary from notification data, error string is: %s", (uint8_t *)object, 0xCu);
        LOBYTE(v13) = HIBYTE(v33);
LABEL_59:
        if ((v13 & 0x80) != 0) {
          operator delete(MutableCopy);
        }
        goto LABEL_61;
      }
    }
    else
    {
      unsigned int v14 = *(NSObject **)(a1 + 72);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
LABEL_61:
        sub_100057D78((const void **)&theDict);
        return sub_100030068((const void **)&data);
      }
    }
    p_CFMutableDictionaryRef MutableCopy = (CFMutableDictionaryRef *)"<null>";
    goto LABEL_58;
  }
  return result;
}

void sub_1011EBC28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, uint64_t a13, uint64_t a14, const void *a15, uint64_t a16, uint64_t a17, const void *a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  char v27 = v24;
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  xpc_release(v25);
  sub_1000558F4(&a11);
  sub_10005717C(&a12);
  sub_100057D78(&a15);
  sub_100030068(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_1011EBD38(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

uint64_t sub_1011EBD68(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  return result;
}

void sub_1011EBD98(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  xpc_object_t v7[2] = sub_1011EBEB0;
  void v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2 || (uint64_t v3 = a1[5], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  BOOL v5 = v4;
  char v6 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v3;
  uint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

uint64_t sub_1011EBEB0(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 152))();
  }
  return result;
}

uint64_t sub_1011EBEE4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 656);
  *a2 = *(void *)(result + 648);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011EBF04@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 648);
  *a2 = *(void *)(result + 640);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011EBF24(uint64_t a1, uint64_t a2)
{
  BOOL v23 = 0;
  uint64_t v4 = sub_100365D74();
  sub_100058DB0(&__p, "DataPlanManagerBootstrap::kDataPlanThrottled");
  sub_1002260B0(v4, (void **)&__p.__r_.__value_.__l.__data_, &v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  int v5 = *(_DWORD *)(a2 + 32);
  BOOL v22 = (v5 & 0xFF00) == 2048;
  if (v23 && (v5 & 0xFF00) == 0x800)
  {
    char v6 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignoring usage notification in throttled state", (uint8_t *)&__p, 2u);
    }
    return 1;
  }
  uint64_t result = 0;
  if ((v5 & 0x900) != 0 && v23 != ((v5 & 0xFF00) == 2048))
  {
    int v8 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&__p, "DataPlanManagerBootstrap::kDataPlanThrottled");
    sub_1002264FC(v8, &__p, (unsigned __int8 *)&v22);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v9 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (v22) {
        xpc_object_t v10 = "true";
      }
      else {
        xpc_object_t v10 = "false";
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Sending throttle state transition, is throttled:%s", (uint8_t *)&__p, 0xCu);
    }
    __p.__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue((CFMutableDictionaryRef)__p.__r_.__value_.__l.__data_, kCTCellularDataPlanStatusTypeKey, kCTCellularDataPlanSubscriptionStatus);
    if (v22) {
      CFStringRef v11 = @"throttled";
    }
    else {
      CFStringRef v11 = @"subscribed";
    }
    CFDictionarySetValue((CFMutableDictionaryRef)__p.__r_.__value_.__l.__data_, kCTCellularDataPlanSubscriptionStateKey, v11);
    ctu::cf_to_xpc((uint64_t *)&object, (ctu *)__p.__r_.__value_.__l.__data_, v12);
    xpc_object_t v13 = object;
    if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v13);
    }
    else {
      xpc_object_t v13 = xpc_null_create();
    }
    xpc_release(object);
    xpc_object_t object = v13;
    if (v13)
    {
      xpc_retain(v13);
      xpc_object_t v14 = v13;
    }
    else
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t object = v14;
    }
    xpc_object_t v15 = xpc_null_create();
    xpc_object_t v20 = v15;
    sub_1000452AC(95, &object, &v20);
    xpc_release(v15);
    xpc_release(v14);
    xpc_object_t object = 0;
    uint64_t v16 = *(void (****)(void, BOOL, const void **, xpc_object_t *))(a1 + 720);
    BOOL v17 = v22;
    sub_1011EC328(&v19, a1);
    xpc_object_t v18 = object;
    if (object) {
      CFRetain(object);
    }
    (**v16)(v16, v17, &v19, &v18);
    sub_1000558F4((const void **)&v18);
    sub_1000558F4(&v19);
    sub_1000558F4((const void **)&object);
    xpc_release(v13);
    sub_10005717C((const void **)&__p.__r_.__value_.__l.__data_);
    return 1;
  }
  return result;
}

void sub_1011EC26C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EC328(const void **a1, uint64_t a2)
{
  *a1 = 0;
  uint64_t v4 = *(void *)(a2 + 744);
  int v5 = *(std::__shared_weak_count **)(a2 + 752);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4 && (*(unsigned int (**)(uint64_t))(*(void *)v4 + 696))(v4))
  {
    uint64_t v6 = *(void *)(a2 + 744);
    long long v7 = *(std::__shared_weak_count **)(a2 + 752);
    int v8 = 0;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6 && (*(unsigned int (**)(uint64_t))(*(void *)v6 + 696))(v6))
    {
      (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)v6 + 704))(&v9, v6);
      int v8 = v9;
      uint64_t v9 = 0;
      xpc_object_t v10 = 0;
      sub_1000558F4(&v10);
      sub_1000558F4(&v9);
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
    if (&v8 != a1)
    {
      xpc_object_t v10 = *a1;
      *a1 = v8;
      int v8 = 0;
      sub_1000558F4(&v10);
    }
    sub_1000558F4(&v8);
  }
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1011EC498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1000558F4((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000558F4(v3);
  _Unwind_Resume(a1);
}

uint64_t sub_1011EC4D8(uint64_t a1, uint64_t a2)
{
  return sub_1011EBF24(a1 - 8, a2);
}

void sub_1011EC4E0(uint64_t a1, CFAbsoluteTime a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(CFAbsoluteTime *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Triggering data usage query for prepaid alert with timestamp - %f", buf, 0xCu);
  }
  if (CFAbsoluteTimeGetCurrent() + -86400.0 > a2)
  {
    int v5 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Data usage push message timestamp is too old", buf, 2u);
    }
    return;
  }
  *(_OWORD *)std::string buf = 0uLL;
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)"ck_pointerFvNS3_6objectEEEUlS7_E_", *(Registry **)(a1 + 80));
  long long v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v18 = (void *)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v18);
  if (!v12)
  {
    uint64_t v14 = 0;
    goto LABEL_13;
  }
  uint64_t v14 = v12[3];
  xpc_object_t v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_13:
    std::mutex::unlock(v7);
    xpc_object_t v13 = 0;
    char v15 = 1;
    goto LABEL_14;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_14:
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 8))(buf, v14, 1);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (*(void *)buf)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_1011EC7AC;
    v17[3] = &unk_101A9E5A8;
    v17[4] = a1;
    xpc_object_t v18 = v17;
    (*(void (**)(void, uint64_t, uint64_t, void, void **, uint64_t))(**(void **)buf + 256))(*(void *)buf, 3, a1 + 56, 0, &v18, v16);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_1011EC76C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EC7AC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a3)
  {
    if (!qword_101B14190) {
      return;
    }
    int v5 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (!v5) {
      return;
    }
    uint64_t v6 = v5;
    if (!DataPlanManagerBootstrap::sInstance) {
      goto LABEL_47;
    }
    if (*(void *)(v3 + 648))
    {
      if (sub_1011EBF24(v3, a2)) {
        goto LABEL_47;
      }
      if ((*(unsigned char *)(a2 + 36) & 3) != 0)
      {
        __n128 v30 = 0uLL;
        uint64_t v31 = 0;
        sub_10114E1D0(a2, &v30);
        if (v30.n128_u8[8])
        {
          unint64_t v29 = 0xFFFFFFFFLL;
          long long v7 = *(NSObject **)(v3 + 72);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v8 = *(_DWORD *)(a2 + 36);
            int v9 = v8 & 2;
            if (v8) {
              int v9 = 1;
            }
            if ((v8 & 4) != 0) {
              int v10 = 1;
            }
            else {
              int v10 = (v8 >> 2) & 2;
            }
            uint64_t v11 = *(void *)(a2 + 48);
            *(_DWORD *)std::string buf = 67110144;
            *(_DWORD *)&uint8_t buf[4] = v30.n128_u32[1];
            __int16 v33 = 1024;
            unsigned __int32 v34 = v30.n128_u32[0];
            __int16 v35 = 1024;
            int v36 = v9;
            __int16 v37 = 1024;
            int v38 = v10;
            __int16 v39 = 2048;
            uint64_t v40 = v11;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I got data usage push cap:%d used:%d expiry-type:%d renew-type:%d, billing cycle end:%f", buf, 0x24u);
          }
          int v12 = *(_DWORD *)(a2 + 36);
          if ((v12 & 1) == 0)
          {
            xpc_object_t v13 = (const void *)kCTCellularDataPlanTimedPlanUsageCapKey;
            CFStringRef v14 = @"time";
LABEL_30:
            *(void *)std::string buf = 0;
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if ((v12 & 4) != 0) {
              CFBooleanRef v19 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v19 = kCFBooleanFalse;
            }
            *(void *)std::string buf = Mutable;
            CFDictionarySetValue(Mutable, kCTCellularDataPlanAutorenewEnabledKey, v19);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, kCTCellularDataPlanStatusTypeKey, kCTCellularDataPlanUsageStatus);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, kCTCellularDataPlanTypeKey, v14);
            CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, (char *)&v29 + 4);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, kCTCellularDataPlanUsageKey, v28);
            CFNumberRef v27 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v29);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, v13, v27);
            double v21 = *(double *)(a2 + 48);
            if (v21 != 0.0 && (*(_DWORD *)(a2 + 36) & 3) == 2)
            {
              xpc_object_t object = CFDateCreate(kCFAllocatorDefault, v21);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, kCTCellularDataPlanTimedPlanPeriodEndDateKey, object);
              sub_10007CA64((const void **)&object);
            }
            ctu::cf_to_xpc((uint64_t *)&object, *(ctu **)buf, v20);
            xpc_object_t v22 = object;
            if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
              xpc_retain(v22);
            }
            else {
              xpc_object_t v22 = xpc_null_create();
            }
            xpc_release(object);
            xpc_object_t object = v22;
            if (v22)
            {
              xpc_retain(v22);
              xpc_object_t v23 = v22;
            }
            else
            {
              xpc_object_t v23 = xpc_null_create();
              xpc_object_t object = v23;
            }
            xpc_object_t v24 = xpc_null_create();
            xpc_object_t v25 = v24;
            sub_1000452AC(95, &object, &v25);
            xpc_release(v24);
            xpc_release(v23);
            xpc_release(v22);
            sub_1000570E8((const void **)&v27);
            sub_1000570E8((const void **)&v28);
            sub_10005717C((const void **)buf);
            goto LABEL_47;
          }
          unint64_t v29 = v30.n128_u64[0];
          xpc_object_t v13 = (const void *)kCTCellularDataPlanBucketPlanSizeKey;
          if (v30.n128_i32[0] < 1 || (signed __int32)(100 * v30.n128_u32[1]) / (signed __int32)v30.n128_u32[0] > 49)
          {
            CFStringRef v14 = @"bucket";
            goto LABEL_30;
          }
          uint64_t v16 = *(NSObject **)(v3 + 72);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            BOOL v17 = "#I data used not high enough skipping";
            goto LABEL_46;
          }
LABEL_47:
          sub_10004D2C8(v6);
          return;
        }
        uint64_t v16 = *(NSObject **)(v3 + 72);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_47;
        }
        *(_WORD *)std::string buf = 0;
        BOOL v17 = "#I usage message is not the one to be used for alert";
      }
      else
      {
        uint64_t v16 = *(NSObject **)(v3 + 72);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_47;
        }
        *(_WORD *)std::string buf = 0;
        BOOL v17 = "#I got data usage push with unknown expiry type";
      }
    }
    else
    {
      uint64_t v16 = *(NSObject **)(v3 + 72);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_47;
      }
      *(_WORD *)std::string buf = 0;
      BOOL v17 = "#I data plan does not exist, bail usage";
    }
LABEL_46:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, buf, 2u);
    goto LABEL_47;
  }
  char v15 = *(NSObject **)(v3 + 72);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Error while querying entitlements", buf, 2u);
  }
}

void sub_1011ECCAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  unsigned int v8 = va_arg(va3, const void *);
  uint64_t v10 = va_arg(va3, void);
  uint64_t v11 = va_arg(va3, void);
  uint64_t v12 = va_arg(va3, void);
  uint64_t v13 = va_arg(va3, void);
  sub_10007CA64((const void **)va);
  sub_1000570E8((const void **)va1);
  sub_1000570E8((const void **)va2);
  sub_10005717C((const void **)va3);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_1011ECD68(uint64_t a1, uint64_t a2, char a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  char v7 = a3;
  int v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011ECED0(uint64_t a1, uint64_t a2, char a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  char v7 = a3;
  int v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1011ED038(void *a1, uint64_t a2, char a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  _DWORD v9[2] = sub_1011ED154;
  void v9[3] = &unk_101A9E5C8;
  void v9[4] = a1;
  v9[5] = a2;
  char v10 = a3;
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (!v4 || (uint64_t v5 = a1[5], (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  char v7 = v6;
  unsigned int v8 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v5;
  uint64_t v12 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v8, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v7);
}

void sub_1011ED154(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 760);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void))(*(void *)v2 + 224);
    v3();
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v1 + 72);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fCellularPlanControllerPhone is not available!", v5, 2u);
    }
  }
}

void sub_1011ED20C(void *a1)
{
  char v4 = 0;
  int v2 = sub_1011ED278(a1, &v4);
  if (v4) {
    BOOL v3 = v2 == 2;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    sub_1011ED3C8(a1, 2);
  }
}

uint64_t sub_1011ED278(void *a1, unsigned char *a2)
{
  *a2 = 1;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v18 = 0;
  uint64_t v4 = a1[28];
  if (a1[29] != v4)
  {
    if (*(char *)(v4 + 95) < 0)
    {
      sub_10004FC84(__p, *(void **)(v4 + 72), *(void *)(v4 + 80));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v4 + 72);
      uint64_t v18 = *(void *)(v4 + 88);
    }
  }
  uint64_t v5 = a1 + 85;
  uint64_t v6 = (void *)a1[86];
  char v7 = HIBYTE(v18);
  if (v6 == a1 + 85)
  {
LABEL_25:
    uint64_t v15 = 0xFFFFFFFFLL;
    if (v7 < 0) {
      goto LABEL_30;
    }
    return v15;
  }
  if (v18 >= 0) {
    unsigned int v8 = (void *)HIBYTE(v18);
  }
  else {
    unsigned int v8 = __p[1];
  }
  if (v18 >= 0) {
    int v9 = __p;
  }
  else {
    int v9 = (void **)__p[0];
  }
  char v10 = v6;
  while (1)
  {
    uint64_t v11 = *((unsigned __int8 *)v10 + 39);
    if ((v11 & 0x80u) == 0) {
      uint64_t v12 = (void *)*((unsigned __int8 *)v10 + 39);
    }
    else {
      uint64_t v12 = (void *)v10[3];
    }
    if (v12 != v8) {
      goto LABEL_24;
    }
    uint64_t v13 = (const void **)(v10 + 2);
    if ((v11 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v10 + 39)) {
      goto LABEL_27;
    }
    CFStringRef v14 = v9;
    while (*(unsigned __int8 *)v13 == *(unsigned __int8 *)v14)
    {
      uint64_t v13 = (const void **)((char *)v13 + 1);
      CFStringRef v14 = (void **)((char *)v14 + 1);
      if (!--v11) {
        goto LABEL_27;
      }
    }
LABEL_24:
    char v10 = (void *)v10[1];
    if (v10 == v5) {
      goto LABEL_25;
    }
  }
  if (memcmp(*v13, v9, v10[3])) {
    goto LABEL_24;
  }
LABEL_27:
  if (v10 != v6) {
    *a2 = 0;
  }
  uint64_t v15 = *((unsigned int *)v10 + 10);
  if (v7 < 0) {
LABEL_30:
  }
    operator delete(__p[0]);
  return v15;
}

void sub_1011ED3C8(void *a1, int a2)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v35 = 0;
  uint64_t v4 = a1[28];
  if (a1[29] != v4)
  {
    if (*(char *)(v4 + 95) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v4 + 72), *(void *)(v4 + 80));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(v4 + 72);
      uint64_t v35 = *(void *)(v4 + 88);
    }
  }
  uint64_t v5 = a1[9];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2 + 1) > 3) {
      uint64_t v6 = "WrongPlanType";
    }
    else {
      uint64_t v6 = off_101A9F0F0[a2 + 1];
    }
    char v7 = __dst;
    if (v35 < 0) {
      char v7 = (void **)__dst[0];
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I DataPlanManagerBootstrap::handleDataPlanTypeChanged_sync: Type %s. SubscriberID = %s", buf, 0x16u);
  }
  unsigned int v8 = a1 + 85;
  uint64_t v9 = a1[86];
  if ((void *)v9 != a1 + 85)
  {
    if (v35 >= 0) {
      char v10 = (void *)HIBYTE(v35);
    }
    else {
      char v10 = __dst[1];
    }
    if (v35 >= 0) {
      uint64_t v11 = __dst;
    }
    else {
      uint64_t v11 = (void **)__dst[0];
    }
    do
    {
      uint64_t v12 = *(unsigned __int8 *)(v9 + 39);
      if ((v12 & 0x80u) == 0) {
        uint64_t v13 = (void *)*(unsigned __int8 *)(v9 + 39);
      }
      else {
        uint64_t v13 = *(void **)(v9 + 24);
      }
      if (v13 == v10)
      {
        CFStringRef v14 = (const void **)(v9 + 16);
        if ((v12 & 0x80) != 0)
        {
          if (!memcmp(*v14, v11, *(void *)(v9 + 24)))
          {
LABEL_32:
            uint64_t v16 = a1[9];
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 136315138;
              *(void *)&uint8_t buf[4] = v11;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I DataPlanManagerBootstrap::updateSubscriber_sync: removing subscriber %s for reinsertion to the front", buf, 0xCu);
            }
            BOOL v17 = *(void **)v9;
            v17[1] = *(void *)(v9 + 8);
            **(void **)(v9 + 8) = v17;
            --a1[87];
            sub_1011F2D74((void **)v9);
            break;
          }
        }
        else
        {
          if (!*(unsigned char *)(v9 + 39)) {
            goto LABEL_32;
          }
          uint64_t v15 = v11;
          while (*(unsigned __int8 *)v14 == *(unsigned __int8 *)v15)
          {
            CFStringRef v14 = (const void **)((char *)v14 + 1);
            uint64_t v15 = (void **)((char *)v15 + 1);
            if (!--v12) {
              goto LABEL_32;
            }
          }
        }
      }
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while ((void *)v9 != v8);
  }
  unint64_t v18 = a1[87];
  if (v18 >= 5)
  {
    uint64_t v19 = a1[85];
    xpc_object_t v20 = *(void **)v19;
    v20[1] = *(void *)(v19 + 8);
    **(void **)(v19 + 8) = v20;
    a1[87] = v18 - 1;
    sub_1011F2D74((void **)v19);
  }
  if (SHIBYTE(v35) < 0)
  {
    sub_10004FC84(buf, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__dst;
    *(void *)&uint8_t buf[16] = v35;
  }
  *(_DWORD *)&uint8_t buf[24] = a2;
  double v21 = operator new(0x30uLL);
  v21[1] = *(_OWORD *)buf;
  *((void *)v21 + 4) = *(void *)&buf[16];
  memset(buf, 0, 24);
  *((_DWORD *)v21 + 10) = a2;
  xpc_object_t v22 = (void *)a1[86];
  *(void *)double v21 = v8;
  *((void *)v21 + 1) = v22;
  *xpc_object_t v22 = v21;
  a1[86] = v21;
  ++a1[87];
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  int v23 = sub_10017B48C();
  unsigned __int8 v33 = v23;
  if (v23) {
    sub_1011E57F4();
  }
  xpc_object_t v24 = (uint64_t **)sub_100365D74();
  sub_100058DB0(buf, "DataPlanManager::kDataPlanUsedReported");
  sub_1002264FC(v24, (std::string *)buf, &v33);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v54 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004DE24((uint64_t)buf);
  for (uint64_t i = a1[86]; (void *)i != v8; uint64_t i = *(void *)(i + 8))
  {
    if (i != a1[86]) {
      sub_10004B96C(buf, (uint64_t)";", 1);
    }
    int v26 = *(char *)(i + 39);
    if (v26 >= 0) {
      uint64_t v27 = i + 16;
    }
    else {
      uint64_t v27 = *(void *)(i + 16);
    }
    if (v26 >= 0) {
      uint64_t v28 = *(unsigned __int8 *)(i + 39);
    }
    else {
      uint64_t v28 = *(void *)(i + 24);
    }
    unint64_t v29 = sub_10004B96C(buf, v27, v28);
    sub_10004B96C(v29, (uint64_t)":", 1);
    std::ostream::operator<<();
  }
  __n128 v30 = a1[9];
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[8], &__p);
    uint64_t v31 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)__int16 v37 = 136315138;
    *(void *)&v37[4] = v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I DataPlanManagerBootstrap::savePersistantData_sync:  %s", v37, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  int v32 = (uint64_t **)sub_100365D74();
  sub_100058DB0(&__p, "DataPlanManager::kDataPlanUsed");
  sub_10004BC98((uint64_t)&buf[8], v37);
  sub_1002266A4(v32, &__p, (uint64_t)v37);
  if (v38 < 0) {
    operator delete(*(void **)v37);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43) < 0) {
    operator delete(*((void **)&v42 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  if (SHIBYTE(v35) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_1011ED980(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

void sub_1011EDA14(uint64_t a1)
{
}

void sub_1011EDA1C(void *a1)
{
  char v4 = 0;
  int v2 = sub_1011ED278(a1, &v4);
  int v3 = v2;
  if (v4)
  {
    if ((v2 + 1) > 1) {
      return;
    }
    int v3 = 1;
  }

  sub_1011ED3C8(a1, v3);
}

void sub_1011EDA90(uint64_t a1)
{
}

void sub_1011EDA98(void *a1)
{
  char v4 = 0;
  int v2 = sub_1011ED278(a1, &v4);
  if (v4) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    sub_1011ED3C8(a1, 0);
  }
}

void sub_1011EDB04(uint64_t a1)
{
}

const void **sub_1011EDB0C(uint64_t a1)
{
  return sub_1011EB718(a1 - 8);
}

uint64_t sub_1011EDB14(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 96))(result);
    if (result) {
      return *(_DWORD *)(a1 + 216) == 2;
    }
  }
  return result;
}

uint64_t sub_1011EDB70(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 96))(result);
    if (result) {
      return *(_DWORD *)(a1 + 208) == 2;
    }
  }
  return result;
}

uint64_t sub_1011EDBCC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 648);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 56))();
  }
  else {
    return 1;
  }
}

uint64_t sub_1011EDC00(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 640);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 56))();
  }
  else {
    return 1;
  }
}

uint64_t sub_1011EDC34(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 256))();
  }
  return result;
}

uint64_t sub_1011EDC6C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 256))();
  }
  return result;
}

uint64_t sub_1011EDCA4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

uint64_t sub_1011EDCDC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

uint64_t sub_1011EDD14(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 304))();
  }
  return result;
}

uint64_t sub_1011EDD4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 304))();
  }
  return result;
}

uint64_t sub_1011EDD84(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

uint64_t sub_1011EDDBC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  return result;
}

void sub_1011EDDF4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[81];
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, a2);
  }
  uint64_t v5 = a1[93];
  uint64_t v6 = (std::__shared_weak_count *)a1[94];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 656))(v5, a2);
  }
  if (v6)
  {
    sub_10004D2C8(v6);
  }
}

void sub_1011EDEB8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EDED0(uint64_t a1, uint64_t a2)
{
}

void sub_1011EDED8(uint64_t a1, int a2)
{
  if (a2 == -2)
  {
    BOOL v3 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Internet activate failed while roaming in monitor mode", buf, 2u);
    }
    uint64_t v4 = *(void *)(a1 + 720);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    void v5[2] = sub_1011EDFF8;
    v5[3] = &unk_101A9E5E8;
    v5[4] = a1;
    long long aBlock = _Block_copy(v5);
    (*(void (**)(uint64_t, void **))(*(void *)v4 + 64))(v4, &aBlock);
    if (aBlock) {
      _Block_release(aBlock);
    }
  }
}

void sub_1011EDFD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EDFF8(uint64_t a1, char a2)
{
  int v2 = *(void **)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011EE114;
  v8[3] = &unk_1019BB378;
  v8[4] = v2;
  char v9 = a2;
  BOOL v3 = (std::__shared_weak_count *)v2[6];
  if (!v3 || (uint64_t v4 = v2[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  char v7 = v2[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  uint64_t v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_1011EE114(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 40)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    *(_DWORD *)uint64_t v19 = 136315138;
    *(void *)&v19[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I user enabled roaming? %s:", v19, 0xCu);
  }
  uint64_t v5 = *(void *)(v2 + 648);
  if (v5 && (*(unsigned int (**)(uint64_t))(*(void *)v5 + 88))(v5))
  {
    if (*(unsigned char *)(a1 + 40))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 40), *(Registry **)(v2 + 80));
      char v7 = ServiceMap;
      if (v8 < 0)
      {
        char v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          uint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      *(void *)uint64_t v19 = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v19);
      if (v12)
      {
        CFStringRef v14 = (RoamingInterface *)v12[3];
        uint64_t v13 = (std::__shared_weak_count *)v12[4];
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          char v15 = 0;
LABEL_23:
          RoamingInterface::setDataRoamingSetting(v14, 1);
          if ((v15 & 1) == 0) {
            sub_10004D2C8(v13);
          }
          unint64_t v18 = *(NSObject **)(v2 + 72);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v19 = 0;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Did enable roaming from Alert", v19, 2u);
          }
          return;
        }
      }
      else
      {
        CFStringRef v14 = 0;
      }
      std::mutex::unlock(v7);
      uint64_t v13 = 0;
      char v15 = 1;
      goto LABEL_23;
    }
    (*(void (**)(void, void))(**(void **)(v2 + 648) + 184))(*(void *)(v2 + 648), 0);
    uint64_t v16 = *(void *)(v2 + 744);
    BOOL v17 = *(std::__shared_weak_count **)(v2 + 752);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v16) {
      (*(void (**)(uint64_t, void))(*(void *)v16 + 736))(v16, 0);
    }
    if (v17) {
      sub_10004D2C8(v17);
    }
  }
}

void sub_1011EE38C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EE3CC(uint64_t a1, int a2)
{
}

uint64_t sub_1011EE3D4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 336))();
  }
  return result;
}

uint64_t sub_1011EE40C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 336))();
  }
  return result;
}

uint64_t sub_1011EE444(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t sub_1011EE474(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t sub_1011EE4A4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  return result;
}

uint64_t sub_1011EE4D4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  return result;
}

uint64_t sub_1011EE504(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(void *)(a1 + 744);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 752);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    int v73 = 0;
    int v6 = (*(uint64_t (**)(uint64_t, int *))(*(void *)v4 + 632))(v4, &v73);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 80));
    char v9 = ServiceMap;
    if (v10 < 0)
    {
      unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v10;
    CFStringRef v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      char v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v18 = 0;
        if (!v16)
        {
LABEL_14:
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          if (v6) {
            goto LABEL_17;
          }
          xpc_object_t v22 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 80));
          int v23 = v22;
          if (v24 < 0)
          {
            xpc_object_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v26 = 5381;
            do
            {
              uint64_t v24 = v26;
              unsigned int v27 = *v25++;
              uint64_t v26 = (33 * v26) ^ v27;
            }
            while (v27);
          }
          std::mutex::lock(v22);
          *(void *)std::string buf = v24;
          uint64_t v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)buf);
          if (v28)
          {
            uint64_t v30 = v28[3];
            unint64_t v29 = (std::__shared_weak_count *)v28[4];
            if (v29)
            {
              atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v23);
              atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v29);
              char v31 = 0;
              if (!v30)
              {
LABEL_33:
                if ((v31 & 1) == 0) {
                  sub_10004D2C8(v29);
                }
                if (!v73)
                {
LABEL_159:
                  uint64_t v20 = 0;
                  if (!v5) {
                    return v20;
                  }
                  goto LABEL_19;
                }
                *a2 = 1;
                uint64_t v32 = *(void *)(a1 + 296);
                if (!v32) {
                  goto LABEL_47;
                }
                uint64_t v33 = a1 + 296;
                do
                {
                  int v34 = *(_DWORD *)(v32 + 28);
                  BOOL v35 = v34 < 1;
                  if (v34 >= 1) {
                    int v36 = (uint64_t *)v32;
                  }
                  else {
                    int v36 = (uint64_t *)(v32 + 8);
                  }
                  if (!v35) {
                    uint64_t v33 = v32;
                  }
                  uint64_t v32 = *v36;
                }
                while (*v36);
                if (v33 == a1 + 296 || *(int *)(v33 + 28) > 1) {
LABEL_47:
                }
                  uint64_t v37 = 0;
                else {
                  uint64_t v37 = *(unsigned __int8 *)(v33 + 32);
                }
                char v38 = *(NSObject **)(a1 + 72);
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I posting activation failure", buf, 2u);
                }
                __int16 v39 = (char *)asDataActivateFailureReason();
                sub_100058DB0(v71, v39);
                v92[0] = @"kCTRegistrationDataContextID";
                *(void *)std::string buf = +[NSNumber numberWithInt:0];
                v92[1] = @"kCTRegistrationDataActive";
                int v94 = +[NSNumber numberWithInt:0];
                dispatch_object_t v92[2] = @"kCTRegistrationDataAttached";
                unint64_t v95 = +[NSNumber numberWithInt:v37];
                v92[3] = @"kCTRegistrationDataActivateFailure";
                char v96 = +[NSNumber numberWithInt:18];
                CFStringRef v97 = @"kCTErrorRequestedFacilityNotSubscribed";
                v92[4] = @"kCTRegistrationDataActivateFailureString";
                v92[5] = @"kCTRegistrationDataActivationPreventionReason";
                v92[6] = @"kCTRegistrationDataConnectionServices";
                CFStringRef v98 = @"Unknown reason";
                int v99 = &off_101AE7EB0;
                long long v41 = +[NSDictionary dictionaryWithObjects:buf forKeys:v92 count:7];
                uint64_t v42 = *(void *)(a1 + 704);
                BOOL v48 = 0;
                if (v42 && ((*(uint64_t (**)(uint64_t))(*(void *)v42 + 32))(v42) & 1) == 0)
                {
                  int v43 = (char)v72;
                  long long v44 = (v72 & 0x80u) == 0 ? (void *)v72 : v71[1];
                  if (v44 == (void *)strlen(kDataActivateFailureReasonDataPlanExpiredSequoia)
                    && ((v72 & 0x80u) == 0 ? (long long v45 = v71) : (long long v45 = (void **)v71[0]),
                        !memcmp(v45, kDataActivateFailureReasonDataPlanExpiredSequoia, (size_t)v44))
                    || v44 == (void *)strlen(kDataActivateFailureReasonDataPlanNoExistingPlan)
                    && (v43 >= 0 ? (long long v46 = v71) : (long long v46 = (void **)v71[0]),
                        !memcmp(v46, kDataActivateFailureReasonDataPlanNoExistingPlan, (size_t)v44))
                    || v44 == (void *)strlen(kDataActivateFailureReasonDataPlanUnusableProfile)
                    && (v43 >= 0 ? (long long v47 = v71) : (long long v47 = (void **)v71[0]),
                        !memcmp(v47, kDataActivateFailureReasonDataPlanUnusableProfile, (size_t)v44)))
                  {
                    BOOL v48 = 1;
                  }
                }
                dispatch_object_t v89 = v41;
                if (v41)
                {
                  CFRetain(v41);
                  long long v49 = (ctu *)v89;
                }
                else
                {
                  long long v49 = 0;
                }
                ctu::cf_to_xpc((uint64_t *)&object, v49, v40);
                xpc_object_t v50 = (xpc_object_t)object;
                if ((void)object && xpc_get_type((xpc_object_t)object) == (xpc_type_t)&_xpc_type_dictionary) {
                  xpc_retain(v50);
                }
                else {
                  xpc_object_t v50 = xpc_null_create();
                }
                xpc_release((xpc_object_t)object);
                *(void *)&long long object = v50;
                if (v50)
                {
                  xpc_retain(v50);
                  xpc_object_t v51 = v50;
                }
                else
                {
                  xpc_object_t v51 = xpc_null_create();
                  *(void *)&long long object = v51;
                }
                xpc_object_t v52 = xpc_null_create();
                __p[0] = v52;
                sub_1000452AC(52, (xpc_object_t *)&object, __p);
                xpc_release(v52);
                xpc_release(v51);
                uint64_t v53 = *(void *)(a1 + 744);
                uint64_t v54 = *(std::__shared_weak_count **)(a1 + 752);
                if (v54) {
                  atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v88 = 0;
                if (v53)
                {
                  (*(void (**)(xpc_object_t *__return_ptr))(*(void *)v53 + 688))(__p);
                  *(void *)&long long object = v88;
                  uint64_t v88 = (ctu *)__p[0];
                  __p[0] = 0;
                  sub_100030068((const void **)&object);
                  sub_100030068((const void **)__p);
                }
                xpc_object_t v87 = 0;
                xpc_object_t v55 = xpc_dictionary_create(0, 0, 0);
                xpc_object_t v56 = v55;
                if (v55)
                {
                  xpc_object_t v87 = v55;
                }
                else
                {
                  xpc_object_t v56 = xpc_null_create();
                  xpc_object_t v87 = v56;
                  if (!v56)
                  {
                    xpc_object_t v57 = xpc_null_create();
                    xpc_object_t v56 = 0;
                    goto LABEL_93;
                  }
                }
                if (xpc_get_type(v56) == (xpc_type_t)&_xpc_type_dictionary)
                {
                  xpc_retain(v56);
LABEL_94:
                  xpc_release(v56);
                  xpc_object_t v85 = xpc_BOOL_create(1);
                  if (!v85) {
                    xpc_object_t v85 = xpc_null_create();
                  }
                  *(void *)&long long object = &v87;
                  *((void *)&object + 1) = kDataActivateFailureDueToDataPlanKey;
                  sub_100035E70((uint64_t)&object, &v85, &v86);
                  xpc_release(v86);
                  xpc_object_t v86 = 0;
                  xpc_release(v85);
                  xpc_object_t v85 = 0;
                  if (v48)
                  {
                    xpc_object_t v84 = xpc_string_create(kDataActivateFailureReasonDataPlanConnectToWifi);
                    if (!v84) {
                      xpc_object_t v84 = xpc_null_create();
                    }
                    *(void *)&long long object = &v87;
                    *((void *)&object + 1) = kDataActivateFailureReasonKey;
                    sub_100035E70((uint64_t)&object, &v84, __p);
                    xpc_release(__p[0]);
                    __p[0] = 0;
                    xpc_release(v84);
                    xpc_object_t v84 = 0;
                    *(void *)&long long object = v50;
                    if (v50) {
                      xpc_retain(v50);
                    }
                    else {
                      *(void *)&long long object = xpc_null_create();
                    }
                    xpc_object_t v83 = v87;
                    if (v87) {
                      xpc_retain(v87);
                    }
                    else {
                      xpc_object_t v83 = xpc_null_create();
                    }
                    long long v66 = *(Registry **)(a1 + 80);
                    size_t v67 = *(std::__shared_weak_count **)(a1 + 88);
                    if (v67) {
                      unint64_t add_explicit = (uint64_t *)atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    sub_1011E5A4C(v66, (uint64_t)&object, (uint64_t)&v83, add_explicit);
                    if (v67) {
                      sub_10004D2C8(v67);
                    }
                    xpc_release(v83);
                    xpc_release((xpc_object_t)object);
                  }
                  else
                  {
                    if ((v72 & 0x80u) == 0) {
                      unsigned int v58 = v71;
                    }
                    else {
                      unsigned int v58 = (void **)v71[0];
                    }
                    xpc_object_t v83 = xpc_string_create((const char *)v58);
                    if (!v83) {
                      xpc_object_t v83 = xpc_null_create();
                    }
                    *(void *)&long long object = &v87;
                    *((void *)&object + 1) = kDataActivateFailureReasonKey;
                    sub_100035E70((uint64_t)&object, &v83, &v84);
                    xpc_release(v84);
                    xpc_object_t v84 = 0;
                    xpc_release(v83);
                    xpc_object_t v83 = 0;
                    if (v88) {
                      char v60 = sub_10008324C;
                    }
                    else {
                      char v60 = 0;
                    }
                    if (v60)
                    {
                      ctu::cf_to_xpc((uint64_t *)&v81, v88, v59);
                      *(void *)&long long object = &v87;
                      *((void *)&object + 1) = "DataPlanCsn";
                      sub_100035E70((uint64_t)&object, &v81, &v82);
                      xpc_release(v82);
                      xpc_object_t v82 = 0;
                      xpc_release(v81);
                      xpc_object_t v81 = 0;
                    }
                    sub_1011F0A10((const void **)&object, *(void *)(a1 + 744), *(std::__shared_weak_count **)(a1 + 752));
                    if ((void)object) {
                      size_t v61 = sub_1000810B8;
                    }
                    else {
                      size_t v61 = 0;
                    }
                    sub_1000558F4((const void **)&object);
                    if (v61)
                    {
                      sub_1011F0A10((const void **)&v76, *(void *)(a1 + 744), *(std::__shared_weak_count **)(a1 + 752));
                      long long object = 0uLL;
                      uint64_t v91 = 0;
                      ctu::cf::assign();
                      *(_OWORD *)std::string __p = object;
                      uint64_t v78 = v91;
                      if (v91 >= 0) {
                        int v62 = __p;
                      }
                      else {
                        int v62 = (xpc_object_t *)__p[0];
                      }
                      xpc_object_t v79 = xpc_string_create((const char *)v62);
                      if (!v79) {
                        xpc_object_t v79 = xpc_null_create();
                      }
                      *(void *)&long long object = &v87;
                      *((void *)&object + 1) = "DataPlanIccid";
                      sub_100035E70((uint64_t)&object, &v79, &v80);
                      xpc_release(v80);
                      xpc_object_t v80 = 0;
                      xpc_release(v79);
                      xpc_object_t v79 = 0;
                      if (SHIBYTE(v78) < 0) {
                        operator delete(__p[0]);
                      }
                      sub_1000558F4((const void **)&v76);
                    }
                    sub_1011EC328((const void **)&object, a1);
                    if ((void)object) {
                      int v63 = sub_1000810B8;
                    }
                    else {
                      int v63 = 0;
                    }
                    sub_1000558F4((const void **)&object);
                    if (v63)
                    {
                      sub_1011EC328(&v74, a1);
                      long long object = 0uLL;
                      uint64_t v91 = 0;
                      ctu::cf::assign();
                      *(_OWORD *)std::string __p = object;
                      uint64_t v78 = v91;
                      if (v91 >= 0) {
                        std::string::size_type v64 = __p;
                      }
                      else {
                        std::string::size_type v64 = (xpc_object_t *)__p[0];
                      }
                      xpc_object_t v75 = xpc_string_create((const char *)v64);
                      if (!v75) {
                        xpc_object_t v75 = xpc_null_create();
                      }
                      *(void *)&long long object = &v87;
                      *((void *)&object + 1) = "DataPlanUrl";
                      sub_100035E70((uint64_t)&object, &v75, &v76);
                      xpc_release(v76);
                      xpc_object_t v76 = 0;
                      xpc_release(v75);
                      xpc_object_t v75 = 0;
                      if (SHIBYTE(v78) < 0) {
                        operator delete(__p[0]);
                      }
                      sub_1000558F4(&v74);
                    }
                    *(void *)&long long object = v50;
                    if (v50) {
                      xpc_retain(v50);
                    }
                    else {
                      *(void *)&long long object = xpc_null_create();
                    }
                    __p[0] = v87;
                    if (v87) {
                      xpc_retain(v87);
                    }
                    else {
                      __p[0] = xpc_null_create();
                    }
                    uint64_t v69 = *(Registry **)(a1 + 80);
                    uint64_t v70 = *(std::__shared_weak_count **)(a1 + 88);
                    if (v70) {
                      unint64_t v68 = (uint64_t *)atomic_fetch_add_explicit(&v70->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    sub_1011E5A4C(v69, (uint64_t)&object, (uint64_t)__p, v68);
                    if (v70) {
                      sub_10004D2C8(v70);
                    }
                    xpc_release(__p[0]);
                    xpc_release((xpc_object_t)object);
                  }
                  xpc_release(v87);
                  sub_100030068((const void **)&v88);
                  if (v54) {
                    sub_10004D2C8(v54);
                  }
                  xpc_release(v50);
                  sub_100057D78((const void **)&v89);
                  if ((char)v72 < 0) {
                    operator delete(v71[0]);
                  }
                  goto LABEL_159;
                }
                xpc_object_t v57 = xpc_null_create();
LABEL_93:
                xpc_object_t v87 = v57;
                goto LABEL_94;
              }
LABEL_32:
              (*(void (**)(uint64_t, void, uint64_t))(*(void *)v30 + 464))(v30, 0, 5);
              goto LABEL_33;
            }
          }
          else
          {
            uint64_t v30 = 0;
          }
          std::mutex::unlock(v23);
          unint64_t v29 = 0;
          char v31 = 1;
          if (!v30) {
            goto LABEL_33;
          }
          goto LABEL_32;
        }
LABEL_13:
        (*(void (**)(uint64_t, void))(*(void *)v16 + 72))(v16, v6 ^ 1u);
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    char v15 = 0;
    char v18 = 1;
    if (!v16) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_17:
  uint64_t v19 = *(void *)(a1 + 648);
  if (!v19)
  {
    uint64_t v20 = 1;
    if (!v5) {
      return v20;
    }
    goto LABEL_19;
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v19 + 296))(v19, a2);
  if (v5) {
LABEL_19:
  }
    sub_10004D2C8(v5);
  return v20;
}

void sub_1011EF068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, xpc_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,xpc_object_t a27,uint64_t a28,uint64_t a29,uint64_t a30,xpc_object_t object,char a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011EF29C(uint64_t a1, unsigned char *a2)
{
  return sub_1011EE504(a1 - 8, a2);
}

uint64_t sub_1011EF2A4(capabilities::ct *a1)
{
  LODWORD(v2) = capabilities::ct::supportsDataPlanNotifications(a1);
  if (v2)
  {
    uint64_t v2 = *((void *)a1 + 81);
    if (v2) {
      LODWORD(v2) = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 96))(v2);
    }
  }
  uint64_t v3 = *((void *)a1 + 93);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)a1 + 94);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v3)
  {
LABEL_9:
    if (!v2) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  if ((v2 & 1) == 0)
  {
    LODWORD(v2) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 664))(v3);
    goto LABEL_9;
  }
LABEL_10:
  uint64_t v5 = *((void *)a1 + 9);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I run activate mechanism for failing socket", buf, 2u);
  }
  char v8 = 0;
  sub_1011EE504((uint64_t)a1, &v8);
  if (v8)
  {
    uint64_t v6 = 1;
    if (!v4) {
      return v6;
    }
    goto LABEL_16;
  }
LABEL_15:
  uint64_t v6 = 0;
  if (v4) {
LABEL_16:
  }
    sub_10004D2C8(v4);
  return v6;
}

void sub_1011EF3D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011EF3EC(uint64_t a1)
{
  return sub_1011EF2A4((capabilities::ct *)(a1 - 8));
}

uint64_t sub_1011EF3F4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 648);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

uint64_t sub_1011EF424(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 640);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 208))();
  }
  return result;
}

void sub_1011EF454(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 720) + 160))(*(void *)(a1 + 720));
  uint64_t v5 = *(void *)(a1 + 744);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 752);
  if (v6) {
    unint64_t add_explicit = (uint64_t *)atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 640))(v5, a2);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(add_explicit, *(Registry **)(a1 + 80));
  char v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v17);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_13:
    std::mutex::unlock(v8);
    CFStringRef v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v15 = v13[3];
  CFStringRef v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (v15) {
LABEL_14:
  }
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v15 + 464))(v15, 0, 5);
LABEL_15:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_1011EF5F4(_Unwind_Exception *exception_object)
{
  char v4 = v2;
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EF62C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1011EF634(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[93];
  char v4 = (std::__shared_weak_count *)a1[94];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v3)
  {
    uint64_t v7 = 0;
    if (!v4) {
      return v7;
    }
    goto LABEL_10;
  }
  uint64_t v5 = a1[81];
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 88))(v5);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 712))(v3, v6, a2);
  if (v4) {
LABEL_10:
  }
    sub_10004D2C8(v4);
  return v7;
}

void sub_1011EF704(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011EF71C(uint64_t a1, uint64_t a2)
{
  return sub_1011EF634((void *)(a1 - 8), a2);
}

uint64_t sub_1011EF724(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 744);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 752);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v2)
  {
    uint64_t v4 = 0;
    if (!v3) {
      return v4;
    }
    goto LABEL_5;
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 728))(v2);
  if (v3) {
LABEL_5:
  }
    sub_10004D2C8(v3);
  return v4;
}

void sub_1011EF7AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011EF7C4(uint64_t a1)
{
  return sub_1011EF724(a1 - 8);
}

void sub_1011EF7CC(uint64_t a1)
{
  if (*(void *)(a1 + 880))
  {
    char v2 = *(unsigned char *)(a1 + 855);
    if (v2 < 0)
    {
      if (!*(void *)(a1 + 840)) {
        return;
      }
    }
    else if (!*(unsigned char *)(a1 + 855))
    {
      return;
    }
    uint64_t v3 = (const void **)(a1 + 832);
    uint64_t v4 = *(void *)(a1 + 224);
    uint64_t v5 = *(void *)(a1 + 232);
    if (v4 != v5)
    {
      if (v2 >= 0) {
        uint64_t v6 = *(unsigned __int8 *)(a1 + 855);
      }
      else {
        uint64_t v6 = *(void *)(a1 + 840);
      }
      while (1)
      {
        uint64_t v7 = *(unsigned __int8 *)(v4 + 95);
        if ((v7 & 0x80u) == 0) {
          uint64_t v8 = *(unsigned __int8 *)(v4 + 95);
        }
        else {
          uint64_t v8 = *(void *)(v4 + 80);
        }
        if (v8 != v6) {
          goto LABEL_27;
        }
        if (v2 >= 0) {
          unint64_t v9 = (unsigned __int8 *)(a1 + 832);
        }
        else {
          unint64_t v9 = (unsigned __int8 *)*v3;
        }
        if ((v7 & 0x80) != 0)
        {
          if (memcmp(*(const void **)(v4 + 72), v9, *(void *)(v4 + 80))) {
            goto LABEL_27;
          }
        }
        else if (*(unsigned char *)(v4 + 95))
        {
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v4 + v10 + 72) == v9[v10])
          {
            if (v7 == ++v10) {
              goto LABEL_24;
            }
          }
          goto LABEL_27;
        }
LABEL_24:
        uint64_t v11 = *(unsigned __int8 *)(v4 + 119);
        if ((v11 & 0x80u) != 0) {
          uint64_t v11 = *(void *)(v4 + 104);
        }
        if (v11) {
          break;
        }
LABEL_27:
        v4 += 168;
        if (v4 == v5) {
          return;
        }
      }
    }
    if (v4 != v5 && subscriber::isEsimCapable())
    {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 855);
      if (*(unsigned char *)(a1 + 552))
      {
        uint64_t v13 = *(unsigned __int8 *)(a1 + 375);
        if ((v13 & 0x80u) == 0) {
          uint64_t v14 = *(unsigned __int8 *)(a1 + 375);
        }
        else {
          uint64_t v14 = *(void *)(a1 + 360);
        }
        uint64_t v15 = *(void *)(a1 + 840);
        if ((v12 & 0x80u) == 0) {
          uint64_t v16 = *(unsigned __int8 *)(a1 + 855);
        }
        else {
          uint64_t v16 = *(void *)(a1 + 840);
        }
        if (v14 == v16)
        {
          unint64_t v17 = (const void **)(a1 + 352);
          if ((v12 & 0x80u) == 0) {
            char v18 = (unsigned __int8 *)(a1 + 832);
          }
          else {
            char v18 = (unsigned __int8 *)*v3;
          }
          if ((v13 & 0x80) != 0)
          {
            if (!memcmp(*v17, v18, *(void *)(a1 + 360))) {
              return;
            }
          }
          else
          {
            if (!*(unsigned char *)(a1 + 375)) {
              return;
            }
            while (*(unsigned __int8 *)v17 == *v18)
            {
              unint64_t v17 = (const void **)((char *)v17 + 1);
              ++v18;
              if (!--v13) {
                return;
              }
            }
          }
        }
      }
      else
      {
        uint64_t v15 = *(void *)(a1 + 840);
      }
      uint64_t v19 = *(unsigned __int8 *)(a1 + 879);
      if ((v19 & 0x80u) == 0) {
        uint64_t v20 = *(unsigned __int8 *)(a1 + 879);
      }
      else {
        uint64_t v20 = *(void *)(a1 + 864);
      }
      if ((v12 & 0x80u) == 0) {
        uint64_t v21 = v12;
      }
      else {
        uint64_t v21 = v15;
      }
      if (v20 == v21)
      {
        xpc_object_t v22 = (const void **)(a1 + 856);
        if ((v12 & 0x80u) == 0) {
          int v23 = (unsigned __int8 *)(a1 + 832);
        }
        else {
          int v23 = (unsigned __int8 *)*v3;
        }
        if ((v19 & 0x80) != 0)
        {
          BOOL v31 = memcmp(*v22, v23, *(void *)(a1 + 864)) == 0;
        }
        else if (*(unsigned char *)(a1 + 879))
        {
          uint64_t v24 = v19 - 1;
          do
          {
            int v26 = *(unsigned __int8 *)v22;
            xpc_object_t v22 = (const void **)((char *)v22 + 1);
            int v25 = v26;
            int v28 = *v23++;
            int v27 = v28;
            BOOL v30 = v24-- != 0;
            BOOL v31 = v25 == v27;
          }
          while (v25 == v27 && v30);
        }
        else
        {
          BOOL v31 = 1;
        }
      }
      else
      {
        BOOL v31 = 0;
      }
      uint64_t v32 = *(void *)(a1 + 880);
      uint64_t v33 = *(NSObject **)(a1 + 56);
      dispatch_object_t object = v33;
      if (v33) {
        dispatch_retain(v33);
      }
      int v34 = *(std::__shared_weak_count **)(a1 + 48);
      if (!v34 || (uint64_t v35 = *(void *)(a1 + 40), (v36 = std::__shared_weak_count::lock(v34)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v37 = v35 + 32;
      if (!v35) {
        uint64_t v37 = 0;
      }
      uint64_t v51 = v37;
      xpc_object_t v52 = v36;
      (*(void (**)(long long *__return_ptr, uint64_t, dispatch_object_t *, uint64_t, uint64_t *, BOOL))(*(void *)v32 + 16))(&v54, v32, &object, v4, &v51, v31);
      long long v38 = v54;
      long long v54 = 0uLL;
      __int16 v39 = *(std::__shared_weak_count **)(a1 + 904);
      *(_OWORD *)(a1 + 896) = v38;
      if (v39)
      {
        sub_10004D2C8(v39);
        if (*((void *)&v54 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v54 + 1));
        }
      }
      if (v52) {
        sub_10004D2C8(v52);
      }
      if (object) {
        dispatch_release(object);
      }
      if (*(char *)(a1 + 855) < 0)
      {
        **(unsigned char **)(a1 + 832) = 0;
        *(void *)(a1 + 840) = 0;
      }
      else
      {
        *(unsigned char *)(a1 + 832) = 0;
        *(unsigned char *)(a1 + 855) = 0;
      }
      long long v40 = *(uint64_t **)(a1 + 896);
      if (v40)
      {
        ServiceMap = (std::mutex *)Registry::getServiceMap(v40, *(Registry **)(a1 + 80));
        uint64_t v42 = ServiceMap;
        if (v43 < 0)
        {
          long long v44 = (unsigned __int8 *)(v43 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v45 = 5381;
          do
          {
            uint64_t v43 = v45;
            unsigned int v46 = *v44++;
            uint64_t v45 = (33 * v45) ^ v46;
          }
          while (v46);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long v54 = v43;
        long long v47 = sub_10004D37C(&v42[1].__m_.__sig, (unint64_t *)&v54);
        if (v47)
        {
          uint64_t v49 = v47[3];
          BOOL v48 = (std::__shared_weak_count *)v47[4];
          if (v48)
          {
            atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v42);
            atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v48);
            char v50 = 0;
LABEL_97:
            if (v49) {
              (*(void (**)(uint64_t, void, BOOL))(*(void *)v49 + 24))(v49, 0, v31 | 0x100);
            }
            if ((v50 & 1) == 0) {
              sub_10004D2C8(v48);
            }
            return;
          }
        }
        else
        {
          uint64_t v49 = 0;
        }
        std::mutex::unlock(v42);
        BOOL v48 = 0;
        char v50 = 1;
        goto LABEL_97;
      }
    }
  }
}

void sub_1011EFBC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011EFC04(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  xpc_object_t v7[2] = sub_1011EFD1C;
  void v7[3] = &unk_1019A1BF8;
  void v7[4] = a1;
  char v2 = (std::__shared_weak_count *)a1[6];
  if (!v2 || (uint64_t v3 = a1[5], (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  uint64_t v6 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v3;
  unint64_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_1011EFD1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(NSObject **)(v1 + 72);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I expiring plan due to debug trigger", v3, 2u);
  }
  sub_1011EF454(v1, 1);
}

void sub_1011EFD8C(uint64_t a1)
{
}

const void **sub_1011EFD94(void *a1, const void **a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3321888768;
  _DWORD v9[2] = sub_1011EFEC0;
  void v9[3] = &unk_101A9E608;
  void v9[4] = a1;
  sub_100083DA4(&v10, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  uint64_t v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v9;
  dispatch_async(v7, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v6);
  return sub_1000558F4(&v10);
}

void sub_1011EFEC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    uint64_t v3 = sub_1000810B8;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(NSObject **)(v1 + 72);
  if (v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(v1 + 72), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I manage plan for alert", buf, 2u);
      uint64_t v2 = *(void *)(a1 + 40);
    }
    v10[0] = @"Iccid";
    v10[1] = @"FlowTypeKey";
    v11[0] = v2;
    v11[1] = &off_101AE6598;
    uint64_t v6 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];
    uint64_t v7 = *(void *)(v1 + 720);
    uint64_t v8 = v6;
    if (v6) {
      CFRetain(v6);
    }
    (*(void (**)(uint64_t, NSDictionary **))(*(void *)v7 + 216))(v7, &v8);
    sub_100057D78((const void **)&v8);
  }
  else if (os_log_type_enabled(*(os_log_t *)(v1 + 72), OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Missing ICCID", buf, 2u);
  }
}

void sub_1011F0038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011F0064(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[93];
  unint64_t v9 = (std::__shared_weak_count *)a1[94];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v8 || (int v13 = 0, (*(unsigned int (**)(uint64_t, int *))(*(void *)v8 + 632))(v8, &v13)))
  {
    uint64_t v10 = a1[81];
    if (v10)
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 328))(v10, a2, a3, a4);
      if (!v9) {
        return v11;
      }
      goto LABEL_9;
    }
  }
  uint64_t v11 = 0;
  if (v9) {
LABEL_9:
  }
    sub_10004D2C8(v9);
  return v11;
}

void sub_1011F015C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011F0178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1011F0064((void *)(a1 - 8), a2, a3, a4);
}

void sub_1011F0180(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011F0298;
  v8[3] = &unk_101A9E568;
  v8[4] = a2;
  void v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  uint64_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_1011F0298(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 760);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 280))(v2);
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v3();
}

void sub_1011F0318(void *a1, uint64_t a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011F0430;
  v8[3] = &unk_101A9E568;
  v8[4] = a2;
  void v8[5] = a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  uint64_t v10 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10004D2C8(v6);
}

uint64_t sub_1011F0430(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 760);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 288))(v2);
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v3();
}

BOOL sub_1011F04B0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 88);
  unint64_t v9 = *(Registry **)(a1 + 80);
  uint64_t v10 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v2 = *(_DWORD *)(a1 + 672);
  uint64_t v3 = *(void *)(a1 + 744);
  if (v3) {
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 696))(v3);
  }
  else {
    int v4 = 0;
  }
  uint64_t v5 = sub_1011F05C0(&v9, @"DataPlanReduceNetworkSignaling", v2, v4);
  uint64_t v11 = v5;
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v5) {
    uint64_t v6 = sub_100084B4C;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6) {
    BOOL v7 = CFBooleanGetValue((CFBooleanRef)v5) == 1;
  }
  else {
    BOOL v7 = 0;
  }
  sub_100062778(&v11);
  return v7;
}

void sub_1011F0598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

const void *sub_1011F05C0(Registry **a1, const void *a2, int a3, int a4)
{
  CFDictionaryRef v6 = (const __CFDictionary *)sub_100916B20(a1, a4);
  CFDictionaryRef v17 = v6;
  if (v6) {
    BOOL v7 = sub_100080778;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7) {
    goto LABEL_19;
  }
  if (a3 != -1)
  {
    CFDictionaryRef v15 = v6;
    CFDictionaryRef theDict = 0;
    if (v6) {
      CFRetain(v6);
    }
    sub_100916790(&v15, a3, (const void **)&theDict);
    sub_100057D78((const void **)&v15);
    if (theDict) {
      uint64_t v8 = sub_100080778;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8)
    {
      int Value = CFDictionaryGetValue(theDict, a2);
      uint64_t v10 = Value;
      if (Value)
      {
        CFTypeID v11 = CFGetTypeID(Value);
        if (v11 == CFBooleanGetTypeID())
        {
          sub_100057D78((const void **)&theDict);
LABEL_18:
          CFRetain(v10);
          goto LABEL_20;
        }
      }
    }
    sub_100057D78((const void **)&theDict);
    CFDictionaryRef v6 = v17;
  }
  uint64_t v12 = CFDictionaryGetValue(v6, a2);
  uint64_t v10 = v12;
  if (v12)
  {
    CFTypeID v13 = CFGetTypeID(v12);
    if (v13 == CFBooleanGetTypeID()) {
      goto LABEL_18;
    }
LABEL_19:
    uint64_t v10 = 0;
  }
LABEL_20:
  sub_100057D78((const void **)&v17);
  return v10;
}

void sub_1011F06F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F0720(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 744);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  return result;
}

BOOL sub_1011F0758(uint64_t a1)
{
  return sub_1011F04B0(a1 - 8);
}

const void **sub_1011F0760(uint64_t a1, int a2, int a3)
{
  CFDictionaryRef v6 = *(std::__shared_weak_count **)(a1 + 88);
  long long valuePtr = *(Registry **)(a1 + 80);
  int v23 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v7 = *(_DWORD *)(a1 + 672);
  uint64_t v8 = *(void *)(a1 + 744);
  if (v8) {
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 696))(v8);
  }
  else {
    int v9 = 0;
  }
  CFNumberRef number = (CFNumberRef)sub_1011E5694(&valuePtr, @"DataPlanNetworkRejectionCause", v7, v9);
  if (v23) {
    sub_10004D2C8(v23);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 88);
  long long valuePtr = *(Registry **)(a1 + 80);
  int v23 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v11 = *(_DWORD *)(a1 + 672);
  uint64_t v12 = *(void *)(a1 + 744);
  if (v12) {
    int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 696))(v12);
  }
  else {
    int v13 = 0;
  }
  uint64_t v14 = sub_1011E5694(&valuePtr, @"DataPlanNetworkRejectionCauseToForce3G", v11, v13);
  uint64_t v21 = v14;
  if (v23) {
    sub_10004D2C8(v23);
  }
  LODWORD(valuePtr) = -1;
  if (v14) {
    CFDictionaryRef v15 = sub_100081E58;
  }
  else {
    CFDictionaryRef v15 = 0;
  }
  if (v15)
  {
    CFNumberGetValue((CFNumberRef)v14, kCFNumberIntType, &valuePtr);
    if (valuePtr == a2)
    {
      uint64_t v16 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v20 = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Rejected from LTE, forcing LTE to provisioning mode", v20, 2u);
      }
      sub_100358C28((uint64_t)&event::registration::setLTEToProvisioning, 1);
    }
  }
  if (number) {
    CFDictionaryRef v17 = sub_100081E58;
  }
  else {
    CFDictionaryRef v17 = 0;
  }
  if (a3 == 7)
  {
    if (v17)
    {
      CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
      if (valuePtr == a2)
      {
        *(unsigned char *)(a1 + 795) = 1;
        char v18 = *(NSObject **)(a1 + 72);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v20 = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Disable LTE", v20, 2u);
        }
        sub_100358C28((uint64_t)&event::registration::setLTEEnabled, 0);
      }
    }
  }
  sub_1000570E8(&v21);
  return sub_1000570E8((const void **)&number);
}

void sub_1011F09CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_1000570E8((const void **)va);
  sub_1000570E8((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1011F0A10(const void **a1, uint64_t a2, std::__shared_weak_count *a3)
{
  *a1 = 0;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a2 && (*(unsigned int (**)(uint64_t))(*(void *)a2 + 696))(a2))
  {
    (*(void (**)(const void **__return_ptr, uint64_t))(*(void *)a2 + 672))(&v7, a2);
    if (&v7 != a1)
    {
      uint64_t v6 = *a1;
      *a1 = v7;
      uint64_t v7 = 0;
      uint64_t v8 = v6;
      sub_1000558F4(&v8);
    }
    sub_1000558F4(&v7);
  }
  if (a3) {
    sub_10004D2C8(a3);
  }
}

void sub_1011F0B00(_Unwind_Exception *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_1000558F4(v2);
  _Unwind_Resume(a1);
}

void sub_1011F0B24(void *a1, long long *a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3321888768;
  void v8[2] = sub_1011F0C78;
  v8[3] = &unk_1019CC228;
  v8[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  uint64_t v12 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v6);
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)__p);
  }
}

uint64_t sub_1011F0C78(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = (const void **)(a1 + 40);
  int v3 = *(char *)(a1 + 63);
  if (v3 >= 0) {
    size_t v4 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    size_t v4 = *(void *)(a1 + 48);
  }
  if (v4 == strlen(kDataActivateFailureReasonDataPlanExpiredSequoia)
    && (v3 >= 0 ? (uint64_t v5 = v2) : (uint64_t v5 = *v2), !memcmp(v5, kDataActivateFailureReasonDataPlanExpiredSequoia, v4))
    || v4 == strlen(kDataActivateFailureReasonDataPlanNoExistingPlan)
    && (v3 >= 0 ? (uint64_t v6 = v2) : (uint64_t v6 = *v2), !memcmp(v6, kDataActivateFailureReasonDataPlanNoExistingPlan, v4))
    || (uint64_t result = strlen(kDataActivateFailureReasonDataPlanUnusableProfile), v4 == result)
    && (v3 >= 0 ? (uint64_t v8 = v2) : (uint64_t v8 = *v2),
        uint64_t result = memcmp(v8, kDataActivateFailureReasonDataPlanUnusableProfile, v4),
        !result))
  {
    int v9 = *(uint64_t (**)(void))(**(void **)(v1 + 704) + 40);
    return v9();
  }
  return result;
}

const void **sub_1011F0DB0(void *a1, const void **a2, const void **a3)
{
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3321888768;
  void v11[2] = sub_1011F0F00;
  v11[3] = &unk_101A9E638;
  void v11[4] = a1;
  sub_100083DA4(&v12, a2);
  sub_100058198(&v13, a3);
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (!v5 || (v6 = a1[5], (uint64_t v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v8 = v7;
  int v9 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v6;
  CFDictionaryRef v15 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v11;
  dispatch_async(v9, block);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10004D2C8(v8);
  sub_100057D78(&v13);
  return sub_1000558F4(&v12);
}

const void **sub_1011F0F00(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 720);
  sub_100083DA4(&v6, (const void **)(a1 + 40));
  sub_100058198(&v5, (const void **)(a1 + 48));
  size_t v4 = 0;
  (*(void (**)(uint64_t, const void **, const void **, const void **))(*(void *)v2 + 176))(v2, &v6, &v5, &v4);
  sub_1000558F4(&v4);
  sub_100057D78(&v5);
  return sub_1000558F4(&v6);
}

void sub_1011F0F98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_1011F0FBC(uint64_t a1, uint64_t a2)
{
  sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));

  return sub_100058198((const void **)(a1 + 48), (const void **)(a2 + 48));
}

const void **sub_1011F1004(uint64_t a1)
{
  uint64_t v1 = (const void **)(a1 + 40);
  sub_100057D78((const void **)(a1 + 48));

  return sub_1000558F4(v1);
}

BOOL sub_1011F1040(void *a1, int a2, int a3)
{
  uint64_t v6 = (std::__shared_weak_count *)a1[11];
  uint64_t v14 = (Registry *)a1[10];
  CFDictionaryRef v15 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = a1[93];
  if (v7) {
    int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 696))(v7);
  }
  else {
    int v8 = 0;
  }
  int v9 = sub_100916B20(&v14, v8);
  uint64_t v16 = v9;
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v10 = (std::__shared_weak_count *)a1[11];
  uint64_t v14 = (Registry *)a1[10];
  CFDictionaryRef v15 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v13 = v9;
  if (v9) {
    CFRetain(v9);
  }
  BOOL v11 = sub_1006CF698(&v14, a2, a3, &v13);
  sub_100057D78(&v13);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_100057D78(&v16);
  return v11;
}

void sub_1011F1158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, std::__shared_weak_count *a11, const void *a12)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  sub_100057D78(&a12);
  _Unwind_Resume(a1);
}

BOOL sub_1011F1194(uint64_t a1, int a2, int a3)
{
  return sub_1011F1040((void *)(a1 - 8), a2, a3);
}

uint64_t sub_1011F119C(uint64_t a1, uint64_t a2)
{
  size_t v4 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I internet probe available changed: %d", (uint8_t *)v6, 8u);
  }
  uint64_t result = *(void *)(a1 + 776);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a2);
  }
  return result;
}

uint64_t sub_1011F1274(uint64_t a1, uint64_t a2)
{
  return sub_1011F119C(a1 - 8, a2);
}

void sub_1011F127C(void *a1@<X8>)
{
  uint64_t v1 = qword_101B13F38;
  *a1 = qword_101B13F38;
  if (v1) {
    dispatch_retain(v1);
  }
}

void sub_1011F1294(void *a1@<X8>)
{
  uint64_t v1 = qword_101B13F38;
  *a1 = qword_101B13F38;
  if (v1) {
    dispatch_retain(v1);
  }
}

uint64_t sub_1011F12AC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 720) + 32))();
}

uint64_t sub_1011F12D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 696) + 32))();
}

const void **sub_1011F12FC(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v4 = *(void *)(a1 + 720);
  sub_100083DA4(&v6, a3);
  (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)v4 + 40))(v4, a2, &v6);
  return sub_1000558F4(&v6);
}

void sub_1011F136C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1011F1380(uint64_t a1, uint64_t a2, const void **a3)
{
  return sub_1011F12FC(a1 - 24, a2, a3);
}

uint64_t sub_1011F1388(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 720) + 48))();
}

uint64_t sub_1011F13B0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 696) + 48))();
}

uint64_t sub_1011F13D8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 704);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1011F1408(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 680);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t sub_1011F1438(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 704);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

uint64_t sub_1011F1468(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 680);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void sub_1011F1498(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 880))
  {
    uint64_t v2 = a2 + 1;
    int v3 = (void *)*a2;
    if ((void *)*a2 != a2 + 1)
    {
      uint64_t v5 = (std::string *)(a1 + 832);
      do
      {
        uint64_t v6 = (unsigned __int8 **)(v3 + 4);
        char v7 = *(unsigned char *)(a1 + 855);
        uint64_t v8 = *(void *)(a1 + 840);
        if (v7 >= 0) {
          uint64_t v9 = *(unsigned __int8 *)(a1 + 855);
        }
        else {
          uint64_t v9 = *(void *)(a1 + 840);
        }
        int v10 = *((char *)v3 + 55);
        if (v10 >= 0) {
          uint64_t v11 = *((unsigned __int8 *)v3 + 55);
        }
        else {
          uint64_t v11 = v3[5];
        }
        if (v9 == v11)
        {
          if (v10 >= 0) {
            uint64_t v12 = (unsigned __int8 *)(v3 + 4);
          }
          else {
            uint64_t v12 = *v6;
          }
          if ((*(unsigned char *)(a1 + 855) & 0x80) != 0)
          {
            int v15 = memcmp(v5->__r_.__value_.__l.__data_, v12, *(void *)(a1 + 840));
            uint64_t v9 = v8;
            if (!v15) {
              return;
            }
          }
          else
          {
            if (!*(unsigned char *)(a1 + 855)) {
              return;
            }
            int v13 = v5;
            uint64_t v14 = *(unsigned __int8 *)(a1 + 855);
            while (v13->__r_.__value_.__s.__data_[0] == *v12)
            {
              int v13 = (std::string *)((char *)v13 + 1);
              ++v12;
              if (!--v14) {
                return;
              }
            }
          }
        }
        if (v11) {
          BOOL v16 = v9 == 0;
        }
        else {
          BOOL v16 = 1;
        }
        if (!v16)
        {
          CFDictionaryRef v17 = *(NSObject **)(a1 + 72);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            char v18 = v5;
            if (v7 < 0) {
              char v18 = (std::string *)v5->__r_.__value_.__r.__words[0];
            }
            uint64_t v19 = (unsigned __int8 *)(v3 + 4);
            if (v10 < 0) {
              uint64_t v19 = *v6;
            }
            *(_DWORD *)std::string buf = 136315394;
            uint64_t v24 = v18;
            __int16 v25 = 2080;
            int v26 = v19;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Overwriting plan expiry ICCID (%s) with (%s)", buf, 0x16u);
          }
        }
        std::string::operator=(v5, (const std::string *)(v3 + 4));
        uint64_t v20 = *(std::__shared_weak_count **)(a1 + 904);
        *(_OWORD *)(a1 + 896) = 0u;
        if (v20) {
          sub_10004D2C8(v20);
        }
        sub_1011EF7CC(a1);
        uint64_t v21 = (void *)v3[1];
        if (v21)
        {
          do
          {
            xpc_object_t v22 = v21;
            uint64_t v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            xpc_object_t v22 = (void *)v3[2];
            BOOL v16 = *v22 == (void)v3;
            int v3 = v22;
          }
          while (!v16);
        }
        int v3 = v22;
      }
      while (v22 != v2);
    }
  }
}

void sub_1011F1694(uint64_t a1, void *a2)
{
}

uint64_t sub_1011F169C(uint64_t result, std::string *__str)
{
  uint64_t v2 = result;
  if (*(void *)(result + 880))
  {
    int v3 = __str;
    uint64_t v4 = *(unsigned __int8 *)(result + 879);
    if ((v4 & 0x80u) == 0) {
      uint64_t v5 = *(unsigned __int8 *)(result + 879);
    }
    else {
      uint64_t v5 = *(void *)(result + 864);
    }
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    int v7 = (char)size;
    if ((size & 0x80u) != 0) {
      std::string::size_type size = __str->__r_.__value_.__l.__size_;
    }
    if (v5 == size)
    {
      if (v7 < 0) {
        std::string __str = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      if ((v4 & 0x80) != 0)
      {
        uint64_t result = memcmp(*(const void **)(result + 856), __str, *(void *)(result + 864));
        if (!result) {
          return result;
        }
      }
      else
      {
        if (!*(unsigned char *)(result + 879)) {
          return result;
        }
        for (uint64_t i = (unsigned __int8 *)(result + 856); *i == __str->__r_.__value_.__s.__data_[0]; ++i)
        {
          std::string __str = (std::string *)((char *)__str + 1);
          if (!--v4) {
            return result;
          }
        }
      }
    }
    std::string::operator=((std::string *)(v2 + 856), v3);
  }
  uint64_t result = *(void *)(v2 + 704);
  if (result)
  {
    uint64_t v9 = *(uint64_t (**)(void))(*(void *)result + 56);
    return v9();
  }
  return result;
}

uint64_t sub_1011F17A0(uint64_t a1, std::string *a2)
{
  return sub_1011F169C(a1 - 24, a2);
}

const void **sub_1011F17A8(uint64_t a1, const void **a2, const void **a3, const void **a4)
{
  uint64_t v6 = *(void *)(a1 + 720);
  sub_100083DA4(&v10, a2);
  sub_100058198(&v9, a3);
  sub_100083DA4(&v8, a4);
  (*(void (**)(uint64_t, const void **, const void **, const void **))(*(void *)v6 + 176))(v6, &v10, &v9, &v8);
  sub_1000558F4(&v8);
  sub_100057D78(&v9);
  return sub_1000558F4(&v10);
}

void sub_1011F184C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

const void **sub_1011F1870(uint64_t a1, const void **a2, const void **a3, const void **a4)
{
  return sub_1011F17A8(a1 - 24, a2, a3, a4);
}

const void **sub_1011F1878(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, const void **a5)
{
  uint64_t v8 = *(void *)(a1 + 720);
  sub_10002FD9C(&v11, a2);
  sub_100058198(&v10, a5);
  (*(void (**)(uint64_t, const void **, uint64_t, uint64_t, const void **))(*(void *)v8 + 168))(v8, &v11, a3, a4, &v10);
  sub_100057D78(&v10);
  return sub_100030068(&v11);
}

void sub_1011F1910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **sub_1011F192C(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, const void **a5)
{
  return sub_1011F1878(a1 - 24, a2, a3, a4, a5);
}

const void **sub_1011F1934(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(void *)(a1 + 720);
  sub_10002FD9C(&v16, a2);
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a5;
    uint64_t v15 = *(void *)(a5 + 16);
  }
  if (*(char *)(a6 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a6, *(void *)(a6 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a6;
    uint64_t v13 = *(void *)(a6 + 16);
  }
  (*(void (**)(uint64_t, const void **, uint64_t, uint64_t, void **, void **))(*(void *)v10 + 200))(v10, &v16, a3, a4, __dst, __p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst[0]);
  }
  return sub_100030068(&v16);
}

void sub_1011F1A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_100030068(&a22);
  _Unwind_Resume(a1);
}

const void **sub_1011F1A7C(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_1011F1934(a1 - 24, a2, a3, a4, a5, a6);
}

uint64_t sub_1011F1A84(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 720) + 208))();
}

uint64_t sub_1011F1AAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 696) + 208))();
}

BOOL sub_1011F1AD4@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 80));
  int v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (!v8)
  {
    uint64_t v10 = 0;
    goto LABEL_8;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9)
  {
LABEL_8:
    std::mutex::unlock(v3);
    return v10 == 0;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  sub_10004D2C8(v9);
  return v10 == 0;
}

BOOL sub_1011F1BA8@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_1011F1AD4(a1 - 24, a2);
}

void sub_1011F1BB0(uint64_t a1, void *a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  unsigned int v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)BOOL v30 = v8;
  unint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v30);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      sub_10004D2C8(v13);
      if (v14) {
        return;
      }
    }
    else
    {
      std::mutex::unlock(v7);
      if (v14) {
        return;
      }
    }
  }
  else
  {
    std::mutex::unlock(v7);
  }
  BOOL v16 = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(a1 + 80));
  CFDictionaryRef v17 = v16;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)BOOL v30 = v18;
  xpc_object_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)v30);
  if (!v22)
  {
    uint64_t v24 = 0;
LABEL_19:
    std::mutex::unlock(v17);
    int v23 = 0;
    char v25 = 1;
    if (!v24) {
      goto LABEL_26;
    }
LABEL_20:
    if (a2[1] - *a2 <= 4uLL) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = 2;
    }
    int v27 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = subscriber::asString();
      uint64_t v29 = subscriber::asString();
      *(_DWORD *)BOOL v30 = 136315394;
      *(void *)&void v30[4] = v28;
      __int16 v31 = 2080;
      uint64_t v32 = v29;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I setting msim config to: %s, default user data slot to: %s", v30, 0x16u);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v24 + 1216))(v24, a3, v26);
    goto LABEL_26;
  }
  uint64_t v24 = v22[3];
  int v23 = (std::__shared_weak_count *)v22[4];
  if (!v23) {
    goto LABEL_19;
  }
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v17);
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  char v25 = 0;
  if (v24) {
    goto LABEL_20;
  }
LABEL_26:
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
}

void sub_1011F1E28(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011F1E60(uint64_t a1, void *a2, uint64_t a3)
{
}

void sub_1011F1E68(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (uint64_t *)*((unsigned __int8 *)a3 + 23);
  if ((char)v6 >= 0) {
    uint64_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v7 = a3[1];
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 80));
  uint64_t v9 = ServiceMap;
  if (v7)
  {
    if (v10 < 0)
    {
      unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)uint64_t v28 = v10;
    uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v28);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        if (!v16) {
          goto LABEL_31;
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_31;
    }
LABEL_21:
    uint64_t v24 = *(NSObject **)(a1 + 72);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        char v25 = a3;
      }
      else {
        char v25 = (uint64_t *)*a3;
      }
      *(_DWORD *)uint64_t v28 = 136315138;
      *(void *)&v28[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Requesting default active user data: (%s)", v28, 0xCu);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v16 + 64))(v16, a3);
    goto LABEL_31;
  }
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v28 = v18;
  xpc_object_t v22 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v28);
  if (v22)
  {
    uint64_t v23 = v22[3];
    uint64_t v15 = (std::__shared_weak_count *)v22[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v23) {
        goto LABEL_31;
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  char v17 = 1;
  if (!v23) {
    goto LABEL_31;
  }
LABEL_29:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 1208))(v23, a2);
  uint64_t v26 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = subscriber::asString();
    *(_DWORD *)uint64_t v28 = 136315138;
    *(void *)&v28[4] = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I active user set to: %s", v28, 0xCu);
  }
LABEL_31:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_1011F2140(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011F2178(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_1011F2180(uint64_t a1, uint64_t a2)
{
  atomic_store(a2, (unsigned int *)(a1 + 168));
  uint64_t v4 = a1 + 208;
  if (*(_DWORD *)(a1 + 208) != a2)
  {
    *(_DWORD *)(a1 + 208) = a2;
    uint64_t v5 = *(void *)(a1 + 200);
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, v4);
    }
  }
  uint64_t v6 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    uint64_t v9 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I default voice set to: %s", (uint8_t *)&v8, 0xCu);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 800) + 80))(*(void *)(a1 + 800), a2);
}

uint64_t sub_1011F22A4(uint64_t a1, uint64_t a2)
{
  return sub_1011F2180(a1 - 24, a2);
}

BOOL sub_1011F22AC@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 80));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v17);
  if (!v12)
  {
    uint64_t v13 = 0;
LABEL_9:
    std::mutex::unlock(v7);
    uint64_t v14 = 0;
    char v15 = 1;
    if (!v13) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v13 = v12[3];
  uint64_t v14 = (std::__shared_weak_count *)v12[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v15 = 0;
  if (v13) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13 + 72))(v13, a2, a3);
LABEL_11:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  return v13 != 0;
}

void sub_1011F23D4(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1011F23F0@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return sub_1011F22AC(a1 - 24, a2, a3, a4);
}

void sub_1011F23F8(uint64_t a1, __int16 a2)
{
  if ((a2 & 0xFF00) != 0)
  {
    uint64_t v3 = *(void *)(a1 + 744);
    if (!v3) {
      goto LABEL_29;
    }
    int v4 = a2;
    if (!(_BYTE)a2)
    {
      uint64_t v5 = *(NSObject **)(a1 + 72);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v30[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Plan Expired", (uint8_t *)v30, 2u);
        uint64_t v3 = *(void *)(a1 + 744);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 640))(v3, 1);
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 904);
      *(_OWORD *)(a1 + 896) = 0u;
      if (v6) {
        sub_10004D2C8(v6);
      }
    }
    if (*(char *)(a1 + 879) < 0)
    {
      if (!*(void *)(a1 + 864)) {
        goto LABEL_29;
      }
    }
    else if (!*(unsigned char *)(a1 + 879))
    {
      goto LABEL_29;
    }
    (*(void (**)(void, BOOL))(**(void **)(a1 + 744) + 736))(*(void *)(a1 + 744), v4 != 0);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 80));
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    v30[0] = v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, v30);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        if (!v17)
        {
LABEL_27:
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
LABEL_29:
          uint64_t v19 = (uint64_t *)*(char *)(a1 + 879);
          if ((v19 & 0x80000000) != 0)
          {
            if (!*(void *)(a1 + 864)) {
              return;
            }
            uint64_t v19 = *(uint64_t **)(a1 + 856);
            *(unsigned char *)uint64_t v19 = 0;
            *(void *)(a1 + 864) = 0;
          }
          else
          {
            if (!*(unsigned char *)(a1 + 879)) {
              return;
            }
            *(unsigned char *)(a1 + 856) = 0;
            *(unsigned char *)(a1 + 879) = 0;
          }
          uint64_t v20 = (std::mutex *)Registry::getServiceMap(v19, *(Registry **)(a1 + 80));
          unsigned int v21 = v20;
          if ((v22 & 0x8000000000000000) != 0)
          {
            uint64_t v23 = (unsigned __int8 *)(v22 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v24 = 5381;
            do
            {
              unint64_t v22 = v24;
              unsigned int v25 = *v23++;
              uint64_t v24 = (33 * v24) ^ v25;
            }
            while (v25);
          }
          std::mutex::lock(v20);
          v30[0] = v22;
          uint64_t v26 = sub_10004D37C(&v21[1].__m_.__sig, v30);
          if (v26)
          {
            uint64_t v28 = v26[3];
            uint64_t v27 = (std::__shared_weak_count *)v26[4];
            if (v27)
            {
              atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v21);
              atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v27);
              char v29 = 0;
              if (!v28)
              {
LABEL_44:
                if ((v29 & 1) == 0) {
                  sub_10004D2C8(v27);
                }
                return;
              }
LABEL_43:
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28 + 464))(v28, 1, 5);
              goto LABEL_44;
            }
          }
          else
          {
            uint64_t v28 = 0;
          }
          std::mutex::unlock(v21);
          uint64_t v27 = 0;
          char v29 = 1;
          if (!v28) {
            goto LABEL_44;
          }
          goto LABEL_43;
        }
LABEL_26:
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)v17 + 24))(v17, 0, 256);
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  uint64_t v7 = *(NSObject **)(a1 + 72);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v30[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Unknown result, leave plan as enabled and do not show anything", (uint8_t *)v30, 2u);
  }
  if (*(char *)(a1 + 879) < 0)
  {
    **(unsigned char **)(a1 + 856) = 0;
    *(void *)(a1 + 864) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 856) = 0;
    *(unsigned char *)(a1 + 879) = 0;
  }
}

void sub_1011F2770(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011F279C(uint64_t a1, __int16 a2)
{
}

uint64_t sub_1011F27A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 744);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 736))();
  }
  return result;
}

uint64_t sub_1011F27E0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 728);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 736))();
  }
  return result;
}

BOOL sub_1011F2818(uint64_t a1)
{
  return *(unsigned char *)(a1 + 552) && *(unsigned char *)(a1 + 425) != 0;
}

BOOL sub_1011F2838(uint64_t a1)
{
  return *(unsigned char *)(a1 + 544) && *(unsigned char *)(a1 + 417) != 0;
}

BOOL sub_1011F2858(uint64_t a1)
{
  return *(unsigned char *)(a1 + 536) && *(unsigned char *)(a1 + 409) != 0;
}

uint64_t sub_1011F2878(uint64_t a1)
{
  return *(unsigned int *)(a1 + 672);
}

uint64_t sub_1011F2880(uint64_t a1)
{
  return *(unsigned int *)(a1 + 656);
}

uint64_t sub_1011F2888(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 728);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  return result;
}

void sub_1011F28C0(void *a1, char a2)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1011F29DC;
  v8[3] = &unk_1019BB378;
  v8[4] = a1;
  char v9 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (!v3 || (uint64_t v4 = a1[5], (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v5;
  uint64_t v7 = a1[7];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_1011F5EA4;
  block[3] = &unk_101A9F020;
  void block[5] = v4;
  unint64_t v11 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v8;
  dispatch_async(v7, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v6);
}

void sub_1011F29DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 72);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asStringBool(*(unsigned char *)(a1 + 40));
    int v7 = 136315138;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I switchSecondaryProvisioning, enable=%s", (uint8_t *)&v7, 0xCu);
  }
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (*(unsigned __int8 *)(v2 + 160) != v5)
  {
    *(unsigned char *)(v2 + 160) = v5;
    uint64_t v6 = *(void *)(v2 + 152);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v2 + 160);
    }
  }
}

void sub_1011F2AD0(uint64_t a1, char a2)
{
}

void sub_1011F2AD8(uint64_t a1, char a2)
{
}

BOOL sub_1011F2AE0(uint64_t a1)
{
  char v1 = *(uint64_t **)(a1 + 648);
  if (!v1) {
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v1, *(Registry **)(a1 + 80));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v25 = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, &v25);
  if (!v9)
  {
    std::mutex::unlock(v4);
    return 0;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10)
  {
    std::mutex::unlock(v4);
    if (v11) {
      goto LABEL_12;
    }
    return 0;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  if (!v11)
  {
    BOOL v12 = 0;
    goto LABEL_23;
  }
LABEL_12:
  int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 776))(v11);
  uint64_t v15 = *(void *)(a1 + 320);
  if (!v15) {
    goto LABEL_22;
  }
  uint64_t v16 = a1 + 320;
  do
  {
    int v17 = *(_DWORD *)(v15 + 32);
    BOOL v18 = v17 < v14;
    if (v17 >= v14) {
      uint64_t v19 = (uint64_t *)v15;
    }
    else {
      uint64_t v19 = (uint64_t *)(v15 + 8);
    }
    if (!v18) {
      uint64_t v16 = v15;
    }
    uint64_t v15 = *v19;
  }
  while (*v19);
  if (v16 == a1 + 320 || v14 < *(_DWORD *)(v16 + 32))
  {
LABEL_22:
    BOOL v12 = 0;
    BOOL result = 0;
    if (!v10) {
      return result;
    }
    goto LABEL_23;
  }
  uint64_t v20 = *(void **)(v16 + 40);
  unsigned int v21 = (void *)(v16 + 48);
  if (v20 == (void *)(v16 + 48))
  {
LABEL_33:
    BOOL v12 = 0;
  }
  else
  {
    while ((ConnectionTypeToMask() & 0x10000) == 0)
    {
      unint64_t v22 = (void *)v20[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          unint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v20[2];
          BOOL v24 = *v23 == (void)v20;
          uint64_t v20 = v23;
        }
        while (!v24);
      }
      uint64_t v20 = v23;
      if (v23 == v21) {
        goto LABEL_33;
      }
    }
    BOOL v12 = *((_DWORD *)v20 + 11) == 2;
  }
  BOOL result = v12;
  if (v10)
  {
LABEL_23:
    sub_10004D2C8(v10);
    return v12;
  }
  return result;
}

void sub_1011F2CC0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1011F2CE0(uint64_t a1)
{
  return sub_1011F2AE0(a1 - 16);
}

void sub_1011F2CE8(uint64_t a1@<X0>, NSObject **a2@<X8>)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  *a2 = v2;
  if (v2) {
    dispatch_retain(v2);
  }
}

void sub_1011F2CFC(uint64_t a1@<X0>, NSObject **a2@<X8>)
{
  uint64_t v2 = *(NSObject **)(a1 + 48);
  *a2 = v2;
  if (v2) {
    dispatch_retain(v2);
  }
}

void *sub_1011F2D10(void *result)
{
  if (result[2])
  {
    char v1 = result;
    BOOL result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = (void *)*result;
    v3[1] = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        sub_1011F2D74((void **)result);
        BOOL result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void sub_1011F2D74(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_1011F2DBC()
{
}

void *sub_1011F2DD0(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A9E760;
  result[1] = v3;
  return result;
}

uint64_t sub_1011F2E18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A9E760;
  a2[1] = v2;
  return result;
}

uint64_t sub_1011F2E44(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    LODWORD(v15) = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v15, (int *)a2, v5);
    unsigned int v8 = v15;
    if (v15) {
      goto LABEL_16;
    }
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    if (v8) {
      goto LABEL_16;
    }
  }
  char v9 = *(NSObject **)(v3 + 72);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Last known default voice slot: subscriber::SimSlot::kUnknown", (uint8_t *)&v15, 2u);
  }
  unsigned int v8 = 1;
LABEL_16:
  if (atomic_load((unsigned int *)(v3 + 168)))
  {
    uint64_t v11 = *(NSObject **)(v3 + 72);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = subscriber::asString();
      LODWORD(v15) = 136315138;
      *(void *)((char *)&v15 + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I default voice slot '%s', not initialized here", (uint8_t *)&v15, 0xCu);
    }
  }
  else
  {
    atomic_store(v8, (unsigned int *)(v3 + 168));
    *(_DWORD *)(v3 + 208) = v8;
    uint64_t v13 = *(void *)(v3 + 200);
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 48))(v13);
    }
  }
  *(void *)&long long v15 = off_101A9E7D0;
  *((void *)&v15 + 1) = v3 + 112;
  uint64_t v16 = &v15;
  sub_100609368(&v15, (void *)(v3 + 176));
  sub_100600F40(&v15);
  uint64_t result = *(void *)(v3 + 200);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v3 + 208);
  }
  return result;
}

uint64_t sub_1011F3058(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011F3098()
{
}

void sub_1011F30A8()
{
}

void *sub_1011F30BC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A9E7D0;
  result[1] = v3;
  return result;
}

uint64_t sub_1011F3104(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A9E7D0;
  a2[1] = v2;
  return result;
}

void sub_1011F3130(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/prefs-nb/user_default_voice_slot");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_1011F31E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1011F3228(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F3268()
{
}

void sub_1011F3278()
{
}

__n128 sub_1011F328C(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = off_101A9E860;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011F32E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9E860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011F3318(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  unint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1004CF7D4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  char v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1011F33D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1011F33F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F3430()
{
}

void sub_1011F3440()
{
}

void *sub_1011F3454(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A9E8E0;
  result[1] = v3;
  return result;
}

uint64_t sub_1011F349C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A9E8E0;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_1011F34C8(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    *uint64_t v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    *uint64_t v3 = (int)result;
  }
  return result;
}

uint64_t sub_1011F3564(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F35A4()
{
}

void sub_1011F35B4()
{
}

void *sub_1011F35C8(uint64_t a1)
{
  xpc_type_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101A9E960;
  result[1] = v3;
  return result;
}

uint64_t sub_1011F3610(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A9E960;
  a2[1] = v2;
  return result;
}

void sub_1011F363C(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/provisioning_pco_switch");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_1011F36EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F3734(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F3774()
{
}

void *sub_1011F3780(void *a1)
{
  *a1 = off_101A9E9E0;
  xpc_object_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011F37CC(void *a1)
{
  *a1 = off_101A9E9E0;
  char v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011F3838(uint64_t a1)
{
  xpc_type_t result = (char *)operator new(0x20uLL);
  *(void *)xpc_type_t result = off_101A9E9E0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011F389C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A9E9E0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011F38DC(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011F38EC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011F392C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (a1[2])
      {
        uint64_t v6 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = *(_DWORD *)(v3 + 672);
          if (*(unsigned char *)(v3 + 676)) {
            int v8 = "true";
          }
          else {
            int v8 = "false";
          }
          int v17 = 136315394;
          BOOL v18 = v8;
          __int16 v19 = 1024;
          LODWORD(v20) = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fWebsheetVisible:%s, fDataMode:%d", (uint8_t *)&v17, 0x12u);
          uint64_t v6 = *(NSObject **)(v3 + 72);
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          xpc_object_t v9 = "true";
          if (*(unsigned char *)(v3 + 793)) {
            uint64_t v10 = "true";
          }
          else {
            uint64_t v10 = "false";
          }
          if (!*(unsigned char *)(v3 + 794)) {
            xpc_object_t v9 = "false";
          }
          int v17 = 136315394;
          BOOL v18 = v10;
          __int16 v19 = 2080;
          uint64_t v20 = v9;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fBBEnteredProvisioningMode:%s, fColdSimRemoved:%s", (uint8_t *)&v17, 0x16u);
          uint64_t v6 = *(NSObject **)(v3 + 72);
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          atomic_load((unsigned int *)(v3 + 168));
          uint64_t v11 = subscriber::asString();
          int v17 = 136315138;
          BOOL v18 = (void *)v11;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I fDefaultVoiceSim:%s", (uint8_t *)&v17, 0xCu);
        }
        uint64_t v12 = *(void *)(v3 + 648);
        if (v12)
        {
          (*(void (**)(uint64_t))(*(void *)v12 + 176))(v12);
        }
        else
        {
          uint64_t v13 = *(NSObject **)(v3 + 72);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v17) = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I No data plan", (uint8_t *)&v17, 2u);
          }
        }
        (*(void (**)(void))(**(void **)(v3 + 720) + 224))(*(void *)(v3 + 720));
        uint64_t v14 = *(void *)(v3 + 704);
        if (v14) {
          (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
        }
        long long v15 = *(NSObject **)(v3 + 72);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = (void *)(v3 + 832);
          if (*(char *)(v3 + 855) < 0) {
            uint64_t v16 = (void *)*v16;
          }
          int v17 = 136315138;
          BOOL v18 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Plan Expiry ICCID: (%s)", (uint8_t *)&v17, 0xCu);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1011F3C44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F3C58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F3C98()
{
}

void *sub_1011F3CA4(void *a1)
{
  *a1 = off_101A9EA60;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011F3CF0(void *a1)
{
  *a1 = off_101A9EA60;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011F3D5C(uint64_t a1)
{
  xpc_type_t result = (char *)operator new(0x28uLL);
  *(void *)xpc_type_t result = off_101A9EA60;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011F3DC0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A9EA60;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011F3E00(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011F3E10(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011F3E50(void *a1)
{
  read_rest_value();
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2)
  {
    uint64_t v3 = (void *)a1[2];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      char v5 = v4;
      if (a1[3])
      {
        uint64_t v6 = v3[9];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I selected plan changed", v7, 2u);
        }
        sub_1011E8598(v3, 0, 1);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1011F3EFC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F3F10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F3F50()
{
}

void *sub_1011F3F5C(void *a1)
{
  *a1 = off_101A9EAE0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1011F3FA8(void *a1)
{
  *a1 = off_101A9EAE0;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1011F4014(uint64_t a1)
{
  xpc_type_t result = (char *)operator new(0x28uLL);
  *(void *)xpc_type_t result = off_101A9EAE0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1011F4078(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A9EAE0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011F40B8(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1011F40C8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1011F4108(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v16 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v16, (int *)a2, v6);
    *uint64_t v4 = v16;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  xpc_object_t v9 = (std::__shared_weak_count *)a1[4];
  if (v9)
  {
    uint64_t v10 = a1[2];
    uint64_t v11 = std::__shared_weak_count::lock(v9);
    if (v11)
    {
      uint64_t v12 = v11;
      if (a1[3])
      {
        uint64_t v13 = *(void *)(v10 + 744);
        if (v13)
        {
          if (*(_DWORD *)(v10 + 280))
          {
            uint64_t v14 = *(NSObject **)(v10 + 72);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v15 = subscriber::asString();
              int v16 = 136315138;
              uint64_t v17 = v15;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I MSIM config changed, %s", (uint8_t *)&v16, 0xCu);
              uint64_t v13 = *(void *)(v10 + 744);
            }
            (*(void (**)(uint64_t))(*(void *)v13 + 720))(v13);
          }
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_1011F42A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F42C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F4300()
{
}

void sub_1011F4310(uint64_t a1)
{
  sub_1011F4600(a1);

  operator delete();
}

BOOL sub_1011F4348(uint64_t a1)
{
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v6, v2);
  if (*(void *)(a1 + 32))
  {
    for (uint64_t i = *(_DWORD **)sub_100A9348C((uint64_t *)(a1 + 32));
          i != *(_DWORD **)(sub_100A9348C((uint64_t *)(a1 + 32)) + 8);
          i += 6)
    {
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*(unsigned char *)(a1 + 24))
        {
          *(unsigned char *)(a1 + 24) = 0;
          sub_100163448((atomic_uint **)a1, v6);
        }
        sub_1000624B4((uint64_t)v8);
        break;
      }
      sub_1000624B4((uint64_t)v8);
    }
  }
  int v4 = *(unsigned __int8 *)(a1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v7 + 1));
  sub_10000A5F8(v6);
  return v4 != 0;
}

void sub_1011F4480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4(v3 - 80);
  sub_100161F10((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F44C4(uint64_t a1)
{
  char v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_1011F44F0(uint64_t a1)
{
  char v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_1011F451C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_1011F457C()
{
}

uint64_t sub_1011F4590(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1011F4BF8((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_1011F45E8()
{
  return 0;
}

uint64_t sub_1011F45F0()
{
  return 0;
}

uint64_t sub_1011F45F8()
{
  return 0;
}

uint64_t sub_1011F4600(uint64_t a1)
{
  *(void *)a1 = off_101A9EB60;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

void sub_1011F4674()
{
}

uint64_t sub_1011F4688(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1011F46B8()
{
  return 0;
}

uint64_t sub_1011F46C0()
{
  return 0;
}

uint64_t sub_1011F46C8()
{
  return 0;
}

uint64_t sub_1011F46D0(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015D7A20 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015D7A20 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_1011F4810(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_101A9EC88 + 1;
  operator new();
}

void sub_1011F496C()
{
}

uint64_t sub_1011F49A0(uint64_t a1)
{
  sub_100A93514(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_1011F4BF8(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1011F4A48(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015D7ABCLL & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015D7ABCLL & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_1011F4AF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_1011F4B38(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    long long v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_1011F4BD4(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_1011F4BE4(_Unwind_Exception *a1)
{
}

uint64_t *sub_1011F4BF8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      long long v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_1011F4C4C(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015D7B40 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015D7B40 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_1011F4D8C(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_101A9ECC8 + 1;
  operator new();
}

void sub_1011F4EC0()
{
}

uint64_t sub_1011F4EF4(uint64_t a1)
{
  sub_1003595BC(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100980A44(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1011F4F78(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015D7BC6 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015D7BC6 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_1011F5020(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

uint64_t sub_1011F5068(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      if (*(void *)a2)
      {
        dispatch_release(**(dispatch_object_t **)a2);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015D7C34 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015D7C34 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
  return result;
}

void sub_1011F51A8(uint64_t a1)
{
  long long v1 = *(_OWORD *)(*(void *)a1 + 8);
  uint64_t v4 = *(void *)(*(void *)a1 + 24);
  long long v3 = v1;
  uint64_t v2 = (char *)off_101A9ED08 + 1;
  operator new();
}

void sub_1011F52DC()
{
}

uint64_t sub_1011F5310(uint64_t a1)
{
  sub_1004F9A98(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_1004F9FB0(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1011F5394(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == (0x80000001015D7CC9 & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)(0x80000001015D7CC9 & 0x7FFFFFFFFFFFFFFFLL)),
            !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

uint64_t sub_1011F543C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(uint64_t (**)(void *))a1;
  long long v3 = (void *)(*(void *)(a1 + 16) + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

void sub_1011F5488()
{
}

__n128 sub_1011F549C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A9ED38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011F54F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9ED38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011F5528(void *a1, xpc_object_t *a2)
{
  long long v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  long long v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *long long v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100318E34((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10024D10C((uint64_t)&v9, v10);
}

void sub_1011F55E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1011F5600(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F5640()
{
}

void sub_1011F5650()
{
}

__n128 sub_1011F5664(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A9EDB8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011F56B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9EDB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011F56F0(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = **(unsigned int **)(a1 + 8);
  xpc_object_t object = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  uint64_t v4 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = (void *)(*(void *)(a1 + 16) + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t))(*v6 + v4);
  }
  return v4(v6, v3);
}

void sub_1011F57AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

uint64_t sub_1011F57C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F5808()
{
}

void sub_1011F5818()
{
}

__n128 sub_1011F582C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A9EE38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1011F5880(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9EE38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1011F58B8(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1011F59B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F59F0()
{
}

void sub_1011F5A00()
{
}

__n128 sub_1011F5A14(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A9EEB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1011F5A60(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9EEB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1011F5A90(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(void *)(a1 + 16);
  sub_1011EF7CC(v3);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  sub_10010CB7C(&v14, *(void *)(v3 + 224), *(void *)(v3 + 232), 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(v3 + 232) - *(void *)(v3 + 224)) >> 3));
  if (v15 != v14 && *(_DWORD *)(v14 + 8) == 5 && *(unsigned char *)(v3 + 795))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(v3 + 795), *(Registry **)(v3 + 80));
    uint64_t v5 = ServiceMap;
    if (v6 < 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v17 = (void **)v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v17);
    if (v10)
    {
      uint64_t v12 = (MaxDataRateInterface *)v10[3];
      uint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        if (!v12)
        {
LABEL_16:
          sub_10004D2C8(v11);
          goto LABEL_17;
        }
      }
      else
      {
        std::mutex::unlock(v5);
        if (!v12) {
          goto LABEL_17;
        }
      }
      if (MaxDataRateInterface::getUserPreferenceEnableLTE(v12) == 2) {
        sub_100358C28((uint64_t)&event::registration::setLTEEnabled, 1);
      }
      *(unsigned char *)(v3 + 795) = 0;
      if (v11) {
        goto LABEL_16;
      }
    }
    else
    {
      std::mutex::unlock(v5);
    }
  }
LABEL_17:
  if (v14 != v15)
  {
    uint64_t v13 = *(void *)(v3 + 648);
    if (v13) {
      (*(void (**)(uint64_t, void))(*(void *)v13 + 200))(v13, *(unsigned int *)(v14 + 8));
    }
  }
  uint64_t v17 = (void **)&v14;
  sub_10008A88C(&v17);
}

void sub_1011F5C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  if (v12) {
    sub_10004D2C8(v12);
  }
  a12 = (void **)&a9;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1011F5C7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F5CBC()
{
}

void sub_1011F5CC8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EF38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011F5CE8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EF38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011F5D3C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1011F5D64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EF88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011F5D84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EF88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011F5DD8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 1016))();
}

void sub_1011F5E08(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EFD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1011F5E28(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A9EFD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1011F5E7C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 72))();
}

uint64_t sub_1011F5EA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1011F5EB4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1011F5ED0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void *sub_1011F5EE0(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_1011F5EF4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1011F5F30(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_1011F5F6C(unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 760);
  if (v2)
  {
    (*(void (**)(uint64_t, unsigned __int8 *, void))(*(void *)v2 + 208))(v2, v1 + 8, v1[32]);
  }
  else
  {
    uint64_t v3 = *(NSObject **)(*(void *)v1 + 72);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fCellularPlanControllerPhone is not available!", buf, 2u);
    }
  }
  sub_10023CBF8((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1011F6020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1011F603C(unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 760);
  if (v2)
  {
    (*(void (**)(uint64_t, unsigned __int8 *, void))(*(void *)v2 + 216))(v2, v1 + 8, v1[32]);
  }
  else
  {
    uint64_t v3 = *(NSObject **)(*(void *)v1 + 72);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fCellularPlanControllerPhone is not available!", buf, 2u);
    }
  }
  sub_10023CBF8((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1011F60F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1011F610C(uint64_t a1)
{
  *(void *)a1 = off_101A9F060;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1011F615C(uint64_t a1)
{
  *(void *)a1 = off_101A9F060;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

char *sub_1011F61CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A9F060;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = v2 + 24;
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(v3, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)uint64_t v3 = *(_OWORD *)(a1 + 24);
    *((void *)v2 + 5) = *(void *)(a1 + 40);
  }
  return v2;
}

void sub_1011F624C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_1011F6260(char *result, uint64_t a2)
{
  *(void *)a2 = off_101A9F060;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = (unsigned char *)(a2 + 24);
  if (result[47] < 0) {
    return (char *)sub_10004FC84(v2, *((void **)result + 3), *((void *)result + 4));
  }
  long long v3 = *(_OWORD *)(result + 24);
  *(void *)(a2 + 40) = *((void *)result + 5);
  *(_OWORD *)uint64_t v2 = v3;
  return result;
}

void sub_1011F62B4(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void sub_1011F62C8(void **__p)
{
  if (*((char *)__p + 47) < 0) {
    operator delete(__p[3]);
  }

  operator delete(__p);
}

void sub_1011F630C(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *(void *)(a2 + 16);
  *(_OWORD *)long long __p = *(_OWORD *)a2;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v2 = *(unsigned __int8 *)(a1 + 47);
  if ((v2 & 0x80u) == 0) {
    long long v3 = (void *)*(unsigned __int8 *)(a1 + 47);
  }
  else {
    long long v3 = *(void **)(a1 + 32);
  }
  uint64_t v4 = (void *)HIBYTE(v11);
  int v5 = SHIBYTE(v11);
  if (v11 < 0) {
    uint64_t v4 = __p[1];
  }
  if (v3 != v4) {
    goto LABEL_19;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (const void **)(a1 + 24);
  if (v11 >= 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*v7, v8, *(void *)(a1 + 32))) {
      goto LABEL_19;
    }
LABEL_16:
    unsigned int v9 = *(std::__shared_weak_count **)(v6 + 48);
    if (v9)
    {
      if (std::__shared_weak_count::lock(v9)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  if (!*(unsigned char *)(a1 + 47)) {
    goto LABEL_16;
  }
  while (*(unsigned __int8 *)v7 == *(unsigned __int8 *)v8)
  {
    uint64_t v7 = (const void **)((char *)v7 + 1);
    uint64_t v8 = (void **)((char *)v8 + 1);
    if (!--v2) {
      goto LABEL_16;
    }
  }
LABEL_19:
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_1011F64B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1011F64F0()
{
}

void sub_1011F64FC(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_1011F0760(**a1, *((unsigned __int8 *)*a1 + 8), *((unsigned __int8 *)*a1 + 12));
  operator delete();
}

void sub_1011F6558()
{
}

uint64_t sub_1011F6584()
{
  return __cxa_atexit((void (*)(void *))sub_1011E54BC, &DataPlanManagerBootstrap::sInstance, (void *)&_mh_execute_header);
}

void sub_1011F68D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F6CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F6FC8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1011F735C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15, uint64_t a16)
{
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }

  _Unwind_Resume(a1);
}

void sub_1011F7740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F7B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15, uint64_t a16)
{
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }

  _Unwind_Resume(a1);
}

void sub_1011F7F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F830C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t a11, char a12, uint64_t a13, dispatch_object_t object, char a15, uint64_t a16)
{
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }

  _Unwind_Resume(a1);
}

void sub_1011F86F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F8AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F8EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, char a11, dispatch_object_t object, char a13, uint64_t a14)
{
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1011F94D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, int a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,dispatch_object_t object,char a34,uint64_t a35)
{
  sub_1000793FC((uint64_t)&a34);
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a9);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1011F95D4(uint64_t a1)
{
  return a1;
}

void sub_1011F9600(uint64_t a1)
{
  operator delete();
}

void *sub_1011F964C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F120;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011F96A4(uint64_t a1, void *a2)
{
  *a2 = off_101A9F120;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011F96EC(uint64_t a1)
{
}

void sub_1011F96F4(id *a1)
{
  operator delete(a1);
}

void sub_1011F9730(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  long long v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  char v5 = sub_10135929C(*(_DWORD *)(a2 + 16));
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = sub_10135930C(*v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1011F97D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011F9800(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F180)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011F9840()
{
  return &off_101A9F180;
}

uint64_t sub_1011F984C(uint64_t a1)
{
  return a1;
}

void sub_1011F9878(uint64_t a1)
{
  operator delete();
}

void *sub_1011F98C4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F1A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011F991C(uint64_t a1, void *a2)
{
  *a2 = off_101A9F1A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011F9964(uint64_t a1)
{
}

void sub_1011F996C(id *a1)
{
  operator delete(a1);
}

void sub_1011F99A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  long long v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  char v5 = sub_10135929C(*(_DWORD *)(a2 + 16));
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = sub_1013593D8(*v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1011F9A50(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011F9A78(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F200)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011F9AB8()
{
  return &off_101A9F200;
}

uint64_t sub_1011F9AC4(uint64_t a1)
{
  return a1;
}

void sub_1011F9AF0(uint64_t a1)
{
  operator delete();
}

void *sub_1011F9B3C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F220;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011F9B94(uint64_t a1, void *a2)
{
  *a2 = off_101A9F220;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011F9BDC(uint64_t a1)
{
}

void sub_1011F9BE4(id *a1)
{
  operator delete(a1);
}

void sub_1011F9C20(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  long long v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  char v5 = sub_10135929C(*(_DWORD *)(a2 + 16));
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = sub_1013594A8(*v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1011F9CC8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011F9CF0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F280)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011F9D30()
{
  return &off_101A9F280;
}

uint64_t sub_1011F9D3C(uint64_t a1)
{
  return a1;
}

void sub_1011F9D68(uint64_t a1)
{
  operator delete();
}

void *sub_1011F9DB4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F2A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011F9E0C(uint64_t a1, void *a2)
{
  *a2 = off_101A9F2A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011F9E54(uint64_t a1)
{
}

void sub_1011F9E5C(id *a1)
{
  operator delete(a1);
}

void sub_1011F9E98(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10135929C(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1011F9EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1011F9F10(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F300)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011F9F50()
{
  return &off_101A9F300;
}

uint64_t sub_1011F9F5C(uint64_t a1)
{
  return a1;
}

void sub_1011F9F88(uint64_t a1)
{
  operator delete();
}

void *sub_1011F9FD4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F320;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FA02C(uint64_t a1, void *a2)
{
  *a2 = off_101A9F320;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FA074(uint64_t a1)
{
}

void sub_1011FA07C(id *a1)
{
  operator delete(a1);
}

void sub_1011FA0B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  id v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  char v5 = sub_10135929C(*(_DWORD *)(a2 + 16));
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = sub_101359D0C(*v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1011FA160(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011FA188(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F380)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FA1C8()
{
  return &off_101A9F380;
}

uint64_t sub_1011FA1D4(uint64_t a1)
{
  return a1;
}

void sub_1011FA200(uint64_t a1)
{
  operator delete();
}

void *sub_1011FA24C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F3A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FA2A4(uint64_t a1, void *a2)
{
  *a2 = off_101A9F3A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FA2EC(uint64_t a1)
{
}

void sub_1011FA2F4(id *a1)
{
  operator delete(a1);
}

void sub_1011FA330(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10135929C(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1011FA394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1011FA3A8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F400)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FA3E8()
{
  return &off_101A9F400;
}

uint64_t sub_1011FA3F4(uint64_t a1)
{
  return a1;
}

void sub_1011FA420(uint64_t a1)
{
  operator delete();
}

void *sub_1011FA46C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F420;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FA4C4(uint64_t a1, void *a2)
{
  *a2 = off_101A9F420;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FA50C(uint64_t a1)
{
}

void sub_1011FA514(id *a1)
{
  operator delete(a1);
}

void sub_1011FA550(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  id v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  char v5 = sub_10135929C(*(_DWORD *)(a2 + 16));
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = sub_10135A25C(*v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1011FA5F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011FA620(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F480)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FA660()
{
  return &off_101A9F480;
}

uint64_t sub_1011FA66C(uint64_t a1)
{
  return a1;
}

void sub_1011FA698(uint64_t a1)
{
  operator delete();
}

void *sub_1011FA6E4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F4A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FA73C(uint64_t a1, void *a2)
{
  *a2 = off_101A9F4A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FA784(uint64_t a1)
{
}

void sub_1011FA78C(id *a1)
{
  operator delete(a1);
}

void sub_1011FA7C8(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10135929C(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1011FA82C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1011FA840(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F500)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FA880()
{
  return &off_101A9F500;
}

uint64_t sub_1011FA88C(uint64_t a1)
{
  return a1;
}

void sub_1011FA8B8(uint64_t a1)
{
  operator delete();
}

void *sub_1011FA904(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F520;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FA95C(uint64_t a1, void *a2)
{
  *a2 = off_101A9F520;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FA9A4(uint64_t a1)
{
}

void sub_1011FA9AC(id *a1)
{
  operator delete(a1);
}

void sub_1011FA9E8(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10135929C(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1011FAA4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1011FAA60(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F580)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FAAA0()
{
  return &off_101A9F580;
}

uint64_t sub_1011FAAAC(uint64_t a1)
{
  return a1;
}

void sub_1011FAAD8(uint64_t a1)
{
  operator delete();
}

void *sub_1011FAB24(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F5A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FAB7C(uint64_t a1, void *a2)
{
  *a2 = off_101A9F5A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FABC4(uint64_t a1)
{
}

void sub_1011FABCC(id *a1)
{
  operator delete(a1);
}

void sub_1011FAC08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void ***)a2;
  id v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  char v5 = sub_10135929C(*(_DWORD *)(a2 + 16));
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = sub_10135A32C(*v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

void sub_1011FACB0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1011FACD8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F600)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FAD18()
{
  return &off_101A9F600;
}

uint64_t sub_1011FAD24(uint64_t a1)
{
  return a1;
}

void sub_1011FAD50(uint64_t a1)
{
  operator delete();
}

void *sub_1011FAD9C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A9F620;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1011FADF4(uint64_t a1, void *a2)
{
  *a2 = off_101A9F620;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1011FAE3C(uint64_t a1)
{
}

void sub_1011FAE44(id *a1)
{
  operator delete(a1);
}

void sub_1011FAE80(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_10135929C(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1011FAEE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1011FAEF8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A9F680)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1011FAF38()
{
  return &off_101A9F680;
}

void sub_1011FAF44(uint64_t a1)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 2) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = a1 + 48;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)operator new(8uLL) = @"Stewie";
  sub_100076430((void *)(a1 + 64));
}

void sub_1011FB03C(_Unwind_Exception *a1)
{
  operator delete(v3);
  uint64_t v5 = *(void *)(v1 + 72);
  *(void *)(v1 + 72) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  sub_10005CD2C(v2, *(char **)(v1 + 48));
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 32);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (v7) {
    sub_10004D2C8(v7);
  }
  _Unwind_Resume(a1);
}

void sub_1011FB0C4(uint64_t a1)
{
  *(void *)a1 = &off_101A9F6A0;
  *(void *)(a1 + 8) = off_101A9F890;
  *(void *)(a1 + 56) = off_101A9F8C8;
  *(void *)(a1 + 64) = off_101A9F8F8;
  *(void *)(a1 + 72) = off_101A9F930;
  *(void *)(a1 + 80) = off_101A9FA40;
  *(void *)(a1 + 88) = off_101A9FA70;
  uint64_t v2 = *(void *)(a1 + 2768);
  *(void *)(a1 + 2768) = 0;
  if (v2) {
    sub_10026CD9C(a1 + 2768, v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 2752);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 2728);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 2680);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 2664);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 2640);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 2616);
  *(void *)(a1 + 2616) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 2600);
  *(void *)(a1 + 2600) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
  }
  sub_10005CD2C(a1 + 2568, *(char **)(a1 + 2576));
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 2560);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 2544);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(void *)(a1 + 2520);
  *(void *)(a1 + 2520) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
  }
  uint64_t v13 = *(void *)(a1 + 2504);
  *(void *)(a1 + 2504) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
  }
  sub_10005CD2C(a1 + 2472, *(char **)(a1 + 2480));
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 2464);
  if (v14) {
    sub_10004D2C8(v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 2448);
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = *(void *)(a1 + 2408);
  *(void *)(a1 + 2408) = 0;
  if (v16) {
    sub_10026CD9C(a1 + 2408, v16);
  }
  uint64_t v17 = *(void *)(a1 + 2376);
  *(void *)(a1 + 2376) = 0;
  if (v17) {
    sub_10026CD9C(a1 + 2376, v17);
  }
  char v18 = *(std::__shared_weak_count **)(a1 + 2360);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_100160A84((atomic_uint **)(a1 + 2296));
  __int16 v19 = *(std::__shared_weak_count **)(a1 + 2288);
  if (v19) {
    sub_10004D2C8(v19);
  }
  char v20 = *(std::__shared_weak_count **)(a1 + 2272);
  if (v20) {
    sub_10004D2C8(v20);
  }
  unsigned int v21 = *(std::__shared_weak_count **)(a1 + 2256);
  if (v21) {
    sub_10004D2C8(v21);
  }
  unint64_t v22 = *(std::__shared_weak_count **)(a1 + 2240);
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(a1 + 2224);
  if (v23) {
    sub_10004D2C8(v23);
  }
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 2048));
  BOOL v24 = *(std::__shared_weak_count **)(a1 + 2040);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_100BA5304(*(void **)(a1 + 2008));
  unint64_t v25 = *(std::__shared_weak_count **)(a1 + 1984);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(a1 + 1952);
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 1936);
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_1000346F8(a1 + 1896, *(void **)(a1 + 1904));
  sub_1000346F8(a1 + 1872, *(void **)(a1 + 1880));
  sub_10005CD2C(a1 + 1832, *(char **)(a1 + 1840));
  sub_10003FB28(a1 + 1808, *(void **)(a1 + 1816));
  uint64_t v28 = (void **)(a1 + 1784);
  sub_100047F64(&v28);
  sub_1000886C0(a1 + 1752, *(char **)(a1 + 1760));
  sub_100136194(a1 + 944);
  sub_100136194(a1 + 144);
  sub_101208508((void *)(a1 + 96));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  StewieInterface::~StewieInterface((StewieInterface *)a1);
}

uint64_t sub_1011FB458(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  sub_10005CD2C(a1 + 40, *(char **)(a1 + 48));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_1011FB504(uint64_t a1)
{
}

void sub_1011FB50C(uint64_t a1)
{
}

void sub_1011FB514(uint64_t a1)
{
}

void sub_1011FB51C(uint64_t a1)
{
}

void sub_1011FB524(uint64_t a1)
{
}

void sub_1011FB52C(uint64_t a1)
{
}

void sub_1011FB534(uint64_t a1)
{
  sub_1011FB0C4(a1);

  operator delete();
}

void sub_1011FB56C(uint64_t a1)
{
  sub_1011FB0C4(a1 - 8);

  operator delete();
}

void sub_1011FB5A8(uint64_t a1)
{
  sub_1011FB0C4(a1 - 56);

  operator delete();
}

void sub_1011FB5E4(uint64_t a1)
{
  sub_1011FB0C4(a1 - 64);

  operator delete();
}

void sub_1011FB620(uint64_t a1)
{
  sub_1011FB0C4(a1 - 72);

  operator delete();
}

void sub_1011FB65C(uint64_t a1)
{
  sub_1011FB0C4(a1 - 80);

  operator delete();
}

void sub_1011FB698(uint64_t a1)
{
  sub_1011FB0C4(a1 - 88);

  operator delete();
}

void StewieController::create(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::supportsStewie(a1))
  {
    if (_os_feature_enabled_impl())
    {
      *(_OWORD *)std::string buf = 0u;
      long long v6 = 0u;
      uint64_t v3 = operator new(8uLL);
      *(void *)uint64_t v7 = v3;
      *uint64_t v3 = @"Stewie";
      uint64_t v8 = v3 + 1;
      uint64_t v9 = v3 + 1;
      sub_1005CBE24(buf);
    }
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "stw.ctr");
    uint64_t v4 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Not enabled", buf, 2u);
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_1011FBFAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ctu::OsLogLogger *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,dispatch_object_t object,dispatch_object_t a29)
{
  uint64_t v29 = a18;
  a18 = 0;
  if (v29) {
    sub_10026CD9C((uint64_t)&a18, v29);
  }
  _Unwind_Resume(exception_object);
}

void sub_1011FC370()
{
  uint64_t v1 = *(void **)(v0 - 128);
  if (v1)
  {
    *(void *)(v0 - 120) = v1;
    operator delete(v1);
  }
  JUMPOUT(0x1011FC29CLL);
}

uint64_t sub_1011FC388(uint64_t a1)
{
  unsigned int v2 = atomic_load((unsigned int *)(a1 + 1960));
  if (v2 == 1 && sub_10025B63C(a1 + 2368, 0) == 1)
  {
    int v3 = sub_10025B63C(a1 + 2400, 0);
    uint64_t result = 0;
    BOOL v5 = v3 == 1;
    long long v6 = (unsigned __int8 *)(a1 + 2624);
    unsigned __int8 v7 = atomic_load((unsigned __int8 *)(a1 + 2624));
    if (v5 == (v7 & 1)) {
      return result;
    }
  }
  else
  {
    LOBYTE(v5) = 0;
    uint64_t result = 0;
    long long v6 = (unsigned __int8 *)(a1 + 2624);
    unsigned __int8 v8 = atomic_load((unsigned __int8 *)(a1 + 2624));
    if ((v8 & 1) == 0) {
      return result;
    }
  }
  atomic_store(v5, (unsigned __int8 *)(a1 + 2624));
  uint64_t v9 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v10 = atomic_load(v6);
    int v11 = 136315138;
    uint64_t v12 = asStringBool(v10 & 1);
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Stewie feature support status: %s", (uint8_t *)&v11, 0xCu);
  }
  return 1;
}

void sub_1011FC4A8(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v48, *(Registry **)(a1 + 1928));
  ctu::RestModule::connect();
  if (v49) {
    sub_10004D2C8(v49);
  }
  uint64_t v53 = 0;
  (*(void (**)(unsigned __int16 **__return_ptr))(**(void **)(a1 + 2600) + 8))(&v53);
  unsigned int v2 = v53;
  if (v53) {
    int v3 = sub_100080934;
  }
  else {
    int v3 = 0;
  }
  if (v3)
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    if (v53)
    {
      CFTypeID v4 = CFGetTypeID(v53);
      if (v4 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&__p, v2, v5);
      }
    }
    int data_low = LOWORD(__p.__r_.__value_.__l.__data_);
    uint64_t v7 = __p.__r_.__value_.__s.__data_[0] & 0x3F;
    if (!*(unsigned char *)(a1 + 2530)) {
      *(unsigned char *)(a1 + 2530) = 1;
    }
    *(_WORD *)(a1 + 2528) = v7;
    unsigned __int8 v8 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC897C(v7, &__p);
      uint64_t v9 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = data_low;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][Bystander location based] Supported services: %{public}s, Raw stored value: %hu", (uint8_t *)&buf, 0x12u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  sub_1000577C4((const void **)&v53);
  uint64_t v53 = 0;
  (*(void (**)(unsigned __int16 **__return_ptr))(**(void **)(a1 + 2504) + 8))(&v53);
  unsigned __int8 v10 = v53;
  if (v53) {
    int v11 = sub_100080934;
  }
  else {
    int v11 = 0;
  }
  if (v11)
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    if (v53)
    {
      CFTypeID v12 = CFGetTypeID(v53);
      if (v12 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)&__p, v10, v13);
      }
    }
    int v14 = LOWORD(__p.__r_.__value_.__l.__data_);
    uint64_t v15 = __p.__r_.__value_.__s.__data_[0] & 0x3F;
    if (!*(unsigned char *)(a1 + 2434)) {
      *(unsigned char *)(a1 + 2434) = 1;
    }
    *(_WORD *)(a1 + 2432) = v15;
    uint64_t v16 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC897C(v15, &__p);
      uint64_t v17 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v14;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][MCC and MNC based] Supported services: %{public}s, Raw stored value: %hu", (uint8_t *)&buf, 0x12u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  sub_1000577C4((const void **)&v53);
  uint64_t v53 = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 2616) + 8))(&__p);
  sub_100044D6C(&v53, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
  if (v53) {
    char v18 = sub_100083F10;
  }
  else {
    char v18 = 0;
  }
  if (v18)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)v53);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v53, i);
        if (ValueAtIndex)
        {
          CFTypeID v22 = CFGetTypeID(ValueAtIndex);
          if (v22 == CFStringGetTypeID())
          {
            memset(&buf, 0, sizeof(buf));
            memset(&__p, 0, sizeof(__p));
            ctu::cf::assign();
            std::string buf = __p;
            uint64_t v23 = *(NSObject **)(a1 + 48);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_std::string buf = &buf;
              }
              else {
                p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
              }
              LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][Derived ISO][Bystander location based] ISO: %s", (uint8_t *)&__p, 0xCu);
            }
            sub_1000EA6A0((uint64_t **)(a1 + 2568), (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
        }
      }
    }
  }
  sub_100044D00((const void **)&v53);
  uint64_t v53 = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 2520) + 8))(&__p);
  sub_100044D6C(&v53, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
  if (v53) {
    unint64_t v25 = sub_100083F10;
  }
  else {
    unint64_t v25 = 0;
  }
  if (v25)
  {
    CFIndex v26 = CFArrayGetCount((CFArrayRef)v53);
    if (v26 >= 1)
    {
      for (CFIndex j = 0; j != v26; ++j)
      {
        uint64_t v28 = CFArrayGetValueAtIndex((CFArrayRef)v53, j);
        if (v28)
        {
          CFTypeID v29 = CFGetTypeID(v28);
          if (v29 == CFStringGetTypeID())
          {
            memset(&buf, 0, sizeof(buf));
            memset(&__p, 0, sizeof(__p));
            ctu::cf::assign();
            std::string buf = __p;
            BOOL v30 = *(NSObject **)(a1 + 48);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                __int16 v31 = &buf;
              }
              else {
                __int16 v31 = (std::string *)buf.__r_.__value_.__r.__words[0];
              }
              LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I [Bootstrap][Loaded][Derived ISO][MCC and MNC based] ISO: %s", (uint8_t *)&__p, 0xCu);
            }
            sub_1000EA6A0((uint64_t **)(a1 + 2472), (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
          }
        }
      }
    }
  }
  sub_100044D00((const void **)&v53);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v32, *(Registry **)(a1 + 1928));
  int v34 = ServiceMap;
  if ((v35 & 0x8000000000000000) != 0)
  {
    int v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v37 = 5381;
    do
    {
      std::string::size_type v35 = v37;
      unsigned int v38 = *v36++;
      uint64_t v37 = (33 * v37) ^ v38;
    }
    while (v38);
  }
  std::mutex::lock(ServiceMap);
  __p.__r_.__value_.__r.__words[0] = v35;
  __int16 v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)&__p);
  if (v39)
  {
    uint64_t v41 = v39[3];
    long long v40 = (std::__shared_weak_count *)v39[4];
    if (v40)
    {
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v34);
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v40);
      char v42 = 0;
      if (!v41) {
        goto LABEL_77;
      }
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v41 = 0;
  }
  std::mutex::unlock(v34);
  long long v40 = 0;
  char v42 = 1;
  if (!v41) {
    goto LABEL_77;
  }
LABEL_74:
  sub_100058DB0(&__p, "com.apple.MobileSMS");
  *(unsigned char *)(a1 + 2808) = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)v41 + 128))(v41, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_100058DB0(&__p, "com.apple.findmy");
  *(unsigned char *)(a1 + 2809) = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)v41 + 128))(v41, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v42)
    {
LABEL_79:
      uint64_t v44 = *(void *)(a1 + 16);
      uint64_t v43 = *(std::__shared_weak_count **)(a1 + 24);
      if (v43)
      {
        uint64_t v45 = std::__shared_weak_count::lock(v43);
        if (v45)
        {
          unsigned int v46 = v45;
          atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v45);
          xpc_object_t v52 = 0;
          long long v47 = operator new(0x20uLL);
          *long long v47 = off_101A9FC78;
          v47[1] = a1;
          v47[2] = v44;
          void v47[3] = v46;
          xpc_object_t v52 = v47;
          sub_100201FC4((uint64_t)&v53, (void *)(a1 + 1928), (id *)(a1 + 32));
        }
      }
      sub_100088B9C();
    }
LABEL_78:
    sub_10004D2C8(v40);
    goto LABEL_79;
  }
LABEL_77:
  if (v42) {
    goto LABEL_79;
  }
  goto LABEL_78;
}

void sub_1011FDC9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,std::__shared_weak_count *a35,int a36,__int16 a37,char a38,char a39)
{
  sub_1000577C4((const void **)(v39 - 136));
  _Unwind_Resume(a1);
}

uint64_t sub_1011FDF54(uint64_t result)
{
  if (!*(unsigned char *)(result + 1966))
  {
    uint64_t v1 = result;
    unsigned int v2 = *(NSObject **)(result + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Entering E911 state", v3, 2u);
    }
    *(unsigned char *)(v1 + 1966) = 1;
    return sub_101203230(v1);
  }
  return result;
}

uint64_t sub_1011FDFD0(uint64_t result)
{
  if (*(unsigned char *)(result + 1966))
  {
    uint64_t v1 = result;
    unsigned int v2 = *(NSObject **)(result + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Exiting E911 state completed", v3, 2u);
    }
    *(unsigned char *)(v1 + 1966) = 0;
    return sub_101203230(v1);
  }
  return result;
}

uint64_t sub_1011FE048(uint64_t a1, int a2)
{
  if (capabilities::ct::requiresSeparateOperatingModeForStewie((capabilities::ct *)a1)) {
    int v4 = 7;
  }
  else {
    int v4 = 0;
  }
  CFNumberRef v5 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136315394;
    uint64_t v8 = asString();
    __int16 v9 = 2080;
    uint64_t v10 = asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Current operating mode is: %s, required mode: %s", (uint8_t *)&v7, 0x16u);
  }
  return (*(uint64_t (**)(void, BOOL))(**(void **)(a1 + 2232) + 104))(*(void *)(a1 + 2232), v4 == a2);
}

void sub_1011FE158(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void))(**(void **)(a1 + 2248) + 80))(*(void *)(a1 + 2248));
  if (*(unsigned char *)(*(void *)a3 + 49)) {
    return;
  }
  dispatch_object_t v89 = 0;
  uint64_t v90 = 0;
  uint64_t v87 = 0;
  uint64_t v88 = &v89;
  xpc_object_t v85 = &v86;
  xpc_object_t v86 = 0;
  CFNumberRef v5 = *(uint64_t ***)(a1 + 2200);
  int v7 = *v5;
  long long v6 = v5[1];
  if (*v5 != v6)
  {
    do
    {
      uint64_t v8 = *v7;
      if (!*(unsigned char *)(*v7 + 48) || *(unsigned char *)(v8 + 49)) {
        goto LABEL_24;
      }
      int v9 = *(_DWORD *)(v8 + 52);
      LODWORD(v81) = v9;
      if (*(char *)(v8 + 47) < 0)
      {
        sub_10004FC84(&__p, *(void **)(v8 + 24), *(void *)(v8 + 32));
        uint64_t v8 = *v7;
        int v9 = (int)v81;
      }
      else
      {
        long long __p = *(_OWORD *)(v8 + 24);
        uint64_t v83 = *(void *)(v8 + 40);
      }
      char v10 = *(unsigned char *)(v8 + 62);
      char v84 = v10;
      int v11 = v89;
      for (i = &v89; ; int v11 = *i)
      {
        CFNumberRef v13 = i;
        if (!v11) {
          break;
        }
        while (1)
        {
          CFIndex i = (uint64_t **)v11;
          int v14 = *((_DWORD *)v11 + 8);
          if (v14 > v9) {
            break;
          }
          if (v14 >= v9) {
            goto LABEL_21;
          }
          int v11 = i[1];
          if (!v11)
          {
            CFNumberRef v13 = i + 1;
            goto LABEL_15;
          }
        }
      }
LABEL_15:
      uint64_t v15 = (char *)operator new(0x48uLL);
      *((_DWORD *)v15 + 8) = v9;
      uint64_t v16 = v15 + 40;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(v16, (void *)__p, *((unint64_t *)&__p + 1));
        char v10 = v84;
      }
      else
      {
        *(_OWORD *)uint64_t v16 = __p;
        *((void *)v15 + 7) = v83;
      }
      v15[64] = v10;
      *(void *)uint64_t v15 = 0;
      *((void *)v15 + 1) = 0;
      *((void *)v15 + 2) = i;
      *CFNumberRef v13 = (uint64_t *)v15;
      if (*v88)
      {
        uint64_t v88 = (uint64_t **)*v88;
        uint64_t v15 = (char *)*v13;
      }
      sub_100046C90(v89, (uint64_t *)v15);
      ++v90;
LABEL_21:
      if (SHIBYTE(v83) < 0) {
        operator delete((void *)__p);
      }
      uint64_t v17 = *v7;
      if (*(unsigned char *)(*v7 + 62)) {
        goto LABEL_24;
      }
      if (*(char *)(v17 + 95) < 0)
      {
        if (*(void *)(v17 + 80))
        {
LABEL_30:
          char v18 = (uint64_t *)operator new(0x10uLL);
          *(void *)&long long __p = v18 + 2;
          *((void *)&__p + 1) = v18 + 2;
          *char v18 = @"Roadside";
          v18[1] = @"SupportedProviderIds";
          CFArrayRef theArray = 0;
          xpc_object_t v81 = v18;
          ServiceMap = (std::mutex *)Registry::getServiceMap(v18 + 2, *(Registry **)(a1 + 1928));
          char v20 = ServiceMap;
          if (v21 < 0)
          {
            CFTypeID v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v23 = 5381;
            do
            {
              uint64_t v21 = v23;
              unsigned int v24 = *v22++;
              uint64_t v23 = (33 * v23) ^ v24;
            }
            while (v24);
          }
          std::mutex::lock(ServiceMap);
          *(void *)std::string buf = v21;
          unint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)buf);
          if (v25)
          {
            uint64_t v27 = v25[3];
            CFIndex v26 = (std::__shared_weak_count *)v25[4];
            if (v26)
            {
              atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v20);
              atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v26);
              char v28 = 0;
LABEL_38:
              (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, void **, void, void))(*(void *)v27 + 104))(&v79, v27, *(unsigned int *)(*v7 + 52), 1, &v81, 0, 0);
              sub_100044D6C(&theArray, &v79);
              sub_1000577C4(&v79);
              if ((v28 & 1) == 0) {
                sub_10004D2C8(v26);
              }
              if (theArray) {
                CFTypeID v29 = sub_100083F10;
              }
              else {
                CFTypeID v29 = 0;
              }
              if (v29)
              {
                CFIndex Count = CFArrayGetCount(theArray);
                if (Count >= 1)
                {
                  for (CFIndex j = 0; j != Count; ++j)
                  {
                    CFTypeRef ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex(theArray, j);
                    uint64_t v33 = ValueAtIndex;
                    if (ValueAtIndex && (CFTypeID v34 = CFGetTypeID(ValueAtIndex), v34 == CFNumberGetTypeID()))
                    {
                      *(_DWORD *)std::string buf = 0;
                      ctu::cf::assign((ctu::cf *)buf, v33, v35);
                      int v36 = *(_DWORD *)buf;
                      uint64_t v37 = v86;
                      unsigned int v38 = &v86;
LABEL_49:
                      uint64_t v39 = v38;
                      if (v37)
                      {
                        while (1)
                        {
                          unsigned int v38 = (uint64_t **)v37;
                          unsigned int v40 = *((_DWORD *)v37 + 8);
                          if (v40 > *(_DWORD *)buf)
                          {
                            uint64_t v37 = *v38;
                            goto LABEL_49;
                          }
                          if (v40 >= *(_DWORD *)buf) {
                            break;
                          }
                          uint64_t v37 = v38[1];
                          if (!v37)
                          {
                            uint64_t v39 = v38 + 1;
                            goto LABEL_60;
                          }
                        }
                        char v42 = (char *)v38;
                      }
                      else
                      {
LABEL_60:
                        char v42 = (char *)operator new(0x40uLL);
                        *((_DWORD *)v42 + 8) = v36;
                        *((void *)v42 + 7) = 0;
                        *((void *)v42 + 6) = 0;
                        *((void *)v42 + 5) = v42 + 48;
                        *(void *)char v42 = 0;
                        *((void *)v42 + 1) = 0;
                        *((void *)v42 + 2) = v38;
                        void *v39 = (uint64_t *)v42;
                        uint64_t v43 = (uint64_t *)v42;
                        if (*v85)
                        {
                          xpc_object_t v85 = (uint64_t **)*v85;
                          uint64_t v43 = *v39;
                        }
                        sub_100046C90(v86, v43);
                        ++v87;
                      }
                      sub_100046BAC((uint64_t **)v42 + 5, (void **)(*v7 + 72), *v7 + 72);
                      uint64_t v44 = *(NSObject **)(a1 + 48);
                      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v45 = (void *)(*v7 + 72);
                        if (*(char *)(*v7 + 95) < 0) {
                          uint64_t v45 = (void *)*v45;
                        }
                        *(_DWORD *)std::string buf = 67109378;
                        *(_DWORD *)&uint8_t buf[4] = v36;
                        *(_WORD *)&uint8_t buf[8] = 2080;
                        *(void *)&std::string buf[10] = v45;
                        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I ProviderId: %u is associated with phone number: %s", buf, 0x12u);
                      }
                    }
                    else
                    {
                      uint64_t v41 = *(NSObject **)(a1 + 48);
                      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v46 = subscriber::asString();
                        *(_DWORD *)std::string buf = 136315394;
                        *(void *)&uint8_t buf[4] = v46;
                        *(_WORD *)&unsigned char buf[12] = 2048;
                        *(void *)&buf[14] = j;
                        _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "[Skipping] Found invalid entry in carrier bundle for slot: %s, at index: %ld, for SupportedProviderIds", buf, 0x16u);
                      }
                    }
                  }
                }
              }
              sub_100044D00((const void **)&theArray);
              if (v81)
              {
                *(void *)&long long __p = v81;
                operator delete(v81);
              }
              goto LABEL_24;
            }
          }
          else
          {
            uint64_t v27 = 0;
          }
          std::mutex::unlock(v20);
          CFIndex v26 = 0;
          char v28 = 1;
          goto LABEL_38;
        }
      }
      else if (*(unsigned char *)(v17 + 95))
      {
        goto LABEL_30;
      }
LABEL_24:
      v7 += 2;
    }
    while (v7 != v6);
  }
  long long v47 = *(void **)(a1 + 2280);
  if (v47)
  {
    if (v47[2] == v90)
    {
      char v50 = (void *)*v47;
      uint64_t v48 = v47 + 1;
      uint64_t v49 = v50;
      if (v50 == v48)
      {
LABEL_87:
        BOOL v57 = 1;
        goto LABEL_90;
      }
      uint64_t v51 = v88;
      while (*((_DWORD *)v49 + 8) == *((_DWORD *)v51 + 8)
           && sub_10001D294((unsigned __int8 *)v49 + 40, (unsigned __int8 *)v51 + 40)
           && *((unsigned __int8 *)v49 + 64) == *((unsigned __int8 *)v51 + 64))
      {
        xpc_object_t v52 = (void *)v49[1];
        uint64_t v53 = v49;
        if (v52)
        {
          do
          {
            uint64_t v49 = v52;
            xpc_object_t v52 = (void *)*v52;
          }
          while (v52);
        }
        else
        {
          do
          {
            uint64_t v49 = (void *)v53[2];
            BOOL v54 = *v49 == (void)v53;
            uint64_t v53 = v49;
          }
          while (!v54);
        }
        xpc_object_t v55 = v51[1];
        if (v55)
        {
          do
          {
            xpc_object_t v56 = (uint64_t **)v55;
            xpc_object_t v55 = (uint64_t *)*v55;
          }
          while (v55);
        }
        else
        {
          do
          {
            xpc_object_t v56 = (uint64_t **)v51[2];
            BOOL v54 = *v56 == (uint64_t *)v51;
            uint64_t v51 = v56;
          }
          while (!v54);
        }
        uint64_t v51 = v56;
        if (v49 == v48) {
          goto LABEL_87;
        }
      }
    }
    BOOL v57 = 0;
  }
  else
  {
    BOOL v57 = v90 == 0;
  }
LABEL_90:
  if (*(void *)(a1 + 2016) != v87) {
    goto LABEL_121;
  }
  unsigned int v58 = *(void **)(a1 + 2000);
  if (v58 != (void *)(a1 + 2008))
  {
    char v59 = v85;
    while (*((_DWORD *)v58 + 8) == *((_DWORD *)v59 + 8) && (uint64_t *)v58[7] == v59[7])
    {
      char v60 = (unsigned __int8 *)v58[5];
      if (v60 != (unsigned __int8 *)(v58 + 6))
      {
        size_t v61 = (unsigned __int8 *)v59[5];
        while ((sub_1000609C0((uint64_t)&v81, v60 + 32, v61 + 32) & 1) != 0)
        {
          int v62 = (unsigned __int8 *)*((void *)v60 + 1);
          int v63 = v60;
          if (v62)
          {
            do
            {
              char v60 = v62;
              int v62 = *(unsigned __int8 **)v62;
            }
            while (v62);
          }
          else
          {
            do
            {
              char v60 = (unsigned __int8 *)*((void *)v63 + 2);
              BOOL v54 = *(void *)v60 == (void)v63;
              int v63 = v60;
            }
            while (!v54);
          }
          std::string::size_type v64 = (unsigned __int8 *)*((void *)v61 + 1);
          if (v64)
          {
            do
            {
              dispatch_object_t v65 = v64;
              std::string::size_type v64 = *(unsigned __int8 **)v64;
            }
            while (v64);
          }
          else
          {
            do
            {
              dispatch_object_t v65 = (unsigned __int8 *)*((void *)v61 + 2);
              BOOL v54 = *(void *)v65 == (void)v61;
              size_t v61 = v65;
            }
            while (!v54);
          }
          size_t v61 = v65;
          if (v60 == (unsigned __int8 *)(v58 + 6)) {
            goto LABEL_109;
          }
        }
        break;
      }
LABEL_109:
      long long v66 = (void *)v58[1];
      if (v66)
      {
        do
        {
          size_t v67 = v66;
          long long v66 = (void *)*v66;
        }
        while (v66);
      }
      else
      {
        do
        {
          size_t v67 = (void *)v58[2];
          BOOL v54 = *v67 == (void)v58;
          unsigned int v58 = v67;
        }
        while (!v54);
      }
      unint64_t v68 = v59[1];
      if (v68)
      {
        do
        {
          uint64_t v69 = (uint64_t **)v68;
          unint64_t v68 = (uint64_t *)*v68;
        }
        while (v68);
      }
      else
      {
        do
        {
          uint64_t v69 = (uint64_t **)v59[2];
          BOOL v54 = *v69 == (uint64_t *)v59;
          char v59 = v69;
        }
        while (!v54);
      }
      int v70 = 1;
      char v59 = v69;
      unsigned int v58 = v67;
      if (v67 == (void *)(a1 + 2008)) {
        goto LABEL_122;
      }
    }
LABEL_121:
    int v70 = 0;
LABEL_122:
    if (v57) {
      goto LABEL_130;
    }
    goto LABEL_123;
  }
  int v70 = 1;
  if (!v57)
  {
LABEL_123:
    uint64_t v71 = v90;
    if (v90)
    {
      unsigned __int8 v72 = operator new(0x30uLL);
      *unsigned __int8 v72 = off_101AA0938;
      v72[1] = 0;
      int v73 = v89;
      v72[3] = v88;
      uint64_t v74 = v72 + 3;
      void v72[4] = v73;
      v72[2] = 0;
      void v72[5] = v71;
      v73[2] = (uint64_t)(v72 + 4);
      uint64_t v88 = &v89;
      dispatch_object_t v89 = 0;
      uint64_t v90 = 0;
    }
    else
    {
      unsigned __int8 v72 = 0;
      uint64_t v74 = 0;
    }
    *(void *)(a1 + 2280) = v74;
    xpc_object_t v75 = *(std::__shared_weak_count **)(a1 + 2288);
    *(void *)(a1 + 2288) = v72;
    if (v75) {
      sub_10004D2C8(v75);
    }
  }
LABEL_130:
  if (v70)
  {
    xpc_object_t v76 = v86;
  }
  else
  {
    uint64_t v77 = a1 + 2008;
    sub_100BA5304(*(void **)(a1 + 2008));
    xpc_object_t v76 = v86;
    *(void *)(a1 + 2000) = v85;
    *(void *)(a1 + 2008) = v76;
    uint64_t v78 = v87;
    *(void *)(a1 + 2016) = v87;
    if (v78)
    {
      v76[2] = v77;
      xpc_object_t v85 = &v86;
      xpc_object_t v86 = 0;
      uint64_t v87 = 0;
      xpc_object_t v76 = 0;
    }
    else
    {
      *(void *)(a1 + 2000) = v77;
    }
  }
  sub_100BA5304(v76);
  sub_10026D080((char *)v89);
  if (!v57) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 2232) + 120))(*(void *)(a1 + 2232), a1 + 2280);
  }
  if ((v70 & 1) == 0) {
    sub_1012020A0(a1);
  }

  sub_1012034D4(a1);
}

void sub_1011FEA80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,char *a35)
{
}

uint64_t sub_1011FEB30(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 2232) + 112))();
}

uint64_t sub_1011FEB58(uint64_t a1)
{
  void (***v141)(unsigned char *__return_ptr, void);
  char v142;
  BOOL *v143;
  NSObject *v144;
  NSObject *v145;
  std::string::size_type v146;
  NSObject *v147;
  std::string::size_type v148;
  NSObject *v149;
  std::string::size_type v150;
  NSObject *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unsigned char *v155;
  unsigned char *v156;
  const char *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  void *v164;
  void *v165;
  uint64_t v166;
  int *v167;
  int *v168;
  std::string v169;
  unsigned char buf[38];
  __int16 v171;
  uint64_t v172;
  __int16 v173;
  void *v174;
  __int16 v175;
  uint64_t v176;
  __int16 v177;
  uint64_t v178;
  __int16 v179;
  uint64_t v180;

  uint64_t v1 = a1;
  unsigned int v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] **************************", buf, 2u);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * StewieController state *", buf, 2u);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] **************************", buf, 2u);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 2624));
    uint64_t v4 = asStringBool(v3 & 1);
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Stewie feature support status: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = atomic_load((unsigned int *)(v1 + 1960));
    if (v5 > 2) {
      long long v6 = "???";
    }
    else {
      long long v6 = off_101AA0C88[v5];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] HWSupport: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10025B63C(v1 + 2368, 0);
    uint64_t v8 = "kDisabled";
    if (v7 == 1) {
      uint64_t v8 = "kEnabled";
    }
    if (v7 == 2) {
      uint64_t v8 = "kUnknown";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Supported based on min iOS version: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asStringBool(*(unsigned char *)(v1 + 1964));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] LazyBootstrapComplete: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = asStringBool(*(unsigned char *)(v1 + 1965));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] LazyStartComplete: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asStringBool(*(unsigned char *)(v1 + 1966));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] In E911: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asStringBool(*(unsigned char *)(v1 + 1967));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] In Emergency: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 1968)) {
      CFNumberRef v13 = "true";
    }
    else {
      CFNumberRef v13 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Emergency call active: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v14 = *(char *)(v1 + 1969);
    if (v14 > 2) {
      uint64_t v15 = "???";
    }
    else {
      uint64_t v15 = off_101AA0C70[v14];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Cell Service Status: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = asStringBool(*(unsigned char *)(v1 + 1970));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Can make Em call based on cell service status: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = asStringBool(*(unsigned char *)(v1 + 1972));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Cellular Internet active: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    char v18 = *(unsigned char **)(v1 + 1976);
    if (*v18) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v18[1] != 0;
    }
    uint64_t v20 = asStringBool(v19);
    uint64_t v21 = asStringBool(**(unsigned char **)(v1 + 1976));
    uint64_t v22 = asStringBool(*(unsigned char *)(*(void *)(v1 + 1976) + 1));
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v21;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&uint8_t buf[24] = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Internet active: %s [cellular: %s, wifi: %s]", buf, 0x20u);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = asStringBool(*(unsigned char *)(v1 + 1992));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Provisioned: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = asStringBool(*(unsigned char *)(v1 + 1993));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v24;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is feature requested: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = asStringBool(*(unsigned char *)(v1 + 1994));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is Disabled by network: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = asStringBool(*(unsigned char *)(v1 + 1995));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v26;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Is thermal pressure intolerable: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = "???";
    if (*(unsigned char *)(v1 + 2024) == 1) {
      uint64_t v27 = "kSatisfied";
    }
    if (*(unsigned char *)(v1 + 2024)) {
      char v28 = v27;
    }
    else {
      char v28 = "kNotSatisfied";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Preconditions Status: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v29 = *(char *)(v1 + 2025);
    if (v29 > 0xA) {
      BOOL v30 = "???";
    }
    else {
      BOOL v30 = off_101AA0C18[v29];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v30;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Preconditions Reason: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v31 = sub_10025B63C(v1 + 2400, 0) == 1;
    uint64_t v32 = asStringBool(v31);
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v32;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Did enter launch country once: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = asStringBool(*(unsigned char *)(v1 + 2625));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v33;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Authorized for bystander location: %s", buf, 0xCu);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = asStringBool(*(void *)(v1 + 2656) != 0);
    *(_DWORD *)std::string buf = 134218242;
    *(void *)&uint8_t buf[4] = 30;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v34;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Min gap between bystander location checks: %lld (In gap: %s)", buf, 0x16u);
    unsigned int v2 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v35 = asStringBool(*(void *)(v1 + 2632) != 0);
    uint64_t v36 = asStringBool(*(unsigned char *)(v1 + 2648));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v35;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v36;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Has cached bystander location: %s, did process: %s", buf, 0x16u);
  }
  uint64_t v37 = *(void **)(v1 + 2568);
  if (v37 != (void *)(v1 + 2576))
  {
    do
    {
      unsigned int v38 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v39 = v37 + 4;
        if (*((char *)v37 + 55) < 0) {
          uint64_t v39 = (void *)*v39;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v39;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I [d] [Derived ISO][Bystander location based] ISO: %s", buf, 0xCu);
      }
      unsigned int v40 = (void *)v37[1];
      if (v40)
      {
        do
        {
          uint64_t v41 = v40;
          unsigned int v40 = (void *)*v40;
        }
        while (v40);
      }
      else
      {
        do
        {
          uint64_t v41 = (void *)v37[2];
          BOOL v42 = *v41 == (void)v37;
          uint64_t v37 = v41;
        }
        while (!v42);
      }
      uint64_t v37 = v41;
    }
    while (v41 != (void *)(v1 + 2576));
  }
  uint64_t v43 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 2530))
    {
      sub_100BC897C(*(unsigned __int16 *)(v1 + 2528), (std::string *)buf);
      if (buf[23] >= 0) {
        uint64_t v44 = buf;
      }
      else {
        uint64_t v44 = *(unsigned char **)buf;
      }
      LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] [Bystander location based] Supported services: %{public}s", (uint8_t *)&v169, 0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)"<Not determined>";
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] [Bystander location based] Supported services: %{public}s", (uint8_t *)&v169, 0xCu);
    }
    uint64_t v43 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v45 = asStringBool(*(unsigned char *)(v1 + 2530)) != 0;
    uint64_t v46 = asStringBool(v45);
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v46;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [d] Important: MCC and MNC fallback is only used when bystander location based is not known. Is fallback in use: %s", buf, 0xCu);
  }
  long long v47 = *(void **)(v1 + 2000);
  if (v47 != (void *)(v1 + 2008))
  {
    do
    {
      uint64_t v48 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        int v49 = *((_DWORD *)v47 + 8);
        stewie::dumpToString((const void ***)v47 + 5, buf);
        char v50 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
        LODWORD(v169.__r_.__value_.__l.__data_) = 67109378;
        HIDWORD(v169.__r_.__value_.__r.__words[0]) = v49;
        LOWORD(v169.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v169.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v50;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I [d] [RoadsideProviderIdToPhoneNumbers] Provider id: %u, Associated phone numbers: %s", (uint8_t *)&v169, 0x12u);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }
      uint64_t v51 = (void *)v47[1];
      if (v51)
      {
        do
        {
          xpc_object_t v52 = v51;
          uint64_t v51 = (void *)*v51;
        }
        while (v51);
      }
      else
      {
        do
        {
          xpc_object_t v52 = (void *)v47[2];
          BOOL v42 = *v52 == (void)v47;
          long long v47 = v52;
        }
        while (!v42);
      }
      long long v47 = v52;
    }
    while (v52 != (void *)(v1 + 2008));
  }
  uint64_t v53 = *(void **)(v1 + 2536);
  v166 = v1;
  if (v53)
  {
    xpc_object_t v56 = (void *)*v53;
    xpc_object_t v55 = v53 + 1;
    BOOL v54 = v56;
    if (v56 != v55)
    {
      do
      {
        v167 = (int *)(v54 + 5);
        BOOL v57 = *(NSObject **)(v1 + 48);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v58 = v54 + 6;
          if (*((char *)v54 + 71) < 0) {
            unsigned int v58 = (void *)*v58;
          }
          int64x2_t v164 = v58;
          int v59 = *((_DWORD *)v54 + 10);
          uint64_t v60 = asStringBool(*((unsigned char *)v54 + 97));
          sub_10026CCB8((unsigned __int8 *)v54 + 136, &v169);
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v61 = &v169;
          }
          else {
            size_t v61 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          uint64_t v62 = asStringBool(*((unsigned char *)v54 + 96));
          int v63 = v54 + 9;
          if (*((char *)v54 + 95) < 0) {
            int v63 = (void *)*v63;
          }
          uint64_t v64 = asStringBool(*((unsigned char *)v54 + 138));
          BOOL v65 = sub_100A0766C((uint64_t)v167);
          uint64_t v66 = asStringBool(v65);
          uint64_t v67 = asStringBool(*((unsigned char *)v54 + 98));
          *(_DWORD *)std::string buf = 67111170;
          *(_DWORD *)&uint8_t buf[4] = v59;
          *(_WORD *)&uint8_t buf[8] = 2080;
          *(void *)&std::string buf[10] = v164;
          *(_WORD *)&unsigned char buf[18] = 2082;
          *(void *)&buf[20] = v60;
          *(_WORD *)&buf[28] = 2082;
          *(void *)&buf[30] = v61;
          long long v171 = 2080;
          unint64_t v172 = v62;
          unint64_t v173 = 2080;
          unint64_t v174 = v63;
          unint64_t v175 = 2080;
          v176 = v64;
          v177 = 2080;
          long long v178 = v66;
          long long v179 = 2080;
          v180 = v67;
          _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][Bystander location based] Provider id: %u, name: %s, supported by configuration: %{public}s, supported at location: %{public}s, supports pay per use: %s, bizID: %s, isTest: %s, isActive: %s, isCarrierProvider: %s", buf, 0x58u);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v169.__r_.__value_.__l.__data_);
          }
          uint64_t v1 = v166;
        }
        if (*((unsigned char *)v54 + 128))
        {
          unint64_t v68 = *(NSObject **)(v1 + 48);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            int v69 = *v167;
            stewie::dumpToString((const void ***)v54 + 13, buf);
            int v70 = buf;
            if (buf[23] < 0) {
              int v70 = *(unsigned char **)buf;
            }
            LODWORD(v169.__r_.__value_.__l.__data_) = 67109378;
            HIDWORD(v169.__r_.__value_.__r.__words[0]) = v69;
            LOWORD(v169.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v169.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v70;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][Bystander location based][Provider id: %u] Associated phone numbers: %s", (uint8_t *)&v169, 0x12u);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
        }
        uint64_t v71 = (void *)v54[1];
        if (v71)
        {
          do
          {
            unsigned __int8 v72 = v71;
            uint64_t v71 = (void *)*v71;
          }
          while (v71);
        }
        else
        {
          do
          {
            unsigned __int8 v72 = (void *)v54[2];
            BOOL v42 = *v72 == (void)v54;
            BOOL v54 = v72;
          }
          while (!v42);
        }
        BOOL v54 = v72;
      }
      while (v72 != v55);
    }
  }
  uint64_t v73 = *(void *)(v1 + 2552);
  if (v73)
  {
    if (*(unsigned char *)(v73 + 24))
    {
      uint64_t v74 = (void *)(v73 + 8);
      xpc_object_t v75 = *(void **)v73;
      if (*(void *)v73 != v73 + 8)
      {
        do
        {
          xpc_object_t v76 = *(NSObject **)(v1 + 48);
          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
          {
            sub_100BC897C(*((unsigned __int16 *)v75 + 16), (std::string *)buf);
            uint64_t v77 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
            LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)v77;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][Bystander location based] Services: %{public}s", (uint8_t *)&v169, 0xCu);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          uint64_t v78 = (uint64_t *)v75[5];
          xpc_object_t v79 = (uint64_t *)v75[6];
          while (v78 != v79)
          {
            xpc_object_t v80 = *(NSObject **)(v1 + 48);
            if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
            {
              xpc_object_t v81 = v78;
              if (*((char *)v78 + 23) < 0) {
                xpc_object_t v81 = (uint64_t *)*v78;
              }
              *(_DWORD *)std::string buf = 136446210;
              *(void *)&uint8_t buf[4] = v81;
              _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][Bystander location based]    -> Partner: %{public}s", buf, 0xCu);
            }
            v78 += 3;
          }
          xpc_object_t v82 = (void *)v75[1];
          if (v82)
          {
            do
            {
              uint64_t v83 = v82;
              xpc_object_t v82 = (void *)*v82;
            }
            while (v82);
          }
          else
          {
            do
            {
              uint64_t v83 = (void *)v75[2];
              BOOL v42 = *v83 == (void)v75;
              xpc_object_t v75 = v83;
            }
            while (!v42);
          }
          xpc_object_t v75 = v83;
        }
        while (v83 != v74);
        uint64_t v73 = *(void *)(v1 + 2552);
      }
    }
    int v84 = *(unsigned __int16 *)(v73 + 32);
    if (*(_WORD *)(v73 + 32))
    {
      xpc_object_t v85 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v84;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][Bystander location based] Footnote mask: %hu", buf, 8u);
      }
    }
  }
  xpc_object_t v86 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(v1 + 2488)) {
      uint64_t v87 = "";
    }
    else {
      uint64_t v87 = "<none>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v87;
    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I [d] MCC and MNC based ISOs: %s", buf, 0xCu);
  }
  uint64_t v88 = *(void **)(v1 + 2472);
  if (v88 != (void *)(v1 + 2480))
  {
    do
    {
      dispatch_object_t v89 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v90 = v88 + 4;
        if (*((char *)v88 + 55) < 0) {
          uint64_t v90 = (void *)*v90;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v90;
        _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "#I [d] [Derived ISO][MCC and MNC based] ISO: %s", buf, 0xCu);
      }
      uint64_t v91 = (void *)v88[1];
      if (v91)
      {
        do
        {
          long long v92 = v91;
          uint64_t v91 = (void *)*v91;
        }
        while (v91);
      }
      else
      {
        do
        {
          long long v92 = (void *)v88[2];
          BOOL v42 = *v92 == (void)v88;
          uint64_t v88 = v92;
        }
        while (!v42);
      }
      uint64_t v88 = v92;
    }
    while (v92 != (void *)(v1 + 2480));
  }
  __n128 v93 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 2434))
    {
      sub_100BC897C(*(unsigned __int16 *)(v1 + 2432), (std::string *)buf);
      if (buf[23] >= 0) {
        int v94 = buf;
      }
      else {
        int v94 = *(unsigned char **)buf;
      }
      LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)v94;
      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I [d] [MCC and MNC based] Supported services: %{public}s", (uint8_t *)&v169, 0xCu);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)"<Not determined>";
      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I [d] [MCC and MNC based] Supported services: %{public}s", (uint8_t *)&v169, 0xCu);
    }
  }
  unint64_t v95 = *(void **)(v1 + 2440);
  if (v95)
  {
    CFStringRef v98 = (void *)*v95;
    CFStringRef v97 = v95 + 1;
    char v96 = v98;
    if (v98 != v97)
    {
      do
      {
        long long v168 = (int *)(v96 + 5);
        int v99 = *(NSObject **)(v1 + 48);
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
        {
          long long v100 = v96 + 6;
          if (*((char *)v96 + 71) < 0) {
            long long v100 = (void *)*v100;
          }
          v165 = v100;
          int v101 = *((_DWORD *)v96 + 10);
          uint64_t v102 = asStringBool(*((unsigned char *)v96 + 97));
          sub_10026CCB8((unsigned __int8 *)v96 + 136, &v169);
          if ((v169.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            unint64_t v103 = &v169;
          }
          else {
            unint64_t v103 = (std::string *)v169.__r_.__value_.__r.__words[0];
          }
          uint64_t v104 = asStringBool(*((unsigned char *)v96 + 96));
          unint64_t v105 = v96 + 9;
          if (*((char *)v96 + 95) < 0) {
            unint64_t v105 = (void *)*v105;
          }
          uint64_t v106 = asStringBool(*((unsigned char *)v96 + 138));
          BOOL v107 = sub_100A0766C((uint64_t)v168);
          uint64_t v108 = asStringBool(v107);
          uint64_t v109 = asStringBool(*((unsigned char *)v96 + 98));
          *(_DWORD *)std::string buf = 67111170;
          *(_DWORD *)&uint8_t buf[4] = v101;
          *(_WORD *)&uint8_t buf[8] = 2080;
          *(void *)&std::string buf[10] = v165;
          *(_WORD *)&unsigned char buf[18] = 2082;
          *(void *)&buf[20] = v102;
          *(_WORD *)&buf[28] = 2082;
          *(void *)&buf[30] = v103;
          long long v171 = 2080;
          unint64_t v172 = v104;
          unint64_t v173 = 2080;
          unint64_t v174 = v105;
          unint64_t v175 = 2080;
          v176 = v106;
          v177 = 2080;
          long long v178 = v108;
          long long v179 = 2080;
          v180 = v109;
          _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][MCC and MNC based] Provider id: %u, name: %s, supported by configuration: %{public}s, supported at location: %{public}s, supports pay per use: %s, bizID: %s, isTest: %s, isActive: %s, isCarrierProvider: %s", buf, 0x58u);
          if (SHIBYTE(v169.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v169.__r_.__value_.__l.__data_);
          }
          uint64_t v1 = v166;
        }
        if (*((unsigned char *)v96 + 128))
        {
          xpc_object_t v110 = *(NSObject **)(v1 + 48);
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
          {
            int v111 = *v168;
            stewie::dumpToString((const void ***)v96 + 13, buf);
            uint64_t v112 = buf;
            if (buf[23] < 0) {
              uint64_t v112 = *(unsigned char **)buf;
            }
            LODWORD(v169.__r_.__value_.__l.__data_) = 67109378;
            HIDWORD(v169.__r_.__value_.__r.__words[0]) = v111;
            LOWORD(v169.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v169.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v112;
            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I [d] [Providers][MCC and MNC based][Provider id: %u] Associated phone numbers: %s", (uint8_t *)&v169, 0x12u);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
        }
        int v113 = (void *)v96[1];
        if (v113)
        {
          do
          {
            int v114 = v113;
            int v113 = (void *)*v113;
          }
          while (v113);
        }
        else
        {
          do
          {
            int v114 = (void *)v96[2];
            BOOL v42 = *v114 == (void)v96;
            char v96 = v114;
          }
          while (!v42);
        }
        char v96 = v114;
      }
      while (v114 != v97);
    }
  }
  uint64_t v115 = *(void *)(v1 + 2456);
  if (v115)
  {
    if (*(unsigned char *)(v115 + 24))
    {
      long long v116 = (void *)(v115 + 8);
      __n128 v117 = *(void **)v115;
      if (*(void *)v115 != v115 + 8)
      {
        do
        {
          unint64_t v118 = *(NSObject **)(v1 + 48);
          if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
          {
            sub_100BC897C(*((unsigned __int16 *)v117 + 16), (std::string *)buf);
            char v119 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
            LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
            *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)v119;
            _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][MCC and MNC based] Services: %{public}s", (uint8_t *)&v169, 0xCu);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          char v120 = (uint64_t *)v117[5];
          uint64_t v121 = (uint64_t *)v117[6];
          while (v120 != v121)
          {
            unint64_t v122 = *(NSObject **)(v1 + 48);
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
            {
              long long v123 = v120;
              if (*((char *)v120 + 23) < 0) {
                long long v123 = (uint64_t *)*v120;
              }
              *(_DWORD *)std::string buf = 136446210;
              *(void *)&uint8_t buf[4] = v123;
              _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][MCC and MNC based]    - Partner: %{public}s", buf, 0xCu);
            }
            v120 += 3;
          }
          uint64_t v124 = (void *)v117[1];
          if (v124)
          {
            do
            {
              unint64_t v125 = v124;
              uint64_t v124 = (void *)*v124;
            }
            while (v124);
          }
          else
          {
            do
            {
              unint64_t v125 = (void *)v117[2];
              BOOL v42 = *v125 == (void)v117;
              __n128 v117 = v125;
            }
            while (!v42);
          }
          __n128 v117 = v125;
        }
        while (v125 != v116);
        uint64_t v115 = *(void *)(v1 + 2456);
      }
    }
    int v126 = *(unsigned __int16 *)(v115 + 32);
    if (*(_WORD *)(v115 + 32))
    {
      uint64_t v127 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v126;
        _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "#I [d] [ServicePartners][MCC and MNC based] Footnote mask: %hu", buf, 8u);
      }
    }
  }
  long long v128 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v129 = asStringBool(*(unsigned char *)(v1 + 1996));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v129;
    _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#I [d] IMS registered for voice: %s", buf, 0xCu);
    long long v128 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 1999)) {
      __n128 v130 = (const char *)asStringBool(*(unsigned char *)(v1 + 1998));
    }
    else {
      __n128 v130 = "Unknown";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v130;
    _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#I [d] Is emergency call possible based on cached cell scan result: %s", buf, 0xCu);
    long long v128 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v132 = asStringBool(*(unsigned char *)(v1 + 1997));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v132;
    _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "#I [d] Is emergency call capable: %s", buf, 0xCu);
  }
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v131, *(Registry **)(v1 + 1928));
  __n128 v134 = ServiceMap;
  __n128 v135 = "20ProfileManagedConfig";
  if (((unint64_t)"20ProfileManagedConfig" & 0x8000000000000000) != 0)
  {
    unint64_t v136 = (unsigned __int8 *)((unint64_t)"20ProfileManagedConfig" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v137 = 5381;
    do
    {
      __n128 v135 = (const char *)v137;
      unsigned int v138 = *v136++;
      uint64_t v137 = (33 * v137) ^ v138;
    }
    while (v138);
  }
  std::mutex::lock(ServiceMap);
  v169.__r_.__value_.__r.__words[0] = (std::string::size_type)v135;
  unint64_t v139 = sub_10004D37C(&v134[1].__m_.__sig, (unint64_t *)&v169);
  if (v139)
  {
    unint64_t v141 = (void (***)(unsigned char *__return_ptr, void))v139[3];
    unint64_t v140 = (std::__shared_weak_count *)v139[4];
    if (v140)
    {
      atomic_fetch_add_explicit(&v140->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v134);
      atomic_fetch_add_explicit(&v140->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v140);
      long long v142 = 0;
      goto LABEL_253;
    }
  }
  else
  {
    unint64_t v141 = 0;
  }
  std::mutex::unlock(v134);
  unint64_t v140 = 0;
  long long v142 = 1;
LABEL_253:
  (**v141)(buf, v141);
  if ((v142 & 1) == 0) {
    sub_10004D2C8(v140);
  }
  uint64_t v143 = *(BOOL **)buf;
  if (*(void *)buf)
  {
    __n128 v144 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v169.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "#I [Profile] Is installed", (uint8_t *)&v169, 2u);
      uint64_t v143 = *(BOOL **)buf;
    }
    if (v143[1])
    {
      long long v145 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v146 = asStringBool(*v143);
        LODWORD(v169.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = v146;
        _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "#I [Profile] Mock mode: %s", (uint8_t *)&v169, 0xCu);
        uint64_t v143 = *(BOOL **)buf;
      }
    }
    if (v143[3])
    {
      unint64_t v147 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
      {
        long long v148 = asStringBool(v143[2]);
        LODWORD(v169.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = v148;
        _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEFAULT, "#I [Profile] Test mode: %s", (uint8_t *)&v169, 0xCu);
        uint64_t v143 = *(BOOL **)buf;
      }
    }
    if (v143[5])
    {
      long long v149 = *(NSObject **)(v1 + 48);
      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
      {
        long long v150 = asStringBool(v143[4]);
        LODWORD(v169.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = v150;
        _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "#I [Profile] Use Dev Namespace: %s", (uint8_t *)&v169, 0xCu);
      }
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  int64x2_t v151 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v152 = *(void *)(v1 + 2280);
    if (v152) {
      v152 = *(void *)(v152 + 16);
    }
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v152;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Number of active SIMs: %lu", buf, 0xCu);
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v153 = asStringBool(*(unsigned char *)(v1 + 2626));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v153;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Allow Emergency use cases in limited service: %s", buf, 0xCu);
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    char v154 = asStringBool(*(unsigned char *)(v1 + 1971));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v154;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Apply policy for satellite system: %s", buf, 0xCu);
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026B270(v1 + 2688, (std::string *)buf);
    if (buf[23] >= 0) {
      uint64_t v155 = buf;
    }
    else {
      uint64_t v155 = *(unsigned char **)buf;
    }
    LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)v155;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Disconnect messaging after ScreenLock, seconds: %{public}s", (uint8_t *)&v169, 0xCu);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    sub_10026B270(v1 + 2704, (std::string *)buf);
    if (buf[23] >= 0) {
      unint64_t v156 = buf;
    }
    else {
      unint64_t v156 = *(unsigned char **)buf;
    }
    LODWORD(v169.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)v169.__r_.__value_.__r.__words + 4) = (std::string::size_type)v156;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Disconnect messaging after ScreenLock when outgoing message is pending, seconds: %{public}s", (uint8_t *)&v169, 0xCu);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (*(void *)(v1 + 2720) && os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] DisconnectMessagingAfterScreenLockTimer is running", buf, 2u);
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(v1 + 2737))
    {
      if (*(unsigned char *)(v1 + 2736)) {
        v157 = "true";
      }
      else {
        v157 = "false";
      }
    }
    else
    {
      v157 = "<none>";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v157;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is SatSms provisioned: %s", buf, 0xCu);
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v158 = asStringBool(*(unsigned char *)(v1 + 2808));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v158;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is Messages installed: %s", buf, 0xCu);
    int64x2_t v151 = *(NSObject **)(v1 + 48);
  }
  if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
  {
    v159 = asStringBool(*(unsigned char *)(v1 + 2809));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v159;
    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I [d] Is FindMy installed: %s", buf, 0xCu);
  }
  v160 = *(void *)(v1 + 2232);
  if (v160) {
    (*(void (**)(uint64_t))(*(void *)v160 + 176))(v160);
  }
  v161 = *(void *)(v1 + 2032);
  if (v161) {
    (*(void (**)(uint64_t))(*(void *)v161 + 216))(v161);
  }
  long long v162 = *(void *)(v1 + 2216);
  if (v162) {
    (*(void (**)(uint64_t))(*(void *)v162 + 200))(v162);
  }
  return (*(uint64_t (**)(void))(**(void **)(v1 + 2248) + 136))(*(void *)(v1 + 2248));
}

void sub_1012007F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_101200858(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 136);
  if (v2 != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v5 = "yes";
      if (!v2) {
        unsigned int v5 = "no";
      }
      int v6 = 136315138;
      int v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Emergency call in progress: %s", (uint8_t *)&v6, 0xCu);
    }
    sub_101203230(a1);
    if (*(unsigned char *)(a1 + 136))
    {
      if (*(unsigned char *)(a1 + 1993))
      {
        int v6 = 4;
        LOBYTE(v7) = 0;
        BYTE2(v7) = 0;
        BYTE4(v7) = 0;
        sub_1012030EC(a1, &v6);
      }
    }
  }
}

void sub_101200958(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 140) != a2)
  {
    unsigned __int8 v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Airplane mode user preference: %s", (uint8_t *)&v4, 0xCu);
    }
    sub_101201E5C(a1);
    if (*(_DWORD *)(a1 + 140) == 2)
    {
      if (*(unsigned char *)(a1 + 1993))
      {
        int v4 = 2;
        LOBYTE(v5) = 0;
        BYTE2(v5) = 0;
        BYTE4(v5) = 1;
        sub_1012030EC(a1, &v4);
      }
    }
  }
}

void sub_101200A50(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 1744) != a2)
  {
    unsigned __int8 v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136315138;
      uint64_t v7 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I WiFiStatus: %s", (uint8_t *)&v6, 0xCu);
    }
    sub_101204500(a1);
    if (*(unsigned char *)(a1 + 1965))
    {
      uint64_t v4 = *(void *)(a1 + 2032);
      uint64_t v5 = sub_101203094(a1);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 80))(v4, a1 + 2320, v5);
    }
  }
}

void sub_101200B58(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 1768) == a2[2])
  {
    unsigned __int8 v3 = *(void **)(a1 + 1752);
    uint64_t v4 = a1 + 1760;
    if (v3 == (void *)(a1 + 1760)) {
      return;
    }
    uint64_t v5 = (void *)*a2;
    while (*((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8) && operator==())
    {
      int v6 = (void *)v3[1];
      uint64_t v7 = v3;
      if (v6)
      {
        do
        {
          unsigned __int8 v3 = v6;
          int v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unsigned __int8 v3 = (void *)v7[2];
          BOOL v8 = *v3 == (void)v7;
          uint64_t v7 = v3;
        }
        while (!v8);
      }
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v8);
      }
      uint64_t v5 = v10;
      if (v3 == (void *)v4) {
        return;
      }
    }
  }

  sub_100067A24(a1);
}

void sub_101200C50(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 1776);
  if (v2 != a2)
  {
    int v4 = v2 > 39;
    uint64_t v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = "";
      if (v2 > 39) {
        int v6 = "in";
      }
      int v7 = 67109378;
      int v8 = v2;
      __int16 v9 = 2080;
      uint64_t v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Thermal level changed to: %u, which is %stolerable", (uint8_t *)&v7, 0x12u);
    }
    if (*(unsigned __int8 *)(a1 + 1995) != v4)
    {
      *(unsigned char *)(a1 + 1995) = v4;
      sub_101201E5C(a1);
      if (v2 >= 40)
      {
        int v7 = 11;
        LOBYTE(v8) = 0;
        BYTE2(v8) = 0;
        LOBYTE(v9) = 1;
        sub_1012030EC(a1, &v7);
      }
    }
  }
}

void sub_101200D70(uint64_t a1)
{
  void (***v4)(uint8_t *__return_ptr, void, uint64_t, unsigned char *);
  NSObject *v5;
  char *v6;
  NSObject *v7;
  void *v8;
  char *v9;
  char **v10;
  BOOL v11;
  uint8_t buf[8];
  char *v13;
  uint64_t v14;
  void (***v15)(uint8_t *__return_ptr, void, uint64_t, unsigned char *);
  std::__shared_weak_count *v16;
  unsigned char __p[12];
  char v18;

  if (*(void *)(a1 + 1784) != *(void *)(a1 + 1792))
  {
    int v2 = (const ctu::OsLogLogger *)(a1 + 48);
    unsigned __int8 v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Preferred languages changed", buf, 2u);
    }
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    sub_100058DB0(buf, "/System/Library/Frameworks/CoreTelephony.framework/Support/CompressionConfig.plist");
    sub_10135BC84((uint64_t *)buf, v2, (uint64_t)&v15);
    if (SHIBYTE(v14) < 0) {
      operator delete(*(void **)buf);
    }
    int v4 = v15;
    if (v15)
    {
      uint64_t v5 = *(NSObject **)v2;
      if (os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Determining codecs to download (Assuming USA):", buf, 2u);
      }
      *(void *)std::string buf = 0;
      CFNumberRef v13 = 0;
      unint64_t v14 = 0;
      sub_100058DB0(__p, "USA");
      (**v4)(buf, v4, a1 + 1784, __p);
      if (v18 < 0) {
        operator delete(*(void **)__p);
      }
      int v6 = *(char **)buf;
      if (*(char ***)buf != &v13)
      {
        do
        {
          int v7 = *(NSObject **)v2;
          if (os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEFAULT))
          {
            int v8 = v6 + 32;
            if (v6[55] < 0) {
              int v8 = (void *)*v8;
            }
            *(_DWORD *)long long __p = 136315138;
            *(void *)&__p[4] = v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [codec]    %s", __p, 0xCu);
          }
          __int16 v9 = (char *)*((void *)v6 + 1);
          if (v9)
          {
            do
            {
              uint64_t v10 = (char **)v9;
              __int16 v9 = *(char **)v9;
            }
            while (v9);
          }
          else
          {
            do
            {
              uint64_t v10 = (char **)*((void *)v6 + 2);
              uint64_t v11 = *v10 == v6;
              int v6 = (char *)v10;
            }
            while (!v11);
          }
          int v6 = (char *)v10;
        }
        while (v10 != &v13);
      }
      (*(void (**)(void, uint8_t *))(**(void **)(a1 + 2216) + 176))(*(void *)(a1 + 2216), buf);
      sub_10005CD2C((uint64_t)buf, v13);
    }
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
}

void sub_101200FF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, char *a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10120105C(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(void **)(result + 1832);
  if (v2 == (void *)(result + 1840))
  {
LABEL_10:
    int v6 = 0;
  }
  else
  {
    while (*((_DWORD *)v2 + 14) != 1 || (*((unsigned char *)v2 + 60) & 1) == 0)
    {
      unsigned __int8 v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          int v4 = v3;
          unsigned __int8 v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          int v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          int v2 = v4;
        }
        while (!v5);
      }
      int v2 = v4;
      if (v4 == (void *)(result + 1840)) {
        goto LABEL_10;
      }
    }
    int v6 = 1;
  }
  if (*(unsigned __int8 *)(result + 1996) != v6)
  {
    *(unsigned char *)(result + 1996) = v6;
    int v7 = *(NSObject **)(result + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = "not ";
      if (v6) {
        int v8 = "";
      }
      int v9 = 136315138;
      uint64_t v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Voice call over IMS is %spossible", (uint8_t *)&v9, 0xCu);
    }
    return sub_101203E80(v1);
  }
  return result;
}

uint64_t sub_101201198(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 1856) != a2)
  {
    uint64_t v2 = result;
    unsigned __int8 v3 = *(NSObject **)(result + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Buddy state changed to: %s", (uint8_t *)&v4, 0xCu);
    }
    return sub_101201E5C(v2);
  }
  return result;
}

uint64_t sub_101201258(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 1864));
    int v5 = 136315138;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I TurnOffCellular forAllSims is: %s", (uint8_t *)&v5, 0xCu);
  }
  return sub_101201E5C(a1);
}

uint64_t sub_101201304(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (*(void *)(result + 1912) == a2[2])
  {
    uint64_t v3 = *(void **)(result + 1896);
    uint64_t v4 = result + 1904;
    if (v3 == (void *)(result + 1904)) {
      return result;
    }
    int v5 = (void *)*a2;
    while (*((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7))
    {
      uint64_t result = operator==();
      if (!result) {
        break;
      }
      uint64_t v6 = (void *)v3[1];
      int v7 = v3;
      if (v6)
      {
        do
        {
          uint64_t v3 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v7[2];
          BOOL v8 = *v3 == (void)v7;
          int v7 = v3;
        }
        while (!v8);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          int v5 = v10;
        }
        while (!v8);
      }
      int v5 = v10;
      if (v3 == (void *)v4) {
        return result;
      }
    }
  }

  return sub_100067704(v2);
}

void sub_1012013FC(uint64_t a1, unsigned char *a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 1923);
  int v5 = *(unsigned __int8 *)(a1 + 1921);
  int v6 = *(unsigned __int8 *)(a1 + 1920);
  if (*(unsigned char *)(a1 + 1923)) {
    BOOL v7 = *(unsigned char *)(a1 + 1921) == 0;
  }
  else {
    BOOL v7 = *(unsigned char *)(a1 + 1920) != 0;
  }
  BOOL v8 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = v6 != 0;
    if (v7) {
      uint64_t v10 = "";
    }
    else {
      uint64_t v10 = "in";
    }
    if (v5) {
      uint64_t v11 = "";
    }
    else {
      uint64_t v11 = "un";
    }
    if (v4) {
      uint64_t v12 = "";
    }
    else {
      uint64_t v12 = "not ";
    }
    int v14 = 136315906;
    uint64_t v15 = v10;
    __int16 v16 = 2080;
    uint64_t v17 = v11;
    __int16 v18 = 2080;
    BOOL v19 = v12;
    __int16 v20 = 2080;
    uint64_t v21 = asStringBool(v9);
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [Display Status: %sactive] %slocked, passcode: %sset, is on: %s", (uint8_t *)&v14, 0x2Au);
  }
  if (*(unsigned char *)(a1 + 1965)) {
    (*(void (**)(void, BOOL, void))(**(void **)(a1 + 2032) + 192))(*(void *)(a1 + 2032), v7, *(unsigned __int8 *)(a1 + 1922));
  }
  if (a2[3]) {
    BOOL v13 = a2[1] == 0;
  }
  else {
    BOOL v13 = *a2 != 0;
  }
  if (v7 != v13)
  {
    sub_101203F9C(a1);
    sub_101204164(a1);
  }
}

void sub_1012015AC(NSObject *a1)
{
  if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_DEFAULT, "#I Lazy bootstrap", v2, 2u);
  }
}

uint64_t sub_101201608(uint64_t a1, int a2)
{
  uint64_t result = sub_1011FC388(a1);
  int v5 = result;
  if ((result & 1) != 0 || a2)
  {
    int v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (v5) {
        BOOL v7 = "[Support Changed] ";
      }
      else {
        BOOL v7 = "";
      }
      if (a2) {
        BOOL v8 = "[Forced notify] ";
      }
      else {
        BOOL v8 = "";
      }
      unsigned __int8 v9 = atomic_load((unsigned __int8 *)(a1 + 2624));
      uint64_t v10 = asStringBool(v9 & 1);
      unsigned int v11 = atomic_load((unsigned int *)(a1 + 1960));
      if (v11 > 2) {
        uint64_t v12 = "???";
      }
      else {
        uint64_t v12 = off_101AA0C88[v11];
      }
      int v13 = 136315906;
      int v14 = v7;
      __int16 v15 = 2080;
      __int16 v16 = v8;
      __int16 v17 = 2080;
      uint64_t v18 = v10;
      __int16 v19 = 2080;
      __int16 v20 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sNotifying clients. Feature support status: %s, HWSupport: %s", (uint8_t *)&v13, 0x2Au);
    }
    return (***(uint64_t (****)(void))(a1 + 2672))(*(void *)(a1 + 2672));
  }
  return result;
}

uint64_t sub_101201768(uint64_t result)
{
  unsigned int v1 = atomic_load((unsigned int *)(result + 1960));
  if (v1 == 1)
  {
    uint64_t v2 = result;
    if (!*(unsigned char *)(result + 1965))
    {
      unsigned int v3 = atomic_load((unsigned int *)(result + 1960));
      if (v3 == 1 && !*(unsigned char *)(result + 1964))
      {
        *(unsigned char *)(result + 1964) = 1;
        sub_1012015AC(*(NSObject **)(result + 48));
      }
      int v4 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Lazy start", buf, 2u);
      }
      (*(void (**)(void))(**(void **)(v2 + 2232) + 16))(*(void *)(v2 + 2232));
      uint64_t v5 = *(void *)(v2 + 2216);
      *(void *)std::string buf = 0;
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v5 + 40))(v5, v2 + 2342, buf);
      if (*(void *)buf)
      {
        dispatch_group_leave(*(dispatch_group_t *)buf);
        if (*(void *)buf) {
          dispatch_release(*(dispatch_object_t *)buf);
        }
      }
      (*(void (**)(void))(**(void **)(v2 + 2216) + 48))(*(void *)(v2 + 2216));
      uint64_t v6 = *(void *)(v2 + 2248);
      *(void *)std::string buf = 0;
      (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v6 + 40))(v6, v2 + 2344, buf);
      if (*(void *)buf)
      {
        dispatch_group_leave(*(dispatch_group_t *)buf);
        if (*(void *)buf) {
          dispatch_release(*(dispatch_object_t *)buf);
        }
      }
      (*(void (**)(void))(**(void **)(v2 + 2248) + 48))(*(void *)(v2 + 2248));
      memset(&buf[22], 0, 26);
      *(_OWORD *)std::string buf = *(_OWORD *)(v2 + 2320);
      *(void *)&buf[14] = *(void *)(v2 + 2334);
      char v7 = sub_101202E14(v2);
      BOOL v8 = 0;
      if ((v7 & 1) == 0) {
        BOOL v8 = *(unsigned char *)(v2 + 1997) != 0;
      }
      unsigned char buf[22] = v8;
      *(_DWORD *)&uint8_t buf[24] = sub_101203094(v2);
      *(_WORD *)&buf[28] = (*(uint64_t (**)(void))(**(void **)(v2 + 2264) + 8))(*(void *)(v2 + 2264));
      if (*(unsigned char *)(v2 + 1923)) {
        BOOL v9 = *(unsigned char *)(v2 + 1921) == 0;
      }
      else {
        BOOL v9 = *(unsigned char *)(v2 + 1920) != 0;
      }
      buf[30] = v9;
      buf[31] = *(unsigned char *)(v2 + 1922);
      if (*(unsigned char *)(v2 + 2530)) {
        uint64_t v10 = v2 + 2528;
      }
      else {
        uint64_t v10 = v2 + 2432;
      }
      uint64_t v12 = *(void *)(v10 + 24);
      uint64_t v11 = *(void *)(v10 + 32);
      *(void *)&unsigned char buf[32] = v12;
      *(void *)&buf[40] = v11;
      if (v11) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
      }
      int v13 = *(Registry **)(v2 + 1928);
      int v14 = *(std::__shared_weak_count **)(v2 + 1936);
      char v50 = v13;
      uint64_t v51 = v14;
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        int v13 = *(Registry **)(v2 + 1928);
      }
      Registry::getTimerService(&v48, v13);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(v2 + 1928));
      __int16 v17 = ServiceMap;
      if ((v18 & 0x8000000000000000) != 0)
      {
        __int16 v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v20 = 5381;
        do
        {
          unint64_t v18 = v20;
          unsigned int v21 = *v19++;
          uint64_t v20 = (33 * v20) ^ v21;
        }
        while (v21);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v46 = v18;
      uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v46);
      if (v22)
      {
        unint64_t v24 = v22[3];
        uint64_t v23 = (std::__shared_weak_count *)v22[4];
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        unint64_t v24 = 0;
        uint64_t v23 = 0;
      }
      std::mutex::unlock(v17);
      unint64_t v46 = v24;
      long long v47 = v23;
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
      }
      Registry::getNotificationSenderFactory(&v42, *(Registry **)(v2 + 1928));
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v42 + 40))(&v44);
      uint64_t v25 = *(NSObject **)(v2 + 32);
      dispatch_object_t object = v25;
      if (v25) {
        dispatch_retain(v25);
      }
      uint64_t v26 = *(std::__shared_weak_count **)(v2 + 24);
      if (!v26 || (uint64_t v27 = std::__shared_weak_count::lock(v26)) == 0) {
        sub_100088B9C();
      }
      char v28 = v27;
      atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v27);
      unint64_t v29 = std::__shared_weak_count::lock(v28);
      BOOL v30 = v29;
      if (v29) {
        atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      std::__shared_weak_count::__release_weak(v28);
      if (v30) {
        sub_10004D2C8(v30);
      }
      stewie::StewieConnectionAssistant::create(&v48, &v46, &v44, &object, &v52);
      long long v31 = v52;
      long long v52 = 0uLL;
      uint64_t v32 = *(std::__shared_weak_count **)(v2 + 2040);
      *(_OWORD *)(v2 + 2032) = v31;
      if (v32)
      {
        sub_10004D2C8(v32);
        if (*((void *)&v52 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v52 + 1));
        }
      }
      if (v30) {
        std::__shared_weak_count::__release_weak(v30);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v45) {
        sub_10004D2C8(v45);
      }
      if (v43) {
        sub_10004D2C8(v43);
      }
      if (v47) {
        sub_10004D2C8(v47);
      }
      if (v49) {
        sub_10004D2C8(v49);
      }
      if (v51) {
        sub_10004D2C8(v51);
      }
      StewieController::setupQueryableMetrics((StewieController *)v2);
      if (*(void *)&buf[40]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[40]);
      }
      *(unsigned char *)(v2 + 1965) = 1;
      if (*(void *)(v2 + 2584))
      {
        memset(buf, 0, 40);
        (*(void (**)(unsigned char *__return_ptr))(**(void **)(v2 + 2216) + 120))(buf);
        uint64_t v34 = *(void *)&buf[8];
        uint64_t v33 = *(void *)&buf[16];
        if (*(void *)&buf[16]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[16] + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)(v2 + 2536) = v34;
        uint64_t v35 = *(std::__shared_weak_count **)(v2 + 2544);
        *(void *)(v2 + 2544) = v33;
        if (v35) {
          sub_10004D2C8(v35);
        }
        uint64_t v37 = *(void *)&buf[24];
        uint64_t v36 = *(void *)&buf[32];
        if (*(void *)&buf[32]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[32] + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)(v2 + 2552) = v37;
        unsigned int v38 = *(std::__shared_weak_count **)(v2 + 2560);
        *(void *)(v2 + 2560) = v36;
        if (v38) {
          sub_10004D2C8(v38);
        }
        sub_1012020A0(v2);
        sub_101202200(v2);
        if (*(void *)&buf[32]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[32]);
        }
        if (*(void *)&buf[16]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[16]);
        }
      }
      if (*(unsigned char *)(v2 + 2530)) {
        uint64_t v39 = (unsigned __int16 *)(v2 + 2528);
      }
      else {
        uint64_t v39 = (unsigned __int16 *)(v2 + 2432);
      }
      if (*((unsigned char *)v39 + 2)) {
        uint64_t v40 = *v39;
      }
      else {
        uint64_t v40 = 0;
      }
      (*(void (**)(void, uint64_t))(**(void **)(v2 + 2232) + 160))(*(void *)(v2 + 2232), v40);
      sub_1012022AC(v2);
      sub_101202394(v2, 0);
      sub_101202670(v2);
      return sub_101202D98(v2);
    }
  }
  return result;
}

void sub_101201D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  unint64_t v24 = *(std::__shared_weak_count **)(v22 - 72);
  if (v24) {
    sub_10004D2C8(v24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101201E5C(uint64_t a1)
{
  uint64_t result = sub_10025B63C(a1 + 2368, 0);
  if (result)
  {
    unsigned int v3 = atomic_load((unsigned int *)(a1 + 1960));
    if (v3 == 2)
    {
      int v4 = 0;
      int v5 = 2;
    }
    else
    {
      unsigned int v6 = atomic_load((unsigned int *)(a1 + 1960));
      if (v6 == 1)
      {
        if (*(unsigned char *)(a1 + 1992))
        {
          uint64_t v7 = a1 + 2528;
          uint64_t v8 = 2528;
          if (!*(unsigned char *)(a1 + 2530))
          {
            uint64_t v8 = 2432;
            uint64_t v7 = a1 + 2432;
          }
          if (*(unsigned char *)(v7 + 2) && *(_WORD *)(a1 + v8))
          {
            if (*(unsigned char *)(a1 + 1994))
            {
              int v4 = 0;
              int v5 = 5;
            }
            else if (*(unsigned char *)(a1 + 1995))
            {
              int v4 = 0;
              int v5 = 8;
            }
            else if (*(_DWORD *)(a1 + 140) == 2)
            {
              int v4 = 0;
              int v5 = 7;
            }
            else if (*(_DWORD *)(a1 + 1856) == 1)
            {
              int v4 = 0;
              int v5 = 9;
            }
            else
            {
              int v4 = *(unsigned __int8 *)(a1 + 1864) ^ 1;
              if (*(unsigned char *)(a1 + 1864)) {
                int v5 = 10;
              }
              else {
                int v5 = 0;
              }
            }
          }
          else
          {
            int v4 = 0;
            int v5 = 6;
          }
        }
        else
        {
          int v4 = 0;
          int v5 = 4;
        }
      }
      else
      {
        int v4 = 0;
        int v5 = 3;
      }
    }
  }
  else
  {
    int v4 = 0;
    int v5 = 1;
  }
  if (*(unsigned __int8 *)(a1 + 2024) != v4 || *(unsigned __int8 *)(a1 + 2025) != v5)
  {
    uint64_t v10 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = "???";
      if (v4 == 1) {
        uint64_t v11 = "kSatisfied";
      }
      uint64_t v12 = off_101AA0C18[v5];
      if (!v4) {
        uint64_t v11 = "kNotSatisfied";
      }
      int v13 = 136315394;
      int v14 = v11;
      __int16 v15 = 2080;
      __int16 v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Preconditions status: %s, Reason: %s", (uint8_t *)&v13, 0x16u);
    }
    *(unsigned char *)(a1 + 2024) = v4;
    *(unsigned char *)(a1 + 2025) = v5;
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 2232) + 128))(*(void *)(a1 + 2232), a1 + 2024);
  }
  return result;
}

void sub_1012020A0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 2536);
  if (v2) {
    sub_100A07F00(v2, a1 + 2000);
  }
  unsigned int v3 = *(void **)(a1 + 2440);
  if (v3) {
    sub_100A07F00(v3, a1 + 2000);
  }
  uint64_t v4 = a1 + 2528;
  if (!*(unsigned char *)(a1 + 2530)) {
    uint64_t v4 = a1 + 2432;
  }
  unsigned int v6 = *(void **)(v4 + 8);
  int v5 = *(std::__shared_weak_count **)(v4 + 16);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v6)
  {
    BOOL v9 = (void *)*v6;
    uint64_t v7 = v6 + 1;
    uint64_t v8 = v9;
    if (v9 == v7)
    {
      char v10 = 0;
    }
    else
    {
      char v10 = 0;
      while (1)
      {
        BOOL v11 = sub_100A0766C((uint64_t)(v8 + 5));
        if (v11) {
          char v10 = 1;
        }
        if (v11) {
          break;
        }
        uint64_t v12 = (void *)v8[1];
        if (v12)
        {
          do
          {
            int v13 = v12;
            uint64_t v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            int v13 = (void *)v8[2];
            BOOL v14 = *v13 == (void)v8;
            uint64_t v8 = v13;
          }
          while (!v14);
        }
        uint64_t v8 = v13;
        if (v13 == v7) {
          goto LABEL_25;
        }
      }
      char v10 = 1;
    }
LABEL_25:
    uint64_t v15 = v10 & 1;
  }
  else
  {
    uint64_t v15 = 0;
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 2232) + 200))(*(void *)(a1 + 2232), v15);
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_1012021E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101202200(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1965))
  {
    uint64_t v2 = *(void *)(a1 + 2032);
    uint64_t v3 = a1 + 2528;
    int v4 = *(unsigned __int8 *)(a1 + 2530);
    uint64_t v5 = a1 + 2432;
    if (v4) {
      uint64_t v5 = v3;
    }
    uint64_t v7 = *(void *)(v5 + 24);
    unsigned int v6 = *(std::__shared_weak_count **)(v5 + 32);
    uint64_t v8 = v7;
    BOOL v9 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 112))(v2, &v8);
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
}

void sub_101202294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1012022AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 2530)) {
    uint64_t v2 = a1 + 2528;
  }
  else {
    uint64_t v2 = a1 + 2432;
  }
  sub_100058DB0(__p, "JPN");
  uint64_t v3 = sub_100046F68(v2 + 40, __p);
  int v4 = (void **)(v2 + 48);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  int v5 = v4 != v3;
  if (*(unsigned __int8 *)(a1 + 2626) != v5)
  {
    *(unsigned char *)(a1 + 2626) = v5;
    (*(void (**)(void, BOOL))(**(void **)(a1 + 2232) + 168))(*(void *)(a1 + 2232), v4 != v3);
    sub_101203444(a1);
  }
}

void sub_101202378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101202394(uint64_t a1, BOOL a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (a2)
  {
    *(unsigned char *)(a1 + 2648) = 0;
    int v4 = *(std::__shared_weak_count **)(a1 + 2664);
    *(void *)(a1 + 2656) = 0;
    *(void *)(a1 + 2664) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  if (*(unsigned char *)(a1 + 1965))
  {
    if (*(unsigned char *)(a1 + 1992))
    {
      int v5 = *(uint64_t **)(a1 + 2632);
      if (v5)
      {
        if (*(unsigned char *)(a1 + 2625) && !*(void *)(a1 + 2656) && (!*(unsigned char *)(a1 + 2648) || a2))
        {
          *(unsigned char *)(a1 + 2648) = 1;
          unsigned int v6 = *(NSObject **)(a1 + 48);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v7 = *v5;
            *(_DWORD *)std::string buf = 134218498;
            *(void *)&uint8_t buf[4] = v7;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = asStringBool(a2);
            __int16 v22 = 2048;
            uint64_t v23 = 30;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Processing bystander location, location timestamp: %lld, forced: %s (Min gap between checks unless forced: %lld seconds)", buf, 0x20u);
          }
          sub_100058DB0(&__p, "ReduceBystanderLocationProcessing");
          Registry::getTimerService(&v16, *(Registry **)(a1 + 1928));
          *(void *)std::string buf = off_101AA0A98;
          *(void *)&uint8_t buf[8] = a1;
          uint64_t v23 = (uint64_t)buf;
          AutoStartTimer::create();
          long long v8 = v20;
          long long v20 = 0uLL;
          BOOL v9 = *(std::__shared_weak_count **)(a1 + 2664);
          *(_OWORD *)(a1 + 2656) = v8;
          if (v9)
          {
            sub_10004D2C8(v9);
            if (*((void *)&v20 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
            }
          }
          sub_10003B34C(buf);
          if (v17) {
            sub_10004D2C8(v17);
          }
          if (v19 < 0) {
            operator delete(__p);
          }
          char v10 = *(std::__shared_weak_count **)(a1 + 24);
          if (!v10
            || (uint64_t v11 = *(void *)(a1 + 2216),
                uint64_t v12 = *(void *)(a1 + 16),
                (int v13 = std::__shared_weak_count::lock(v10)) == 0))
          {
            sub_100088B9C();
          }
          BOOL v14 = v13;
          atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          uint64_t v15 = operator new(0x20uLL);
          void *v15 = off_101AA0B18;
          v15[1] = a1;
          dispatch_object_t v15[2] = v12;
          unint64_t v15[3] = v14;
          uint64_t v23 = (uint64_t)v15;
          (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v11 + 112))(v11, a1 + 2632, buf);
          sub_101211BB8(buf);
        }
      }
    }
  }
}

void sub_101202610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
}

void sub_101202670(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 1965)) {
    return;
  }
  uint64_t v1 = a1;
  if (!*(unsigned char *)(a1 + 1992)) {
    return;
  }
  uint64_t v2 = operator new(0x30uLL);
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = off_101A29340;
  v2[4] = 0;
  uint64_t v3 = (uint64_t **)(v2 + 4);
  v2[3] = v2 + 4;
  int v4 = (uint64_t **)(v2 + 3);
  uint64_t v48 = (std::__shared_weak_count *)v2;
  v2[5] = 0;
  int v5 = *(void **)(v1 + 2472);
  char v50 = (void *)(v1 + 2480);
  if (v5 == (void *)(v1 + 2480))
  {
    LOWORD(v6) = 0;
    uint64_t v51 = 0;
    uint64_t v7 = 0;
    uint64_t v33 = (std::__shared_weak_count *)v2;
LABEL_69:
    v6 &= 0xFFF7u;
    sub_10004D2C8(v33);
    int v4 = 0;
    uint64_t v33 = 0;
    char v34 = 1;
    goto LABEL_70;
  }
  long long v47 = v2 + 1;
  unsigned int v6 = 0;
  uint64_t v51 = 0;
  uint64_t v7 = 0;
  xpc_object_t v55 = (uint64_t **)(v2 + 3);
  uint64_t v49 = v1;
  do
  {
    int v59 = 0;
    long long valuePtr = 0u;
    long long v58 = 0u;
    (*(void (**)(long long *__return_ptr))(**(void **)(v1 + 2216) + 120))(&valuePtr);
    if ((_WORD)valuePtr)
    {
      int v52 = (unsigned __int16)valuePtr;
      unsigned int v53 = v6;
      BOOL v54 = v7;
      if ((valuePtr & 8) != 0)
      {
        if (*((void *)&valuePtr + 1))
        {
          uint64_t v9 = *((void *)&valuePtr + 1) + 8;
          long long v8 = (void *)**((void **)&valuePtr + 1);
          if (**((void **)&valuePtr + 1) != *((void *)&valuePtr + 1) + 8)
          {
            do
            {
              char v10 = *v3;
              unint64_t v11 = v8[4];
              uint64_t v12 = v3;
              int v13 = v3;
              if (*v3)
              {
                BOOL v14 = v3;
                uint64_t v15 = *v3;
                do
                {
                  unint64_t v16 = v15[4];
                  BOOL v17 = v16 >= v11;
                  if (v16 >= v11) {
                    unint64_t v18 = (uint64_t **)v15;
                  }
                  else {
                    unint64_t v18 = (uint64_t **)(v15 + 1);
                  }
                  if (v17) {
                    BOOL v14 = (uint64_t **)v15;
                  }
                  uint64_t v15 = *v18;
                }
                while (*v18);
                if (v14 != v3 && v11 >= (unint64_t)v14[4])
                {
                  if (*((unsigned char *)v8 + 137) && *((unsigned char *)v8 + 136)) {
                    *((_WORD *)v14 + 68) = 257;
                  }
                  goto LABEL_36;
                }
                uint64_t v12 = v3;
                int v13 = v3;
                if (v10)
                {
                  while (1)
                  {
                    while (1)
                    {
                      int v13 = (uint64_t **)v10;
                      unint64_t v19 = v10[4];
                      if (v19 <= v11) {
                        break;
                      }
                      char v10 = *v13;
                      uint64_t v12 = v13;
                      if (!*v13) {
                        goto LABEL_27;
                      }
                    }
                    if (v19 >= v11) {
                      goto LABEL_36;
                    }
                    char v10 = v13[1];
                    if (!v10)
                    {
                      uint64_t v12 = v13 + 1;
                      break;
                    }
                  }
                }
              }
LABEL_27:
              uint64_t v61 = 0;
              long long v20 = operator new(0x90uLL);
              unsigned int v21 = v20;
              *(void *)&long long buf = v20;
              *((void *)&buf + 1) = v3;
              LOBYTE(v61) = 0;
              v20[4] = v11;
              *((_DWORD *)v20 + 10) = *((_DWORD *)v8 + 10);
              if (*((char *)v8 + 71) < 0)
              {
                sub_10004FC84((unsigned char *)v20 + 48, (void *)v8[6], v8[7]);
              }
              else
              {
                long long v22 = *((_OWORD *)v8 + 3);
                unsigned char v20[8] = v8[8];
                *((_OWORD *)v20 + 3) = v22;
              }
              if (*((char *)v8 + 95) < 0)
              {
                sub_10004FC84((unsigned char *)v21 + 72, (void *)v8[9], v8[10]);
              }
              else
              {
                long long v23 = *(_OWORD *)(v8 + 9);
                v21[11] = v8[11];
                *(_OWORD *)(v21 + 9) = v23;
              }
              char v24 = *((unsigned char *)v8 + 98);
              __int16 v25 = *((_WORD *)v8 + 48);
              *((unsigned char *)v21 + 104) = 0;
              *((_WORD *)v21 + 48) = v25;
              *((unsigned char *)v21 + 98) = v24;
              *((unsigned char *)v21 + 128) = 0;
              if (*((unsigned char *)v8 + 128))
              {
                sub_1000C6BDC(v21 + 13, (uint64_t)(v8 + 13));
                *((unsigned char *)v21 + 128) = 1;
              }
              __int16 v26 = *((_WORD *)v8 + 68);
              *((unsigned char *)v21 + 138) = *((unsigned char *)v8 + 138);
              *((_WORD *)v21 + 68) = v26;
              LOBYTE(v61) = 1;
              int v4 = v55;
              sub_100046C38(v55, (uint64_t)v13, v12, (uint64_t *)buf);
              *(void *)&long long buf = 0;
              sub_100A08220((uint64_t)&buf, 0);
LABEL_36:
              uint64_t v27 = (void *)v8[1];
              if (v27)
              {
                do
                {
                  char v28 = v27;
                  uint64_t v27 = (void *)*v27;
                }
                while (v27);
              }
              else
              {
                do
                {
                  char v28 = (void *)v8[2];
                  BOOL v30 = *v28 == (void)v8;
                  long long v8 = v28;
                }
                while (!v30);
              }
              long long v8 = v28;
            }
            while (v28 != (void *)v9);
          }
        }
      }
      unsigned int v6 = v52 | v53;
      uint64_t v29 = *((void *)&v58 + 1);
      if (*((void *)&v58 + 1)) {
        BOOL v30 = v51 == 0;
      }
      else {
        BOOL v30 = 0;
      }
      if (v30)
      {
        uint64_t v7 = v59;
        uint64_t v1 = v49;
        if (v59) {
          atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v54) {
          sub_10004D2C8(v54);
        }
        uint64_t v51 = v29;
      }
      else
      {
        uint64_t v7 = v54;
        uint64_t v1 = v49;
      }
    }
    if (v59) {
      sub_10004D2C8(v59);
    }
    if ((void)v58) {
      sub_10004D2C8((std::__shared_weak_count *)v58);
    }
    long long v31 = (void *)v5[1];
    if (v31)
    {
      do
      {
        uint64_t v32 = v31;
        long long v31 = (void *)*v31;
      }
      while (v31);
    }
    else
    {
      do
      {
        uint64_t v32 = (void *)v5[2];
        BOOL v30 = *v32 == (void)v5;
        int v5 = v32;
      }
      while (!v30);
    }
    int v5 = v32;
  }
  while (v32 != v50);
  uint64_t v33 = v48;
  if (!v48[1].__shared_weak_owners_) {
    goto LABEL_69;
  }
  char v34 = 0;
  atomic_fetch_add_explicit(v47, 1uLL, memory_order_relaxed);
LABEL_70:
  *(void *)(v1 + 2440) = v4;
  uint64_t v35 = *(std::__shared_weak_count **)(v1 + 2448);
  *(void *)(v1 + 2448) = v33;
  if (v35) {
    sub_10004D2C8(v35);
  }
  sub_1012020A0(v1);
  uint64_t v36 = *(void *)(v1 + 2456);
  if (v36 != v51)
  {
    if (!v51
      || !v36
      || ((char v37 = sub_1012AD3D4(*(void *)(v1 + 2456), v51),
           *(unsigned __int16 *)(v36 + 32) == *(unsigned __int16 *)(v51 + 32))
        ? (char v38 = v37)
        : (char v38 = 0),
          (v38 & 1) == 0))
    {
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)(v1 + 2456) = v51;
      uint64_t v39 = *(std::__shared_weak_count **)(v1 + 2464);
      *(void *)(v1 + 2464) = v7;
      if (v39) {
        sub_10004D2C8(v39);
      }
      sub_101202200(v1);
    }
  }
  uint64_t v40 = (_WORD *)(v1 + 2432);
  if (!*(unsigned char *)(v1 + 2434) || (unsigned __int16)*v40 != v6)
  {
    *(_WORD *)(v1 + 2432) = v6;
    *(unsigned char *)(v1 + 2434) = 1;
    CFNumberRef v56 = 0;
    *(void *)&long long valuePtr = v6;
    CFNumberRef v41 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    if (v41)
    {
      CFNumberRef v42 = v56;
      CFNumberRef v56 = v41;
      *(void *)&long long valuePtr = v42;
      sub_1000570E8((const void **)&valuePtr);
      (***(void (****)(void))(v1 + 2504))();
    }
    uint64_t v43 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(unsigned char *)(v1 + 2434)) {
        sub_10016C840();
      }
      sub_100BC897C((unsigned __int16)*v40, (std::string *)&valuePtr);
      if ((SBYTE7(v58) & 0x80u) == 0) {
        p_long long valuePtr = &valuePtr;
      }
      else {
        p_long long valuePtr = (long long *)valuePtr;
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = p_valuePtr;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I [MCC and MNC based] Supported services: %{public}s", (uint8_t *)&buf, 0xCu);
      if (SBYTE7(v58) < 0) {
        operator delete((void *)valuePtr);
      }
    }
    BOOL v45 = (unsigned __int16 *)(v1 + 2528);
    if (!*(unsigned char *)(v1 + 2530)) {
      BOOL v45 = (unsigned __int16 *)(v1 + 2432);
    }
    if (*((unsigned char *)v45 + 2)) {
      uint64_t v46 = *v45;
    }
    else {
      uint64_t v46 = 0;
    }
    (*(void (**)(void, uint64_t))(**(void **)(v1 + 2232) + 160))(*(void *)(v1 + 2232), v46);
    if (*(unsigned char *)(v1 + 2434) && *v40) {
      sub_101203378(v1);
    }
    sub_101201E5C(v1);
    sub_1000570E8((const void **)&v56);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v33);
  }
}

void sub_101202CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1000570E8((const void **)va);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (a4) {
    sub_10004D2C8(a4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101202D98(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 2232) + 224);

  return v2();
}

uint64_t sub_101202E14(uint64_t a1)
{
  void (***v11)(uint64_t *__return_ptr, void);
  char v12;
  uint64_t *v13;
  uint64_t v14;
  std::mutex *v15;
  std::mutex *v16;
  unint64_t v17;
  unsigned __int8 *v18;
  uint64_t v19;
  unsigned int v20;
  void *v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  char v24;
  uint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t v28;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  __int16 v26 = 0;
  uint64_t v27 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 1928));
  int v4 = ServiceMap;
  int v5 = "20ProfileManagedConfig";
  if (((unint64_t)"20ProfileManagedConfig" & 0x8000000000000000) != 0)
  {
    unsigned int v6 = (unsigned __int8 *)((unint64_t)"20ProfileManagedConfig" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      int v5 = (const char *)v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  char v28 = (unint64_t)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v28);
  if (v9)
  {
    unint64_t v11 = (void (***)(uint64_t *__return_ptr, void))v9[3];
    char v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      uint64_t v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  char v10 = 0;
  uint64_t v12 = 1;
LABEL_9:
  (**v11)(&v26, v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  int v13 = (uint64_t *)v26;
  if (v26)
  {
    if (*(unsigned char *)(v26 + 3))
    {
      int v13 = (uint64_t *)*(unsigned __int8 *)(v26 + 2);
      if (*(unsigned char *)(v26 + 2))
      {
        BOOL v14 = 1;
        goto LABEL_31;
      }
    }
  }
  uint64_t v15 = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(a1 + 1928));
  unint64_t v16 = v15;
  if ((v17 & 0x8000000000000000) != 0)
  {
    unint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    unint64_t v19 = 5381;
    do
    {
      BOOL v17 = v19;
      long long v20 = *v18++;
      unint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v15);
  char v28 = v17;
  unsigned int v21 = sub_10004D37C(&v16[1].__m_.__sig, &v28);
  if (v21)
  {
    long long v23 = v21[3];
    long long v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v24 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    long long v23 = 0;
  }
  std::mutex::unlock(v16);
  long long v22 = 0;
  char v24 = 1;
LABEL_23:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v23 + 16))(v23))
  {
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
    goto LABEL_30;
  }
  BOOL v14 = sub_10025B63C(a1 + 2760, 0);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  if (v14 != 1) {
LABEL_30:
  }
    BOOL v14 = 0;
LABEL_31:
  if (v27) {
    sub_10004D2C8(v27);
  }
  return v14;
}

void sub_101203054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101203094(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 2340) != 2) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 1744) == 1) {
    return 1;
  }
  return 2 * *(unsigned __int8 *)(a1 + 1972);
}

void sub_1012030EC(uint64_t a1, _DWORD *a2)
{
  if (*(unsigned char *)(a1 + 1965))
  {
    if (*(unsigned char *)(a1 + 1993))
    {
      uint64_t v4 = *(unsigned __int16 *)(a1 + 132);
      if (*a2 == 3)
      {
        int v5 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Network has requested Stewie disablement. Stewie won't be allowed until process is restarted.", v7, 2u);
        }
        *(unsigned char *)(a1 + 1994) = 1;
        sub_101201E5C(a1);
      }
      if ((*(unsigned int (**)(void, _DWORD *))(**(void **)(a1 + 2232) + 40))(*(void *)(a1 + 2232), a2))
      {
        (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 2032) + 24))(*(void *)(a1 + 2032), v4, *a2);
        *(unsigned char *)(a1 + 1993) = 0;
      }
    }
  }
  else
  {
    unsigned int v6 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
}

uint64_t sub_101203230(uint64_t result)
{
  uint64_t v1 = result;
  if (*(unsigned char *)(result + 1966)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(unsigned char *)(result + 136) != 0;
  }
  if (*(unsigned char *)(result + 1967) == v2)
  {
    int v3 = *(unsigned __int8 *)(result + 136);
    if (*(unsigned __int8 *)(result + 1968) == v3) {
      return result;
    }
  }
  else
  {
    int v3 = *(unsigned __int8 *)(result + 136);
  }
  *(unsigned char *)(result + 1967) = v2;
  *(unsigned char *)(result + 1968) = v3;
  uint64_t v4 = *(NSObject **)(result + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "no";
    if (v2) {
      int v5 = "yes";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Re-evaluated InEmergency: %s", (uint8_t *)&v6, 0xCu);
    int v3 = *(unsigned __int8 *)(v1 + 1968);
    BOOL v2 = *(unsigned char *)(v1 + 1967) != 0;
  }
  return (*(uint64_t (**)(void, BOOL, BOOL))(**(void **)(v1 + 2232) + 72))(*(void *)(v1 + 2232), v2, v3 != 0);
}

uint64_t sub_101203378(uint64_t a1)
{
  uint64_t v2 = a1 + 2400;
  uint64_t result = sub_10025B63C(a1 + 2400, 0);
  if (result != 1)
  {
    uint64_t v4 = a1 + 2528;
    uint64_t v5 = 2528;
    if (!*(unsigned char *)(a1 + 2530))
    {
      uint64_t v5 = 2432;
      uint64_t v4 = a1 + 2432;
    }
    if (*(unsigned char *)(v4 + 2) && *(_WORD *)(a1 + v5))
    {
      int v6 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Saving information that user is in a launch country", v7, 2u);
      }
      sub_10025CAD8(v2, 1u);
      return sub_101201608(a1, 0);
    }
  }
  return result;
}

uint64_t sub_101203444(uint64_t result)
{
  if (*(unsigned char *)(result + 1965))
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 1997)) {
      sub_101202E14(result);
    }
    uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 2032) + 88);
    return v2();
  }
  return result;
}

void sub_1012034D4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 1928));
  int v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v4;
  unsigned int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&buf);
  if (!v8)
  {
    std::mutex::unlock(v3);
    return;
  }
  uint64_t v9 = v8[3];
  char v10 = (std::__shared_weak_count *)v8[4];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v3);
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    if (!v9)
    {
LABEL_75:
      sub_10004D2C8(v10);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v3);
    if (!v9) {
      return;
    }
  }
  uint64_t v60 = v10;
  xpc_object_t v75 = 0;
  uint64_t v76 = 0;
  uint64_t v74 = &v75;
  char v11 = *(void **)(a1 + 1808);
  if (v11 == (void *)(a1 + 1816))
  {
    char v38 = 0;
    goto LABEL_74;
  }
  do
  {
    MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)(v11 + 5));
    int v12 = MCC::valid((MCC *)&buf);
    int v13 = v12;
    if (v80 < 0)
    {
      operator delete(*((void **)&buf + 1));
      if (!v13) {
        goto LABEL_27;
      }
    }
    else if (!v12)
    {
      goto LABEL_27;
    }
    BOOL v14 = v75;
    uint64_t v15 = &v75;
    unint64_t v16 = &v75;
    if (!v75) {
      goto LABEL_24;
    }
    uint64_t v15 = &v75;
    while (1)
    {
      while (1)
      {
        unint64_t v16 = (uint64_t **)v14;
        if (!MCCAndMNC::operator<()) {
          break;
        }
        BOOL v14 = *v16;
        uint64_t v15 = v16;
        if (!*v16) {
          goto LABEL_24;
        }
      }
      if (!MCCAndMNC::operator<()) {
        break;
      }
      uint64_t v15 = v16 + 1;
      BOOL v14 = v16[1];
      if (!v14) {
        goto LABEL_24;
      }
    }
    if (!*v15)
    {
LABEL_24:
      uint64_t v79 = 0;
      BOOL v17 = (uint64_t *)operator new(0x60uLL);
      *(void *)&long long buf = v17;
      *((void *)&buf + 1) = &v75;
      sub_1003FB5E8((MCC *)(v17 + 4), (uint64_t)(v11 + 5));
      LOBYTE(v79) = 1;
      *BOOL v17 = 0;
      v17[1] = 0;
      v17[2] = (uint64_t)v16;
      uint64_t *v15 = v17;
      if (*v74)
      {
        uint64_t v74 = (uint64_t **)*v74;
        BOOL v17 = *v15;
      }
      sub_100046C90(v75, v17);
      ++v76;
      *(void *)&long long buf = 0;
      sub_1010B9558((uint64_t)&buf);
    }
LABEL_27:
    unint64_t v18 = (void *)v11[1];
    if (v18)
    {
      do
      {
        unint64_t v19 = v18;
        unint64_t v18 = (void *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        unint64_t v19 = (void *)v11[2];
        BOOL v20 = *v19 == (void)v11;
        char v11 = v19;
      }
      while (!v20);
    }
    char v11 = v19;
  }
  while (v19 != (void *)(a1 + 1816));
  if (!v76)
  {
    char v38 = v75;
LABEL_74:
    sub_1010B92A4(v38);
    char v10 = v60;
    if (!v60) {
      return;
    }
    goto LABEL_75;
  }
  unsigned __int8 v72 = 0;
  uint64_t v73 = 0;
  uint64_t v71 = &v72;
  unsigned int v21 = (uint64_t *)v74;
  if (v74 == &v75)
  {
    uint64_t v37 = 0;
  }
  else
  {
    do
    {
      MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)(v21 + 4));
      long long v69 = 0uLL;
      uint64_t v70 = 0;
      MCCAndMNC::getMnc((uint64_t *)theArray, (MCCAndMNC *)(v21 + 4));
      if (MCC::valid((MCC *)theArray))
      {
        MCC::getStringValue((uint64_t *)v63, (MCC *)&buf);
        sub_100058DB0(__p, "");
      }
      else
      {
        MCC::getStringValue((uint64_t *)v63, (MCC *)&buf);
        MCC::getStringValue((uint64_t *)__p, (MCC *)theArray);
      }
      (*(void (**)(long long *__return_ptr, uint64_t, void **, void **))(*(void *)v9 + 88))(&v65, v9, v63, __p);
      sub_10005CBB4((uint64_t *)&v69);
      long long v69 = v65;
      uint64_t v70 = v66;
      uint64_t v66 = 0;
      long long v65 = 0uLL;
      uint64_t v77 = (void **)&v65;
      sub_100047F64(&v77);
      if (v62 < 0) {
        operator delete(__p[0]);
      }
      if (v64 < 0) {
        operator delete(v63[0]);
      }
      uint64_t v23 = *((void *)&v69 + 1);
      uint64_t v22 = v69;
      if ((void)v69 != *((void *)&v69 + 1))
      {
        do
        {
          if (*(char *)(v22 + 23) < 0)
          {
            __int16 v25 = *(unsigned char **)v22;
            char v24 = (unsigned char *)(*(void *)v22 + *(void *)(v22 + 8));
          }
          else
          {
            char v24 = (unsigned char *)(v22 + *(unsigned __int8 *)(v22 + 23));
            __int16 v25 = (unsigned char *)v22;
          }
          while (v25 != v24)
          {
            unsigned char *v25 = __toupper(*v25);
            ++v25;
          }
          v22 += 24;
        }
        while (v22 != v23);
        uint64_t v27 = (long long *)*((void *)&v69 + 1);
        __int16 v26 = (long long *)v69;
        if ((void)v69 != *((void *)&v69 + 1))
        {
          char v28 = &v72;
          do
          {
            *(void *)&long long v65 = 0;
            v63[0] = 0;
            uint64_t v29 = sub_1000C6D50(&v71, (uint64_t)v28, (void ***)&v65, (uint64_t *)v63, (void **)v26);
            BOOL v30 = (uint64_t *)*v29;
            if (!*v29)
            {
              BOOL v30 = (uint64_t *)operator new(0x38uLL);
              long long v31 = *v26;
              v30[6] = *((void *)v26 + 2);
              *((_OWORD *)v30 + 2) = v31;
              *((void *)v26 + 1) = 0;
              *((void *)v26 + 2) = 0;
              *(void *)__int16 v26 = 0;
              uint64_t v32 = v65;
              uint64_t *v30 = 0;
              v30[1] = 0;
              unint64_t v30[2] = v32;
              *uint64_t v29 = v30;
              uint64_t v33 = v30;
              if (*v71)
              {
                uint64_t v71 = (uint64_t **)*v71;
                uint64_t v33 = (uint64_t *)*v29;
              }
              sub_100046C90(v72, v33);
              ++v73;
            }
            char v34 = (uint64_t *)v30[1];
            if (v34)
            {
              do
              {
                char v28 = (uint64_t **)v34;
                char v34 = (uint64_t *)*v34;
              }
              while (v34);
            }
            else
            {
              do
              {
                char v28 = (uint64_t **)v30[2];
                BOOL v20 = *v28 == v30;
                BOOL v30 = (uint64_t *)v28;
              }
              while (!v20);
            }
            __int16 v26 = (long long *)((char *)v26 + 24);
          }
          while (v26 != v27);
        }
      }
      if (v68 < 0) {
        operator delete(theArray[1]);
      }
      theArray[0] = (CFMutableArrayRef)&v69;
      sub_100047F64((void ***)theArray);
      if (v80 < 0) {
        operator delete(*((void **)&buf + 1));
      }
      uint64_t v35 = (uint64_t *)v21[1];
      if (v35)
      {
        do
        {
          uint64_t v36 = (uint64_t **)v35;
          uint64_t v35 = (uint64_t *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          uint64_t v36 = (uint64_t **)v21[2];
          BOOL v20 = *v36 == v21;
          unsigned int v21 = (uint64_t *)v36;
        }
        while (!v20);
      }
      unsigned int v21 = (uint64_t *)v36;
    }
    while (v36 != &v75);
    uint64_t v37 = v73;
  }
  char v10 = v60;
  if (*(void *)(a1 + 2488) != v37) {
    goto LABEL_94;
  }
  uint64_t v39 = *(unsigned __int8 **)(a1 + 2472);
  if (v39 != (unsigned __int8 *)(a1 + 2480))
  {
    uint64_t v40 = v71;
    while ((sub_1000609C0((uint64_t)&buf, v39 + 32, (unsigned __int8 *)v40 + 32) & 1) != 0)
    {
      CFNumberRef v41 = (unsigned __int8 *)*((void *)v39 + 1);
      CFNumberRef v42 = v39;
      if (v41)
      {
        do
        {
          uint64_t v39 = v41;
          CFNumberRef v41 = *(unsigned __int8 **)v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          uint64_t v39 = (unsigned __int8 *)*((void *)v42 + 2);
          BOOL v20 = *(void *)v39 == (void)v42;
          CFNumberRef v42 = v39;
        }
        while (!v20);
      }
      uint64_t v43 = v40[1];
      if (v43)
      {
        do
        {
          uint64_t v44 = (uint64_t **)v43;
          uint64_t v43 = (uint64_t *)*v43;
        }
        while (v43);
      }
      else
      {
        do
        {
          uint64_t v44 = (uint64_t **)v40[2];
          BOOL v20 = *v44 == (uint64_t *)v40;
          uint64_t v40 = v44;
        }
        while (!v20);
      }
      uint64_t v40 = v44;
      if (v39 == (unsigned __int8 *)(a1 + 2480)) {
        goto LABEL_124;
      }
    }
LABEL_94:
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    theArray[0] = Mutable;
    uint64_t v46 = v71;
    if (v71 != &v72)
    {
      do
      {
        long long v47 = (const char *)(v46 + 4);
        *(void *)&long long buf = 0;
        if (*((char *)v46 + 55) < 0) {
          long long v47 = *(const char **)v47;
        }
        *(void *)&long long buf = CFStringCreateWithCString(kCFAllocatorDefault, v47, 0x8000100u);
        CFArrayAppendValue(theArray[0], (const void *)buf);
        sub_1000558F4((const void **)&buf);
        uint64_t v48 = v46[1];
        if (v48)
        {
          do
          {
            uint64_t v49 = (uint64_t **)v48;
            uint64_t v48 = (uint64_t *)*v48;
          }
          while (v48);
        }
        else
        {
          do
          {
            uint64_t v49 = (uint64_t **)v46[2];
            BOOL v20 = *v49 == (uint64_t *)v46;
            uint64_t v46 = v49;
          }
          while (!v20);
        }
        uint64_t v46 = v49;
      }
      while (v49 != &v72);
      CFMutableDictionaryRef Mutable = theArray[0];
    }
    (***(void (****)(void, __CFArray *))(a1 + 2520))(*(void *)(a1 + 2520), Mutable);
    char v50 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      if (v73) {
        uint64_t v51 = "";
      }
      else {
        uint64_t v51 = "<none>";
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v51;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I MCC and MNC based ISOs: %s", (uint8_t *)&buf, 0xCu);
    }
    int v52 = v71;
    if (v71 != &v72)
    {
      do
      {
        unsigned int v53 = *(NSObject **)(a1 + 48);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v54 = v52 + 4;
          if (*((char *)v52 + 55) < 0) {
            BOOL v54 = (void *)*v54;
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v54;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I [Derived ISO][MCC and MNC based]: %s", (uint8_t *)&buf, 0xCu);
        }
        xpc_object_t v55 = v52[1];
        if (v55)
        {
          do
          {
            CFNumberRef v56 = (uint64_t **)v55;
            xpc_object_t v55 = (uint64_t *)*v55;
          }
          while (v55);
        }
        else
        {
          do
          {
            CFNumberRef v56 = (uint64_t **)v52[2];
            BOOL v20 = *v56 == (uint64_t *)v52;
            int v52 = v56;
          }
          while (!v20);
        }
        int v52 = v56;
      }
      while (v56 != &v72);
    }
    uint64_t v57 = a1 + 2480;
    sub_10005CD2C(a1 + 2472, *(char **)(a1 + 2480));
    long long v58 = v72;
    *(void *)(a1 + 2472) = v71;
    *(void *)(a1 + 2480) = v58;
    uint64_t v59 = v73;
    *(void *)(a1 + 2488) = v73;
    if (v59)
    {
      v58[2] = v57;
      uint64_t v71 = &v72;
      unsigned __int8 v72 = 0;
      uint64_t v73 = 0;
    }
    else
    {
      *(void *)(a1 + 2472) = v57;
    }
    sub_1012022AC(a1);
    sub_101202670(a1);
    sub_1000440D4((const void **)theArray);
  }
LABEL_124:
  sub_10005CD2C((uint64_t)&v71, (char *)v72);
  sub_1010B92A4(v75);
  if (v60) {
    goto LABEL_75;
  }
}

void sub_101203D40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,char a39,char *a40)
{
  sub_10005CD2C((uint64_t)&a39, a40);
  sub_1010B92A4(*(void **)(v40 - 168));
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101203E80(uint64_t result)
{
  uint64_t v1 = result;
  if (*(_DWORD *)(result + 140) == 2 || *(unsigned char *)(result + 1971)) {
    goto LABEL_3;
  }
  if (*(unsigned char *)(result + 1996) || *(unsigned char *)(result + 1970))
  {
    int v2 = 1;
  }
  else
  {
    if (!*(unsigned char *)(result + 1999))
    {
LABEL_3:
      int v2 = 0;
      goto LABEL_4;
    }
    int v2 = *(unsigned char *)(result + 1998) != 0;
  }
LABEL_4:
  if (*(unsigned __int8 *)(result + 1997) != v2)
  {
    *(unsigned char *)(result + 1997) = v2;
    int v3 = *(NSObject **)(result + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = "not";
      if (v2) {
        uint64_t v4 = "";
      }
      int v5 = 136315138;
      uint64_t v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [Aggregate] Device can%s make emergency calls", (uint8_t *)&v5, 0xCu);
    }
    return sub_101203444(v1);
  }
  return result;
}

void sub_101203F9C(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 132) & 2) != 0
    && (*(unsigned char *)(a1 + 1923) ? (BOOL v2 = *(unsigned char *)(a1 + 1921) == 0) : (BOOL v2 = *(unsigned char *)(a1 + 1920) != 0), !v2))
  {
    if (!*(void *)(a1 + 2744))
    {
      sub_100058DB0(&__p, "DisconnectTryOut");
      Registry::getTimerService(&v6, *(Registry **)(a1 + 1928));
      v11[0] = off_101AA0838;
      v11[1] = a1;
      v11[3] = v11;
      AutoStartTimer::create();
      long long v4 = v10;
      long long v10 = 0uLL;
      int v5 = *(std::__shared_weak_count **)(a1 + 2752);
      *(_OWORD *)(a1 + 2744) = v4;
      if (v5)
      {
        sub_10004D2C8(v5);
        if (*((void *)&v10 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
        }
      }
      sub_10003B34C(v11);
      if (v7) {
        sub_10004D2C8(v7);
      }
      if (v9 < 0) {
        operator delete(__p);
      }
    }
  }
  else
  {
    int v3 = *(std::__shared_weak_count **)(a1 + 2752);
    *(_OWORD *)(a1 + 2744) = 0u;
    if (v3)
    {
      sub_10004D2C8(v3);
    }
  }
}

void sub_101204124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_10003B34C((void *)(v17 - 56));
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_101204164(uint64_t a1)
{
  int v2 = *(unsigned __int16 *)(a1 + 132);
  uint64_t v3 = v2 & 0x30;
  int v4 = v2 & ~(v2 & 0x30);
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5 && (*(unsigned char *)(a1 + 1923) ? (BOOL v6 = *(unsigned char *)(a1 + 1921) == 0) : (BOOL v6 = *(unsigned char *)(a1 + 1920) != 0), !v6))
  {
    if (!*(void *)(a1 + 2720))
    {
      if ((*(unsigned int (**)(void))(**(void **)(a1 + 2232) + 48))(*(void *)(a1 + 2232)))
      {
        unsigned int v8 = (uint64_t *)(a1 + 2704);
        int v9 = *(unsigned __int8 *)(a1 + 2712);
        long long v10 = (uint64_t *)&unk_1015D9EC0;
      }
      else
      {
        unsigned int v8 = (uint64_t *)(a1 + 2688);
        int v9 = *(unsigned __int8 *)(a1 + 2696);
        long long v10 = (uint64_t *)&unk_1015D9EC8;
      }
      if (!v9) {
        unsigned int v8 = v10;
      }
      uint64_t v11 = *v8;
      int v12 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Starting %llu seconds timer to disconnect messaging after screen lock", (uint8_t *)&buf, 0xCu);
      }
      sub_100058DB0(&__p, "DisconnectMessaging");
      Registry::getTimerService(&v15, *(Registry **)(a1 + 1928));
      *(void *)&long long buf = off_101AA08B8;
      *((void *)&buf + 1) = a1;
      uint64_t v21 = v3;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v13 = v19;
      long long v19 = 0uLL;
      BOOL v14 = *(std::__shared_weak_count **)(a1 + 2728);
      *(_OWORD *)(a1 + 2720) = v13;
      if (v14)
      {
        sub_10004D2C8(v14);
        if (*((void *)&v19 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v19 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v16) {
        sub_10004D2C8(v16);
      }
      if (v18 < 0) {
        operator delete(__p);
      }
    }
  }
  else
  {
    unsigned int v7 = *(std::__shared_weak_count **)(a1 + 2728);
    *(_OWORD *)(a1 + 2720) = 0u;
    if (v7)
    {
      sub_10004D2C8(v7);
    }
  }
}

void sub_1012043AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1012043EC(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  sub_100058DB0(__p, "com.apple.MobileSMS");
  int v4 = sub_100046F68(a2, __p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  BOOL v5 = (void **)(a2 + 8);
  if ((void **)(a2 + 8) == v4 || (int v6 = *((unsigned __int8 *)v4 + 56), *(unsigned __int8 *)(a1 + 2808) == v6))
  {
    int v7 = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 2808) = v6;
    int v7 = 1;
  }
  sub_100058DB0(__p, "com.apple.findmy");
  unsigned int v8 = sub_100046F68(a2, __p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (v5 != v8)
  {
    int v9 = *((unsigned __int8 *)v8 + 56);
    if (*(unsigned __int8 *)(a1 + 2809) != v9)
    {
      *(unsigned char *)(a1 + 2809) = v9;
      goto LABEL_14;
    }
  }
  if (v7) {
LABEL_14:
  }
    sub_101202D98(a1);
}

void sub_1012044E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101204500(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 1972);
  BOOL v3 = *(unsigned __int8 *)(a1 + 1744) == 1;
  int v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_1019B0B08;
  LOWORD(v4[1].__vftable) = v2 & 0xFEFF | (v3 << 8);
  BOOL v5 = *(unsigned __int8 **)(a1 + 1976);
  int v6 = *v5;
  int v7 = v3 & 0xFFFFFF;
  int v8 = v5[1];
  if (v2 == v6 && v8 == v7)
  {
    sub_10004D2C8(v4);
  }
  else
  {
    int v10 = (v2 | v7) != 0;
    int v11 = (v6 | v8) != 0;
    *(void *)(a1 + 1976) = v4 + 1;
    int v12 = *(std::__shared_weak_count **)(a1 + 1984);
    *(void *)(a1 + 1984) = v4;
    if (v12) {
      sub_10004D2C8(v12);
    }
    long long v13 = (BOOL **)(a1 + 1976);
    BOOL v14 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v15 = **v13 || (*v13)[1];
      uint64_t v16 = asStringBool(v15);
      uint64_t v17 = asStringBool(**v13);
      uint64_t v18 = asStringBool((*v13)[1]);
      int v23 = 136315650;
      uint64_t v24 = v16;
      __int16 v25 = 2080;
      uint64_t v26 = v17;
      __int16 v27 = 2080;
      uint64_t v28 = v18;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Internet active: %s [cellular: %s, wifi: %s]", (uint8_t *)&v23, 0x20u);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 2232) + 144))(*(void *)(a1 + 2232), a1 + 1976);
    if (v10 != v11)
    {
      long long v19 = *(unsigned char **)(a1 + 1976);
      if (*v19) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v19[1] != 0;
      }
      (*(void (**)(void, BOOL))(**(void **)(a1 + 2216) + 208))(*(void *)(a1 + 2216), v20);
      uint64_t v21 = *(unsigned char **)(a1 + 1976);
      if (*v21) {
        BOOL v22 = 1;
      }
      else {
        BOOL v22 = v21[1] != 0;
      }
      (*(void (**)(void, BOOL))(**(void **)(a1 + 2248) + 88))(*(void *)(a1 + 2248), v22);
    }
  }
}

void sub_1012047B0(uint64_t a1, char *a2, uint64_t a3)
{
  BOOL v3 = (void *)(a1 + 16);
  v5[4] = a1;
  char v6 = *a2;
  LOBYTE(__p) = 0;
  char v9 = 0;
  if (a2[32])
  {
    long long __p = *(_OWORD *)(a2 + 8);
    uint64_t v8 = *((void *)a2 + 3);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 1) = 0;
    char v9 = 1;
  }
  long long v10 = *(_OWORD *)(a2 + 40);
  long long v4 = *((_OWORD *)a2 + 5);
  long long v12 = *((_OWORD *)a2 + 4);
  long long v13 = v4;
  char v11 = a2[56];
  *((void *)a2 + 8) = 0;
  *((void *)a2 + 9) = 0;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  uint64_t v14 = *((void *)a2 + 12);
  sub_10120BA14((uint64_t)&v15, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

void sub_1012049F8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101204A08(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101204B04(uint64_t a1)
{
}

void sub_101204B0C(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_100BFEE6C((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_101204C40(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101204C50(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101204D3C(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (void *)(a1 + 16);
  __int16 v6 = a2;
  uint64_t v7 = a1;
  *(_OWORD *)long long __p = *(_OWORD *)a3;
  uint64_t v9 = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  sub_1002723D4((uint64_t)&v10, a4);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v4);
  operator new();
}

void sub_101204EB8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101204EC8(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101204FAC(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_10120D2E8((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_1012050E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1012050F0(uint64_t a1, long long *a2, uint64_t a3)
{
  BOOL v3 = (void *)(a1 + 16);
  v4[4] = a1;
  long long v5 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  sub_10120D674((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_101205254(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101205264(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_10120DA18((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_101205398(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1012053A8(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_100BFF000((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_1012054DC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1012054EC(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_100BFF194((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_101205620(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101205630(uint64_t a1, char a2, uint64_t a3)
{
  BOOL v3 = (void *)(a1 + 16);
  v4[4] = a1;
  char v5 = a2;
  sub_10120BA14((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_101205778(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101205788(uint64_t a1, void **a2, uint64_t a3)
{
  char v5 = *a2;
  void v6[4] = a1;
  xpc_object_t object_8 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object_8 = xpc_null_create();
  }
  sub_100C03EB8((uint64_t)&v8, a3);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 16));
  operator new();
}

void sub_1012058F0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_101205920(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  int v2 = *(uint64_t (**)(void))(**(void **)(a1 + 2264) + 16);

  return v2();
}

uint64_t sub_101205988(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 - 24));
  int v2 = *(uint64_t (**)(void))(**(void **)(a1 + 2208) + 16);

  return v2();
}

void sub_1012059F0(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 1992) != a2)
  {
    *(unsigned char *)(a1 + 1992) = a2;
    sub_101202394(a1, 1);
    sub_101202670(a1);
    sub_101201E5C(a1);
    uint64_t v4 = *(void (**)(void))(**(void **)(a1 + 2232) + 80);
    v4();
  }
}

void sub_101205A8C(uint64_t a1, int a2)
{
}

void sub_101205A94(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101205B70(uint64_t a1)
{
}

uint64_t sub_101205B78(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t result = *(void *)(a1 + 2352);
  if (result)
  {
    unsigned int v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    uint64_t result = sub_10025B63C(a1 + 2368, 0);
    if (v3 != (result == 1))
    {
      int v4 = result;
      char v5 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = 136315394;
        uint64_t v7 = asStringBool(v4 == 1);
        __int16 v8 = 2080;
        uint64_t v9 = asStringBool(v3);
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Min iOS based support changed from %s to %s", (uint8_t *)&v6, 0x16u);
      }
      sub_10025CAD8(a1 + 2368, v3);
      sub_101201608(a1, 0);
      return sub_101201E5C(a1);
    }
  }
  return result;
}

void sub_101205CC4(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101205DA0(uint64_t a1)
{
}

void sub_101205DA8(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101205E8C(uint64_t a1)
{
}

uint64_t (***sub_101205E94@<X0>(uint64_t a1@<X0>, void *a2@<X8>))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 2264);
  if (result) {
    return (uint64_t (***)(void))(**result)(result);
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t (***sub_101205EC8@<X0>(uint64_t a1@<X0>, void *a2@<X8>))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 2184);
  if (result) {
    return (uint64_t (***)(void))(**result)(result);
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_101205EFC(uint64_t a1, uint64_t a2)
{
  int v4 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    char v5 = "off";
    if (a2) {
      char v5 = "on";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I offGridModeUpdated: %s", (uint8_t *)&v6, 0xCu);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965)) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 2032) + 184))(*(void *)(a1 + 2032), a2);
  }
}

void sub_101205FF8(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_101206000(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I idsContactsUpdated", v4, 2u);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  return (*(uint64_t (**)(void))(**(void **)(a1 + 2248) + 96))(*(void *)(a1 + 2248));
}

uint64_t sub_101206094(uint64_t a1)
{
  return sub_101206000(a1 - 88);
}

void sub_10120609C(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_101210770((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_1012061D0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1012061E0(uint64_t a1, int a2, void *a3, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  if (cf) {
    CFRetain(cf);
  }
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 16));
  operator new();
}

void sub_101206368(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101206444(uint64_t a1, uint64_t a2)
{
  int v2 = (void *)(a1 + 16);
  v3[4] = a1;
  sub_101210B4C((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, v2);
  operator new();
}

void sub_101206578(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_101206588(uint64_t a1, uint64_t a2)
{
}

void sub_101206590(uint64_t a1, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  v8[0] = 0;
  v8[1] = 0;
  sub_10003E168(v8, (void *)(a1 + 16));
  operator new();
}

void sub_101206748(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
}

void sub_101206750(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_101206834(uint64_t a1)
{
}

void sub_10120683C(uint64_t a1, unsigned int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned int v4 = atomic_load((unsigned int *)(a1 + 1960));
  if (v4 != a2)
  {
    atomic_store(a2, (unsigned int *)(a1 + 1960));
    char v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v6 = atomic_load((unsigned int *)(a1 + 1960));
      if (v6 > 2) {
        uint64_t v7 = "???";
      }
      else {
        uint64_t v7 = off_101AA0C88[v6];
      }
      int v8 = 136315138;
      uint64_t v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Determined HW support: %s", (uint8_t *)&v8, 0xCu);
    }
    sub_101201768(a1);
    sub_101201608(a1, 1);
    sub_101201E5C(a1);
  }
}

void sub_101206940(uint64_t a1, unsigned int a2)
{
}

void sub_101206948(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 64);
    v2();
  }
  else
  {
    unsigned int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101206A20(uint64_t a1)
{
}

void sub_101206A28(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1965))
  {
    uint64_t v1 = *(void (**)(void))(**(void **)(a1 + 2032) + 152);
    v1();
  }
  else
  {
    int v2 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v3, 2u);
    }
  }
}

void sub_101206AD8(uint64_t a1)
{
}

void sub_101206AE0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 136);
    v2();
  }
  else
  {
    unsigned int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101206BA4(uint64_t a1)
{
}

void sub_101206BAC(uint64_t a1, int *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    uint64_t v4 = *(void *)(a1 + 2032);
    int v6 = *a2;
    *(_OWORD *)long long __p = *(_OWORD *)(a2 + 2);
    uint64_t v8 = *((void *)a2 + 3);
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    (*(void (**)(uint64_t, int *))(*(void *)v4 + 144))(v4, &v6);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    char v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
}

void sub_101206C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101206CA0(uint64_t a1, int *a2)
{
}

void sub_101206CA8(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 72);
    v2();
  }
  else
  {
    unsigned int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101206D80(uint64_t a1)
{
}

void sub_101206D88(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  sub_100058DB0(&__p, "/cc/assertions/stewie_mode_assertion");
  ctu::rest::AssertionHandle::create();
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_101206DF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101206E10(uint64_t a1)
{
}

void sub_101206E18(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  sub_100058DB0(&__p, "/cc/assertions/prevent_nvm_sync");
  ctu::rest::AssertionHandle::create();
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_101206E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101206EA0(uint64_t a1)
{
}

void sub_101206EA8(uint64_t a1, char a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));

  sub_101206EEC(a1 + 1944, a2);
}

void sub_101206EEC(uint64_t a1, char a2)
{
  xpc_object_t v2 = xpc_BOOL_create(a2 != 0);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/events/stewie_block_cellular_tx_event");
  xpc_object_t object = v2;
  xpc_object_t v3 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v6 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_101206F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_101206FD4(uint64_t a1, char a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 - 40));

  sub_101206EEC(a1 + 1872, a2);
}

void sub_101207018(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    xpc_object_t v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 200);
    v2();
  }
  else
  {
    xpc_object_t v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_1012070DC(uint64_t a1)
{
}

void sub_1012070E4(uint64_t a1, __int16 a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  *(_WORD *)(a1 + 2342) = a2 | 0x100;
  if (*(unsigned char *)(a1 + 1965))
  {
    uint64_t v4 = *(void (**)(void))(**(void **)(a1 + 2216) + 192);
    v4();
  }
}

void sub_101207164(uint64_t a1, __int16 a2)
{
}

void sub_10120716C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  *(_WORD *)(a1 + 2344) = a2 | 0x100;
  if (*(unsigned char *)(a1 + 1965))
  {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 2248) + 112))(*(void *)(a1 + 2248), a2);
    xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
    if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v4);
        xpc_object_t v5 = v4;
      }
      else
      {
        xpc_object_t v5 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
    }
    xpc_release(v4);
    xpc_object_t object = v5;
    if (v5) {
      xpc_retain(v5);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v7 = v6;
    sub_1000452AC(135, &object, &v7);
    xpc_release(v6);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v5);
  }
}

void sub_1012072AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  long long v12 = v11;
  xpc_release(v12);
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_1012072F8(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_101207300(uint64_t result, int a2)
{
  unsigned int v2 = a2 & 0xFFFFFFFD;
  int v3 = (a2 & 0xFFFFFFFD) == 0;
  if (*(unsigned __int8 *)(result + 2625) != v3)
  {
    uint64_t v4 = result;
    *(unsigned char *)(result + 2625) = v3;
    xpc_object_t v5 = *(NSObject **)(result + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 136315138;
      uint64_t v15 = asStringBool(v2 == 0);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Authorized for bystander location: %s", (uint8_t *)&v14, 0xCu);
    }
    if (v2)
    {
      xpc_object_t v6 = *(NSObject **)(v4 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [Bystander location based] Lost authorization. Clear bystander cache and fallback to MCC and MNC based approach", (uint8_t *)&v14, 2u);
      }
      xpc_object_t v7 = *(std::__shared_weak_count **)(v4 + 2640);
      *(void *)(v4 + 2632) = 0;
      *(void *)(v4 + 2640) = 0;
      if (v7) {
        sub_10004D2C8(v7);
      }
      *(unsigned char *)(v4 + 2648) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(v4 + 2664);
      *(void *)(v4 + 2656) = 0;
      *(void *)(v4 + 2664) = 0;
      if (v8) {
        sub_10004D2C8(v8);
      }
      if (*(unsigned char *)(v4 + 2530)) {
        *(unsigned char *)(v4 + 2530) = 0;
      }
      uint64_t v9 = *(std::__shared_weak_count **)(v4 + 2544);
      *(void *)(v4 + 2536) = 0;
      *(void *)(v4 + 2544) = 0;
      if (v9) {
        sub_10004D2C8(v9);
      }
      uint64_t v10 = *(std::__shared_weak_count **)(v4 + 2560);
      *(void *)(v4 + 2552) = 0;
      *(void *)(v4 + 2560) = 0;
      if (v10) {
        sub_10004D2C8(v10);
      }
      sub_10005CD2C(v4 + 2568, *(char **)(v4 + 2576));
      *(void *)(v4 + 2568) = v4 + 2576;
      *(void *)(v4 + 2584) = 0;
      *(void *)(v4 + 2576) = 0;
      (*(void (**)(void))(**(void **)(v4 + 2600) + 16))(*(void *)(v4 + 2600));
      (*(void (**)(void))(**(void **)(v4 + 2616) + 16))(*(void *)(v4 + 2616));
      sub_1012022AC(v4);
      sub_101202670(v4);
      if (*(unsigned char *)(v4 + 1965))
      {
        uint64_t v11 = v4 + 2528;
        uint64_t v12 = 2528;
        if (!*(unsigned char *)(v4 + 2530))
        {
          uint64_t v12 = 2432;
          uint64_t v11 = v4 + 2432;
        }
        if (*(unsigned char *)(v11 + 2)) {
          uint64_t v13 = *(unsigned __int16 *)(v4 + v12);
        }
        else {
          uint64_t v13 = 0;
        }
        (*(void (**)(void, uint64_t))(**(void **)(v4 + 2232) + 160))(*(void *)(v4 + 2232), v13);
      }
    }
    sub_101202394(v4, 0);
    return sub_101201E5C(v4);
  }
  return result;
}

uint64_t sub_101207554(uint64_t a1, int a2)
{
  return sub_101207300(a1 - 72, a2);
}

void sub_10120755C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    unsigned int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 160);
    v2();
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101207620(uint64_t a1)
{
}

void sub_101207628(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    unsigned int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 168);
    v2();
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101207700(uint64_t a1)
{
}

void sub_101207708(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    unsigned int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 176);
    v2();
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_1012077CC(uint64_t a1)
{
}

void sub_1012077D4(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 16));
  operator new();
}

void sub_1012078D8(uint64_t a1)
{
}

void sub_1012078E0(uint64_t a1, BOOL *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  BOOL v4 = a2[1];
  if (*(unsigned char *)(a1 + 1999)) {
    BOOL v5 = !v4;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    int v7 = v4;
    int v6 = *(unsigned __int8 *)(a1 + 1999) != 0;
  }
  else
  {
    int v6 = *(unsigned __int8 *)(a1 + 1998);
    int v7 = *a2;
  }
  if (v6 != v7)
  {
    uint64_t v8 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (v4) {
        uint64_t v9 = (const char *)asStringBool(*a2);
      }
      else {
        uint64_t v9 = "Unknown";
      }
      int v10 = 136315138;
      uint64_t v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Emergency call is possible based on cell scan result: %s", (uint8_t *)&v10, 0xCu);
    }
    *(_WORD *)(a1 + 1998) = *(_WORD *)a2;
    sub_101203E80(a1);
  }
}

void sub_1012079F0(uint64_t a1, BOOL *a2)
{
}

void sub_1012079F8(uint64_t a1, uint64_t **a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (!*a2) {
    __TUAssertTrigger();
  }
  if (!*(void *)(a1 + 2632))
  {
    BOOL v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = **a2;
      int v9 = 134217984;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received first bystander location, location timestamp: %lld", (uint8_t *)&v9, 0xCu);
    }
  }
  int v7 = *a2;
  int v6 = a2[1];
  if (v6) {
    atomic_fetch_add_explicit(v6 + 1, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 2632) = v7;
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 2640);
  *(void *)(a1 + 2640) = v6;
  if (v8) {
    sub_10004D2C8(v8);
  }
  *(unsigned char *)(a1 + 2648) = 0;
  sub_101202394(a1, 0);
}

void sub_101207B04(uint64_t a1, uint64_t **a2)
{
}

void sub_101207B0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    long long v19 = 0u;
    memset(v18, 0, sizeof(v18));
    *(void *)long long buf = a1;
    sub_1005CE444((uint64_t)v18, a3);
    int v6 = *(std::__shared_weak_count **)(a1 + 24);
    if (!v6 || (uint64_t v7 = *(void *)(a1 + 16), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
      sub_100088B9C();
    }
    *(void *)&long long v19 = v7;
    *((void *)&v19 + 1) = v8;
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    uint64_t v9 = *(void *)(a1 + 2216);
    uint64_t v12 = *(void *)buf;
    sub_1005CE444((uint64_t)v13, (uint64_t)v18);
    *(_OWORD *)int v14 = v19;
    long long v19 = 0uLL;
    uint64_t v16 = 0;
    uint64_t v10 = operator new(0x40uLL);
    *uint64_t v10 = off_101AA0BA8;
    v10[1] = v12;
    sub_1005CE444((uint64_t)(v10 + 2), (uint64_t)v13);
    *((_OWORD *)v10 + 3) = *(_OWORD *)v14;
    v14[0] = 0;
    v14[1] = 0;
    uint64_t v16 = v10;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v9 + 104))(v9, a2, v15);
    sub_1003891A4(v15);
    if (v14[1]) {
      std::__shared_weak_count::__release_weak(v14[1]);
    }
    sub_1003891A4(v13);
    if (*((void *)&v19 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v19 + 1));
    }
    sub_1003891A4(v18);
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    *(void *)&v18[0] = 0;
    sub_100268E74(a3);
    if (*(void *)&v18[0]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v18[0]);
    }
  }
}

void sub_101207D20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101207D70(uint64_t a1)
{
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_1003891A4((void *)(a1 + 8));
  return a1;
}

void sub_101207DA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_101207DB0(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    BOOL v4 = *(void (**)(void))(**(void **)(a1 + 2248) + 120);
    v4();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v6, 2u);
    }
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_101207E78(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_101207E80(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    BOOL v4 = *(void (**)(void))(**(void **)(a1 + 2216) + 136);
    v4();
  }
  else
  {
    uint64_t v5 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v6) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Not ready. Pending start", (uint8_t *)&v6, 2u);
    }
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    sub_100269014(a2);
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
}

void sub_101207F60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_101207F78(uint64_t a1, uint64_t a2)
{
}

void sub_101207F80(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    unsigned int v2 = *(void (**)(void))(**(void **)(a1 + 2216) + 64);
    v2();
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101208044(uint64_t a1)
{
}

void sub_10120804C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    (*(void (**)(void))(**(void **)(a1 + 2216) + 72))(*(void *)(a1 + 2216));
    unsigned int v2 = *(void (**)(void))(**(void **)(a1 + 2032) + 120);
    v2();
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_101208130(uint64_t a1)
{
}

void sub_101208138(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    *a2 = 0;
    a2[1] = 0;
    (*(void (**)(void))(**(void **)(a1 + 2216) + 96))(*(void *)(a1 + 2216));
    (*(void (**)(void, void *))(**(void **)(a1 + 2032) + 128))(*(void *)(a1 + 2032), a2);
  }
  else
  {
    BOOL v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v5, 2u);
    }
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_101208218(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_101208230(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_101208238(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    unsigned int v2 = *(void (**)(void))(**(void **)(a1 + 2216) + 144);
    v2();
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)BOOL v4 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v4, 2u);
    }
  }
}

void sub_1012082FC(uint64_t a1)
{
}

uint64_t sub_101208304(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  if (*(unsigned char *)(a1 + 1965))
  {
    unsigned int v2 = *(uint64_t (**)(void))(**(void **)(a1 + 2216) + 168);
    return v2();
  }
  else
  {
    BOOL v4 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", v5, 2u);
    }
    return 0;
  }
}

uint64_t sub_1012083CC(uint64_t a1)
{
  return sub_101208304(a1 - 72);
}

char *sub_1012083D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  BOOL v4 = *(long long **)(a1 + 1784);
  uint64_t v5 = *(long long **)(a1 + 1792);

  return sub_1000302C0((char *)a2, v4, v5, 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3));
}

char *sub_101208438@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1012083D4(a1 - 72, a2);
}

uint64_t sub_101208440(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  unsigned int v2 = *(uint64_t (**)(void))(**(void **)(a1 + 2216) + 184);

  return v2();
}

uint64_t sub_1012084A4(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 - 40));
  unsigned int v2 = *(uint64_t (**)(void))(**(void **)(a1 + 2144) + 184);

  return v2();
}

void *sub_101208508(void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_101208590(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1012085C8(uint64_t a1)
{
}

uint64_t sub_1012085E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_101208628(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_101208654(ServiceManager::Service *this)
{
  *(void *)this = off_101A9FBF8;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1012086B0(ServiceManager::Service *this)
{
  *(void *)this = off_101A9FBF8;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_101208720@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "StewieController");
}

unsigned char *sub_101208730@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unsigned int v2 = operator new(1uLL);
  *a1 = v2;
  *unsigned int v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_101208770(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(v2 + 16));
  operator new();
}

uint64_t sub_101208868()
{
  return 0;
}

uint64_t sub_101208870()
{
  return 1;
}

uint64_t sub_101208878()
{
  return 0;
}

void sub_101208884(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 16);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_101208960(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 16));
  operator new();
}

void sub_101208A74(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1;
  uint64_t v3 = v1;
  sub_1011FC4A8(*v1);
}

void sub_101208AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_101208AD4(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  sub_101201608(v1, 1);
  (*(void (**)(void))(**(void **)(v1 + 2232) + 8))(*(void *)(v1 + 2232));
  sub_101201768(v1);
  sub_101201E5C(v1);
  operator delete();
}

void sub_101208BAC()
{
}

uint64_t *sub_101208BD8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  (*(void (**)(void, uint64_t))(**(void **)(*(void *)v1 + 2216) + 160))(*(void *)(*(void *)v1 + 2216), *(void *)v1 + 64);
  (*(void (**)(void, uint64_t))(**(void **)(v2 + 2248) + 72))(*(void *)(v2 + 2248), v2 + 80);
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 1944));
  *(unsigned char *)(v2 + 1965) = 0;
  sub_100088C88(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_101208C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_101208C98(void *a1)
{
  *a1 = off_101A9FC78;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101208CE4(void *a1)
{
  *a1 = off_101A9FC78;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_101208D50(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A9FC78;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101208DB4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A9FC78;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101208DF4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101208E04(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_101208E44(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    BOOL v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[2]) {
        sub_101205B78(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_101208EB8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101208ECC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_101208F0C()
{
}

void sub_101208F1C()
{
}

__n128 sub_101208F30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A9FCF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101208F84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9FCF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101208FBC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101209004(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101209044()
{
}

void sub_101209054()
{
}

__n128 sub_101209068(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A9FD78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1012090BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9FD78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1012090F4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10120913C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120917C()
{
}

uint64_t sub_101209188(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 16);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_1012091D4(void *a1)
{
  *a1 = off_101A9FE18;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101209220(void *a1)
{
  *a1 = off_101A9FE18;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_10120928C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_10120933C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_101209354(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_101209374()
{
}

void *sub_1012093E0(void *a1)
{
  *a1 = off_101A9FE68;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10120942C(void *a1)
{
  *a1 = off_101A9FE68;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_101209498()
{
}

void sub_101209508()
{
}

__n128 sub_10120951C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A9FEA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101209570(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9FEA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1012095A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    BOOL v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_1012095F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101209638()
{
}

void sub_101209648()
{
}

__n128 sub_10120965C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A9FF28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1012096B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9FF28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1012096E8(void *a1, xpc_object_t *a2)
{
  uint64_t v7 = 0;
  sub_100034810((int *)&v7, a2);
  uint64_t v3 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v4 = a1[3];
  uint64_t v5 = (void *)(a1[1] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t *))(*v5 + v3);
  }
  return v3(v5, &v7);
}

uint64_t sub_101209768(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1012097A8()
{
}

void sub_1012097B8()
{
}

__n128 sub_1012097CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A9FFA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101209820(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A9FFA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101209858(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = &v16;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10005CD2C((uint64_t)&v15, v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = &v16;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v22, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v21, object, count);
    xpc_release(object[0]);
    for (CFIndex i = v23; ; CFIndex i = ++v23)
    {
      if (i == v21[1] && v22 == v21[0])
      {
        xpc_release(v22);
        xpc_release(v22);
        goto LABEL_41;
      }
      xpc_object_t v20 = 0;
      object[0] = &v22;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v20);
      if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_39:
      xpc_release(v20);
    }
    *(_OWORD *)xpc_object_t object = 0u;
    long long v19 = 0u;
    xpc_object_t v6 = v20;
    if (v20)
    {
      xpc_retain(v20);
      xpc_object_t v26 = v6;
    }
    else
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v26 = v6;
      if (!v6)
      {
        xpc_object_t v7 = xpc_null_create();
        xpc_object_t v6 = 0;
        goto LABEL_26;
      }
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v6);
      xpc_object_t v7 = v6;
LABEL_27:
      if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v24[0] = &v26;
        v24[1] = "first";
        sub_100048BAC((uint64_t)v24, &v25);
        uint64_t v29 = 0;
        BOOL v30 = 0;
        uint64_t v31 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v31) < 0) {
          operator delete(v29);
        }
        if (SBYTE7(v19) < 0) {
          operator delete(object[0]);
        }
        *(_OWORD *)xpc_object_t object = *(_OWORD *)v27;
        *(void *)&long long v19 = v28;
        xpc_release(v25);
        uint64_t v29 = &v26;
        BOOL v30 = "second";
        sub_100048BAC((uint64_t)&v29, v27);
        BYTE8(v19) = xpc::dyn_cast_or_default((xpc *)v27, 0, v8);
        xpc_release(v27[0]);
        xpc_object_t v7 = v26;
      }
      xpc_release(v7);
      xpc_release(v6);
      uint64_t v29 = 0;
      uint64_t v9 = sub_100046ED4((uint64_t)&v15, &v29, object);
      if (!*v9)
      {
        uint64_t v10 = operator new(0x40uLL);
        void v10[2] = *(_OWORD *)object;
        *((void *)v10 + 6) = v19;
        object[1] = 0;
        *(void *)&long long v19 = 0;
        object[0] = 0;
        *((unsigned char *)v10 + 56) = BYTE8(v19);
        uint64_t v11 = v29;
        *(void *)uint64_t v10 = 0;
        *((void *)v10 + 1) = 0;
        *((void *)v10 + 2) = v11;
        *uint64_t v9 = v10;
        if (*v15)
        {
          uint64_t v15 = (char **)*v15;
          uint64_t v10 = (_OWORD *)*v9;
        }
        sub_100046C90((uint64_t *)v16, (uint64_t *)v10);
        ++v17;
      }
      if (SBYTE7(v19) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_39;
    }
    xpc_object_t v7 = xpc_null_create();
LABEL_26:
    xpc_object_t v26 = v7;
    goto LABEL_27;
  }
LABEL_41:
  xpc_release(v3);
  uint64_t v12 = (void (*)(void *, xpc_object_t *))a1[2];
  uint64_t v13 = a1[3];
  int v14 = (void *)(a1[1] + (v13 >> 1));
  if (v13) {
    uint64_t v12 = *(void (**)(void *, xpc_object_t *))(*v14 + v12);
  }
  object[0] = v15;
  object[1] = v16;
  *(void *)&long long v19 = v17;
  if (v17)
  {
    *((void *)v16 + 2) = &object[1];
    uint64_t v15 = &v16;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  else
  {
    object[0] = &object[1];
  }
  v12(v14, object);
  sub_10005CD2C((uint64_t)object, (char *)object[1]);
  sub_10005CD2C((uint64_t)&v15, v16);
}

void sub_101209C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, char *a11, uint64_t a12, xpc_object_t object, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, xpc_object_t a20,xpc_object_t a21,uint64_t a22,xpc_object_t a23,uint64_t a24,uint64_t a25,uint64_t a26,xpc_object_t a27,xpc_object_t a28,xpc_object_t a29)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a23);
  xpc_release(v29);
  sub_10005CD2C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_101209D98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101209DD8()
{
}

void sub_101209DE8()
{
}

__n128 sub_101209DFC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101AA0028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101209E50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_101209E88(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  xpc_object_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_101209ED0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101209F10()
{
}

void sub_101209F20()
{
}

void *sub_101209F34(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA00A8;
  result[1] = v3;
  return result;
}

uint64_t sub_101209F7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA00A8;
  a2[1] = v2;
  return result;
}

void sub_101209FA8(uint64_t a1, const StewieFeatureState *a2)
{
  xpc_object_t v5 = 0;
  write_rest_value(a2);
  sub_100058DB0(&__p, "/cc/props/stewie_feature_state");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10120A04C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10120A090(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120A0D0()
{
}

void sub_10120A0E0()
{
}

__n128 sub_10120A0F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0138;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120A148(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120A180(void *a1, xpc *this, BOOL a3)
{
  char v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *char v4 = xpc::dyn_cast_or_default(this, 0, a3);
  xpc_object_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  BOOL v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_10120A21C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120A25C()
{
}

void sub_10120A26C()
{
}

__n128 sub_10120A280(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA01B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120A2D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA01B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120A30C(void *a1, xpc_object_t *a2)
{
  char v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *char v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *char v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10120A404(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120A444()
{
}

void sub_10120A454()
{
}

__n128 sub_10120A468(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0238;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120A4BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0238;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120A4F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120A534()
{
}

void sub_10120A544()
{
}

__n128 sub_10120A558(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA02B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120A5AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA02B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120A5E4(uint64_t a1, const xpc::object *a2)
{
  read_rest_value(*(RegisteredNetworkInfo **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10120A660(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120A6A0()
{
}

void sub_10120A6B0()
{
}

__n128 sub_10120A6C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0338;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120A718(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0338;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120A750(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned __int8 v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10120A848(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120A888()
{
}

void sub_10120A898()
{
}

__n128 sub_10120A8AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA03B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120A900(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA03B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10120A938(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1004CED98((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  BOOL v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000886C0((uint64_t)&v9, v10);
}

void sub_10120A9F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_10120AA10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120AA50()
{
}

void sub_10120AA60()
{
}

__n128 sub_10120AA74(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0438;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120AAC8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0438;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120AB00(void *a1, xpc *this, uint64_t a3)
{
  uint64_t v4 = (_DWORD *)a1[1];
  uint64_t v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  xpc_object_t v6 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v7 = a1[4];
  BOOL v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(uint64_t (**)(void *, uint64_t))(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_10120AB98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120ABD8()
{
}

void sub_10120ABE8()
{
}

__n128 sub_10120ABFC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA04B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120AC50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA04B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120AC88(uint64_t a1, xpc_object_t *a2)
{
  sub_100033E28(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10120AD04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120AD44()
{
}

void sub_10120AD54()
{
}

__n128 sub_10120AD68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0538;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120ADBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0538;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120ADF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120AE34()
{
}

void sub_10120AE44()
{
}

__n128 sub_10120AE58(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA05B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120AEAC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA05B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120AEE4(uint64_t *a1, xpc_object_t *a2)
{
  sub_1002430C8(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10120AF60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120AFA0()
{
}

void sub_10120AFB0()
{
}

__n128 sub_10120AFC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0638;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120B018(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0638;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120B050(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10120B148(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120B188()
{
}

void sub_10120B198()
{
}

__n128 sub_10120B1AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA06B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120B200(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA06B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120B238(void *a1)
{
  rest::read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  uint64_t v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_10120B2B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120B2F4()
{
}

void sub_10120B304()
{
}

__n128 sub_10120B318(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA0738;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120B36C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0738;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10120B3A4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    *uint64_t v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1010B1040((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  BOOL v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_10120B464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10120B47C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120B4BC()
{
}

void sub_10120B4CC()
{
}

__n128 sub_10120B4E0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101AA07B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10120B534(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA07B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10120B56C(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  int v9 = **(_DWORD **)(a1 + 8);
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  uint64_t v4 = *(uint64_t (**)(void *, int *))(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  xpc_object_t v6 = (void *)(*(void *)(a1 + 16) + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, int *))(*v6 + v4);
  }
  return v4(v6, &v9);
}

void sub_10120B624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

uint64_t sub_10120B640(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120B680()
{
}

void sub_10120B690()
{
}

void *sub_10120B6A4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA0838;
  result[1] = v3;
  return result;
}

uint64_t sub_10120B6EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA0838;
  a2[1] = v2;
  return result;
}

void sub_10120B718(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(NSObject **)(v1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Timer to disconnect TryOut after screen lock expired", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 2752);
  *(_OWORD *)(v1 + 2744) = 0u;
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = 16;
  __int16 v5 = 2;
  char v6 = 1;
  char v7 = 1;
  sub_1012030EC(v1, &v4);
}

uint64_t sub_10120B7BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120B7FC()
{
}

void sub_10120B80C()
{
}

__n128 sub_10120B820(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101AA08B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_10120B86C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA08B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10120B89C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Timer to disconnect messaging after screen lock expired", buf, 2u);
  }
  int v4 = *(std::__shared_weak_count **)(v2 + 2728);
  *(_OWORD *)(v2 + 2720) = 0u;
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = 16;
  __int16 v6 = *(_DWORD *)(a1 + 16);
  char v7 = 1;
  char v8 = 0;
  sub_1012030EC(v2, &v5);
}

uint64_t sub_10120B948(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120B988()
{
}

void sub_10120B994(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101AA0938;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10120B9B4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101AA0938;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10120BA08(uint64_t a1)
{
}

uint64_t sub_10120BA14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_10120BA94(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v43 = a1;
  uint64_t v44 = v1;
  uint64_t v2 = *(void *)v1;
  if (!*(unsigned char *)(*(void *)v1 + 1965))
  {
    CFNumberRef v42 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Not ready. Pending start", (uint8_t *)buf, 2u);
    }
    sub_100058DB0(buf, "Not ready to service request");
    sub_10120C6B8(*(void *)(v1 + 136), 0);
    goto LABEL_87;
  }
  uint64_t v3 = (BOOL *)(v1 + 48);
  uint64_t v4 = (unsigned char *)(v1 + 8);
  if (!*(unsigned char *)(v1 + 48))
  {
    if (!*v4)
    {
      int v11 = *(_DWORD *)(v1 + 108);
      if (v11 == 10 || v11 == 8)
      {
        (*(void (**)(void *__return_ptr))(**(void **)(v2 + 2248) + 120))(buf);
        long long v13 = *(_OWORD *)buf;
        buf[0] = 0;
        buf[1] = 0;
        unsigned int v14 = *(std::__shared_weak_count **)(v1 + 96);
        *(_OWORD *)(v1 + 88) = v13;
        if (v14)
        {
          sub_10004D2C8(v14);
          if (buf[1]) {
            sub_10004D2C8((std::__shared_weak_count *)buf[1]);
          }
        }
      }
      else if (v11 == 7 && !*(void *)(v1 + 72))
      {
        uint64_t v16 = *(std::__shared_weak_count **)(v2 + 24);
        if (v16)
        {
          uint64_t v17 = *(void *)(v2 + 16);
          uint64_t v18 = std::__shared_weak_count::lock(v16);
          if (v18)
          {
            buf[0] = v17;
            buf[1] = v18;
            atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v18);
            LOBYTE(buf[2]) = *(unsigned char *)(v1 + 8);
            LOBYTE(buf[3]) = 0;
            LOBYTE(v49[0]) = 0;
            if (*(unsigned char *)(v1 + 40))
            {
              long long v19 = *(_OWORD *)(v1 + 16);
              buf[5] = *(void *)(v1 + 32);
              *(_OWORD *)&buf[3] = v19;
              *(void *)(v1 + 24) = 0;
              *(void *)(v1 + 32) = 0;
              *(void *)(v1 + 16) = 0;
              LOBYTE(v49[0]) = 1;
            }
            long long v20 = *(_OWORD *)v3;
            BYTE8(v49[1]) = *(unsigned char *)(v1 + 64);
            *(_OWORD *)((char *)v49 + 8) = v20;
            long long v50 = *(_OWORD *)(v1 + 72);
            *(void *)(v1 + 72) = 0;
            *(void *)(v1 + 80) = 0;
            long long v51 = *(_OWORD *)(v1 + 88);
            *(void *)(v1 + 88) = 0;
            *(void *)(v1 + 96) = 0;
            uint64_t v52 = *(void *)(v1 + 104);
            sub_10120BA14((uint64_t)v53, v1 + 112);
            uint64_t v21 = (char *)operator new(0xA0uLL);
            xpc_object_t v22 = v21;
            *(void *)uint64_t v21 = off_101AA0988;
            *(_OWORD *)(v21 + 8) = *(_OWORD *)buf;
            buf[0] = 0;
            buf[1] = 0;
            v21[24] = buf[2];
            v21[32] = 0;
            v21[56] = 0;
            if (LOBYTE(v49[0]))
            {
              *((_OWORD *)v21 + 2) = *(_OWORD *)&buf[3];
              *((void *)v21 + 6) = buf[5];
              memset(&buf[3], 0, 24);
              v21[56] = 1;
            }
            *((_OWORD *)v21 + 4) = *(_OWORD *)((char *)v49 + 8);
            long long v23 = v51;
            *(_OWORD *)(v21 + 88) = v50;
            v21[80] = BYTE8(v49[1]);
            long long v50 = 0uLL;
            *(_OWORD *)(v21 + 104) = v23;
            long long v51 = 0uLL;
            *((void *)v21 + 15) = v52;
            sub_10120BA14((uint64_t)(v21 + 128), (uint64_t)v53);
            *((void *)&v47[0] + 1) = v22;
            sub_101204FAC(v2, (uint64_t)v46);
          }
        }
        sub_100088B9C();
      }
      goto LABEL_5;
    }
    goto LABEL_10;
  }
  if (!*(unsigned char *)(v1 + 50))
  {
    unsigned int v9 = *(_DWORD *)(v1 + 108);
    if (v9 > 0xA) {
      unsigned __int16 v10 = 0;
    }
    else {
      unsigned __int16 v10 = word_1015DD0C2[v9];
    }
    if ((v10 & *(_WORD *)(v2 + 130)) != 0)
    {
      long long v50 = 0u;
      memset(v49, 0, sizeof(v49));
      memset(buf, 0, sizeof(buf));
      LODWORD(buf[0]) = v9;
      LOBYTE(buf[1]) = 0;
      BYTE2(buf[5]) = 0;
      BYTE8(v49[0]) = 0;
      LOBYTE(buf[5]) = 1;
      (*(void (**)(void, void *))(**(void **)(v2 + 2032) + 16))(*(void *)(v2 + 2032), buf);
      if (LOBYTE(buf[4]) && SHIBYTE(buf[3]) < 0) {
        operator delete((void *)buf[1]);
      }
      goto LABEL_15;
    }
LABEL_40:
    sub_100058DB0(buf, "Stewie is not permitted right now");
    sub_10120C6B8(*(void *)(v1 + 136), 0);
    goto LABEL_87;
  }
  if (*v4)
  {
LABEL_10:
    int v8 = *(_DWORD *)(v1 + 108);
    if ((v8 - 8) >= 3)
    {
      sub_100058DB0(buf, "Offer is not supported for this request reason");
      sub_10120C6B8(*(void *)(v1 + 136), 0);
      goto LABEL_87;
    }
    if (((unsigned __int16)(0x2000100030uLL >> (16 * (v8 - 8))) & *(_WORD *)(v2 + 128)) != 0)
    {
      long long v50 = 0u;
      memset(v49, 0, sizeof(v49));
      memset(buf, 0, sizeof(buf));
      LODWORD(buf[0]) = v8;
      LOBYTE(buf[1]) = 0;
      LOBYTE(buf[5]) = 0;
      BYTE4(buf[0]) = 1;
      BYTE8(v50) = 0;
      sub_100179AF8((std::string *)&buf[1], (const std::string *)(v1 + 16));
      (*(void (**)(void, void *))(**(void **)(v2 + 2032) + 16))(*(void *)(v2 + 2032), buf);
      if (LOBYTE(buf[4]) && SHIBYTE(buf[3]) < 0) {
        operator delete((void *)buf[1]);
      }
LABEL_15:
      sub_100058DB0(buf, "");
      sub_10120C6B8(*(void *)(v1 + 136), 1);
      goto LABEL_87;
    }
    goto LABEL_40;
  }
LABEL_5:
  memset(v47, 0, sizeof(v47));
  *(_OWORD *)uint64_t v46 = 0u;
  uint64_t v5 = *(void *)(v2 + 2232);
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v2 + 2216) + 80))(*(void *)(v2 + 2216));
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 32))(v46, v5, v1 + 8, v6);
  if (v46[1])
  {
    char v7 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Awaiting user action...", (uint8_t *)buf, 2u);
    }
    goto LABEL_86;
  }
  StewieController::submitStewieRequestMetric(v2, *(_DWORD *)(v1 + 108), *(unsigned __int8 *)(v1 + 48), v46[0]);
  Registry::getTimerService(buf, *(Registry **)(v2 + 1928));
  uint64_t v15 = (**(uint64_t (***)(void))buf[0])(buf[0]);
  if (!*(unsigned char *)(v2 + 2800)) {
    *(unsigned char *)(v2 + 2800) = 1;
  }
  *(void *)(v2 + 2792) = v15;
  if (buf[1]) {
    sub_10004D2C8((std::__shared_weak_count *)buf[1]);
  }
  if (v46[0])
  {
    if (!v46[4])
    {
      if (v46[9])
      {
        int isServiceActive = StewieFeatureState::isServiceActive();
        uint64_t v26 = *(void *)(v2 + 2032);
        if (*v3) {
          int v27 = 5;
        }
        else {
          int v27 = *(_DWORD *)(v1 + 108);
        }
        if (isServiceActive) {
          int v31 = 65544;
        }
        else {
          int v31 = 0;
        }
        LODWORD(buf[0]) = v27;
        BYTE4(buf[0]) = 0;
        LOBYTE(buf[1]) = 0;
        LOBYTE(buf[4]) = 0;
        LOBYTE(buf[5]) = 0;
        WORD1(buf[5]) = *(_WORD *)&v46[7];
        HIDWORD(buf[5]) = v31;
        LOBYTE(v49[0]) = 1;
        BYTE8(v49[0]) = 0;
        BYTE8(v50) = 0;
        (*(void (**)(uint64_t, void *))(*(void *)v26 + 16))(v26, buf);
        if (LOBYTE(buf[4]) && SHIBYTE(buf[3]) < 0) {
          operator delete((void *)buf[1]);
        }
        LODWORD(buf[0]) = 1;
        WORD2(buf[0]) = 8;
      }
      else
      {
        if (!BYTE8(v47[1]))
        {
          uint64_t v32 = *(NSObject **)(v2 + 48);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I No conversation info was provided", (uint8_t *)buf, 2u);
          }
          uint64_t v33 = *(void *)(v2 + 2032);
          if (*v3) {
            int v34 = 5;
          }
          else {
            int v34 = *(_DWORD *)(v1 + 108);
          }
          LODWORD(buf[0]) = v34;
          BYTE4(buf[0]) = 0;
          LOBYTE(buf[1]) = 0;
          LOBYTE(buf[4]) = 0;
          LOBYTE(buf[5]) = 0;
          BYTE2(buf[5]) = 0;
          LOBYTE(v49[0]) = 0;
          BYTE8(v49[0]) = 0;
          BYTE8(v50) = 0;
          (*(void (**)(uint64_t, void *))(*(void *)v33 + 16))(v33, buf);
          if (LOBYTE(buf[4]) && SHIBYTE(buf[3]) < 0) {
            operator delete((void *)buf[1]);
          }
          if (!*(unsigned char *)(v2 + 1993))
          {
            *(unsigned char *)(v2 + 1993) = 1;
            sub_10120C708();
          }
          goto LABEL_86;
        }
        int v28 = StewieFeatureState::isServiceActive();
        uint64_t v29 = *(void *)(v2 + 2032);
        if (*v3) {
          int v30 = 5;
        }
        else {
          int v30 = *(_DWORD *)(v1 + 108);
        }
        if (v28) {
          int v40 = 0x10000;
        }
        else {
          int v40 = 0;
        }
        LODWORD(buf[0]) = v30;
        BYTE4(buf[0]) = 0;
        LOBYTE(buf[1]) = 0;
        LOBYTE(buf[4]) = 0;
        LOBYTE(buf[5]) = 0;
        BYTE2(buf[5]) = 0;
        LOBYTE(v49[0]) = 0;
        WORD4(v49[0]) = v47[0];
        v49[1] = *(_OWORD *)((char *)v47 + 8);
        LODWORD(v50) = v40 | v28;
        BYTE8(v50) = 1;
        (*(void (**)(uint64_t, void *))(*(void *)v29 + 16))(v29, buf);
        if (LOBYTE(buf[4]) && SHIBYTE(buf[3]) < 0) {
          operator delete((void *)buf[1]);
        }
        LODWORD(buf[0]) = 1;
        WORD2(buf[0]) = 1;
      }
      BYTE6(buf[0]) = 1;
      LOBYTE(buf[1]) = 0;
      sub_101204A08(v2);
    }
LABEL_86:
    sub_100058DB0(buf, "");
    sub_10120C6B8(*(void *)(v1 + 136), 1);
    goto LABEL_87;
  }
  uint64_t v24 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v35 = sub_100BC8B6C(*(_DWORD *)(v1 + 108));
    sub_100BC897C(*(unsigned __int16 *)&v46[2], &v45);
    int v36 = SHIBYTE(v45.__r_.__value_.__r.__words[2]);
    std::string::size_type v37 = v45.__r_.__value_.__r.__words[0];
    uint64_t v38 = asStringBool(*v3);
    uint64_t v39 = &v45;
    LODWORD(buf[0]) = 136315650;
    if (v36 < 0) {
      uint64_t v39 = (std::string *)v37;
    }
    *(void *)((char *)buf + 4) = v35;
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v39;
    HIWORD(buf[2]) = 2080;
    buf[3] = v38;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Request for reason: %s failed, requested services: %{public}s, isTryOut: %s", (uint8_t *)buf, 0x20u);
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
  }
  sub_100058DB0(buf, "Stewie is not permitted right now");
  sub_10120C6B8(*(void *)(v1 + 136), 0);
LABEL_87:
  if (SHIBYTE(buf[2]) < 0) {
    operator delete((void *)buf[0]);
  }
  sub_10120C638(&v44);
  return sub_100046B58((uint64_t *)&v43);
}

void sub_10120C53C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,std::__shared_weak_count *a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,char a34,int a35,int a36,__int16 a37,char a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  sub_10120C638(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120C638(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E7E54((void *)(v1 + 112));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 96);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 80);
    if (v3) {
      sub_10004D2C8(v3);
    }
    if (*(unsigned char *)(v1 + 40))
    {
      if (*(char *)(v1 + 39) < 0) {
        operator delete(*(void **)(v1 + 16));
      }
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10120C6B8(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_10120C708()
{
  sub_100058DB0(&__p, "/cc/events/stewie_requested_event");
  xpc_object_t object = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
}

void sub_10120C778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10120C7A8(uint64_t a1)
{
  *(void *)a1 = off_101AA0988;
  sub_1001E7E54((void *)(a1 + 128));
  char v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_10120C828(uint64_t a1)
{
  *(void *)a1 = off_101AA0988;
  sub_1001E7E54((void *)(a1 + 128));
  char v2 = *(std::__shared_weak_count **)(a1 + 112);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 96);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_10120C8C8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0xA0uLL);
  *char v2 = off_101AA0988;
  sub_10120CBB0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10120C91C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10120C930(uint64_t a1, void *a2)
{
  *a2 = off_101AA0988;
  return sub_10120CBB0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10120C95C(uint64_t a1)
{
}

void sub_10120C964(void *a1)
{
  sub_10120CD18((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10120C9A0(uint64_t a1, uint64_t *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *a2;
        if (*a2 && *(void *)(v7 + 16))
        {
          uint64_t v8 = a2[1];
          *a2 = 0;
          a2[1] = 0;
          unsigned int v9 = *(std::__shared_weak_count **)(a1 + 96);
          *(void *)(a1 + 88) = v7;
          *(void *)(a1 + 96) = v8;
          if (v9) {
            sub_10004D2C8(v9);
          }
          sub_1012047B0(v6, (char *)(a1 + 24), a1 + 128);
        }
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "stw.ctr");
        unsigned __int16 v10 = __p[1];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No roadside providers found! Failing request for Roadside assitance", (uint8_t *)__p, 2u);
        }
        sub_100058DB0(__p, "No roadside providers found!");
        sub_10120C6B8(*(void *)(a1 + 152), 0);
        if (v12 < 0) {
          operator delete(__p[0]);
        }
LABEL_18:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  sub_100058DB0(__p, "Failed to process request");
  sub_10120C6B8(*(void *)(a1 + 152), 0);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (v5) {
    goto LABEL_18;
  }
}

void sub_10120CB10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_10120CB64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10120CBA4()
{
}

uint64_t sub_10120CBB0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  sub_1000593FC(a1 + 24, (long long *)(a2 + 24));
  long long v5 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  uint64_t v6 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a2 + 104);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a1 + 104) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  uint64_t v8 = *(void *)(a2 + 144);
  if (v8)
  {
    if (v8 == a2 + 120)
    {
      *(void *)(a1 + 144) = a1 + 120;
      (*(void (**)(void))(**(void **)(a2 + 144) + 24))(*(void *)(a2 + 144));
      return a1;
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  *(void *)(a1 + 144) = v8;
  return a1;
}

void sub_10120CCC8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 104);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(v1 + 88);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*(unsigned char *)(v1 + 48) && *(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 8);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  _Unwind_Resume(exception_object);
}

void sub_10120CD18(uint64_t a1)
{
  sub_1001E7E54((void *)(a1 + 120));
  char v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_10004D2C8(v2);
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_10120CD94(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_1012030EC(**a1, (_DWORD *)*a1 + 2);
  operator delete();
}

void sub_10120CDEC()
{
}

uint64_t *sub_10120CE18(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *v1;
  if (*(unsigned char *)(*v1 + 1965))
  {
    (*(void (**)(void, void *))(**(void **)(v2 + 2032) + 32))(*(void *)(v2 + 2032), v1 + 1);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    unsigned int v9 = 0;
    uint64_t v5 = v1[4];
    if (!v5) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 48))(v5, buf);
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  sub_10120CF48((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10120CF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10120CF48(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120CF48(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E8174((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_10120CF98(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (*(unsigned char *)(v2 + 1965))
  {
    (*(void (**)(void, uint64_t *))(**(void **)(v2 + 2232) + 152))(*(void *)(v2 + 2232), v1 + 1);
    (*(void (**)(void, uint64_t *))(**(void **)(v2 + 2032) + 96))(*(void *)(v2 + 2032), v1 + 1);
  }
  else
  {
    char v3 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
  operator delete();
}

void sub_10120D094()
{
}

uint64_t *sub_10120D0C0(unsigned __int16 **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *((void *)v1 + 1);
  if (*(unsigned char *)(v2 + 1965))
  {
    (*(void (**)(void, void, unsigned __int16 *, unsigned __int16 *))(**(void **)(v2 + 2232) + 56))(*(void *)(v2 + 2232), *v1, v1 + 8, v1 + 20);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
  sub_10120D198(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10120D17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_10120D198(void *result)
{
  uint64_t v1 = (void *)*result;
  void *result = 0;
  if (v1)
  {
    sub_1001E8DA8(v1 + 5);
    uint64_t v2 = (void *)v1[2];
    if (v2)
    {
      v1[3] = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

void sub_10120D1F8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (*(unsigned char *)(v1 + 1965))
  {
    (*(void (**)(void, void))(**(void **)(v1 + 2032) + 56))(*(void *)(v1 + 2032), *((unsigned int *)*a1 + 2));
  }
  else
  {
    uint64_t v2 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
  operator delete();
}

void sub_10120D2BC()
{
}

uint64_t sub_10120D2E8(uint64_t a1, uint64_t a2)
{
  char v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    char v3 = (void *)(a1 + 24);
  }
  *char v3 = 0;
  return a1;
}

uint64_t *sub_10120D368(void **a1)
{
  uint64_t v1 = *a1;
  char v12 = a1;
  long long v13 = v1;
  uint64_t v2 = *v1;
  if (!*(unsigned char *)(*v1 + 1965))
  {
    unsigned __int16 v10 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    *(void *)&long long v17 = 0;
    uint64_t v11 = v1[4];
    if (!v11) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v11 + 48))(v11, buf);
    uint64_t v5 = (std::__shared_weak_count *)v17;
    if ((void)v17) {
      goto LABEL_24;
    }
    goto LABEL_25;
  }
  if (*(unsigned char *)(v2 + 2530)) {
    uint64_t v3 = v2 + 2528;
  }
  else {
    uint64_t v3 = v2 + 2432;
  }
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 16);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    if (v4)
    {
      *(void *)long long buf = v4;
      *(void *)&long long v17 = v5;
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_10;
    }
LABEL_14:
    uint64_t v7 = *(void *)(v2 + 2216);
    sub_100058DB0(__p, "");
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void **))(*(void *)v7 + 120))(buf, v7, __p);
    long long v19 = v17;
    long long v17 = 0uLL;
    uint64_t v8 = v1[4];
    if (!v8) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v8 + 48))(v8, &v19);
    if (*((void *)&v19 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v19 + 1));
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (*((void *)&v17 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v17 + 1));
    }
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_23;
  }
  if (!v4) {
    goto LABEL_14;
  }
  *(void *)long long buf = *(void *)(v3 + 8);
  *(void *)&long long v17 = 0;
LABEL_10:
  uint64_t v6 = v1[4];
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v6 + 48))(v6, buf);
  if ((void)v17)
  {
    sub_10004D2C8((std::__shared_weak_count *)v17);
    if (!v5) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
LABEL_23:
  if (v5) {
LABEL_24:
  }
    sub_10004D2C8(v5);
LABEL_25:
  sub_10120D624((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_10120D598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10120D624(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120D624(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E971C((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10120D674(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_10120D6F4(void **a1)
{
  uint64_t v1 = *a1;
  char v12 = a1;
  long long v13 = v1;
  uint64_t v2 = *v1;
  if (!*(unsigned char *)(*v1 + 1965))
  {
    uint64_t v11 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    long long __p = 0;
    uint64_t v10 = v1[6];
    if (!v10) {
      sub_10007B600();
    }
LABEL_15:
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 48))(v10, buf);
    uint64_t v7 = (std::__shared_weak_count *)__p;
    if (!__p) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (!v1[1])
  {
    unsigned int v9 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Context is missing", buf, 2u);
    }
    *(void *)long long buf = 0;
    long long __p = 0;
    uint64_t v10 = v1[6];
    if (!v10) {
      sub_10007B600();
    }
    goto LABEL_15;
  }
  uint64_t v26 = 0;
  int v27 = 0;
  (*(void (**)(char **__return_ptr))(**(void **)(v2 + 2232) + 184))(&v26);
  if (v26)
  {
    if (v26[1])
    {
      uint64_t v3 = *(void *)(v2 + 2032);
      char v4 = *v26;
      *(_DWORD *)long long buf = 7;
      uint8_t buf[4] = 0;
      long long v5 = *(_OWORD *)(v26 + 8);
      LOBYTE(__p) = 0;
      char v17 = 0;
      char v18 = 0;
      char v19 = 0;
      char v20 = 0;
      char v21 = v4;
      char v22 = 1;
      long long v23 = v5;
      int v24 = 0;
      char v25 = 1;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v3 + 16))(v3, buf);
      if (v17)
      {
        if (v16 < 0) {
          operator delete(__p);
        }
      }
    }
  }
  uint64_t v6 = v1[6];
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char **))(*(void *)v6 + 48))(v6, &v26);
  uint64_t v7 = v27;
  if (v27) {
LABEL_10:
  }
    sub_10004D2C8(v7);
LABEL_11:
  sub_10120D9BC((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_10120D958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (__p) {
    sub_10004D2C8(__p);
  }
  sub_10120D9BC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120D9BC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E9A74((void *)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_10120DA18(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_10120DA98(uint64_t **a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *v1;
  if (*(unsigned char *)(*v1 + 1965))
  {
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 2232) + 192))(buf);
    sub_10120DC04(v1[4], 1);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    uint64_t v8 = 0;
    sub_10120DC04(v1[4], 0);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_10120DBB4((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10120DB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10120DBB4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120DBB4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E9D80((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_10120DC04(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t *sub_10120DC54(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *v1;
  if (*(unsigned char *)(*v1 + 1965))
  {
    (*(void (**)(void, void *))(**(void **)(v2 + 2032) + 40))(*(void *)(v2 + 2032), v1 + 1);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    unsigned int v9 = 0;
    uint64_t v5 = v1[4];
    if (!v5) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 48))(v5, buf);
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  sub_10120DD84((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10120DD54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10120DD84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120DD84(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E8464((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_10120DDD4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *v1;
  if (*(unsigned char *)(*v1 + 1965))
  {
    (*(void (**)(void, void *))(**(void **)(v2 + 2032) + 48))(*(void *)(v2 + 2032), v1 + 1);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    *(void *)long long buf = 0;
    unsigned int v9 = 0;
    uint64_t v5 = v1[4];
    if (!v5) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 48))(v5, buf);
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  sub_10120DF04((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_10120DED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10120DF04(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120DF04(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E8754((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_10120DF54(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(unsigned char *)(*(void *)v1 + 1965))
  {
    int v3 = *(unsigned __int8 *)(v1 + 8);
    if (*(unsigned __int8 *)(v2 + 1994) == v3)
    {
      sub_100058DB0(buf, "");
      sub_10120C6B8(*(void *)(v1 + 40), 1);
      goto LABEL_16;
    }
    uint64_t v4 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "blocked. Stewie won't be allowed until process is restarted.";
      if (!v3) {
        uint64_t v5 = "unblocked";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Stewie is %s", buf, 0xCu);
      int v3 = *(unsigned __int8 *)(v1 + 8);
    }
    if (v3)
    {
      if (*(unsigned char *)(v2 + 1993))
      {
        *(_DWORD *)long long buf = 3;
        uint8_t buf[4] = 0;
        void buf[6] = 0;
        uint8_t buf[8] = 1;
        sub_1012030EC(v2, buf);
        sub_100058DB0(buf, "");
        sub_10120C6B8(*(void *)(v1 + 40), 1);
        goto LABEL_16;
      }
      *(unsigned char *)(v2 + 1994) = 1;
      uint64_t v6 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Presenting popup: device lost access to network", buf, 2u);
      }
      sub_1004B2FA8((Registry **)(v2 + 1928), @"BIFROST_DISABLED_BY_NETWORK_OVER_INTERNET_TITLE", @"BIFROST_DISABLED_BY_NETWORK_OVER_INTERNET_MESSAGE");
    }
    else
    {
      *(unsigned char *)(v2 + 1994) = 0;
    }
    sub_101201E5C(v2);
    sub_100058DB0(buf, "");
    sub_10120C6B8(*(void *)(v1 + 40), 1);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
    sub_100058DB0(buf, "Not ready to service request");
    sub_10120C6B8(*(void *)(v1 + 40), 0);
  }
LABEL_16:
  if (v12 < 0) {
    operator delete(*(void **)buf);
  }
  sub_10120E1FC(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_10120E1BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10120E1FC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10120E1FC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E7E54((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_10120E24C(uint64_t **a1)
{
  uint64_t v2 = a1;
  int v3 = *a1;
  sub_10120E2AC(v3);
  sub_10120FF38((uint64_t *)&v3);
  return sub_100046B58((uint64_t *)&v2);
}

void sub_10120E290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_10120E2AC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*(unsigned char *)(*a1 + 1965))
  {
    v113[0] = 0;
    v105[0] = a1 + 1;
    v105[1] = "service-info";
    sub_10000CB28((uint64_t)v105, v113);
    if (xpc_get_type((xpc_object_t)v113[0]) != (xpc_type_t)&_xpc_type_dictionary)
    {
LABEL_3:
      int v3 = 1;
      goto LABEL_146;
    }
    v105[0] = 0;
    v105[1] = 0;
    DWORD2(v106) = 0;
    *(void *)&long long v106 = 0;
    xpc_object_t v112 = 0;
    __p[0] = v113;
    __p[1] = "connectionStatus";
    sub_100048BAC((uint64_t)__p, &v112);
    if (xpc_get_type(v112) == (xpc_type_t)&_xpc_type_null)
    {
LABEL_54:
      xpc_release(v112);
      xpc_object_t v112 = 0;
      __p[0] = v113;
      __p[1] = "registrationStatus";
      sub_100048BAC((uint64_t)__p, &v112);
      if (xpc_get_type(v112) != (xpc_type_t)&_xpc_type_null)
      {
        if (xpc_get_type(v112) != (xpc_type_t)&_xpc_type_string)
        {
          sub_100058DB0(__p, "service-info: registrationStatus - invalid format, string expected");
          sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
          if ((SHIBYTE(v100) & 0x80000000) == 0) {
            goto LABEL_114;
          }
          char v19 = __p[0];
LABEL_93:
          operator delete(v19);
          goto LABEL_114;
        }
        long long v110 = 0uLL;
        uint64_t v111 = 0;
        xpc_object_t object = v112;
        if (v112) {
          xpc_retain(v112);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v100 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v100) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(object);
        int v20 = SHIBYTE(v111);
        if (v111 >= 0) {
          uint64_t v21 = HIBYTE(v111);
        }
        else {
          uint64_t v21 = *((void *)&v110 + 1);
        }
        switch(v21)
        {
          case 13:
            char v22 = (void *)v110;
            int v28 = &v110;
            if (v111 < 0) {
              int v28 = (long long *)v110;
            }
            uint64_t v29 = *(void *)v28;
            uint64_t v30 = *(void *)((char *)v28 + 5);
            if (v29 != 0x7369676552746F6ELL || v30 != 0x6465726574736967) {
              goto LABEL_89;
            }
            int v27 = 1;
            break;
          case 10:
            char v22 = (void *)v110;
            if (v111 >= 0) {
              uint64_t v32 = &v110;
            }
            else {
              uint64_t v32 = (long long *)v110;
            }
            if (memcmp(v32, "registered", 0xAuLL))
            {
LABEL_89:
              sub_100058DB0(__p, "service-info: registrationStatus - invalid value");
              sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
              if (SHIBYTE(v100) < 0) {
                operator delete(__p[0]);
              }
              if ((SHIBYTE(v111) & 0x80000000) == 0) {
                goto LABEL_114;
              }
              char v19 = (void *)v110;
              goto LABEL_93;
            }
            int v27 = 2;
            break;
          case 7:
            char v22 = (void *)v110;
            long long v23 = &v110;
            if (v111 < 0) {
              long long v23 = (long long *)v110;
            }
            int v24 = *(_DWORD *)v23;
            int v25 = *(_DWORD *)((char *)v23 + 3);
            if (v24 != 1852534389 || v25 != 1853321070) {
              goto LABEL_89;
            }
            int v27 = 0;
            break;
          default:
            goto LABEL_89;
        }
        HIDWORD(v105[0]) = v27;
        if (v20 < 0) {
          operator delete(v22);
        }
      }
      xpc_release(v112);
      *(void *)&long long v110 = 0;
      __p[0] = v113;
      __p[1] = "rssi";
      sub_100048BAC((uint64_t)__p, &v110);
      if (xpc_get_type((xpc_object_t)v110) != (xpc_type_t)&_xpc_type_null)
      {
        if (xpc_get_type((xpc_object_t)v110) != (xpc_type_t)&_xpc_type_int64)
        {
          sub_100058DB0(__p, "service-info: rssi - invalid format, integer expected");
          sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
          if (SHIBYTE(v100) < 0) {
            operator delete(__p[0]);
          }
LABEL_144:
          xpc_release((xpc_object_t)v110);
          goto LABEL_145;
        }
        __p[0] = (void *)v110;
        if ((void)v110) {
          xpc_retain((xpc_object_t)v110);
        }
        else {
          __p[0] = xpc_null_create();
        }
        int v34 = xpc::dyn_cast_or_default((xpc *)__p, 0, v33);
        if (!BYTE4(v105[1])) {
          BYTE4(v105[1]) = 1;
        }
        LODWORD(v105[1]) = v34;
        xpc_release(__p[0]);
      }
      xpc_release((xpc_object_t)v110);
      xpc_object_t v112 = 0;
      __p[0] = v113;
      __p[1] = "congestionStatus";
      sub_100048BAC((uint64_t)__p, &v112);
      if (xpc_get_type(v112) != (xpc_type_t)&_xpc_type_null)
      {
        if (xpc_get_type(v112) != (xpc_type_t)&_xpc_type_string)
        {
          sub_100058DB0(__p, "service-info: congestionStatus - invalid format, string expected");
          sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
          if ((SHIBYTE(v100) & 0x80000000) == 0) {
            goto LABEL_114;
          }
          uint64_t v35 = __p[0];
LABEL_113:
          operator delete(v35);
          goto LABEL_114;
        }
        long long v110 = 0uLL;
        uint64_t v111 = 0;
        xpc_object_t object = v112;
        if (v112) {
          xpc_retain(v112);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v100 = 0;
        xpc::dyn_cast_or_default();
        if (SHIBYTE(v100) < 0) {
          operator delete(__p[0]);
        }
        xpc_release(object);
        uint64_t v36 = HIBYTE(v111);
        if (v111 < 0) {
          uint64_t v36 = *((void *)&v110 + 1);
        }
        if (v36 != 7) {
          goto LABEL_129;
        }
        std::string::size_type v37 = &v110;
        if (v111 < 0) {
          std::string::size_type v37 = (long long *)v110;
        }
        int v38 = *(_DWORD *)v37;
        int v39 = *(_DWORD *)((char *)v37 + 3);
        if (v38 == 1852534389 && v39 == 1853321070)
        {
          int v41 = 0;
        }
        else
        {
LABEL_129:
          if (sub_1002E6B08((const void **)&v110, "none"))
          {
            int v41 = 1;
          }
          else if (sub_1002E6B08((const void **)&v110, "light"))
          {
            int v41 = 2;
          }
          else if (sub_1002E6B08((const void **)&v110, "moderate"))
          {
            int v41 = 3;
          }
          else
          {
            if (!sub_1002E6B08((const void **)&v110, "severe"))
            {
              sub_100058DB0(__p, "service-info: congestionStatus - invalid value");
              sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
              if (SHIBYTE(v100) < 0) {
                operator delete(__p[0]);
              }
              if ((SHIBYTE(v111) & 0x80000000) == 0) {
                goto LABEL_114;
              }
              uint64_t v35 = (void *)v110;
              goto LABEL_113;
            }
            int v41 = 4;
          }
        }
        LODWORD(v106) = v41;
        BYTE4(v106) = 1;
        if (SHIBYTE(v111) < 0) {
          operator delete((void *)v110);
        }
      }
      xpc_release(v112);
      *(void *)&long long v110 = 0;
      __p[0] = v113;
      __p[1] = "currentLLCTargetID";
      sub_100048BAC((uint64_t)__p, &v110);
      if (xpc_get_type((xpc_object_t)v110) != (xpc_type_t)&_xpc_type_null)
      {
        if (xpc_get_type((xpc_object_t)v110) != (xpc_type_t)&_xpc_type_int64)
        {
          sub_100058DB0(__p, "service-info: currentLLCTargetID - invalid format, integer expected");
          sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
          if (SHIBYTE(v100) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_144;
        }
        __p[0] = (void *)v110;
        if ((void)v110) {
          xpc_retain((xpc_object_t)v110);
        }
        else {
          __p[0] = xpc_null_create();
        }
        char v94 = xpc::dyn_cast_or_default((xpc *)__p, 0, v86);
        if (!BYTE9(v106)) {
          BYTE9(v106) = 1;
        }
        BYTE8(v106) = v94;
        xpc_release(__p[0]);
      }
      xpc_release((xpc_object_t)v110);
      sub_101206AE0(v2);
      goto LABEL_3;
    }
    if (xpc_get_type(v112) != (xpc_type_t)&_xpc_type_string)
    {
      sub_100058DB0(__p, "service-info: connectionStatus - invalid format, string expected");
      sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
      if (SHIBYTE(v100) < 0)
      {
        uint64_t v4 = __p[0];
LABEL_47:
        operator delete(v4);
      }
LABEL_114:
      xpc_release(v112);
LABEL_145:
      int v3 = 0;
LABEL_146:
      xpc_release((xpc_object_t)v113[0]);
      if (!v3) {
        return;
      }
      *(void *)&long long v110 = 0;
      v105[0] = a1 + 1;
      v105[1] = "gps-time-and-loc";
      sub_10000CB28((uint64_t)v105, &v110);
      if (xpc_get_type((xpc_object_t)v110) == (xpc_type_t)&_xpc_type_dictionary)
      {
        __p[0] = 0;
        v105[0] = &v110;
        v105[1] = "lat";
        sub_100048BAC((uint64_t)v105, __p);
        uint64_t v42 = 0;
        if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null
          && xpc_get_type(__p[0]) == (xpc_type_t)&_xpc_type_double)
        {
          v105[0] = __p[0];
          if (__p[0]) {
            xpc_retain(__p[0]);
          }
          else {
            v105[0] = xpc_null_create();
          }
          xpc::dyn_cast_or_default((xpc *)v105, v44, 0.0);
          uint64_t v42 = v45;
          xpc_release(v105[0]);
          int v43 = 1;
        }
        else
        {
          int v43 = 0;
        }
        xpc_release(__p[0]);
        __p[0] = 0;
        v105[0] = &v110;
        v105[1] = "lng";
        sub_100048BAC((uint64_t)v105, __p);
        uint64_t v46 = 0;
        if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null
          && xpc_get_type(__p[0]) == (xpc_type_t)&_xpc_type_double)
        {
          v105[0] = __p[0];
          if (__p[0]) {
            xpc_retain(__p[0]);
          }
          else {
            v105[0] = xpc_null_create();
          }
          xpc::dyn_cast_or_default((xpc *)v105, v48, 0.0);
          uint64_t v46 = v49;
          xpc_release(v105[0]);
          int v47 = 1;
        }
        else
        {
          int v47 = 0;
        }
        xpc_release(__p[0]);
        __p[0] = 0;
        v105[0] = &v110;
        v105[1] = "alt";
        sub_100048BAC((uint64_t)v105, __p);
        uint64_t v50 = 0;
        if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null
          && xpc_get_type(__p[0]) == (xpc_type_t)&_xpc_type_double)
        {
          v105[0] = __p[0];
          if (__p[0]) {
            xpc_retain(__p[0]);
          }
          else {
            v105[0] = xpc_null_create();
          }
          xpc::dyn_cast_or_default((xpc *)v105, v52, 0.0);
          uint64_t v50 = v53;
          xpc_release(v105[0]);
          int v51 = 1;
        }
        else
        {
          int v51 = 0;
        }
        xpc_release(__p[0]);
        __p[0] = 0;
        v105[0] = &v110;
        v105[1] = "timeNsec";
        sub_100048BAC((uint64_t)v105, __p);
        if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null && xpc_get_type(__p[0]) == (xpc_type_t)&_xpc_type_int64)
        {
          v105[0] = __p[0];
          if (__p[0]) {
            xpc_retain(__p[0]);
          }
          else {
            v105[0] = xpc_null_create();
          }
          uint64_t v56 = xpc::dyn_cast_or_default((xpc *)v105, 0, v57);
          xpc_release(v105[0]);
          unint64_t v55 = v56 & 0xFFFFFFFFFFFFFF00;
          int v54 = 1;
        }
        else
        {
          int v54 = 0;
          unint64_t v55 = 0;
          LOBYTE(v56) = 0;
        }
        xpc_release(__p[0]);
        if ((v43 & v47 & v51 & v54 & 1) == 0)
        {
          sub_100058DB0(v105, "gps-time-and-loc: invalid format");
          sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)v105, 0);
          if (SBYTE7(v106) < 0) {
            operator delete(v105[0]);
          }
          int v60 = 0;
LABEL_183:
          xpc_release((xpc_object_t)v110);
          if (!v60) {
            return;
          }
          xpc_object_t v108 = 0;
          v105[0] = a1 + 1;
          v105[1] = "message-status";
          sub_10000CB28((uint64_t)v105, &v108);
          if (xpc_get_type(v108) != (xpc_type_t)&_xpc_type_dictionary) {
            goto LABEL_185;
          }
          memset(v107, 0, 7);
          *(_OWORD *)unint64_t v105 = 0u;
          long long v106 = 0u;
          v113[0] = 0;
          __p[0] = &v108;
          __p[1] = "UUID";
          sub_100048BAC((uint64_t)__p, v113);
          if (xpc_get_type((xpc_object_t)v113[0]) != (xpc_type_t)&_xpc_type_null
            && xpc_get_type((xpc_object_t)v113[0]) == (xpc_type_t)&_xpc_type_string)
          {
            xpc_object_t v112 = (xpc_object_t)v113[0];
            if (v113[0]) {
              xpc_retain((xpc_object_t)v113[0]);
            }
            else {
              xpc_object_t v112 = xpc_null_create();
            }
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v100 = 0;
            xpc::dyn_cast_or_default();
            if (SHIBYTE(v100) < 0) {
              operator delete(__p[0]);
            }
            long long v65 = (void *)*((void *)&v110 + 1);
            __src = (void *)v110;
            v107[0] = v111;
            *(_DWORD *)((char *)v107 + 3) = *(_DWORD *)((char *)&v111 + 3);
            char v64 = HIBYTE(v111);
            long long v110 = 0uLL;
            uint64_t v111 = 0;
            xpc_release(v112);
            int v63 = 1;
          }
          else
          {
            int v63 = 0;
            char v64 = 0;
            long long v65 = 0;
            __src = 0;
          }
          xpc_release((xpc_object_t)v113[0]);
          v113[0] = 0;
          __p[0] = &v108;
          __p[1] = "status";
          char v97 = v64;
          sub_100048BAC((uint64_t)__p, v113);
          if (xpc_get_type((xpc_object_t)v113[0]) != (xpc_type_t)&_xpc_type_null
            && xpc_get_type((xpc_object_t)v113[0]) == (xpc_type_t)&_xpc_type_string)
          {
            xpc_object_t v112 = (xpc_object_t)v113[0];
            if (v113[0]) {
              xpc_retain((xpc_object_t)v113[0]);
            }
            else {
              xpc_object_t v112 = xpc_null_create();
            }
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v100 = 0;
            xpc::dyn_cast_or_default();
            if (SHIBYTE(v100) < 0) {
              operator delete(__p[0]);
            }
            *(_OWORD *)unint64_t v105 = v110;
            *(void *)&long long v106 = v111;
            long long v110 = 0uLL;
            uint64_t v111 = 0;
            BYTE8(v106) = 1;
            xpc_release(v112);
            int v70 = 1;
          }
          else
          {
            int v70 = 0;
          }
          xpc_release((xpc_object_t)v113[0]);
          *(void *)&long long v110 = 0;
          __p[0] = &v108;
          __p[1] = "sizeBytes";
          sub_100048BAC((uint64_t)__p, &v110);
          if (xpc_get_type((xpc_object_t)v110) != (xpc_type_t)&_xpc_type_null
            && xpc_get_type((xpc_object_t)v110) == (xpc_type_t)&_xpc_type_int64)
          {
            __p[0] = (void *)v110;
            if ((void)v110) {
              xpc_retain((xpc_object_t)v110);
            }
            else {
              __p[0] = xpc_null_create();
            }
            uint64_t v71 = xpc::dyn_cast_or_default((xpc *)__p, 0, v74);
            xpc_release(__p[0]);
            unint64_t v72 = v71 & 0xFFFFFFFFFFFFFF00;
            int v73 = 1;
          }
          else
          {
            LOBYTE(v71) = 0;
            unint64_t v72 = 0;
            int v73 = 0;
          }
          xpc_release((xpc_object_t)v110);
          if ((v70 & v73 & v63 & 1) == 0)
          {
            sub_100058DB0(__p, "progress: invalid format");
            sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
            if (SHIBYTE(v100) < 0) {
              operator delete(__p[0]);
            }
            if (SBYTE7(v106) < 0) {
              int v75 = v70;
            }
            else {
              int v75 = 0;
            }
            if (v75 == 1) {
              operator delete(v105[0]);
            }
            if (v97 < 0) {
              int v76 = v63;
            }
            else {
              int v76 = 0;
            }
            if (v76 == 1) {
              operator delete(__src);
            }
            int v61 = 0;
LABEL_186:
            xpc_release(v108);
            if (!v61) {
              return;
            }
            __p[0] = 0;
            v105[0] = a1 + 1;
            v105[1] = "conversation-committed";
            sub_100048BAC((uint64_t)v105, __p);
            if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null)
            {
              if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_int64) {
                goto LABEL_201;
              }
              v105[0] = __p[0];
              if (__p[0]) {
                xpc_retain(__p[0]);
              }
              else {
                v105[0] = xpc_null_create();
              }
              unint64_t v66 = xpc::dyn_cast_or_default((xpc *)v105, 0, v62);
              xpc_release(v105[0]);
              if (v66 >= 0x100)
              {
LABEL_201:
                sub_100058DB0(v105, "conversation-committed: invalid format");
                sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)v105, 0);
                if (SBYTE7(v106) < 0) {
                  operator delete(v105[0]);
                }
                int v67 = 0;
LABEL_206:
                xpc_release(__p[0]);
                if (!v67) {
                  return;
                }
                __p[0] = 0;
                v105[0] = a1 + 1;
                v105[1] = "stewie-tx-defer-time";
                sub_100048BAC((uint64_t)v105, __p);
                if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null)
                {
                  if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_int64)
                  {
                    sub_100058DB0(v105, "stewie-tx-defer-time: expected time ms, int64 value");
                    sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)v105, 0);
                    if (SBYTE7(v106) < 0) {
                      operator delete(v105[0]);
                    }
                    int v68 = 0;
LABEL_291:
                    xpc_release(__p[0]);
                    if (!v68) {
                      return;
                    }
                    __p[0] = 0;
                    v105[0] = a1 + 1;
                    v105[1] = "set-gps-time-adjustment";
                    sub_100048BAC((uint64_t)v105, __p);
                    if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_null)
                    {
                      if (xpc_get_type(__p[0]) != (xpc_type_t)&_xpc_type_int64)
                      {
                        uint64_t v88 = *(NSObject **)(v2 + 48);
                        if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(v105[0]) = 0;
                          _os_log_error_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "testStewieCommand::set-gps-time-adjustment - invalid format", (uint8_t *)v105, 2u);
                        }
                        sub_100058DB0(v105, "set-gps-time-adjustment: invalid format");
                        sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)v105, 0);
                        if (SBYTE7(v106) < 0) {
                          operator delete(v105[0]);
                        }
                        int v89 = 0;
                        goto LABEL_304;
                      }
                      v105[0] = __p[0];
                      if (__p[0]) {
                        xpc_retain(__p[0]);
                      }
                      else {
                        v105[0] = xpc_null_create();
                      }
                      uint64_t v91 = xpc::dyn_cast_or_default((xpc *)v105, 0, v90);
                      xpc_release(v105[0]);
                      (*(void (**)(void, uint64_t))(**(void **)(v2 + 2232) + 208))(*(void *)(v2 + 2232), v91);
                    }
                    int v89 = 1;
LABEL_304:
                    xpc_release(__p[0]);
                    if (v89)
                    {
                      __p[0] = 0;
                      v105[0] = a1 + 1;
                      v105[1] = "sat-msg-provisioning";
                      sub_10000CB28((uint64_t)v105, __p);
                      xpc_type_t type = xpc_get_type(__p[0]);
                      if (type == (xpc_type_t)&_xpc_type_dictionary) {
                        (*(void (**)(void, void **, uint64_t *))(**(void **)(v2 + 2248) + 144))(*(void *)(v2 + 2248), __p, a1 + 2);
                      }
                      xpc_release(__p[0]);
                      if (type != (xpc_type_t)&_xpc_type_dictionary)
                      {
                        uint64_t v93 = *(void *)(v2 + 2032);
                        sub_100117418(&v98, (void **)a1 + 1);
                        (*(void (**)(uint64_t, xpc_object_t *, uint64_t *))(*(void *)v93 + 224))(v93, &v98, a1 + 2);
                        xpc_release(v98);
                      }
                    }
                    return;
                  }
                  v105[0] = __p[0];
                  if (__p[0]) {
                    xpc_retain(__p[0]);
                  }
                  else {
                    v105[0] = xpc_null_create();
                  }
                  uint64_t v87 = (void *)xpc::dyn_cast_or_default((xpc *)v105, 0, v69);
                  xpc_release(v105[0]);
                  v105[0] = v87;
                  sub_101206A28(v2);
                }
                int v68 = 1;
                goto LABEL_291;
              }
              sub_10120755C(v2);
            }
            int v67 = 1;
            goto LABEL_206;
          }
          CFStringRef uuidStr = 0;
          if (v97 < 0)
          {
            sub_10004FC84(__dst, __src, (unint64_t)v65);
            if (SHIBYTE(v103) < 0)
            {
              sub_10004FC84(&v110, __dst[0], (unint64_t)__dst[1]);
              goto LABEL_252;
            }
          }
          else
          {
            __dst[0] = __src;
            __dst[1] = v65;
            LODWORD(v103) = v107[0];
            *(_DWORD *)((char *)&v103 + 3) = *(_DWORD *)((char *)v107 + 3);
            HIBYTE(v103) = v97;
          }
          long long v110 = *(_OWORD *)__dst;
          uint64_t v111 = v103;
LABEL_252:
          xpc_object_t object = 0;
          if (SHIBYTE(v111) < 0)
          {
            sub_10004FC84(__p, (void *)v110, *((unint64_t *)&v110 + 1));
          }
          else
          {
            *(_OWORD *)long long __p = v110;
            uint64_t v100 = v111;
          }
          xpc_object_t v112 = 0;
          if (ctu::cf::convert_copy())
          {
            xpc_object_t v77 = object;
            xpc_object_t object = v112;
            v113[0] = v77;
            sub_1000558F4(v113);
          }
          if (SHIBYTE(v100) < 0) {
            operator delete(__p[0]);
          }
          CFStringRef uuidStr = (CFStringRef)object;
          xpc_object_t object = 0;
          sub_1000558F4((const void **)&object);
          if (SHIBYTE(v111) < 0) {
            operator delete((void *)v110);
          }
          if (SHIBYTE(v103) < 0) {
            operator delete(__dst[0]);
          }
          *(void *)&long long v110 = 0;
          CFUUIDRef v78 = CFUUIDCreateFromString(0, uuidStr);
          *(void *)&long long v110 = v78;
          xpc_object_t v79 = (xpc_object_t)BYTE7(v106);
          int v80 = SBYTE7(v106);
          if (SBYTE7(v106) < 0) {
            xpc_object_t v79 = v105[1];
          }
          if (v79 == (xpc_object_t)7)
          {
            if ((SBYTE7(v106) & 0x80u) == 0) {
              xpc_object_t v81 = (unsigned int *)v105;
            }
            else {
              xpc_object_t v81 = (unsigned int *)v105[0];
            }
            unsigned int v82 = 1936027236;
            unsigned int v83 = bswap32(*v81);
            if (v83 == 1936027236
              && (unsigned int v82 = 1684631143, v83 = bswap32(*(unsigned int *)((char *)v81 + 3)), v83 == 1684631143))
            {
              int v84 = 0;
            }
            else if (v83 < v82)
            {
              int v84 = -1;
            }
            else
            {
              int v84 = 1;
            }
            if (v84) {
              int v85 = 2;
            }
            else {
              int v85 = 1;
            }
          }
          else
          {
            int v85 = 2;
          }
          __p[0] = v78;
          if (v78) {
            CFRetain(v78);
          }
          LODWORD(__p[1]) = 3;
          BYTE4(__p[1]) = 1;
          LODWORD(v100) = v85;
          unint64_t v101 = v72 | v71;
          sub_101207708(v2);
          sub_10012577C((const void **)__p);
          sub_10012577C((const void **)&v110);
          sub_1000558F4((const void **)&uuidStr);
          if (v80 < 0) {
            operator delete(v105[0]);
          }
          if (v97 < 0) {
            operator delete(__src);
          }
LABEL_185:
          int v61 = 1;
          goto LABEL_186;
        }
        long long v58 = (std::__shared_weak_count *)operator new(0x88uLL);
        v58->__shared_owners_ = 0;
        v58->__shared_weak_owners_ = 0;
        v58->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC378;
        v58[1].std::__shared_count = 0u;
        *(_OWORD *)&v58[2].__shared_owners_ = 0u;
        *(_OWORD *)&v58[1].__shared_weak_owners_ = 0u;
        v58[3].std::__shared_count = 0u;
        *(_OWORD *)&v58[3].__shared_weak_owners_ = 0u;
        *(_OWORD *)&v58[4].__shared_owners_ = 0u;
        v58[5].std::__shared_count = 0u;
        v58[2].__shared_owners_ = v56 | v55;
        uint64_t v59 = (std::__shared_weak_count *)operator new(0x70uLL);
        v59->__shared_weak_owners_ = 0;
        v59->__shared_owners_ = 0;
        v59->__vftable = (std::__shared_weak_count_vtbl *)off_101A459C8;
        *(_OWORD *)&v59[1].__shared_weak_owners_ = 0u;
        *(_OWORD *)&v59[2].__shared_owners_ = 0u;
        v59[3].std::__shared_count = 0u;
        *(_OWORD *)&v59[3].__shared_weak_owners_ = 0u;
        v59[1].std::__shared_count = 0u;
        v59[4].__shared_owners_ = 0;
        v59[1].__shared_owners_ = v46;
        v59[1].__shared_weak_owners_ = v42;
        v59[2].__shared_owners_ = v50;
        v105[0] = &v58[1];
        v105[1] = v58;
        atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
        __p[0] = &v59[1];
        __p[1] = v59;
        atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_101206948(v2);
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
        if (v105[1]) {
          sub_10004D2C8((std::__shared_weak_count *)v105[1]);
        }
        sub_10004D2C8(v59);
        sub_10004D2C8(v58);
      }
      int v60 = 1;
      goto LABEL_183;
    }
    long long v110 = 0uLL;
    uint64_t v111 = 0;
    xpc_object_t object = v112;
    if (v112) {
      xpc_retain(v112);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v100 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v100) < 0) {
      operator delete(__p[0]);
    }
    xpc_release(object);
    int v5 = SHIBYTE(v111);
    if (v111 >= 0) {
      uint64_t v6 = HIBYTE(v111);
    }
    else {
      uint64_t v6 = *((void *)&v110 + 1);
    }
    switch(v6)
    {
      case 6:
        uint64_t v7 = (void *)v110;
        unsigned int v14 = &v110;
        if (v111 < 0) {
          unsigned int v14 = (long long *)v110;
        }
        int v15 = *(_DWORD *)v14;
        int v16 = *((unsigned __int16 *)v14 + 2);
        if (v15 != 1668184435 || v16 != 25701) {
          goto LABEL_43;
        }
        int v13 = 2;
        break;
      case 9:
        uint64_t v7 = (void *)v110;
        if (v111 >= 0) {
          char v18 = &v110;
        }
        else {
          char v18 = (long long *)v110;
        }
        if (memcmp(v18, "connected", 9uLL)) {
          goto LABEL_43;
        }
        int v13 = 3;
        break;
      case 7:
        uint64_t v7 = (void *)v110;
        uint64_t v8 = &v110;
        if (v111 < 0) {
          uint64_t v8 = (long long *)v110;
        }
        if (*(_DWORD *)v8 == 1852534389 && *(_DWORD *)((char *)v8 + 3) == 1853321070)
        {
          LODWORD(v105[0]) = 0;
          goto LABEL_52;
        }
        int v10 = *(_DWORD *)v8;
        int v11 = *(_DWORD *)((char *)v8 + 3);
        if (v10 != 1668184435 || v11 != 1735289187) {
          goto LABEL_43;
        }
        int v13 = 1;
        break;
      default:
LABEL_43:
        sub_100058DB0(__p, "service-info: connectionStatus - invalid value");
        sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)__p, 0);
        if (SHIBYTE(v100) < 0) {
          operator delete(__p[0]);
        }
        if ((SHIBYTE(v111) & 0x80000000) == 0) {
          goto LABEL_114;
        }
        uint64_t v4 = (void *)v110;
        goto LABEL_47;
    }
    LODWORD(v105[0]) = v13;
LABEL_52:
    if (v5 < 0) {
      operator delete(v7);
    }
    goto LABEL_54;
  }
  unint64_t v95 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v105[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "Not ready. Pending start", (uint8_t *)v105, 2u);
  }
  sub_100058DB0(v105, "StewieInterface is down");
  sub_100C04F1C((uint64_t)(a1 + 2), (uint64_t)v105, 0);
  if (SBYTE7(v106) < 0) {
    operator delete(v105[0]);
  }
}

void sub_10120F85C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, int a11, int a12, xpc_object_t a13, xpc_object_t object, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,xpc_object_t a37,xpc_object_t a38,xpc_object_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10120FF38(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1001E917C((void *)(v1 + 16));
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

void sub_10120FF98(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 2232) + 88))(*(void *)(**(void **)a1 + 2232));
  operator delete();
}

void sub_101210010()
{
}

void sub_10121003C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  sub_101202394(v1, 1);
  sub_101202670(v1);
  (*(void (**)(void))(**(void **)(v1 + 2232) + 96))(*(void *)(v1 + 2232));
  if (*(unsigned char *)(v1 + 1965))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (!v2
      || (uint64_t v3 = *(void *)(v1 + 2216), v4 = *(void *)(v1 + 16), (v5 = std::__shared_weak_count::lock(v2)) == 0))
    {
      sub_100088B9C();
    }
    uint64_t v6 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v5);
    uint64_t v7 = operator new(0x20uLL);
    *uint64_t v7 = off_101AA0A08;
    v7[1] = v1;
    void v7[2] = v4;
    void v7[3] = v6;
    int v10 = v7;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v3 + 128))(v3, buf);
    sub_1012105E0(buf);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
  operator delete();
}

void sub_1012101E0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1012105E0((uint64_t *)va);
  operator delete();
}

void *sub_10121022C(void *a1)
{
  *a1 = off_101AA0A08;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_101210278(void *a1)
{
  *a1 = off_101AA0A08;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1012102E4(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101AA0A08;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_101210348(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA0A08;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101210388(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101210398(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1012103D8(uint64_t a1, void *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 16);
      if (v6)
      {
        *a2 = 0;
        v7[0] = 0;
        v7[1] = 0;
        sub_10003E168(v7, (void *)(v6 + 16));
        operator new();
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_101210508(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101210548()
{
}

uint64_t *sub_101210554(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  int v5 = v1;
  uint64_t v2 = *v1;
  (***(void (****)(void, uint64_t))(v2 + 2352))(*(void *)(v2 + 2352), (uint64_t)(v1 + 1));
  sub_101205B78(v2);
  sub_10005F900((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1012105C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1012105E0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_101210664(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  int v3 = *((unsigned __int8 *)*a1 + 8);
  if (*(unsigned char *)(v2 + 2737)) {
    BOOL v4 = *(unsigned __int8 *)(v2 + 2736) == v3;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    *(_WORD *)(v2 + 2736) = v3 | 0x100;
    int v5 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I satMsg Provisioning Changed", buf, 2u);
    }
    (*(void (**)(void, void))(**(void **)(v2 + 2232) + 216))(*(void *)(v2 + 2232), *((unsigned __int8 *)v1 + 8));
  }
  operator delete();
}

void sub_101210744()
{
}

uint64_t sub_101210770(uint64_t a1, uint64_t a2)
{
  int v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    int v3 = (void *)(a1 + 24);
  }
  *int v3 = 0;
  return a1;
}

uint64_t *sub_1012107F0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void (****)(void, void *))(*(void *)v1 + 2216);
  sub_101210918((uint64_t)v6, v1 + 8);
  (**v2)(v2, v6);
  sub_100A6AF14(v6);
  sub_1012108C8(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10121089C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_100A6AF14((uint64_t *)va2);
  sub_1012108C8((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1012108C8(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100A6AF14((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_101210918(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_1012109B0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  (*(void (**)(void, void, uint64_t, void))(**(void **)(*(void *)v1 + 2216) + 8))(*(void *)(*(void *)v1 + 2216), *(unsigned __int8 *)(v1 + 8), v1 + 16, *(void *)(v1 + 40));
  sub_101210A40(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_101210A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_101210A40(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 40));
    uint64_t v2 = (void **)(v1 + 16);
    sub_100A6AABC(&v2);
    operator delete();
  }
  return result;
}

void sub_101210AA8(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 2216) + 16))(*(void *)(**(void **)a1 + 2216));
  operator delete();
}

void sub_101210B20()
{
}

uint64_t sub_101210B4C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t *sub_101210BCC(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void (****)(void, void *))(*v1 + 2248);
  uint64_t v3 = v1[4];
  if (v3)
  {
    if ((void *)v3 == v1 + 1)
    {
      uint64_t v8 = v7;
      (*(void (**)(uint64_t, void *))(*(void *)v3 + 24))(v3, v7);
      goto LABEL_6;
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  uint64_t v8 = (void *)v3;
LABEL_6:
  (**v2)(v2, v7);
  sub_100A6B2C4(v7);
  sub_101210D0C((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_101210CE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_101210D0C((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_101210D0C(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100A6B2C4((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_101210D5C(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = (const void **)v1;
  (*(void (**)(void, void, void, void))(**(void **)(*(void *)v1 + 2248) + 8))(*(void *)(*(void *)v1 + 2248), *(void *)(v1 + 8), *(void *)(v1 + 16), *(void *)(v1 + 24));
  sub_101210DE4(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_101210DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10)
{
}

const void ***sub_101210DE4(const void ***result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1000558F4(v1 + 3);
    sub_10012577C(v1 + 2);
    sub_100127D74(v1 + 1);
    operator delete();
  }
  return result;
}

void sub_101210E44(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void))(**(void **)(**(void **)a1 + 2248) + 16))(*(void *)(**(void **)a1 + 2248), *(unsigned __int8 *)(*(void *)a1 + 8));
  operator delete();
}

void sub_101210EC0()
{
}

void sub_101210EEC(uint64_t **a1)
{
  uint64_t v1 = (unsigned __int16 *)*a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(uint64_t *)((char *)*a1 + 22);
  *(_OWORD *)(v2 + 2320) = *(_OWORD *)(*a1 + 1);
  *(void *)(v2 + 2334) = v3;
  StewieFeatureState::StewieFeatureState((StewieFeatureState *)buf, v1[4], v1[10], v1[5]);
  if (operator!=())
  {
    *(_DWORD *)(v2 + 128) = *(_DWORD *)buf;
    *(_WORD *)(v2 + 132) = v9;
    uint64_t v4 = *(void *)(v2 + 120);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v2 + 128);
    }
  }
  if (*(unsigned char *)(v2 + 1965))
  {
    uint64_t v5 = *(void *)(v2 + 2032);
    uint64_t v6 = sub_101203094(v2);
    (*(void (**)(uint64_t, unsigned __int16 *, uint64_t))(*(void *)v5 + 80))(v5, v1 + 4, v6);
    sub_101204164(v2);
    sub_101203F9C(v2);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Not ready. Pending start", buf, 2u);
    }
  }
  operator delete();
}

void sub_101211054()
{
}

void sub_101211084()
{
}

void *sub_101211098(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_101AA0A98;
  result[1] = v3;
  return result;
}

uint64_t sub_1012110E0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101AA0A98;
  a2[1] = v2;
  return result;
}

void sub_10121110C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 2664);
  *(void *)(v1 + 2656) = 0;
  *(void *)(v1 + 2664) = 0;
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_101202394(v1, 0);
}

uint64_t sub_101211158(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_101211198()
{
}

void *sub_1012111A4(void *a1)
{
  *a1 = off_101AA0B18;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1012111F0(void *a1)
{
  *a1 = off_101AA0B18;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10121125C(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101AA0B18;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1012112C0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101AA0B18;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_101211300(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_101211310(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const void **sub_101211350(void *a1, __int16 *a2)
{
  __int16 v3 = *a2;
  uint64_t v4 = (const void *)*((void *)a2 + 1);
  uint64_t v5 = *((void *)a2 + 2);
  unsigned int v14 = v4;
  uint64_t v15 = v5;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  uint64_t v6 = (std::__shared_weak_count *)*((void *)a2 + 3);
  uint64_t v7 = *((void *)a2 + 4);
  int v16 = v6;
  uint64_t v17 = v7;
  uint64_t v8 = (std::__shared_weak_count *)*((void *)a2 + 5);
  char v18 = v8;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 3) = 0;
  __int16 v9 = (std::__shared_weak_count *)a1[3];
  if (v9)
  {
    uint64_t v10 = a1[1];
    int v11 = std::__shared_weak_count::lock(v9);
    if (v11)
    {
      uint64_t v12 = a1[2];
      if (v12)
      {
        uint64_t v19 = v10;
        __int16 v20 = v3;
        unsigned int v14 = 0;
        uint64_t v21 = v4;
        uint64_t v22 = v5;
        uint64_t v15 = 0;
        int v16 = 0;
        long long v23 = v6;
        uint64_t v24 = v7;
        int v25 = v8;
        v26[0] = 0;
        uint64_t v17 = 0;
        char v18 = 0;
        v26[1] = 0;
        sub_10003E168(v26, (void *)(v12 + 16));
        operator new();
      }
      sub_10004D2C8(v11);
    }
  }
  if (v8)
  {
    sub_10004D2C8(v8);
    uint64_t v6 = v16;
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return sub_1000558F4(&v14);
}

uint64_t sub_10121152C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10121156C()
{
}

uint64_t *sub_101211578(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v38 = a1;
  uint64_t v39 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v4 = *(void *)(v1 + 24);
  uint64_t v3 = *(void *)(v1 + 32);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(v2 + 2536) = v4;
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 2544);
  *(void *)(v2 + 2544) = v3;
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1012020A0(v2);
  uint64_t v6 = *(void *)(v2 + 2552);
  uint64_t v7 = *(void *)(v1 + 40);
  if (v6 != v7)
  {
    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      char v9 = sub_1012AD3D4(*(void *)(v2 + 2552), *(void *)(v1 + 40));
      if (*(unsigned __int16 *)(v6 + 32) == *(unsigned __int16 *)(v7 + 32)) {
        char v10 = v9;
      }
      else {
        char v10 = 0;
      }
      if (v10) {
        goto LABEL_20;
      }
      uint64_t v7 = *(void *)(v1 + 40);
    }
    uint64_t v11 = *(void *)(v1 + 48);
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v2 + 2552) = v7;
    uint64_t v12 = *(std::__shared_weak_count **)(v2 + 2560);
    *(void *)(v2 + 2560) = v11;
    if (v12) {
      sub_10004D2C8(v12);
    }
    sub_101202200(v2);
  }
LABEL_20:
  int v41 = 0;
  uint64_t v42 = 0;
  int v40 = &v41;
  if (*(void *)(v1 + 16)) {
    int v13 = sub_1000810B8;
  }
  else {
    int v13 = 0;
  }
  if (v13)
  {
    memset(&__p, 0, sizeof(__p));
    memset(&theArray, 0, sizeof(theArray));
    ctu::cf::assign();
    std::string __p = theArray;
    if (SHIBYTE(theArray.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
      if (!__p.__r_.__value_.__l.__size_)
      {
LABEL_33:
        operator delete(__p.__r_.__value_.__l.__data_);
        goto LABEL_34;
      }
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    else
    {
      std::string::size_type size = HIBYTE(theArray.__r_.__value_.__r.__words[2]);
      if (!*((unsigned char *)&theArray.__r_.__value_.__s + 23))
      {
LABEL_34:
        int v13 = v42;
        goto LABEL_35;
      }
      p_p = &__p;
    }
    int v16 = (std::string *)((char *)p_p + size);
    while (p_p != v16)
    {
      p_p->__r_.__value_.__s.__data_[0] = __toupper(p_p->__r_.__value_.__s.__data_[0]);
      p_p = (std::string *)((char *)p_p + 1);
    }
    sub_1000EA6A0((uint64_t **)&v40, (void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
LABEL_35:
  uint64_t v17 = (uint64_t **)(v2 + 2568);
  if (v13 == *(uint64_t (**)(uint64_t))(v2 + 2584))
  {
    char v18 = (uint64_t *)v40;
    if (v40 == &v41) {
      goto LABEL_64;
    }
    uint64_t v19 = *v17;
    while ((sub_1000609C0((uint64_t)&theArray, (unsigned __int8 *)v18 + 32, (unsigned __int8 *)v19 + 32) & 1) != 0)
    {
      __int16 v20 = (uint64_t *)v18[1];
      uint64_t v21 = v18;
      if (v20)
      {
        do
        {
          char v18 = v20;
          __int16 v20 = (uint64_t *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          char v18 = (uint64_t *)v21[2];
          BOOL v8 = *v18 == (void)v21;
          uint64_t v21 = v18;
        }
        while (!v8);
      }
      uint64_t v22 = (uint64_t *)v19[1];
      if (v22)
      {
        do
        {
          long long v23 = v22;
          uint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          long long v23 = (uint64_t *)v19[2];
          BOOL v8 = *v23 == (void)v19;
          uint64_t v19 = v23;
        }
        while (!v8);
      }
      uint64_t v19 = v23;
      if (v18 == (uint64_t *)&v41) {
        goto LABEL_64;
      }
    }
  }
  if (v17 != (uint64_t **)&v40) {
    sub_1000EA390((uint64_t **)(v2 + 2568), v40, &v41);
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  theArray.__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
  int v25 = (uint64_t *)v40;
  if (v40 != &v41)
  {
    do
    {
      uint64_t v26 = (const char *)(v25 + 4);
      __p.__r_.__value_.__r.__words[0] = 0;
      if (*((char *)v25 + 55) < 0) {
        uint64_t v26 = *(const char **)v26;
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)CFStringCreateWithCString(kCFAllocatorDefault, v26, 0x8000100u);
      CFArrayAppendValue((CFMutableArrayRef)theArray.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&__p.__r_.__value_.__l.__data_);
      int v27 = (char *)v25[1];
      if (v27)
      {
        do
        {
          int v28 = (char **)v27;
          int v27 = *(char **)v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          int v28 = (char **)v25[2];
          BOOL v8 = *v28 == (char *)v25;
          int v25 = (uint64_t *)v28;
        }
        while (!v8);
      }
      int v25 = (uint64_t *)v28;
    }
    while (v28 != &v41);
    CFMutableArrayRef Mutable = (CFMutableArrayRef)theArray.__r_.__value_.__r.__words[0];
  }
  (***(void (****)(void, CFMutableArrayRef))(v2 + 2616))(*(void *)(v2 + 2616), Mutable);
  sub_1012022AC(v2);
  sub_1000440D4((const void **)&theArray.__r_.__value_.__l.__data_);
LABEL_64:
  std::string::size_type v29 = *(unsigned __int16 *)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  if (*(unsigned char *)(v2 + 2625) || *(void *)(v2 + 2632))
  {
    uint64_t v30 = (_WORD *)(v2 + 2528);
    if (!*(unsigned char *)(v2 + 2530) || (unsigned __int16)*v30 != v29)
    {
      *(_WORD *)(v2 + 2528) = v29;
      *(unsigned char *)(v2 + 2530) = 1;
      CFNumberRef v44 = 0;
      theArray.__r_.__value_.__r.__words[0] = v29;
      CFNumberRef v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &theArray);
      if (v31)
      {
        std::string::size_type v32 = (std::string::size_type)v44;
        CFNumberRef v44 = v31;
        theArray.__r_.__value_.__r.__words[0] = v32;
        sub_1000570E8((const void **)&theArray.__r_.__value_.__l.__data_);
        (***(void (****)(void))(v2 + 2600))();
      }
      unint64_t v33 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        if (!*(unsigned char *)(v2 + 2530)) {
          sub_10016C840();
        }
        sub_100BC897C((unsigned __int16)*v30, &theArray);
        if ((theArray.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_std::string theArray = &theArray;
        }
        else {
          p_std::string theArray = (std::string *)theArray.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_theArray;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I [Bystander location based] Supported services: %{public}s", (uint8_t *)&__p, 0xCu);
        if (SHIBYTE(theArray.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(theArray.__r_.__value_.__l.__data_);
        }
      }
      if (*(unsigned char *)(v2 + 2530)) {
        uint64_t v35 = (unsigned __int16 *)(v2 + 2528);
      }
      else {
        uint64_t v35 = (unsigned __int16 *)(v2 + 2432);
      }
      if (*((unsigned char *)v35 + 2)) {
        uint64_t v36 = *v35;
      }
      else {
        uint64_t v36 = 0;
      }
      (*(void (**)(void, uint64_t))(**(void **)(v2 + 2232) + 160))(*(void *)(v2 + 2232), v36);
      if (*(unsigned char *)(v2 + 2530) && *v30) {
        sub_101203378(v2);
      }
      sub_101201E5C(v2);
      sub_1000570E8((const void **)&v44);
    }
  }
  sub_10005CD2C((uint64_t)&v40, v41);
  sub_101211B50(&v39);
  return sub_100046B58((uint64_t *)&v38);
}

void sub_101211AB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(a19);
  }
  sub_10005CD2C((uint64_t)&a12, a13);
  sub_101211B50(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_101211B50(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 32);
    if (v3) {
      sub_10004D2C8(v3);
    }
    sub_1000558F4((const void **)(v1 + 16));
    operator delete();
  }
  return result;
}

void *sub_101211BB8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_101211C3C(void *a1)
{
  *a1 = off_101AA0BA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_1003891A4(a1 + 2);
  return a1;
}

void sub_101211C90(void *a1)
{
  *a1 = off_101AA0BA8;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_1003891A4(a1 + 2);

  operator delete();
}

void *sub_101211D04(void *a1)
{
  uint64_t v2 = operator new(0x40uLL);
  uint64_t v3 = a1[1];
  *uint64_t v2 = off_101AA0BA8;
  v2[1] = v3;
  sub_1005CE9E0((uint64_t)(v2 + 2), (uint64_t)(a1 + 2));
  uint64_t v4 = a1[7];
  v2[6] = a1[6];
  v2[7] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return v2;
}

void sub_101211D74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_101211D88(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  *a2 = off_101AA0BA8;
  a2[1] = v4;
  uint64_t result = sub_1005CE9E0((uint64_t)(a2 + 2), (uint64_t)(a1 + 2));
  uint64_t v6 = a1[7];
  a2[6] = a1[6];
  a2[7] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_101211DF0(uint64_t a1)
{
  return sub_1012120A4(a1 + 8);
}

void sub_101211DF8(void *a1)
{
  sub_1012120A4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_101211E34(void *a1, uint64_t *a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6 && a1[6])
    {
      uint64_t v8 = *a2;
      uint64_t v7 = a2[1];
      v10[4] = v5;
      v10[5] = v8;
      void v10[6] = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      sub_1005CE9E0((uint64_t)&v11, (uint64_t)(a1 + 2));
      v10[0] = 0;
      v10[1] = 0;
      sub_10003E168(v10, (void *)(v5 + 16));
      operator new();
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v9 = a1[5];
  if (!v9) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, a2);
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_101212018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101212058(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101212098()
{
}

void *sub_1012120A4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  return sub_1003891A4((void *)(a1 + 8));
}

uint64_t *sub_1012120E4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *v1;
  uint64_t v4 = v1 + 1;
  uint64_t v3 = v1[1];
  if (v3)
  {
    (*(void (**)(void, void))(**(void **)(v2 + 2232) + 160))(*(void *)(v2 + 2232), *(unsigned __int16 *)(v3 + 160));
    long long v5 = *(_OWORD *)(*v4 + 168);
    *(_OWORD *)(v2 + 2704) = *(_OWORD *)(*v4 + 184);
    *(_OWORD *)(v2 + 2688) = v5;
  }
  uint64_t v6 = v1[6];
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v6 + 48))(v6, v1 + 1);
  (*(void (**)(void, void *))(**(void **)(v2 + 2032) + 104))(*(void *)(v2 + 2032), v1 + 1);
  sub_1005CED14((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1012121DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1012121F8@<X0>(std::string **a1@<X0>, void *a2@<X8>)
{
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  sub_10004DE24((uint64_t)v5);
  sub_10121236C(v5, a1);
  sub_10004BC98((uint64_t)v5 + 8, a2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_101212358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10121236C(void *a1, std::string **a2)
{
  uint64_t v3 = sub_10004B96C(a1, (uint64_t)"{", 1);
  sub_100062B40(*a2, a2[1], ", ", 2uLL, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v6 = sub_10004B96C(v3, (uint64_t)p_p, size);
  long long v7 = sub_10004B96C(v6, (uint64_t)"}", 1);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v7;
}

void sub_10121240C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101212428(uint64_t a1, uint64_t *a2)
{
  sub_101212498(a2, &__p);
  ctu::operator<<();
  if (v5 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_10121247C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_101212498@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long v13 = 0u;
  memset(v12, 0, sizeof(v12));
  sub_10004DE24((uint64_t)v12);
  sub_10004B96C(v12, (uint64_t)"{", 1);
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  if (*a1 != v5)
  {
    do
    {
      sub_1000292E0((uint64_t)__p);
      if ((v11 & 0x80u) == 0) {
        uint64_t v6 = __p;
      }
      else {
        uint64_t v6 = (void **)__p[0];
      }
      if ((v11 & 0x80u) == 0) {
        uint64_t v7 = v11;
      }
      else {
        uint64_t v7 = (uint64_t)__p[1];
      }
      long long v8 = sub_10004B96C(v12, (uint64_t)v6, v7);
      sub_10004B96C(v8, (uint64_t)", ", 2);
      if ((char)v11 < 0) {
        operator delete(__p[0]);
      }
      v4 += 8;
    }
    while (v4 != v5);
  }
  sub_10004B96C(v12, (uint64_t)"}", 1);
  sub_10004BC98((uint64_t)v12 + 8, a2);
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_101212690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void sub_1012126C0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_10121274C(uint64_t a1, int a2, __int16 a3, uint64_t a4)
{
  int v10 = a2;
  __int16 v9 = a3;
  uint64_t v5 = *(void ***)(a1 + 8);
  uint64_t v6 = operator new(0x20uLL);
  void *v6 = off_101AA0D68;
  v6[1] = a4;
  _DWORD v6[2] = &v10;
  void v6[3] = &v9;
  v11[3] = v6;
  sub_100043ED0((uint64_t)v11, *v5);
  return sub_100043E48(v11);
}

void sub_101212804(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_101212820(CTXPCEnhancedLQMNotificationInterface *this)
{
  *(void *)this = off_101AA0CB0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCEnhancedLQMNotificationInterface::~CTXPCEnhancedLQMNotificationInterface(this);
}

void sub_10121287C(CTXPCEnhancedLQMNotificationInterface *this)
{
  *(void *)this = off_101AA0CB0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCEnhancedLQMNotificationInterface::~CTXPCEnhancedLQMNotificationInterface(this);

  operator delete();
}

void sub_1012128EC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101212954(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101212990(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1012129C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1012129F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_101212A40()
{
}

__n128 sub_101212A54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101AA0D68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_101212AA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101AA0D68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_101212AE0(uint64_t a1, id *a2)
{
  id v7 = *a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v4 = *(unsigned int **)(a1 + 16);
  uint64_t v5 = *v3;
  *uint64_t v3 = 0;
  uint64_t v6 = +[CTXPCPlaceholder simSlot:*v4];
  [v7 taggedInfoIndicationChanged:v6 type:**(unsigned __int16 **)(a1 + 24) payload:v5];
}

void sub_101212B74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_101212B98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_101212BD8()
{
}

void *sub_101212BEC(void *a1, void *a2)
{
  sub_100058DB0(__p, "commCenterSwitchState");
  AnalyticsEvent::AnalyticsEvent(a1, (long long *)__p, a2);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = &off_101AA0EF8;
  return a1;
}

void sub_101212C68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_101212C88(void **a1)
{
  AnalyticsEvent::~AnalyticsEvent(a1);

  operator delete();
}

void sub_101212CC0(uint64_t a1, uint64_t a2)
{
  if (!a2 || a2 == 3) {
    return;
  }
  unsigned int v4 = analytics::simSlotAsSubsId();
  xpc_object_t v22 = xpc_int64_create(v4);
  if (!v22) {
    xpc_object_t v22 = xpc_null_create();
  }
  uint64_t v5 = a1 + 32;
  __p[0] = (void *)(a1 + 32);
  __p[1] = "subs_id";
  sub_100035E70((uint64_t)__p, &v22, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v22);
  xpc_object_t v22 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 40));
  id v7 = ServiceMap;
  if (v8 < 0)
  {
    __int16 v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v8;
  long long v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (!v12)
  {
    uint64_t v14 = 0;
LABEL_13:
    std::mutex::unlock(v7);
    long long v13 = 0;
    char v15 = 1;
    if (!v14) {
      goto LABEL_11;
    }
LABEL_14:
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 16))(__p, v14, a2);
    goto LABEL_15;
  }
  uint64_t v14 = v12[3];
  long long v13 = (std::__shared_weak_count *)v12[4];
  if (!v13) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
  if (v14) {
    goto LABEL_14;
  }
LABEL_11:
  sub_100058DB0(__p, "");
LABEL_15:
  if (v19 >= 0) {
    long long v16 = __p;
  }
  else {
    long long v16 = (void **)__p[0];
  }
  xpc_object_t v20 = xpc_string_create((const char *)v16);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  v17[0] = v5;
  v17[1] = "carrierName";
  sub_100035E70((uint64_t)v17, &v20, &v21);
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
  if (v19 < 0)
  {
    operator delete(__p[0]);
    if (v15) {
      return;
    }
  }
  else if (v15)
  {
    return;
  }
  sub_10004D2C8(v13);
}

void sub_101212EDC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_101212F04(uint64_t a1, char *string)
{
  if (string[23] < 0) {
    string = *(char **)string;
  }
  xpc_object_t v4 = xpc_string_create(string);
  if (!v4) {
    xpc_object_t v4 = xpc_null_create();
  }
  v3[0] = a1 + 32;
  v3[1] = "status";
  sub_100035E70((uint64_t)v3, &v4, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v4);
}

void sub_101212F94(uint64_t a1, char *string)
{
  if (string[23] < 0) {
    string = *(char **)string;
  }
  xpc_object_t v4 = xpc_string_create(string);
  if (!v4) {
    xpc_object_t v4 = xpc_null_create();
  }
  v3[0] = a1 + 32;
  v3[1] = "switchName";
  sub_100035E70((uint64_t)v3, &v4, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v4);
}

void sub_101213024()
{
}

void sub_101213140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (v15)
  {
    sub_10004D2C8(v15);
    if (!v14) {
      goto LABEL_3;
    }
  }
  else if (!v14)
  {
    goto LABEL_3;
  }
  dispatch_release(v14);
LABEL_3:
  operator delete();
}

uint64_t sub_1012131B0(uint64_t a1, NSObject **a2, void *a3, void *a4, uint64_t a5)
{
  __int16 v9 = *a2;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)a4[1];
  v15[0] = *a4;
  v15[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v14 = *(void *)(a5 + 16);
  }
  sub_10045E7FC(a1, &object, a3, v15, "cp.mm.dp", (long long *)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = &off_101AA0F30;
  uint64_t v11 = a4[1];
  *(void *)(a1 + 152) = *a4;
  *(void *)(a1 + 160) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 168) = 1;
  return a1;
}

void sub_1012132CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, dispatch_object_t object)
{
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

CellularPlanProvisioningMonitorModeInterface *sub_101213308(CellularPlanProvisioningMonitorModeInterface *this)
{
  *(void *)this = &off_101AA0F30;
  char v2 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  return sub_10045E9DC(this);
}

void sub_101213368(CellularPlanProvisioningMonitorModeInterface *a1)
{
  sub_101213308(a1);

  operator delete();
}

void sub_1012133A0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    *(unsigned char *)(a1 + 168) = 0;
    sub_10045EEC8(a1, 0x100u);
    return;
  }
  char v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 152);
      if (v4)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 24))(v4, a1 + 64);
        sub_10045EEC8(a1, 0x100u);
LABEL_13:
        sub_10004D2C8(v3);
        return;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)char v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CellularPlanDelayProvisioningMonitorModeDelegate is not available", v6, 2u);
  }
  if (v3) {
    goto LABEL_13;
  }
}

void sub_1012134A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1012134B8(void *a1)
{
  char v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I handling vinyl info update in monitor mode", v4, 2u);
  }
  uint64_t result = sIsProfileInstalled();
  if (result) {
    return (*(uint64_t (**)(void *, uint64_t))(*a1 + 40))(a1, 257);
  }
  return result;
}

void sub_101213568(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_101213634(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10121370C);
  __cxa_rethrow();
}

void sub_10121365C(_Unwind_Exception *a1)
{
}

void sub_101213674(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1012136AC(uint64_t a1)
{
}

uint64_t sub_1012136C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10121370C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_101213738@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  ProvisioningProfileSupport = (capabilities::ct *)capabilities::ct::getProvisioningProfileSupport(a1);
  if (ProvisioningProfileSupport == 1
    || (uint64_t result = capabilities::ct::supportsVoiceCall(ProvisioningProfileSupport), (result & 1) == 0))
  {
    operator new();
  }
  return result;
}

void sub_101213A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_101213B94(uint64_t a1)
{
  *(void *)a1 = off_101AA1028;
  uint64_t v2 = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  char v6 = (void **)(a1 + 344);
  sub_10008A88C(&v6);
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(unsigned char *)(a1 + 296)) {
    sub_1000C584C(a1 + 80);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  BootstrapControllerInterface::~BootstrapControllerInterface((BootstrapControllerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_101213C74(uint64_t a1)
{
  sub_101213B94(a1);

  operator delete();
}

void sub_101213CAC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_101213DAC(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_101215D74;
  v5[3] = &unk_101AA1450;
  _OWORD v5[4] = a1 + 8;
  void v5[5] = &v4;
  char v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    __int16 v9 = sub_101215F08;
    uint64_t v10 = &unk_101AA1490;
    uint64_t v11 = &v13;
    long long v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    __int16 v9 = sub_101215ECC;
    uint64_t v10 = &unk_101AA1470;
    uint64_t v11 = &v13;
    long long v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

uint64_t sub_101213ED4(uint64_t result, unsigned __int8 *a2)
{
  int v2 = *(unsigned __int8 *)(result + 333);
  if (*a2 != v2)
  {
    if (v2 == 1 || *(unsigned char *)(result + 370) || *(unsigned char *)(result + 371) || *(unsigned char *)(result + 332) == 1) {
      __int16 v3 = 256;
    }
    else {
      __int16 v3 = 257;
    }
    *(_WORD *)(result + 368) = v3;
  }
  return result;
}

uint64_t sub_101213F1C(uint64_t result, unsigned __int8 *a2)
{
  int v2 = *(unsigned __int8 *)(result + 332);
  if (*a2 != v2)
  {
    if (*(unsigned char *)(result + 333) == 1 || *(unsigned char *)(result + 370) || *(unsigned char *)(result + 371) || v2 == 1) {
      __int16 v3 = 256;
    }
    else {
      __int16 v3 = 257;
    }
    *(_WORD *)(result + 368) = v3;
  }
  return result;
}

void sub_101213F64(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 80;
  int v5 = *(unsigned __int8 *)(a1 + 296);
  if (*(unsigned char *)(a2 + 216)) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if ((*(unsigned char *)(a2 + 216) != 0) == (v5 != 0)) {
      return;
    }
    if (!*(unsigned char *)(a2 + 216)) {
      goto LABEL_17;
    }
    goto LABEL_11;
  }
  char v7 = VinylProfileDetails::operator==();
  if ((v7 & 1) == 0)
  {
    int v5 = *(unsigned __int8 *)(a1 + 296);
    if (!*(unsigned char *)(a2 + 216)) {
      goto LABEL_17;
    }
LABEL_11:
    if (!v5)
    {
LABEL_15:
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      __int16 v9 = "Bootstrap no longer valid";
LABEL_23:
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, buf, 2u);
      return;
    }
    *(void *)long long buf = a2 + 96;
    *(void *)&uint8_t buf[8] = a2 + 120;
    *(void *)&long long v44 = a2 + 144;
    *((void *)&v44 + 1) = a2 + 168;
    uint64_t v45 = a2 + 16;
    __p[0] = (void *)(a1 + 176);
    __p[1] = (void *)(a1 + 200);
    *(void *)&long long v41 = a1 + 224;
    *((void *)&v41 + 1) = a1 + 248;
    uint64_t v42 = a1 + 96;
    if (sub_10078531C((uint64_t)&__dst, (uint64_t)buf, (uint64_t)__p)) {
      return;
    }
    int v5 = *(unsigned __int8 *)(a1 + 296);
    if (*(unsigned char *)(a2 + 216))
    {
      if (!*(unsigned char *)(a1 + 296)) {
        goto LABEL_15;
      }
LABEL_18:
      *(_OWORD *)std::string __p = 0u;
      long long v41 = 0u;
      uint64_t v10 = (os_log_t *)(a1 + 40);
      sub_10098CFF0((uint64_t)__p, (Registry **)(a1 + 64), (os_log_t *)(a1 + 40), v4);
      uint64_t v45 = 0;
      *(_OWORD *)long long buf = 0u;
      long long v44 = 0u;
      sub_10098DFC0((long long *)__p, (uint64_t)buf);
      if (!(_BYTE)v45)
      {
        uint64_t v11 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No proxy settings", (uint8_t *)&__dst, 2u);
        }
        goto LABEL_76;
      }
      memset(&__dst, 0, sizeof(__dst));
      if (SBYTE7(v44) < 0)
      {
        sub_10004FC84(&__dst, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)buf;
        __dst.__r_.__value_.__r.__words[2] = v44;
      }
      int v12 = DWORD2(v44);
      char v13 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
      uint64_t v15 = *(unsigned __int8 *)(a1 + 327);
      int v16 = (char)v15;
      if ((v15 & 0x80u) != 0) {
        uint64_t v15 = *(void *)(a1 + 312);
      }
      if (size != v15) {
        goto LABEL_46;
      }
      if (v16 >= 0) {
        long long v17 = (unsigned __int8 *)(a1 + 304);
      }
      else {
        long long v17 = *(unsigned __int8 **)(a1 + 304);
      }
      if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        xpc_object_t v20 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        if (memcmp(__dst.__r_.__value_.__l.__data_, v17, __dst.__r_.__value_.__l.__size_))
        {
          xpc_object_t v21 = *v10;
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
      }
      else if (*((unsigned char *)&__dst.__r_.__value_.__s + 23))
      {
        p_dst = &__dst;
        uint64_t v19 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        while (p_dst->__r_.__value_.__s.__data_[0] == *v17)
        {
          p_dst = (std::string *)((char *)p_dst + 1);
          ++v17;
          if (!--v19) {
            goto LABEL_45;
          }
        }
LABEL_46:
        xpc_object_t v21 = *v10;
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_51;
        }
        if (v13 >= 0) {
          xpc_object_t v20 = &__dst;
        }
        else {
          xpc_object_t v20 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
LABEL_50:
        *(_DWORD *)int v47 = 136315394;
        *(void *)&v47[4] = v20;
        __int16 v48 = 1024;
        int v49 = v12;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I updating proxy : %s : %u", v47, 0x12u);
LABEL_51:
        std::string::operator=((std::string *)(a1 + 304), &__dst);
        *(_DWORD *)(a1 + 328) = v12;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *(Registry **)(a1 + 64));
        long long v24 = ServiceMap;
        if (v25 < 0)
        {
          uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v27 = 5381;
          do
          {
            uint64_t v25 = v27;
            unsigned int v28 = *v26++;
            uint64_t v27 = (33 * v27) ^ v28;
          }
          while (v28);
        }
        std::mutex::lock(ServiceMap);
        *(void *)int v47 = v25;
        std::string::size_type v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)v47);
        if (v29)
        {
          uint64_t v31 = v29[3];
          uint64_t v30 = (std::__shared_weak_count *)v29[4];
          if (v30)
          {
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v24);
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v30);
            char v32 = 0;
            if (!v31)
            {
LABEL_69:
              if ((v32 & 1) == 0) {
                sub_10004D2C8(v30);
              }
              goto LABEL_71;
            }
LABEL_60:
            uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 776))(v31);
            unsigned int v34 = *(_DWORD *)(a1 + 328);
            uint64_t v46 = 0;
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (Mutable)
            {
              uint64_t v36 = v46;
              uint64_t v46 = Mutable;
              *(void *)int v47 = v36;
              sub_10005717C((const void **)v47);
            }
            if (*(char *)(a1 + 327) >= 0) {
              std::string::size_type v37 = (const char *)(a1 + 304);
            }
            else {
              std::string::size_type v37 = *(const char **)(a1 + 304);
            }
            *(void *)int v47 = CFStringCreateWithCString(kCFAllocatorDefault, v37, 0x8000100u);
            sub_10010F3F0(v46, (void *)kSCPropNetProxiesHTTPSProxy, *(uint64_t *)v47);
            if (v34 == 443)
            {
              sub_101214BA0(v46, (void *)kSCPropNetProxiesHTTPSPort, 0x1BBu, kCFAllocatorDefault);
              sub_1011CDCC8(v46, (void *)kSCPropNetProxiesHTTPSEnable, 1, kCFAllocatorDefault);
              sub_1011CDCC8(v46, @"HTTPSOverTLSEnable", 1, kCFAllocatorDefault);
            }
            else
            {
              sub_101214BA0(v46, (void *)kSCPropNetProxiesHTTPSPort, v34, kCFAllocatorDefault);
            }
            sub_10004EFE4(&v38, (CFTypeRef *)&v46);
            sub_1000558F4((const void **)v47);
            sub_10005717C((const void **)&v46);
            (*(void (**)(uint64_t, uint64_t, uint64_t, const void **))(*(void *)v31 + 968))(v31, v33, 19, &v38);
            sub_100057D78(&v38);
            goto LABEL_69;
          }
        }
        else
        {
          uint64_t v31 = 0;
        }
        std::mutex::unlock(v24);
        uint64_t v30 = 0;
        char v32 = 1;
        if (!v31) {
          goto LABEL_69;
        }
        goto LABEL_60;
      }
LABEL_45:
      if (v12 == *(_DWORD *)(a1 + 328))
      {
LABEL_71:
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if ((_BYTE)v45 && SBYTE7(v44) < 0) {
          operator delete(*(void **)buf);
        }
LABEL_76:
        if (SBYTE7(v41) < 0) {
          operator delete(__p[0]);
        }
        return;
      }
      goto LABEL_46;
    }
LABEL_17:
    if (!v5)
    {
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      __int16 v9 = "No Bootstrap profile details";
      goto LABEL_23;
    }
    goto LABEL_18;
  }
}

void sub_101214568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,char a34)
{
  sub_1000558F4((const void **)(v36 - 112));
  sub_10005717C((const void **)(v36 - 120));
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a34 && a32 < 0) {
    operator delete(a27);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

void sub_101214630(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v6 = *(void *)(a1 + 344);
  uint64_t v5 = *(void *)(a1 + 352);
  if (v4 - *a2 == v5 - v6)
  {
    while (v3 != v4)
    {
      if (!BasicSimInfo::operator==())
      {
        uint64_t v6 = *(void *)(a1 + 344);
        uint64_t v5 = *(void *)(a1 + 352);
        goto LABEL_6;
      }
      v3 += 168;
      v6 += 168;
    }
  }
  else
  {
LABEL_6:
    while (v6 != v5)
    {
      if (!*(_DWORD *)(v6 + 8))
      {
        uint64_t v7 = *(void *)(a1 + 376);
        if (v7)
        {
          *(void *)(a1 + 376) = 0;
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        uint64_t v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Delaying recommendation due to sim transition", buf, 2u);
        }
        Registry::getTimerService(&v20, *(Registry **)(a1 + 64));
        uint64_t v9 = v20;
        sub_100058DB0(v18, "BootstrapRecommendation Timer");
        uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v10 || (uint64_t v11 = *(void *)(a1 + 8), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
          sub_100088B9C();
        }
        char v13 = v12;
        atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        *(_OWORD *)std::string __p = *(_OWORD *)v18;
        uint64_t v24 = v19;
        v18[0] = 0;
        v18[1] = 0;
        uint64_t v19 = 0;
        uint64_t v26 = 0;
        uint64_t v14 = operator new(0x20uLL);
        *uint64_t v14 = off_101AA14C0;
        v14[1] = a1;
        v14[2] = v11;
        void v14[3] = v13;
        uint64_t v26 = v14;
        (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, uint8_t *))(*(void *)v9 + 40))(&v22, v9, __p, 2, 10000000, 0, buf);
        sub_10003B34C(buf);
        if (SHIBYTE(v24) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v15 = v22;
        uint64_t v22 = 0;
        uint64_t v16 = *(void *)(a1 + 376);
        *(void *)(a1 + 376) = v15;
        if (v16)
        {
          (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
          uint64_t v17 = v22;
          uint64_t v22 = 0;
          if (v17) {
            (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
          }
        }
        if (SHIBYTE(v19) < 0) {
          operator delete(v18[0]);
        }
        if (v21) {
          sub_10004D2C8(v21);
        }
        return;
      }
      v6 += 168;
    }
  }
}

void sub_1012148C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(a1);
}

void sub_101214930(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_101214A28(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)(a1 + 304);
    if (*(char *)(a1 + 327) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    int v4 = *(_DWORD *)(a1 + 328);
    int v11 = 136315394;
    int v12 = v3;
    __int16 v13 = 1024;
    LODWORD(v14) = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Boostrap Proxy {%s:%u}", (uint8_t *)&v11, 0x12u);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = printers::asString((printers *)(a1 + 368), v5);
    int v11 = 136315138;
    int v12 = (void *)v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrap recommendation: %s", (uint8_t *)&v11, 0xCu);
    int v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = printers::asString((printers *)(a1 + 370), v7);
    uint64_t v10 = printers::asString((printers *)(a1 + 371), v9);
    int v11 = 136315394;
    int v12 = (void *)v8;
    __int16 v13 = 2080;
    uint64_t v14 = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I MonitorModes Provisioning:%s Expiry:%s", (uint8_t *)&v11, 0x16u);
  }
}