void sub_100EB8970(uint64_t a1, uint64_t a2, ...)
{
  std::__shared_weak_count *v2;
  char v3;
  va_list va;

  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

void sub_100EB89CC()
{
}

__n128 sub_100EB89E0(uint64_t a1)
{
  v2 = (char *)operator new(0x18uLL);
  *(void *)v2 = off_101A67C98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100EB8A2C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A67C98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EB8A5C(uint64_t a1)
{
  v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_100EB8B50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB8B90()
{
}

void sub_100EB8B9C(uint64_t **a1)
{
  v5 = a1;
  v1 = *a1;
  uint64_t v2 = **a1;
  *(_DWORD *)(v2 + 4520) = 0;
  v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *((unsigned __int8 *)v1 + 16);
    *(_DWORD *)buf = 67109120;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchState back to DDS due to pending, success = %d. kInit", buf, 8u);
  }
  sub_100EB570C(v2, *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3));
  operator delete();
}

void sub_100EB8C7C()
{
}

void sub_100EB8CAC()
{
}

__n128 sub_100EB8CC0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A67D18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100EB8D0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A67D18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EB8D3C(uint64_t a1)
{
  v1 = (void *)(*(void *)(a1 + 16) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_100EB8E30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB8E70()
{
}

void sub_100EB8E80()
{
}

__n128 sub_100EB8E94(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A67D98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100EB8EE0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A67D98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EB8F10(uint64_t a1)
{
  v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_100EB9004(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB9044()
{
}

void sub_100EB9050(uint64_t **a1)
{
  v5 = a1;
  v1 = *a1;
  uint64_t v2 = **a1;
  *(_DWORD *)(v2 + 4520) = 0;
  v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *((unsigned __int8 *)v1 + 16);
    *(_DWORD *)buf = 67109120;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fTempDataSubSwitchState back to DDS success = %d, return to init", buf, 8u);
  }
  sub_100EB570C(v2, *((unsigned int *)v1 + 2), *((unsigned int *)v1 + 3));
  operator delete();
}

void sub_100EB9130()
{
}

void sub_100EB915C(capabilities::ct ***a1)
{
  v1 = a1;
  sub_100EB2AFC(**a1, *((unsigned __int8 *)*a1 + 8));
  operator delete();
}

void sub_100EB91B4()
{
}

uint64_t sub_100EB91E0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      int v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        int v7 = (void *)v4[1];
        v8 = v4;
        if (v7)
        {
          do
          {
            int v4 = v7;
            int v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            int v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            v8 = v4;
          }
          while (!v6);
        }
        v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            v5 = v10;
          }
          while (!v6);
        }
        v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_100EB931C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = emergency::CallAgent::CallAgent();
  *(void *)uint64_t v5 = off_101A67F00;
  *(void *)(v5 + 120) = a3;
  *(unsigned char *)(v5 + 128) = 0;
  if (!a3) {
    __assert_rtn("ActivationAgent", "EmergencyActivationAgent.cpp", 19, "activator && \"Need valid data session activator\"");
  }
  return a1;
}

void sub_100EB9394(_Unwind_Exception *a1)
{
  emergency::CallAgent::~CallAgent(v1);
  _Unwind_Resume(a1);
}

void *sub_100EB93A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1000F0058((uint64_t)v16, a2);
  sub_1000DFC90((uint64_t)v15, a3);
  sub_1000F0058((uint64_t)v14, a4);
  emergency::CallAgent::dial();
  sub_10003B34C(v14);
  sub_100060644(v15);
  sub_10003B34C(v16);
  if (*(unsigned char *)(a1 + 128)) {
    return (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  }
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  v13[0] = off_101A67F98;
  v13[1] = a1;
  v13[3] = v13;
  v12[0] = off_101A68028;
  v12[1] = a1;
  v12[3] = v12;
  v11[0] = off_101A680A8;
  v11[1] = a1;
  v11[3] = v11;
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
  (*(void (**)(uint64_t, uint64_t, void *, void *, void *, uint64_t))(*(void *)v8 + 32))(v8, v9, v13, v12, v11, v10);
  sub_10003B34C(v11);
  sub_100060644(v12);
  return sub_100EB975C(v13);
}

void sub_100EB957C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  sub_10003B34C((uint64_t *)va);
  sub_100060644((uint64_t *)va1);
  sub_100EB975C(va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100EB95D8(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    *(unsigned char *)(a1 + 128) = 0;
    (*(void (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
  }

  return emergency::CallAgent::endDialing((emergency::CallAgent *)a1);
}

void sub_100EB9658()
{
}

void *sub_100EB966C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A67F98;
  result[1] = v3;
  return result;
}

uint64_t sub_100EB96B4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A67F98;
  a2[1] = v2;
  return result;
}

uint64_t sub_100EB96E0(uint64_t a1)
{
  v1 = *(unsigned char **)(a1 + 8);
  v1[128] = 1;
  return (*(uint64_t (**)(void))(*(void *)v1 + 88))();
}

uint64_t sub_100EB9710(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB9750()
{
}

void *sub_100EB975C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100EB97E4()
{
}

void *sub_100EB97F8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A68028;
  result[1] = v3;
  return result;
}

uint64_t sub_100EB9840(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A68028;
  a2[1] = v2;
  return result;
}

uint64_t sub_100EB986C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  v3[128] = 0;
  return (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v3 + 96))(v3, v2);
}

uint64_t sub_100EB989C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB98DC()
{
}

void sub_100EB98EC()
{
}

void *sub_100EB9900(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A680A8;
  result[1] = v3;
  return result;
}

uint64_t sub_100EB9948(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A680A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100EB9974(uint64_t a1)
{
  v1 = *(unsigned char **)(a1 + 8);
  v1[128] = 0;
  return (*(uint64_t (**)(void))(*(void *)v1 + 104))();
}

uint64_t sub_100EB99A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EB99E0()
{
}

void sub_100EB99EC(void ***a1)
{
  *a1 = (void **)off_101A68128;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_100EB9A44(void ***a1)
{
  *a1 = (void **)off_101A68128;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

void *sub_100EB9AB0(void *result, uint64_t a2)
{
  *__n128 result = off_101A68128;
  result[1] = 0;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  return result;
}

uint64_t sub_100EB9B58(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100EB9BB4(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      if ((v10 >> 3) == 1) {
        operator new();
      }
LABEL_23:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_20;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100EB9D4C(uint64_t result, PB::Writer *this)
{
  unint64_t v2 = *(const PB::Data **)(result + 8);
  if (v2) {
    return PB::Writer::write(this, v2, 1u);
  }
  return result;
}

uint64_t RegistrationController::sendGetServingSystemReq_sync(RegistrationController *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 13) + 48))(*((void *)this + 13));
  if (!result)
  {
    unint64_t v3 = *(uint64_t (**)(void))(**((void **)this + 11) + 128);
    return v3();
  }
  return result;
}

void RegistrationController::handleScanCompletionStatus(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::operatorName(uint64_t a1, int a2, long long *a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  v6[2] = sub_100EBA098;
  v6[3] = &unk_101A681B8;
  int v4 = (void *)(a1 + 8);
  v6[4] = a1;
  int v21 = a2;
  sub_1003FB348((char *)&v7, a3);
  uint64_t v24 = 0;
  v25 = 0;
  sub_10003E168(&v24, v4);
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059524;
  block[3] = &unk_101A68368;
  block[5] = v24;
  v23 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (v20 < 0) {
    operator delete(__p);
  }
  if (v18 && v17 < 0) {
    operator delete(v16);
  }
  if (v15 && v14 < 0) {
    operator delete(v13);
  }
  if (v12 < 0) {
    operator delete(v11);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
}

void sub_100EBA098(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 224));
  v135 = 0;
  uint64_t v134 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(a1 + 224), &v134);
  uint64_t v4 = v134;
  if (v134)
  {
    int v5 = *(_DWORD *)(a1 + 116);
    if (v5 == 11) {
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v134 + 464))(v134);
    }
    long long __dst = 0uLL;
    uint64_t v133 = 0;
    if (*(char *)(a1 + 87) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 64), *(void *)(a1 + 72));
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 64);
      uint64_t v133 = *(void *)(a1 + 80);
    }
    long long __src = 0uLL;
    uint64_t v131 = 0;
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(&__src, *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      long long __src = *(_OWORD *)(a1 + 40);
      uint64_t v131 = *(void *)(a1 + 56);
    }
    char v8 = v5 + 1;
    if ((v5 + 1) > 0xC) {
      goto LABEL_119;
    }
    if (((1 << v8) & 0xD0A) == 0)
    {
      if (((1 << v8) & 0x1071) != 0)
      {
        unsigned int v9 = *v3;
        if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = SHIBYTE(v133);
          unint64_t v11 = (long long *)__dst;
          int v12 = SHIBYTE(v131);
          BOOL v13 = (long long *)__src;
          uint64_t v14 = asString();
          p_src = &__src;
          if (v12 < 0) {
            p_src = v13;
          }
          *(_DWORD *)buf = 136315650;
          p_dst = &__dst;
          if (v10 < 0) {
            p_dst = v11;
          }
          *(void *)&uint8_t buf[4] = p_dst;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = p_src;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = v14;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Ignoring short operator name (%s) and long (%s) for RAT %s", buf, 0x20u);
        }
        goto LABEL_119;
      }
      if (v5 != 8
        || ((*(uint64_t (**)(void))(**(void **)(v2 + 104) + 128))(*(void *)(v2 + 104)) & 1) == 0)
      {
        goto LABEL_119;
      }
    }
    uint64_t v17 = HIBYTE(v131);
    char v18 = HIBYTE(v131);
    if (v131 < 0) {
      uint64_t v17 = *((void *)&__src + 1);
    }
    if (v17) {
      goto LABEL_209;
    }
    uint64_t v19 = HIBYTE(v133);
    if (v133 < 0) {
      uint64_t v19 = *((void *)&__dst + 1);
    }
    if (v19)
    {
LABEL_209:
      if (*(unsigned char *)(a1 + 152) && *(unsigned char *)(a1 + 192))
      {
        char v20 = *v3;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          int IntValue = MCC::getIntValue((MCC *)(a1 + 120));
          int IntegerWidth = MNC::getIntegerWidth((MNC *)(a1 + 160));
          int v23 = MCC::getIntValue((MCC *)(a1 + 160));
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = IntValue;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = IntegerWidth;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&buf[16] = v23;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Using PLMN (%03d-%0.*d) from baseband", buf, 0x14u);
          char v18 = HIBYTE(v131);
        }
        if (v18 < 0)
        {
          sub_10004FC84(&v111, (void *)__src, *((unint64_t *)&__src + 1));
        }
        else
        {
          long long v111 = __src;
          uint64_t v112 = v131;
        }
        if (SHIBYTE(v133) < 0)
        {
          sub_10004FC84(&v113, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          long long v113 = __dst;
          uint64_t v114 = v133;
        }
        if (*(char *)(a1 + 111) < 0)
        {
          sub_10004FC84(&v115, *(void **)(a1 + 88), *(void *)(a1 + 96));
        }
        else
        {
          long long v115 = *(_OWORD *)(a1 + 88);
          uint64_t v116 = *(void *)(a1 + 104);
        }
        int v117 = *(_DWORD *)(a1 + 112);
        int v118 = v5;
        sub_100026914((MCC *)&v119, (const MCC *)(a1 + 120));
        sub_1000268AC((MCC *)&v123, (const MCC *)(a1 + 160));
        uint64_t v128 = 0;
        v127 = 0;
        uint64_t v129 = 0;
        (*(void (**)(uint64_t, long long *))(*(void *)v4 + 336))(v4, &v111);
        if (SHIBYTE(v129) < 0) {
          operator delete(v127);
        }
        if (v126 && v125 < 0) {
          operator delete(v124);
        }
        if (v122 && v121 < 0) {
          operator delete(v120);
        }
        if (SHIBYTE(v116) < 0) {
          operator delete((void *)v115);
        }
        if (SHIBYTE(v114) < 0) {
          operator delete((void *)v113);
        }
        if (SHIBYTE(v112) < 0)
        {
          v28 = (void *)v111;
          goto LABEL_118;
        }
      }
      else
      {
        uint64_t v24 = *v3;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v4 + 424))(buf, v4);
          int v25 = MCC::getIntValue((MCC *)buf);
          (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v108, v4);
          int v26 = MNC::getIntegerWidth((MNC *)&v108);
          (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v105, v4);
          int v27 = MCC::getIntValue((MCC *)&v105);
          LODWORD(v146) = 67109632;
          DWORD1(v146) = v25;
          WORD4(v146) = 1024;
          *(_DWORD *)((char *)&v146 + 10) = v26;
          HIWORD(v146) = 1024;
          LODWORD(v147) = v27;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Using PLMN (%03d-%0.*d) from model", (uint8_t *)&v146, 0x14u);
          if (v107 < 0) {
            operator delete(*((void **)&v105 + 1));
          }
          if (v110 < 0) {
            operator delete(*((void **)&v108 + 1));
          }
          if ((buf[31] & 0x80000000) != 0) {
            operator delete(*(void **)&buf[8]);
          }
          char v18 = HIBYTE(v131);
        }
        if (v18 < 0)
        {
          sub_10004FC84(&v86, (void *)__src, *((unint64_t *)&__src + 1));
        }
        else
        {
          long long v86 = __src;
          uint64_t v87 = v131;
        }
        if (SHIBYTE(v133) < 0)
        {
          sub_10004FC84(&v88, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          long long v88 = __dst;
          uint64_t v89 = v133;
        }
        if (*(char *)(a1 + 111) < 0)
        {
          sub_10004FC84(&v90, *(void **)(a1 + 88), *(void *)(a1 + 96));
        }
        else
        {
          long long v90 = *(_OWORD *)(a1 + 88);
          uint64_t v91 = *(void *)(a1 + 104);
        }
        int v92 = *(_DWORD *)(a1 + 112);
        int v93 = v5;
        (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v4 + 424))(buf, v4);
        MCC::MCC((MCC *)&v94, (const MCC *)buf);
        char v97 = 1;
        (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v108, v4);
        MCC::MCC((MCC *)&v98, (const MCC *)&v108);
        char v101 = 1;
        uint64_t v104 = 0;
        v102 = 0;
        uint64_t v103 = 0;
        (*(void (**)(uint64_t, long long *))(*(void *)v4 + 336))(v4, &v86);
        if (SHIBYTE(v104) < 0) {
          operator delete(v102);
        }
        if (v101 && v100 < 0) {
          operator delete(v99);
        }
        if (v97 && v96 < 0) {
          operator delete(v95);
        }
        if (SHIBYTE(v91) < 0) {
          operator delete((void *)v90);
        }
        if (SHIBYTE(v89) < 0) {
          operator delete((void *)v88);
        }
        if (SHIBYTE(v87) < 0) {
          operator delete((void *)v86);
        }
        if (v110 < 0) {
          operator delete(*((void **)&v108 + 1));
        }
        if ((buf[31] & 0x80000000) != 0)
        {
          v28 = *(void **)&buf[8];
LABEL_118:
          operator delete(v28);
        }
      }
LABEL_119:
      uint64_t v37 = *(unsigned int *)(a1 + 224);
      sub_1003FB348((char *)&v58, (long long *)(a1 + 40));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12E88, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_101B12E88))
      {
        *(_OWORD *)buf = *(_OWORD *)off_101A681E8;
        *(void *)&buf[16] = @"Type2";
        sub_100367E88(qword_101B12E90, buf, 3uLL);
        __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B12E90, (void *)&_mh_execute_header);
        __cxa_guard_release(&qword_101B12E88);
      }
      *(void *)&long long v146 = v2;
      *((void *)&v146 + 1) = v37;
      uint64_t v38 = HIBYTE(v71);
      if (v71 < 0) {
        uint64_t v38 = *((void *)&v70 + 1);
      }
      if (v38)
      {
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
        v40 = ServiceMap;
        if (v41 < 0)
        {
          v42 = (unsigned __int8 *)(v41 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v43 = 5381;
          do
          {
            uint64_t v41 = v43;
            unsigned int v44 = *v42++;
            uint64_t v43 = (33 * v43) ^ v44;
          }
          while (v44);
        }
        std::mutex::lock(ServiceMap);
        *(void *)buf = v41;
        v45 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)buf);
        if (v45)
        {
          uint64_t v47 = v45[3];
          v46 = (std::__shared_weak_count *)v45[4];
          if (v46)
          {
            atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v40);
            atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v46);
            if (!v47)
            {
LABEL_173:
              sub_10004D2C8(v46);
              goto LABEL_174;
            }
LABEL_133:
            CFDictionaryRef v138 = 0;
            (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v47 + 80))(&v137, v47, v37, 1, @"TypesOfEvo", 0, 0);
            *(void *)&long long v108 = v137;
            if (v137) {
              CFRetain(v137);
            }
            *(void *)&long long v105 = 0;
            *(void *)buf = 0;
            sub_10004EFE4(buf, (CFTypeRef *)&v108);
            if (*(void *)buf) {
              v49 = sub_100080778;
            }
            else {
              v49 = 0;
            }
            if (v49) {
              sub_100058140((const void **)&v105, (const void **)buf);
            }
            sub_100057D78((const void **)buf);
            CFDictionaryRef v138 = (const __CFDictionary *)v105;
            *(void *)&long long v105 = 0;
            sub_100057D78((const void **)&v105);
            sub_1000577C4((const void **)&v108);
            sub_1000577C4(&v137);
            if (v138) {
              v50 = sub_100080778;
            }
            else {
              v50 = 0;
            }
            if (v50)
            {
              if (SHIBYTE(v71) < 0)
              {
                sub_10004FC84(&v105, (void *)v70, *((unint64_t *)&v70 + 1));
              }
              else
              {
                long long v105 = v70;
                uint64_t v106 = v71;
              }
              if (SHIBYTE(v106) < 0)
              {
                sub_10004FC84(&v108, (void *)v105, *((unint64_t *)&v105 + 1));
              }
              else
              {
                long long v108 = v105;
                uint64_t v109 = v106;
              }
              v139 = 0;
              if (SHIBYTE(v109) < 0)
              {
                sub_10004FC84(buf, (void *)v108, *((unint64_t *)&v108 + 1));
              }
              else
              {
                *(_OWORD *)buf = v108;
                *(void *)&buf[16] = v109;
              }
              v140 = 0;
              if (ctu::cf::convert_copy())
              {
                v51 = v139;
                v139 = v140;
                *(void *)v141 = v51;
                sub_1000558F4((const void **)v141);
              }
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              v136 = v139;
              v139 = 0;
              sub_1000558F4(&v139);
              if (SHIBYTE(v109) < 0) {
                operator delete((void *)v108);
              }
              if (SHIBYTE(v106) < 0) {
                operator delete((void *)v105);
              }
              if (unk_101B12E98 == qword_101B12E90[0])
              {
LABEL_170:
                LOBYTE(v52) = 0;
              }
              else
              {
                unint64_t v52 = 0;
                if ((unint64_t)((unk_101B12E98 - qword_101B12E90[0]) >> 3) <= 1) {
                  uint64_t v53 = 1;
                }
                else {
                  uint64_t v53 = (unk_101B12E98 - qword_101B12E90[0]) >> 3;
                }
                while (1)
                {
                  if (v52 >= (unk_101B12E98 - qword_101B12E90[0]) >> 3) {
                    sub_10015B728();
                  }
                  Value = CFDictionaryGetValue(v138, *(const void **)(qword_101B12E90[0] + 8 * v52));
                  v55 = Value;
                  if (Value)
                  {
                    CFTypeID v56 = CFGetTypeID(Value);
                    if (v56 == CFStringGetTypeID())
                    {
                      if (CFEqual(v136, v55)) {
                        break;
                      }
                    }
                  }
                  if (v53 == ++v52) {
                    goto LABEL_170;
                  }
                }
              }
              LOBYTE(v108) = v52;
              *(void *)buf = 1;
              *(_OWORD *)&buf[16] = 0u;
              uint64_t v149 = 0;
              *(void *)&buf[8] = v146 + 760;
              v57 = sub_1004C46F4((uint64_t *)&buf[16], v146 + 792);
              sub_100EBC7FC(v57, (int *)&v146 + 2, &v108);
              sub_100EBC8D8((uint64_t)buf);
              sub_1000558F4(&v136);
            }
            sub_100057D78((const void **)&v138);
            if (!v46) {
              goto LABEL_174;
            }
            goto LABEL_173;
          }
          std::mutex::unlock(v40);
          if (v47) {
            goto LABEL_133;
          }
        }
        else
        {
          std::mutex::unlock(v40);
        }
      }
      else
      {
        LOBYTE(v108) = 0;
        *(void *)buf = 1;
        *(_OWORD *)&buf[16] = 0u;
        uint64_t v149 = 0;
        *(void *)&buf[8] = v2 + 760;
        v48 = sub_1004C46F4((uint64_t *)&buf[16], v2 + 792);
        sub_100EBC7FC(v48, (int *)&v146 + 2, &v108);
        sub_100EBC8D8((uint64_t)buf);
      }
LABEL_174:
      if (SHIBYTE(v71) < 0) {
        operator delete((void *)v70);
      }
      if (v69 && v68 < 0) {
        operator delete(v67);
      }
      if (v66 && v65 < 0) {
        operator delete(v64);
      }
      if (v63 < 0) {
        operator delete(v62);
      }
      if (v61 < 0) {
        operator delete(v60);
      }
      if (v59 < 0) {
        operator delete(v58);
      }
      if (SHIBYTE(v131) < 0) {
        operator delete((void *)__src);
      }
      if (SHIBYTE(v133) < 0) {
        operator delete((void *)__dst);
      }
      goto LABEL_192;
    }
    if (*(unsigned char *)(a1 + 152) && *(unsigned char *)(a1 + 192))
    {
      v29 = *v3;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        int v30 = MCC::getIntValue((MCC *)(a1 + 120));
        int v31 = MNC::getIntegerWidth((MNC *)(a1 + 160));
        int v32 = MCC::getIntValue((MCC *)(a1 + 160));
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&uint8_t buf[4] = v30;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v31;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v32;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Using PLMN (%03d-%0.*d) from baseband", buf, 0x14u);
        char v18 = HIBYTE(v131);
      }
      if (v18 < 0)
      {
        sub_10004FC84(&v76, (void *)__src, *((unint64_t *)&__src + 1));
      }
      else
      {
        long long v76 = __src;
        uint64_t v77 = v131;
      }
      if (SHIBYTE(v133) < 0)
      {
        sub_10004FC84(&v78, (void *)__dst, *((unint64_t *)&__dst + 1));
      }
      else
      {
        long long v78 = __dst;
        uint64_t v79 = v133;
      }
      if (*(char *)(a1 + 111) < 0)
      {
        sub_10004FC84(&v80, *(void **)(a1 + 88), *(void *)(a1 + 96));
      }
      else
      {
        long long v80 = *(_OWORD *)(a1 + 88);
        uint64_t v81 = *(void *)(a1 + 104);
      }
      int v82 = *(_DWORD *)(a1 + 112);
      int v83 = v5;
      sub_100026914((MCC *)&v84, (const MCC *)(a1 + 120));
      sub_1000268AC((MCC *)v85, (const MCC *)(a1 + 160));
      memset(&v85[40], 0, 24);
      (*(void (**)(uint64_t, long long *))(*(void *)v4 + 336))(v4, &v76);
      sub_1003FB4D8((uint64_t)&v76);
      goto LABEL_119;
    }
    long long v146 = 0uLL;
    uint64_t v147 = 0;
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v4 + 424))(buf, v4);
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v108, v4);
    formPLMN((const MCC *)buf, (const MNC *)&v108);
    if (v110 < 0) {
      operator delete(*((void **)&v108 + 1));
    }
    if ((buf[31] & 0x80000000) != 0) {
      operator delete(*(void **)&buf[8]);
    }
    v33 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v4 + 424))(buf, v4);
      int v34 = MCC::getIntValue((MCC *)buf);
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v108, v4);
      int v35 = MNC::getIntegerWidth((MNC *)&v108);
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v4 + 432))(&v105, v4);
      int v36 = MCC::getIntValue((MCC *)&v105);
      *(_DWORD *)v141 = 67109632;
      *(_DWORD *)&v141[4] = v34;
      __int16 v142 = 1024;
      int v143 = v35;
      __int16 v144 = 1024;
      int v145 = v36;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Using PLMN (%03d-%0.*d) from model", v141, 0x14u);
      if (v107 < 0) {
        operator delete(*((void **)&v105 + 1));
      }
      if (v110 < 0) {
        operator delete(*((void **)&v108 + 1));
      }
      if ((buf[31] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[8]);
      }
    }
    if (SHIBYTE(v147) < 0)
    {
      sub_10004FC84(&v74, (void *)v146, *((unint64_t *)&v146 + 1));
      if (SHIBYTE(v147) < 0)
      {
        sub_10004FC84(&v72, (void *)v146, *((unint64_t *)&v146 + 1));
LABEL_112:
        (*(void (**)(uint64_t, long long *, long long *, uint64_t))(*(void *)v4 + 344))(v4, &v74, &v72, 5);
        if (SHIBYTE(v73) < 0) {
          operator delete((void *)v72);
        }
        if (SHIBYTE(v75) < 0) {
          operator delete((void *)v74);
        }
        if (SHIBYTE(v147) < 0)
        {
          v28 = (void *)v146;
          goto LABEL_118;
        }
        goto LABEL_119;
      }
    }
    else
    {
      long long v74 = v146;
      uint64_t v75 = v147;
    }
    long long v72 = v146;
    uint64_t v73 = v147;
    goto LABEL_112;
  }
  uint64_t v6 = *v3;
  if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = subscriber::asString();
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model %s for operator name", buf, 0xCu);
  }
LABEL_192:
  if (v135) {
    sub_10004D2C8(v135);
  }
}

void sub_100EBB248(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_guard_abort(&qword_101B12E88);
  sub_1003FB4D8((uint64_t)va);
  if (SLOBYTE(STACK[0x397]) < 0) {
    operator delete((void *)STACK[0x380]);
  }
  if (SLOBYTE(STACK[0x3B7]) < 0) {
    operator delete((void *)STACK[0x3A0]);
  }
  if (STACK[0x3C0]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x3C0]);
  }
  _Unwind_Resume(a1);
}

char *sub_100EBB650(uint64_t a1, uint64_t a2)
{
  return sub_1003FB348((char *)(a1 + 40), (long long *)(a2 + 40));
}

uint64_t sub_100EBB65C(uint64_t a1)
{
  return sub_1003FB4D8(a1 + 40);
}

void RegistrationController::handleNetworkReject(uint64_t a1, int a2, int a3, char a4, int a5)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100EBB780;
  v7[3] = &unk_101A68200;
  v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  char v11 = a4;
  int v10 = a5;
  uint64_t v14 = 0;
  char v15 = 0;
  sub_10003E168(&v14, (void *)(a1 + 8));
  uint64_t v6 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059524;
  block[3] = &unk_101A68368;
  block[5] = v14;
  BOOL v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v7;
  dispatch_async(v6, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100EBB780(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 44);
  uint64_t v3 = *(unsigned __int8 *)(a1 + 52);
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  unsigned int v30 = *(_DWORD *)(a1 + 40);
  int v5 = sub_1000FD774(v1 + 64, (int *)&v30);
  uint64_t v7 = *v5;
  uint64_t v6 = (std::__shared_weak_count *)v5[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v30);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 304))(v7, v3);
  int v9 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = asString();
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Registration for domain %s failed with cause %d", buf, 0x12u);
  }
  (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v7 + 424))(buf, v7);
  char v11 = MCC::valid((MCC *)buf);
  if (SBYTE7(v34) < 0) {
    operator delete(*(void **)&buf[8]);
  }
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v7 + 424))(buf, v7);
  MCC::getStringValue((uint64_t *)v28, (MCC *)buf);
  char v12 = v11 ^ 1;
  if (SBYTE7(v34) < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (v2 == 3)
  {
    *(_OWORD *)&buf[8] = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    *(void *)buf = v1;
    uint64_t v13 = v30;
    *(_DWORD *)&buf[8] = v30;
    buf[12] = v3;
    *(_DWORD *)&buf[16] = v4;
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&v34, v28[0], (unint64_t)v28[1]);
      uint64_t v13 = v30;
    }
    else
    {
      long long v34 = *(_OWORD *)v28;
      *(void *)&long long v35 = v29;
    }
    BYTE8(v35) = v12;
    uint64_t v17 = *(void *)(v1 + 280);
    long long v21 = *(_OWORD *)buf;
    int v23 = *(_DWORD *)&buf[16];
    if (SBYTE7(v35) < 0)
    {
      sub_10004FC84(&__p, (void *)v34, *((unint64_t *)&v34 + 1));
      char v12 = BYTE8(v35);
    }
    else
    {
      long long __p = v34;
      uint64_t v26 = v35;
    }
    char v27 = v12;
    int v32 = 0;
    char v20 = (char *)operator new(0x40uLL);
    *(void *)char v20 = off_101A68428;
    *(_OWORD *)(v20 + 8) = v21;
    *((_DWORD *)v20 + 6) = v23;
    *((_OWORD *)v20 + 2) = __p;
    *((void *)v20 + 6) = v26;
    uint64_t v26 = 0;
    long long __p = 0uLL;
    v20[56] = v12;
    int v32 = v20;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 24))(v17, v13, v31);
  }
  else
  {
    if (v2 != 2)
    {
      if (v2 == 1)
      {
        (*(void (**)(void, void, uint64_t, uint64_t))(**(void **)(v1 + 344) + 168))(*(void *)(v1 + 344), v30, v3, v4);
      }
      else
      {
        char v15 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = asString();
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = v16;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v3;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N Unhandled network reject service domain %s for reject cause code %d", buf, 0x12u);
        }
      }
      goto LABEL_33;
    }
    *(_OWORD *)&buf[8] = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    *(void *)buf = v1;
    uint64_t v14 = v30;
    *(_DWORD *)&buf[8] = v30;
    buf[12] = v3;
    *(_DWORD *)&buf[16] = v4;
    if (SHIBYTE(v29) < 0)
    {
      sub_10004FC84(&v34, v28[0], (unint64_t)v28[1]);
      uint64_t v14 = v30;
    }
    else
    {
      long long v34 = *(_OWORD *)v28;
      *(void *)&long long v35 = v29;
    }
    BYTE8(v35) = v12;
    uint64_t v18 = *(void *)(v1 + 280);
    long long v22 = *(_OWORD *)buf;
    int v24 = *(_DWORD *)&buf[16];
    if (SBYTE7(v35) < 0)
    {
      sub_10004FC84(&__p, (void *)v34, *((unint64_t *)&v34 + 1));
      char v12 = BYTE8(v35);
    }
    else
    {
      long long __p = v34;
      uint64_t v26 = v35;
    }
    char v27 = v12;
    int v32 = 0;
    uint64_t v19 = (char *)operator new(0x40uLL);
    *(void *)uint64_t v19 = off_101A683A8;
    *(_OWORD *)(v19 + 8) = v22;
    *((_DWORD *)v19 + 6) = v24;
    *((_OWORD *)v19 + 2) = __p;
    *((void *)v19 + 6) = v26;
    uint64_t v26 = 0;
    long long __p = 0uLL;
    v19[56] = v12;
    int v32 = v19;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v18 + 24))(v18, v14, v31);
  }
  sub_10001E914(v31);
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)__p);
  }
  if (SBYTE7(v35) < 0) {
    operator delete((void *)v34);
  }
LABEL_33:
  (*(void (**)(void, void, uint64_t))(**(void **)(v1 + 312) + 112))(*(void *)(v1 + 312), v30, v3);
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100EBBD1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (v39) {
    sub_10004D2C8(v39);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::networkTimeUpdate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100026914((MCC *)&v5, (const MCC *)(a3 + 72));
  sub_1000268AC((MCC *)&v6, (const MCC *)(a3 + 112));
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_100EBBF98(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (*(unsigned char *)(v28 + 160) && *(char *)(v28 + 159) < 0) {
    operator delete(*(void **)(v28 + 136));
  }
  if (*(unsigned char *)(v28 + 120))
  {
    if (*(char *)(v28 + 119) < 0) {
      operator delete(*(void **)(v28 + 96));
    }
  }
  sub_10006A6AC(a1);
}

void RegistrationController::ratSelectionComplete(uint64_t a1, int a2, char a3, char a4)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100EBC124;
  v6[3] = &unk_101A68220;
  v6[4] = a1;
  int v7 = a2;
  char v8 = a3;
  char v9 = a4;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10003E168(&v12, (void *)(a1 + 8));
  uint64_t v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059524;
  block[3] = &unk_101A68368;
  block[5] = v12;
  char v11 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_100EBC124(uint64_t a1)
{
  int v2 = *(void **)(a1 + 32);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  RegistrationController::getModel_sync((uint64_t)v2, *(_DWORD *)(a1 + 40), &v15);
  uint64_t v3 = v15;
  if (v15)
  {
    *(void *)buf = 0;
    RatSelectionType::RatSelectionType();
    char v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 600))(v3, *(void *)buf);
    (*(void (**)(uint64_t, void))(*(void *)v3 + 560))(v3, 0);
    uint64_t v5 = v2[43];
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 656))(v3);
    uint64_t v7 = *(unsigned __int8 *)(a1 + 44);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 584))(v3);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 112))(v5, v6, v7, v8);
    if (v4)
    {
      uint64_t v9 = v2[41];
      uint64_t v10 = *(unsigned int *)(a1 + 40);
      uint64_t Selection = RatSelectionType::getSelection((RatSelectionType *)buf);
      Preferreduint64_t Selection = RatSelectionType::getPreferredSelection((RatSelectionType *)buf);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 136))(v9, v10, Selection, PreferredSelection);
    }
  }
  else
  {
    uint64_t v13 = v2[5];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = subscriber::asString();
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find model %s for RAT selection complete", buf, 0xCu);
    }
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_100EBC38C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::setSystemSelectionAndOrderPreferenceFailed(uint64_t a1, int a2)
{
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_100EBC638;
  v14[3] = &unk_101A68240;
  void v14[4] = a1;
  int v15 = a2;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_10003E168(&v18, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = (unint64_t)_NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = (unint64_t)sub_100059524;
  block[3] = (unint64_t)&unk_101A68368;
  block[5] = v18;
  uint64_t v17 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = (unint64_t)v14;
  dispatch_async(v3, block);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 136));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  block[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, block);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
LABEL_15:
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 16))(v12))
  {
    dispatch_get_global_queue(0, 0);
    if ((v13 & 1) == 0) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    operator new();
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100EBC618(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EBC638(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(a1 + 40), &v6);
  uint64_t v3 = v6;
  char v4 = *(NSObject **)(v2 + 40);
  if (v6)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#N Serving System Selection failed", buf, 2u);
    }
    (*(void (**)(uint64_t, void))(*(void *)v3 + 560))(v3, 0);
    (*(void (**)(uint64_t, void))(*(void *)v3 + 576))(v3, 0);
    (*(void (**)(void, void))(**(void **)(v2 + 344) + 120))(*(void *)(v2 + 344), *(unsigned int *)(a1 + 40));
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = subscriber::asString();
    *(_DWORD *)buf = 136315138;
    uint64_t v9 = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for system selection preference failure", buf, 0xCu);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100EBC7E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100EBC7FC(uint64_t *result, int *a2, unsigned char *a3)
{
  uint64_t v5 = (uint64_t **)result;
  uint64_t v6 = result + 1;
  uint64_t v7 = result[1];
  if (v7)
  {
    int v8 = *a2;
    uint64_t v9 = result + 1;
    do
    {
      int v10 = *(_DWORD *)(v7 + 28);
      BOOL v11 = v10 < v8;
      if (v10 >= v8) {
        uint64_t v12 = (uint64_t *)v7;
      }
      else {
        uint64_t v12 = (uint64_t *)(v7 + 8);
      }
      if (!v11) {
        uint64_t v9 = (uint64_t *)v7;
      }
      uint64_t v7 = *v12;
    }
    while (*v12);
    if (v9 != v6 && v8 >= *((_DWORD *)v9 + 7))
    {
      *((unsigned char *)v9 + 32) = *a3;
      return result;
    }
    uint64_t v6 = v9;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t result = sub_10005CF3C(result, v6, &v16, &v15, a2);
  if (!*result)
  {
    char v13 = (uint64_t **)result;
    uint64_t v14 = operator new(0x28uLL);
    v14[7] = *a2;
    *((unsigned char *)v14 + 32) = *a3;
    return sub_100046C38(v5, (uint64_t)v16, v13, (uint64_t *)v14);
  }
  return result;
}

uint64_t sub_100EBC8D8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_27;
      }
      char v4 = *(void **)(a1 + 16);
      while (1)
      {
        BOOL v5 = *((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7)
          && *((unsigned __int8 *)v3 + 32) == *((unsigned __int8 *)v4 + 32);
        if (!v5) {
          break;
        }
        uint64_t v6 = (void *)v3[1];
        uint64_t v7 = v3;
        if (v6)
        {
          do
          {
            uint64_t v3 = v6;
            uint64_t v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v7[2];
            BOOL v5 = *v3 == (void)v7;
            uint64_t v7 = v3;
          }
          while (!v5);
        }
        int v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            int v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v5 = *v9 == (void)v4;
            char v4 = v9;
          }
          while (!v5);
        }
        char v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_27;
        }
      }
    }
    int v10 = v2 + 5;
    sub_1000346F8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    BOOL v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      *BOOL v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_27:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_100EBCA48()
{
}

void *sub_100EBCA5C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A68270;
  return result;
}

void sub_100EBCA94(uint64_t a1, void *a2)
{
  *a2 = off_101A68270;
}

uint64_t sub_100EBCAC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EBCB00()
{
}

void sub_100EBCB10()
{
}

void *sub_100EBCB24()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A682F0;
  return result;
}

void sub_100EBCB5C(uint64_t a1, void *a2)
{
  *a2 = off_101A682F0;
}

uint64_t sub_100EBCB88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EBCBC8()
{
}

void sub_100EBCBD4(uint64_t **a1)
{
  uint64_t v5 = 0;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v6 = 0;
  RegistrationController::getModel_sync(v2, *((_DWORD *)v1 + 2), &v5);
  if (v5)
  {
    (*(void (**)(void, void, void))(**(void **)(v2 + 344) + 224))(*(void *)(v2 + 344), *((unsigned int *)v1 + 2), *((unsigned __int8 *)v1 + 12));
  }
  else
  {
    uint64_t v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = subscriber::asString();
      *(_DWORD *)buf = 136315138;
      uint64_t v8 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Could not find model %s for OOS scan completion status", buf, 0xCu);
    }
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  operator delete();
}

void sub_100EBCD00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

uint64_t sub_100EBCD3C(uint64_t a1)
{
  *(void *)a1 = off_101A683A8;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

void sub_100EBCD8C(uint64_t a1)
{
  *(void *)a1 = off_101A683A8;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  operator delete();
}

void *sub_100EBCDFC(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A683A8;
  sub_100EBD170((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100EBCE50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EBCE64(uint64_t a1, void *a2)
{
  *a2 = off_101A683A8;
  return sub_100EBD170((uint64_t)(a2 + 1), (long long *)(a1 + 8));
}

void sub_100EBCE90(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void sub_100EBCEA4(void **__p)
{
  if (*((char *)__p + 55) < 0) {
    operator delete(__p[4]);
  }

  operator delete(__p);
}

void sub_100EBCEE8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v3 = *(void **)(a2 + 8);
  *(_DWORD *)uint64_t v7 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)&v7[3] = *(_DWORD *)(a2 + 19);
  int v5 = *(char *)(a2 + 23);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v5 < 0)
  {
    sub_10004FC84(v8, v4, (unint64_t)v3);
  }
  else
  {
    v8[0] = v4;
    v8[1] = v3;
    *(_DWORD *)uint64_t v9 = *(_DWORD *)v7;
    *(_DWORD *)&v9[3] = *(_DWORD *)&v7[3];
    char v10 = v5;
  }
  if (*(char *)(a1 + 55) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 32);
    __p[2] = *(void **)(a1 + 48);
  }
  char v12 = *(unsigned char *)(a1 + 56);
  v13[0] = 0;
  v13[1] = 0;
  sub_10003E168(v13, (void *)(v6 + 8));
  operator new();
}

void sub_100EBD0EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EBD124(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EBD164()
{
}

uint64_t sub_100EBD170(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
  *(_OWORD *)a1 = v4;
  uint64_t v5 = a1 + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *(void *)(v5 + 16) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(unsigned char *)(a1 + 48) = *((unsigned char *)a2 + 48);
  return a1;
}

uint64_t *sub_100EBD1D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  v55 = a1;
  uint64_t v56 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 344);
  uint64_t v4 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(unsigned __int8 *)(v1 + 12);
  uint64_t v6 = *(unsigned int *)(v1 + 16);
  uint64_t v7 = *(unsigned __int8 *)(v1 + 47);
  if ((v7 & 0x80u) == 0) {
    uint64_t v8 = *(unsigned __int8 *)(v1 + 47);
  }
  else {
    uint64_t v8 = *(void *)(v1 + 32);
  }
  uint64_t v9 = *(unsigned __int8 *)(v1 + 71);
  int v10 = (char)v9;
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(v1 + 56);
  }
  if (v8 == v9)
  {
    BOOL v11 = (const void **)(v1 + 24);
    if (v10 >= 0) {
      char v12 = (unsigned __int8 *)(v1 + 48);
    }
    else {
      char v12 = *(unsigned __int8 **)(v1 + 48);
    }
    if ((v7 & 0x80) != 0)
    {
      BOOL v20 = memcmp(*v11, v12, *(void *)(v1 + 32)) == 0;
    }
    else if (*(unsigned char *)(v1 + 47))
    {
      uint64_t v13 = v7 - 1;
      do
      {
        int v15 = *(unsigned __int8 *)v11;
        BOOL v11 = (const void **)((char *)v11 + 1);
        int v14 = v15;
        int v17 = *v12++;
        int v16 = v17;
        BOOL v19 = v13-- != 0;
        BOOL v20 = v14 == v16;
      }
      while (v14 == v16 && v19);
    }
    else
    {
      BOOL v20 = 1;
    }
  }
  else
  {
    BOOL v20 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, BOOL, void))(*(void *)v3 + 160))(v3, v4, v5, v6, v20, *(unsigned __int8 *)(v1 + 72));
  long long v21 = &unk_101B12000;
  if ((byte_101B12E80 & 1) == 0)
  {
    uint64_t v22 = *(unsigned int *)(v1 + 8);
    int v23 = *(_DWORD *)(v1 + 16);
    int v24 = *(unsigned __int8 *)(v1 + 12);
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)byte_101B12E80, *(Registry **)(v2 + 136));
    uint64_t v26 = ServiceMap;
    if (v27 < 0)
    {
      uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(ServiceMap);
    *(void *)buf = v27;
    int v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      int v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
        if (v23) {
          goto LABEL_38;
        }
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    int v32 = 0;
    char v34 = 1;
    if (v23) {
      goto LABEL_38;
    }
LABEL_32:
    if (v24 == 133) {
      goto LABEL_33;
    }
LABEL_38:
    if (v23 == 7)
    {
      CFArrayRef theArray = 0;
      (*(void (**)(unsigned char *__return_ptr))(**(void **)(v2 + 248) + 96))(buf);
      sub_100044D6C(&theArray, (CFTypeRef *)buf);
      sub_1000577C4((const void **)buf);
      if (theArray) {
        uint64_t v37 = sub_100083F10;
      }
      else {
        uint64_t v37 = 0;
      }
      if (v37)
      {
        unsigned int v53 = v22;
        char v54 = v34;
        CFIndex Count = CFArrayGetCount(theArray);
        if (Count)
        {
          for (CFIndex i = 0; Count != i; ++i)
          {
            ValueAtIndex = (int *)CFArrayGetValueAtIndex(theArray, i);
            uint64_t v41 = ValueAtIndex;
            if (ValueAtIndex && (CFTypeID v42 = CFGetTypeID(ValueAtIndex), v42 == CFNumberGetTypeID()))
            {
              *(_DWORD *)buf = 0;
              ctu::cf::assign((ctu::cf *)buf, v41, v43);
              int v44 = *(_DWORD *)buf;
              if (*(_DWORD *)buf > 0xFEu)
              {
                v46 = *(NSObject **)(v2 + 40);
                if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 67109378;
                  *(_DWORD *)&uint8_t buf[4] = v44;
                  *(_WORD *)&buf[8] = 2112;
                  *(void *)&buf[10] = v41;
                  uint64_t v47 = v46;
                  v48 = "IgnoreRejectCodesForPNROnLTE key carry incorrect value %d (%@), suppose to be of uint8_t size";
                  uint32_t v49 = 18;
LABEL_56:
                  _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, v48, buf, v49);
                }
              }
              else if (*(_DWORD *)buf == v24)
              {
                sub_100044D00((const void **)&theArray);
                char v34 = v54;
                long long v21 = (unsigned char *)&unk_101B12000;
                uint64_t v22 = v53;
                goto LABEL_33;
              }
            }
            else
            {
              v45 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = i;
                uint64_t v47 = v45;
                v48 = "IgnoreRejectCodesForPNROnLTE array has incorrect element at index %zu";
                uint32_t v49 = 12;
                goto LABEL_56;
              }
            }
          }
        }
        sub_100044D00((const void **)&theArray);
        char v34 = v54;
      }
      else
      {
        sub_100044D00((const void **)&theArray);
        if (v24 == 7 || v24 == 10)
        {
LABEL_33:
          long long v35 = *(NSObject **)(v2 + 40);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v36 = asString();
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = v36;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v24;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I %s: Sending notification for iMessage registration failure, reject code %d", buf, 0x12u);
          }
          if (v33) {
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)v33 + 32))(v33, v22, 0);
          }
          v21[3712] = 1;
LABEL_60:
          if ((v34 & 1) == 0) {
            sub_10004D2C8(v32);
          }
          goto LABEL_62;
        }
      }
    }
    v50 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v51 = asString();
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = v51;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v24;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#N RAT %s not sending phone number registration state notification for cause code %d", buf, 0x12u);
    }
    goto LABEL_60;
  }
LABEL_62:
  sub_100EBD778(&v56);
  return sub_100046B58((uint64_t *)&v55);
}

void sub_100EBD6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, char a9, ...)
{
  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v13 = va_arg(va2, void);
  sub_100044D00((const void **)va2);
  if ((a9 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  sub_100EBD778((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EBD778(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100EBD7E0(uint64_t a1)
{
  *(void *)a1 = off_101A68428;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

void sub_100EBD830(uint64_t a1)
{
  *(void *)a1 = off_101A68428;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  operator delete();
}

void *sub_100EBD8A0(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A68428;
  sub_100EBD170((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100EBD8F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EBD908(uint64_t a1, void *a2)
{
  *a2 = off_101A68428;
  return sub_100EBD170((uint64_t)(a2 + 1), (long long *)(a1 + 8));
}

void sub_100EBD934(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

void sub_100EBD948(void **__p)
{
  if (*((char *)__p + 55) < 0) {
    operator delete(__p[4]);
  }

  operator delete(__p);
}

void sub_100EBD98C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  uint64_t v3 = *(void **)(a2 + 8);
  *(_DWORD *)uint64_t v7 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)&v7[3] = *(_DWORD *)(a2 + 19);
  int v5 = *(char *)(a2 + 23);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v5 < 0)
  {
    sub_10004FC84(v8, v4, (unint64_t)v3);
  }
  else
  {
    v8[0] = v4;
    v8[1] = v3;
    *(_DWORD *)uint64_t v9 = *(_DWORD *)v7;
    *(_DWORD *)&v9[3] = *(_DWORD *)&v7[3];
    char v10 = v5;
  }
  if (*(char *)(a1 + 55) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 32);
    __p[2] = *(void **)(a1 + 48);
  }
  char v12 = *(unsigned char *)(a1 + 56);
  v13[0] = 0;
  v13[1] = 0;
  sub_10003E168(v13, (void *)(v6 + 8));
  operator new();
}

void sub_100EBDB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EBDBC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EBDC08()
{
}

uint64_t *sub_100EBDC14(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = *(void *)v1;
  (*(void (**)(void, void, void, void))(**(void **)(*(void *)v1 + 344) + 168))(*(void *)(*(void *)v1 + 344), *(unsigned int *)(v1 + 8), *(unsigned __int8 *)(v1 + 12), *(unsigned int *)(v1 + 16));
  uint64_t v3 = *(void *)(v2 + 344);
  uint64_t v4 = *(unsigned int *)(v1 + 8);
  uint64_t v5 = *(unsigned __int8 *)(v1 + 12);
  uint64_t v6 = *(unsigned int *)(v1 + 16);
  uint64_t v7 = *(unsigned __int8 *)(v1 + 47);
  if ((v7 & 0x80u) == 0) {
    uint64_t v8 = *(unsigned __int8 *)(v1 + 47);
  }
  else {
    uint64_t v8 = *(void *)(v1 + 32);
  }
  uint64_t v9 = *(unsigned __int8 *)(v1 + 71);
  int v10 = (char)v9;
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(v1 + 56);
  }
  if (v8 == v9)
  {
    uint64_t v11 = (const void **)(v1 + 24);
    if (v10 >= 0) {
      char v12 = (unsigned __int8 *)(v1 + 48);
    }
    else {
      char v12 = *(unsigned __int8 **)(v1 + 48);
    }
    if ((v7 & 0x80) != 0)
    {
      BOOL v20 = memcmp(*v11, v12, *(void *)(v1 + 32)) == 0;
    }
    else if (*(unsigned char *)(v1 + 47))
    {
      uint64_t v13 = v7 - 1;
      do
      {
        int v15 = *(unsigned __int8 *)v11;
        uint64_t v11 = (const void **)((char *)v11 + 1);
        int v14 = v15;
        int v17 = *v12++;
        int v16 = v17;
        BOOL v19 = v13-- != 0;
        BOOL v20 = v14 == v16;
      }
      while (v14 == v16 && v19);
    }
    else
    {
      BOOL v20 = 1;
    }
  }
  else
  {
    BOOL v20 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, BOOL, void))(*(void *)v3 + 160))(v3, v4, v5, v6, v20, *(unsigned __int8 *)(v1 + 72));
  sub_100EBD778(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100EBDD74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EBDD90(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v59 = a1;
  uint64_t v60 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v79 = 0;
  long long v80 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v79);
  uint64_t v3 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
  uint64_t v4 = (os_log_t *)v3;
  if (v79)
  {
    if ((capabilities::ct::supportsEmptyNITZIndication(v3) & 1) == 0 && *(unsigned char *)(v1 + 80))
    {
      uint64_t v5 = *v4;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      *(_WORD *)buf = 0;
      uint64_t v6 = "#N Ignoring empty NITZ indication";
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
      goto LABEL_78;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
    uint64_t v8 = ServiceMap;
    uint64_t v10 = v9;
    if (v9 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)buf = v10;
    int v14 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      int v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v8);
    int v15 = 0;
    char v17 = 1;
LABEL_16:
    *(_DWORD *)(v1 + 16) = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 88))(v16);
    if ((v17 & 1) == 0) {
      sub_10004D2C8(v15);
    }
    BOOL v19 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *(_DWORD *)(v1 + 16);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Processing Network Time update, timestamped with %d", buf, 8u);
    }
    if (*(_DWORD *)(v1 + 84) == 4)
    {
      uint64_t v5 = *v4;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      *(_WORD *)buf = 0;
      uint64_t v6 = "#N RAT is set to EVDO, cannot process Time from EVDO source";
      goto LABEL_23;
    }
    (*(void (**)(void, void))(**(void **)(v2 + 120) + 32))(*(void *)(v2 + 120), *(unsigned int *)(v1 + 48));
    (*(void (**)(void, void))(**(void **)(v2 + 120) + 40))(*(void *)(v2 + 120), *(unsigned int *)(v1 + 72));
    long long v77 = 0u;
    long long v78 = 0u;
    if (*(unsigned char *)(v1 + 120)) {
      MCC::MCC((MCC *)&v77, (const MCC *)(v1 + 88));
    }
    else {
      (*(void (**)(long long *__return_ptr))(*(void *)v79 + 632))(&v77);
    }
    *(_OWORD *)uint64_t v75 = 0u;
    long long v76 = 0u;
    if (*(unsigned char *)(v1 + 160)) {
      MCC::MCC((MCC *)v75, (const MCC *)(v1 + 128));
    }
    else {
      (*(void (**)(void **__return_ptr))(*(void *)v79 + 640))(v75);
    }
    if (*(_DWORD *)(v1 + 44))
    {
      long long v21 = (long long *)(v1 + 24);
      uint64_t v22 = *(void *)(v2 + 120);
      long long v24 = *(_OWORD *)(v1 + 24);
      long long v23 = *(_OWORD *)(v1 + 40);
      uint64_t v84 = *(void *)(v1 + 72);
      long long v25 = *(_OWORD *)(v1 + 56);
      long long v82 = v23;
      long long v83 = v25;
      *(_OWORD *)buf = v24;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v22 + 24))(v22, buf);
      uint64_t v26 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
      uint64_t v27 = v26;
      if (v9 < 0)
      {
        uint64_t v28 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v29 = 5381;
        do
        {
          uint64_t v9 = v29;
          unsigned int v30 = *v28++;
          uint64_t v29 = (33 * v29) ^ v30;
        }
        while (v30);
      }
      std::mutex::lock(v26);
      *(void *)uint64_t v71 = v9;
      int v31 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)v71);
      if (v31)
      {
        uint64_t v33 = v31[3];
        int v32 = (std::__shared_weak_count *)v31[4];
        if (v32)
        {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v27);
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v32);
          char v34 = 0;
          goto LABEL_46;
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
      std::mutex::unlock(v27);
      int v32 = 0;
      char v34 = 1;
LABEL_46:
      int v44 = *v4;
      if (v33)
      {
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v71 = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Received a valid network time, sending it to time handler", v71, 2u);
        }
        uint64_t v45 = *(unsigned int *)(v1 + 8);
        long long v46 = *v21;
        long long v47 = *(_OWORD *)(v1 + 40);
        uint64_t v74 = *(void *)(v1 + 72);
        long long v48 = *(_OWORD *)(v1 + 56);
        long long v72 = v47;
        long long v73 = v48;
        *(_OWORD *)uint64_t v71 = v46;
        uint64_t v49 = *(unsigned int *)(v1 + 16);
        MCC::MCC((MCC *)v68, (const MCC *)&v77);
        MCC::MCC((MCC *)v65, (const MCC *)v75);
        (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, unsigned char *, unsigned char *, void, uint64_t, uint64_t *, uint64_t))(*(void *)v33 + 48))(v33, v45, v71, v49, v68, v65, *(unsigned int *)(v1 + 84), 1, v59, v60);
        if (v67 < 0) {
          operator delete(__p);
        }
        if (v70 < 0)
        {
          operator delete(v69);
          if (v34) {
            goto LABEL_57;
          }
          goto LABEL_56;
        }
      }
      else if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v71 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Could not get TimeHandler for sending network time update", v71, 2u);
        if (v34) {
          goto LABEL_57;
        }
        goto LABEL_56;
      }
      if (v34)
      {
LABEL_57:
        uint64_t v50 = *(void *)(v2 + 312);
        long long v51 = *v21;
        long long v52 = *(_OWORD *)(v1 + 56);
        long long v62 = *(_OWORD *)(v1 + 40);
        long long v63 = v52;
        uint64_t v64 = *(void *)(v1 + 72);
        *(_OWORD *)char v61 = v51;
        (*(void (**)(uint64_t, void **))(*(void *)v50 + 120))(v50, v61);
LABEL_74:
        if (SHIBYTE(v76) < 0) {
          operator delete(v75[1]);
        }
        if (SHIBYTE(v78) < 0) {
          operator delete(*((void **)&v77 + 1));
        }
        goto LABEL_78;
      }
LABEL_56:
      sub_10004D2C8(v32);
      goto LABEL_57;
    }
    uint64_t v84 = 0xFFFFFFFFLL;
    long long v82 = 0u;
    long long v83 = 0u;
    *(_OWORD *)buf = 0u;
    if (!(*(unsigned int (**)(void, uint8_t *))(**(void **)(v2 + 120) + 48))(*(void *)(v2 + 120), buf))
    {
      unsigned int v53 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v71 = 0;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I Time value is not cached, not sending the time value", v71, 2u);
      }
      goto LABEL_74;
    }
    long long v35 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 136));
    uint64_t v36 = v35;
    if (v9 < 0)
    {
      uint64_t v37 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v38 = 5381;
      do
      {
        uint64_t v9 = v38;
        unsigned int v39 = *v37++;
        uint64_t v38 = (33 * v38) ^ v39;
      }
      while (v39);
    }
    std::mutex::lock(v35);
    *(void *)uint64_t v71 = v9;
    v40 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)v71);
    if (v40)
    {
      uint64_t v42 = v40[3];
      uint64_t v41 = (std::__shared_weak_count *)v40[4];
      if (v41)
      {
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v36);
        atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v41);
        char v43 = 0;
LABEL_62:
        char v54 = *v4;
        BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
        if (v42)
        {
          if (v55)
          {
            *(_WORD *)uint64_t v71 = 0;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Retrieving the time saved time value and sending the update", v71, 2u);
          }
          uint64_t v56 = *(unsigned int *)(v1 + 8);
          uint64_t v74 = v84;
          long long v72 = v82;
          long long v73 = v83;
          *(_OWORD *)uint64_t v71 = *(_OWORD *)buf;
          uint64_t v57 = *(unsigned int *)(v1 + 16);
          MCC::MCC((MCC *)v61, (const MCC *)&v77);
          MCC::MCC((MCC *)v68, (const MCC *)v75);
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, void **, unsigned char *, void, uint64_t, uint64_t *, uint64_t))(*(void *)v42 + 56))(v42, v56, v71, v57, v61, v68, *(unsigned int *)(v1 + 84), 1, v59, v60);
          if (v70 < 0) {
            operator delete(v69);
          }
          if (SHIBYTE(v62) < 0) {
            operator delete(v61[1]);
          }
        }
        else if (v55)
        {
          *(_WORD *)uint64_t v71 = 0;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#N Could not get TimeHandler to send network time zone update", v71, 2u);
        }
        if ((v43 & 1) == 0) {
          sub_10004D2C8(v41);
        }
        (*(void (**)(void, void, BOOL))(**(void **)(v2 + 312) + 128))(*(void *)(v2 + 312), DWORD2(v82), v84 != 0);
        goto LABEL_74;
      }
    }
    else
    {
      uint64_t v42 = 0;
    }
    std::mutex::unlock(v36);
    uint64_t v41 = 0;
    char v43 = 1;
    goto LABEL_62;
  }
  unint64_t v18 = *(NSObject **)v3;
  if (os_log_type_enabled(*(os_log_t *)v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not find model for network time update", buf, 2u);
  }
LABEL_78:
  if (v80) {
    sub_10004D2C8(v80);
  }
  sub_100EBE73C(&v60);
  return sub_100046B58((uint64_t *)&v59);
}

void sub_100EBE630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if ((v51 & 1) == 0) {
    sub_10004D2C8(v50);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  if (*(char *)(v52 - 161) < 0) {
    operator delete(*(void **)(v52 - 184));
  }
  char v54 = *(std::__shared_weak_count **)(v52 - 152);
  if (v54) {
    sub_10004D2C8(v54);
  }
  sub_100EBE73C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EBE73C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 160) && *(char *)(v1 + 159) < 0) {
      operator delete(*(void **)(v1 + 136));
    }
    if (*(unsigned char *)(v1 + 120))
    {
      if (*(char *)(v1 + 119) < 0) {
        operator delete(*(void **)(v1 + 96));
      }
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100EBE7B4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100EBE808(unsigned __int8 *a1)
{
  uint64_t v11 = a1;
  v18[0] = 0;
  v18[1] = 0;
  uint64_t v19 = 0;
  sub_100058DB0(v18, "RAT selection failed");
  ratSelectionAsStr((uint64_t *)&v12, a1[16]);
  uint64_t v2 = std::string::insert(&v12, 0, "Changing the RAT to ", 0x14uLL);
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v13.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  uint64_t v4 = std::string::append(&v13, " failed\n\n", 9uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v14, "Please file a radar against Telephony | iOS\n", 0x2CuLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  uint64_t v8 = std::string::append(&v15, "This is shown on internal and carrier installations only", 0x38uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  std::string::size_type v17 = v8->__r_.__value_.__r.__words[2];
  long long v16 = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  (*(void (**)(void, void **, long long *))(**(void **)a1 + 24))(*(void *)a1, v18, &v16);
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  return sub_100EBE7B4((uint64_t *)&v11);
}

void sub_100EBE9A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v35 - 41) < 0) {
    operator delete(*(void **)(v35 - 64));
  }
  if (*(char *)(v35 - 17) < 0) {
    operator delete(*(void **)(v35 - 40));
  }
  sub_100EBE7B4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100EBEA44(std::string *a1, char *a2)
{
  if (a2) {
    sub_10003ED78(a1 + 1, a2);
  }
  return 1;
}

uint64_t sub_100EBEA6C(const std::string *a1, std::string *this)
{
  std::string::operator=(this, a1 + 1);
  return 1;
}

BOOL sub_100EBEA94(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  CFStringEncoding v6 = sub_100F5EC24(a3);
  if (v6 == -1) {
    return 0;
  }
  CFStringEncoding v7 = v6;
  CFStringEncoding v8 = sub_100F5EC24(a4);
  if (v8 == -1) {
    return 0;
  }
  CFStringEncoding v9 = v8;
  int v10 = *(char *)(a1 + 23);
  uint64_t v11 = v10 >= 0 ? (const UInt8 *)a1 : *(const UInt8 **)a1;
  CFIndex v12 = v10 >= 0 ? *(unsigned __int8 *)(a1 + 23) : *(void *)(a1 + 8);
  CFStringRef v13 = CFStringCreateWithBytes(0, v11, v12, v7, 0);
  if (!v13) {
    return 0;
  }
  CFStringRef v14 = v13;
  CFIndex Length = CFStringGetLength(v13);
  CFIndex maxBufLen = 0;
  v19.location = 0;
  v19.length = Length;
  CFStringGetBytes(v14, v19, v9, 0x3Fu, 0, 0, 0, &maxBufLen);
  BOOL v16 = maxBufLen != 0;
  if (maxBufLen) {
    operator new[]();
  }
  CFRelease(v14);
  return v16;
}

void sub_100EBEC00()
{
}

void sub_100EBEC8C()
{
}

void sub_100EBECB0()
{
}

void sub_100EBED58()
{
}

uint64_t sub_100EBED7C(std::string *a1, uint64_t a2)
{
  return sub_100FECA4C(a2, a1 + 1);
}

uint64_t sub_100EBED8C(uint64_t a1, uint64_t a2)
{
  long long v3 = (unsigned char *)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    long long v3 = *(unsigned char **)v3;
  }
  sub_10078E78C(a2, v3);
  return 1;
}

const char *sub_100EBEDC0()
{
  return "text-string";
}

void sub_100EBEDCC()
{
}

void sub_100EBEE58()
{
}

void sub_100EBEE7C()
{
}

void sub_100EBEF24()
{
}

uint64_t sub_100EBEF48(std::string *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 20);
  if (v2 < *(_DWORD *)(a2 + 16)) {
    *(_DWORD *)(a2 + 20) = v2 + 1;
  }
  return sub_100FEC944(a2, a1 + 1, 0xFFFFFFFF);
}

uint64_t sub_100EBEF70(uint64_t a1, uint64_t a2)
{
  std::string::push_back((std::string *)(a2 + 8), 34);
  uint64_t v4 = (unsigned char *)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    uint64_t v4 = *(unsigned char **)v4;
  }
  sub_10078E554(a2, v4);
  return 1;
}

const char *sub_100EBEFBC()
{
  return "quoted-string";
}

void sub_100EBEFC8()
{
}

void sub_100EBF05C()
{
}

void sub_100EBF080()
{
}

void sub_100EBF130()
{
}

uint64_t sub_100EBF154(uint64_t a1, uint64_t a2)
{
  int v3 = 0;
  return sub_100FECBF4(a2, (std::string *)(a1 + 24), (unsigned int *)(a1 + 48), &v3);
}

uint64_t sub_100EBF18C(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_100EBF1B8(uint64_t a1, char *a2)
{
  *(_DWORD *)(a1 + 48) = 3;
  LOBYTE(v2) = *a2;
  if (*a2)
  {
    unsigned int v3 = 1;
    while ((v2 & 0x80) == 0)
    {
      int v2 = a2[v3++];
      if (!v2) {
        goto LABEL_7;
      }
    }
    *(_DWORD *)(a1 + 48) = 106;
  }
LABEL_7:
  sub_10003ED78((std::string *)(a1 + 24), a2);
  return 1;
}

const char *sub_100EBF208()
{
  return "encoded-string";
}

uint64_t sub_100EBF214()
{
  return 1;
}

void sub_100EBF21C()
{
}

void sub_100EBF2B0()
{
}

void sub_100EBF2D4()
{
}

void sub_100EBF384()
{
}

uint64_t sub_100EBF3A8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)buf = 0;
  unsigned int v3 = (std::string *)(a1 + 24);
  uint64_t v4 = sub_100FECBF4(a2, (std::string *)(a1 + 24), (unsigned int *)(a1 + 48), buf);
  if (qword_101B14178 != -1) {
    dispatch_once(&qword_101B14178, &stru_101A84F28);
  }
  long long v5 = qword_101B14170;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
  if (v4)
  {
    if (v6)
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "About to decode the subject private -> public", buf, 2u);
    }
    uint64_t v7 = *(unsigned int *)(a2 + 36);
    Registry::get((uint64_t *)&v9, (Registry *)v6);
    *(_OWORD *)buf = v9;
    long long v9 = 0uLL;
    sub_10079694C(v7, (Registry **)buf, v3, 1);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (*((void *)&v9 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v9 + 1));
    }
  }
  else if (v6)
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not decode subject header value!", buf, 2u);
  }
  return v4;
}

void sub_100EBF4E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EBF508(uint64_t a1, unsigned int *a2)
{
  memset(&__p, 0, sizeof(__p));
  if (*(char *)(a1 + 47) < 0) {
    sub_10004FC84(&__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else {
    std::string __p = *(std::string *)(a1 + 24);
  }
  if (qword_101B14178 != -1) {
    dispatch_once(&qword_101B14178, &stru_101A84F28);
  }
  uint64_t v4 = qword_101B14170;
  BOOL v5 = os_log_type_enabled((os_log_t)qword_101B14170, OS_LOG_TYPE_ERROR);
  if (v5)
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "About to encode the subject public -> private", buf, 2u);
  }
  uint64_t v6 = *a2;
  Registry::get((uint64_t *)&v8, (Registry *)v5);
  *(_OWORD *)buf = v8;
  long long v8 = 0uLL;
  sub_10079694C(v6, (Registry **)buf, &__p, 0);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  sub_10078E7E0((uint64_t)a2, (uint64_t)&__p, *(_DWORD *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 1;
}

void sub_100EBF644(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EBF684()
{
}

void sub_100EBF734()
{
}

void sub_100EBF758()
{
}

void sub_100EBF7EC()
{
}

void sub_100EBF810()
{
}

void sub_100EBF8A8()
{
}

void sub_100EBF8CC()
{
}

void sub_100EBF97C()
{
}

uint64_t sub_100EBF9A0(uint64_t a1, uint64_t a2)
{
  int v6 = 0;
  int v4 = sub_100FECA8C(a2, &v6);
  uint64_t result = 0;
  if (v4)
  {
    uint64_t result = sub_100FECBAC(a2, (int *)(a1 + 52));
    if (result)
    {
      int v7 = 0;
      return sub_100FECBF4(a2, (std::string *)(a1 + 24), (unsigned int *)(a1 + 48), &v7);
    }
  }
  return result;
}

uint64_t sub_100EBFA10(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  LODWORD(__p[0]) = *(_DWORD *)a2;
  uint64_t v10 = 0;
  __p[1] = 0;
  long long v9 = 0uLL;
  sub_10078E66C((uint64_t)__p, *(_DWORD *)(a1 + 52));
  sub_10078E7E0((uint64_t)__p, a1 + 24, *(_DWORD *)(a1 + 48));
  if (v9 >= 0) {
    unsigned int v4 = HIBYTE(v9);
  }
  else {
    unsigned int v4 = v9;
  }
  sub_10078E718(a2, v4);
  if (v9 >= 0) {
    BOOL v5 = (const std::string::value_type *)&__p[1];
  }
  else {
    BOOL v5 = (const std::string::value_type *)__p[1];
  }
  if (v9 >= 0) {
    std::string::size_type v6 = HIBYTE(v9);
  }
  else {
    std::string::size_type v6 = v9;
  }
  std::string::append((std::string *)(a2 + 8), v5, v6);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  return 1;
}

void sub_100EBFAD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100EBFAF4()
{
  return "indexed-encoded-string";
}

uint64_t sub_100EBFB08(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100EBFB58(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

uint64_t sub_100EBFBC8(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100EBFC18(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

uint64_t sub_100EBFC88(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100EBFCD8(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

uint64_t sub_100EBFD48(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100EBFD98(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

uint64_t sub_100EBFE08(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100EBFE58(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

uint64_t sub_100EBFEC8(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100EBFF18(uint64_t a1)
{
  *(void *)a1 = off_101A684A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

void sub_100EC0038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC0184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100EC02B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100EC0608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC09C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC0BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  char v7 = v6;
  if ((v7 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  sub_1000558F4((const void **)va);

  _Unwind_Resume(a1);
}

void sub_100EC0CEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC0ED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC13C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC1628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100EC1CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _Unwind_Exception *exception_object, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void sub_100EC22C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC2508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100EC27E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100EC2904(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unsigned int v4 = ServiceMap;
  if (v5 < 0)
  {
    char v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v13.var0 = (char *)v5;
  long long v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v13);
  if (v9)
  {
    uint64_t v11 = (GestaltUtilityInterface *)v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11) {
    goto LABEL_13;
  }
LABEL_10:
  if ((GestaltUtilityInterface::isIPad(v11) & 1) != 0 || GestaltUtilityInterface::isIPhone(v11)) {
    operator new();
  }
LABEL_13:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_100EC2B60(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EC2C1C(uint64_t a1)
{
  FollowUpControllerInterface::~FollowUpControllerInterface((FollowUpControllerInterface *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100EC2C68(uint64_t a1)
{
  sub_100EC2C1C(a1);

  operator delete();
}

uint64_t sub_100EC2CA0(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  unsigned int v4 = a4;
  if (!a4)
  {
    v9[0] = 0;
    v9[1] = 0;
    sub_100EC2D2C(a1, a2, v9, &v10);
    unsigned int v4 = v10;
    sub_1000558F4(&v10);
  }
  uint64_t result = sub_100EC2E54(a1, a2, (uint64_t)v4);
  if ((result & 1) == 0) {
    return (uint64_t)[*(id *)(a1 + 32) showFollowUp:a2 userInfo:a3 withUniqueIdentifier:v4];
  }
  return result;
}

void sub_100EC2D2C(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X2>, void *a4@<X8>)
{
  if (a2 == 7)
  {
    uint64_t v5 = +[NSString stringWithFormat:@"%@.%@", @"com.apple.coretelephony.cellularplan-default.setup-required", @"no.sim"];
LABEL_11:
    sub_100056210(a4, v5);
    return;
  }
  if (*a3)
  {
    if ((a2 - 1) > 7) {
      CFStringRef v6 = &stru_101AC1B28;
    }
    else {
      CFStringRef v6 = off_101A68A10[a2 - 1];
    }
    uint64_t v5 = +[NSString stringWithFormat:@"%@.%u", v6, subscriber::simSlotAsInstance()];
    goto LABEL_11;
  }
  uint64_t v7 = sub_100200FB4((id *)(a1 + 8));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I No unique identifier defined", buf, 2u);
  }

  *a4 = 0;
}

uint64_t sub_100EC2E54(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v4 = [*(id *)(a1 + 32) getPendingFollowUpItems];
  uint64_t v26 = v4;
  if (v4)
  {
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v5 = v4;
    id v6 = [v5 countByEnumeratingWithState:&v28 objects:v36 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v29;
      uint64_t v8 = a2 - 1;
      while (2)
      {
        for (CFIndex i = 0; i != v6; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v29 != v7) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = *(void **)(*((void *)&v28 + 1) + 8 * i);
          if (v10)
          {
            uint64_t v11 = [*(id *)(*((void *)&v28 + 1) + 8 * i) extensionIdentifier];
            unsigned __int8 v12 = [v11 isEqualToString:@"com.apple.CoreTelephony.CTFollowUpExtension"];

            if (v12)
            {
              OsLogContext v13 = [v10 categoryIdentifier];
              CFStringRef v14 = v13;
              CFStringRef v15 = &stru_101AC1B28;
              if (v8 <= 7) {
                CFStringRef v15 = off_101A68A50[v8];
              }
              unsigned __int8 v16 = [v13 isEqualToString:v15];

              if (v16)
              {
                std::string::size_type v17 = [v10 uniqueIdentifier];
                BOOL v18 = v17 == 0;

                if (!v18)
                {
                  CFRange v19 = [v10 uniqueIdentifier];
                  unsigned int v20 = [v19 isEqualToString:a3];

                  if (v20)
                  {
                    uint64_t v22 = sub_100200FB4((id *)(a1 + 8));
                    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412546;
                      uint64_t v33 = v10;
                      __int16 v34 = 2112;
                      uint64_t v35 = a3;
                      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Same followup item exists: %@ with uniqueIdentifier: %@", buf, 0x16u);
                    }

                    uint64_t v21 = 1;
                    goto LABEL_21;
                  }
                }
              }
            }
          }
        }
        id v6 = [v5 countByEnumeratingWithState:&v28 objects:v36 count:16];
        if (v6) {
          continue;
        }
        break;
      }
    }
    uint64_t v21 = 0;
LABEL_21:
  }
  else
  {
    uint64_t v21 = 0;
  }

  return v21;
}

void sub_100EC30C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100EC310C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) clearFollowUp:a2];
}

id sub_100EC3118(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) clearFollowUpWithUID:a2];
}

void sub_100EC3124(uint64_t a1, int a2, uint64_t a3)
{
  if ((a2 - 1) > 7) {
    CFStringRef v4 = &stru_101AC1B28;
  }
  else {
    CFStringRef v4 = off_101A68A50[a2 - 1];
  }
  id v5 = +[NSString stringWithFormat:@"%@.%@", v4, a3];
  objc_msgSend(*(id *)(a1 + 32), "clearFollowUpWithUID:");
}

void sub_100EC31B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

const void **sub_100EC31C4@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  *(void *)long long v28 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    id v5 = *(__CFDictionary **)v28;
    *(void *)long long v28 = Mutable;
    *(void *)&long long v32 = v5;
    sub_10005717C((const void **)&v32);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a1;
    uint64_t v26 = *(void *)(a1 + 16);
  }
  if (SHIBYTE(v26) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v31 = v26;
  }
  long long v29 = 0;
  if (SHIBYTE(v31) < 0)
  {
    sub_10004FC84(&v32, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v32 = __dst;
    uint64_t v33 = v31;
  }
  __int16 v34 = 0;
  if (ctu::cf::convert_copy())
  {
    id v6 = v29;
    long long v29 = v34;
    uint64_t v35 = v6;
    sub_1000558F4(&v35);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  uint64_t v27 = (uint64_t)v29;
  long long v29 = 0;
  sub_1000558F4(&v29);
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)__dst);
  }
  sub_10010F3F0(*(__CFDictionary **)v28, @"ServerURL", v27);
  sub_1000558F4((const void **)&v27);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    unint64_t v8 = *(void *)(a1 + 32);
    if (!v8) {
      goto LABEL_39;
    }
    sub_10004FC84(v23, *v7, v8);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 47)) {
      goto LABEL_39;
    }
    *(_OWORD *)long long v23 = *(_OWORD *)v7;
    uint64_t v24 = *(void *)(a1 + 40);
  }
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(&__dst, v23[0], (unint64_t)v23[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v23;
    uint64_t v31 = v24;
  }
  long long v29 = 0;
  if (SHIBYTE(v31) < 0)
  {
    sub_10004FC84(&v32, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v32 = __dst;
    uint64_t v33 = v31;
  }
  __int16 v34 = 0;
  if (ctu::cf::convert_copy())
  {
    long long v9 = v29;
    long long v29 = v34;
    uint64_t v35 = v9;
    sub_1000558F4(&v35);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  uint64_t v27 = (uint64_t)v29;
  long long v29 = 0;
  sub_1000558F4(&v29);
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)__dst);
  }
  sub_10010F3F0(*(__CFDictionary **)v28, @"MatchingID", v27);
  sub_1000558F4((const void **)&v27);
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[0]);
  }
LABEL_39:
  uint64_t v10 = (void **)(a1 + 48);
  if (*(char *)(a1 + 71) < 0)
  {
    unint64_t v11 = *(void *)(a1 + 56);
    if (!v11) {
      goto LABEL_58;
    }
    sub_10004FC84(v21, *v10, v11);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 71)) {
      goto LABEL_58;
    }
    *(_OWORD *)uint64_t v21 = *(_OWORD *)v10;
    uint64_t v22 = *(void *)(a1 + 64);
  }
  if (SHIBYTE(v22) < 0)
  {
    sub_10004FC84(&__dst, v21[0], (unint64_t)v21[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v21;
    uint64_t v31 = v22;
  }
  long long v29 = 0;
  if (SHIBYTE(v31) < 0)
  {
    sub_10004FC84(&v32, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v32 = __dst;
    uint64_t v33 = v31;
  }
  __int16 v34 = 0;
  if (ctu::cf::convert_copy())
  {
    unsigned __int8 v12 = v29;
    long long v29 = v34;
    uint64_t v35 = v12;
    sub_1000558F4(&v35);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  uint64_t v27 = (uint64_t)v29;
  long long v29 = 0;
  sub_1000558F4(&v29);
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)__dst);
  }
  sub_10010F3F0(*(__CFDictionary **)v28, @"CarrierName", v27);
  sub_1000558F4((const void **)&v27);
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
LABEL_58:
  OsLogContext v13 = (void **)(a1 + 72);
  if (*(char *)(a1 + 95) < 0)
  {
    unint64_t v14 = *(void *)(a1 + 80);
    if (!v14) {
      goto LABEL_77;
    }
    sub_10004FC84(v19, *v13, v14);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 95)) {
      goto LABEL_77;
    }
    *(_OWORD *)CFRange v19 = *(_OWORD *)v13;
    uint64_t v20 = *(void *)(a1 + 88);
  }
  if (SHIBYTE(v20) < 0)
  {
    sub_10004FC84(&__dst, v19[0], (unint64_t)v19[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v19;
    uint64_t v31 = v20;
  }
  long long v29 = 0;
  if (SHIBYTE(v31) < 0)
  {
    sub_10004FC84(&v32, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v32 = __dst;
    uint64_t v33 = v31;
  }
  __int16 v34 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v15 = v29;
    long long v29 = v34;
    uint64_t v35 = v15;
    sub_1000558F4(&v35);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  uint64_t v16 = (uint64_t)v29;
  uint64_t v27 = (uint64_t)v29;
  long long v29 = 0;
  sub_1000558F4(&v29);
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)__dst);
  }
  sub_10010F3F0(*(__CFDictionary **)v28, @"IccidHash", v16);
  sub_1000558F4((const void **)&v27);
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
LABEL_77:
  uint64_t v17 = *(unsigned __int8 *)(a1 + 119);
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *(void *)(a1 + 104);
  }
  if (v17) {
    sub_10012C97C(*(__CFDictionary **)v28, @"Cancel", (uint64_t)kCFBooleanFalse);
  }
  sub_10004EFE4(a2, (CFTypeRef *)v28);
  return sub_10005717C((const void **)v28);
}

void sub_100EC3714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,int a37,const void *a38,const void *a39)
{
  sub_1000558F4(&a39);
  if (*(char *)(v39 - 105) < 0) {
    operator delete(*(void **)(v39 - 128));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10005717C(&a38);
  _Unwind_Resume(a1);
}

const void **sub_100EC38B0@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  *(void *)uint64_t v21 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    long long v9 = *(__CFDictionary **)v21;
    *(void *)uint64_t v21 = Mutable;
    *(void *)&long long v25 = v9;
    sub_10005717C((const void **)&v25);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v19) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v24 = v19;
  }
  uint64_t v22 = 0;
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(&v25, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v25 = *(_OWORD *)__p;
    uint64_t v26 = v24;
  }
  uint64_t v27 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v10 = v22;
    uint64_t v22 = v27;
    long long v28 = v10;
    sub_1000558F4(&v28);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)v25);
  }
  uint64_t v20 = (uint64_t)v22;
  uint64_t v22 = 0;
  sub_1000558F4(&v22);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  sub_10010F3F0(*(__CFDictionary **)v21, @"ServerURL", v20);
  sub_1000558F4((const void **)&v20);
  if (SHIBYTE(v19) < 0) {
    operator delete(__dst[0]);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v11 = *(void *)(a1 + 8);
    if (!v11) {
      goto LABEL_39;
    }
    sub_10004FC84(v16, *(void **)a1, v11);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 23)) {
      goto LABEL_39;
    }
    *(_OWORD *)uint64_t v16 = *(_OWORD *)a1;
    uint64_t v17 = *(void *)(a1 + 16);
  }
  if (SHIBYTE(v17) < 0)
  {
    sub_10004FC84(__p, v16[0], (unint64_t)v16[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v16;
    uint64_t v24 = v17;
  }
  uint64_t v22 = 0;
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(&v25, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v25 = *(_OWORD *)__p;
    uint64_t v26 = v24;
  }
  uint64_t v27 = 0;
  if (ctu::cf::convert_copy())
  {
    unsigned __int8 v12 = v22;
    uint64_t v22 = v27;
    long long v28 = v12;
    sub_1000558F4(&v28);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)v25);
  }
  uint64_t v13 = (uint64_t)v22;
  uint64_t v20 = (uint64_t)v22;
  uint64_t v22 = 0;
  sub_1000558F4(&v22);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  sub_10010F3F0(*(__CFDictionary **)v21, @"CarrierName", v13);
  sub_1000558F4((const void **)&v20);
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
LABEL_39:
  if (*a3) {
    unint64_t v14 = sub_100080778;
  }
  else {
    unint64_t v14 = 0;
  }
  if (v14) {
    sub_1001C6A4C(*(__CFDictionary **)v21, @"PostData", *a3);
  }
  sub_10004EFE4(a4, (CFTypeRef *)v21);
  return sub_10005717C((const void **)v21);
}

void sub_100EC3BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,const void *a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a24);
  _Unwind_Resume(a1);
}

void sub_100EC3C94(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  id v6 = [*(id *)(a1 + 32) getPendingFollowUpItems];
  uint64_t v26 = v6;
  if (v6)
  {
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v7 = v6;
    id v8 = [v7 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v29;
      uint64_t v10 = a2 - 1;
      while (2)
      {
        unint64_t v11 = 0;
        do
        {
          if (*(void *)v29 != v9) {
            objc_enumerationMutation(v7);
          }
          unsigned __int8 v12 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v11);
          if (v12)
          {
            uint64_t v13 = [*(id *)(*((void *)&v28 + 1) + 8 * (void)v11) extensionIdentifier];
            unsigned __int8 v14 = [v13 isEqualToString:@"com.apple.CoreTelephony.CTFollowUpExtension"];

            if (v14)
            {
              CFStringRef v15 = [v12 categoryIdentifier];
              uint64_t v16 = v15;
              CFStringRef v17 = &stru_101AC1B28;
              if (v10 <= 7) {
                CFStringRef v17 = off_101A68A50[v10];
              }
              unsigned __int8 v18 = [v15 isEqualToString:v17];

              if (v18)
              {
                uint64_t v19 = [v12 uniqueIdentifier];
                BOOL v20 = v19 == 0;

                if (!v20)
                {
                  uint64_t v21 = [v12 uniqueIdentifier];
                  unsigned int v22 = [v21 isEqualToString:a3];

                  if (v22)
                  {
                    long long v23 = [v12 userInfo];
                    sub_10004EFAC(a4, v23);

                    goto LABEL_19;
                  }
                }
              }
            }
          }
          unint64_t v11 = (char *)v11 + 1;
        }
        while (v8 != v11);
        id v8 = [v7 countByEnumeratingWithState:&v28 objects:v32 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }
  }
  *a4 = 0;
LABEL_19:
}

void sub_100EC3EB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100EC3F00(uint64_t a1@<X0>, int a2@<W1>, uint64_t **a3@<X8>)
{
  uint64_t v37 = a3;
  a3[2] = 0;
  a3[1] = 0;
  *a3 = (uint64_t *)(a3 + 1);
  id v6 = [*(id *)(a1 + 32) getPendingFollowUpItems];
  if (v6)
  {
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    id v35 = v6;
    id obj = v6;
    id v7 = [obj countByEnumeratingWithState:&v47 objects:v53 count:16];
    if (v7)
    {
      uint64_t v8 = *(void *)v48;
      uint64_t v9 = (id *)(a1 + 8);
      uint64_t v38 = a2 - 1;
      do
      {
        for (CFIndex i = 0; i != v7; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v48 != v8) {
            objc_enumerationMutation(obj);
          }
          unint64_t v11 = *(void **)(*((void *)&v47 + 1) + 8 * i);
          if (v11)
          {
            unsigned __int8 v12 = [*(id *)(*((void *)&v47 + 1) + 8 * i) extensionIdentifier];
            unsigned __int8 v13 = [v12 isEqualToString:@"com.apple.CoreTelephony.CTFollowUpExtension"];

            if (v13)
            {
              unsigned __int8 v14 = [v11 categoryIdentifier];
              CFStringRef v15 = v14;
              CFStringRef v16 = &stru_101AC1B28;
              if (v38 <= 7) {
                CFStringRef v16 = off_101A68A50[v38];
              }
              unsigned __int8 v17 = objc_msgSend(v14, "isEqualToString:", v16, v35);

              if (v17)
              {
                unsigned __int8 v18 = [v11 uniqueIdentifier];
                BOOL v19 = v18 == 0;

                if (v19)
                {
                  long long v31 = sub_100200FB4(v9);
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(__p[0]) = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "No UID exists", (uint8_t *)__p, 2u);
                  }
                }
                else
                {
                  __p[0] = 0;
                  __p[1] = 0;
                  uint64_t v46 = 0;
                  id v20 = [v11 uniqueIdentifier];
                  sub_100058DB0(__p, (char *)[v20 UTF8String]);

                  uint64_t v21 = [v11 actions];
                  BOOL v22 = v21 == 0;

                  if (v22)
                  {
                    long long v23 = sub_100200FB4(v9);
                    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No user actions available", buf, 2u);
                    }
                  }
                  else
                  {
                    long long v43 = 0u;
                    long long v44 = 0u;
                    long long v41 = 0u;
                    long long v42 = 0u;
                    long long v23 = [v11 actions];
                    id v24 = [v23 countByEnumeratingWithState:&v41 objects:v52 count:16];
                    if (v24)
                    {
                      uint64_t v25 = *(void *)v42;
                      while (2)
                      {
                        for (j = 0; j != v24; j = (char *)j + 1)
                        {
                          if (*(void *)v42 != v25) {
                            objc_enumerationMutation(v23);
                          }
                          uint64_t v27 = *(void **)(*((void *)&v41 + 1) + 8 * (void)j);
                          long long v28 = [v27 userInfo];
                          BOOL v29 = v28 == 0;

                          if (!v29)
                          {
                            v40 = 0;
                            long long v32 = [v27 userInfo];
                            uint64_t v33 = v32;
                            v40 = v32;
                            if (v32) {
                              CFRetain(v32);
                            }

                            *(void *)buf = __p;
                            __int16 v34 = sub_100B6FE88(v37, __p, (uint64_t)&unk_10144E20E, (long long **)buf);
                            sub_100058140((const void **)v34 + 7, &v40);
                            sub_100057D78(&v40);
                            goto LABEL_33;
                          }
                          long long v30 = sub_100200FB4(v9);
                          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                          {
                            *(_WORD *)buf = 0;
                            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "No user info available", buf, 2u);
                          }
                        }
                        id v24 = [v23 countByEnumeratingWithState:&v41 objects:v52 count:16];
                        if (v24) {
                          continue;
                        }
                        break;
                      }
                    }
                  }
LABEL_33:

                  if (SHIBYTE(v46) < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
          }
        }
        id v7 = [obj countByEnumeratingWithState:&v47 objects:v53 count:16];
      }
      while (v7);
    }

    id v6 = v35;
  }
}

void sub_100EC433C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_10008E5B8(a11, *(void **)(a11 + 8));
  _Unwind_Resume(a1);
}

void *sub_100EC4404@<X0>(int a1@<W1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  if ((a1 - 1) > 7) {
    CFStringRef v4 = &stru_101AC1B28;
  }
  else {
    CFStringRef v4 = off_101A68A50[a1 - 1];
  }
  id v5 = +[NSString stringWithFormat:@"%@.%@", v4, a2];

  return sub_100056210(a3, v5);
}

void sub_100EC4484(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EC44BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100EC44EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100EC4530()
{
}

void sub_100EC4558()
{
}

void sub_100EC4674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (v15)
  {
    sub_10004D2C8(v15);
    if (!v14) {
      goto LABEL_3;
    }
  }
  else if (!v14)
  {
    goto LABEL_3;
  }
  dispatch_release(v14);
LABEL_3:
  operator delete();
}

uint64_t sub_100EC46E4(uint64_t a1, NSObject **a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)a4[1];
  v15[0] = *a4;
  v15[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v14 = *(void *)(a5 + 16);
  }
  sub_10045E7FC(a1, &object, a3, v15, "cp.mm.ret.tr", (long long *)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = &off_101A68AA0;
  uint64_t v11 = a4[1];
  *(void *)(a1 + 152) = *a4;
  *(void *)(a1 + 160) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 168) = 1;
  return a1;
}

void sub_100EC4800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, dispatch_object_t object)
{
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

CellularPlanProvisioningMonitorModeInterface *sub_100EC483C(CellularPlanProvisioningMonitorModeInterface *this)
{
  *(void *)this = &off_101A68AA0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  return sub_10045E9DC(this);
}

void sub_100EC489C(CellularPlanProvisioningMonitorModeInterface *a1)
{
  sub_100EC483C(a1);

  operator delete();
}

void sub_100EC48D4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    *(unsigned char *)(a1 + 168) = 0;
    sub_10045EEC8(a1, 0x100u);
    return;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 160);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 152);
      if (v4)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 24))(v4, a1 + 64);
        sub_10045EEC8(a1, 0x100u);
LABEL_13:
        sub_10004D2C8(v3);
        return;
      }
    }
  }
  else
  {
    char v3 = 0;
  }
  id v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v6 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "CellularPlanRetryTransferMonitorModeDelegate is not available", v6, 2u);
  }
  if (v3) {
    goto LABEL_13;
  }
}

void sub_100EC49D4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EC49EC(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I handling vinyl info update in monitor mode", buf, 2u);
  }
  char v3 = (std::__shared_weak_count *)a1[20];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = a1[19];
      if (v5)
      {
        if ((sIsProfileInstalled() & 1) != 0
          || (*(unsigned int (**)(uint64_t, void *))(*(void *)v5 + 32))(v5, a1 + 8))
        {
          (*(void (**)(void *, uint64_t))(*a1 + 40))(a1, 257);
        }
        goto LABEL_12;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  id v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)id v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "CellularPlanRetryTransferMonitorModeDelegate is not available", v7, 2u);
    if (!v4) {
      return;
    }
  }
  else if (!v4)
  {
    return;
  }
LABEL_12:
  sub_10004D2C8(v4);
}

void sub_100EC4B48(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EC4B64(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EC4C30(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100EC4D08);
  __cxa_rethrow();
}

void sub_100EC4C58(_Unwind_Exception *a1)
{
}

void sub_100EC4C70(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EC4CA8(uint64_t a1)
{
}

uint64_t sub_100EC4CC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100EC4D08(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100EC4D34(uint64_t a1)
{
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "call.branded");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *(void *)a1 = off_101A68B98;
  *(unsigned char *)(a1 + 16) = 0;
  return a1;
}

void sub_100EC4DE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  BrandedCallingHelperInterface::~BrandedCallingHelperInterface(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100EC4E18(uint64_t a1, uint64_t a2, const void **a3, std::string *a4, char *a5, uint64_t a6)
{
  memset(&__str, 0, sizeof(__str));
  if (*(char *)(a2 + 23) < 0) {
    sub_10004FC84(&__str, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __str = *(std::string *)a2;
  }
  int64_t v10 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  char v11 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  std::string::size_type size = __str.__r_.__value_.__l.__size_;
  std::string::size_type v13 = __str.__r_.__value_.__r.__words[0];
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t v14 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    int64_t v14 = __str.__r_.__value_.__l.__size_;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  if (v14 < 4) {
    goto LABEL_36;
  }
  long long v95 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  std::string __p = a5;
  uint64_t v98 = a4;
  CFStringRef v16 = p_str;
  unsigned __int8 v17 = (char *)p_str + v14;
  uint64_t v18 = v14;
  BOOL v19 = p_str;
  uint64_t v104 = a3;
  do
  {
    id v20 = memchr(v19, 46, v18 - 3);
    if (!v20) {
      break;
    }
    uint64_t v21 = (char *)v20;
    if (*v20 == 1735420462) {
      goto LABEL_16;
    }
    BOOL v19 = (std::string *)((char *)v20 + 1);
    uint64_t v18 = v17 - (v21 + 1);
  }
  while (v18 > 3);
  uint64_t v21 = (char *)p_str + v14;
LABEL_16:
  BOOL v22 = (char *)p_str + v14;
  if (v14 < 5) {
    goto LABEL_25;
  }
  uint64_t v23 = v14;
  id v24 = p_str;
  while (1)
  {
    uint64_t v25 = (char *)memchr(v24, 46, v23 - 4);
    if (!v25)
    {
LABEL_24:
      BOOL v22 = (char *)p_str + v14;
      goto LABEL_25;
    }
    BOOL v22 = v25;
    if (*(_DWORD *)v25 == 1701866030 && v25[4] == 103) {
      break;
    }
    id v24 = (std::string *)(v25 + 1);
    uint64_t v23 = v17 - (v22 + 1);
    if (v23 <= 4) {
      goto LABEL_24;
    }
  }
  do
  {
LABEL_25:
    uint64_t v27 = (char *)memchr(v16, 46, v14 - 3);
    if (!v27) {
      break;
    }
    if (*(_DWORD *)v27 == 1735290926) {
      goto LABEL_29;
    }
    CFStringRef v16 = (std::string *)(v27 + 1);
    int64_t v14 = v17 - (v27 + 1);
  }
  while (v14 > 3);
  uint64_t v27 = v17;
LABEL_29:
  a4 = v98;
  std::string::size_type v28 = v21 - (char *)p_str;
  if (v21 != v17 && v21 - (char *)p_str != -1)
  {
    std::string::size_type v29 = 4;
    a3 = v104;
    a5 = __p;
LABEL_35:
    std::string::replace(&__str, v28, v29, ".bmp", 4uLL);
    int64_t v10 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
    std::string::size_type v13 = __str.__r_.__value_.__r.__words[0];
    char v11 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    goto LABEL_36;
  }
  a5 = __p;
  if (v22 != v17 && v22 - (char *)p_str != -1)
  {
    std::string::size_type v29 = 5;
    std::string::size_type v28 = v22 - (char *)p_str;
    a3 = v104;
    goto LABEL_35;
  }
  a3 = v104;
  if (v27 == v17)
  {
    std::string::size_type size = *((void *)&v95 + 1);
    std::string::size_type v13 = v95;
  }
  else
  {
    std::string::size_type v28 = v27 - (char *)p_str;
    std::string::size_type size = *((void *)&v95 + 1);
    std::string::size_type v13 = v95;
    if (v27 - (char *)p_str != -1)
    {
      std::string::size_type v29 = 4;
      goto LABEL_35;
    }
  }
LABEL_36:
  if (v11 >= 0) {
    int64_t v30 = v10;
  }
  else {
    int64_t v30 = size;
  }
  if (v11 >= 0) {
    long long v31 = &__str;
  }
  else {
    long long v31 = (std::string *)v13;
  }
  if (v30 >= 1)
  {
    long long v32 = (char *)v31 + v30;
    uint64_t v33 = v31;
    do
    {
      __int16 v34 = memchr(v33, 63, v30);
      if (!v34) {
        break;
      }
      if (*v34 == 63)
      {
        if (v34 == v32) {
          break;
        }
        std::string::size_type v35 = v34 - (unsigned char *)v31;
        if (v34 - (unsigned char *)v31 == -1) {
          break;
        }
        uint64_t v36 = a5;
        uint64_t v37 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#E HTTP GET parameters not allowed", (uint8_t *)&buf, 2u);
        }
        std::string::basic_string(&buf, &__str, 0, v35, (std::allocator<char> *)&values);
        a5 = v36;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        goto LABEL_55;
      }
      uint64_t v33 = (std::string *)(v34 + 1);
      int64_t v30 = v32 - (unsigned char *)v33;
    }
    while (v32 - (unsigned char *)v33 >= 1);
  }
  std::string buf = __str;
LABEL_55:
  if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0) {
    operator delete(a4->__r_.__value_.__l.__data_);
  }
  *a4 = buf;
  if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v38 = a4->__r_.__value_.__l.__size_;
    if (v38)
    {
      uint64_t v39 = (unsigned __int8 *)a4->__r_.__value_.__r.__words[0];
      goto LABEL_62;
    }
    return 1;
  }
  std::string::size_type v38 = HIBYTE(a4->__r_.__value_.__r.__words[2]);
  if (!*((unsigned char *)&a4->__r_.__value_.__s + 23)) {
    return 1;
  }
  uint64_t v39 = (unsigned __int8 *)a4;
LABEL_62:
  v40 = &v39[v38];
  long long v41 = v39;
  long long v42 = v40;
  do
  {
    long long v43 = v41;
    long long v44 = v41;
    while (1)
    {
      int v45 = *v44++;
      if (v45 == 47) {
        break;
      }
      long long v43 = v44;
      if (v44 == v40)
      {
        long long v43 = v42;
        goto LABEL_68;
      }
    }
    long long v41 = v43 + 1;
    long long v42 = v43;
  }
  while (v44 != v40);
LABEL_68:
  if (v43 == v40 || (int64_t v46 = v43 - v39, v46 == -1))
  {
    uint64_t v87 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__str.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#E Cannot fetch malformed URL", (uint8_t *)&__str, 2u);
    }
    return 1;
  }
  std::string::basic_string(&__str, a4, v46 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&buf);
  if (a5[23] < 0) {
    operator delete(*(void **)a5);
  }
  *(std::string *)a5 = __str;
  sub_100062740((const void **)&theArray, a3);
  if (theArray) {
    long long v47 = sub_100083F10;
  }
  else {
    long long v47 = 0;
  }
  if (!v47)
  {
    uint64_t v89 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__str.__r_.__value_.__l.__data_) = 0;
      long long v90 = "#E Allowed Asset Server list is not found";
      goto LABEL_177;
    }
    goto LABEL_178;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v49 = Count;
  if (!Count)
  {
    uint64_t v89 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__str.__r_.__value_.__l.__data_) = 0;
      long long v90 = "#E BrandedCallingAssetServersAllowList is empty";
LABEL_177:
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, v90, (uint8_t *)&__str, 2u);
    }
LABEL_178:
    uint64_t v91 = 0;
    char v80 = 0;
    *(void *)((char *)v115 + 7) = 0;
    v115[0] = 0;
    goto LABEL_179;
  }
  if (Count < 1) {
    goto LABEL_173;
  }
  CFIndex v50 = 0;
  v99 = a4;
  uint64_t v100 = a6;
  CFIndex v96 = Count;
  while (2)
  {
    CFDictionaryRef theDict = 0;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex(theArray, v50);
    sub_10004EFE4(&theDict, (CFTypeRef *)&__str.__r_.__value_.__l.__data_);
    if (theDict) {
      char v51 = sub_100080778;
    }
    else {
      char v51 = 0;
    }
    if (!v51) {
      goto LABEL_152;
    }
    CFIndex v52 = CFDictionaryGetCount(theDict);
    memset(&buf, 0, sizeof(buf));
    sub_10004EE3C(&buf, v52);
    values = 0;
    char v110 = 0;
    uint64_t v111 = 0;
    sub_10004EE3C(&values, v52);
    CFDictionaryGetKeysAndValues(theDict, (const void **)buf.__r_.__value_.__l.__data_, (const void **)values);
    if (v52 != 2)
    {
      __pa = 0;
      char v80 = 0;
      *(void *)((char *)v115 + 7) = 0;
      v115[0] = 0;
      int v79 = 1;
      goto LABEL_147;
    }
    __pa = 0;
    char v105 = 0;
    unsigned int v53 = 0;
    char v54 = 0;
    char v107 = 0;
    long long v108 = 0uLL;
    v115[0] = 0;
    char v55 = 1;
    *(void *)((char *)v115 + 7) = 0;
    do
    {
      char v56 = v55;
      memset(&__str, 0, sizeof(__str));
      ctu::cf::assign();
      std::string v118 = __str;
      std::string::size_type v57 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v57 = v118.__r_.__value_.__l.__size_;
      }
      if (v57 == 6)
      {
        v58 = (std::string *)v118.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          v58 = &v118;
        }
        int data = (int)v58->__r_.__value_.__l.__data_;
        int v60 = WORD2(v58->__r_.__value_.__r.__words[0]);
        BOOL v62 = data == 1987208531 && v60 == 29285;
        if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_97:
          if (v62) {
            goto LABEL_98;
          }
          goto LABEL_103;
        }
      }
      else
      {
        BOOL v62 = 0;
        if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_97;
        }
      }
      operator delete(v118.__r_.__value_.__l.__data_);
      if (v62)
      {
LABEL_98:
        memset(&__str, 0, sizeof(__str));
        ctu::cf::assign();
        v118.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__l.__size_;
        std::string::size_type v63 = __str.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7);
        char v64 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v108) < 0) {
          operator delete(v54);
        }
        *(void *)&long long v108 = v118.__r_.__value_.__r.__words[0];
        *(void *)((char *)&v108 + 7) = *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7);
        HIBYTE(v108) = v64;
        char v54 = (char *)v63;
        goto LABEL_126;
      }
LABEL_103:
      memset(&__str, 0, sizeof(__str));
      ctu::cf::assign();
      std::string v118 = __str;
      std::string::size_type v65 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v65 = v118.__r_.__value_.__l.__size_;
      }
      if (v65 == 11)
      {
        char v66 = (std::string *)v118.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v66 = &v118;
        }
        std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
        uint64_t v68 = *(std::string::size_type *)((char *)v66->__r_.__value_.__r.__words + 3);
        BOOL v70 = v67 == 0x6369666974726543 && v68 == 0x6574616369666974;
        if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_115:
          if (v70) {
            goto LABEL_116;
          }
          goto LABEL_121;
        }
      }
      else
      {
        BOOL v70 = 0;
        if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_115;
        }
      }
      operator delete(v118.__r_.__value_.__l.__data_);
      if (v70)
      {
LABEL_116:
        memset(&__str, 0, sizeof(__str));
        ctu::cf::assign();
        v118.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__l.__size_;
        std::string::size_type v71 = __str.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7);
        char v72 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if (v105 < 0) {
          operator delete(v53);
        }
        v115[0] = v118.__r_.__value_.__r.__words[0];
        *(void *)((char *)v115 + 7) = *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7);
        char v105 = v72;
        __pa = (void *)v71;
        unsigned int v53 = (void *)v71;
        goto LABEL_126;
      }
LABEL_121:
      long long v73 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        memset(&__str, 0, sizeof(__str));
        ctu::cf::assign();
        std::string v118 = __str;
        uint64_t v74 = (std::string *)__str.__r_.__value_.__r.__words[0];
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v74 = &v118;
        }
        *(_DWORD *)uint64_t v116 = 136315138;
        int v117 = v74;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#E Unrecognized key %s", v116, 0xCu);
        if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v118.__r_.__value_.__l.__data_);
        }
      }
LABEL_126:
      char v55 = 0;
    }
    while ((v56 & 1) != 0);
    char v107 = v54;
    uint64_t v75 = (char *)HIBYTE(v99->__r_.__value_.__r.__words[2]);
    if ((char)v75 >= 0) {
      std::string::size_type v76 = (std::string::size_type)v99;
    }
    else {
      std::string::size_type v76 = v99->__r_.__value_.__r.__words[0];
    }
    if (v108 >= 0) {
      long long v77 = &v107;
    }
    else {
      long long v77 = (char **)v54;
    }
    if (v108 >= 0) {
      int64_t v78 = HIBYTE(v108);
    }
    else {
      int64_t v78 = v108;
    }
    if (v78)
    {
      __s = (unsigned char *)v76;
      int v97 = SHIBYTE(v108);
      if ((char)v75 < 0) {
        uint64_t v75 = (char *)v99->__r_.__value_.__l.__size_;
      }
      if ((uint64_t)v75 >= v78)
      {
        uint64_t v81 = (void *)v76;
        long long v82 = &v75[v76];
        int v83 = *(char *)v77;
        do
        {
          uint64_t v84 = &v75[-v78];
          if (v84 == (char *)-1) {
            break;
          }
          v85 = (char *)memchr(v81, v83, (size_t)(v84 + 1));
          if (!v85) {
            break;
          }
          long long v86 = v85;
          if (!memcmp(v85, v77, v78))
          {
            if (v86 != v82 && v86 - __s != -1)
            {
              int v79 = 1;
              goto LABEL_143;
            }
            break;
          }
          uint64_t v81 = v86 + 1;
          uint64_t v75 = (char *)(v82 - (v86 + 1));
        }
        while ((uint64_t)v75 >= v78);
      }
      if (v105 < 0) {
        operator delete(__pa);
      }
      int v79 = 0;
LABEL_143:
      a6 = v100;
      if (v97 < 0) {
LABEL_144:
      }
        operator delete(v54);
    }
    else
    {
      int v79 = 1;
      a6 = v100;
      if (SHIBYTE(v108) < 0) {
        goto LABEL_144;
      }
    }
    CFIndex v49 = v96;
    char v80 = v105;
LABEL_147:
    if (values)
    {
      char v110 = values;
      operator delete(values);
    }
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (!v79)
    {
LABEL_152:
      sub_100057D78((const void **)&theDict);
      if (++v50 == v49)
      {
LABEL_173:
        uint64_t v89 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__str.__r_.__value_.__l.__data_) = 0;
          long long v90 = "#E URL does not belong to any allowed asset server";
          goto LABEL_177;
        }
        goto LABEL_178;
      }
      continue;
    }
    break;
  }
  sub_100057D78((const void **)&theDict);
  uint64_t v91 = __pa;
LABEL_179:
  if (*(char *)(a6 + 23) < 0) {
    operator delete(*(void **)a6);
  }
  uint64_t v92 = v115[0];
  *(void *)a6 = v91;
  *(void *)(a6 + 8) = v92;
  *(void *)(a6 + 15) = *(void *)((char *)v115 + 7);
  *(unsigned char *)(a6 + 23) = v80;
  sub_100044D00((const void **)&theArray);
  uint64_t v93 = *(unsigned __int8 *)(a6 + 23);
  if ((v93 & 0x80u) != 0) {
    uint64_t v93 = *(void *)(a6 + 8);
  }
  return 2 * (v93 == 0);
}

void sub_100EC58B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, int a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,char a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC5984(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  int64_t v10 = +[NSURLSessionConfiguration ephemeralSessionConfiguration];
  objc_msgSend(v10, "set_sourceApplicationSecondaryIdentifier:", @"com.apple.CommCenter.BrandedCalling");
  [v10 setHTTPShouldSetCookies:0];
  [v10 setHTTPCookieAcceptPolicy:1];
  [v10 setHTTPCookieStorage:0];
  id v24 = objc_alloc((Class)NSOperationQueue);
  [v24 setMaxConcurrentOperationCount:1];
  char v11 = [BrandedCallingSessionDelegate alloc];
  id v12 = objc_alloc((Class)NSString);
  if (*((char *)a4 + 23) >= 0) {
    std::string::size_type v13 = a4;
  }
  else {
    std::string::size_type v13 = (uint64_t *)*a4;
  }
  id v14 = [v12 initWithCString:v13 encoding:4];
  [(BrandedCallingSessionDelegate *)v11 setPublicKeyHash:v14];

  CFStringRef v15 = +[NSURLSession sessionWithConfiguration:v10 delegate:v11 delegateQueue:v24];
  id v16 = objc_alloc((Class)NSMutableURLRequest);
  id v17 = objc_alloc((Class)NSString);
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v18 = a2;
  }
  else {
    uint64_t v18 = (uint64_t *)*a2;
  }
  id v19 = [v17 initWithCString:v18 encoding:4];
  id v20 = +[NSURL URLWithString:v19];
  id v21 = [v16 initWithURL:v20];

  [v21 _setPrivacyProxyFailClosed:1];
  [v21 setAllHTTPHeaderFields:&off_101AE8088];
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v26 = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a3;
    uint64_t v26 = *(void *)(a3 + 16);
  }
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3321888768;
  v27[2] = sub_100EC5D34;
  v27[3] = &unk_101A68BD0;
  v27[4] = a1;
  sub_1009A4640((uint64_t)v28, a5);
  if (SHIBYTE(v26) < 0)
  {
    sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    long long __p = *(_OWORD *)__dst;
    uint64_t v30 = v26;
  }
  uint64_t v22 = [v15 dataTaskWithRequest:v21 completionHandler:v27];
  uint64_t v23 = (void *)qword_101B12EA8;
  qword_101B12EA8 = v22;

  *(unsigned char *)(a1 + 16) = 0;
  [(id)qword_101B12EA8 resume];
  if (SHIBYTE(v30) < 0) {
    operator delete((void *)__p);
  }
  sub_1009A45BC(v28);
  if (SHIBYTE(v26) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100EC5C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_1009A45BC(v35);
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100EC5D34(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(a1 + 32);
  id v11 = v8;
  id v12 = [v11 statusCode];
  std::string::size_type v13 = *(NSObject **)(v10 + 8);
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if (v7 && !v9 && v12 == (id)200)
  {
    if (v14)
    {
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = [v7 length];
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Retrieved %lu bytes", buf, 0xCu);
    }
    id v15 = v7;
    id v16 = [v15 bytes];
    if ((unint64_t)[v15 length] >= 0x12 && *v16 == 66 && v16[1] == 77)
    {
      long long v32 = +[NSFileManager defaultManager];
      id v17 = [objc_alloc((Class)NSString) initWithCString:"/var/wireless/Library/Images" encoding:4];
      uint64_t v18 = +[NSURL fileURLWithPath:v17];

      id v19 = [v18 absoluteString];
      unsigned __int8 v20 = [v32 fileExistsAtPath:v19];

      if ((v20 & 1) == 0) {
        [v32 createDirectoryAtURL:v18 withIntermediateDirectories:1 attributes:0 error:0];
      }
      id v21 = [objc_alloc((Class)NSString) initWithCString:"/var/wireless/Library/Images" encoding:4];
      uint64_t v22 = +[NSURL URLWithString:v21];

      id v23 = objc_alloc((Class)NSString);
      id v24 = (void *)(a1 + 72);
      if (*(char *)(a1 + 95) < 0) {
        id v24 = (void *)*v24;
      }
      id v25 = [v23 initWithCString:v24 encoding:4];
      uint64_t v26 = [v22 URLByAppendingPathComponent:v25];

      uint64_t v27 = [v26 path];
      [v32 createFileAtPath:v27 contents:v15 attributes:0];

      id v28 = [v26 path];
      sub_100058DB0(buf, (char *)[v28 UTF8String]);
      sub_100EC61E4(*(void *)(a1 + 64), (uint64_t)buf, 0);
      if (v36 < 0) {
        operator delete(*(void **)buf);
      }

      goto LABEL_27;
    }
    long long v31 = *(NSObject **)(v10 + 8);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#E BMP file format verification failed", buf, 2u);
    }
    sub_100058DB0(buf, "/stock");
    sub_100EC61E4(*(void *)(a1 + 64), (uint64_t)buf, 3);
  }
  else
  {
    if (v14)
    {
      *(_DWORD *)std::string buf = 134218242;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v34 = 2112;
      id v35 = v9;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Response error from server, HTTP Status: %ld, %@", buf, 0x16u);
    }
    int v29 = *(unsigned __int8 *)(v10 + 16);
    sub_100058DB0(buf, "/stock");
    if (v29) {
      char v30 = 4;
    }
    else {
      char v30 = 5;
    }
    sub_100EC61E4(*(void *)(a1 + 64), (uint64_t)buf, v30);
  }
  if (v36 < 0) {
    operator delete(*(void **)buf);
  }
LABEL_27:
}

void sub_100EC60FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100EC61E4(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

unsigned char *sub_100EC6234(uint64_t a1, uint64_t a2)
{
  sub_1009A4640(a1 + 40, a2 + 40);
  uint64_t result = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  long long v5 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_100EC629C(_Unwind_Exception *a1)
{
  sub_1009A45BC(v1);
  _Unwind_Resume(a1);
}

void *sub_100EC62B0(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }

  return sub_1009A45BC((void *)(a1 + 40));
}

id sub_100EC62F4(uint64_t a1)
{
  id result = [(id)qword_101B12EA8 state];
  if (!result)
  {
    *(unsigned char *)(a1 + 16) = 1;
    char v3 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E Image fetching timed out", v4, 2u);
    }
    return [(id)qword_101B12EA8 cancel];
  }
  return result;
}

void sub_100EC6378(uint64_t a1, unsigned char *__s)
{
  char v4 = __s[23];
  if ((v4 & 0x80000000) == 0)
  {
    if (__s[23])
    {
      long long v5 = __s;
      uint64_t v6 = __s[23];
      goto LABEL_6;
    }
LABEL_21:
    std::string::size_type v13 = *(NSObject **)(a1 + 8);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    BOOL v14 = "#E File path URL is empty";
    id v15 = v13;
    uint32_t v16 = 2;
    goto LABEL_45;
  }
  uint64_t v6 = *((void *)__s + 1);
  if (!v6) {
    goto LABEL_21;
  }
  long long v5 = *(unsigned char **)__s;
LABEL_6:
  if (v6 >= 28)
  {
    id v7 = &v5[v6];
    id v8 = v5;
    do
    {
      id v9 = (char *)memchr(v8, 47, v6 - 27);
      if (!v9) {
        break;
      }
      if (*(void *)v9 == 0x7269772F7261762FLL
        && *((void *)v9 + 1) == 0x694C2F7373656C65
        && *((void *)v9 + 2) == 0x6D492F7972617262
        && *((_DWORD *)v9 + 6) == 1936025441)
      {
        if (v9 == v7 || v9 - v5 == -1) {
          break;
        }
        id v17 = +[NSFileManager defaultManager];
        uint64_t v18 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          if ((char)__s[23] >= 0) {
            id v19 = __s;
          }
          else {
            id v19 = *(unsigned char **)__s;
          }
          *(_DWORD *)std::string buf = 136315138;
          int v29 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Deleting %s file", buf, 0xCu);
        }
        if ((char)__s[23] >= 0) {
          unsigned __int8 v20 = __s;
        }
        else {
          unsigned __int8 v20 = *(unsigned char **)__s;
        }
        id v21 = +[NSString stringWithCString:v20 encoding:4];
        id v27 = 0;
        [v17 removeItemAtPath:v21 error:&v27];
        id v22 = v27;

        if (v22)
        {
          id v23 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            if ((char)__s[23] >= 0) {
              id v24 = __s;
            }
            else {
              id v24 = *(unsigned char **)__s;
            }
            *(_DWORD *)std::string buf = 136315394;
            int v29 = v24;
            __int16 v30 = 2112;
            id v31 = v22;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#E Failed to remove a file %s, error: %@", buf, 0x16u);
          }
        }

        return;
      }
      id v8 = v9 + 1;
      uint64_t v6 = v7 - (unsigned char *)v8;
    }
    while (v7 - (unsigned char *)v8 >= 28);
  }
  id v25 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    if (v4 >= 0) {
      uint64_t v26 = __s;
    }
    else {
      uint64_t v26 = *(unsigned char **)__s;
    }
    *(_DWORD *)std::string buf = 136315138;
    int v29 = v26;
    BOOL v14 = "#E Cannot remove files from invalid directory %s";
    id v15 = v25;
    uint32_t v16 = 12;
LABEL_45:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
  }
}

void sub_100EC6678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100EC669C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (!v3)
  {
    long long v5 = *(NSObject **)(a1 + 8);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v6) {
      return result;
    }
    __int16 v11 = 0;
    id v7 = "#E Not a valid URL";
    id v8 = (uint8_t *)&v11;
    goto LABEL_10;
  }
  if (sub_1002357A8((uint64_t *)a2, "https://")) {
    return 1;
  }
  long long v5 = *(NSObject **)(a1 + 8);
  BOOL v9 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v9)
  {
    __int16 v10 = 0;
    id v7 = "#E URL doesnt starts with https";
    id v8 = (uint8_t *)&v10;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, v8, 2u);
    return 0;
  }
  return result;
}

void sub_100EC677C(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  BrandedCallingHelperInterface::~BrandedCallingHelperInterface((BrandedCallingHelperInterface *)a1);
}

void sub_100EC67B8(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  BrandedCallingHelperInterface::~BrandedCallingHelperInterface((BrandedCallingHelperInterface *)a1);

  operator delete();
}

void sub_100EC6808()
{
}

uint64_t sub_100EC6890@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  CFArrayRef theArray = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 8));
  id v7 = ServiceMap;
  if (v8 < 0)
  {
    BOOL v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __int16 v34 = (void *)v8;
  id v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v34);
  if (v12)
  {
    uint64_t v14 = v12[3];
    std::string::size_type v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  std::string::size_type v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v14 + 96))(__p, v14, a3, 1, @"DisallowedDialingPrefixes", 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (theArray) {
    uint32_t v16 = sub_100083F10;
  }
  else {
    uint32_t v16 = 0;
  }
  if (!v16) {
    goto LABEL_36;
  }
  __int16 v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  sub_100058DB0(&v34, a2);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v33 = 0;
  uint64_t v17 = HIBYTE(v36);
  if (v36 >= 0) {
    uint64_t v18 = &v34;
  }
  else {
    uint64_t v18 = v34;
  }
  if (v36 < 0) {
    uint64_t v17 = v35;
  }
  buf[0] = 32;
  id v19 = sub_1001D40E0(v18, (unsigned __int8 *)v18 + v17, buf);
  sub_10012CD04(__p, (char *)v18, (char *)v19, v19 - (unsigned char *)v18);
  CFStringRef theString = 0;
  CFStringRef v38 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v20 = theString;
    CFStringRef theString = v38;
    *(void *)std::string buf = v20;
    sub_1000558F4((const void **)buf);
  }
  if (theString) {
    id v21 = sub_1000810B8;
  }
  else {
    id v21 = 0;
  }
  if (!v21 || (CFIndex Count = CFArrayGetCount(theArray), Count < 1))
  {
LABEL_32:
    sub_1000558F4((const void **)&theString);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(v34);
    }
LABEL_36:
    uint64_t v27 = 0;
    goto LABEL_37;
  }
  CFIndex v23 = 0;
  while (1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v23);
    CFStringRef v25 = ValueAtIndex;
    if (ValueAtIndex)
    {
      CFTypeID v26 = CFGetTypeID(ValueAtIndex);
      if (v26 == CFStringGetTypeID())
      {
        v40.length = CFStringGetLength(theString);
        v40.location = 0;
        if (CFStringFindWithOptions(theString, v25, v40, 9uLL, 0)) {
          break;
        }
      }
    }
    if (Count == ++v23) {
      goto LABEL_32;
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12EB8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12EB8))
  {
    LogGroupName = (const char *)sGetLogGroupName();
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B12EB0, kCtLoggingSystemName, LogGroupName);
    __cxa_guard_release(&qword_101B12EB8);
  }
  int v29 = qword_101B12EB0;
  if (os_log_type_enabled((os_log_t)qword_101B12EB0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Number is disallowed by bundle", buf, 2u);
  }
  sub_1000558F4((const void **)&theString);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v34);
  }
  uint64_t v27 = 1;
LABEL_37:
  sub_100044D00((const void **)&theArray);
  return v27;
}

void sub_100EC6C34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,const void *a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_100044D00(&a23);
  _Unwind_Resume(a1);
}

void sub_100EC6CC4(DisallowedNumbersInterface *this)
{
  *(void *)this = off_101A68C58;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  DisallowedNumbersInterface::~DisallowedNumbersInterface(this);
}

void sub_100EC6D20(DisallowedNumbersInterface *this)
{
  *(void *)this = off_101A68C58;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  DisallowedNumbersInterface::~DisallowedNumbersInterface(this);

  operator delete();
}

void sub_100EC6D90(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EC6DF8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC6E34(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EC6E6C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100EC6E9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100EC6EE0(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x70uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A68DA0;
  sub_100EC6FD8(&v8[1].__vftable, a1, a2, a3);
  shared_owners = (std::__shared_weak_count *)v8[1].__shared_owners_;
  if (!shared_owners)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)&v8[1];
    v8[1].__shared_owners_ = (uint64_t)v8;
    goto LABEL_5;
  }
  if (shared_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)&v8[1];
    v8[1].__shared_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_owners);
LABEL_5:
    sub_10004D2C8(v8);
  }
  *a4 = v8 + 1;
  a4[1] = v8;
}

void sub_100EC6FC0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void *sub_100EC6FD8(void *a1, uint64_t a2, void *a3, void *a4)
{
  *a1 = 0;
  a1[1] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v22, kCtLoggingSystemName, "ent.pnr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v23, &v22);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 2), (const ctu::OsLogLogger *)v23);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v23);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  uint64_t v8 = *(Registry **)a2;
  a1[3] = *(void *)a2;
  uint64_t v9 = *(void *)(a2 + 8);
  a1[4] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    uint64_t v8 = (Registry *)a1[3];
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8);
  unsigned int v11 = ServiceMap;
  if (v12 < 0)
  {
    std::string::size_type v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v22.var0 = (char *)v12;
  uint32_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v22);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v11);
  a1[5] = v18;
  a1[6] = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
  }
  a1[7] = *a3;
  uint64_t v19 = a3[1];
  a1[8] = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  a1[9] = *a4;
  uint64_t v20 = a4[1];
  a1[10] = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100EC7168(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  char v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EC71BC(uint64_t a1)
{
  uint64_t v7 = 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 72) + 64), @"GetPhoneNumberSigningVersion");
  v8.__r_.__value_.__r.__words[0] = (std::string::size_type)Value;
  if (Value) {
    CFRetain(Value);
  }
  sub_100056248(&v7, (CFTypeRef *)&v8.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&v8.__r_.__value_.__l.__data_);
  if (v7) {
    uint64_t v2 = sub_1000810B8;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    memset(&v8, 0, sizeof(v8));
    ctu::cf::assign();
    std::string __p = v8;
    std::string::size_type size = HIBYTE(v8.__r_.__value_.__r.__words[2]);
    if ((v8.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v8.__r_.__value_.__l.__size_;
    }
    if (size) {
      unsigned __int8 v4 = std::stoul(&__p, 0, 10);
    }
    else {
      unsigned __int8 v4 = 2;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    unsigned __int8 v4 = 2;
  }
  sub_1000558F4(&v7);
  return v4;
}

void sub_100EC72DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    JUMPOUT(0x100EC72ECLL);
  }
  JUMPOUT(0x100EC72F0);
}

void sub_100EC7300(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000577C4((const void **)va);
  JUMPOUT(0x100EC730CLL);
}

void sub_100EC7314(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  std::string v8 = *(NSObject **)(a1 + 16);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v9;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    uint64_t v34 = asString();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sRequested version is %s", buf, 0x20u);
    std::string v8 = *(NSObject **)(a1 + 16);
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
    ctu::hex();
    unsigned int v11 = v32 >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&buf[22] = 2080;
    uint64_t v34 = (uint64_t)v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sPush token is [%s]", buf, 0x20u);
    if (v32 < 0) {
      operator delete(*(void **)__p);
    }
  }
  if (a2 < 3) {
    goto LABEL_10;
  }
  uint64_t v15 = *(void *)(a1 + 40);
  if (!v15)
  {
    id v21 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#W %s%sUnable to get machine ID provider, will use default nonce version", buf, 0x16u);
    }
    goto LABEL_10;
  }
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v15 + 16))(buf);
  uint32_t v16 = *(void **)buf;
  if (*(void *)buf == *(void *)&buf[8])
  {
    CFIndex v23 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
      *(_DWORD *)std::string __p = 136315394;
      *(void *)&__p[4] = v24;
      __int16 v30 = 2080;
      id v31 = " ";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#W %s%sMachine ID is empty, will use default nonce version", __p, 0x16u);
    }
    uint64_t v20 = 0;
    uint64_t v19 = 0;
LABEL_25:
    uint32_t v16 = *(void **)buf;
    if (!*(void *)buf) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (a2 == 4)
  {
    CFStringRef v25 = *(const void **)a3;
    uint64_t v26 = *(void *)(a3 + 8);
    uint64_t v19 = (std::__shared_weak_count *)operator new(0x50uLL);
    v19->__shared_owners_ = 0;
    v19->__shared_weak_owners_ = 0;
    v19->__vftable = (std::__shared_weak_count_vtbl *)off_101A68E40;
    uint64_t v20 = v19 + 1;
    v19[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A68D38;
    v19[1].__shared_owners_ = 0;
    v19[1].__shared_weak_owners_ = 0;
    v19[2].__vftable = 0;
    sub_10005C928(&v19[1].__shared_owners_, v25, v26, v26 - (void)v25);
    v19[2].__shared_owners_ = 0;
    v19[2].__shared_weak_owners_ = 0;
    v19[3].__vftable = 0;
    sub_10005C928(&v19[2].__shared_owners_, *(const void **)buf, *(uint64_t *)&buf[8], *(void *)&buf[8] - *(void *)buf);
    goto LABEL_25;
  }
  if (a2 == 3)
  {
    uint64_t v17 = *(const void **)a3;
    uint64_t v18 = *(void *)(a3 + 8);
    uint64_t v19 = (std::__shared_weak_count *)operator new(0x50uLL);
    v19->__shared_owners_ = 0;
    v19->__shared_weak_owners_ = 0;
    v19->__vftable = (std::__shared_weak_count_vtbl *)off_101A68DF0;
    uint64_t v20 = v19 + 1;
    v19[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A68D10;
    v19[1].__shared_owners_ = 0;
    v19[1].__shared_weak_owners_ = 0;
    v19[2].__vftable = 0;
    sub_10005C928(&v19[1].__shared_owners_, v17, v18, v18 - (void)v17);
    v19[2].__shared_owners_ = 0;
    v19[2].__shared_weak_owners_ = 0;
    v19[3].__vftable = 0;
    sub_10005C928(&v19[2].__shared_owners_, *(const void **)buf, *(uint64_t *)&buf[8], *(void *)&buf[8] - *(void *)buf);
    goto LABEL_25;
  }
  uint64_t v20 = 0;
  uint64_t v19 = 0;
  if (*(void *)buf)
  {
LABEL_26:
    *(void *)&uint8_t buf[8] = v16;
    operator delete(v16);
  }
LABEL_27:
  if (!v20)
  {
    if (v19) {
      sub_10004D2C8(v19);
    }
LABEL_10:
    uint64_t v12 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
      uint64_t v14 = asString();
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      *(_WORD *)&buf[22] = 2080;
      uint64_t v34 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%sUsing default nonce version %s", buf, 0x20u);
    }
    *(unsigned char *)a4 = 2;
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    sub_10005C928((void *)(a4 + 8), *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
    return;
  }
  uint64_t v27 = *(NSObject **)(a1 + 16);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Using version %s for nonce format", buf, 0xCu);
  }
  ((void (*)(uint8_t *__return_ptr, std::__shared_weak_count *))v20->__on_zero_shared)(buf, v20);
  *(unsigned char *)a4 = a2;
  *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
  *(void *)(a4 + 24) = *(void *)&buf[16];
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_100EC7860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  uint64_t v17 = *v15;
  if (*v15)
  {
    v14[1].__shared_weak_owners_ = (uint64_t)v17;
    operator delete(v17);
  }
  std::__shared_weak_count::~__shared_weak_count(v14);
  operator delete(v18);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

char *sub_100EC78D8@<X0>(char **a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_100240658((unint64_t *)a2, &a1[5][(void)a1[2]] - &a1[4][(void)a1[1]]);
  sub_10005C748(a2, *(char **)(a2 + 8), a1[1], a1[2], a1[2] - a1[1]);
  return sub_10005C748(a2, *(char **)(a2 + 8), a1[4], a1[5], a1[5] - a1[4]);
}

void sub_100EC7948(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC796C(char **a1@<X0>, int64x2_t **a2@<X8>)
{
  int64x2_t v45 = 0uLL;
  v46[0] = 0;
  unsigned __int8 v4 = (std::__shared_weak_count *)operator new(0x40uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_101A68E90;
  LOBYTE(v4[1].__shared_owners_) = 1;
  v4[1].__shared_weak_owners_ = 0;
  p_shared_weak_owners = (char **)&v4[1].__shared_weak_owners_;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A68EE0;
  v4[2].__vftable = 0;
  v4[2].__shared_owners_ = 0;
  CFIndex v50 = v46;
  BOOL v6 = sub_1009C886C(1uLL);
  std::string v8 = &v6[2 * v7];
  *BOOL v6 = v4 + 1;
  v6[1] = v4;
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v9 = v6 + 2;
  uint64_t v10 = (void *)v45.i64[1];
  unsigned int v11 = (void *)v45.i64[0];
  if (v45.i64[1] == v45.i64[0])
  {
    int64x2_t v13 = vdupq_n_s64(v45.u64[1]);
  }
  else
  {
    do
    {
      long long v12 = *((_OWORD *)v10 - 1);
      v10 -= 2;
      *((_OWORD *)v6 - 1) = v12;
      v6 -= 2;
      void *v10 = 0;
      v10[1] = 0;
    }
    while (v10 != v11);
    int64x2_t v13 = v45;
  }
  v45.i64[0] = (uint64_t)v6;
  int64x2_t v48 = v13;
  uint64_t v14 = v46[0];
  v46[0] = v8;
  uint64_t v49 = v14;
  long long v47 = (int64x2_t *)v13.i64[0];
  sub_10019E528((uint64_t)&v47);
  v45.i64[1] = (uint64_t)v9;
  sub_10004D2C8(v4);
  if (a1 + 1 != p_shared_weak_owners) {
    sub_10006E4A8(p_shared_weak_owners, a1[1], a1[2], a1[2] - a1[1]);
  }
  int64x2_t v15 = v45;
  uint32_t v16 = (char ***)v45.i64[0];
  if (v45.i64[0] != v45.i64[1])
  {
    while (*((unsigned char *)*v16 + 8) != 2)
    {
      v16 += 2;
      if (v16 == (char ***)v45.i64[1]) {
        goto LABEL_16;
      }
    }
  }
  if (v16 == (char ***)v45.i64[1])
  {
LABEL_16:
    id v21 = operator new(0x40uLL);
    uint64_t v22 = (std::__shared_weak_count *)v21;
    v21[1] = 0;
    int v21[2] = 0;
    *id v21 = off_101A68F38;
    CFIndex v23 = (char *)(v21 + 3);
    *((unsigned char *)v21 + 32) = 2;
    v21[3] = off_101A68F88;
    v21[5] = 0;
    uint64_t v19 = (char **)(v21 + 5);
    v21[6] = 0;
    v21[7] = 0;
    if (v15.i64[1] >= v46[0])
    {
      uint64_t v25 = (v15.i64[1] - v15.i64[0]) >> 4;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 60) {
        sub_10006A748();
      }
      uint64_t v27 = v46[0] - v15.i64[0];
      if ((v46[0] - v15.i64[0]) >> 3 > v26) {
        unint64_t v26 = v27 >> 3;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v26;
      }
      CFIndex v50 = v46;
      int v29 = (char *)sub_1009C886C(v28);
      id v31 = &v29[16 * v25];
      *(void *)id v31 = v23;
      *((void *)v31 + 1) = v22;
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v24 = (uint64_t)(v31 + 16);
      char v32 = (void *)v45.i64[1];
      uint64_t v33 = (void *)v45.i64[0];
      if (v45.i64[1] == v45.i64[0])
      {
        int64x2_t v35 = vdupq_n_s64(v45.u64[1]);
      }
      else
      {
        do
        {
          long long v34 = *((_OWORD *)v32 - 1);
          v32 -= 2;
          *((_OWORD *)v31 - 1) = v34;
          v31 -= 16;
          *char v32 = 0;
          v32[1] = 0;
        }
        while (v32 != v33);
        int64x2_t v35 = v45;
      }
      v45.i64[0] = (uint64_t)v31;
      v45.i64[1] = v24;
      int64x2_t v48 = v35;
      uint64_t v36 = v46[0];
      v46[0] = &v29[16 * v30];
      uint64_t v49 = v36;
      long long v47 = (int64x2_t *)v35.i64[0];
      sub_10019E528((uint64_t)&v47);
    }
    else
    {
      *(void *)v15.i64[1] = v23;
      *(void *)(v15.i64[1] + 8) = v21;
      atomic_fetch_add_explicit(v21 + 1, 1uLL, memory_order_relaxed);
      uint64_t v24 = v15.i64[1] + 16;
    }
    v45.i64[1] = v24;
    uint64_t v20 = v22;
  }
  else
  {
    uint64_t v17 = *v16;
    if (!*v16
    {
      uint64_t v19 = v17 + 2;
      goto LABEL_32;
    }
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v19 = v17 + 2;
    uint64_t v20 = v18;
  }
  sub_10004D2C8(v20);
LABEL_32:
  if (a1 + 4 != v19) {
    sub_10006E4A8(v19, a1[4], a1[5], a1[5] - a1[4]);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v37 = (uint64_t *)v45.i64[0];
  if (v45.i64[0] == v45.i64[1])
  {
    size_t v38 = 0;
  }
  else
  {
    size_t v38 = 0;
    do
    {
      uint64_t v39 = *v37;
      CFRange v40 = (std::__shared_weak_count *)v37[1];
      if (v40) {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 16))(v39);
      if (v40) {
        sub_10004D2C8(v40);
      }
      v38 += v41;
      v37 += 2;
    }
    while (v37 != (uint64_t *)v45.i64[1]);
  }
  sub_10008E4E8(a2, v38);
  long long v47 = *a2;
  for (CFIndex i = (uint64_t *)v45.i64[0]; i != (uint64_t *)v45.i64[1]; i += 2)
  {
    uint64_t v43 = *i;
    long long v44 = (std::__shared_weak_count *)i[1];
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, int64x2_t **))(*(void *)v43 + 24))(v43, &v47);
    if (v44) {
      sub_10004D2C8(v44);
    }
  }
  long long v47 = &v45;
  sub_10077EE24((void ***)&v47);
}

void sub_100EC7DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  sub_10004D2C8(v13);
  a13 = (void **)&a9;
  sub_10077EE24(&a13);
  _Unwind_Resume(a1);
}

void *sub_100EC7E20(void *a1)
{
  *a1 = off_101A68D10;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100EC7E80(void *a1)
{
  *a1 = off_101A68D10;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }

  operator delete();
}

void *sub_100EC7F00(void *a1)
{
  *a1 = off_101A68D38;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100EC7F60(void *a1)
{
  *a1 = off_101A68D38;
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }

  operator delete();
}

void sub_100EC7FE0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A68DA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EC8000(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A68DA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EC8054(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[13];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[11];
  if (v3) {
    sub_10004D2C8(v3);
  }
  unsigned __int8 v4 = (std::__shared_weak_count *)a1[9];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  BOOL v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
  {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_100EC80D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A68DF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EC80F4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A68DF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EC8148(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100EC8170(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A68E40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EC8190(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A68E40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EC81E4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100EC820C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A68E90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EC822C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A68E90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EC8280(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_100EC82A8(void *a1)
{
  *a1 = off_101A68EE0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100EC82F8(void *a1)
{
  *a1 = off_101A68EE0;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_100EC8368(uint64_t a1)
{
  return *(void *)(a1 + 24) - *(void *)(a1 + 16) + 5;
}

uint64_t sub_100EC8378(uint64_t a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *a2;
  uint64_t v5 = (char *)(*a2 + 5);
  *a2 = v5;
  memcpy(v5, *(const void **)(a1 + 16), *(void *)(a1 + 24) - *(void *)(a1 + 16));
  void *v2 = &v5[*(void *)(a1 + 24) - *(void *)(a1 + 16)];
  LOBYTE(v2) = byte_order::big::operator()();
  uint64_t result = byte_order::big::operator()();
  *(unsigned char *)uint64_t v4 = (_BYTE)v2;
  *(_DWORD *)(v4 + 1) = result;
  return result;
}

void sub_100EC8408(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A68F38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EC8428(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A68F38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EC847C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *sub_100EC84A4(void *a1)
{
  *a1 = off_101A68F88;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100EC84F4(void *a1)
{
  *a1 = off_101A68F88;
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    a1[3] = v2;
    operator delete(v2);
  }

  operator delete();
}

uint64_t sub_100EC8564(uint64_t a1)
{
  return *(void *)(a1 + 24) - *(void *)(a1 + 16) + 5;
}

uint64_t sub_100EC8574(uint64_t a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *a2;
  uint64_t v5 = (char *)(*a2 + 5);
  *a2 = v5;
  memcpy(v5, *(const void **)(a1 + 16), *(void *)(a1 + 24) - *(void *)(a1 + 16));
  void *v2 = &v5[*(void *)(a1 + 24) - *(void *)(a1 + 16)];
  LOBYTE(v2) = byte_order::big::operator()();
  uint64_t result = byte_order::big::operator()();
  *(unsigned char *)uint64_t v4 = (_BYTE)v2;
  *(_DWORD *)(v4 + 1) = result;
  return result;
}

double sub_100EC8624@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_100EC865C(SubscriberTrackerFactoryInterface *this)
{
  *(void *)this = off_101A69030;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  SubscriberTrackerFactoryInterface::~SubscriberTrackerFactoryInterface(this);
}

void sub_100EC86B8(SubscriberTrackerFactoryInterface *this)
{
  *(void *)this = off_101A69030;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  SubscriberTrackerFactoryInterface::~SubscriberTrackerFactoryInterface(this);

  operator delete();
}

void TechPolicyController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100EC87E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void TechPolicyController::init_sync(TechPolicyController *this)
{
  sub_100EC8E9C((uint64_t)this, 1);
  if (capabilities::ct::supportsGemini(v2)) {
    sub_100EC8E9C((uint64_t)this, 2);
  }
  uint64_t v3 = *((void *)this + 7);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *((void *)this + 12);
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Created %zu set(s) of policy variables", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t *TechPolicyController::TechPolicyController(uint64_t *a1, uint64_t *a2, NSObject **a3, char *a4)
{
  *a1 = (uint64_t)off_101A1EFE8;
  a1[1] = (uint64_t)off_101A6DEA0;
  a1[2] = 0;
  v21[0] = off_101999E18;
  v21[1] = sub_100EC8E70;
  v21[3] = v21;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)a1) & 1) == 0) {
    operator new();
  }
  if (!a1[2]) {
    operator new();
  }
  sub_10008863C(v21);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v22, kCtLoggingSystemName, a4);
  a1[3] = 0;
  a1[4] = 0;
  std::string v8 = *a3;
  a1[5] = (uint64_t)*a3;
  if (v8) {
    dispatch_retain(v8);
  }
  a1[6] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v20, &v22);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 7), (const ctu::OsLogLogger *)v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  *a1 = (uint64_t)off_101A69070;
  a1[1] = (uint64_t)off_101A690D8;
  a1[8] = *a2;
  uint64_t v9 = a2[1];
  a1[9] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  a1[14] = 0;
  a1[11] = 0;
  a1[10] = (uint64_t)(a1 + 11);
  a1[12] = 0;
  a1[13] = (uint64_t)(a1 + 14);
  a1[15] = 0;
  a1[16] = (uint64_t)a4;
  sub_100058DB0(&__p, a4);
  uint64_t v10 = a1[5];
  uint64_t v17 = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  ctu::RestModule::RestModule();
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  a1[20] = 0;
  a1[19] = (uint64_t)(a1 + 20);
  a1[21] = 0;
  sub_10005DF14(a1 + 22, (uint64_t)&rest::kDefaultDataAttachedStates);
  sub_10005DF14(a1 + 25, (uint64_t)&rest::kDefaultCsAttachedStates);
  sub_10013646C(a1 + 28, (uint64_t)&rest::kDefaultRoamingResults);
  unsigned int v11 = sub_10005DF14(a1 + 31, (uint64_t)&rest::kDefaultInHomeCountries);
  a1[35] = 0;
  a1[36] = 0;
  a1[34] = (uint64_t)(a1 + 35);
  rest::getDefaultDataConnectionTypeMaskStates((uint64_t *)&v22, (rest *)v11);
  var0 = v22.var0;
  fRef = v22.var1.fRef;
  a1[40] = 0;
  a1[41] = (uint64_t)var0;
  uint64_t v14 = a1 + 42;
  uint64_t v15 = v23;
  a1[42] = (uint64_t)fRef;
  a1[43] = v15;
  if (v15)
  {
    *((void *)fRef + 2) = v14;
    v22.var0 = (char *)&v22.var1;
    v22.var1.fRef = 0;
    uint64_t v23 = 0;
    fRef = 0;
  }
  else
  {
    a1[41] = (uint64_t)v14;
  }
  sub_1000346F8((uint64_t)&v22, fRef);
  return a1;
}

void sub_100EC8CB8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

const char *sub_100EC8E70(int a1)
{
  uint64_t v1 = "DATA.tech.policy.?";
  if (a1 == 2) {
    uint64_t v1 = "DATA.tech.policy.2";
  }
  if (a1 == 1) {
    return "DATA.tech.policy.1";
  }
  else {
    return v1;
  }
}

void sub_100EC8E9C(uint64_t a1, int a2)
{
  int v5 = (uint64_t **)(a1 + 88);
  uint64_t v4 = *(char **)(a1 + 88);
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = v4;
        int v7 = *((_DWORD *)v4 + 8);
        if (v7 <= a2) {
          break;
        }
        uint64_t v4 = *(char **)v6;
        int v5 = (uint64_t **)v6;
        if (!*(void *)v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= a2) {
        break;
      }
      uint64_t v4 = (char *)*((void *)v6 + 1);
      if (!v4)
      {
        int v5 = (uint64_t **)(v6 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v6 = (char *)(a1 + 88);
LABEL_9:
    std::string v8 = v6;
    uint64_t v6 = (char *)operator new(0x48uLL);
    *((_DWORD *)v6 + 8) = a2;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *((void *)v6 + 6) = v6 + 56;
    *(void *)uint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v8;
    char *v5 = (uint64_t *)v6;
    uint64_t v9 = **(void **)(a1 + 80);
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *(void *)(a1 + 80) = v9;
      uint64_t v10 = *v5;
    }
    sub_100046C90(*(uint64_t **)(a1 + 88), v10);
    ++*(void *)(a1 + 96);
  }
  unsigned int v11 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v11) {
    goto LABEL_65;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  int64x2_t v13 = std::__shared_weak_count::lock(v11);
  if (!v13) {
    goto LABEL_65;
  }
  uint64_t v14 = v13;
  uint64_t v15 = (uint64_t)(v6 + 40);
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  uint32_t v16 = std::__shared_weak_count::lock(v14);
  uint64_t v17 = v16;
  if (v16)
  {
    if (v12) {
      uint64_t v18 = (std::__shared_weak_count *)(v12 + 8);
    }
    else {
      uint64_t v18 = 0;
    }
    atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v14);
    sub_10004D2C8(v17);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v14);
    uint64_t v18 = 0;
  }
  unsigned int v53 = v18;
  char v54 = v17;
  sub_100ECD078(v15, "cellData", &v53);
  if (v54) {
    std::__shared_weak_count::__release_weak(v54);
  }
  char v19 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v19) {
    goto LABEL_65;
  }
  uint64_t v20 = *(void *)(a1 + 24);
  id v21 = std::__shared_weak_count::lock(v19);
  if (!v21) {
    goto LABEL_65;
  }
  OsLogContext v22 = v21;
  atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v21);
  uint64_t v23 = std::__shared_weak_count::lock(v22);
  uint64_t v24 = v23;
  if (v23)
  {
    if (v20) {
      uint64_t v25 = (std::__shared_weak_count *)(v20 + 8);
    }
    else {
      uint64_t v25 = 0;
    }
    atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v22);
    sub_10004D2C8(v24);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v22);
    uint64_t v25 = 0;
  }
  char v51 = v25;
  CFIndex v52 = v24;
  sub_100ECD078(v15, "dataRoaming", &v51);
  if (v52) {
    std::__shared_weak_count::__release_weak(v52);
  }
  unint64_t v26 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v26) {
    goto LABEL_65;
  }
  uint64_t v27 = *(void *)(a1 + 24);
  unint64_t v28 = std::__shared_weak_count::lock(v26);
  if (!v28) {
    goto LABEL_65;
  }
  int v29 = v28;
  atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v28);
  uint64_t v30 = std::__shared_weak_count::lock(v29);
  id v31 = v30;
  if (v30)
  {
    if (v27) {
      char v32 = (std::__shared_weak_count *)(v27 + 8);
    }
    else {
      char v32 = 0;
    }
    atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v29);
    sub_10004D2C8(v31);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v29);
    char v32 = 0;
  }
  uint64_t v49 = v32;
  CFIndex v50 = v31;
  sub_100ECD078(v15, "csAttached", &v49);
  if (v50) {
    std::__shared_weak_count::__release_weak(v50);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(a1 + 32);
  if (!v33 || (uint64_t v34 = *(void *)(a1 + 24), (v35 = std::__shared_weak_count::lock(v33)) == 0)) {
LABEL_65:
  }
    sub_100088B9C();
  uint64_t v36 = v35;
  atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v35);
  uint64_t v37 = std::__shared_weak_count::lock(v36);
  size_t v38 = v37;
  if (v37)
  {
    if (v34) {
      uint64_t v39 = (std::__shared_weak_count *)(v34 + 8);
    }
    else {
      uint64_t v39 = 0;
    }
    atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v36);
    sub_10004D2C8(v38);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v36);
    uint64_t v39 = 0;
  }
  long long v47 = v39;
  int64x2_t v48 = v38;
  sub_100ECD078(v15, "inRoaming", &v47);
  if (v48) {
    std::__shared_weak_count::__release_weak(v48);
  }
  uint64_t v41 = (uint64_t **)(a1 + 112);
  CFRange v40 = *(uint64_t **)(a1 + 112);
  if (v40)
  {
    while (1)
    {
      while (1)
      {
        long long v42 = (uint64_t **)v40;
        int v43 = *((_DWORD *)v40 + 8);
        if (v43 <= a2) {
          break;
        }
        CFRange v40 = *v42;
        uint64_t v41 = v42;
        if (!*v42) {
          goto LABEL_60;
        }
      }
      if (v43 >= a2) {
        break;
      }
      CFRange v40 = v42[1];
      if (!v40)
      {
        uint64_t v41 = v42 + 1;
        goto LABEL_60;
      }
    }
  }
  else
  {
    long long v42 = (uint64_t **)(a1 + 112);
LABEL_60:
    long long v44 = operator new(0x40uLL);
    v44[8] = a2;
    *((void *)v44 + 6) = 0;
    *((void *)v44 + 7) = 0;
    *((void *)v44 + 5) = 0;
    *(void *)long long v44 = 0;
    *((void *)v44 + 1) = 0;
    *((void *)v44 + 2) = v42;
    *uint64_t v41 = (uint64_t *)v44;
    uint64_t v45 = **(void **)(a1 + 104);
    if (v45)
    {
      *(void *)(a1 + 104) = v45;
      int64_t v46 = *v41;
    }
    else
    {
      int64_t v46 = (uint64_t *)v44;
    }
    sub_100046C90(*(uint64_t **)(a1 + 112), v46);
    ++*(void *)(a1 + 120);
  }
}

void sub_100EC9268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a10) {
    std::__shared_weak_count::__release_weak(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EC92B0(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v11, *(Registry **)(a1 + 64));
  ctu::RestModule::connect();
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100058DB0(__p, "/cc/props/vowifi_provisioning_state");
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A69280;
  v2[1] = a1 + 152;
  void v2[2] = a1;
  v2[3] = sub_100EC9814;
  v2[4] = 0;
  uint64_t v14 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_data_attached");
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_101A69300;
  v3[1] = a1 + 176;
  v3[2] = a1;
  v3[3] = sub_100EC99E4;
  v3[4] = 0;
  uint64_t v14 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/reg_cs_attached");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A69380;
  v4[1] = a1 + 200;
  v4[2] = a1;
  v4[3] = sub_100EC9BF0;
  v4[4] = 0;
  uint64_t v14 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/roaming_results");
  int v5 = operator new(0x28uLL);
  void *v5 = off_101A69400;
  v5[1] = a1 + 224;
  v5[2] = a1;
  v5[3] = sub_100EC9DFC;
  v5[4] = 0;
  uint64_t v14 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/in_home_countries_definite");
  uint64_t v6 = operator new(0x28uLL);
  *uint64_t v6 = off_101A69480;
  v6[1] = a1 + 248;
  v6[2] = a1;
  v6[3] = sub_100EC9FF8;
  v6[4] = 0;
  uint64_t v14 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  int v7 = operator new(0x28uLL);
  *int v7 = off_101A69500;
  v7[1] = a1 + 272;
  void v7[2] = a1;
  v7[3] = sub_100ECA1F8;
  v7[4] = 0;
  uint64_t v14 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(v13);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  std::string v8 = (void *)(a1 + 296);
  v13[0] = off_101A69580;
  v13[1] = a1 + 136;
  uint64_t v14 = v13;
  if (v13 != (void *)(a1 + 296))
  {
    uint64_t v9 = *(void **)(a1 + 320);
    if (v9 == v8)
    {
      __p[1] = (void *)(a1 + 136);
      uint64_t v16 = 0;
      uint64_t v14 = 0;
      __p[0] = off_101A69580;
      (*(void (**)(uint64_t, void *))(*v8 + 24))(a1 + 296, v13);
      (*(void (**)(void))(**(void **)(a1 + 320) + 32))(*(void *)(a1 + 320));
      *(void *)(a1 + 320) = 0;
      uint64_t v14 = v13;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, a1 + 296);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(a1 + 296) = off_101A69580;
      *(void *)(a1 + 304) = a1 + 136;
      uint64_t v14 = v9;
    }
    *(void *)(a1 + 320) = v8;
  }
  sub_100ECD820(v13);
  uint64_t result = *(void *)(a1 + 320);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a1 + 328);
  }
  return result;
}

void sub_100EC9794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC9814(uint64_t a1, void *a2)
{
  if ((sub_100E996C4(a2, a1 + 152) & 1) == 0)
  {
    v15[0] = 0;
    v15[1] = 0;
    uint64_t v14 = (uint64_t *)v15;
    uint64_t v4 = *(void **)(a1 + 152);
    if (v4 != (void *)(a1 + 160))
    {
      do
      {
        int v5 = sub_100046F68((uint64_t)a2, (void **)v4 + 4);
        if (a2 + 1 == v5
          || *((_DWORD *)v5 + 14) != *((_DWORD *)v4 + 14)
          || *((unsigned __int8 *)v5 + 60) != *((unsigned __int8 *)v4 + 60)
          || (sub_1005A0BB8((unsigned __int8 *)v5 + 64, (unsigned __int8 *)v4 + 64) & 1) == 0)
        {
          uint64_t v6 = *((unsigned __int8 *)v4 + 55);
          if ((v6 & 0x80u) != 0) {
            uint64_t v6 = v4[5];
          }
          if (v6)
          {
            int v13 = 0;
            int v13 = SlotIdFromPersonalityId();
            if (subscriber::isValidSimSlot()) {
              sub_10078C71C(&v14, &v13, &v13);
            }
          }
        }
        int v7 = (void *)v4[1];
        if (v7)
        {
          do
          {
            std::string v8 = v7;
            int v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            std::string v8 = (void *)v4[2];
            BOOL v9 = *v8 == (void)v4;
            uint64_t v4 = v8;
          }
          while (!v9);
        }
        uint64_t v4 = v8;
      }
      while (v8 != (void *)(a1 + 160));
      uint64_t v10 = v14;
      if (v14 != (uint64_t *)v15)
      {
        do
        {
          sub_100ECA574(a1, *((unsigned int *)v10 + 7), "VoWiFi");
          uint64_t v11 = (uint64_t *)v10[1];
          if (v11)
          {
            do
            {
              uint64_t v12 = v11;
              uint64_t v11 = (uint64_t *)*v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              uint64_t v12 = (uint64_t *)v10[2];
              BOOL v9 = *v12 == (void)v10;
              uint64_t v10 = v12;
            }
            while (!v9);
          }
          uint64_t v10 = v12;
        }
        while (v12 != (uint64_t *)v15);
      }
    }
    sub_1000346F8((uint64_t)&v14, v15[0]);
  }
}

void sub_100EC99C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void sub_100EC99E4(void *a1, void *a2)
{
  uint64_t v3 = a1 + 22;
  if (a2[2] == a1[24])
  {
    uint64_t v6 = (void *)*a2;
    uint64_t v4 = a2 + 1;
    int v5 = v6;
    if (v6 == v4) {
      return;
    }
    int v7 = (void *)*v3;
    while (1)
    {
      BOOL v8 = *((_DWORD *)v5 + 7) == *((_DWORD *)v7 + 7) && *((unsigned __int8 *)v5 + 32) == *((unsigned __int8 *)v7 + 32);
      if (!v8) {
        break;
      }
      BOOL v9 = (void *)v5[1];
      uint64_t v10 = v5;
      if (v9)
      {
        do
        {
          int v5 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v5 = (void *)v10[2];
          BOOL v8 = *v5 == (void)v10;
          uint64_t v10 = v5;
        }
        while (!v8);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v8 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v8);
      }
      int v7 = v12;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v13 = (void *)a1[10];
  uint64_t v14 = a1 + 11;
  if (v13 == a1 + 11) {
    return;
  }
  do
  {
    signed int v15 = *((_DWORD *)v13 + 8);
    unsigned int v25 = v15;
    uint64_t v16 = (uint64_t *)a1[23];
    if (!v16)
    {
LABEL_27:
      int v18 = 0;
      goto LABEL_29;
    }
    while (1)
    {
      signed int v17 = *((_DWORD *)v16 + 7);
      if (v15 >= v17) {
        break;
      }
LABEL_26:
      uint64_t v16 = (uint64_t *)*v16;
      if (!v16) {
        goto LABEL_27;
      }
    }
    if (v17 < v15)
    {
      ++v16;
      goto LABEL_26;
    }
    int v18 = *(unsigned char *)sub_10012EF5C((uint64_t)v3, (int *)&v25) != 0;
LABEL_29:
    if (*((unsigned __int8 *)v13 + 40) != v18)
    {
      *((unsigned char *)v13 + 40) = v18;
      sub_100058DB0(__p, "cellData");
      uint64_t v19 = sub_100ECD30C((uint64_t)(v13 + 6), __p);
      sub_100F04328(v19, v18);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v18) {
        uint64_t v20 = "Data attached";
      }
      else {
        uint64_t v20 = "Data not attached";
      }
      sub_100ECC040((uint64_t)a1, v25, v20);
    }
    id v21 = (void *)v13[1];
    if (v21)
    {
      do
      {
        OsLogContext v22 = v21;
        id v21 = (void *)*v21;
      }
      while (v21);
    }
    else
    {
      do
      {
        OsLogContext v22 = (void *)v13[2];
        BOOL v8 = *v22 == (void)v13;
        int v13 = v22;
      }
      while (!v8);
    }
    int v13 = v22;
  }
  while (v22 != v14);
}

void sub_100EC9BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC9BF0(void *a1, void *a2)
{
  uint64_t v3 = a1 + 25;
  if (a2[2] == a1[27])
  {
    uint64_t v6 = (void *)*a2;
    uint64_t v4 = a2 + 1;
    int v5 = v6;
    if (v6 == v4) {
      return;
    }
    int v7 = (void *)*v3;
    while (1)
    {
      BOOL v8 = *((_DWORD *)v5 + 7) == *((_DWORD *)v7 + 7) && *((unsigned __int8 *)v5 + 32) == *((unsigned __int8 *)v7 + 32);
      if (!v8) {
        break;
      }
      BOOL v9 = (void *)v5[1];
      uint64_t v10 = v5;
      if (v9)
      {
        do
        {
          int v5 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v5 = (void *)v10[2];
          BOOL v8 = *v5 == (void)v10;
          uint64_t v10 = v5;
        }
        while (!v8);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v8 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v8);
      }
      int v7 = v12;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v13 = (void *)a1[10];
  uint64_t v14 = a1 + 11;
  if (v13 == a1 + 11) {
    return;
  }
  do
  {
    signed int v15 = *((_DWORD *)v13 + 8);
    unsigned int v25 = v15;
    uint64_t v16 = (uint64_t *)a1[26];
    if (!v16)
    {
LABEL_27:
      int v18 = 0;
      goto LABEL_29;
    }
    while (1)
    {
      signed int v17 = *((_DWORD *)v16 + 7);
      if (v15 >= v17) {
        break;
      }
LABEL_26:
      uint64_t v16 = (uint64_t *)*v16;
      if (!v16) {
        goto LABEL_27;
      }
    }
    if (v17 < v15)
    {
      ++v16;
      goto LABEL_26;
    }
    int v18 = *(unsigned char *)sub_10012EF5C((uint64_t)v3, (int *)&v25) != 0;
LABEL_29:
    if (*((unsigned __int8 *)v13 + 41) != v18)
    {
      *((unsigned char *)v13 + 41) = v18;
      sub_100058DB0(__p, "csAttached");
      uint64_t v19 = sub_100ECD30C((uint64_t)(v13 + 6), __p);
      sub_100F04328(v19, v18);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (v18) {
        uint64_t v20 = "CS attached";
      }
      else {
        uint64_t v20 = "CS not attached";
      }
      sub_100ECC040((uint64_t)a1, v25, v20);
    }
    id v21 = (void *)v13[1];
    if (v21)
    {
      do
      {
        OsLogContext v22 = v21;
        id v21 = (void *)*v21;
      }
      while (v21);
    }
    else
    {
      do
      {
        OsLogContext v22 = (void *)v13[2];
        BOOL v8 = *v22 == (void)v13;
        int v13 = v22;
      }
      while (!v8);
    }
    int v13 = v22;
  }
  while (v22 != v14);
}

void sub_100EC9DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC9DFC(void *a1, void *a2)
{
  uint64_t v3 = a1 + 28;
  if (a2[2] == a1[30])
  {
    uint64_t v6 = (void *)*a2;
    uint64_t v4 = a2 + 1;
    int v5 = v6;
    if (v6 == v4) {
      return;
    }
    int v7 = (void *)*v3;
    while (1)
    {
      BOOL v8 = *((_DWORD *)v5 + 7) == *((_DWORD *)v7 + 7) && *((_DWORD *)v5 + 8) == *((_DWORD *)v7 + 8);
      if (!v8) {
        break;
      }
      BOOL v9 = (void *)v5[1];
      uint64_t v10 = v5;
      if (v9)
      {
        do
        {
          int v5 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v5 = (void *)v10[2];
          BOOL v8 = *v5 == (void)v10;
          uint64_t v10 = v5;
        }
        while (!v8);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v8 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v8);
      }
      int v7 = v12;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v13 = (void *)a1[10];
  uint64_t v14 = a1 + 11;
  if (v13 == a1 + 11) {
    return;
  }
  do
  {
    signed int v15 = *((_DWORD *)v13 + 8);
    unsigned int v24 = v15;
    uint64_t v16 = (uint64_t *)a1[29];
    if (!v16)
    {
LABEL_27:
      int v18 = 0;
      goto LABEL_29;
    }
    while (1)
    {
      signed int v17 = *((_DWORD *)v16 + 7);
      if (v15 >= v17) {
        break;
      }
LABEL_26:
      uint64_t v16 = (uint64_t *)*v16;
      if (!v16) {
        goto LABEL_27;
      }
    }
    if (v17 < v15)
    {
      ++v16;
      goto LABEL_26;
    }
    sub_10012EF5C((uint64_t)v3, (int *)&v24);
    int v18 = mapRoamingResultToTriBOOL() != 0;
LABEL_29:
    if (*((unsigned __int8 *)v13 + 42) != v18)
    {
      *((unsigned char *)v13 + 42) = v18;
      sub_100058DB0(__p, "inRoaming");
      uint64_t v19 = sub_100ECD30C((uint64_t)(v13 + 6), __p);
      sub_100F04328(v19, v18);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      sub_100ECC040((uint64_t)a1, v24, "Roaming update");
    }
    uint64_t v20 = (void *)v13[1];
    if (v20)
    {
      do
      {
        id v21 = v20;
        uint64_t v20 = (void *)*v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        id v21 = (void *)v13[2];
        BOOL v8 = *v21 == (void)v13;
        int v13 = v21;
      }
      while (!v8);
    }
    int v13 = v21;
  }
  while (v21 != v14);
}

void sub_100EC9FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EC9FF8(void *a1, void *a2)
{
  uint64_t v3 = a1 + 31;
  if (a2[2] == a1[33])
  {
    uint64_t v6 = (void *)*a2;
    uint64_t v4 = a2 + 1;
    int v5 = v6;
    if (v6 == v4) {
      return;
    }
    int v7 = (void *)*v3;
    while (1)
    {
      BOOL v8 = *((_DWORD *)v5 + 7) == *((_DWORD *)v7 + 7) && *((unsigned __int8 *)v5 + 32) == *((unsigned __int8 *)v7 + 32);
      if (!v8) {
        break;
      }
      BOOL v9 = (void *)v5[1];
      uint64_t v10 = v5;
      if (v9)
      {
        do
        {
          int v5 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v5 = (void *)v10[2];
          BOOL v8 = *v5 == (void)v10;
          uint64_t v10 = v5;
        }
        while (!v8);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v8 = *v12 == (void)v7;
          int v7 = v12;
        }
        while (!v8);
      }
      int v7 = v12;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v13 = (void *)a1[10];
  uint64_t v14 = a1 + 11;
  if (v13 == a1 + 11) {
    return;
  }
  do
  {
    signed int v15 = *((_DWORD *)v13 + 8);
    unsigned int v24 = v15;
    uint64_t v16 = (uint64_t *)a1[32];
    if (!v16)
    {
LABEL_27:
      int v18 = 0;
      goto LABEL_29;
    }
    while (1)
    {
      signed int v17 = *((_DWORD *)v16 + 7);
      if (v15 >= v17) {
        break;
      }
LABEL_26:
      uint64_t v16 = (uint64_t *)*v16;
      if (!v16) {
        goto LABEL_27;
      }
    }
    if (v17 < v15)
    {
      ++v16;
      goto LABEL_26;
    }
    int v18 = *(unsigned char *)sub_10012EF5C((uint64_t)v3, (int *)&v24) == 0;
LABEL_29:
    if (*((unsigned __int8 *)v13 + 43) != v18)
    {
      *((unsigned char *)v13 + 43) = v18;
      sub_100058DB0(__p, "dataRoaming");
      uint64_t v19 = sub_100ECD30C((uint64_t)(v13 + 6), __p);
      sub_100F04328(v19, v18);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
      sub_100ECC040((uint64_t)a1, v24, "Data roaming");
    }
    uint64_t v20 = (void *)v13[1];
    if (v20)
    {
      do
      {
        id v21 = v20;
        uint64_t v20 = (void *)*v20;
      }
      while (v20);
    }
    else
    {
      do
      {
        id v21 = (void *)v13[2];
        BOOL v8 = *v21 == (void)v13;
        int v13 = v21;
      }
      while (!v8);
    }
    int v13 = v21;
  }
  while (v21 != v14);
}

void sub_100ECA1DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ECA1F8(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 272);
  uint64_t v2 = (void *)(result + 280);
  if (v1 != (void *)(result + 280))
  {
    uint64_t v3 = result;
    do
    {
      int v4 = *((unsigned __int8 *)v1 + 40);
      if (*((unsigned char *)v1 + 40)) {
        BOOL v5 = v4 == 5;
      }
      else {
        BOOL v5 = 1;
      }
      if (!v5 && v4 != 255) {
        uint64_t result = sub_100ECA574(v3, *((unsigned int *)v1 + 8), "CB changed");
      }
      uint64_t v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v1[2];
          BOOL v5 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v5);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

uint64_t sub_100ECA29C(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 136));
}

uint64_t sub_100ECA2A4(uint64_t a1, void **a2)
{
  uint64_t v3 = sub_1000389F8(*(uint64_t **)(a1 + 88), 1);
  return *(unsigned int *)(sub_100ECD30C((uint64_t)(v3 + 1), a2) + 4);
}

void sub_100ECA2E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::logic_error a9)
{
  if (a2 == 1)
  {
    exception_ptr = (const std::logic_error *)__cxa_get_exception_ptr(exception_object);
    std::logic_error::logic_error(&a9, exception_ptr);
    __cxa_begin_catch(exception_object);
    std::out_of_range::~out_of_range((std::out_of_range *)&a9);
    __cxa_end_catch();
    JUMPOUT(0x100ECA2D8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ECA350(uint64_t a1, void **a2)
{
  return sub_100ECA2A4(a1 - 8, a2);
}

void sub_100ECA358(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 31);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 16);
  }
  if (v2)
  {
    uint64_t v6 = *(subscriber **)(a2 + 48);
    if (!v6)
    {
      uint64_t v14 = *(NSObject **)(a1 + 56);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v21 = *(void *)(a2 + 8);
      uint64_t v20 = a2 + 8;
      uint64_t v19 = v21;
      if (v3 >= 0) {
        uint64_t v19 = v20;
      }
      int v24 = 136315138;
      uint64_t v25 = v19;
      int v18 = "#E No instance (info) configured for variable '%s'";
      goto LABEL_23;
    }
    uint64_t v7 = subscriber::fromString(v6, (const char *)a2);
    BOOL v8 = *(uint64_t **)(a1 + 88);
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = a1 + 88;
    uint64_t v10 = *(void *)(a1 + 88);
    do
    {
      int v11 = *(_DWORD *)(v10 + 32);
      BOOL v12 = v11 < (int)v7;
      if (v11 >= (int)v7) {
        int v13 = (uint64_t *)v10;
      }
      else {
        int v13 = (uint64_t *)(v10 + 8);
      }
      if (!v12) {
        uint64_t v9 = v10;
      }
      uint64_t v10 = *v13;
    }
    while (*v13);
    if (v9 == a1 + 88 || (int)v7 < *(_DWORD *)(v9 + 32))
    {
LABEL_15:
      uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v7);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v17 = *(void *)(a2 + 8);
      uint64_t v16 = a2 + 8;
      uint64_t v15 = v17;
      if (*(char *)(v16 + 23) >= 0) {
        uint64_t v15 = v16;
      }
      int v24 = 136315138;
      uint64_t v25 = v15;
      int v18 = "#E Sim not found for variable '%s'";
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v24, 0xCu);
      return;
    }
    OsLogContext v22 = sub_1000389F8(v8, v7);
    char v23 = (_DWORD *)sub_100ECD30C((uint64_t)(v22 + 1), (void **)(a2 + 8));
    sub_100F04388((_DWORD *)a2, v23);
  }
}

void sub_100ECA56C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100ECA574(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  uint64_t v7 = v6;
  uint64_t v9 = (uint64_t **)(a1 + 112);
  uint64_t v8 = *(void *)(a1 + 112);
  if (v8)
  {
    uint64_t v10 = a1 + 112;
    do
    {
      int v11 = *(_DWORD *)(v8 + 32);
      BOOL v12 = v11 < (int)a2;
      if (v11 >= (int)a2) {
        int v13 = (uint64_t *)v8;
      }
      else {
        int v13 = (uint64_t *)(v8 + 8);
      }
      if (!v12) {
        uint64_t v10 = v8;
      }
      uint64_t v8 = *v13;
    }
    while (*v13);
    if ((uint64_t **)v10 != v9 && *(_DWORD *)(v10 + 32) <= (int)a2)
    {
      uint64_t v17 = sub_1000389F8(*(uint64_t **)(a1 + 88), a2);
      if (v7)
      {
        int v18 = (BOOL *)v17;
        uint64_t v19 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          if (a3) {
            uint64_t v20 = a3;
          }
          else {
            uint64_t v20 = "unknown";
          }
          uint64_t v21 = asStringBool(*v18);
          uint64_t v22 = asStringBool(v18[3]);
          uint64_t v23 = asStringBool(v18[1]);
          uint64_t v24 = asStringBool(v18[2]);
          *(_DWORD *)std::string buf = 136316418;
          *(void *)&uint8_t buf[4] = "refreshPolicies";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v20;
          *(_WORD *)&buf[22] = 2080;
          *(void *)long long v77 = v21;
          *(_WORD *)&v77[8] = 2080;
          *(void *)&v77[10] = v22;
          __int16 v78 = 2080;
          uint64_t v79 = v23;
          __int16 v80 = 2080;
          uint64_t v81 = v24;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: (%s) fisDataAttached: %s, fisInDataRoaming: %s, fisCSAttached: %s, fisInRoaming: %s", buf, 0x3Eu);
        }
      }
      unint64_t v26 = sub_1000389F8(*v9, a2);
      uint64_t v28 = *v26;
      for (uint64_t i = v26[1]; i != v28; sub_1001FEC1C(i))
        i -= 56;
      v26[1] = v28;
      CFDictionaryRef theDict = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)(a1 + 64));
      uint64_t v30 = ServiceMap;
      if (v31 < 0)
      {
        char v32 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v33 = 5381;
        do
        {
          uint64_t v31 = v33;
          unsigned int v34 = *v32++;
          uint64_t v33 = (33 * v33) ^ v34;
        }
        while (v34);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v31;
      int64x2_t v35 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)buf);
      if (!v35)
      {
        std::mutex::unlock(v30);
        goto LABEL_39;
      }
      uint64_t v37 = v35[3];
      uint64_t v36 = (std::__shared_weak_count *)v35[4];
      if (v36)
      {
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v30);
        atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v36);
        if (!v37) {
          goto LABEL_38;
        }
      }
      else
      {
        std::mutex::unlock(v30);
        if (!v37) {
          goto LABEL_39;
        }
      }
      *(void *)std::string buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v37 + 32))(buf, v37, a2);
      if (*(void *)buf)
      {
        (*(void (**)(long long *__return_ptr))(**(void **)buf + 40))(&v71);
        __p[0] = theDict;
        CFDictionaryRef theDict = (CFDictionaryRef)v71;
        *(void *)&long long v71 = 0;
        sub_100057D78((const void **)__p);
        sub_100057D78((const void **)&v71);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (!v36)
      {
LABEL_39:
        if (theDict) {
          size_t v38 = sub_100080778;
        }
        else {
          size_t v38 = 0;
        }
        if (v38)
        {
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"TechPolicies");
          CFArrayRef v40 = Value;
          if (Value)
          {
            CFTypeID v41 = CFGetTypeID(Value);
            if (v41 == CFArrayGetTypeID())
            {
              uint64_t v68 = subscriber::asString();
              CFIndex Count = CFArrayGetCount(v40);
              if (Count >= 1)
              {
                for (CFIndex j = 0; Count != j; ++j)
                {
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v40, j);
                  CFDictionaryRef v45 = ValueAtIndex;
                  if (ValueAtIndex && (CFTypeID v46 = CFGetTypeID(ValueAtIndex), v46 == CFDictionaryGetTypeID()))
                  {
                    CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue(v45, @"serviceMask");
                    CFNumberRef v48 = v47;
                    if (v47 && (CFTypeID v49 = CFGetTypeID(v47), v49 == CFNumberGetTypeID()))
                    {
                      uint64_t valuePtr = 0;
                      CFNumberGetValue(v48, kCFNumberLongLongType, &valuePtr);
                      CFIndex v50 = CFDictionaryGetValue(v45, @"policy");
                      if (v50)
                      {
                        CFTypeID v51 = CFGetTypeID(v50);
                        if (v51 == CFStringGetTypeID())
                        {
                          __p[0] = 0;
                          __p[1] = 0;
                          uint64_t v73 = 0;
                          memset(buf, 0, sizeof(buf));
                          ctu::cf::assign();
                          *(_OWORD *)std::string __p = *(_OWORD *)buf;
                          uint64_t v73 = *(void *)&buf[16];
                          long long v71 = 0uLL;
                          CFIndex v52 = *(std::__shared_weak_count **)(a1 + 32);
                          if (v52)
                          {
                            uint64_t v53 = *(void *)(a1 + 24);
                            char v54 = std::__shared_weak_count::lock(v52);
                            if (v54)
                            {
                              char v55 = v54;
                              atomic_fetch_add_explicit(&v54->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                              sub_10004D2C8(v54);
                              uint64_t v69 = 0;
                              BOOL v70 = 0;
                              char v56 = std::__shared_weak_count::lock(v55);
                              std::string::size_type v57 = v56;
                              if (v56)
                              {
                                uint64_t v58 = v53 + 8;
                                if (!v53) {
                                  uint64_t v58 = 0;
                                }
                                atomic_fetch_add_explicit(&v56->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                              }
                              else
                              {
                                uint64_t v58 = 0;
                              }
                              uint64_t v69 = v58;
                              BOOL v70 = v56;
                              std::__shared_weak_count::__release_weak(v55);
                              if (v57) {
                                sub_10004D2C8(v57);
                              }
                              sub_100F038BC((uint64_t *)__p, (uint64_t)&v69, v68);
                            }
                          }
                          sub_100088B9C();
                        }
                      }
                      if (!v7) {
                        continue;
                      }
                      os_log_t v63 = *v7;
                      if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
                        continue;
                      }
                      *(_DWORD *)std::string buf = 136315138;
                      *(void *)&uint8_t buf[4] = "refreshPolicies";
                      int v60 = v63;
                      char v61 = "#I %s: policy not found in Policy Dict";
                    }
                    else
                    {
                      if (!v7) {
                        continue;
                      }
                      os_log_t v62 = *v7;
                      if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
                        continue;
                      }
                      *(_DWORD *)std::string buf = 136315138;
                      *(void *)&uint8_t buf[4] = "refreshPolicies";
                      int v60 = v62;
                      char v61 = "#I %s: serviceMask not found in Policy Dict";
                    }
                  }
                  else
                  {
                    if (!v7) {
                      continue;
                    }
                    os_log_t v59 = *v7;
                    if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
                      continue;
                    }
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = "refreshPolicies";
                    int v60 = v59;
                    char v61 = "#I %s: Fail to get policy dict from TechPolicies array";
                  }
                  _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, v61, buf, 0xCu);
                }
              }
LABEL_83:
              sub_100057D78((const void **)&theDict);
              if (v7)
              {
                uint64_t v66 = v26[1] - *v26;
                if (v66)
                {
                  std::string::size_type v67 = *v7;
                  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)std::string buf = 136315394;
                    *(void *)&uint8_t buf[4] = "refreshPolicies";
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&buf[14] = 0x6DB6DB6DB6DB6DB7 * (v66 >> 3);
                    _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I %s: Policy count: %lu", buf, 0x16u);
                  }
                }
              }
              sub_100ECB4B8(a1, a2);
              return 1;
            }
          }
          if (!v7) {
            goto LABEL_83;
          }
          char v64 = *v7;
          if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_83;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = "refreshPolicies";
          std::string::size_type v65 = "#I %s: TechPolicies not found in Carrier Bundle";
        }
        else
        {
          if (!v7) {
            goto LABEL_83;
          }
          char v64 = *v7;
          if (!os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_83;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = "refreshPolicies";
          std::string::size_type v65 = "#I %s: iWLAN settings not found in Carrier Bundle";
        }
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, v65, buf, 0xCu);
        goto LABEL_83;
      }
LABEL_38:
      sub_10004D2C8(v36);
      goto LABEL_39;
    }
  }
  if (v6)
  {
    uint64_t v14 = *v6;
    BOOL v15 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v15) {
      return result;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = "refreshPolicies";
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Sim not found", buf, 0xCu);
  }
  return 0;
}

void sub_100ECB0F8()
{
}

void sub_100ECB110(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 137) < 0) {
    JUMPOUT(0x100ECB120);
  }
  sub_100057D78(&v3);
  _Unwind_Resume(a1);
}

void sub_100ECB128(_Unwind_Exception *a1)
{
  sub_100057D78(&v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100ECB198(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 80);
  uint64_t v2 = (void *)(a1 + 88);
  if (v1 == (void *)(a1 + 88)) {
    return 1;
  }
  uint64_t v24 = a1 + 200;
  uint64_t v25 = a1 + 176;
  uint64_t v22 = a1 + 248;
  uint64_t v23 = a1 + 224;
  LOBYTE(v4) = 1;
  do
  {
    int v28 = *((_DWORD *)v1 + 8);
    BOOL v5 = (char *)sub_1000389F8(*(uint64_t **)(a1 + 88), v28);
    uint64_t v6 = *(uint64_t **)(a1 + 184);
    if (!v6) {
      goto LABEL_10;
    }
    while (1)
    {
      int v7 = *((_DWORD *)v6 + 7);
      if (v28 >= v7) {
        break;
      }
LABEL_7:
      uint64_t v6 = (uint64_t *)*v6;
      if (!v6) {
        goto LABEL_10;
      }
    }
    if (v7 < v28)
    {
      ++v6;
      goto LABEL_7;
    }
    char *v5 = *(unsigned char *)sub_10012EF5C(v25, &v28);
LABEL_10:
    sub_100058DB0(__p, "cellData");
    uint64_t v8 = sub_100ECD30C((uint64_t)(v5 + 8), __p);
    sub_100F04328(v8, *v5);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    for (uint64_t i = *(uint64_t **)(a1 + 208); i; uint64_t i = (uint64_t *)*i)
    {
      int v10 = *((_DWORD *)i + 7);
      if (v28 >= v10)
      {
        if (v10 >= v28)
        {
          v5[1] = *(unsigned char *)sub_10012EF5C(v24, &v28);
          break;
        }
        ++i;
      }
    }
    sub_100058DB0(__p, "csAttached");
    uint64_t v11 = sub_100ECD30C((uint64_t)(v5 + 8), __p);
    sub_100F04328(v11, v5[1]);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    for (CFIndex j = *(uint64_t **)(a1 + 232); j; CFIndex j = (uint64_t *)*j)
    {
      int v13 = *((_DWORD *)j + 7);
      if (v28 >= v13)
      {
        if (v13 >= v28)
        {
          sub_10012EF5C(v23, &v28);
          v5[2] = mapRoamingResultToTriBOOL() != 0;
          break;
        }
        ++j;
      }
    }
    sub_100058DB0(__p, "inRoaming");
    uint64_t v14 = sub_100ECD30C((uint64_t)(v5 + 8), __p);
    sub_100F04328(v14, v5[2]);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    for (k = *(uint64_t **)(a1 + 256); k; k = (uint64_t *)*k)
    {
      int v16 = *((_DWORD *)k + 7);
      if (v28 >= v16)
      {
        if (v16 >= v28)
        {
          v5[3] = *(unsigned char *)sub_10012EF5C(v22, &v28) ^ 1;
          break;
        }
        ++k;
      }
    }
    sub_100058DB0(__p, "dataRoaming");
    uint64_t v17 = sub_100ECD30C((uint64_t)(v5 + 8), __p);
    sub_100F04328(v17, v5[3]);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v4) {
      uint64_t v4 = sub_100ECA574(a1, v28, "Setup policies");
    }
    else {
      uint64_t v4 = 0;
    }
    int v18 = (void *)v1[1];
    if (v18)
    {
      do
      {
        uint64_t v19 = v18;
        int v18 = (void *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        uint64_t v19 = (void *)v1[2];
        BOOL v20 = *v19 == (void)v1;
        uint64_t v1 = v19;
      }
      while (!v20);
    }
    uint64_t v1 = v19;
  }
  while (v19 != v2);
  return v4;
}

void sub_100ECB490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ECB4B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  int v33 = a2;
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  BOOL v5 = (uint64_t **)(a1 + 328);
  uint64_t v6 = (uint64_t **)(a1 + 336);
  uint64_t v7 = *(void *)(a1 + 336);
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = a1 + 336;
  do
  {
    int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 < (int)v2;
    if (v9 >= (int)v2) {
      uint64_t v11 = (uint64_t *)v7;
    }
    else {
      uint64_t v11 = (uint64_t *)(v7 + 8);
    }
    if (!v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }
  while (*v11);
  if ((uint64_t **)v8 != v6 && *(_DWORD *)(v8 + 32) <= (int)v2)
  {
    uint64_t v12 = *sub_1000FD774(a1 + 328, &v33);
    uint64_t v2 = v33;
  }
  else
  {
LABEL_11:
    uint64_t v12 = 0;
  }
  int v13 = *(uint64_t **)(a1 + 112);
  if (!v13) {
    goto LABEL_58;
  }
  uint64_t v14 = a1 + 112;
  uint64_t v15 = *(void *)(a1 + 112);
  do
  {
    int v16 = *(_DWORD *)(v15 + 32);
    BOOL v17 = v16 < (int)v2;
    if (v16 >= (int)v2) {
      int v18 = (uint64_t *)v15;
    }
    else {
      int v18 = (uint64_t *)(v15 + 8);
    }
    if (!v17) {
      uint64_t v14 = v15;
    }
    uint64_t v15 = *v18;
  }
  while (*v18);
  if (v14 == a1 + 112 || *(_DWORD *)(v14 + 32) > (int)v2)
  {
LABEL_58:
    if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v2))
    {
      uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v2);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        int64x2_t v35 = "getAllowedPolicyMasks_sync";
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s: Sim not found", buf, 0xCu);
      }
    }
LABEL_39:
    uint64_t v23 = 0;
    goto LABEL_40;
  }
  while (1)
  {
    while (1)
    {
      int v20 = *((_DWORD *)v13 + 8);
      if (v20 <= (int)v2) {
        break;
      }
      int v13 = (uint64_t *)*v13;
      if (!v13) {
        goto LABEL_30;
      }
    }
    if (v20 >= (int)v2) {
      break;
    }
    int v13 = (uint64_t *)v13[1];
    if (!v13) {
LABEL_30:
    }
      sub_1000C14F0("map::at:  key not found");
  }
  uint64_t v22 = v13[5];
  uint64_t v21 = v13[6];
  if (v22 == v21) {
    goto LABEL_39;
  }
  uint64_t v23 = 0;
  do
  {
    if (*(unsigned char *)(v22 + 48)) {
      uint64_t v24 = *(void *)(v22 + 40);
    }
    else {
      uint64_t v24 = 0;
    }
    uint64_t v23 = (uint64_t *)(v24 | (unint64_t)v23);
    v22 += 56;
  }
  while (v22 != v21);
LABEL_40:
  if ((uint64_t *)v12 == v23)
  {
    if (v4)
    {
      uint64_t v25 = *v4;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315650;
        int64x2_t v35 = "updateiWLanPolicySource";
        __int16 v36 = 2048;
        uint64_t v37 = v12;
        __int16 v38 = 2048;
        uint64_t v39 = v12;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s: Allowed policy masks unchanged 0x%02llx(%lld)", buf, 0x20u);
      }
    }
  }
  else
  {
    v32[0] = 1;
    v32[1] = a1 + 296;
    int v26 = v33;
    char v27 = *v6;
    int v28 = (uint64_t **)(a1 + 336);
    if (*v6)
    {
      while (1)
      {
        while (1)
        {
          int v28 = (uint64_t **)v27;
          int v29 = *((_DWORD *)v27 + 8);
          if (v29 <= v33) {
            break;
          }
          char v27 = *v28;
          uint64_t v6 = v28;
          if (!*v28) {
            goto LABEL_51;
          }
        }
        if (v29 >= v33) {
          break;
        }
        char v27 = v28[1];
        if (!v27)
        {
          uint64_t v6 = v28 + 1;
          goto LABEL_51;
        }
      }
    }
    else
    {
LABEL_51:
      uint64_t v30 = operator new(0x30uLL);
      v30[8] = v26;
      *((void *)v30 + 5) = 0;
      sub_100046C38(v5, (uint64_t)v28, v6, (uint64_t *)v30);
      int v28 = (uint64_t **)v30;
    }
    v28[5] = v23;
    if (v4)
    {
      uint64_t v31 = *v4;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136316162;
        int64x2_t v35 = "updateiWLanPolicySource";
        __int16 v36 = 2048;
        uint64_t v37 = v12;
        __int16 v38 = 2048;
        uint64_t v39 = v12;
        __int16 v40 = 2048;
        CFTypeID v41 = v23;
        __int16 v42 = 2048;
        int v43 = v23;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s: Allowed policy masks changed 0x%02llx(%lld) -> 0x%02llx(%lld)", buf, 0x34u);
      }
    }
    sub_100ECEB4C((uint64_t)v32);
  }
}

void sub_100ECB888(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100ECEB4C((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_100ECB8A4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  char v6 = capabilities::ct::supportsThumperService((capabilities::ct *)a1);
  if (a3 == 0x4000000 && (v6 & 1) != 0)
  {
    a3 = 0x20000;
  }
  else if (a3 != 0x4000000 && (a3 & 0x4000000) != 0)
  {
    uint64_t v7 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#N The connection mask should not have any bit set except the bit for kDataConnectionTypeThumperIMS", buf, 2u);
    }
  }
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), a2);
  uint64_t v11 = *(uint64_t **)(a1 + 112);
  BOOL v10 = (uint64_t *)(a1 + 112);
  int v9 = v11;
  if (!v11) {
    goto LABEL_18;
  }
  uint64_t v12 = v10;
  int v13 = v9;
  do
  {
    int v14 = *((_DWORD *)v13 + 8);
    BOOL v15 = v14 < (int)a2;
    if (v14 >= (int)a2) {
      int v16 = (uint64_t **)v13;
    }
    else {
      int v16 = (uint64_t **)(v13 + 1);
    }
    if (!v15) {
      uint64_t v12 = v13;
    }
    int v13 = *v16;
  }
  while (*v16);
  if (v12 != v10 && *((_DWORD *)v12 + 8) <= (int)a2)
  {
    if (!a3)
    {
      if (!v8) {
        return 0;
      }
      os_log_t v32 = *v8;
      BOOL v18 = 0;
      if (!os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT)) {
        return v18;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "isPolicyAllowedOnMask";
      uint64_t v19 = "#I %s: !!! the connection mask is zero !";
      int v20 = v32;
      uint32_t v21 = 12;
      goto LABEL_22;
    }
    uint64_t v23 = sub_1000389F8(v9, a2);
    uint64_t v24 = *v23;
    uint64_t v25 = v23[1] - *v23;
    if (!v25)
    {
LABEL_31:
      memset(buf, 0, 41);
      int v30 = sub_100ECBD5C(a2, a3, (uint64_t)buf);
      if ((buf[39] & 0x80000000) != 0) {
        operator delete(*(void **)&buf[16]);
      }
      if (v8) {
        int v31 = v30;
      }
      else {
        int v31 = 0;
      }
      if (v31 != 1) {
        return 0;
      }
      BOOL v17 = *v8;
      BOOL v18 = 0;
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        return v18;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "isPolicyAllowedOnMask";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a3;
      uint64_t v19 = "#I %s: No Policy found for connection mask 0x%02llx, treat as Policy not allowed";
      goto LABEL_21;
    }
    uint64_t v26 = 0;
    unint64_t v27 = v25 / 56;
    if (v27 <= 1) {
      unint64_t v27 = 1;
    }
    while (1)
    {
      int v28 = (long long *)(v24 + v26);
      uint64_t v29 = *(void *)(v24 + v26 + 40);
      if ((a3 & ~v29) == 0) {
        break;
      }
      v26 += 56;
      if (!--v27) {
        goto LABEL_31;
      }
    }
    *(_OWORD *)CFNumberRef v48 = 0u;
    *(_OWORD *)CFTypeID v49 = 0u;
    if (*((char *)v28 + 23) < 0)
    {
      sub_10004FC84(v44, *(void **)(v24 + v26), *(void *)(v24 + v26 + 8));
      uint64_t v24 = *v23;
    }
    else
    {
      long long v33 = *v28;
      uint64_t v45 = *((void *)v28 + 2);
      *(_OWORD *)long long v44 = v33;
    }
    char v34 = *(unsigned char *)(v24 + v26 + 48);
    unint64_t v46 = a3;
    uint64_t v47 = v29;
    if (SHIBYTE(v45) < 0)
    {
      sub_10004FC84(v48, v44[0], (unint64_t)v44[1]);
      v49[8] = v34;
      if (SHIBYTE(v45) < 0) {
        operator delete(v44[0]);
      }
    }
    else
    {
      *(_OWORD *)CFNumberRef v48 = *(_OWORD *)v44;
      *(void *)CFTypeID v49 = v45;
      v49[8] = v34;
    }
    int v35 = sub_100ECBD5C(a2, a3, (uint64_t)&v46);
    if (v8) {
      int v36 = v35;
    }
    else {
      int v36 = 0;
    }
    if (v36 == 1)
    {
      uint64_t v37 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v39 = v46;
        uint64_t v38 = v47;
        int v40 = v49[7];
        CFTypeID v41 = (void **)v48[0];
        uint64_t v42 = asStringBool(v49[8]);
        *(_DWORD *)std::string buf = 136316162;
        if (v40 >= 0) {
          int v43 = v48;
        }
        else {
          int v43 = v41;
        }
        *(void *)&uint8_t buf[4] = "isPolicyAllowedOnMask";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v39;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&uint8_t buf[24] = v38;
        *(_WORD *)&unsigned char buf[32] = 2080;
        *(void *)&buf[34] = v43;
        __int16 v51 = 2080;
        uint64_t v52 = v42;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I %s: Policy found for connection mask 0x%02llx: policy mask: 0x%02llx, expr: '%s', allowed: %s", buf, 0x34u);
      }
    }
    BOOL v18 = *(unsigned char *)(*v23 + v26 + 48) != 0;
    if (v49[7] < 0) {
      operator delete(v48[0]);
    }
  }
  else
  {
LABEL_18:
    if (!v8) {
      return 0;
    }
    BOOL v17 = *v8;
    BOOL v18 = 0;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "isPolicyAllowedOnMask";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a3;
      uint64_t v19 = "#I %s: Sim not found for mask 0x%02llx";
LABEL_21:
      int v20 = v17;
      uint32_t v21 = 22;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
      return 0;
    }
  }
  return v18;
}

void sub_100ECBD0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ECBD5C(int a1, unint64_t a2, uint64_t a3)
{
  sub_100ECD684();
  uint64_t v6 = qword_101B12ED0;
  if (qword_101B12ED0)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t *)v6;
        int v8 = *(_DWORD *)(v6 + 32);
        if (v8 <= a1) {
          break;
        }
        uint64_t v6 = *v7;
        int v9 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a1) {
        break;
      }
      uint64_t v6 = v7[1];
      if (!v6)
      {
        int v9 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v9 = &qword_101B12ED0;
    uint64_t v7 = &qword_101B12ED0;
LABEL_9:
    BOOL v10 = v7;
    uint64_t v7 = (uint64_t *)operator new(0x40uLL);
    *((_DWORD *)v7 + 8) = a1;
    unsigned char v7[7] = 0;
    v7[6] = 0;
    void v7[5] = (uint64_t)(v7 + 6);
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = (uint64_t)v10;
    uint64_t *v9 = (uint64_t)v7;
    uint64_t v11 = v7;
    if (*(void *)qword_101B12EC8)
    {
      qword_101B12EC8 = *(void *)qword_101B12EC8;
      uint64_t v11 = (uint64_t *)*v9;
    }
    sub_100046C90((uint64_t *)qword_101B12ED0, v11);
    ++qword_101B12ED8;
  }
  int v13 = (uint64_t **)(v7 + 6);
  uint64_t v12 = (char *)v7[6];
  if (v12)
  {
    int v14 = v7 + 6;
    BOOL v15 = (void *)v7[6];
    do
    {
      unint64_t v16 = v15[4];
      BOOL v17 = v16 >= a2;
      if (v16 >= a2) {
        BOOL v18 = v15;
      }
      else {
        BOOL v18 = v15 + 1;
      }
      if (v17) {
        int v14 = v15;
      }
      BOOL v15 = (void *)*v18;
    }
    while (*v18);
    if (v14 != (uint64_t *)v13 && v14[4] <= a2 && v14[5] == *(void *)a3 && v14[6] == *(void *)(a3 + 8))
    {
      uint64_t v19 = *((unsigned __int8 *)v14 + 79);
      if ((v19 & 0x80u) == 0) {
        uint64_t v20 = *((unsigned __int8 *)v14 + 79);
      }
      else {
        uint64_t v20 = v14[8];
      }
      uint64_t v21 = *(unsigned __int8 *)(a3 + 39);
      int v22 = (char)v21;
      if ((v21 & 0x80u) != 0) {
        uint64_t v21 = *(void *)(a3 + 24);
      }
      if (v20 == v21)
      {
        uint64_t v23 = (const void **)(v14 + 7);
        uint64_t v24 = v22 >= 0 ? (unsigned __int8 *)(a3 + 16) : *(unsigned __int8 **)(a3 + 16);
        if ((v19 & 0x80) != 0)
        {
          if (memcmp(*v23, v24, v14[8])) {
            goto LABEL_43;
          }
        }
        else if (*((unsigned char *)v14 + 79))
        {
          do
          {
            if (*(unsigned __int8 *)v23 != *v24) {
              goto LABEL_43;
            }
            uint64_t v23 = (const void **)((char *)v23 + 1);
            ++v24;
            --v19;
          }
          while (v19);
        }
        if (*((unsigned __int8 *)v14 + 80) == *(unsigned __int8 *)(a3 + 40)) {
          return 0;
        }
      }
    }
    while (1)
    {
LABEL_43:
      while (1)
      {
        uint64_t v25 = v12;
        unint64_t v27 = *((void *)v12 + 4);
        if (v27 <= a2) {
          break;
        }
        uint64_t v12 = *(char **)v12;
        int v13 = (uint64_t **)v25;
        if (!*(void *)v25) {
          goto LABEL_49;
        }
      }
      if (v27 >= a2) {
        break;
      }
      uint64_t v12 = (char *)*((void *)v12 + 1);
      if (!v12)
      {
        int v13 = (uint64_t **)(v25 + 8);
        goto LABEL_49;
      }
    }
  }
  else
  {
    uint64_t v25 = (char *)(v7 + 6);
LABEL_49:
    int v28 = v25;
    uint64_t v25 = (char *)operator new(0x58uLL);
    *((void *)v25 + 4) = a2;
    *(_OWORD *)(v25 + 40) = 0u;
    *(_OWORD *)(v25 + 56) = 0u;
    *(_OWORD *)(v25 + 65) = 0u;
    *(void *)uint64_t v25 = 0;
    *((void *)v25 + 1) = 0;
    *((void *)v25 + 2) = v28;
    *int v13 = (uint64_t *)v25;
    uint64_t v29 = *(void *)v7[5];
    int v30 = (uint64_t *)v25;
    if (v29)
    {
      void v7[5] = v29;
      int v30 = *v13;
    }
    sub_100046C90((uint64_t *)v7[6], v30);
    ++v7[7];
  }
  *(_OWORD *)(v25 + 40) = *(_OWORD *)a3;
  std::string::operator=((std::string *)(v25 + 56), (const std::string *)(a3 + 16));
  v25[80] = *(unsigned char *)(a3 + 40);
  return 1;
}

BOOL sub_100ECBFF8(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = ConnectionTypeToMask();

  return sub_100ECB8A4(a1, a2, v4);
}

void sub_100ECC040(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  uint64_t v7 = v6;
  int v9 = (uint64_t **)(a1 + 112);
  uint64_t v8 = *(void *)(a1 + 112);
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v10 = a1 + 112;
  do
  {
    int v11 = *(_DWORD *)(v8 + 32);
    BOOL v12 = v11 < (int)a2;
    if (v11 >= (int)a2) {
      int v13 = (uint64_t *)v8;
    }
    else {
      int v13 = (uint64_t *)(v8 + 8);
    }
    if (!v12) {
      uint64_t v10 = v8;
    }
    uint64_t v8 = *v13;
  }
  while (*v13);
  if ((uint64_t **)v10 != v9 && *(_DWORD *)(v10 + 32) <= (int)a2)
  {
    BOOL v15 = sub_1000389F8(*(uint64_t **)(a1 + 88), a2);
    if (v7)
    {
      unint64_t v16 = (BOOL *)v15;
      BOOL v17 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          BOOL v18 = a3;
        }
        else {
          BOOL v18 = "unknown";
        }
        uint64_t v19 = asStringBool(*v16);
        uint64_t v20 = asStringBool(v16[3]);
        uint64_t v21 = asStringBool(v16[1]);
        uint64_t v22 = asStringBool(v16[2]);
        *(_DWORD *)std::string buf = 136316418;
        int v35 = "recalculatePolicies";
        __int16 v36 = 2080;
        uint64_t v37 = v18;
        __int16 v38 = 2080;
        uint64_t v39 = v19;
        __int16 v40 = 2080;
        uint64_t v41 = v20;
        __int16 v42 = 2080;
        uint64_t v43 = v21;
        __int16 v44 = 2080;
        uint64_t v45 = v22;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s: (%s) fisDataAttached: %s, fisInDataRoaming: %s, fisCSAttached: %s, fisInRoaming: %s", buf, 0x3Eu);
      }
    }
    uint64_t v23 = sub_1000389F8(*v9, a2);
    uint64_t v24 = v23[1] - *v23;
    if (v24)
    {
      uint64_t v25 = 0;
      unint64_t v26 = v24 / 56;
      if (v26 <= 1) {
        uint64_t v27 = 1;
      }
      else {
        uint64_t v27 = v26;
      }
      do
      {
        uint64_t v28 = *v23 + v25;
        uint64_t v29 = **(void **)(v28 + 24);
        if (v29) {
          LODWORD(v29) = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
        }
        if (*(unsigned __int8 *)(v28 + 48) != v29)
        {
          *(unsigned char *)(v28 + 48) = v29;
          if (v7)
          {
            int v30 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v31 = *v23 + v25;
              os_log_t v32 = *(const char **)(v31 + 40);
              uint64_t v33 = asStringBool(*(unsigned char *)(v31 + 48));
              *(_DWORD *)std::string buf = 136315650;
              int v35 = "recalculatePolicies";
              __int16 v36 = 2048;
              uint64_t v37 = v32;
              __int16 v38 = 2080;
              uint64_t v39 = v33;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I %s: Tech Policy changed for typeMask: 0x%02llx, allowed: %s", buf, 0x20u);
            }
          }
        }
        v25 += 56;
        --v27;
      }
      while (v27);
    }
    sub_100ECB4B8(a1, a2);
  }
  else
  {
LABEL_11:
    if (v6)
    {
      int v14 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        int v35 = "recalculatePolicies";
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s: Sim not found", buf, 0xCu);
      }
    }
  }
}

uint64_t sub_100ECC458(void *a1)
{
  uint64_t v1 = a1[7];
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = a1[16];
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I DATA:: ------- %s ==>> -------", buf, 0xCu);
  }
  uint64_t v117 = 0;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v106 = 0u;
  long long v104 = 0u;
  *(_OWORD *)char v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  *(_OWORD *)std::string buf = 0u;
  sub_10004DE24((uint64_t)buf);
  uint64_t v3 = (void *)a1[10];
  if (v3 != a1 + 11)
  {
    do
    {
      long long __p = 0uLL;
      uint64_t v100 = 0;
      sub_1004FD2F4((uint64_t)&buf[8], &__p);
      if (SHIBYTE(v100) < 0) {
        operator delete((void *)__p);
      }
      int v4 = *((unsigned __int8 *)v3 + 40);
      int v5 = *((unsigned __int8 *)v3 + 43);
      int v6 = *((unsigned __int8 *)v3 + 41);
      int v7 = *((unsigned __int8 *)v3 + 42);
      uint64_t v8 = sub_10004B96C(buf, (uint64_t)"\t", 1);
      int v9 = sub_10004B96C(v8, (uint64_t)"Sim: ", 5);
      uint64_t v10 = (const char *)subscriber::asString();
      size_t v11 = strlen(v10);
      BOOL v12 = sub_10004B96C(v9, (uint64_t)v10, v11);
      int v13 = sub_10004B96C(v12, (uint64_t)" (", 2);
      int v14 = sub_10004B96C(v13, (uint64_t)"fisDataAttached=", 16);
      BOOL v15 = (const char *)asStringBool(v4 != 0);
      size_t v16 = strlen(v15);
      BOOL v17 = sub_10004B96C(v14, (uint64_t)v15, v16);
      BOOL v18 = sub_10004B96C(v17, (uint64_t)", ", 2);
      uint64_t v19 = sub_10004B96C(v18, (uint64_t)"fisInDataRoaming=", 17);
      uint64_t v20 = (const char *)asStringBool(v5 != 0);
      size_t v21 = strlen(v20);
      uint64_t v22 = sub_10004B96C(v19, (uint64_t)v20, v21);
      uint64_t v23 = sub_10004B96C(v22, (uint64_t)", ", 2);
      uint64_t v24 = sub_10004B96C(v23, (uint64_t)"fisCSAttached=", 14);
      uint64_t v25 = (const char *)asStringBool(v6 != 0);
      size_t v26 = strlen(v25);
      uint64_t v27 = sub_10004B96C(v24, (uint64_t)v25, v26);
      uint64_t v28 = sub_10004B96C(v27, (uint64_t)", ", 2);
      uint64_t v29 = sub_10004B96C(v28, (uint64_t)"fisInRoaming=", 13);
      int v30 = (const char *)asStringBool(v7 != 0);
      size_t v31 = strlen(v30);
      os_log_t v32 = sub_10004B96C(v29, (uint64_t)v30, v31);
      sub_10004B96C(v32, (uint64_t)")", 1);
      uint64_t v33 = a1[7];
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        sub_10004BC98((uint64_t)&buf[8], &__p);
        uint64_t p_p = (uint64_t)&__p;
        if (v100 < 0) {
          uint64_t p_p = __p;
        }
        *(_DWORD *)int v97 = 136315138;
        uint64_t v98 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", v97, 0xCu);
        if (SHIBYTE(v100) < 0) {
          operator delete((void *)__p);
        }
      }
      int v35 = (void *)v3[1];
      if (v35)
      {
        do
        {
          __int16 v36 = v35;
          int v35 = (void *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          __int16 v36 = (void *)v3[2];
          BOOL v37 = *v36 == (void)v3;
          uint64_t v3 = v36;
        }
        while (!v37);
      }
      uint64_t v3 = v36;
    }
    while (v36 != a1 + 11);
  }
  __int16 v38 = (void *)a1[13];
  if (v38 != a1 + 14)
  {
    do
    {
      long long __p = 0uLL;
      uint64_t v100 = 0;
      sub_1004FD2F4((uint64_t)&buf[8], &__p);
      if (SHIBYTE(v100) < 0) {
        operator delete((void *)__p);
      }
      uint64_t v39 = sub_10004B96C(buf, (uint64_t)"\t", 1);
      __int16 v40 = sub_10004B96C(v39, (uint64_t)"Sim: ", 5);
      uint64_t v41 = (const char *)subscriber::asString();
      size_t v42 = strlen(v41);
      uint64_t v43 = sub_10004B96C(v40, (uint64_t)v41, v42);
      sub_10004B96C(v43, (uint64_t)" Policies:", 10);
      __int16 v44 = a1[7];
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        sub_10004BC98((uint64_t)&buf[8], &__p);
        uint64_t v45 = (uint64_t)&__p;
        if (v100 < 0) {
          uint64_t v45 = __p;
        }
        *(_DWORD *)int v97 = 136315138;
        uint64_t v98 = v45;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", v97, 0xCu);
        if (SHIBYTE(v100) < 0) {
          operator delete((void *)__p);
        }
      }
      uint64_t v46 = v38[5];
      uint64_t v47 = v38[6];
      while (v46 != v47)
      {
        long long __p = 0uLL;
        uint64_t v100 = 0;
        sub_1004FD2F4((uint64_t)&buf[8], &__p);
        if (SHIBYTE(v100) < 0) {
          operator delete((void *)__p);
        }
        CFNumberRef v48 = sub_10004B96C(buf, (uint64_t)" [", 2);
        CFTypeID v49 = sub_10004B96C(v48, (uint64_t)"exprString=", 11);
        int v50 = *(char *)(v46 + 23);
        if (v50 >= 0) {
          uint64_t v51 = v46;
        }
        else {
          uint64_t v51 = *(void *)v46;
        }
        if (v50 >= 0) {
          uint64_t v52 = *(unsigned __int8 *)(v46 + 23);
        }
        else {
          uint64_t v52 = *(void *)(v46 + 8);
        }
        uint64_t v53 = sub_10004B96C(v49, v51, v52);
        char v54 = sub_10004B96C(v53, (uint64_t)", ", 2);
        sub_10004B96C(v54, (uint64_t)"typeMask=", 9);
        char v55 = (void *)std::ostream::operator<<();
        char v56 = sub_10004B96C(v55, (uint64_t)", ", 2);
        sub_10004B96C(v56, (uint64_t)"allowed=", 8);
        std::string::size_type v57 = (void *)std::ostream::operator<<();
        sub_10004B96C(v57, (uint64_t)"]", 1);
        uint64_t v58 = a1[7];
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          sub_10004BC98((uint64_t)&buf[8], &__p);
          uint64_t v59 = (uint64_t)&__p;
          if (v100 < 0) {
            uint64_t v59 = __p;
          }
          *(_DWORD *)int v97 = 136315138;
          uint64_t v98 = v59;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", v97, 0xCu);
          if (SHIBYTE(v100) < 0) {
            operator delete((void *)__p);
          }
        }
        v46 += 56;
      }
      int v60 = (void *)v38[1];
      if (v60)
      {
        do
        {
          char v61 = v60;
          int v60 = (void *)*v60;
        }
        while (v60);
      }
      else
      {
        do
        {
          char v61 = (void *)v38[2];
          BOOL v37 = *v61 == (void)v38;
          __int16 v38 = v61;
        }
        while (!v37);
      }
      __int16 v38 = v61;
    }
    while (v61 != a1 + 14);
  }
  long long __p = 0uLL;
  uint64_t v100 = 0;
  sub_1004FD2F4((uint64_t)&buf[8], &__p);
  if (SHIBYTE(v100) < 0) {
    operator delete((void *)__p);
  }
  os_log_t v62 = sub_10004B96C(buf, (uint64_t)"\t", 1);
  os_log_t v63 = sub_10004B96C(v62, (uint64_t)"PrintThrottlingMap: ", 20);
  std::ios_base::getloc((const std::ios_base *)((char *)v63 + *(void *)(*v63 - 24)));
  char v64 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v64->__vftable[2].~facet_0)(v64, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  sub_100ECD684();
  std::string::size_type v65 = (uint64_t *)qword_101B12EC8;
  if ((uint64_t *)qword_101B12EC8 != &qword_101B12ED0)
  {
    do
    {
      uint64_t v66 = sub_10004B96C(buf, (uint64_t)"Sim: ", 5);
      std::string::size_type v67 = (const char *)subscriber::asString();
      size_t v68 = strlen(v67);
      uint64_t v69 = sub_10004B96C(v66, (uint64_t)v67, v68);
      std::ios_base::getloc((const std::ios_base *)((char *)v69 + *(void *)(*v69 - 24)));
      BOOL v70 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10);
      std::locale::~locale((std::locale *)&__p);
      std::ostream::put();
      std::ostream::flush();
      long long v71 = (uint64_t *)v65[5];
      if (v71 != v65 + 6)
      {
        do
        {
          char v72 = sub_10004B96C(buf, (uint64_t)" [", 2);
          sub_10004B96C(v72, (uint64_t)"pald.fConnectionMask=", 21);
          uint64_t v73 = (void *)std::ostream::operator<<();
          uint64_t v74 = sub_10004B96C(v73, (uint64_t)", ", 2);
          sub_10004B96C(v74, (uint64_t)"pald.fTypeMask=", 15);
          uint64_t v75 = (void *)std::ostream::operator<<();
          std::string::size_type v76 = sub_10004B96C(v75, (uint64_t)", ", 2);
          long long v77 = sub_10004B96C(v76, (uint64_t)"pald.fExprString=", 17);
          int v78 = *((char *)v71 + 79);
          if (v78 >= 0) {
            uint64_t v79 = (uint64_t)(v71 + 7);
          }
          else {
            uint64_t v79 = v71[7];
          }
          if (v78 >= 0) {
            uint64_t v80 = *((unsigned __int8 *)v71 + 79);
          }
          else {
            uint64_t v80 = v71[8];
          }
          uint64_t v81 = sub_10004B96C(v77, v79, v80);
          long long v82 = sub_10004B96C(v81, (uint64_t)", ", 2);
          int v83 = sub_10004B96C(v82, (uint64_t)"pald.fAllowed=", 14);
          uint64_t v84 = (const char *)asStringBool(*((unsigned char *)v71 + 80));
          size_t v85 = strlen(v84);
          long long v86 = sub_10004B96C(v83, (uint64_t)v84, v85);
          sub_10004B96C(v86, (uint64_t)"]", 1);
          uint64_t v87 = (uint64_t *)v71[1];
          if (v87)
          {
            do
            {
              long long v88 = v87;
              uint64_t v87 = (uint64_t *)*v87;
            }
            while (v87);
          }
          else
          {
            do
            {
              long long v88 = (uint64_t *)v71[2];
              BOOL v37 = *v88 == (void)v71;
              long long v71 = v88;
            }
            while (!v37);
          }
          long long v71 = v88;
        }
        while (v88 != v65 + 6);
      }
      std::ios_base::getloc((const std::ios_base *)&buf[*(void *)(*(void *)buf - 24)]);
      uint64_t v89 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v89->__vftable[2].~facet_0)(v89, 10);
      std::locale::~locale((std::locale *)&__p);
      std::ostream::put();
      std::ostream::flush();
      long long v90 = (uint64_t *)v65[1];
      if (v90)
      {
        do
        {
          uint64_t v91 = v90;
          long long v90 = (uint64_t *)*v90;
        }
        while (v90);
      }
      else
      {
        do
        {
          uint64_t v91 = (uint64_t *)v65[2];
          BOOL v37 = *v91 == (void)v65;
          std::string::size_type v65 = v91;
        }
        while (!v37);
      }
      std::string::size_type v65 = v91;
    }
    while (v91 != &qword_101B12ED0);
  }
  uint64_t v92 = a1[7];
  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[8], &__p);
    if (v100 >= 0) {
      uint64_t v93 = (uint64_t)&__p;
    }
    else {
      uint64_t v93 = __p;
    }
    *(_DWORD *)int v97 = 136315138;
    uint64_t v98 = v93;
    _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I DATA:: %s", v97, 0xCu);
    if (SHIBYTE(v100) < 0) {
      operator delete((void *)__p);
    }
    uint64_t v92 = a1[7];
  }
  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v94 = a1[16];
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v94;
    _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I DATA:: ------- <<== %s -------", (uint8_t *)&__p, 0xCu);
  }
  if (SHIBYTE(v106) < 0) {
    operator delete(v105[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100ECCFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24)
{
}

void sub_100ECD078(uint64_t a1, char *a2, std::__shared_weak_count **a3)
{
  v22[0] = 0;
  v22[1] = 0;
  uint64_t v23 = 0;
  sub_100058DB0(v22, a2);
  sub_100058DB0(v15, a2);
  int v7 = *a3;
  int v6 = a3[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  LOBYTE(v17) = 0;
  HIDWORD(v17) = 0;
  if (SHIBYTE(v16) < 0)
  {
    sub_10004FC84(&__p, v15[0], (unint64_t)v15[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v15;
    uint64_t v19 = v16;
  }
  uint64_t v8 = (void **)(a1 + 8);
  v20[0] = v7;
  v20[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = 0;
  uint64_t v26 = 0;
  int v9 = (char **)sub_100046ED4(a1 + 8, &v26, v22);
  if (!*v9)
  {
    uint64_t v10 = v9;
    uint64_t v25 = 0;
    size_t v11 = (char *)operator new(0x70uLL);
    v24[0] = v11;
    v24[1] = a1 + 16;
    BOOL v12 = v11 + 32;
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(v12, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      *(_OWORD *)BOOL v12 = *(_OWORD *)v22;
      *((void *)v11 + 6) = v23;
    }
    *((void *)v11 + 7) = v17;
    *((_OWORD *)v11 + 4) = __p;
    *((void *)v11 + 10) = v19;
    long long __p = 0uLL;
    uint64_t v19 = 0;
    *(_OWORD *)(v11 + 88) = *(_OWORD *)v20;
    v20[0] = 0;
    v20[1] = 0;
    *((void *)v11 + 13) = v21;
    LOBYTE(v25) = 1;
    uint64_t v13 = v26;
    *(void *)size_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v13;
    const char *v10 = v11;
    int v14 = (void *)**v8;
    if (v14)
    {
      void *v8 = v14;
      size_t v11 = *v10;
    }
    sub_100046C90(*(uint64_t **)(a1 + 16), (uint64_t *)v11);
    ++*(void *)(a1 + 24);
    v24[0] = 0;
    sub_100ECEBB0((uint64_t)v24);
  }
  if (v20[1]) {
    std::__shared_weak_count::__release_weak(v20[1]);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)__p);
  }
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
}

void sub_100ECD26C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_100ECEBB0(v29 - 80);
  sub_100ECD2CC((uint64_t)&a16);
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100ECD2CC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100ECD30C(uint64_t a1, void **a2)
{
  uint64_t v2 = *sub_100046ED4(a1, &v4, a2);
  if (!v2) {
    sub_1000C14F0("map::at:  key not found");
  }
  return v2 + 56;
}

void sub_100ECD350(uint64_t a1)
{
  sub_100ECD6F4(a1);

  operator delete();
}

uint64_t sub_100ECD388(uint64_t a1)
{
  return sub_100ECD6F4(a1 - 8);
}

void sub_100ECD390(uint64_t a1)
{
  sub_100ECD6F4(a1 - 8);

  operator delete();
}

void sub_100ECD3CC(void *a1)
{
  if (a1)
  {
    sub_100ECD3CC(*a1);
    sub_100ECD3CC(a1[1]);
    sub_100ECD420((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100ECD420(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

char *sub_100ECD484(int64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x492492492492492) {
    sub_10006A748();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[1].i64[0] - a1->i64[0]) >> 3)) >= 0x249249249249249) {
    unint64_t v6 = 0x492492492492492;
  }
  else {
    unint64_t v6 = v3;
  }
  uint64_t v24 = a1 + 1;
  if (v6)
  {
    if (v6 > 0x492492492492492) {
      sub_10006A7CC();
    }
    int v7 = (char *)operator new(56 * v6);
  }
  else
  {
    int v7 = 0;
  }
  uint64_t v8 = &v7[56 * v2];
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  int v9 = &v7[56 * v6];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(v8 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 16) = 0;
  *((void *)v8 + 5) = *(void *)(a2 + 40);
  v8[48] = *(unsigned char *)(a2 + 48);
  uint64_t v10 = v8 + 56;
  v22.i64[1] = (uint64_t)(v8 + 56);
  uint64_t v23 = v9;
  uint64_t v12 = a1->i64[0];
  unint64_t v11 = a1->u64[1];
  if (v11 == a1->i64[0])
  {
    int64x2_t v18 = vdupq_n_s64(v11);
  }
  else
  {
    uint64_t v13 = 0;
    do
    {
      int v14 = &v8[v13];
      uint64_t v15 = v11 + v13;
      long long v16 = *(_OWORD *)(v11 + v13 - 56);
      *((void *)v14 - 5) = *(void *)(v11 + v13 - 40);
      *(_OWORD *)(v14 - 56) = v16;
      *(void *)(v15 - 48) = 0;
      *(void *)(v15 - 40) = 0;
      *(void *)(v15 - 56) = 0;
      *((_OWORD *)v14 - 2) = *(_OWORD *)(v11 + v13 - 32);
      *(void *)(v15 - 32) = 0;
      *(void *)(v15 - 24) = 0;
      uint64_t v17 = *(void *)(v11 + v13 - 16);
      *(v14 - 8) = *(unsigned char *)(v11 + v13 - 8);
      *((void *)v14 - 2) = v17;
      v13 -= 56;
    }
    while (v11 + v13 != v12);
    int64x2_t v18 = *a1;
    v8 += v13;
    uint64_t v10 = (char *)v22.i64[1];
    int v9 = v23;
  }
  a1->i64[0] = (uint64_t)v8;
  a1->i64[1] = (uint64_t)v10;
  int64x2_t v22 = v18;
  uint64_t v19 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v9;
  uint64_t v23 = v19;
  uint64_t v21 = v18.i64[0];
  sub_100ECD634((uint64_t)&v21);
  return v10;
}

uint64_t sub_100ECD634(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    sub_1001FEC1C(i - 56);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100ECD684()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12EC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12EC0))
  {
    qword_101B12ED8 = 0;
    qword_101B12ED0 = 0;
    qword_101B12EC8 = (uint64_t)&qword_101B12ED0;
    __cxa_guard_release(&qword_101B12EC0);
  }
}

uint64_t sub_100ECD6F4(uint64_t a1)
{
  *(void *)a1 = off_101A69070;
  *(void *)(a1 + 8) = off_101A690D8;
  uint64_t v2 = (void *)(a1 + 296);
  sub_1000346F8(a1 + 328, *(void **)(a1 + 336));
  sub_100ECD820(v2);
  sub_100087F94(a1 + 272, *(void **)(a1 + 280));
  sub_1000346F8(a1 + 248, *(void **)(a1 + 256));
  sub_1000346F8(a1 + 224, *(void **)(a1 + 232));
  sub_1000346F8(a1 + 200, *(void **)(a1 + 208));
  sub_1000346F8(a1 + 176, *(void **)(a1 + 184));
  sub_1007035FC(a1 + 152, *(void **)(a1 + 160));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100ECDAEC(*(void **)(a1 + 112));
  sub_100ECDA98(*(void **)(a1 + 88));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));
  sub_100087E88((void *)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void *sub_100ECD820(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100ECD8A4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100ECD970(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[5], v1, (dispatch_function_t)sub_100ECDA48);
  __cxa_rethrow();
}

void sub_100ECD998(_Unwind_Exception *a1)
{
}

void sub_100ECD9B0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100ECD9E8(uint64_t a1)
{
}

uint64_t sub_100ECDA04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100ECDA48(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100ECDA78()
{
}

uint64_t sub_100ECDA8C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 56;
}

void sub_100ECDA98(void *a1)
{
  if (a1)
  {
    sub_100ECDA98(*a1);
    sub_100ECDA98(a1[1]);
    sub_100ECD3CC((void *)a1[7]);
    operator delete(a1);
  }
}

void sub_100ECDAEC(void *a1)
{
  if (a1)
  {
    sub_100ECDAEC(*a1);
    sub_100ECDAEC(a1[1]);
    uint64_t v2 = a1[5];
    if (v2)
    {
      uint64_t v3 = a1[6];
      uint64_t v4 = (void *)a1[5];
      if (v3 != v2)
      {
        do
        {
          v3 -= 56;
          sub_1001FEC1C(v3);
        }
        while (v3 != v2);
        uint64_t v4 = (void *)a1[5];
      }
      a1[6] = v2;
      operator delete(v4);
    }
    operator delete(a1);
  }
}

void sub_100ECDB7C()
{
}

__n128 sub_100ECDB90(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A69280;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100ECDBE4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69280;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ECDC1C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_100A5892C((uint64_t)v3, a2, "PersonalityID", "State");
  unint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1007035FC((uint64_t)&v9, v10);
}

void sub_100ECDCEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100ECDD04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECDD44()
{
}

void sub_100ECDD54()
{
}

__n128 sub_100ECDD68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A69300;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100ECDDBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69300;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ECDDF4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  unint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100ECDEB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100ECDECC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECDF0C()
{
}

void sub_100ECDF1C()
{
}

__n128 sub_100ECDF30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A69380;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100ECDF84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69380;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ECDFBC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  unint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100ECE07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100ECE094(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECE0D4()
{
}

void sub_100ECE0E4()
{
}

__n128 sub_100ECE0F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A69400;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100ECE14C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ECE184(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  unint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100ECE244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100ECE25C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECE29C()
{
}

void sub_100ECE2AC()
{
}

__n128 sub_100ECE2C0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A69480;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100ECE314(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69480;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ECE34C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  unint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100ECE40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100ECE424(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECE464()
{
}

void sub_100ECE474()
{
}

__n128 sub_100ECE488(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A69500;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100ECE4DC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69500;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ECE514(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v15 = 0;
  long long v16 = 0;
  int v14 = &v15;
  sub_10008AAD8((uint64_t)&v14, a2);
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  unint64_t v11 = (void **)*v3;
  uint64_t v12 = v5;
  if (v3[2])
  {
    v5[2] = &v12;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    unint64_t v11 = &v12;
  }
  int v9 = v14;
  v10[0] = v15;
  v10[1] = v16;
  if (v16)
  {
    void v15[2] = v10;
    int v14 = &v15;
    uint64_t v15 = 0;
    long long v16 = 0;
  }
  else
  {
    int v9 = v10;
  }
  sub_100A555B4((uint64_t)v3, &v9);
  sub_100087F94((uint64_t)&v9, v10[0]);
  if (rest::operator!=())
  {
    unint64_t v6 = (void (*)(void *, void ***))a1[3];
    uint64_t v7 = a1[4];
    uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      unint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
    }
    v6(v8, &v11);
  }
  sub_100087F94((uint64_t)&v11, v12);
  sub_100087F94((uint64_t)&v14, v15);
}

void sub_100ECE654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, void *a14, uint64_t a15, char a16, void *a17)
{
}

uint64_t sub_100ECE694(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECE6D4()
{
}

void sub_100ECE6E4()
{
}

void *sub_100ECE6F8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A69580;
  result[1] = v3;
  return result;
}

uint64_t sub_100ECE740(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A69580;
  a2[1] = v2;
  return result;
}

void sub_100ECE76C(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  unint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v26;
      uint64_t v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_object_t v22 = xpc_uint64_create(v6[5]);
      if (!v22) {
        xpc_object_t v22 = xpc_null_create();
      }
      long long __p = &v26;
      uint64_t v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      uint64_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          long long v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          unint64_t v6 = v16;
        }
        while (!v17);
      }
      unint64_t v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/iwlan_policies");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_100ECEA40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100ECEB00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ECEB40()
{
}

uint64_t sub_100ECEB4C(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_100ECEBB0(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100ECD420((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_100ECEF04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ECF184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ECF990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100ECFA50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100ECFCBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100ECFD90(void *a1, id *a2, uint64_t a3, uint64_t a4)
{
  *a1 = off_101A69610;
  xpc_object_t v8 = [StewieCLLocationManager alloc];
  xpc_object_t v9 = sub_100200FB4(a2);
  a1[1] = [(StewieCLLocationManager *)v8 initWithQueue:v9 locationDataCallback:a3 authorizationChangedCallback:a4];

  return a1;
}

void sub_100ECFE28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100ECFE38(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) setupManager:a2];
}

id sub_100ECFE44(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) setEmergency:a2];
}

id sub_100ECFE50(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) setLocationUpdateRequested:a2];
}

id sub_100ECFE5C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 8) configureAccuracy:a2];
}

uint64_t sub_100ECFE68(uint64_t a1)
{
  return a1;
}

void sub_100ECFE94(uint64_t a1)
{
  operator delete();
}

uint64_t sub_100ECFEE0@<X0>(unsigned __int8 *a1@<X1>, unsigned __int8 *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = (char *)operator new(0x28uLL);
  uint64_t result = sub_100ECFF44((uint64_t)v6, a1, a2);
  *a3 = v6 + 24;
  a3[1] = v6;
  return result;
}

void sub_100ECFF30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100ECFF44(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_101A69678;
  sub_100ED005C((void **)(a1 + 24), *a2, *a3);
  return a1;
}

void sub_100ECFF94(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100ECFFA8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A69678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100ECFFC8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A69678;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100ED001C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
}

void **sub_100ED005C(void **a1, int a2, int a3)
{
  *a1 = 0;
  a1[1] = 0;
  if (a2)
  {
    id v5 = +[CLEmergencyClientEnablementAssertion newAssertionForBundlePath:@"/System/Library/LocationBundles/Bifrost.bundle" withReason:@"Emergency STW Telephony"];
    unint64_t v6 = *a1;
    *a1 = v5;
  }
  if (a3)
  {
    id v7 = +[CLEmergencyClientEnablementAssertion newAssertionForBundlePath:@"/System/Library/LocationBundles/CompassCalibration.bundle" withReason:@"Emergency STW Telephony"];
    xpc_object_t v8 = a1[1];
    a1[1] = v7;
  }
  return a1;
}

void sub_100ED00E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100ED00FC@<X0>(id *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  xpc_object_t v8 = operator new(0x28uLL);
  uint64_t result = sub_100ED0170(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_100ED015C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100ED0170(void *a1, id *a2, uint64_t a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A696C8;
  sub_100ECFD90(a1 + 3, a2, a3, a4);
  return a1;
}

void sub_100ED01B8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100ED01CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A696C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100ED01EC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A696C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100ED0240(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

double sub_100ED0268@<D0>(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  *(_OWORD *)id v5 = 0uLL;
  sub_10035D4B8((void *)(a1 + 8), a2, v5);
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

double sub_100ED02B0@<D0>(uint64_t a1@<X0>, NSObject **a2@<X1>, int a3@<W2>, _OWORD *a4@<X8>)
{
  int v7 = a3;
  *(_OWORD *)unint64_t v6 = 0uLL;
  sub_100F802D4((void *)(a1 + 8), a2, &v7, v6);
  double result = v6[0];
  *a4 = *(_OWORD *)v6;
  return result;
}

void sub_100ED0304(EmergencyCallManagerFactoryInterface *this)
{
  *(void *)this = off_101A69738;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  EmergencyCallManagerFactoryInterface::~EmergencyCallManagerFactoryInterface(this);
}

void sub_100ED0360(EmergencyCallManagerFactoryInterface *this)
{
  *(void *)this = off_101A69738;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  EmergencyCallManagerFactoryInterface::~EmergencyCallManagerFactoryInterface(this);

  operator delete();
}

void sub_100ED03D0(void *a1)
{
  sub_10003E168(&v2, a1);
  uint64_t v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100ED049C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ED04C0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      xpc_object_t v4 = *(void **)(a1 + 32);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, v4);
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100ED05D4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100ED05F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t sub_100ED0600(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    xpc_object_t v4 = (wis::MetricContainer *)v3;
    id v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    unint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100ED075C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100ED07E0(uint64_t result, uint64_t a2)
{
  char v2 = *(unsigned char *)(result + 32);
  *(_DWORD *)(a2 + 24) |= 1u;
  *(unsigned char *)(a2 + 16) = v2;
  return result;
}

uint64_t *sub_100ED07F8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v4 = a1;
  v5[0] = v1;
  unsigned __int16 v2 = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 72) + 32))(*(void *)(*(void *)v1 + 72));
  if (v2 >= 0x100u)
  {
    v5[1] = (uint64_t)_NSConcreteStackBlock;
    void v5[2] = 0x40000000;
    double v5[3] = (uint64_t)sub_100ED07E0;
    v5[4] = (uint64_t)&unk_101A697A0;
    BOOL v6 = v2 != 0;
    sub_100ED0600((wis::MetricFactory *)0x80014);
  }
  sub_1000E3958(v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100ED08CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_1000E3958((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100ED08E8(uint64_t a1)
{
  sub_100ED0A50((uint64_t)v2, a1);
  MobileInstallationWaitForSystemAppMigrationWithCompletion();
  return sub_1000E52AC(v2);
}

void sub_100ED099C(_Unwind_Exception *a1)
{
  sub_1000E52AC(v1);
  _Unwind_Resume(a1);
}

void sub_100ED09B8(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, id *))(*(void *)v3 + 48))(v3, &v4);
}

void sub_100ED0A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100ED0A3C(uint64_t a1, uint64_t a2)
{
  return sub_100ED0A50(a1 + 32, a2 + 32);
}

void *sub_100ED0A48(uint64_t a1)
{
  return sub_1000E52AC((void *)(a1 + 32));
}

uint64_t sub_100ED0A50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

BOOL RegulatoryCountry::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  BOOL v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return a1[24] == v6[24];
    }
    return 0;
  }
  if (a1[23])
  {
    for (uint64_t i = a1; *i == *a2; ++i)
    {
      ++a2;
      if (!--v2) {
        return a1[24] == v6[24];
      }
    }
    return 0;
  }
  return a1[24] == v6[24];
}

void ctu::rest::read_rest_value<RegulatoryCountry>(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v7 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v7 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v5[0] = &v7;
    v5[1] = "country_code";
    sub_100048BAC((uint64_t)v5, &object);
    long long __p = 0;
    int v11 = 0;
    uint64_t v12 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v12) < 0) {
      operator delete(__p);
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = *(_OWORD *)v8;
    *(void *)(a1 + 16) = v9;
    xpc_release(object);
    long long __p = &v7;
    int v11 = "prio_atleast_loc";
    sub_100048BAC((uint64_t)&__p, v8);
    *(unsigned char *)(a1 + 24) = xpc::dyn_cast_or_default((xpc *)v8, 0, v4);
    xpc_release(v8[0]);
    xpc_object_t v3 = v7;
  }
  else
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 24) = 0;
    *(void *)(a1 + 16) = 0;
  }
  xpc_release(v3);
}

void sub_100ED0CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t a12, xpc_object_t object, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void ctu::rest::write_rest_value<RegulatoryCountry>(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v15 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    xpc_object_t v7 = (const char *)a1;
  }
  else {
    xpc_object_t v7 = *(const char **)a1;
  }
  xpc_object_t v13 = xpc_string_create(v7);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  int v11 = &v15;
  uint64_t v12 = "country_code";
  sub_100035E70((uint64_t)&v11, &v13, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v9 = xpc_BOOL_create(*(unsigned char *)(a1 + 24));
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  int v11 = &v15;
  uint64_t v12 = "prio_atleast_loc";
  sub_100035E70((uint64_t)&v11, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_object_t v8 = v15;
  *a2 = v15;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v15);
}

void CellularPolicyInterface::create(uint64_t a1)
{
  xpc_object_t v3 = *(Registry **)a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  long long v16 = *(Registry **)a1;
  BOOL v17 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1008082F8((capabilities::ct *)&v16, &v18);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3);
  xpc_object_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    xpc_object_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v10 = v18;
  if (v18)
  {
    int v11 = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&long long v20 = v10;
    *((void *)&v20 + 1) = v11;
    unint64_t v21 = v6;
    sub_100136784((uint64_t)&v5[1], &v21, &v21, (uint64_t *)&v20);
    char v13 = v12;
    if (*((void *)&v20 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
    }
    std::mutex::unlock(v5);
    if ((v13 & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "The given type is already in the map!");
    }
  }
  else
  {
    long long v20 = 0uLL;
    unint64_t v21 = v6;
    sub_100136C98(&v5[1].__m_.__sig, &v21);
    std::mutex::unlock(v5);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  xpc_object_t v15 = *(std::__shared_weak_count **)(a1 + 8);
  xpc_object_t v18 = *(Registry **)a1;
  uint64_t v19 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100ED1104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  __cxa_free_exception(v14);
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_100ED1190(id **a1@<X0>, void *a2@<X8>)
{
  if (*a1)
  {
    id v3 = **a1;
    if (v3
      && (unint64_t v6 = v3,
          [v3 planLabel],
          xpc_object_t v4 = objc_claimAutoreleasedReturnValue(),
          v4,
          id v3 = v6,
          v4))
    {
      id v5 = [v6 planLabel];
      sub_100058DB0(a2, (char *)[v5 UTF8String]);

      id v3 = v6;
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_100ED1244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100ED1264(id **a1@<X0>, void *a2@<X8>)
{
  if (*a1)
  {
    id v3 = **a1;
    if (v3
      && (unint64_t v6 = v3,
          [v3 planLabel],
          xpc_object_t v4 = objc_claimAutoreleasedReturnValue(),
          v4,
          id v3 = v6,
          v4))
    {
      id v5 = [v6 planLabel];
      sub_100056210(a2, v5);

      id v3 = v6;
    }
    else
    {
      *a2 = 0;
    }
  }
  else
  {
    *a2 = 0;
  }
}

void sub_100ED1308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100ED1320(id **a1@<X0>, void *a2@<X8>)
{
  if (*a1)
  {
    id v3 = **a1;
    if (v3
      && (unint64_t v6 = v3,
          [v3 planId],
          xpc_object_t v4 = objc_claimAutoreleasedReturnValue(),
          v4,
          id v3 = v6,
          v4))
    {
      id v5 = [v6 planId];
      sub_100058DB0(a2, (char *)[v5 UTF8String]);

      id v3 = v6;
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_100ED13D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *RegistrationController::setRatSelection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_100ED1550;
  v10[3] = &unk_101A697F0;
  v10[4] = a1;
  void v11[4] = a2;
  sub_100017108((uint64_t)v11, a3);
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  xpc_object_t v4 = *(NSObject **)(a1 + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  v6[2] = sub_100059534;
  double v6[3] = &unk_101A69B28;
  void v6[5] = v8;
  xpc_object_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v6[4] = v10;
  dispatch_async(v4, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return sub_10001C9D4(v11);
}

void sub_100ED1544(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100ED1550(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v11 = 0;
  char v12 = 0;
  id v3 = (RatSelectionType *)(a1 + 72);
  int SimSlot = RatSelectionType::getSimSlot((RatSelectionType *)(a1 + 72));
  RegistrationController::getModel_sync(v2, SimSlot, &v11);
  if (v11)
  {
    uint64_t v9 = v11;
    xpc_object_t v10 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v5 = RegistrationController::setRatSelection_sync(v2, &v9, v3);
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v5) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 0x2300000001;
    }
  }
  else
  {
    uint64_t v6 = 0x1600000001;
    xpc_object_t v7 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      RatSelectionType::getSimSlot(v3);
      uint64_t v8 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v14 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find model %s for RAT selection", buf, 0xCu);
    }
  }
  sub_100060854(a1 + 40, v6);
  if (v12) {
    sub_10004D2C8(v12);
  }
}

void sub_100ED169C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ED16CC(uint64_t a1, uint64_t a2)
{
  return sub_100017108(a1 + 40, a2 + 40);
}

void *sub_100ED16D8(uint64_t a1)
{
  return sub_10001C9D4((void *)(a1 + 40));
}

void *RegistrationController::getRatSelection(uint64_t a1, int a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_100ED183C;
  v10[3] = &unk_101A69820;
  v10[4] = a1;
  int v12 = a2;
  sub_100ED7E68((uint64_t)v11, a3);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  xpc_object_t v4 = *(NSObject **)(a1 + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  v6[2] = sub_100059534;
  double v6[3] = &unk_101A69B28;
  void v6[5] = v8;
  xpc_object_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v6[4] = v10;
  dispatch_async(v4, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return sub_100ED7DE4(v11);
}

void sub_100ED1830(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100ED183C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(a1 + 72), &v7);
  if (v7)
  {
    *(void *)std::string buf = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 592))(v7);
    char Selection = RatSelectionType::getSelection((RatSelectionType *)buf);
    Preferredchar Selection = RatSelectionType::getPreferredSelection((RatSelectionType *)buf);
    sub_100D47814(a1 + 40, Selection, PreferredSelection);
  }
  else
  {
    int v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find model %s for RAT selection query", buf, 0xCu);
    }
    sub_100D47814(a1 + 40, 0, 0);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100ED1978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ED1998(uint64_t a1, uint64_t a2)
{
  return sub_100ED7E68(a1 + 40, a2 + 40);
}

void *sub_100ED19A4(uint64_t a1)
{
  return sub_100ED7DE4((void *)(a1 + 40));
}

void RegistrationController::getDisplayStatus(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  xpc_object_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED1BA8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

BOOL RegistrationController::isForcedRegisteredHome(RegistrationController *this)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100ED1D34;
  v4[3] = &unk_101A69880;
  v4[4] = this;
  int v5 = v4;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100ED8180;
  double v6[3] = &unk_101A69B58;
  v6[4] = (char *)this + 8;
  void v6[5] = &v5;
  uint64_t v7 = v6;
  uint64_t v2 = (char *)this + 24;
  uint64_t v1 = *((void *)this + 3);
  if (*((void *)v2 + 1))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    xpc_object_t v10 = sub_10005B374;
    uint64_t v11 = &unk_101A69B98;
    int v12 = &v14;
    char v13 = &v7;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    xpc_object_t v10 = sub_10005A610;
    uint64_t v11 = &unk_101A69B78;
    int v12 = &v14;
    char v13 = &v7;
    dispatch_sync(v1, &block);
  }
  return v14 != 0;
}

uint64_t sub_100ED1D34(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32) + 64;
  int v4 = 1;
  uint64_t v2 = sub_1000FD774(v1, &v4);
  return (*(uint64_t (**)(uint64_t))(*(void *)*v2 + 88))(*v2);
}

void RegistrationController::getRegistrationCauseCode(uint64_t a1, int a2, uint64_t a3)
{
  v4[4] = a1;
  int v5 = a2;
  sub_100356358((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED1ED4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::getMobileCountryCode(uint64_t a1@<X0>, int a2@<W1>, MCC *a3@<X8>)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  xpc_object_t v8[2] = sub_100ED8344;
  v8[3] = &unk_101A69BB8;
  v8[4] = a1 + 8;
  v8[5] = v6;
  uint64_t v9 = v8;
  id v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *(_OWORD *)a3 = 0uLL;
    *((_OWORD *)a3 + 1) = 0uLL;
    MCC::MCC(a3);
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_100ED8504;
    char v13 = &unk_101A69BF8;
    uint64_t v14 = v4;
    xpc_object_t v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(_OWORD *)a3 = 0uLL;
    *((_OWORD *)a3 + 1) = 0uLL;
    MCC::MCC(a3);
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_100ED848C;
    char v13 = &unk_101A69BD8;
    uint64_t v14 = v5;
    xpc_object_t v15 = &v9;
    dispatch_sync(v3, &block);
  }
}

void RegistrationController::getMobileNetworkCode(uint64_t a1@<X0>, int a2@<W1>, MNC *a3@<X8>)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  xpc_object_t v8[2] = sub_100ED857C;
  v8[3] = &unk_101A69C18;
  v8[4] = a1 + 8;
  v8[5] = v6;
  uint64_t v9 = v8;
  id v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *(_OWORD *)a3 = 0uLL;
    *((_OWORD *)a3 + 1) = 0uLL;
    MNC::MNC(a3);
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_100ED873C;
    char v13 = &unk_101A69C58;
    uint64_t v14 = v4;
    xpc_object_t v15 = &v9;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(_OWORD *)a3 = 0uLL;
    *((_OWORD *)a3 + 1) = 0uLL;
    MNC::MNC(a3);
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_100ED86C4;
    char v13 = &unk_101A69C38;
    uint64_t v14 = v5;
    xpc_object_t v15 = &v9;
    dispatch_sync(v3, &block);
  }
}

void RegistrationController::getLastKnownMobileCountryCode(uint64_t a1, int a2, uint64_t a3)
{
  v4[4] = a1;
  int v5 = a2;
  sub_10003E1AC((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED22E8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::getServingPlmn(uint64_t a1, int a2, uint64_t a3)
{
  v4[4] = a1;
  int v5 = a2;
  sub_1000278EC((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED2444(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::getRadioAccessTechnology(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED2658(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::getOperatorName(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100ED8D54;
  void v7[3] = &unk_101A69C78;
  v7[4] = a1 + 8;
  void v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v4 = a1 + 24;
  id v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100ED8E8C;
    int v12 = &unk_101A69CB8;
    char v13 = a3;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100003F8C;
    int v12 = &unk_101A69C98;
    char v13 = a3;
    uint64_t v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void RegistrationController::getOperatorShortName(uint64_t a1, int a2, uint64_t a3)
{
  v4[4] = a1;
  int v5 = a2;
  sub_1000278EC((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED28E4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::isDataAttached(uint64_t a1, int a2, uint64_t a3)
{
  v4[4] = a1;
  int v5 = a2;
  sub_1000DFC90((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED2A40(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::isVoiceServiceAvailable(uint64_t a1, int a2, uint64_t a3)
{
  v4[4] = a1;
  int v5 = a2;
  sub_1000DFC90((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED2B9C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::getDataMode(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED2DB0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::getDataMode(RegistrationController *this)
{
  uint64_t v4 = this;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100ED95B8;
  double v5[3] = &unk_101A69CD8;
  v5[4] = (char *)this + 8;
  void v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = (char *)this + 24;
  uint64_t v1 = *((void *)this + 3);
  if (*((void *)v2 + 1))
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100ED9684;
    uint64_t v10 = &unk_101A69D18;
    uint64_t v11 = &v13;
    int v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    unsigned int v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100ED9648;
    uint64_t v10 = &unk_101A69CF8;
    uint64_t v11 = &v13;
    int v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13;
}

void RegistrationController::isEmergencyCallBackMode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::needNextNetworkTimeUpdate(RegistrationController *this)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  void v3[2] = sub_100ED30F8;
  v3[3] = &unk_101A698A0;
  v3[4] = this;
  uint64_t v6 = 0;
  int v7 = 0;
  sub_10003E168(&v6, (void *)this + 1);
  uint64_t v2 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v6;
  int v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

uint64_t sub_100ED30F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Setting Baseband to active Network Time mode, need the next update", v4, 2u);
  }
  return (*(uint64_t (**)(void))(**(void **)(v1 + 88) + 176))(*(void *)(v1 + 88));
}

void RegistrationController::updateImsStatus(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::sendIMSRegStart(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void RegistrationController::update5GStandaloneInfo(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL RegistrationController::isEmergencyOverImsEnabled(uint64_t a1, int a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100ED35D8;
  double v5[3] = &unk_101A698D8;
  v5[4] = a1;
  int v6 = a2;
  int v7 = v5;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  xpc_object_t v8[2] = sub_100ED8180;
  v8[3] = &unk_101A69B58;
  v8[4] = a1 + 8;
  v8[5] = &v7;
  uint64_t v9 = v8;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_10005B374;
    unsigned int v13 = &unk_101A69B98;
    uint64_t v14 = &v16;
    xpc_object_t v15 = &v9;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_10005A610;
    unsigned int v13 = &unk_101A69B78;
    uint64_t v14 = &v16;
    xpc_object_t v15 = &v9;
    dispatch_sync(v2, &block);
  }
  return v16 != 0;
}

uint64_t sub_100ED35D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  xpc_object_t v26 = 0;
  uint64_t v27 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(a1 + 40), &v26);
  uint64_t v3 = v26;
  if (v26)
  {
    uint64_t v4 = operator new(0x18uLL);
    *((void *)&__p + 1) = v4 + 3;
    uint64_t v33 = (char *)(v4 + 3);
    *(_OWORD *)uint64_t v4 = *(_OWORD *)off_101A698C0;
    v4[2] = @"CheckIMSPrefForEmergency";
    *(void *)&long long __p = v4;
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v2 + 248) + 104))(&cf);
    int v5 = (BOOL *)cf;
    if (cf) {
      int v6 = sub_100080934;
    }
    else {
      int v6 = 0;
    }
    if (v6)
    {
      buf[0] = 0;
      if (cf)
      {
        CFTypeID v7 = CFGetTypeID(cf);
        if (v7 == CFBooleanGetTypeID()) {
          ctu::cf::assign((ctu::cf *)buf, v5, v8);
        }
      }
      BOOL v9 = buf[0] == 0;
    }
    else
    {
      BOOL v9 = 1;
    }
    int v12 = (*(uint64_t (**)(uint64_t *, uint64_t))(*v3 + 704))(v3, 7);
    uint64_t v13 = *v3;
    if (v12 == 1)
    {
      int v14 = (*(uint64_t (**)(uint64_t *, uint64_t))(v13 + 712))(v3, 7);
    }
    else
    {
      if ((*(unsigned int (**)(uint64_t *, uint64_t))(v13 + 704))(v3, 10) != 1)
      {
        BOOL v16 = 0;
        BOOL v15 = 0;
        goto LABEL_20;
      }
      int v14 = (*(uint64_t (**)(uint64_t *, uint64_t))(*v3 + 712))(v3, 10);
    }
    BOOL v15 = v14 == 1;
    BOOL v16 = 1;
LABEL_20:
    BOOL v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = asStringBool(v16);
      uint64_t v19 = asStringBool(v15);
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v29 = v18;
      __int16 v30 = 2080;
      uint64_t v31 = v19;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I IMS bearer support state (%s) and access barred state (%s)", buf, 0x16u);
    }
    if (v16 && !v15 && (v9 || (*(unsigned int (**)(uint64_t *))(*v3 + 608))(v3)))
    {
      xpc_object_t v22 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 40));
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Emergency Over IMS is allowed", buf, 2u);
      }
      uint64_t v11 = 1;
    }
    else
    {
      long long v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 40));
      uint64_t v11 = 0;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v21 = "IMS pref check required, value known and doesn't have Voice support";
        if (v15) {
          unint64_t v21 = "access barred";
        }
        if (!v16) {
          unint64_t v21 = "bearer not supported";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v29 = (uint64_t)v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Emergency Over IMS is not allowed since %s", buf, 0xCu);
        uint64_t v11 = 0;
      }
    }
    sub_1000577C4(&cf);
    if ((void)__p)
    {
      *((void *)&__p + 1) = __p;
      operator delete((void *)__p);
    }
    goto LABEL_36;
  }
  uint64_t v10 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v24 = subscriber::asString();
    LODWORD(__p) = 136315138;
    *(void *)((char *)&__p + 4) = v24;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find model %s for emergency over IMS enabled query", (uint8_t *)&__p, 0xCu);
  }
  uint64_t v11 = 0;
LABEL_36:
  if (v27) {
    sub_10004D2C8(v27);
  }
  return v11;
}

void sub_100ED3A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::getRAT(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100ED99A0;
  void v7[3] = &unk_101A69D38;
  v7[4] = a1 + 8;
  void v7[5] = v5;
  CFBooleanRef v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100ED9B0C;
    int v12 = &unk_101A69D78;
    uint64_t v13 = &v15;
    int v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100ED9AD0;
    int v12 = &unk_101A69D58;
    uint64_t v13 = &v15;
    int v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

BOOL RegistrationController::isLimitedService(uint64_t a1, int a2, int a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_100ED3D68;
  double v6[3] = &unk_101A698F8;
  v6[4] = a1;
  int v7 = a2;
  int v8 = a3;
  BOOL v9 = v6;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100ED8180;
  v10[3] = &unk_101A69B58;
  v10[4] = a1 + 8;
  void v10[5] = &v9;
  uint64_t v11 = v10;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    int v14 = sub_10005B374;
    unsigned int v15 = &unk_101A69B98;
    BOOL v16 = &v18;
    BOOL v17 = &v11;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v18 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v13 = 0x40000000;
    int v14 = sub_10005A610;
    unsigned int v15 = &unk_101A69B78;
    BOOL v16 = &v18;
    BOOL v17 = &v11;
    dispatch_sync(v3, &block);
  }
  return v18 != 0;
}

uint64_t sub_100ED3D68(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v8 = 0;
  BOOL v9 = 0;
  RegistrationController::getModel_sync(v3, *(_DWORD *)(a1 + 40), &v8);
  uint64_t v4 = v8;
  if (v8)
  {
    unsigned __int8 v1 = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 680))(v8, *(unsigned int *)(a1 + 44));
  }
  else
  {
    int v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v11 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find model %s for PS limited service query", buf, 0xCu);
    }
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return (v4 != 0) & v1;
}

void sub_100ED3E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *RegistrationController::setCdmaRoamingSwitchSetting(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 216);
  uint64_t v4 = &_mh_execute_header;
  if (!a3) {
    uint64_t v4 = 0;
  }
  v6[0] = off_101A69DA8;
  v6[1] = a1;
  void v6[2] = (unint64_t)v4 | a2;
  double v6[3] = v6;
  (*(void (**)(uint64_t))(*(void *)v3 + 72))(v3);
  return sub_10041A970(v6);
}

void sub_100ED3F68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10041A970((uint64_t *)va);
  _Unwind_Resume(a1);
}

void RegistrationController::resetNetworkSettings(RegistrationController *this, group_session a2)
{
  uint64_t v2 = (void *)((char *)this + 8);
  uint64_t v3 = *(NSObject **)a2.var0.fObj;
  if (*(void *)a2.var0.fObj)
  {
    dispatch_retain(*(dispatch_object_t *)a2.var0.fObj);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void RegistrationController::setServiceProvisioned(RegistrationController *this, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100ED41B8;
  v4[3] = &unk_101A69918;
  v4[4] = this;
  char v5 = a2;
  uint64_t v8 = 0;
  BOOL v9 = 0;
  sub_10003E168(&v8, (void *)this + 1);
  uint64_t v3 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_100ED41B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 40)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    int v12 = 136315138;
    uint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Got Service Provisioned event, provisioned: %s", (uint8_t *)&v12, 0xCu);
  }
  if (*(unsigned char *)(a1 + 40))
  {
    RegistrationController::sendGetServingSystemReq_sync((RegistrationController *)v2);
    BOOL v5 = *(unsigned char *)(a1 + 40) != 0;
  }
  else
  {
    BOOL v5 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, BOOL))(**(void **)(v2 + 344) + 176))(*(void *)(v2 + 344), 1, v5);
  uint64_t v7 = *(void **)(v2 + 64);
  uint64_t v8 = (void *)(v2 + 72);
  if (v7 != v8)
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)v7[5] + 776))();
      BOOL v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          uint64_t v7 = v10;
        }
        while (!v11);
      }
      uint64_t v7 = v10;
    }
    while (v10 != v8);
  }
  return result;
}

uint64_t RegistrationController::getEnableOnlyHomeNetwork(RegistrationController *this)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100ED4458;
  double v5[3] = &unk_101A69940;
  v5[4] = &v6;
  void v5[5] = this;
  uint64_t v10 = v5;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100EDA11C;
  block[3] = &unk_101A69E48;
  block[4] = (char *)this + 8;
  block[5] = &v10;
  uint64_t v2 = (char *)this + 24;
  unsigned __int8 v1 = *((void *)this + 3);
  if (*((void *)v2 + 1)) {
    dispatch_async_and_wait(v1, block);
  }
  else {
    dispatch_sync(v1, block);
  }
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t sub_100ED4458(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(unsigned char *)(*(void *)(result + 40) + 376);
  return result;
}

void RegistrationController::setEnableOnlyHomeNetwork(RegistrationController *this, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100ED4580;
  v4[3] = &unk_101A69960;
  v4[4] = this;
  char v5 = a2;
  uint64_t v8 = 0;
  char v9 = 0;
  sub_10003E168(&v8, (void *)this + 1);
  uint64_t v3 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

const void **sub_100ED4580(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (uint64_t *)*(unsigned __int8 *)(a1 + 40);
  if (*(unsigned char *)(a1 + 40) && (RoamingInterface::isInHomeCountry(*(RoamingInterface **)(v2 + 216)) & 1) == 0)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bringing down data since we are switching to home only N/W and we are currently roaming", buf, 2u);
    }
    uint64_t v5 = *(void *)(v2 + 216);
    v12[0] = off_101A69E78;
    v12[3] = v12;
    (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v5 + 56))(v5, 1, 0, v12);
    sub_10001C9D4(v12);
    (*(void (**)(void, void, void))(**(void **)(v2 + 264) + 456))(*(void *)(v2 + 264), 0, 0);
    (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v2 + 264) + 312))(*(void *)(v2 + 264), 3, 6, 1);
    *(_DWORD *)std::string buf = 1;
    uint64_t v6 = sub_1000FD774(v2 + 64, (int *)buf);
    uint64_t v8 = *v6;
    uint64_t v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, void))(*(void *)v8 + 496))(v8, 0);
    v10[0] = v8;
    v10[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    RegistrationController::reevaluateDataMode_sync(v2, v10);
    if (v7)
    {
      sub_10004D2C8(v7);
      sub_10004D2C8(v7);
    }
  }
  RegistrationController::setEnableOnlyHomeNetwork_sync((RegistrationController *)v2, *(unsigned char *)(a1 + 40), v3);
  return RegistrationController::sendEnableOnlyHomeNetwork_sync((RegistrationController *)v2);
}

void sub_100ED47AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (v12)
  {
    sub_10004D2C8(v12);
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::getEriVersion(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED49EC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::forceToggleProvisioningMode(RegistrationController *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 11) + 136))();
}

void *RegistrationController::toggleProvisioningMode(RegistrationController *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 5);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    int v6 = "off";
    if (a2) {
      int v6 = "on";
    }
    *(_DWORD *)std::string buf = 136315138;
    BOOL v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Turning %s provisioning mode", buf, 0xCu);
  }
  if (!capabilities::ct::supportsCambioModeQuery((capabilities::ct *)v5)) {
    return (void *)(*(uint64_t (**)(RegistrationController *, uint64_t))(*(void *)this + 328))(this, a2);
  }
  uint64_t v7 = *((void *)this + 11);
  v9[0] = off_101A69EF8;
  v9[1] = a2;
  void v9[2] = this;
  v9[3] = v9;
  (*(void (**)(uint64_t, void *))(*(void *)v7 + 144))(v7, v9);
  return sub_100060644(v9);
}

void sub_100ED4B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *RegistrationController::prepareForServiceProvisioning(RegistrationController *this)
{
  uint64_t result = (void *)capabilities::ct::supportsCambioModeQuery(this);
  if (result)
  {
    uint64_t v3 = *((void *)this + 11);
    v4[0] = off_101A69F98;
    v4[1] = this;
    v4[3] = v4;
    (*(void (**)(uint64_t, void *))(*(void *)v3 + 144))(v3, v4);
    return sub_100060644(v4);
  }
  return result;
}

void sub_100ED4C5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void RegistrationController::sendPSRegistrationRequest(uint64_t a1, int a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100ED4D84;
  v4[3] = &unk_101A69980;
  void v4[4] = a1;
  int v5 = a2;
  uint64_t v8 = 0;
  char v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

uint64_t sub_100ED4D84(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = (*(uint64_t (**)(void))(**(void **)(v2 + 104) + 48))(*(void *)(v2 + 104));
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  BOOL v5 = v3 == 6;
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, BOOL))(**(void **)(v2 + 88) + 152);
  uint64_t v7 = *(void *)(v2 + 88);

  return v6(v7, v4, v5);
}

void RegistrationController::sendDataRoamingSetting(capabilities::ct *a1, int a2, char a3)
{
  if (capabilities::ct::supportsSystemSelectionDataRoaming(a1))
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    void v7[2] = sub_100ED4F40;
    void v7[3] = &unk_101A699A0;
    v7[4] = a1;
    int v8 = a2;
    char v9 = a3;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    sub_10003E168(&v12, (void *)a1 + 1);
    int v6 = *((void *)a1 + 3);
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    block[2] = sub_100059534;
    block[3] = &unk_101A69B28;
    block[5] = v12;
    BOOL v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v7;
    dispatch_async(v6, block);
    if (v11) {
      sub_10004D2C8(v11);
    }
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

uint64_t sub_100ED4F40(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(*(void *)(a1 + 32) + 88) + 240))(*(void *)(*(void *)(a1 + 32) + 88), *(unsigned int *)(a1 + 40), *(unsigned __int8 *)(a1 + 44));
}

void RegistrationController::send5GEnabledSetting(uint64_t a1, int a2, char a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100ED5090;
  double v5[3] = &unk_101A699C0;
  v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  uint64_t v10 = 0;
  BOOL v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v10;
  char v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100ED5090(uint64_t a1)
{
}

void RegistrationController::send3GEnabledSetting(uint64_t a1, int a2, char a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100ED51BC;
  double v5[3] = &unk_101A699E0;
  v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  uint64_t v10 = 0;
  BOOL v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v10;
  char v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100ED51BC(uint64_t a1)
{
}

void RegistrationController::send2GEnabledSetting(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100ED52E4;
  v4[3] = &unk_101A69A00;
  void v4[4] = a1;
  char v5 = a2;
  uint64_t v8 = 0;
  char v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  int v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v8;
  char v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100ED52E4(uint64_t a1)
{
}

void RegistrationController::sendLTEEnabledSetting(uint64_t a1, int a2, char a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100ED540C;
  double v5[3] = &unk_101A69A20;
  v5[4] = a1;
  int v6 = a2;
  char v7 = a3;
  uint64_t v10 = 0;
  BOOL v11 = 0;
  sub_10003E168(&v10, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v10;
  char v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100ED540C(uint64_t a1)
{
}

void RegistrationController::enableEmergencyCallBackMode(RegistrationController *this, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  void v4[2] = sub_100ED5534;
  v4[3] = &unk_101A69A40;
  void v4[4] = this;
  char v5 = a2;
  uint64_t v8 = 0;
  char v9 = 0;
  sub_10003E168(&v8, (void *)this + 1);
  int v3 = *((void *)this + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v8;
  char v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v4;
  dispatch_async(v3, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100ED5534(uint64_t a1)
{
}

void RegistrationController::automaticallySelectNetwork(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_100017108((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED5688(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void *RegistrationController::fetchNetworkList(uint64_t a1, int a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  void v10[2] = sub_100ED57FC;
  v10[3] = &unk_101A69A60;
  v10[4] = a1;
  int v12 = a2;
  sub_100017108((uint64_t)v11, a3);
  uint64_t v8 = 0;
  char v9 = 0;
  sub_10003E168(&v8, (void *)(a1 + 8));
  uint64_t v4 = *(NSObject **)(a1 + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  void v6[2] = sub_100059534;
  double v6[3] = &unk_101A69B28;
  void v6[5] = v8;
  char v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v6[4] = v10;
  dispatch_async(v4, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return sub_10001C9D4(v11);
}

void sub_100ED57F0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_100ED57FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(unsigned int *)(a1 + 72);
  sub_100017108((uint64_t)v4, a1 + 40);
  RegistrationController::fetchNetworkList_sync(v1, v2, (uint64_t)v4);
  return sub_10001C9D4(v4);
}

void sub_100ED5878(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10001C9D4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void RegistrationController::getSelectedNetwork(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED5A90(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::getNetworkList(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED5CA8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::getNetworkSelectionMode(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED5EC0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::getNetworkSelectionState(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED60D8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::getNetworkSelectionInfo(uint64_t a1, int a2, void *a3)
{
  v5[4] = a1;
  int v6 = a2;
  uint64_t v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED62F0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void RegistrationController::getNetworkNeedsReselect(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_1000DFC90((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED6450(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::selectNetwork(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  void v6[4] = a1;
  int v7 = a2;
  sub_100017108((uint64_t)&v8, a4);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

void sub_100ED6604(_Unwind_Exception *a1)
{
  sub_10001C9D4(v1);
  _Unwind_Resume(a1);
}

BOOL RegistrationController::isNetworkSelectionMenuEnabled(uint64_t a1, int a2)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100EDC6CC;
  void v7[3] = &unk_101A6A028;
  v7[4] = a1 + 8;
  void v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_10005B374;
    int v12 = &unk_101A69B98;
    uint64_t v13 = &v15;
    int v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_10005A610;
    int v12 = &unk_101A69B78;
    uint64_t v13 = &v15;
    int v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void RegistrationController::isNetworkSelectionMenuEnabled(uint64_t a1, int a2, uint64_t a3)
{
  v5[4] = a1;
  sub_1000DFC90((uint64_t)v6, a3);
  v6[8] = a2;
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100ED68B8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100ED68D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 232);
  if (v4 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 72))(v4, a2) & 1) != 0) {
    return 1;
  }
  uint64_t v6 = *(void *)(a1 + 184);
  if (!v6)
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v11) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "NAISelector not configured for network selection menu enabled query", (uint8_t *)&v11, 2u);
    }
    return 0;
  }
  uint64_t v11 = 0;
  int v12 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v6 + 16))(&v11);
  uint64_t v7 = v11;
  if (v11) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 96))(v11);
  }
  else {
    uint64_t v5 = 0;
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (!v7)
  {
    char v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v5 = 0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Neither network selection or NAI is available", (uint8_t *)&v11, 2u);
      return 0;
    }
  }
  return v5;
}

void sub_100ED6AA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::getEncryptionStatus(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  void v4[4] = a1;
  int v5 = a2;
  sub_100EDC79C((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_100ED6C04(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t RegistrationController::getNRDisableStatus_sync(uint64_t a1, int a2)
{
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long v16 = 0uLL;
  NRDisableStatus::NRDisableStatus((NRDisableStatus *)&v16, 1, 1);
  uint64_t v5 = *(void *)(a1 + 864);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 864;
  do
  {
    int v7 = *(_DWORD *)(v5 + 28);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      char v9 = (uint64_t *)v5;
    }
    else {
      char v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 864 && *(_DWORD *)(v6 + 28) <= a2)
  {
    long long v16 = *(_OWORD *)(v6 + 32);
  }
  else
  {
LABEL_11:
    uint64_t v10 = *v4;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v14) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not find NR disable status", (uint8_t *)&v14, 2u);
    }
  }
  if (!RegistrationController::supports5GNSA_sync(a1)
    && ((NRDisableStatus::isSADisabledWithReason() & 1) != 0 || NRDisableStatus::isSADisabledWithReason()))
  {
    BYTE8(v16) = 1;
    HIDWORD(v16) |= 0x80000000;
  }
  uint64_t v14 = 0;
  char v15 = 0;
  RegistrationController::getModel_sync(a1, a2, &v14);
  if (v14)
  {
    unsigned __int16 v11 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 816))(v14);
    if (v11 >= 0x100u && v11 == 0)
    {
      LOBYTE(v16) = 1;
      DWORD1(v16) |= 0x40000000u;
    }
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  return v16;
}

void sub_100ED6DD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::getNRStatus_sync(uint64_t a1@<X0>, int a2@<W1>, NRStatus *a3@<X8>)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  v22[0] = (capabilities::ct *)RegistrationController::getNRDisableStatus_sync(a1, a2);
  v22[1] = v7;
  if (capabilities::ct::supports5G(v22[0]))
  {
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    RegistrationController::getModel_sync(a1, a2, &v20);
    uint64_t v8 = v20;
    if (!v20)
    {
      char v15 = *v6;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find model when checking NR status", buf, 2u);
      }
      goto LABEL_14;
    }
    if (!RegistrationController::supports5GNSA_sync(a1))
    {
      char v9 = *v6;
      BOOL v16 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      BOOL v11 = 0;
      LOBYTE(v6) = 0;
      if (!v16) {
        goto LABEL_16;
      }
      *(_WORD *)std::string buf = 0;
      int v12 = "#I Carrier only supports 5G Standalone. Remove switch";
      goto LABEL_13;
    }
    if (NRDisableStatus::isSADisabledWithReason())
    {
      char v9 = *v6;
      BOOL v10 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      BOOL v11 = 0;
      LOBYTE(v6) = 0;
      if (!v10) {
        goto LABEL_16;
      }
      *(_WORD *)std::string buf = 0;
      int v12 = "#I 5G Standalone disabled by baseband due to VoLTE off. Remove switch";
      goto LABEL_13;
    }
    if ((*(unsigned __int16 (**)(uint64_t))(*(void *)v8 + 832))(v8) > 0xFFu)
    {
      unsigned int v18 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 808))(v8);
      BOOL v11 = v18 & 1;
      if (NRDisableStatus::isSADisabledWithReasonMask((NRDisableStatus *)v22))
      {
        uint64_t v19 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109120;
          int v24 = HIDWORD(v22[0]);
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone disabled by baseband with reason 0x%x", buf, 8u);
        }
        goto LABEL_15;
      }
      LODWORD(v6) = (v18 >> 8) & 1;
    }
    else
    {
      char v9 = *v6;
      BOOL v17 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      BOOL v11 = 0;
      LOBYTE(v6) = 0;
      if (v17)
      {
        *(_WORD *)std::string buf = 0;
        int v12 = "#I 5G Standalone support not yet known. Remove switch";
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
LABEL_14:
        BOOL v11 = 0;
LABEL_15:
        LOBYTE(v6) = 0;
      }
    }
LABEL_16:
    if (v21) {
      sub_10004D2C8(v21);
    }
    goto LABEL_18;
  }
  uint64_t v13 = *v6;
  BOOL v14 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
  BOOL v11 = 0;
  LOBYTE(v6) = 0;
  if (v14)
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I 5G not supported when querying NR status", (uint8_t *)&v20, 2u);
    BOOL v11 = 0;
    LOBYTE(v6) = 0;
  }
LABEL_18:
  NRStatus::NRStatus(a3, v11, (BOOL)v6, (const NRDisableStatus *)v22);
}

void sub_100ED711C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void RegistrationController::getNRStatus(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100EDCA04;
  void v7[3] = &unk_101A6A048;
  v7[4] = a1 + 8;
  void v7[5] = v5;
  uint64_t v8 = v7;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 16) = 0;
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)&block, 1, 1);
    NRStatus::NRStatus((NRStatus *)a3, 0, 0, (const NRDisableStatus *)&block);
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_100EDCA68;
    int v12 = &unk_101A6A088;
    uint64_t v13 = a3;
    BOOL v14 = &v8;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 16) = 0;
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)&block, 1, 1);
    NRStatus::NRStatus((NRStatus *)a3, 0, 0, (const NRDisableStatus *)&block);
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    BOOL v11 = sub_100EDCA14;
    int v12 = &unk_101A6A068;
    uint64_t v13 = a3;
    BOOL v14 = &v8;
    dispatch_sync(v4, &block);
  }
}

uint64_t RegistrationController::getSupports5GStandalone(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  v6[0] = a3;
  v6[1] = a1;
  void v6[2] = &v7;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  xpc_object_t v8[2] = sub_100EDCABC;
  v8[3] = &unk_101A6A0A8;
  v8[4] = a1 + 8;
  v8[5] = v6;
  char v9 = v8;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_100EDCDE8;
    uint64_t v13 = &unk_101A6A0E8;
    BOOL v14 = &v16;
    char v15 = &v9;
    uint64_t v16 = 0;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_100EDCDAC;
    uint64_t v13 = &unk_101A6A0C8;
    BOOL v14 = &v16;
    char v15 = &v9;
    uint64_t v16 = 0;
    dispatch_sync(v3, &block);
  }
  return v16;
}

uint64_t RegistrationController::setSupports5GStandalone(uint64_t a1, int a2, char a3)
{
  int v8 = a2;
  char v7 = a3;
  v6[0] = a1;
  v6[1] = &v8;
  void v6[2] = &v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_100EDCE24;
  v9[3] = &unk_101A6A108;
  void v9[4] = a1 + 8;
  v9[5] = v6;
  uint64_t v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_100EDCDE8;
    BOOL v14 = &unk_101A6A0E8;
    char v15 = &v17;
    uint64_t v16 = &v10;
    uint64_t v17 = 0;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    uint64_t v13 = sub_100EDCDAC;
    BOOL v14 = &unk_101A6A0C8;
    char v15 = &v17;
    uint64_t v16 = &v10;
    uint64_t v17 = 0;
    dispatch_sync(v3, &block);
  }
  return v17;
}

void RegistrationController::setGeoMccs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  memset(__p, 0, sizeof(__p));
  sub_1003A10E0(__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

void RegistrationController::getImsAndVoNRStateForBaseband(uint64_t a1, int a2, uint64_t a3)
{
  void v4[4] = a1;
  int v5 = a2;
  sub_1003FB63C((uint64_t)v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, (void *)(a1 + 8));
  operator new();
}

void sub_100ED7834(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void RegistrationController::setSatelliteSystemConfig(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void *sub_100ED7940(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED79C4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7A48(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7ACC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7B50(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7BD4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7C58(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7CDC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7D60(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100ED7DE4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100ED7E68(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_100ED7F00(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v17 = 0;
  unsigned int v18 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v17);
  uint64_t v3 = v17;
  if (v17)
  {
    unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 112))(v3);
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 88))(v3);
    int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 912))(v3);
    uint64_t v8 = 0x100000000000000;
    if (!v7) {
      uint64_t v8 = 0;
    }
    char v9 = &_mh_execute_header;
    if (!v5) {
      char v9 = 0;
    }
    uint64_t v10 = 0x1000000000000;
    if (!v6) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = v4;
    if (v6) {
      uint64_t v11 = 4;
    }
    sub_100D47788(v1 + 16, v10 | (unint64_t)v9 | v11 | v8);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v20 = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not find model %s for registration display status query", buf, 0xCu);
    }
    sub_100D47788(v1 + 16, 0);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_100ED8130(&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100ED8100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100ED8130(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED8130(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100ED7940((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void *sub_100ED8180(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t *sub_100ED8194(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 296))(v9);
  }
  else
  {
    unsigned int v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v12 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for cause code query", buf, 0xCu);
    }
    int v3 = 0;
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100356304(v1 + 16, v3);
  sub_100ED82F4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100ED82C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100ED82F4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED82F4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1000F8E94((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100ED8344(uint64_t a1@<X0>, MCC *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  long long v8 = 0uLL;
  RegistrationController::getModel_sync(v4, **(_DWORD **)(v3 + 8), &v8);
  uint64_t v5 = v8;
  if ((void)v8) {
    (*(void (**)(void))(*(void *)v8 + 424))(v8);
  }
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  if (!v5)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = subscriber::asString();
      LODWORD(v8) = 136315138;
      *(void *)((char *)&v8 + 4) = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model %s for MCC query", (uint8_t *)&v8, 0xCu);
    }
    MCC::MCC(a2);
  }
}

void sub_100ED846C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_100ED848C(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v1);
  MCC::operator=();
  if (v2 < 0) {
    operator delete(v1[1]);
  }
}

void sub_100ED84E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ED8504(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v1);
  MCC::operator=();
  if (v2 < 0) {
    operator delete(v1[1]);
  }
}

void sub_100ED8560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ED857C(uint64_t a1@<X0>, MNC *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  long long v8 = 0uLL;
  RegistrationController::getModel_sync(v4, **(_DWORD **)(v3 + 8), &v8);
  uint64_t v5 = v8;
  if ((void)v8) {
    (*(void (**)(void))(*(void *)v8 + 432))(v8);
  }
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  if (!v5)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = subscriber::asString();
      LODWORD(v8) = 136315138;
      *(void *)((char *)&v8 + 4) = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model %s for MNC query", (uint8_t *)&v8, 0xCu);
    }
    MNC::MNC(a2);
  }
}

void sub_100ED86A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_100ED86C4(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v1);
  MCC::operator=();
  if (v2 < 0) {
    operator delete(v1[1]);
  }
}

void sub_100ED8720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100ED873C(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(v1);
  MCC::operator=();
  if (v2 < 0) {
    operator delete(v1[1]);
  }
}

void sub_100ED8798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100ED87B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v14 = 0;
  char v15 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v14);
  if (v14)
  {
    (*(void (**)(void *__return_ptr))(*(void *)v14 + 440))(v11);
    uint64_t v3 = *(void *)(v1 + 40);
    if (!v3) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v11);
    if (v12 < 0)
    {
      uint64_t v4 = (void **)v11;
LABEL_10:
      operator delete(v4[1]);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v17 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find model %s for last known MCC query", buf, 0xCu);
    }
    MCC::MCC((MCC *)v13);
    uint64_t v6 = *(void *)(v1 + 40);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v6 + 48))(v6, v13);
    if ((v13[31] & 0x80000000) != 0)
    {
      uint64_t v4 = (void **)v13;
      goto LABEL_10;
    }
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_10003DAC0(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100ED8968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  xpc_object_t v26 = *(std::__shared_weak_count **)(v24 - 56);
  if (v26) {
    sub_10004D2C8(v26);
  }
  sub_10003DAC0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED89C0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v9 + 456))(&buf);
    uint64_t v3 = *(void *)(v1 + 40);
    if (!v3) {
      sub_10007B600();
    }
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for serving PLMN query", (uint8_t *)&buf, 0xCu);
    }
    long long buf = 0uLL;
    uint64_t v12 = 0;
    uint64_t v3 = *(void *)(v1 + 40);
    if (!v3) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v3 + 48))(v3, &buf);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)buf);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10001E8C4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100ED8B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10001E8C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED8BB0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 464))(v9);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v12 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for RAT query", buf, 0xCu);
    }
    int v3 = 11;
  }
  sub_100D47A74(v1 + 16, v3);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100ED8D04(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100ED8CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100ED8D04(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED8D04(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100ED79C4((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100ED8D54(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3;
  long long v8 = 0uLL;
  RegistrationController::getModel_sync(v4, *(_DWORD *)(v3 + 8), &v8);
  uint64_t v5 = v8;
  if ((void)v8) {
    (*(void (**)(void))(*(void *)v8 + 312))(v8);
  }
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  if (!v5)
  {
    uint64_t v6 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = subscriber::asString();
      LODWORD(v8) = 136315138;
      *(void *)((char *)&v8 + 4) = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model %s for operator name query", (uint8_t *)&v8, 0xCu);
    }
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_100ED8E74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100ED8E8C(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

uint64_t *sub_100ED8EF0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v9 + 328))(&buf);
    uint64_t v3 = *(void *)(v1 + 40);
    if (!v3) {
      sub_10007B600();
    }
  }
  else
  {
    __n128 v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for operator short name query", (uint8_t *)&buf, 0xCu);
    }
    long long buf = 0uLL;
    uint64_t v12 = 0;
    uint64_t v3 = *(void *)(v1 + 40);
    if (!v3) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v3 + 48))(v3, &buf);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)buf);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10001E8C4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100ED9098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10001E8C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED90E0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v9);
  if (v9)
  {
    char v3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 160))(v9);
  }
  else
  {
    __n128 v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v12 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for data attached query", buf, 0xCu);
    }
    char v3 = 0;
  }
  sub_1000607A8(v1 + 16, v3);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_10041EF98(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100ED9200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10041EF98(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED922C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v10);
  uint64_t v3 = v10;
  if (v10)
  {
    if (((*(uint64_t (**)(uint64_t))(*(void *)v10 + 152))(v10) & 1) != 0
      || ((*(uint64_t (**)(uint64_t))(*(void *)v3 + 240))(v3) & 1) != 0)
    {
      char v4 = 1;
    }
    else
    {
      char v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 208))(v3);
    }
  }
  else
  {
    uint64_t v5 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v13 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not find model %s for voice service available query", buf, 0xCu);
    }
    char v4 = 0;
  }
  sub_1000607A8(v1 + 16, v4);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10041EF98(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100ED93B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10041EF98(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED93E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  long long v10 = 0uLL;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v10);
  if ((void)v10)
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v10 + 1);
    *(_OWORD *)long long buf = v10;
    if (*((void *)&v10 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v10 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    int DataModeInternal_sync = RegistrationController::getDataModeInternal_sync(v2, buf);
    sub_100D4787C(v1 + 16, DataModeInternal_sync);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v3) {
LABEL_7:
    }
      sub_10004D2C8(v3);
  }
  else
  {
    uint64_t v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find model %s for voice service available query", buf, 0xCu);
    }
    sub_100D4787C(v1 + 16, -1);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v10 + 1);
    if (*((void *)&v10 + 1)) {
      goto LABEL_7;
    }
  }
  sub_100ED9568(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100ED9528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100ED9568(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100ED9568(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7A48((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100ED95B8(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  int v6 = 1;
  uint64_t v2 = sub_1000FD774(v1 + 64, &v6);
  uint64_t v3 = (std::__shared_weak_count *)v2[1];
  uint64_t v7 = *v2;
  uint64_t v8 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t DataModeInternal_sync = RegistrationController::getDataModeInternal_sync(v1, &v7);
  if (v8) {
    sub_10004D2C8(v8);
  }
  return DataModeInternal_sync;
}

void sub_100ED9630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ED9648(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100ED9684(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_100ED96C0(void **a1)
{
  uint64_t v1 = *a1;
  char v4 = a1;
  uint64_t v5 = v1;
  char v2 = (*(uint64_t (**)(void))(**(void **)(*v1 + 104) + 88))(*(void *)(*v1 + 104));
  xpc_object_t object = xpc_BOOL_create(v2);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  v6[0] = v1[1];
  v6[1] = "kRegistrationEmergencyCallBackMode";
  sub_100035E70((uint64_t)v6, &object, &v8);
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_release(object);
  sub_10024F798((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100ED9780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100ED979C(unsigned int **a1)
{
  char v2 = a1;
  uint64_t v1 = *a1;
  (*(void (**)(void, void, void, void, void, void))(**(void **)(*(void *)*a1 + 88) + 184))(*(void *)(*(void *)*a1 + 88), v1[2], v1[3], v1[4], v1[5], v1[6]);
  operator delete();
}

void sub_100ED9820()
{
}

void sub_100ED984C(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void))(**(void **)(**(void **)a1 + 88) + 192))(*(void *)(**(void **)a1 + 88), *(unsigned int *)(*(void *)a1 + 8));
  operator delete();
}

void sub_100ED98C8()
{
}

void sub_100ED98F4(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 88) + 200))(*(void *)(**(void **)a1 + 88), *(unsigned int *)(*(void *)a1 + 8), *(unsigned __int8 *)(*(void *)a1 + 12));
  operator delete();
}

void sub_100ED9974()
{
}

uint64_t sub_100ED99A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v7 = 0;
  xpc_object_t v8 = 0;
  uint64_t v2 = *(void *)v1;
  RegistrationController::getModel_sync(*(void *)v1, **(_DWORD **)(v1 + 8), &v7);
  if (v7)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 464))(v7);
  }
  else
  {
    char v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = subscriber::asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v10 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Could not find model %s for RAT query", buf, 0xCu);
    }
    uint64_t v3 = 11;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v3;
}

void sub_100ED9AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ED9AD0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100ED9B0C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_100ED9B4C()
{
}

__n128 sub_100ED9B60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A69DA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100ED9BAC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69DA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100ED9BDC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  void v6[2] = sub_100ED9D9C;
  void v6[3] = &unk_101A69E08;
  int v10 = *(_DWORD *)(a1 + 16);
  char v11 = *(unsigned char *)(a1 + 20);
  void v6[4] = v4;
  long long __p = 0;
  xpc_object_t v8 = 0;
  uint64_t v9 = 0;
  sub_1003A10E0(&__p, v3, v2, (v2 - (uint64_t)v3) >> 1);
  uint64_t v14 = 0;
  char v15 = 0;
  sub_10003E168(&v14, (void *)(v4 + 8));
  uint64_t v5 = *(NSObject **)(v4 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v14;
  uint64_t v13 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v6;
  dispatch_async(v5, block);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (__p)
  {
    xpc_object_t v8 = __p;
    operator delete(__p);
  }
  if (v3) {
    operator delete(v3);
  }
}

void sub_100ED9D38(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100ED9D50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100ED9D90()
{
}

uint64_t sub_100ED9D9C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(*(void *)(a1 + 32) + 88) + 88))(*(void *)(*(void *)(a1 + 32) + 88), *(unsigned int *)(a1 + 64), *(unsigned __int8 *)(a1 + 68), a1 + 40);
}

uint64_t *sub_100ED9DD8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v24 = a1;
  uint64_t v25 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Resetting Voice Roaming preference as network settings have been reset", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 136));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    xpc_object_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_9;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_9:
    char v15 = *(NSObject **)(v2 + 40);
    uint64_t v16 = (capabilities::ct *)os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if (v16)
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not erase Voice Roaming preference", buf, 2u);
      if (v14) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_14:
  sub_100058DB0(buf, "EURQMIC2KRegistrationController::fEnableOnlyHomeNetwork");
  uint64_t v16 = (capabilities::ct *)(*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v13 + 96))(v13, buf);
  if (v27 < 0)
  {
    operator delete(*(void **)buf);
    if (v14) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_15:
  if ((v14 & 1) == 0) {
LABEL_16:
  }
    sub_10004D2C8(v12);
LABEL_17:
  if (capabilities::ct::supports5G(v16))
  {
    uint64_t v17 = *(void **)(v2 + 64);
    if (v17 != (void *)(v2 + 72))
    {
      do
      {
        unsigned int v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v17 + 8));
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Resetting 5G Standalone enabled to carrier default", buf, 2u);
        }
        (*(void (**)(void))(*(void *)v17[5] + 840))(v17[5]);
        RegistrationController::update5GSACapabilityRestProperty_sync((capabilities::ct *)v2, *((unsigned int *)v17 + 8));
        uint64_t v19 = (void *)v17[1];
        if (v19)
        {
          do
          {
            uint64_t v20 = v19;
            uint64_t v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            uint64_t v20 = (void *)v17[2];
            BOOL v21 = *v20 == (void)v17;
            uint64_t v17 = v20;
          }
          while (!v21);
        }
        uint64_t v17 = v20;
      }
      while (v20 != (void *)(v2 + 72));
    }
  }
  uint64_t v22 = *(void *)(v2 + 232);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 88))(v22);
  }
  sub_100088C88(&v25);
  return sub_100046B58((uint64_t *)&v24);
}

void sub_100EDA0CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_100EDA11C(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void sub_100EDA134()
{
}

void *sub_100EDA148()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A69E78;
  return result;
}

void sub_100EDA180(uint64_t a1, void *a2)
{
  *a2 = off_101A69E78;
}

uint64_t sub_100EDA1AC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A69ED8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EDA1EC()
{
  return &off_101A69ED8;
}

uint64_t *sub_100EDA1F8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  *(void *)long long buf = 0;
  uint64_t v12 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), buf);
  uint64_t v3 = *(void *)buf;
  if (*(void *)buf)
  {
    (*(void (**)(uint64_t *__return_ptr, void))(**(void **)buf + 664))(&v9, *(void *)buf);
    unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 64))(v9);
    sub_100D47D3C(v1 + 16, v4 | (unint64_t)&_mh_execute_header);
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (!v3)
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Could not get model for ERI version query", buf, 2u);
    }
    sub_100D47D3C(v1 + 16, 0);
  }
  sub_100EDA3A4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100EDA360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100EDA3A4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDA3A4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100912244((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100EDA3F8()
{
}

__n128 sub_100EDA40C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A69EF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100EDA458(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A69EF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EDA488(uint64_t a1, char *a2)
{
  char v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 16);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100EDA5F0;
  double v5[3] = &unk_101A69F58;
  v5[4] = v3;
  char v6 = *(unsigned char *)(a1 + 8);
  char v7 = v2;
  uint64_t v10 = 0;
  char v11 = 0;
  sub_10003E168(&v10, (void *)(v3 + 8));
  unsigned int v4 = *(NSObject **)(v3 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
}

uint64_t sub_100EDA5A4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EDA5E4()
{
}

void sub_100EDA5F0(uint64_t a1)
{
  char v2 = *(void **)(a1 + 32);
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (v3 == *(unsigned __int8 *)(a1 + 41))
  {
    unsigned int v4 = v2[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "true";
      if (!v3) {
        uint64_t v5 = "false";
      }
      v7[0] = 67109378;
      v7[1] = v3;
      __int16 v8 = 2080;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Current provisioning state %x matches requested %s, ignoring it", (uint8_t *)v7, 0x12u);
    }
  }
  else
  {
    char v6 = *(void (**)(void))(*v2 + 328);
    v6();
  }
}

void sub_100EDA724()
{
}

void *sub_100EDA738(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A69F98;
  result[1] = v3;
  return result;
}

uint64_t sub_100EDA780(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A69F98;
  a2[1] = v2;
  return result;
}

void sub_100EDA7AC(uint64_t a1, char *a2)
{
  char v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_100EDA90C;
  double v5[3] = &unk_101A69FF8;
  v5[4] = v3;
  char v6 = v2;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_10003E168(&v9, (void *)(v3 + 8));
  unsigned int v4 = *(NSObject **)(v3 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059534;
  block[3] = &unk_101A69B28;
  block[5] = v9;
  __int16 v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  block[4] = v5;
  dispatch_async(v4, block);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

uint64_t sub_100EDA8C0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EDA900()
{
}

uint64_t sub_100EDA90C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 344) + 184))(*(void *)(*(void *)(a1 + 32) + 344), *(unsigned __int8 *)(a1 + 40));
}

uint64_t *sub_100EDA940(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  unsigned int v4 = v1;
  (*(void (**)(void, void))(**(void **)(*(void *)v1 + 232) + 96))(*(void *)(*(void *)v1 + 232), v1[2]);
  sub_100060854((uint64_t)(v1 + 4), 0);
  sub_100EDA9D4((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100EDA9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EDA9D4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10001C9D4((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EDAA24(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 232);
  if (v3 && (*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 72))(v3, *(unsigned int *)(v1 + 8)))
  {
    (*(void (**)(long long *__return_ptr))(**(void **)(v2 + 232) + 56))(&buf);
    uint64_t v4 = *(void *)(v1 + 40);
    if (!v4) {
      sub_10007B600();
    }
LABEL_31:
    (*(void (**)(uint64_t, long long *))(*(void *)v4 + 48))(v4, &buf);
    if (SBYTE7(v35) < 0) {
      operator delete((void *)v34);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete(*((void **)&v32 + 1));
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(*((void **)&v30 + 1));
    }
    if (SBYTE7(v29) < 0) {
      operator delete((void *)buf);
    }
    goto LABEL_53;
  }
  uint64_t v5 = *(void *)(v2 + 184);
  if (!v5)
  {
    __int16 v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "NAISelector not configured for selected network query", (uint8_t *)&buf, 2u);
    }
    NetworkListOperator::NetworkListOperator((NetworkListOperator *)&buf);
    uint64_t v4 = *(void *)(v1 + 40);
    if (!v4) {
      sub_10007B600();
    }
    goto LABEL_31;
  }
  uint64_t v26 = 0;
  char v27 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v5 + 16))(&v26);
  if (v26)
  {
    v24[0] = 0;
    v24[1] = 0;
    uint64_t v25 = 0;
    v22[0] = 0;
    v22[1] = 0;
    uint64_t v23 = 0;
    (*(void (**)(uint64_t, void *, void **))(*(void *)v26 + 40))(v26, v24, v22);
    uint64_t v36 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long buf = 0u;
    long long v29 = 0u;
    NetworkListOperator::NetworkListOperator((NetworkListOperator *)&buf);
    NetworkListOperator::setName();
    NetworkListOperator::decodeKey();
    sub_1004C3B28((char *)__dst, &buf);
    uint64_t v6 = *(void *)(v1 + 40);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **))(*(void *)v6 + 48))(v6, __dst);
    if (v21 < 0) {
      operator delete(__p);
    }
    if (v19 < 0) {
      operator delete(v18);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
    if (v15 < 0) {
      operator delete(__dst[0]);
    }
    if (SBYTE7(v35) < 0) {
      operator delete((void *)v34);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete(*((void **)&v32 + 1));
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(*((void **)&v30 + 1));
    }
    if (SBYTE7(v29) < 0) {
      operator delete((void *)buf);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    if ((SHIBYTE(v25) & 0x80000000) == 0) {
      goto LABEL_51;
    }
    char v7 = (void *)v24[0];
  }
  else
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Request for selected network not supported", (uint8_t *)&buf, 2u);
    }
    NetworkListOperator::NetworkListOperator((NetworkListOperator *)&buf);
    uint64_t v10 = *(void *)(v1 + 40);
    if (!v10) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v10 + 48))(v10, &buf);
    if (SBYTE7(v35) < 0) {
      operator delete((void *)v34);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete(*((void **)&v32 + 1));
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(*((void **)&v30 + 1));
    }
    if ((SBYTE7(v29) & 0x80000000) == 0) {
      goto LABEL_51;
    }
    char v7 = (void *)buf;
  }
  operator delete(v7);
LABEL_51:
  if (v27) {
    sub_10004D2C8(v27);
  }
LABEL_53:
  sub_100EDB00C(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100EDAE8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  char v54 = *(std::__shared_weak_count **)(v52 - 184);
  if (v54) {
    sub_10004D2C8(v54);
  }
  sub_100EDB00C(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDB00C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7ACC((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EDB05C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 232);
  if (v3 && (*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 72))(v3, *(unsigned int *)(v1 + 8)))
  {
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 232) + 64))(buf);
    uint64_t v4 = *(void *)(v1 + 40);
    if (!v4) {
      sub_10007B600();
    }
LABEL_30:
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 48))(v4, buf);
    long long v29 = (void **)buf;
    sub_1004C3EF8(&v29);
    goto LABEL_35;
  }
  uint64_t v5 = *(void *)(v2 + 184);
  if (!v5)
  {
    char v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "NAISelector not configured for network list query", buf, 2u);
    }
    memset(buf, 0, sizeof(buf));
    *(void *)&long long v17 = 0;
    uint64_t v4 = *(void *)(v1 + 40);
    if (!v4) {
      sub_10007B600();
    }
    goto LABEL_30;
  }
  uint64_t v32 = 0;
  long long v33 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v5 + 16))(&v32);
  if (v32)
  {
    long long v29 = 0;
    long long v30 = 0;
    unint64_t v31 = 0;
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 24))(v32);
    if (v6)
    {
      uint64_t v7 = 0;
      do
      {
        v27[0] = 0;
        v27[1] = 0;
        uint64_t v28 = 0;
        v25[0] = 0;
        v25[1] = 0;
        uint64_t v26 = 0;
        (*(void (**)(uint64_t, uint64_t, void ***, void **))(*(void *)v32 + 32))(v32, v7, v27, v25);
        uint64_t v24 = 0;
        *(_OWORD *)long long __p = 0u;
        long long v23 = 0u;
        *(_OWORD *)uint64_t v20 = 0u;
        long long v21 = 0u;
        *(_OWORD *)unsigned int v18 = 0u;
        long long v19 = 0u;
        *(_OWORD *)long long buf = 0u;
        long long v17 = 0u;
        NetworkListOperator::NetworkListOperator((NetworkListOperator *)buf);
        NetworkListOperator::setName();
        NetworkListOperator::decodeKey();
        __int16 v8 = v30;
        if ((unint64_t)v30 >= v31)
        {
          uint64_t v9 = (char *)sub_1004C3A20((uint64_t *)&v29, (long long *)buf);
        }
        else
        {
          sub_1004C3B28(v30, (long long *)buf);
          uint64_t v9 = v8 + 136;
        }
        long long v30 = v9;
        if (SBYTE7(v23) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v21) < 0) {
          operator delete(v20[1]);
        }
        if (SHIBYTE(v19) < 0) {
          operator delete(v18[1]);
        }
        if (SBYTE7(v17) < 0) {
          operator delete(*(void **)buf);
        }
        if (SHIBYTE(v26) < 0) {
          operator delete(v25[0]);
        }
        if (SHIBYTE(v28) < 0) {
          operator delete(v27[0]);
        }
        uint64_t v7 = (v7 + 1);
      }
      while (v6 != v7);
    }
    memset(buf, 0, sizeof(buf));
    *(void *)&long long v17 = 0;
    sub_1004C3DEC(buf, (uint64_t)v29, (uint64_t)v30, 0xF0F0F0F0F0F0F0F1 * ((v30 - (char *)v29) >> 3));
    uint64_t v10 = *(void *)(v1 + 40);
    if (!v10) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v10 + 48))(v10, buf);
    v27[0] = (void **)buf;
    sub_1004C3EF8(v27);
    v27[0] = (void **)&v29;
    sub_1004C3EF8(v27);
  }
  else
  {
    uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Request for network list not supported", buf, 2u);
    }
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
LABEL_35:
  sub_100EDB598(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_100EDB49C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  uint64_t v39 = *(std::__shared_weak_count **)(v37 - 56);
  if (v39) {
    sub_10004D2C8(v39);
  }
  sub_100EDB598(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDB598(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7B50((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EDB5E8(unsigned int **a1)
{
  uint64_t v1 = *a1;
  __int16 v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 232);
  if (v3 && (*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 72))(v3, v1[2]))
  {
    int v4 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 232) + 40))(*(void *)(v2 + 232), v1[2]);
  }
  else
  {
    uint64_t v5 = *(void *)(v2 + 184);
    if (v5)
    {
      *(void *)long long buf = 0;
      char v11 = 0;
      (*(void (**)(uint8_t *__return_ptr))(*(void *)v5 + 16))(buf);
      if ((*(unsigned int (**)(void))(**(void **)buf + 96))(*(void *)buf)) {
        int v4 = 1;
      }
      else {
        int v4 = 2;
      }
      if (v11) {
        sub_10004D2C8(v11);
      }
    }
    else
    {
      int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        int v4 = 2;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "NAISelector not configured for network selection mode query", buf, 2u);
      }
      else
      {
        int v4 = 2;
      }
    }
  }
  sub_100D47D9C((uint64_t)(v1 + 4), v4);
  sub_100EDB7C4((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100EDB794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100EDB7C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDB7C4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7BD4((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EDB814(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  *(void *)long long buf = 0;
  unsigned int v18 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), buf);
  uint64_t v3 = *(void *)buf;
  if (*(void *)buf)
  {
    uint64_t v4 = *(void *)(v2 + 232);
    if (v4 && (*(unsigned int (**)(uint64_t, void))(*(void *)v4 + 72))(v4, *(unsigned int *)(v1 + 8)))
    {
      uint64_t v5 = *(void *)(v2 + 232);
      uint64_t v6 = *(unsigned int *)(v1 + 8);
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v3 + 456))(&__p, v3);
      int v7 = (*(uint64_t (**)(uint64_t, uint64_t, void **))(*(void *)v5 + 104))(v5, v6, &__p);
      if (v16 < 0) {
        operator delete(__p);
      }
    }
    else
    {
      uint64_t v8 = *(void *)(v2 + 184);
      if (v8)
      {
        long long __p = 0;
        uint64_t v15 = 0;
        (*(void (**)(void **__return_ptr))(*(void *)v8 + 16))(&__p);
        if ((*(unsigned int (**)(void *))(*(void *)__p + 96))(__p)) {
          int v7 = (*(uint64_t (**)(void *))(*(void *)__p + 64))(__p);
        }
        else {
          int v7 = 0;
        }
        if (v15) {
          sub_10004D2C8(v15);
        }
      }
      else
      {
        uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "NAISelector not configured for network selection state query", (uint8_t *)&__p, 2u);
        }
        int v7 = 0;
      }
    }
    sub_100D47DFC(v1 + 16, v7);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (!v3)
  {
    uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not get model for network selection state query", buf, 2u);
    }
    sub_100D47DFC(v1 + 16, 0);
  }
  sub_100EDBB48(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100EDBAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_100EDBB48(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDBB48(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7C58((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EDBB98(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v12 = a1;
  uint64_t v13 = v1;
  uint64_t v2 = *(void *)v1;
  long long v36 = 0u;
  memset(v37, 0, 24);
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  NetworkListOperator::NetworkListOperator((NetworkListOperator *)&v30);
  uint64_t v28 = 0;
  long long v29 = 0;
  RegistrationController::getModel_sync(v2, *(_DWORD *)(v1 + 8), &v28);
  uint64_t v3 = v28;
  if (v28)
  {
    uint64_t v4 = *(void *)(v2 + 232);
    if (v4 && (*(unsigned int (**)(uint64_t, void))(*(void *)v4 + 72))(v4, *(unsigned int *)(v1 + 8)))
    {
      uint64_t v5 = *(void *)(v2 + 232);
      uint64_t v6 = *(unsigned int *)(v1 + 8);
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v3 + 456))(__p, v3);
      int v7 = (*(uint64_t (**)(uint64_t, uint64_t, void **))(*(void *)v5 + 104))(v5, v6, __p);
      if (SHIBYTE(v27) < 0) {
        operator delete(__p[0]);
      }
      int v8 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 232) + 40))(*(void *)(v2 + 232), *(unsigned int *)(v1 + 8));
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 232) + 56))(buf);
      if (SBYTE7(v31) < 0) {
        operator delete((void *)v30);
      }
      long long v30 = *(_OWORD *)buf;
      *(void *)&long long v31 = v17;
      HIBYTE(v17) = 0;
      buf[0] = 0;
      DWORD2(v31) = v18;
      MCC::operator=();
      MCC::operator=();
      if (SBYTE7(v37[0]) < 0) {
        operator delete((void *)v36);
      }
      long long v36 = *(_OWORD *)v23;
      *(void *)&v37[0] = v24;
      HIBYTE(v24) = 0;
      LOBYTE(v23[0]) = 0;
      *(_OWORD *)((char *)v37 + 8) = v25;
      if (v22 < 0) {
        operator delete(v21);
      }
      if (v20 < 0) {
        operator delete(v19);
      }
      if (SHIBYTE(v17) < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(v2 + 184) + 16))(&v14);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 96))(v14))
      {
        int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 64))(v14);
        memset(buf, 0, sizeof(buf));
        uint64_t v17 = 0;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v27 = 0;
        (*(void (**)(uint64_t, uint8_t *, void **))(*(void *)v14 + 40))(v14, buf, __p);
        NetworkListOperator::setName();
        NetworkListOperator::decodeKey();
        if (SHIBYTE(v27) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v17) < 0) {
          operator delete(*(void **)buf);
        }
        int v8 = 1;
      }
      else
      {
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          int v8 = 2;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Neither manual selection or NAI is supported", buf, 2u);
          int v7 = 0;
        }
        else
        {
          int v7 = 0;
          int v8 = 2;
        }
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
    }
  }
  else
  {
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v1 + 8));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      int v8 = 2;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get model for network selection info query", buf, 2u);
      int v7 = 0;
    }
    else
    {
      int v7 = 0;
      int v8 = 2;
    }
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_1004C3B28((char *)buf, &v30);
  sub_100D47EE8(v1 + 16, v7, v8);
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[0]);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(*(void **)buf);
  }
  if (SBYTE7(v37[0]) < 0) {
    operator delete((void *)v36);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(*((void **)&v34 + 1));
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(*((void **)&v32 + 1));
  }
  if (SBYTE7(v31) < 0) {
    operator delete((void *)v30);
  }
  sub_100EDC21C(&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100EDC0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,std::__shared_weak_count *a49)
{
  if (a49) {
    sub_10004D2C8(a49);
  }
  if (*(char *)(v49 - 73) < 0) {
    operator delete(*(void **)(v49 - 96));
  }
  if (*(char *)(v49 - 97) < 0) {
    operator delete(*(void **)(v49 - 120));
  }
  if (*(char *)(v49 - 129) < 0) {
    operator delete(*(void **)(v49 - 152));
  }
  if (*(char *)(v49 - 169) < 0) {
    operator delete(*(void **)(v49 - 192));
  }
  sub_100EDC21C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDC21C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7CDC((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EDC26C(unsigned int **a1)
{
  uint64_t v1 = *a1;
  int v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 232);
  if (v3 && (*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 72))(v3, v1[2]))
  {
    char v4 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 232) + 128))(*(void *)(v2 + 232), v1[2]);
  }
  else
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1[2]);
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    char v4 = 0;
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Network selection is not enabled, assuming reselection is not needed", buf, 2u);
      char v4 = 0;
    }
  }
  sub_1000607A8((uint64_t)(v1 + 4), v4);
  sub_10041EF98((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100EDC38C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EDC3A8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v17 = a1;
  uint64_t v18 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(v1 + 8));
  char v4 = sub_100ED68D0(v2, *(unsigned int *)(v1 + 8));
  uint64_t v5 = *v3;
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      int v7 = (void *)(v1 + 48);
      if (*(char *)(v1 + 71) < 0) {
        int v7 = (void *)*v7;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Selecting network with code %s", buf, 0xCu);
    }
    uint64_t v8 = *(void *)(v2 + 232);
    uint64_t v9 = *(unsigned int *)(v1 + 8);
    if (v8)
    {
      int v10 = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 72))(v8, *(unsigned int *)(v1 + 8));
      uint64_t v9 = *(unsigned int *)(v1 + 8);
      uint64_t v11 = v1 + 48;
      int v12 = *(char *)(v1 + 71);
      if (v10)
      {
        uint64_t v13 = *(void *)(v2 + 232);
        if (v12 < 0)
        {
          sub_10004FC84(buf, *(void **)(v1 + 48), *(void *)(v1 + 56));
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)v11;
          uint64_t v20 = *(void *)(v1 + 64);
        }
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v13 + 112))(v13, v9, buf);
LABEL_20:
        if (SHIBYTE(v20) < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v14 = 0;
        goto LABEL_23;
      }
      uint64_t v15 = *(void *)(v2 + 264);
      if ((v12 & 0x80000000) == 0) {
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(v2 + 264);
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
      {
        uint64_t v11 = v1 + 48;
LABEL_15:
        *(_OWORD *)long long buf = *(_OWORD *)v11;
        uint64_t v20 = *(void *)(v11 + 16);
LABEL_17:
        (*(void (**)(uint64_t, uint64_t, uint8_t *, const char *))(*(void *)v15 + 352))(v15, v9, buf, "due NAI selection");
        goto LABEL_20;
      }
    }
    sub_10004FC84(buf, *(void **)(v1 + 48), *(void *)(v1 + 56));
    goto LABEL_17;
  }
  uint64_t v14 = 0x2D00000001;
  if (v6)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#N Network selection is not supported", buf, 2u);
  }
LABEL_23:
  sub_100060854(v1 + 16, v14);
  sub_100EDC66C(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_100EDC630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100EDC66C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDC66C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    sub_10001C9D4((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_100EDC6CC(uint64_t a1)
{
  return sub_100ED68D0(**(void **)(a1 + 40), **(unsigned int **)(*(void *)(a1 + 40) + 8));
}

uint64_t *sub_100EDC6DC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v4 = a1;
  uint64_t v5 = v1;
  char v2 = sub_100ED68D0(*(void *)v1, *(unsigned int *)(v1 + 40));
  sub_1000607A8(v1 + 8, v2);
  sub_100EDC74C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100EDC730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EDC74C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100060644((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100EDC79C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100EDC81C(int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  int v12 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  if (capabilities::ct::supportsSecurityStatus((capabilities::ct *)v3))
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    RegistrationController::getModel_sync(v2, v1[2], &v14);
    if (v14)
    {
      int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 784))(v14);
      uint64_t v5 = std::generic_category();
      uint64_t v6 = 0;
      int v7 = v4;
    }
    else
    {
      uint64_t v9 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not find model when getting encryption status", buf, 2u);
      }
      uint64_t v6 = 22;
      uint64_t v5 = std::generic_category();
      int v7 = 0;
    }
    sub_100D48124((uint64_t)(v1 + 4), v7, v6, (uint64_t)v5);
    if (v15) {
      sub_10004D2C8(v15);
    }
  }
  else
  {
    uint64_t v8 = std::generic_category();
    sub_100D48124((uint64_t)(v1 + 4), 0, 45, (uint64_t)v8);
  }
  sub_100EDC9B4((uint64_t *)&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100EDC984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_100EDC9B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EDC9B4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100ED7D60((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100EDCA04(uint64_t a1@<X0>, NRStatus *a2@<X8>)
{
}

__n128 sub_100EDCA14(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(__n128 **)(a1 + 32);
  __n128 result = v4;
  v2[1].n128_u32[0] = v5;
  __n128 *v2 = result;
  return result;
}

__n128 sub_100EDCA68(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(__n128 **)(a1 + 32);
  __n128 result = v4;
  v2[1].n128_u32[0] = v5;
  __n128 *v2 = result;
  return result;
}

uint64_t sub_100EDCABC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 8);
  **(unsigned char **)uint64_t v1 = 0;
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(v1 + 16));
  uint64_t v20 = 0;
  long long v21 = 0;
  Model_sync = (capabilities::ct *)RegistrationController::getModel_sync(v2, **(_DWORD **)(v1 + 16), &v20);
  uint64_t v5 = v20;
  if (!v20)
  {
    uint64_t v15 = *v3;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v19 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find model when checking 5G Standalone support", v19, 2u);
    }
    uint64_t v14 = 0x1600000000;
    goto LABEL_26;
  }
  if ((capabilities::ct::supports5G(Model_sync) & 1) == 0
    || ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 808))(v5) & 1) == 0)
  {
    goto LABEL_25;
  }
  if (!RegistrationController::supports5GNSA_sync(v2))
  {
    unsigned int v16 = (*(unsigned __int16 (**)(uint64_t))(*(void *)v5 + 832))(v5);
    if (v16 <= 0x100) {
      LOBYTE(v16) = 0;
    }
    **(unsigned char **)uint64_t v1 = v16 != 0;
    goto LABEL_25;
  }
  uint64_t v6 = *(void *)(v2 + 864);
  if (!v6) {
    goto LABEL_15;
  }
  int v7 = **(_DWORD **)(v1 + 16);
  uint64_t v8 = v2 + 864;
  do
  {
    int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 < v7;
    if (v9 >= v7) {
      uint64_t v11 = (uint64_t *)v6;
    }
    else {
      uint64_t v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == v2 + 864 || v7 < *(_DWORD *)(v8 + 28)) {
    goto LABEL_15;
  }
  if (NRDisableStatus::isSADisabledWithReason())
  {
LABEL_25:
    uint64_t v14 = 0x2D00000000;
LABEL_26:
    uint64_t v17 = 1;
    goto LABEL_27;
  }
  if ((NRDisableStatus::isSADisabledWithReason() & 1) != 0
    || (NRDisableStatus::isSADisabledWithReason() & 1) != 0
    || (NRDisableStatus::isSADisabledWithReason() & 1) != 0)
  {
    uint64_t v14 = 0;
    uint64_t v17 = 0;
    goto LABEL_27;
  }
  uint64_t v5 = v20;
LABEL_15:
  unsigned __int16 v12 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 832))(v5);
  if (v12 < 0x100u)
  {
    uint64_t v13 = *v3;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone support not yet known", v19, 2u);
    }
    uint64_t v14 = 0x2300000000;
    goto LABEL_26;
  }
  uint64_t v14 = 0;
  uint64_t v17 = 0;
  **(unsigned char **)uint64_t v1 = v12;
LABEL_27:
  if (v21) {
    sub_10004D2C8(v21);
  }
  return v17 | v14;
}

void sub_100EDCD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EDCDAC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100EDCDE8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100EDCE24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(capabilities::ct **)v1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), **(unsigned int **)(v1 + 8));
  uint64_t v18 = 0;
  long long v19 = 0;
  Model_sync = (capabilities::ct *)RegistrationController::getModel_sync((uint64_t)v2, **(_DWORD **)(v1 + 8), &v18);
  uint64_t v5 = v18;
  if (!v18)
  {
    int v7 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find model when setting 5G Standalone support", buf, 2u);
    }
    uint64_t v6 = 0x1600000000;
    goto LABEL_8;
  }
  if ((capabilities::ct::supports5G(Model_sync) & 1) == 0
    || ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 808))(v5) & 1) == 0)
  {
LABEL_4:
    uint64_t v6 = 0x2D00000000;
LABEL_8:
    uint64_t v8 = 1;
    goto LABEL_9;
  }
  uint64_t v10 = *((void *)v2 + 108);
  if (v10)
  {
    int v11 = **(_DWORD **)(v1 + 8);
    unsigned __int16 v12 = (void *)((char *)v2 + 864);
    do
    {
      int v13 = *(_DWORD *)(v10 + 28);
      BOOL v14 = v13 < v11;
      if (v13 >= v11) {
        uint64_t v15 = (uint64_t *)v10;
      }
      else {
        uint64_t v15 = (uint64_t *)(v10 + 8);
      }
      if (!v14) {
        unsigned __int16 v12 = (void *)v10;
      }
      uint64_t v10 = *v15;
    }
    while (*v15);
    if (v12 != (void *)((char *)v2 + 864) && v11 >= *((_DWORD *)v12 + 7))
    {
      if ((NRDisableStatus::isSADisabledWithReason() & 1) != 0
        || (NRDisableStatus::isSADisabledWithReason() & 1) != 0
        || (NRDisableStatus::isSADisabledWithReason() & 1) != 0
        || (NRDisableStatus::isSADisabledWithReason() & 1) != 0)
      {
        goto LABEL_4;
      }
      uint64_t v5 = v18;
    }
  }
  (*(void (**)(uint64_t, void))(*(void *)v5 + 800))(v5, **(unsigned __int8 **)(v1 + 16));
  int v16 = **(_DWORD **)(v1 + 8);
  char v17 = **(unsigned char **)(v1 + 16);
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v21 = 0x40000000;
  char v22 = sub_100515678;
  long long v23 = &unk_1019DD908;
  uint64_t v24 = v2;
  char v26 = v17;
  int v25 = v16;
  sub_100515498((wis::MetricFactory *)0x8012B);
  RegistrationController::send5GStandaloneEnabledSettingFromPreference_sync((uint64_t)v2, **(unsigned int **)(v1 + 8), 1);
  RegistrationController::update5GSACapabilityRestProperty_sync(v2, **(unsigned int **)(v1 + 8));
  uint64_t v6 = 0;
  uint64_t v8 = 0;
LABEL_9:
  if (v19) {
    sub_10004D2C8(v19);
  }
  return v8 | v6;
}

void sub_100EDD0B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100EDD0D4(unsigned int **a1)
{
  uint64_t v1 = *a1;
  __n128 v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  (*(void (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  (*(void (**)(void, void, unsigned int *))(**(void **)(v2 + 88) + 280))(*(void *)(v2 + 88), v1[2], v1 + 4);
  sub_100AB63B8((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100EDD178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EDD194(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  int v7 = v1;
  uint64_t v2 = *(void *)v1;
  (*(void (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v1[2]);
  int ImsStateForBaseband_sync = RegistrationController::getImsStateForBaseband_sync(v2, v1[2]);
  int VoNRStateForBaseband_sync = RegistrationController::getVoNRStateForBaseband_sync(v2, v1[2]);
  sub_100D478E0((uint64_t)(v1 + 4), ImsStateForBaseband_sync, VoNRStateForBaseband_sync);
  sub_100EDD250((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100EDD234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100EDD250(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_1003FB6D4((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100EDD2A0(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, uint64_t))(**(void **)(**(void **)a1 + 88) + 288))(*(void *)(**(void **)a1 + 88), *(unsigned int *)(*(void *)a1 + 8), *(void *)a1 + 12);
  operator delete();
}

void sub_100EDD328()
{
}

void STK_Controller::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100EDD8D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

const char *sub_100EDDB6C(int a1)
{
  uint64_t v1 = "stk.?";
  if (a1 == 2) {
    uint64_t v1 = "stk.2";
  }
  if (a1 == 1) {
    return "stk.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_100EDDB98(uint64_t a1)
{
  *(void *)a1 = off_101A6A3B0;
  uint64_t v2 = (STKStateModelDelegateInterface *)(a1 + 56);
  *(void *)(a1 + 56) = off_101A6A4D0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 328);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100160A84((atomic_uint **)(a1 + 296));
  sub_10019D460(a1 + 272, *(void **)(a1 + 280));
  sub_10097EC08(a1 + 248, *(void **)(a1 + 256));
  sub_100088048(a1 + 224, *(void **)(a1 + 232));
  sub_1000346F8(a1 + 200, *(void **)(a1 + 208));
  sub_1001085D8(a1 + 152);
  __n128 v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100119D90(*(void **)(a1 + 112));
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7) {
    sub_10004D2C8(v7);
  }
  STKStateModelDelegateInterface::~STKStateModelDelegateInterface(v2);
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  STK_Interface::~STK_Interface((STK_Interface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100EDDCF8(uint64_t a1)
{
  return sub_100EDDB98(a1 - 56);
}

void sub_100EDDD00(uint64_t a1)
{
  sub_100EDDB98(a1);

  operator delete();
}

void sub_100EDDD38(uint64_t a1)
{
  sub_100EDDB98(a1 - 56);

  operator delete();
}

void sub_100EDDD74(uint64_t a1, int a2)
{
  __n128 v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v14 = 0;
  uint64_t v15 = 0;
  STK_Controller::getStateModel_sync(a1, a2, &v14);
  uint64_t v5 = v14;
  uint64_t v6 = *v4;
  int v7 = *v4;
  if (v14)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I There has been a SIM Refresh, sending out Idle Text Wipe event", buf, 2u);
    }
    __int16 v10 = 0;
    v9[1] = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v11 = 0;
    __int16 v19 = 0;
    uint64_t v18 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v8 = *v5;
    *(_DWORD *)long long buf = 12;
    (*(void (**)(uint64_t *, uint8_t *))(v8 + 40))(v5, buf);
    sub_1000A3DCC(buf);
    SetupIdleText::~SetupIdleText((SetupIdleText *)v9);
  }
  else if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Could not find state model upon SIM refresh event", buf, 2u);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100EDDF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, int a17)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EDDF68(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (char *)(result + 152);
  uint64_t v4 = a2[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a2[23];
  }
  else {
    uint64_t v5 = *((void *)a2 + 1);
  }
  uint64_t v6 = *(unsigned __int8 *)(result + 175);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(result + 160);
  }
  if (v5 == v6)
  {
    uint64_t v8 = *(char **)v3;
    if (v7 >= 0) {
      uint64_t v8 = (char *)(result + 152);
    }
    if ((v4 & 0x80) != 0)
    {
      uint64_t result = memcmp(*(const void **)a2, v8, *((void *)a2 + 1));
      if (!result) {
        return result;
      }
    }
    else
    {
      if (!a2[23]) {
        return result;
      }
      while (*a2 == *v8)
      {
        ++a2;
        ++v8;
        if (!--v4) {
          return result;
        }
      }
    }
  }
  int v9 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v10 = v3;
    if (v7 < 0) {
      __int16 v10 = *(char **)v3;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v14 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Language has changed to %{public}s", buf, 0xCu);
    LOBYTE(v7) = *(unsigned char *)(v2 + 175);
  }
  if ((v7 & 0x80) != 0) {
    uint64_t v3 = *(char **)v3;
  }
  sub_100058DB0(__p, v3);
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 120))(v2, __p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = *(void *)(v2 + 320);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 24))(result, v2 + 176);
  }
  return result;
}

void sub_100EDE118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EDE13C(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 216))
  {
    uint64_t v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v5 = *(void **)(a1 + 200);
    while (1)
    {
      BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v4 + 8) == *((_DWORD *)v5 + 8);
      if (!v6) {
        break;
      }
      int v7 = (void *)v4[1];
      uint64_t v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v6 = *v4 == (void)v8;
          uint64_t v8 = v4;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          __int16 v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          __int16 v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v4 == a2 + 1) {
        return;
      }
    }
  }
  sub_100EDED68(a1);
  uint64_t v11 = *(void **)(a1 + 104);
  if (v11 != (void *)(a1 + 112))
  {
    char v12 = a2 + 1;
    uint64_t v13 = (uint64_t *)(a1 + 208);
    do
    {
      uint64_t v14 = *v12;
      uint64_t v15 = *((unsigned int *)v11 + 8);
      if (*v12)
      {
        do
        {
          if (*(_DWORD *)(v14 + 28) >= (int)v15) {
            int v16 = (uint64_t *)v14;
          }
          else {
            int v16 = (uint64_t *)(v14 + 8);
          }
          uint64_t v14 = *v16;
        }
        while (*v16);
      }
      uint64_t v17 = *v13;
      if (*v13)
      {
        do
        {
          if (*(_DWORD *)(v17 + 28) >= (int)v15) {
            uint64_t v18 = (uint64_t *)v17;
          }
          else {
            uint64_t v18 = (uint64_t *)(v17 + 8);
          }
          uint64_t v17 = *v18;
        }
        while (*v18);
      }
      __int16 v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v15);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = asString();
        uint64_t v21 = asString();
        *(_DWORD *)long long buf = 136315394;
        uint64_t v25 = v20;
        __int16 v26 = 2080;
        uint64_t v27 = v21;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I RAT has changed from %s to %s", buf, 0x16u);
      }
      uint64_t v22 = (void *)v11[1];
      if (v22)
      {
        do
        {
          long long v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          long long v23 = (void *)v11[2];
          BOOL v6 = *v23 == (void)v11;
          uint64_t v11 = v23;
        }
        while (!v6);
      }
      uint64_t v11 = v23;
    }
    while (v23 != (void *)(a1 + 112));
  }
}

void sub_100EDE3EC(uint64_t a1, uint64_t a2)
{
  sub_100EDED68(a1);
  uint64_t v4 = *(void **)(a1 + 224);
  if (v4 != (void *)(a1 + 232))
  {
    uint64_t v5 = (uint64_t *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      int v7 = *((_DWORD *)v4 + 8);
      uint64_t v8 = a2 + 8;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if ((uint64_t *)v8 == v5 || v7 < *(_DWORD *)(v8 + 32)) {
        goto LABEL_16;
      }
      if ((BasicSimInfo::operator==() & 1) == 0)
      {
        int v7 = *((_DWORD *)v4 + 8);
        uint64_t v12 = a1;
        uint64_t v13 = (uint64_t)(v4 + 5);
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v14 = (void *)v4[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v4[2];
          BOOL v16 = *v15 == (void)v4;
          uint64_t v4 = v15;
        }
        while (!v16);
      }
      uint64_t v4 = v15;
      if (v15 == (void *)(a1 + 232)) {
        return;
      }
    }
    int v7 = *((_DWORD *)v4 + 8);
LABEL_16:
    uint64_t v13 = (uint64_t)(v4 + 5);
    uint64_t v12 = a1;
LABEL_17:
    sub_100EE36F8(v12, v7, v13);
    goto LABEL_18;
  }
}

void sub_100EDE4E4(uint64_t a1, uint64_t a2)
{
  void (***v15)(uint64_t *__return_ptr, void, uint64_t);
  char v16;
  int v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;
  void *v21;
  void **v22;
  char v23;
  void *v24;
  os_log_t *v25;
  os_log_t *v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  void *v30;
  void **v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  long long v35;
  NSObject *v36;
  NSObject *v37;
  BOOL v38;
  void **v39;
  uint64_t v40;
  uint8_t buf[8];
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  std::__shared_weak_count *v45;
  uint8_t *v46;

  uint64_t v2 = *(uint64_t **)(a1 + 248);
  uint64_t v3 = (uint64_t *)(a1 + 256);
  if (v2 != (uint64_t *)(a1 + 256))
  {
    uint64_t v5 = (void **)(a2 + 8);
    uint64_t v6 = (uint64_t *)(a1 + 280);
    uint64_t v39 = (void **)(a1 + 280);
    __int16 v40 = a1 + 272;
    while (1)
    {
      __int16 v44 = 0;
      uint64_t v45 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(a1 + 64));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        BOOL v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v9;
      uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
      if (v13)
      {
        uint64_t v15 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          BOOL v16 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      BOOL v16 = 1;
LABEL_11:
      (**v15)(&v44, v15, (uint64_t)(v2 + 4));
      if ((v16 & 1) == 0) {
        sub_10004D2C8(v14);
      }
      if (v44 && !*(unsigned char *)(v44 + 49))
      {
        uint64_t v20 = *(unsigned int *)(v44 + 52);
        uint64_t v21 = *v5;
        if (!*v5) {
          goto LABEL_37;
        }
        uint64_t v22 = v5;
        do
        {
          long long v23 = sub_100046FE8(v21 + 4, (void **)v2 + 4);
          if (v23 >= 0) {
            uint64_t v24 = v21;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          if (v23 >= 0) {
            uint64_t v22 = (void **)v21;
          }
          uint64_t v21 = (void *)*v24;
        }
        while (*v24);
        if (v22 == v5 || (sub_100046FE8(v2 + 4, v22 + 4) & 0x80) != 0) {
LABEL_37:
        }
          uint64_t v22 = v5;
        uint64_t v25 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v20);
        __int16 v26 = v25;
        if (v5 != v22)
        {
          uint64_t v28 = (unsigned __int8 *)v2[7];
          uint64_t v27 = (unsigned __int8 *)v2[8];
          long long v30 = v22 + 7;
          long long v29 = (unsigned __int8 *)v22[7];
          if (v27 - v28 == v30[1] - (void)v29)
          {
            while (v28 != v27)
            {
              uint64_t v25 = (os_log_t *)sub_100592118(v28, v29);
              if (!v25) {
                goto LABEL_43;
              }
              v28 += 32;
              v29 += 32;
            }
            long long v36 = *v26;
            if (os_log_type_enabled(*v26, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I No change in IMS reg identities", buf, 2u);
            }
            uint64_t v17 = 1;
            goto LABEL_16;
          }
        }
LABEL_43:
        if (!*(void *)(a1 + 288)
          || !capabilities::ct::supportsSTKSendIMSRegEvent((capabilities::ct *)v25))
        {
          goto LABEL_64;
        }
        long long v31 = sub_100046F68(v40, (void **)(v44 + 24));
        if (v39 != v31 && v31[22] != v31[23])
        {
          *(void *)long long buf = 0;
          size_t v42 = 0;
          uint64_t v43 = 0;
          long long v32 = v2[7];
          long long v33 = v2[8];
          if (v32 != v33)
          {
            long long v34 = 0;
            do
            {
              if (*(_DWORD *)(v32 + 24) == 2)
              {
                if (v34 >= v43)
                {
                  long long v34 = sub_100048008((uint64_t *)buf, (long long *)v32);
                }
                else
                {
                  if (*(char *)(v32 + 23) < 0)
                  {
                    sub_10004FC84((unsigned char *)v34, *(void **)v32, *(void *)(v32 + 8));
                  }
                  else
                  {
                    long long v35 = *(_OWORD *)v32;
                    *(void *)(v34 + 16) = *(void *)(v32 + 16);
                    *(_OWORD *)long long v34 = v35;
                  }
                  v34 += 24;
                }
                size_t v42 = v34;
              }
              v32 += 32;
            }
            while (v32 != v33);
          }
          (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t, void))(*(void *)a1 + 136))(a1, v20, buf, 200, 0);
          uint64_t v46 = buf;
          sub_100047F64((void ***)&v46);
          goto LABEL_64;
        }
        uint64_t v37 = *v26;
        __int16 v38 = os_log_type_enabled(*v26, OS_LOG_TYPE_DEFAULT);
        uint64_t v17 = 0;
        if (v38)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I impu absent in ims_info_ready", buf, 2u);
LABEL_64:
          uint64_t v17 = 0;
        }
      }
      else
      {
        uint64_t v17 = 3;
      }
LABEL_16:
      if (v45) {
        sub_10004D2C8(v45);
      }
      if (v17 == 3 || !v17)
      {
        uint64_t v18 = (uint64_t *)v2[1];
        if (v18)
        {
          do
          {
            uint64_t v6 = v18;
            uint64_t v18 = (uint64_t *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v6 = (uint64_t *)v2[2];
            __int16 v19 = *v6 == (void)v2;
            uint64_t v2 = v6;
          }
          while (!v19);
        }
        uint64_t v2 = v6;
        if (v6 != v3) {
          continue;
        }
      }
      return;
    }
  }
}

void sub_100EDE8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void **a16)
{
  a16 = (void **)&a11;
  sub_100047F64(&a16);
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(a1);
}

void sub_100EDE940(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

uint64_t STK_Controller::createSTKSimSlotInfo_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 232);
  uint64_t v2 = a1 + 232;
  uint64_t v3 = v4;
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 32);
    BOOL v7 = v6 < (int)a2;
    if (v6 >= (int)a2) {
      uint64_t v8 = (uint64_t *)v3;
    }
    else {
      uint64_t v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 != v2 && *(_DWORD *)(v5 + 32) <= (int)a2) {
    uint64_t v9 = *(unsigned int *)(v5 + 44);
  }
  else {
LABEL_11:
  }
    uint64_t v9 = 0;
  return v9 | (a2 << 32);
}

unint64_t sub_100EDEA88(uint64_t a1, unint64_t a2)
{
  unint64_t result = HIDWORD(a2);
  if (!HIDWORD(a2))
  {
    uint64_t v4 = *(void **)(a1 + 224);
    uint64_t v5 = (void *)(a1 + 232);
    if (v4 != v5)
    {
      while (*((_DWORD *)v4 + 11) != a2)
      {
        int v6 = (void *)v4[1];
        if (v6)
        {
          do
          {
            BOOL v7 = v6;
            int v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            BOOL v7 = (void *)v4[2];
            BOOL v8 = *v7 == (void)v4;
            uint64_t v4 = v7;
          }
          while (!v8);
        }
        uint64_t v4 = v7;
        if (v7 == v5) {
          return 0;
        }
      }
    }
    if (v4 == v5) {
      return 0;
    }
    else {
      return *((unsigned int *)v4 + 8);
    }
  }
  return result;
}

uint64_t STK_Controller::shouldAllowSTK_sync(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v5 = *(void *)(a1 + 232);
  if (v5)
  {
    uint64_t v6 = a1 + 232;
    do
    {
      int v7 = *(_DWORD *)(v5 + 32);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t *)v5;
      }
      else {
        uint64_t v9 = (uint64_t *)(v5 + 8);
      }
      if (!v8) {
        uint64_t v6 = v5;
      }
      uint64_t v5 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 232 && *(_DWORD *)(v6 + 32) <= a2)
    {
      uint64_t v28 = *(_DWORD **)(v6 + 56);
      uint64_t v27 = *(_DWORD **)(v6 + 64);
      while (v28 != v27)
      {
        if ((*v28 - 3) <= 1)
        {
          long long v29 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v31) = 0;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I The SIM is a 1x SIM, handling STK", (uint8_t *)&v31, 2u);
          }
          return 1;
        }
        ++v28;
      }
    }
  }
  uint64_t v12 = *(void *)(a1 + 208);
  uint64_t v11 = a1 + 208;
  uint64_t v10 = v12;
  if (!v12) {
    goto LABEL_36;
  }
  uint64_t v13 = v11;
  do
  {
    int v14 = *(_DWORD *)(v10 + 28);
    BOOL v15 = v14 < a2;
    if (v14 >= a2) {
      BOOL v16 = (uint64_t *)v10;
    }
    else {
      BOOL v16 = (uint64_t *)(v10 + 8);
    }
    if (!v15) {
      uint64_t v13 = v10;
    }
    uint64_t v10 = *v16;
  }
  while (*v16);
  if (v13 == v11)
  {
LABEL_36:
    BOOL v17 = 1;
    goto LABEL_37;
  }
  BOOL v17 = 1;
  if (*(_DWORD *)(v13 + 28) > a2)
  {
LABEL_37:
    int v25 = 1;
    return v17 | v25;
  }
  unsigned int v18 = *(_DWORD *)(v13 + 32);
  BOOL v17 = v18 - 6 < 0xFFFFFFFD && v18 != 8;
  if (v18 <= 8 && ((1 << v18) & 0x138) != 0)
  {
    os_log_t v20 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    LOWORD(v31) = 0;
    uint64_t v21 = "#I The device is on CDMA mode, STK is not valid in this state. Suppressing STK events";
    uint64_t v22 = v20;
    uint32_t v23 = 2;
    goto LABEL_30;
  }
  os_log_t v30 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    int v31 = 136315138;
    uint64_t v32 = asString();
    uint64_t v21 = "#I Handling STK API as current RAT is %s";
    uint64_t v22 = v30;
    uint32_t v23 = 12;
LABEL_30:
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&v31, v23);
  }
LABEL_31:
  if (v18 > 8 || ((1 << v18) & 0x138) == 0) {
    goto LABEL_37;
  }
  int v25 = 0;
  return v17 | v25;
}

uint64_t sub_100EDED68(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 104);
  uint64_t v2 = (void *)(result + 112);
  if (v1 != (void *)(result + 112))
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = v1[5];
      uint64_t shouldAllowSTK_sync = STK_Controller::shouldAllowSTK_sync(v3, *((_DWORD *)v1 + 8));
      unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 80))(v4, shouldAllowSTK_sync);
      uint64_t v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

uint64_t STK_Controller::validateState(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v18 = 0;
  __int16 v19 = 0;
  STK_Controller::getStateModel_sync(a1, a2, &v18);
  if (v18)
  {
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v18 + 152))(buf);
    int v7 = *(_DWORD *)buf ^ (*(int *)buf >> 31);
    if (v7 >= 0x1E) {
      sub_1000971B8();
    }
    int v8 = dword_10158BAB8[v7];
    uint64_t v9 = sub_1000A3DCC(buf);
    if (v8 == a3)
    {
      if (*(_DWORD *)(a1 + 144) != 2 || (capabilities::ct::defaultVinylCardTypeToGSMA((capabilities::ct *)v9) & 1) != 0)
      {
        uint64_t v10 = 1;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = *v6;
      BOOL v14 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      uint64_t v10 = 0;
      if (!v14) {
        goto LABEL_12;
      }
      uint64_t v15 = asString();
      uint64_t v16 = asString();
      *(_DWORD *)long long buf = 136315394;
      uint64_t v21 = v15;
      __int16 v22 = 2080;
      uint64_t v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Current state's command %s does not match with given %s", buf, 0x16u);
    }
  }
  else
  {
    uint64_t v11 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v21 = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not find state model when validating state: %s", buf, 0xCu);
    }
  }
  uint64_t v10 = 0;
LABEL_12:
  if (v19) {
    sub_10004D2C8(v19);
  }
  return v10;
}

void sub_100EDF014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t STK_Controller::getStateModel_sync@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 112);
  uint64_t result = a1 + 112;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = result;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v4;
    }
    else {
      uint64_t v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != result && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v11 = *(void *)(v6 + 40);
    uint64_t v10 = *(void *)(v6 + 48);
    *a3 = v11;
    a3[1] = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

void sub_100EDF0A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = std::__shared_weak_count::lock(v1);
    if (v2)
    {
      atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v2);
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t STK_Controller::getCurrentAccessTechnology_sync(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 208);
  uint64_t v2 = a1 + 208;
  uint64_t v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    int v6 = *(_DWORD *)(v3 + 28);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      BOOL v8 = (uint64_t *)v3;
    }
    else {
      BOOL v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 == v2) {
    return 0;
  }
  if (*(_DWORD *)(v5 + 28) > a2) {
    return 0;
  }
  uint64_t v9 = *(int *)(v5 + 32);
  if (v9 > 0xA) {
    return 0;
  }
  else {
    return dword_10158BB30[v9];
  }
}

void sub_100EDF1D4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_100EDF2E4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100EDF2EC(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unsigned int v5 = a3[4];
  uint64_t v6 = *(void *)(a1 + 88);
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(a1, v7);
  uint64_t v9 = *a3;
  uint64_t v10 = *((unsigned __int8 *)a3 + 4);
  uint64_t v11 = a3[2];
  uint64_t v12 = a3[3];
  if (v5 == -1)
  {
    uint64_t v17 = a3[5];
    uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 40);
    return v18(v6, STKSimSlotInfo_sync, v9, v10, v11, v12, v17);
  }
  else
  {
    uint64_t v13 = a3[4];
    uint64_t v14 = a3[5];
    uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 48);
    return v15(v6, STKSimSlotInfo_sync, v9, v10, v11, v12, v13, v14);
  }
}

uint64_t sub_100EDF3EC(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return sub_100EDF2EC(a1 - 56, a2, a3);
}

uint64_t sub_100EDF3F4(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 88);
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(a1, v8);
  uint64_t v10 = *a3;
  uint64_t v11 = *((unsigned __int8 *)a3 + 4);
  uint64_t v12 = a3[2];
  uint64_t v13 = a3[3];
  uint64_t v14 = a3[5];
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v7 + 64);

  return v15(v7, STKSimSlotInfo_sync, v10, v11, v12, v13, a4, v14);
}

uint64_t sub_100EDF4A8(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  return sub_100EDF3F4(a1 - 56, a2, a3, a4);
}

uint64_t sub_100EDF4B0(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(a1, v10);
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, uint64_t, uint64_t, unsigned int))(*(void *)v9 + 56))(v9, STKSimSlotInfo_sync, *a3, *((unsigned __int8 *)a3 + 4), a3[2], a3[3], a4, a5, a3[5]);
}

uint64_t sub_100EDF574(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  return sub_100EDF4B0(a1 - 56, a2, a3, a4, a5);
}

uint64_t sub_100EDF57C(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  char v9 = 0;
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(a1, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, void, char *, void, void, void, void, unsigned int))(*(void *)v5 + 160))(v5, STKSimSlotInfo_sync, 0, &v9, *a3, *((unsigned __int8 *)a3 + 4), a3[2], a3[3], a3[5]);
}

uint64_t sub_100EDF634(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return sub_100EDF57C(a1 - 56, a2, a3);
}

uint64_t sub_100EDF63C(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  char v10 = 0;
  BOOL v9 = a3[3] < 2;
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(a1, v6);
  return (*(uint64_t (**)(uint64_t, uint64_t, BOOL *, char *, void, void, void, void, unsigned int))(*(void *)v5 + 160))(v5, STKSimSlotInfo_sync, &v9, &v10, *a3, *((unsigned __int8 *)a3 + 4), a3[2], a3[3], a3[5]);
}

uint64_t sub_100EDF704(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return sub_100EDF63C(a1 - 56, a2, a3);
}

void *sub_100EDF70C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(void *(**)(void *__return_ptr))(**(void **)a2 + 56))(v12);
  if (v13)
  {
    SetupMenu::~SetupMenu((SetupMenu *)v12);
    uint64_t v9 = *(void *)(a1 + 88);
    uint64_t v10 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
    uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(a1, v10);
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 72))(v9, STKSimSlotInfo_sync, a3, a4);
  }
  return result;
}

void *sub_100EDF7F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100EDF70C(a1 - 56, a2, a3, a4);
}

BOOL sub_100EDF800(uint64_t a1)
{
  BOOL v2 = sub_100DD6BD8(78);
  if (!v2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Terminal is busy: No clients registered for STK notifications", v5, 2u);
    }
  }
  return !v2;
}

BOOL sub_100EDF878(uint64_t a1)
{
  return sub_100EDF800(a1 - 56);
}

void sub_100EDF884(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EDF8BC(uint64_t a1)
{
}

uint64_t sub_100EDF8D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100EDF91C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100EDF948(ServiceManager::Service *this)
{
  *(void *)this = off_101A6A668;
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100EDF9A4(ServiceManager::Service *this)
{
  *(void *)this = off_101A6A668;
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100EDFA14@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "STK_Controller");
}

unsigned char *sub_100EDFA24@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  BOOL v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100EDFA64(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    sub_100EDE940(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100EDE940(v4, 0);
}

uint64_t sub_100EDFAD8()
{
  return 0;
}

uint64_t sub_100EDFAE0()
{
  return 1;
}

uint64_t sub_100EDFAE8()
{
  return 0;
}

void sub_100EDFAF4(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_100EDFBD0(uint64_t result, int a2, ServiceStage *this)
{
  if (a2 == 3)
  {
    uint64_t v3 = *(void *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    v5[0] = 0;
    v5[1] = 0;
    sub_10003E168(v5, (void *)(v3 + 8));
    operator new();
  }
  return result;
}

void sub_100EDFCF0()
{
}

uint64_t sub_100EDFD04(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100EDFD10(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v2 || (v3 = *(void *)(v1 + 8), (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x30uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_101A6A728;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A6A7E0;
  v6[1].__shared_owners_ = v3;
  v6[1].__shared_weak_owners_ = (uint64_t)v5;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v5);
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A6A778;
  uint64_t v7 = dispatch_queue_create("com.apple.stk_handler", 0);
  Registry::getCommandDriversFactory((uint64_t *)&v36, *(Registry **)(v1 + 64));
  __int16 v40 = v6;
  dispatch_object_t object = v7;
  uint64_t v39 = v6 + 1;
  ((void (*)(long long *__return_ptr))(*v36)[7].__vftable)(&v46);
  long long v8 = v46;
  long long v46 = 0uLL;
  uint64_t v9 = *(std::__shared_weak_count **)(v1 + 96);
  *(_OWORD *)(v1 + 88) = v8;
  if (v9)
  {
    sub_10004D2C8(v9);
    if (*((void *)&v46 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v46 + 1));
    }
  }
  if (v40) {
    sub_10004D2C8(v40);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v37) {
    sub_10004D2C8(v37);
  }
  uint64_t v10 = *(NSObject **)(v1 + 24);
  if (v10) {
    dispatch_retain(*(dispatch_object_t *)(v1 + 24));
  }
  uint64_t v11 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v11 || (uint64_t v12 = *(void *)(v1 + 8), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v14 = v13;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  uint64_t v15 = std::__shared_weak_count::lock(v14);
  uint64_t v16 = v15;
  if (v15)
  {
    uint64_t v17 = v12 + 56;
    if (!v12) {
      uint64_t v17 = 0;
    }
    uint64_t v35 = v17;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v14);
    sub_10004D2C8(v16);
  }
  else
  {
    std::__shared_weak_count::__release_weak(v14);
    uint64_t v35 = 0;
  }
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  long long v36 = &v37;
  subscriber::makeSimSlotRange();
  uint64_t v18 = (unsigned int *)*((void *)&v46 + 1);
  __int16 v19 = (unsigned int *)v46;
  if ((void)v46 != *((void *)&v46 + 1))
  {
    os_log_t v20 = v47;
    do
    {
      if (v20(*v19)) {
        goto LABEL_26;
      }
      ++v19;
    }
    while (v19 != v18);
    __int16 v19 = v18;
LABEL_26:
    uint64_t v21 = (unsigned int *)*((void *)&v46 + 1);
    long long v34 = (unsigned int *)*((void *)&v46 + 1);
    while (v19 != v21)
    {
      uint64_t v22 = *v19;
      uint64_t v23 = *(void *)(v1 + 80);
      dispatch_object_t v44 = v10;
      if (v10) {
        dispatch_retain(v10);
      }
      uint64_t v42 = v35;
      uint64_t v43 = v16;
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v24 = v1;
      (*(void (**)(long long *__return_ptr, uint64_t, dispatch_object_t *, uint64_t, uint64_t *))(*(void *)v23 + 16))(&v45, v23, &v44, v22, &v42);
      int v25 = v37;
      __int16 v26 = &v37;
      uint64_t v27 = &v37;
      if (v37)
      {
        do
        {
          while (1)
          {
            uint64_t v27 = (std::__shared_weak_count **)v25;
            int shared_owners = v25[1].__shared_owners_;
            if (shared_owners <= (int)v22) {
              break;
            }
            int v25 = *v27;
            __int16 v26 = v27;
            if (!*v27) {
              goto LABEL_39;
            }
          }
          if (shared_owners >= (int)v22) {
            goto LABEL_42;
          }
          int v25 = v27[1];
        }
        while (v25);
        __int16 v26 = v27 + 1;
      }
LABEL_39:
      long long v29 = (char *)operator new(0x38uLL);
      *((_DWORD *)v29 + 8) = v22;
      *(_OWORD *)(v29 + 40) = v45;
      long long v45 = 0uLL;
      *(void *)long long v29 = 0;
      *((void *)v29 + 1) = 0;
      *((void *)v29 + 2) = v27;
      *__int16 v26 = (std::__shared_weak_count *)v29;
      if (*v36)
      {
        long long v36 = (std::__shared_weak_count **)*v36;
        long long v29 = (char *)*v26;
      }
      sub_100046C90((uint64_t *)v37, (uint64_t *)v29);
      ++v38;
LABEL_42:
      if (*((void *)&v45 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v45 + 1));
      }
      uint64_t v1 = v24;
      if (v43) {
        std::__shared_weak_count::__release_weak(v43);
      }
      if (v44) {
        dispatch_release(v44);
      }
      os_log_t v30 = v19 + 1;
      __int16 v19 = v18;
      if (v30 != v18)
      {
        __int16 v19 = v30;
        do
        {
          if (v20(*v19)) {
            goto LABEL_53;
          }
          ++v19;
        }
        while (v19 != v18);
        __int16 v19 = v18;
      }
LABEL_53:
      uint64_t v21 = v34;
    }
  }
  uint64_t v31 = v1 + 112;
  sub_100119D90(*(void **)(v1 + 112));
  uint64_t v32 = (uint64_t *)v37;
  *(void *)(v1 + 104) = v36;
  *(void *)(v1 + 112) = v32;
  uint64_t v33 = v38;
  *(void *)(v1 + 120) = v38;
  if (v33)
  {
    void v32[2] = v31;
    long long v36 = &v37;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v32 = 0;
  }
  else
  {
    *(void *)(v1 + 104) = v31;
  }
  sub_100119D90(v32);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (v10) {
    dispatch_release(v10);
  }
  operator delete();
}

void sub_100EE0168(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t object, uint64_t a20,std::__shared_weak_count *a21,dispatch_object_t a22,uint64_t a23,uint64_t a24)
{
  sub_100119D90(a15);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  if (v24) {
    dispatch_release(v24);
  }
  operator delete();
}

void sub_100EE0254(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6A728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EE0274(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6A728;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EE02C8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100EE02F0(STKCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A6A7E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  STKCommandDriverDelegateInterface::~STKCommandDriverDelegateInterface(this);
}

void sub_100EE034C(STKCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A6A7E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  STKCommandDriverDelegateInterface::~STKCommandDriverDelegateInterface(this);

  operator delete();
}

uint64_t sub_100EE03BC(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    int v12 = a2;
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    void v13[2] = sub_100EE3C90;
    void v13[3] = &unk_101A6ABB8;
    void v13[4] = v7 + 8;
    v13[5] = &v11;
    uint64_t v14 = v13;
    long long v8 = *(NSObject **)(v7 + 24);
    if (*(void *)(v7 + 32))
    {
      unsigned int v21 = 0;
      block = _NSConcreteStackBlock;
      uint64_t v16 = 0x40000000;
      uint64_t v17 = sub_100EE3CDC;
      uint64_t v18 = &unk_101A6ABF8;
      __int16 v19 = &v21;
      os_log_t v20 = &v14;
      dispatch_async_and_wait(v8, &block);
    }
    else
    {
      unsigned int v21 = 0;
      block = _NSConcreteStackBlock;
      uint64_t v16 = 0x40000000;
      uint64_t v17 = sub_100EE3CA0;
      uint64_t v18 = &unk_101A6ABD8;
      __int16 v19 = &v21;
      os_log_t v20 = &v14;
      dispatch_sync(v8, &block);
    }
    uint64_t v9 = v21;
  }
  else
  {
    uint64_t v9 = 0;
  }
  sub_10004D2C8(v6);
  return v9;
}

void sub_100EE053C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        sub_1000B1CE0((uint64_t)v10, a3);
        uint64_t v11 = v8;
        uint64_t v12 = a2;
        sub_1000B1CE0((uint64_t)&v13, (uint64_t)v10);
        v9[0] = 0;
        v9[1] = 0;
        sub_10003E168(v9, (void *)(v8 + 8));
        operator new();
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100EE11E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a2)
  {
    ModelBase::~ModelBase(v14);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EE1334(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100EE1474(STKCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A6A7E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  STKCommandDriverDelegateInterface::~STKCommandDriverDelegateInterface(this);
}

void sub_100EE14D0(STKCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A6A7E0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  STKCommandDriverDelegateInterface::~STKCommandDriverDelegateInterface(this);

  operator delete();
}

uint64_t sub_100EE1540(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100EE158C(void *a1)
{
  *a1 = off_101A6A838;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100EE15D8(void *a1)
{
  *a1 = off_101A6A838;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100EE1644(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100EE16F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100EE170C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100EE172C()
{
}

void *sub_100EE1798(void *a1)
{
  *a1 = off_101A6A888;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100EE17E4(void *a1)
{
  *a1 = off_101A6A888;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100EE1850()
{
}

void sub_100EE18C0()
{
}

void *sub_100EE18D4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A6A8C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100EE191C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6A8C8;
  a2[1] = v2;
  return result;
}

xpc_type_t sub_100EE1948(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(int **)(a1 + 8);
  xpc_type_t result = xpc_get_type(*a2);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int v8 = *v3;
    xpc_type_t result = (xpc_type_t)ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v8, (int *)a2, v5);
    int *v3 = v8;
  }
  else if (result == (xpc_type_t)&_xpc_type_BOOL {
         || result == (xpc_type_t)&_xpc_type_int64
  }
         || result == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_type_t result = (xpc_type_t)xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
    int *v3 = (int)result;
  }
  return result;
}

uint64_t sub_100EE19E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EE1A24()
{
}

void sub_100EE1A34()
{
}

__n128 sub_100EE1A48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6A948;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100EE1A9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6A948;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EE1AD4(void *a1)
{
  uint64_t v2 = (long long *)a1[1];
  long long v3 = *v2;
  uint64_t v9 = *((void *)v2 + 2);
  *(_OWORD *)int v8 = v3;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)uint64_t v2 = 0;
  long long v4 = *(long long *)((char *)v2 + 24);
  uint64_t v11 = *((void *)v2 + 5);
  *(_OWORD *)long long __p = v4;
  *((void *)v2 + 4) = 0;
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 3) = 0;
  read_rest_value();
  uint64_t v5 = (void (*)(void *, void **))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, void **))(*v7 + v5);
  }
  v5(v7, v8);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[0]);
  }
}

void sub_100EE1BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EE1BCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EE1C0C()
{
}

void sub_100EE1C1C()
{
}

__n128 sub_100EE1C30(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6A9C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100EE1C84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6A9C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EE1CBC(void *a1, xpc_object_t *a2)
{
  long long v3 = (void *)a1[1];
  long long v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    *long long v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100EE1D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100EE1D94(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EE1DD4()
{
}

void sub_100EE1DE4()
{
}

__n128 sub_100EE1DF8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6AA48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100EE1E4C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6AA48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EE1E84(void *a1, xpc_object_t *a2)
{
  long long v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_std::string::size_type size = &v3->__r_.__value_.__l.__size_;
  std::string::size_type size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v18 = (void **)v3->__r_.__value_.__r.__words[0];
  __int16 v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_std::string::size_type size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  uint64_t v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    uint64_t v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    uint64_t v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      int v8 = (void **)v6[1];
      uint64_t v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          uint64_t v6 = v8;
          int v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v6 = v9[2];
          BOOL v10 = *v6 == v9;
          uint64_t v9 = (void ***)v6;
        }
        while (!v10);
      }
      uint64_t v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v10);
      }
      uint64_t v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  int v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  uint64_t v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    int v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  uint64_t v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_100EE2048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100EE2090(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EE20D0()
{
}

void sub_100EE20E0()
{
}

__n128 sub_100EE20F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6AAC8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100EE2148(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6AAC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100EE2180(void *a1, xpc_object_t *a2)
{
  long long v3 = (void *)a1[1];
  uint64_t v5 = v3 + 1;
  long long v4 = (void *)v3[1];
  uint64_t v37 = (uint64_t *)*v3;
  uint64_t v38 = v4;
  if (v3[2])
  {
    void v4[2] = &v38;
    void *v3 = v5;
    void *v5 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v37 = (uint64_t *)&v38;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_10097EC08((uint64_t)v3, (void *)v3[1]);
  v3[1] = 0;
  void v3[2] = 0;
  void *v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v44, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    uint64_t v35 = (const char *)(v3 + 1);
    long long v36 = (uint64_t **)v3;
    sub_100048BF4(v43, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v45; ; uint64_t i = ++v45)
    {
      if (i == v43[1] && v44 == v43[0])
      {
        xpc_release(v44);
        xpc_release(v44);
        goto LABEL_86;
      }
      xpc_object_t v42 = 0;
      object[0] = &v44;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v42);
      if (xpc_get_type(v42) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_84:
      xpc_release(v42);
    }
    memset(v41, 0, sizeof(v41));
    *(_OWORD *)dispatch_object_t object = 0u;
    xpc_object_t v9 = v42;
    if (v42)
    {
      xpc_retain(v42);
      xpc_object_t v48 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v48 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
LABEL_30:
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v52 = &v48;
        uint64_t v53 = "first";
        sub_100048BAC((uint64_t)&v52, v51);
        read_rest_value();
        xpc_release(v51[0]);
        v46[0] = &v48;
        v46[1] = "second";
        sub_100048BAC((uint64_t)v46, &v47);
        xpc_object_t v11 = v47;
        if (v47 && xpc_get_type(v47) == (xpc_type_t)&_xpc_type_array) {
          xpc_retain(v11);
        }
        else {
          xpc_object_t v11 = xpc_null_create();
        }
        uint64_t v13 = *((void *)&v41[0] + 1);
        for (uint64_t j = *(void *)&v41[1]; j != v13; j -= 32)
        {
          if (*(char *)(j - 9) < 0) {
            operator delete(*(void **)(j - 32));
          }
        }
        *(void *)&v41[1] = v13;
        if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
        {
          v51[0] = v11;
          if (v11) {
            xpc_retain(v11);
          }
          else {
            v51[0] = xpc_null_create();
          }
          sub_100048BF4((void **)&v52, v51, 0);
          xpc_release(v51[0]);
          v50[0] = v11;
          if (v11) {
            xpc_retain(v11);
          }
          else {
            v50[0] = xpc_null_create();
          }
          if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array) {
            uint64_t v14 = (void *)xpc_array_get_count(v11);
          }
          else {
            uint64_t v14 = 0;
          }
          sub_100048BF4(v51, v50, v14);
          xpc_release(v50[0]);
          for (k = v53; k != v51[1] || v52 != v51[0]; k = ++v53)
          {
            v50[0] = &v52;
            v50[1] = (void *)k;
            uint64_t v16 = *(void *)&v41[1];
            if (*(void *)&v41[1] >= *((void *)&v41[1] + 1))
            {
              uint64_t v18 = (uint64_t)(*(void *)&v41[1] - *((void *)&v41[0] + 1)) >> 5;
              unint64_t v19 = v18 + 1;
              if ((unint64_t)(v18 + 1) >> 59) {
                sub_10006A748();
              }
              uint64_t v20 = *((void *)&v41[1] + 1) - *((void *)&v41[0] + 1);
              if ((uint64_t)(*((void *)&v41[1] + 1) - *((void *)&v41[0] + 1)) >> 4 > v19) {
                unint64_t v19 = v20 >> 4;
              }
              if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v21 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v21 = v19;
              }
              if (v21) {
                uint64_t v22 = (char *)sub_1000F5A68((uint64_t)&v41[1] + 8, v21);
              }
              else {
                uint64_t v22 = 0;
              }
              uint64_t v23 = &v22[32 * v18];
              *(_OWORD *)uint64_t v23 = 0u;
              *((_OWORD *)v23 + 1) = 0u;
              uint64_t v17 = v23 + 32;
              uint64_t v24 = (void **)*((void *)&v41[0] + 1);
              int v25 = *(void ***)&v41[1];
              if (*(void *)&v41[1] == *((void *)&v41[0] + 1))
              {
                *((void *)&v41[0] + 1) = v23;
                *(void *)&v41[1] = v23 + 32;
                *((void *)&v41[1] + 1) = &v22[32 * v21];
              }
              else
              {
                do
                {
                  long long v26 = *((_OWORD *)v25 - 2);
                  *((void *)v23 - 2) = *(v25 - 2);
                  *((_OWORD *)v23 - 2) = v26;
                  *(v25 - 3) = 0;
                  *(v25 - 2) = 0;
                  *(v25 - 4) = 0;
                  *((_DWORD *)v23 - 2) = *((_DWORD *)v25 - 2);
                  v23 -= 32;
                  v25 -= 4;
                }
                while (v25 != v24);
                int v25 = (void **)*((void *)&v41[0] + 1);
                uint64_t v27 = *(void ***)&v41[1];
                *((void *)&v41[0] + 1) = v23;
                *(void *)&v41[1] = v17;
                *((void *)&v41[1] + 1) = &v22[32 * v21];
                while (v27 != v25)
                {
                  if (*((char *)v27 - 9) < 0) {
                    operator delete(*(v27 - 4));
                  }
                  v27 -= 4;
                }
              }
              if (v25) {
                operator delete(v25);
              }
            }
            else
            {
              **(_OWORD **)&v41[1] = 0u;
              *(_OWORD *)(v16 + 16) = 0u;
              uint64_t v17 = (_OWORD *)(v16 + 32);
            }
            *(void *)&v41[1] = v17;
            sub_1000492E0((uint64_t)v50, &v49);
            sub_100591F00((uint64_t)(v17 - 2), &v49);
            xpc_release(v49);
          }
          xpc_release(v52);
          xpc_release(v52);
        }
        xpc_release(v11);
        xpc_release(v47);
        xpc_object_t v10 = v48;
      }
      xpc_release(v10);
      xpc_release(v9);
      v50[0] = 0;
      uint64_t v28 = (uint64_t **)sub_100046ED4((uint64_t)v36, v50, object);
      if (!*v28)
      {
        uint64_t v54 = 0;
        long long v29 = (char *)operator new(0x50uLL);
        uint64_t v52 = (xpc_object_t *)v29;
        uint64_t v53 = v35;
        LOBYTE(v54) = 0;
        os_log_t v30 = v29 + 32;
        if (SBYTE7(v41[0]) < 0)
        {
          sub_10004FC84(v30, object[0], (unint64_t)object[1]);
          uint64_t v31 = (uint64_t *)v52;
        }
        else
        {
          *(_OWORD *)os_log_t v30 = *(_OWORD *)object;
          *((void *)v29 + 6) = *(void *)&v41[0];
          uint64_t v31 = (uint64_t *)v29;
        }
        *(_OWORD *)(v29 + 56) = *(_OWORD *)((char *)v41 + 8);
        *((void *)v29 + 9) = *((void *)&v41[1] + 1);
        memset((char *)v41 + 8, 0, 24);
        LOBYTE(v54) = 1;
        sub_100046C38(v36, (uint64_t)v50[0], v28, v31);
        uint64_t v52 = 0;
        sub_10098CAD4((uint64_t)&v52, 0);
      }
      uint64_t v52 = (xpc_object_t *)v41 + 1;
      sub_1000D82FC(&v52);
      if (SBYTE7(v41[0]) < 0) {
        operator delete(object[0]);
      }
      goto LABEL_84;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v48 = v10;
    goto LABEL_30;
  }
LABEL_86:
  xpc_release(v6);
  uint64_t v32 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v33 = a1[4];
  long long v34 = (void *)(a1[2] + (v33 >> 1));
  if (v33) {
    uint64_t v32 = *(void (**)(void *, uint64_t **))(*v34 + v32);
  }
  v32(v34, &v37);
  sub_10097EC08((uint64_t)&v37, v38);
}

void sub_100EE282C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15, uint64_t a16, xpc_object_t object, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,xpc_object_t a27,uint64_t a28,xpc_object_t a29,uint64_t a30,uint64_t a31,uint64_t a32,xpc_object_t a33)
{
  dispatch_object_t object = 0;
  xpc_release(a29);
  xpc_release(a10);
  sub_10097EC08((uint64_t)&a14, a15);
  _Unwind_Resume(a1);
}

uint64_t sub_100EE29DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EE2A1C()
{
}

void sub_100EE2A2C()
{
}

void *sub_100EE2A40(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A6AB48;
  result[1] = v3;
  return result;
}

uint64_t sub_100EE2A88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6AB48;
  a2[1] = v2;
  return result;
}

void sub_100EE2AB4(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100EE2ABC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100EE2AFC()
{
}

uint64_t *sub_100EE2B08(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v15 = a1;
  uint64_t v16 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = v2[11];
  if (v4)
  {
    uint64_t v5 = v1[1];
    *(void *)long long buf = v5;
    if (v5)
    {
      dispatch_retain(v5);
      if (*(void *)buf) {
        dispatch_group_enter(*(dispatch_group_t *)buf);
      }
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
    if (*(void *)buf)
    {
      dispatch_group_leave(*(dispatch_group_t *)buf);
      if (*(void *)buf) {
        dispatch_release(*(dispatch_object_t *)buf);
      }
    }
  }
  xpc_object_t v6 = (void *)v2[13];
  if (v6 != v2 + 14)
  {
    do
    {
      uint64_t v7 = v6[5];
      int v8 = v1[1];
      dispatch_group_t group = v8;
      if (v8)
      {
        dispatch_retain(v8);
        if (group) {
          dispatch_group_enter(group);
        }
      }
      (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v7 + 24))(v7, &group);
      if (group)
      {
        dispatch_group_leave(group);
        if (group) {
          dispatch_release(group);
        }
      }
      xpc_object_t v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          xpc_object_t v10 = v9;
          xpc_object_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          xpc_object_t v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          xpc_object_t v6 = v10;
        }
        while (!v11);
      }
      xpc_object_t v6 = v10;
    }
    while (v10 != v2 + 14);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 16));
  uint64_t v12 = (atomic_uint **)(v2 + 37);
  for (uint64_t i = v2[38]; (atomic_uint **)i != v12; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84(v12);
  sub_100088C88((uint64_t *)&v16);
  return sub_100046B58((uint64_t *)&v15);
}

void sub_100EE2CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t a12, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100EE2D34(void *a1)
{
  uint64_t v1 = (uint64_t *)*a1;
  uint64_t v7 = a1;
  int v8 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  aBlock[6] = 0;
  xpc_object_t v10 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100EE1540;
  aBlock[3] = &unk_101A6A808;
  aBlock[4] = v2 + 8;
  aBlock[5] = sub_100EDDD74;
  xpc_object_t v10 = _Block_copy(aBlock);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      xpc_object_t v6 = v5;
      sub_100981A64(v11, &v10, *(dispatch_object_t *)(v2 + 24));
      sub_100981AAC(&buf, v11);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100EE33F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,dispatch_group_t group,uint64_t a29)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_100EE3564(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 88);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 80) + 24))(buf);
  long long v4 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 328);
  *(_OWORD *)(v1 + 320) = v4;
  if (v5)
  {
    sub_10004D2C8(v5);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  (*(void (**)(void))(**(void **)(v1 + 320) + 16))(*(void *)(v1 + 320));
  uint64_t v6 = *(void *)(v1 + 320);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 24))(v6, v1 + 176);
  }
  operator delete();
}

void sub_100EE36CC()
{
}

void sub_100EE36F8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  STK_Controller::getStateModel_sync(a1, a2, &v13);
  uint64_t v7 = v13;
  if (v13)
  {
    int v8 = *(_DWORD *)(a3 + 8);
    if (v8 == 8 || v8 == 1)
    {
      xpc_object_t v10 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        uint64_t v16 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I SIM state has changed to %s, resetting state", buf, 0xCu);
      }
      (*(void (**)(uint64_t))(*(void *)v7 + 144))(v7);
    }
  }
  else
  {
    uint64_t v12 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not find state model when evaluating SIM state", buf, 2u);
    }
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
}

void sub_100EE387C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EE3898(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  unint64_t v3 = sub_100EDEA88(v2, (*a1)[1]);
  int v4 = *((_DWORD *)v1 + 4);
  int v5 = *((unsigned __int8 *)v1 + 20);
  if (v4 == 2)
  {
    uint64_t v13 = (NSObject **)(*(uint64_t (**)(void, unint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    *(_OWORD *)long long buf = 0uLL;
    STK_Controller::getStateModel_sync(v2, v3, buf);
    uint64_t v14 = *(void *)buf;
    uint64_t v15 = *v13;
    uint64_t v16 = *v13;
    if (*(void *)buf)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = "failed";
        if (v5) {
          uint64_t v17 = "succeeded";
        }
        *(_DWORD *)uint64_t v22 = 136315138;
        uint64_t v23 = v17;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Terminal Response sent to baseband %s", v22, 0xCu);
      }
      goto LABEL_21;
    }
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
LABEL_31:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
LABEL_33:
      operator delete();
    }
    *(_WORD *)uint64_t v22 = 0;
    unint64_t v21 = "Could not find state model upon terminal response completion";
  }
  else
  {
    if (v4 != 1)
    {
      if (!v4)
      {
        uint64_t v6 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = "not ready";
          if (v5) {
            uint64_t v7 = "ready";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Command Driver is %s resetting the state machine", buf, 0xCu);
        }
        int v8 = *(void **)(v2 + 104);
        xpc_object_t v9 = (void *)(v2 + 112);
        if (v8 != v9)
        {
          do
          {
            (*(void (**)(void))(*(void *)v8[5] + 144))(v8[5]);
            xpc_object_t v10 = (void *)v8[1];
            if (v10)
            {
              do
              {
                uint64_t v11 = v10;
                xpc_object_t v10 = (void *)*v10;
              }
              while (v10);
            }
            else
            {
              do
              {
                uint64_t v11 = (void *)v8[2];
                BOOL v12 = *v11 == (void)v8;
                int v8 = v11;
              }
              while (!v12);
            }
            int v8 = v11;
          }
          while (v11 != v9);
        }
      }
      goto LABEL_33;
    }
    uint64_t v18 = (NSObject **)(*(uint64_t (**)(void, unint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
    *(_OWORD *)long long buf = 0uLL;
    STK_Controller::getStateModel_sync(v2, v3, buf);
    uint64_t v14 = *(void *)buf;
    uint64_t v15 = *v18;
    unint64_t v19 = *v18;
    if (*(void *)buf)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = "failed";
        if (v5) {
          uint64_t v20 = "succeeded";
        }
        *(_DWORD *)uint64_t v22 = 136315138;
        uint64_t v23 = v20;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Event Confirmation sent to baseband %s", v22, 0xCu);
      }
LABEL_21:
      (*(void (**)(uint64_t, BOOL))(*(void *)v14 + 128))(v14, v5 != 0);
      goto LABEL_31;
    }
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    *(_WORD *)uint64_t v22 = 0;
    unint64_t v21 = "Could not find state model upon event confirmation completion";
  }
  _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v21, v22, 2u);
  goto LABEL_31;
}

void sub_100EE3C48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  operator delete();
}

unint64_t sub_100EE3C90(uint64_t a1)
{
  return sub_100EDEA88(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_100EE3CA0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100EE3CDC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

__n128 sub_100EE3D18(__n128 *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 8);
  a1[1].n128_u16[0] = *(_WORD *)(a2 + 16);
  a1->n128_u64[1] = v4;
  int v5 = &a1[1].n128_i8[8];
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *((void *)v5 + 2) = *(void *)(a2 + 40);
    *(_OWORD *)int v5 = v6;
  }
  __n128 result = *(__n128 *)(a2 + 48);
  a1[4].n128_u64[0] = *(void *)(a2 + 64);
  a1[3] = result;
  return result;
}

void sub_100EE3DB8(_Unwind_Exception *a1)
{
  ModelBase::~ModelBase(v1);
  _Unwind_Resume(a1);
}

__n128 sub_100EE3DCC(__n128 *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 8);
  a1[1].n128_u16[0] = *(_WORD *)(a2 + 16);
  a1->n128_u64[1] = v4;
  int v5 = &a1[1].n128_i8[8];
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *((void *)v5 + 2) = *(void *)(a2 + 40);
    *(_OWORD *)int v5 = v6;
  }
  __n128 result = *(__n128 *)(a2 + 48);
  a1[3] = result;
  return result;
}

void sub_100EE3E64(_Unwind_Exception *a1)
{
  ModelBase::~ModelBase(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100EE3E78(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  long long v6 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 48) = v6;
  __n128 result = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  long long v8 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)__n128 result = v8;
  return result;
}

void sub_100EE3F54(_Unwind_Exception *a1)
{
  if (v1[47] < 0) {
    operator delete(*v2);
  }
  ModelBase::~ModelBase((ModelBase *)v1);
  _Unwind_Resume(a1);
}

__n128 sub_100EE3F80(__n128 *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 8);
  a1[1].n128_u16[0] = *(_WORD *)(a2 + 16);
  a1->n128_u64[1] = v4;
  long long v5 = &a1[1].n128_i8[8];
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *((void *)v5 + 2) = *(void *)(a2 + 40);
    *(_OWORD *)long long v5 = v6;
  }
  __n128 result = *(__n128 *)(a2 + 48);
  a1[3] = result;
  return result;
}

void sub_100EE4018(_Unwind_Exception *a1)
{
  ModelBase::~ModelBase(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100EE402C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  __n128 result = (unsigned char *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  long long v7 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)__n128 result = v7;
  return result;
}

void sub_100EE40F8(_Unwind_Exception *a1)
{
  if (v1[47] < 0) {
    operator delete(*v2);
  }
  ModelBase::~ModelBase((ModelBase *)v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100EE4124(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  uint64_t v5 = *(void *)(a2 + 20);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 20) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1000972F4((void *)(a1 + 32), *(void *)(a2 + 32), *(void *)(a2 + 40), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  __n128 result = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)__n128 result = v7;
  }
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  return result;
}

void sub_100EE4208(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100097460((void ***)va);
  ModelBase::~ModelBase(v2);
  _Unwind_Resume(a1);
}

unsigned char *sub_100EE4230(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  uint64_t v5 = *(void *)(a2 + 20);
  int v6 = *(_DWORD *)(a2 + 28);
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = v6;
  *(void *)(a1 + 20) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1000972F4((void *)(a1 + 32), *(void *)(a2 + 32), *(void *)(a2 + 40), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  __n128 result = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)__n128 result = v8;
  }
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  return result;
}

void sub_100EE431C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100097460((void ***)va);
  ModelBase::~ModelBase(v2);
  _Unwind_Resume(a1);
}

void *sub_100EE4344(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v2;
  __n128 result = (void *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  long long v4 = *(_OWORD *)(a2 + 24);
  result[2] = *(void *)(a2 + 40);
  *(_OWORD *)__n128 result = v4;
  return result;
}

void sub_100EE43D4(_Unwind_Exception *a1)
{
  ModelBase::~ModelBase(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100EE43E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v4;
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  __n128 result = (unsigned char *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  long long v7 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)__n128 result = v7;
  return result;
}

void sub_100EE44B4(_Unwind_Exception *a1)
{
  if (v1[47] < 0) {
    operator delete(*v2);
  }
  ModelBase::~ModelBase((ModelBase *)v1);
  _Unwind_Resume(a1);
}

void *sub_100EE44E0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  __n128 result = (void *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  long long v4 = *(_OWORD *)(a2 + 24);
  result[2] = *(void *)(a2 + 40);
  *(_OWORD *)__n128 result = v4;
  return result;
}

void sub_100EE457C(_Unwind_Exception *a1)
{
  ModelBase::~ModelBase(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EE4590(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  unint64_t v3 = sub_100EDEA88(*(void *)v1, *(void *)(v1 + 8));
  sub_1000B1CE0((uint64_t)v15, v1 + 16);
  char v4 = 0;
  switch(v15[0] ^ (v15[0] >> 31))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 0x17:
      break;
    case 4:
      char v4 = 0;
      break;
    case 5:
      char v4 = 0;
      break;
    case 6:
      char v4 = 0;
      break;
    case 7:
      char v4 = 0;
      break;
    case 8:
      char v4 = 0;
      break;
    case 9:
      char v4 = 0;
      break;
    case 0xA:
      char v4 = 0;
      break;
    case 0xB:
      char v4 = 0;
      break;
    case 0xC:
      char v4 = 0;
      break;
    case 0xD:
      char v4 = 0;
      break;
    case 0xE:
      char v4 = 0;
      break;
    case 0xF:
      char v4 = 0;
      break;
    case 0x10:
      char v4 = 0;
      break;
    case 0x11:
      char v4 = 0;
      break;
    case 0x12:
      char v4 = 1;
      break;
    case 0x13:
      char v4 = 0;
      break;
    case 0x14:
      char v4 = 0;
      break;
    case 0x15:
      char v4 = 0;
      break;
    case 0x16:
      char v4 = 0;
      break;
    case 0x18:
      char v4 = 0;
      break;
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
      char v4 = 0;
      break;
    default:
      sub_1000971B8();
  }
  long long v5 = (NSObject **)(*(uint64_t (**)(void, unint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  STK_Controller::getStateModel_sync(v2, v3, &v13);
  uint64_t v6 = v13;
  long long v7 = *v5;
  if (v13)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      *(_DWORD *)long long buf = 136315138;
      uint64_t v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received a Proactive Command: %s event from SIM", buf, 0xCu);
    }
    (*(void (**)(uint64_t, _DWORD *))(*(void *)v6 + 40))(v6, v15);
    if (v4) {
      sub_100EDF0A8(v2);
    }
  }
  else if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = asString();
    *(_DWORD *)long long buf = 136315138;
    uint64_t v17 = v10;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find state model upon receipt of proactive command: %s", buf, 0xCu);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_1000A3DCC(v15);
  sub_100EE4964(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100EE48A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, std::__shared_weak_count *);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_1000A3DCC((int *)va2);
  sub_100EE4964((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100EE4964(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1000A3DCC((_DWORD *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t *sub_100EE49B4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100EE4A08(uint64_t a1)
{
  uint64_t v26 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void *)a1;
    char v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(uint64_t **)(a1 + 16);
      if (!v6)
      {
LABEL_41:
        sub_10004D2C8(v5);
        return sub_100EE49B4(&v26);
      }
      uint64_t v41 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v3 + 64));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v9;
      uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
LABEL_12:
          (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v15 + 96))(__p, v15, *(unsigned int *)(a1 + 8), 1, @"SendCurrentLanguageToSTK", kCFBooleanFalse, 0);
          sub_1000057AC(&v41, (CFTypeRef *)__p);
          sub_1000577C4((const void **)__p);
          if ((v16 & 1) == 0) {
            sub_10004D2C8(v14);
          }
          buf[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, v41, v17);
          if (buf[0])
          {
            uint64_t v18 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I SIM requires current language to be sent, hence pushing it", buf, 2u);
            }
            if (sub_100DD6BD8(78))
            {
              unint64_t v19 = (char *)(v3 + 152);
              if (*(char *)(v3 + 175) < 0) {
                unint64_t v19 = *(char **)v19;
              }
              sub_100058DB0(buf, v19);
              (*(void (**)(uint64_t, uint8_t *))(*(void *)v3 + 120))(v3, buf);
              if (SHIBYTE(v29) < 0) {
                operator delete(*(void **)buf);
              }
            }
            else
            {
              global_queue = dispatch_get_global_queue(0, 0);
              unint64_t v21 = global_queue;
              if (global_queue) {
                dispatch_retain(global_queue);
              }
              Registry::getTimerService(&v39, *(Registry **)(v3 + 64));
              uint64_t v22 = v39;
              sub_100058DB0(__p, "STK_Controller");
              dispatch_object_t object = v21;
              if (v21) {
                dispatch_retain(v21);
              }
              *(void *)long long buf = _NSConcreteStackBlock;
              uint64_t v28 = 1174405120;
              long long v29 = sub_100EE4E50;
              os_log_t v30 = &unk_101A6AC18;
              uint64_t v24 = *(void *)(a1 + 16);
              uint64_t v23 = *(std::__shared_weak_count **)(a1 + 24);
              uint64_t v31 = v3;
              uint64_t v32 = v24;
              uint64_t v33 = v23;
              if (v23) {
                atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              }
              int v34 = *(_DWORD *)(a1 + 8);
              aBlock = _Block_copy(buf);
              sub_10027A2C0(v22, (uint64_t)__p, 0, 5000000, &object, &aBlock);
              if (aBlock) {
                _Block_release(aBlock);
              }
              if (object) {
                dispatch_release(object);
              }
              if (v38 < 0) {
                operator delete(__p[0]);
              }
              if (v40) {
                sub_10004D2C8(v40);
              }
              if (v33) {
                std::__shared_weak_count::__release_weak(v33);
              }
              if (v21) {
                dispatch_release(v21);
              }
            }
          }
          sub_100062778((const void **)&v41);
          goto LABEL_41;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
      goto LABEL_12;
    }
  }
  return sub_100EE49B4(&v26);
}

void sub_100EE4D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,void *aBlock,dispatch_object_t object,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a29 < 0) {
    operator delete(__p);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(v31 - 80);
  if (v33) {
    sub_10004D2C8(v33);
  }
  if (v30) {
    dispatch_release(v30);
  }
  sub_100062778((const void **)(v31 - 72));
  sub_10004D2C8(v29);
  sub_100EE49B4(&a10);
  _Unwind_Resume(a1);
}

void sub_100EE4E50(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    char v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40)) {
        sub_100EDF0A8(v3, *(unsigned int *)(a1 + 56));
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100EE4EC8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EE4EDC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EE4EF8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t *sub_100EE4F08(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  uint64_t v4 = *(unsigned int *)(v1 + 24);
  uint64_t v5 = *(unsigned int *)(v1 + 28);
  if (*(char *)(*(void *)v1 + 175) < 0)
  {
    sub_10004FC84(__p, *(void **)(v2 + 152), *(void *)(v2 + 160));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(v2 + 152);
    uint64_t v10 = *(void *)(v2 + 168);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v3 + 112))(v3, v4, v5, __p);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  sub_100EE4FF4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100EE4FC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t *sub_100EE4FF4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_100EE5048()
{
}

void sub_100EE50F8()
{
}

void *sub_100EE5148(void *a1, void *a2, void *a3)
{
  *a1 = off_101AB3B60;
  uint64_t v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, "euicc.attest");
  uint64_t v7 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  uint64_t v8 = dispatch_queue_create("CellularPlanAttestation", v7);
  *uint64_t v6 = 0;
  v6[1] = 0;
  a1[3] = v8;
  if (v8)
  {
    uint64_t v9 = v8;
    dispatch_retain(v8);
    a1[4] = 0;
    dispatch_release(v9);
  }
  else
  {
    a1[4] = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v16, &v15);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v16);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v16);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  *a1 = off_101A6AC58;
  a1[6] = *a2;
  uint64_t v10 = a2[1];
  a1[7] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  a1[8] = *a3;
  uint64_t v11 = a3[1];
  a1[9] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = a1[3];
  uint64_t v13 = operator new(0x70uLL);
  v13[1] = 0;
  void v13[2] = 0;
  *uint64_t v13 = off_101A6AE08;
  a1[10] = sub_100635D4C((uint64_t)(v13 + 3), a2, v12);
  a1[11] = v13;
  return a1;
}

void sub_100EE52D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  uint64_t v18 = *(std::__shared_weak_count **)(v13 + 72);
  if (v18) {
    sub_10004D2C8(v18);
  }
  unint64_t v19 = *(std::__shared_weak_count **)(v13 + 56);
  if (v19) {
    sub_10004D2C8(v19);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  sub_100087E88(v12);
  _Unwind_Resume(a1);
}

void *sub_100EE5350(void *a1)
{
  *a1 = off_101A6AC58;
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100EE53CC(void *a1)
{
  sub_100EE5350(a1);

  operator delete();
}

void *sub_100EE5404(void *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3321888768;
  v20[2] = sub_100EE55B4;
  v20[3] = &unk_101A6AC90;
  v20[4] = a1;
  char v22 = a4;
  sub_10033ECA0((uint64_t)v21, a5);
  uint64_t v23 = a2;
  uint64_t v24 = a3;
  uint64_t v8 = v20;
  uint64_t v9 = (std::__shared_weak_count *)a1[2];
  if (!v9 || (v10 = a1[1], (uint64_t v11 = std::__shared_weak_count::lock(v9)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v12 = v11;
  uint64_t v13 = a1[3];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3321888768;
  v16[2] = sub_100EE6BAC;
  v16[3] = &unk_101A6AE50;
  uint64_t v18 = v10;
  unint64_t v19 = v11;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v14 = v8;
  id v17 = v14;
  dispatch_async(v13, v16);

  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_10004D2C8(v12);

  return sub_1000DBADC(v21);
}

void sub_100EE55A8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100EE55B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 72)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I euicc ticket requested - userRequest : %s", (uint8_t *)&buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 72) || (*(unsigned int (**)(uint64_t))(*(void *)v2 + 48))(v2))
  {
    uint64_t v5 = *(void *)(a1 + 73);
    uint64_t v6 = *(void *)(a1 + 81);
    sub_10033ECA0((uint64_t)v23, a1 + 40);
    sub_1002D0C14(*(unsigned __int8 *)(a1 + 72), &object);
    CFTypeRef cf = 0;
    char v22 = 0;
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &v22;
    CFTypeRef cf = SecAccessControlCreateWithFlags(0, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate, 0x40000000uLL, (CFErrorRef *)&buf);
    sub_100128064((const void **)&buf);
    if (cf) {
      uint64_t v7 = sub_100126088;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7)
    {
      sub_1002D01C0();
      SecAccessControlSetConstraints();
      CFTypeRef v20 = cf;
      if (cf) {
        CFRetain(cf);
      }
      uint64_t v33 = (uint64_t (**)())kMAOptionsBAANetworkTimeoutInterval;
      int v34 = (_OWORD *)kMAOptionsBAAValidity;
      *(void *)&long long buf = &off_101AE64D8;
      *((void *)&buf + 1) = &off_101AE64F0;
      uint64_t v35 = kMAOptionsBAASCRTAttestation;
      long long v36 = (uint64_t (***)())kMAOptionsResuseExistingKey;
      int v25 = (void (*)(uint64_t, int, const void **, const void *, void *, void *))&__kCFBooleanFalse;
      uint64_t v26 = &__kCFBooleanTrue;
      uint64_t v37 = kMAOptionsBAADeleteDuplicateKeychainItems;
      uint64_t v27 = &__kCFBooleanTrue;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:&buf forKeys:&v33 count:5];
      uint64_t v9 = +[NSMutableDictionary dictionaryWithDictionary:v8];

      id v10 = objc_alloc((Class)NSMutableArray);
      v32[0] = (dispatch_object_t)kMAOptionsBAAOIDUCRTDeviceIdentifiers;
      v32[1] = (dispatch_object_t)kMAOptionsBAAOIDDeviceIdentifiers;
      void v32[2] = (dispatch_object_t)kMAOptionsBAAOIDHardwareProperties;
      v32[3] = (dispatch_object_t)kMAOptionsBAAOIDKeyUsageProperties;
      v32[4] = (dispatch_object_t)kMAOptionsBAAOIDDeviceOSInformation;
      uint64_t v11 = +[NSArray arrayWithObjects:v32 count:5];
      id v12 = [v10 initWithArray:v11];

      uint64_t v13 = kMAOptionsBAAOIDSToInclude;
      [v9 setObject:v12 forKeyedSubscript:kMAOptionsBAAOIDSToInclude];
      uint64_t v14 = [v9 objectForKeyedSubscript:v13];
      [v14 addObject:kMAOptionsBAAOIDAccessControls];

      [v9 setObject:v20 forKeyedSubscript:kMAOptionsBAAAccessControls];
      [v9 setObject:@"euicc" forKeyedSubscript:kMAOptionsBAAKeychainLabel];
      [v9 setObject:@"com.apple.coretelephony" forKeyedSubscript:kMAOptionsBAAKeychainAccessGroup];

      sub_100127DA8(&v20);
      if (v9)
      {
        uint64_t v15 = *(void *)(v2 + 64);
        char v16 = *(NSObject **)(v2 + 24);
        v32[0] = v16;
        if (v16) {
          dispatch_retain(v16);
        }
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3321888768;
        int v25 = sub_100EE650C;
        uint64_t v26 = &unk_101A6ACC0;
        uint64_t v27 = (void *)v2;
        uint64_t v30 = v5;
        uint64_t v31 = v6;
        sub_10033ECA0((uint64_t)v28, (uint64_t)v23);
        xpc_object_t v29 = object;
        if (object) {
          xpc_retain(object);
        }
        else {
          xpc_object_t v29 = xpc_null_create();
        }
        long long v36 = 0;
        uint64_t v33 = off_101A5FCC0;
        int v34 = objc_retainBlock(&buf);
        long long v36 = &v33;
        (*(void (**)(uint64_t, void *, dispatch_object_t *, uint64_t (***)()))(*(void *)v15 + 16))(v15, v9, v32, &v33);
        sub_100613154(&v33);
        if (v32[0]) {
          dispatch_release(v32[0]);
        }
        xpc_release(v29);
        xpc_object_t v29 = 0;
        sub_1000DBADC(v28);
      }
      else
      {
        uint64_t v18 = *(NSObject **)(v2 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "create options for BAA cert generation failed", (uint8_t *)&buf, 2u);
        }
        sub_100058DB0(&buf, "Options Failure");
        sub_1002D14EC((Registry **)(v2 + 48), &object, (const char *)&buf);
        if (SHIBYTE(v25) < 0) {
          operator delete((void *)buf);
        }
        uint64_t v33 = 0;
        int v34 = 0;
        uint64_t v35 = 0;
        sub_10033F214((uint64_t)v23, 0);
        if (SHIBYTE(v35) < 0) {
          operator delete(v33);
        }
      }
    }
    else
    {
      id v17 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "create access control failed", (uint8_t *)&buf, 2u);
      }
      sub_100058DB0(&buf, "ACL Failure");
      sub_1002D14EC((Registry **)(v2 + 48), &object, (const char *)&buf);
      if (SHIBYTE(v25) < 0) {
        operator delete((void *)buf);
      }
      uint64_t v33 = 0;
      int v34 = 0;
      uint64_t v35 = 0;
      sub_10033F214((uint64_t)v23, 0);
      if (SHIBYTE(v35) < 0) {
        operator delete(v33);
      }
    }
    sub_100127DA8(&cf);
    sub_100127D74(&v22);
    xpc_release(object);
    xpc_object_t object = 0;
    sub_1000DBADC(v23);
  }
  else
  {
    sub_10033F214(a1 + 40, 0);
  }
}

void sub_100EE5BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, xpc_object_t object, char a17, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,xpc_object_t a45)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100EE5D5C(uint64_t a1)
{
  CFDateRef v25 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)at = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)at);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      int v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
LABEL_13:
      uint64_t v13 = kCommCenterPreferencesNoBackupAppID;
      (*(void (**)(uint64_t, void, const CFStringRef, const CFStringRef))(*(void *)v10 + 48))(v10, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      uint64_t v26 = 0;
      (*(void (**)(unsigned char *__return_ptr, uint64_t, const __CFString *, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v10 + 40))(at, v10, @"kEuiccTicketPrefetchTimestamp", v13, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      sub_1000842D0(&v26, (CFTypeRef *)at);
      sub_1000577C4((const void **)at);
      if (v26) {
        uint64_t v15 = sub_100081E58;
      }
      else {
        uint64_t v15 = 0;
      }
      if (v15)
      {
        *(void *)at = 0;
        ctu::cf::assign((ctu::cf *)at, v26, v14);
        CFDateRef v16 = CFDateCreate(kCFAllocatorDefault, *(CFAbsoluteTime *)at);
        CFDateRef v25 = v16;
        id v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)at = 138412290;
          *(void *)&at[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I euicc ticket prefetch timestamp [%@] for attestation", at, 0xCu);
        }
      }
      else
      {
        uint64_t v18 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)at = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Empty euicc ticket prefetch timestamp", at, 2u);
        }
        CFDateRef v25 = 0;
      }
      sub_1000570E8((const void **)&v26);
      if (v11)
      {
LABEL_24:
        CFDateRef v19 = v25;
        if (v19) {
          goto LABEL_28;
        }
        goto LABEL_25;
      }
LABEL_23:
      sub_10004D2C8(v9);
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  int v11 = 1;
  if (v10) {
    goto LABEL_13;
  }
LABEL_7:
  id v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)at = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Cannot create preferences", at, 2u);
  }
  CFDateRef v25 = 0;
  if (!v11) {
    goto LABEL_23;
  }
LABEL_25:
  CFTypeRef v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)at = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Generate new euicc ticket prefetch timestamp", at, 2u);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  CFDateRef v19 = (const __CFDate *)objc_claimAutoreleasedReturnValue();
LABEL_28:
  unint64_t v21 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)at = 138412290;
    *(void *)&at[4] = v19;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I euicc ticket fetch timestamp : %@", at, 0xCu);
  }
  char v22 = +[NSDate date];
  BOOL v23 = [(__CFDate *)v19 compare:v22] == (id)-1;

  sub_10007CA64((const void **)&v25);
  return v23;
}

void sub_100EE6154(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

CFDateRef sub_100EE61CC(uint64_t a1)
{
  uint64_t v2 = +[NSDate date];
  sub_1002D00C8(v2);
  CFDateRef v3 = (const __CFDate *)(id)objc_claimAutoreleasedReturnValue();
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  id v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_7:
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Cannot create preferences", buf, 2u);
    }
    goto LABEL_16;
  }
LABEL_11:
  CFNumberRef v23 = 0;
  *(void *)long long buf = CFDateGetAbsoluteTime(v3);
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, buf);
  if (v16)
  {
    CFNumberRef v17 = v23;
    CFNumberRef v23 = v16;
    *(void *)long long buf = v17;
    sub_1000570E8((const void **)buf);
  }
  CFNumberRef v18 = v23;
  CFNumberRef v22 = v23;
  CFNumberRef v23 = 0;
  sub_1000570E8((const void **)&v23);
  uint64_t v19 = kCommCenterPreferencesNoBackupAppID;
  (*(void (**)(uint64_t, const __CFString *, CFNumberRef, void, const CFStringRef, const CFStringRef))(*(void *)v13 + 16))(v13, @"kEuiccTicketPrefetchTimestamp", v18, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFTypeRef v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I saved euicc ticket prefetch timestamp [%@] for attestation", buf, 0xCu);
  }
  (*(void (**)(uint64_t, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v13 + 48))(v13, v19, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1000570E8((const void **)&v22);
LABEL_16:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }

  return v3;
}

void sub_100EE64A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_100EE650C(uint64_t a1, int a2, const void **a3, const void *a4, void *a5, void *a6)
{
  id v11 = a5;
  id v12 = a6;
  uint64_t v13 = *(void *)(a1 + 32);
  CFNumberRef v22 = a4;
  char v14 = *(NSObject **)(v13 + 40);
  if (a2)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *a3;
      *(_DWORD *)long long buf = 138412546;
      CFDateRef v25 = v15;
      __int16 v26 = 2112;
      uint64_t v27 = a4;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I BAA Cert :%@ - ref key : %@", buf, 0x16u);
    }
    uint64_t v16 = *(void *)(v13 + 80);
    sub_10002FD9C(&v21, a3);
    sub_10033ECA0((uint64_t)v23, a1 + 40);
    CFNumberRef v17 = *(void **)(a1 + 72);
    xpc_object_t object = v17;
    if (v17) {
      xpc_retain(v17);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, uint64_t, const void **, const void **, void *, xpc_object_t *))(*(void *)v16 + 16))(v16, a1 + 80, &v21, &v22, v23, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    sub_1000DBADC(v23);
    sub_100030068(&v21);
  }
  else
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Getting device identity framework failed", buf, 2u);
    }
    sub_100058DB0(__p, "Cert Failure");
    sub_1002D14EC((Registry **)(v13 + 48), (xpc_object_t *)(a1 + 72), (const char *)__p);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    sub_10033F214(a1 + 40, 0);
  }
  sub_100127DDC(&v22);
}

void sub_100EE6730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t object,char a23,int a24,__int16 a25,char a26,char a27,int a28,__int16 a29,char a30,char a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

xpc_object_t sub_100EE67C4(uint64_t a1, uint64_t a2)
{
  sub_10033ECA0(a1 + 40, a2 + 40);
  uint64_t v4 = *(void **)(a2 + 72);
  *(void *)(a1 + 72) = v4;
  if (v4) {
    return xpc_retain(v4);
  }
  xpc_object_t result = xpc_null_create();
  *(void *)(a1 + 72) = result;
  return result;
}

void *sub_100EE6814(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 72));
  *(void *)(a1 + 72) = 0;

  return sub_1000DBADC((void *)(a1 + 40));
}

void sub_100EE6858(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100EE6938(uint64_t a1, uint64_t a2)
{
  return sub_1002CFF28(a2);
}

void sub_100EE6940(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EE6A0C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100EE6AE4);
  __cxa_rethrow();
}

void sub_100EE6A34(_Unwind_Exception *a1)
{
}

void sub_100EE6A4C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100EE6A84(uint64_t a1)
{
}

uint64_t sub_100EE6AA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100EE6AE4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100EE6B10(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6AE08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100EE6B30(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6AE08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100EE6B84(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100EE6BAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100EE6BBC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EE6BD8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100EE6BE8(void *a1)
{
  uint64_t v2 = a1;
  if (*a1) {
    operator delete();
  }
  return sub_100046B58((uint64_t *)&v2);
}

double sub_100EE6C2C@<D0>(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  sub_1005291BC((capabilities::ct *)(a1 + 8), a2, &v5);
  double result = *(double *)&v5;
  *a3 = v5;
  return result;
}

void sub_100EE6C68(uint64_t a1@<X0>, int a2@<W1>, long long *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_100944764((Registry **)(a1 + 8), a2, &v10);
  uint64_t v6 = v10;
  long long v7 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  uint64_t v8 = *(std::__shared_weak_count **)(v6 + 176);
  *(_OWORD *)(v6 + 168) = v7;
  if (v8)
  {
    std::__shared_weak_count::__release_weak(v8);
    uint64_t v6 = v10;
  }
  uint64_t v9 = v11;
  *a4 = v6;
  a4[1] = v9;
}

double sub_100EE6CCC@<D0>(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  sub_100580F7C((capabilities::ct *)(a1 + 8), a2, &v5);
  double result = *(double *)&v5;
  *a3 = v5;
  return result;
}

void sub_100EE6D08(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_1010EAC5C();
}

void sub_100EE6D78(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EE6D90(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if (!a3) {
    return;
  }
  uint64_t v9 = a1 + 8;
  LODWORD(v67) = a2;
  uint64_t v64 = 0;
  std::string::size_type v65 = 0;
  sub_100B0DD40(a1 + 8, (int *)&v67, &v64);
  LODWORD(v67) = 1;
  sub_100EE7448((uint64_t)v62, a5, (int *)&v67, &v64);
  if (v63) {
    sub_10004D2C8(v63);
  }
  LODWORD(v67) = 2;
  sub_100EE7448((uint64_t)v60, a5, (int *)&v67, &v64);
  if (v61) {
    sub_10004D2C8(v61);
  }
  LODWORD(v67) = a2;
  long long v59 = 0uLL;
  sub_100C48D74(v9, (int *)&v67, &v59);
  unint64_t v10 = a5[2];
  unint64_t v11 = a5[1];
  if (v11 >= v10)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *a5) >> 3);
    unint64_t v15 = v14 + 1;
    if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *a5) >> 3);
    if (2 * v16 > v15) {
      unint64_t v15 = 2 * v16;
    }
    if (v16 >= 0x555555555555555) {
      unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v17 = v15;
    }
    long long v71 = a5 + 2;
    CFNumberRef v18 = (char *)sub_100601864(v17);
    char v19 = &v18[24 * v14];
    std::string::size_type v67 = v18;
    size_t v68 = v19;
    BOOL v70 = &v18[24 * v20];
    long long v21 = v59;
    long long v59 = 0uLL;
    *(_DWORD *)char v19 = 3;
    *(_OWORD *)(v19 + 8) = v21;
    uint64_t v69 = v19 + 24;
    sub_100EE767C(a5, &v67);
    uint64_t v13 = a5[1];
    sub_100EE76E0((uint64_t)&v67);
  }
  else
  {
    long long v12 = v59;
    long long v59 = 0uLL;
    *(_DWORD *)unint64_t v11 = 3;
    *(_OWORD *)(v11 + 8) = v12;
    uint64_t v13 = v11 + 24;
  }
  a5[1] = v13;
  CFNumberRef v22 = *(std::__shared_weak_count **)(v13 - 8);
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
  }
  if (*((void *)&v59 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v59 + 1));
  }
  CFNumberRef v23 = "sig.mav5.?";
  int v66 = a2;
  if (a2 == 2) {
    CFNumberRef v23 = "sig.mav5.2";
  }
  if (a2 == 1) {
    CFNumberRef v23 = "sig.mav5.1";
  }
  std::string::size_type v67 = v23;
  long long v59 = 0uLL;
  sub_100D7453C(v9, &v66, &v67, &v59);
  unint64_t v24 = a5[1];
  unint64_t v25 = a5[2];
  if (v24 >= v25)
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - *a5) >> 3);
    unint64_t v29 = v28 + 1;
    if (v28 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - *a5) >> 3);
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x555555555555555) {
      unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v31 = v29;
    }
    long long v71 = a5 + 2;
    uint64_t v32 = (char *)sub_100601864(v31);
    uint64_t v33 = &v32[24 * v28];
    std::string::size_type v67 = v32;
    size_t v68 = v33;
    BOOL v70 = &v32[24 * v34];
    long long v35 = v59;
    long long v59 = 0uLL;
    *(_DWORD *)uint64_t v33 = 4;
    *(_OWORD *)(v33 + 8) = v35;
    uint64_t v69 = v33 + 24;
    sub_100EE767C(a5, &v67);
    uint64_t v27 = a5[1];
    sub_100EE76E0((uint64_t)&v67);
  }
  else
  {
    long long v26 = v59;
    long long v59 = 0uLL;
    *(_DWORD *)unint64_t v24 = 4;
    *(_OWORD *)(v24 + 8) = v26;
    uint64_t v27 = v24 + 24;
  }
  a5[1] = v27;
  long long v36 = *(std::__shared_weak_count **)(v27 - 8);
  if (v36)
  {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v36);
  }
  uint64_t v37 = (capabilities::ct *)*((void *)&v59 + 1);
  if (*((void *)&v59 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v59 + 1));
  }
  if (a3 != 1)
  {
    if (a3 == 2) {
      sub_101352594(&v59);
    }
    if (a3 != 3 || !capabilities::ct::supportsCapabilityTDSCDMADevice(v37)) {
      goto LABEL_62;
    }
    LODWORD(v67) = a2;
    long long v59 = 0uLL;
    sub_100D748A4(v9, (int *)&v67, &v59);
    unint64_t v38 = a5[1];
    unint64_t v39 = a5[2];
    if (v38 >= v39)
    {
      unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - *a5) >> 3);
      unint64_t v41 = v40 + 1;
      if (v40 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_10006A748();
      }
      unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - *a5) >> 3);
      if (2 * v42 > v41) {
        unint64_t v41 = 2 * v42;
      }
      if (v42 >= 0x555555555555555) {
        unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v43 = v41;
      }
LABEL_57:
      long long v71 = a5 + 2;
      uint64_t v49 = (char *)sub_100601864(v43);
      int v50 = &v49[24 * v40];
      std::string::size_type v67 = v49;
      size_t v68 = v50;
      BOOL v70 = &v49[24 * v51];
      long long v52 = v59;
      long long v59 = 0uLL;
      *(_DWORD *)int v50 = 5;
      *(_OWORD *)(v50 + 8) = v52;
      uint64_t v69 = v50 + 24;
      sub_100EE767C(a5, &v67);
      uint64_t v46 = a5[1];
      sub_100EE76E0((uint64_t)&v67);
      goto LABEL_58;
    }
    goto LABEL_50;
  }
  if (capabilities::ct::supportsCapabilityTDSCDMADevice(v37))
  {
    LODWORD(v67) = a2;
    long long v59 = 0uLL;
    sub_100D746C8(v9, (int *)&v67, &v59);
    unint64_t v38 = a5[1];
    unint64_t v44 = a5[2];
    if (v38 >= v44)
    {
      unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - *a5) >> 3);
      unint64_t v47 = v40 + 1;
      if (v40 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_10006A748();
      }
      unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v44 - *a5) >> 3);
      if (2 * v48 > v47) {
        unint64_t v47 = 2 * v48;
      }
      if (v48 >= 0x555555555555555) {
        unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v43 = v47;
      }
      goto LABEL_57;
    }
LABEL_50:
    long long v45 = v59;
    long long v59 = 0uLL;
    *(_DWORD *)unint64_t v38 = 5;
    *(_OWORD *)(v38 + 8) = v45;
    uint64_t v46 = v38 + 24;
LABEL_58:
    a5[1] = v46;
    uint64_t v53 = *(std::__shared_weak_count **)(v46 - 8);
    if (v53)
    {
      atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v53);
    }
    if (*((void *)&v59 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v59 + 1));
    }
  }
LABEL_62:
  uint64_t v54 = *a5;
  uint64_t v55 = a5[1];
  if (*a5 != v55)
  {
    do
    {
      if (*(_DWORD *)v54) {
        BOOL v56 = 0;
      }
      else {
        BOOL v56 = *(void *)(v54 + 8) == 0;
      }
      if (!v56)
      {
        std::string::size_type v57 = *(std::__shared_weak_count **)(a4 + 8);
        uint64_t v58 = v57;
        if (v57) {
          atomic_fetch_add_explicit(&v57->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        SignalStrengthModel::setDelegate();
        if (v58) {
          std::__shared_weak_count::__release_weak(v58);
        }
      }
      v54 += 24;
    }
    while (v54 != v55);
  }
  if (v65) {
    sub_10004D2C8(v65);
  }
}

void sub_100EE73C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  sub_100AC22E0((void ***)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_100EE7448(uint64_t result, uint64_t *a2, int *a3, uint64_t *a4)
{
  uint64_t v7 = result;
  unint64_t v8 = a2[2];
  unint64_t v9 = a2[1];
  if (v9 >= v8)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *a2) >> 3);
    unint64_t v15 = v14 + 1;
    if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *a2) >> 3);
    if (2 * v16 > v15) {
      unint64_t v15 = 2 * v16;
    }
    if (v16 >= 0x555555555555555) {
      unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v17 = v15;
    }
    v25[4] = a2 + 2;
    if (v17) {
      unint64_t v17 = (unint64_t)sub_100601864(v17);
    }
    else {
      uint64_t v18 = 0;
    }
    char v19 = (_DWORD *)(v17 + 24 * v14);
    v25[0] = v17;
    v25[1] = v19;
    v25[3] = v17 + 24 * v18;
    int v20 = *a3;
    uint64_t v22 = *a4;
    uint64_t v21 = a4[1];
    if (v21) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
    }
    *char v19 = v20;
    unint64_t v23 = v17 + 24 * v14;
    *(void *)(v23 + 8) = v22;
    *(void *)(v23 + 16) = v21;
    v25[2] = v19 + 6;
    sub_100EE767C(a2, v25);
    uint64_t v13 = a2[1];
    double result = sub_100EE76E0((uint64_t)v25);
  }
  else
  {
    int v10 = *a3;
    uint64_t v11 = *a4;
    uint64_t v12 = a4[1];
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
    *(_DWORD *)unint64_t v9 = v10;
    uint64_t v13 = v9 + 24;
    *(void *)(v9 + 8) = v11;
    *(void *)(v9 + 16) = v12;
  }
  a2[1] = v13;
  *(_DWORD *)uint64_t v7 = *(_DWORD *)(v13 - 24);
  uint64_t v24 = *(void *)(v13 - 8);
  *(void *)(v7 + 8) = *(void *)(v13 - 16);
  *(void *)(v7 + 16) = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EE75B0(SignalStrengthFactoryInterface *this)
{
  *(void *)this = off_101A6AE90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  SignalStrengthFactoryInterface::~SignalStrengthFactoryInterface(this);
}

void sub_100EE760C(SignalStrengthFactoryInterface *this)
{
  *(void *)this = off_101A6AE90;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  SignalStrengthFactoryInterface::~SignalStrengthFactoryInterface(this);

  operator delete();
}

uint64_t *sub_100EE767C(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    int v5 = *(_DWORD *)(v2 - 24);
    v2 -= 24;
    *(_DWORD *)(v4 - 24) = v5;
    v4 -= 24;
    *(_OWORD *)(v4 + 8) = *(_OWORD *)(v2 + 8);
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  a2[1] = v4;
  uint64_t v6 = *result;
  *double result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100EE76E0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 24;
    uint64_t v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      sub_10004D2C8(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100EE7740(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100EE77C0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EE77FC(uint64_t a1)
{
}

void sub_100EE7890(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "tm.mgr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v12, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v12);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A6AEF0;
  *(void *)(a1 + 32) = off_101A6AF48;
  *(void *)(a1 + 40) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 48) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 56) = *a3;
  uint64_t v9 = a3[1];
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = a4;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 109) = 0;
  *(_DWORD *)(a1 + 120) = -1;
  __p.var0 = 0;
  __p.var1.fRef = 0;
  uint64_t v11 = 0;
  sub_100CE7A28((void *)(a1 + 128));
}

void sub_100EE7A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (__p) {
    operator delete(__p);
  }
  unint64_t v15 = (std::__shared_weak_count *)v12[13];
  if (v15) {
    sub_10004D2C8(v15);
  }
  unint64_t v16 = (std::__shared_weak_count *)v12[11];
  if (v16) {
    sub_10004D2C8(v16);
  }
  unint64_t v17 = (std::__shared_weak_count *)v12[8];
  if (v17) {
    sub_10004D2C8(v17);
  }
  uint64_t v18 = (std::__shared_weak_count *)v12[6];
  if (v18) {
    sub_10004D2C8(v18);
  }
  char v19 = (std::__shared_weak_count *)v12[3];
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  ctu::OsLogLogger::~OsLogLogger(v13);
  _Unwind_Resume(a1);
}

void *sub_100EE7A88(void *a1)
{
  uint64_t v4 = a1[17];
  uint64_t v2 = a1 + 17;
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  int v5 = (std::__shared_weak_count *)a1[13];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[11];
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[8];
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)a1[6];
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[3];
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void *sub_100EE7B04(uint64_t a1)
{
  return sub_100EE7A88((void *)(a1 - 32));
}

void sub_100EE7B0C(void *a1)
{
  sub_100EE7A88(a1);

  operator delete();
}

void sub_100EE7B44(uint64_t a1)
{
  sub_100EE7A88((void *)(a1 - 32));

  operator delete();
}

void sub_100EE7B80(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), a2, a3, a5);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 96) + 104))(*(void *)(a1 + 96), a2);

  sub_100EE7C20(a1, a4);
}

void sub_100EE7C20(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 113) != a2)
  {
    BOOL v2 = a2;
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
      uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 113));
      int v7 = 136315906;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      int v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%shasWiFiCall %s => %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(a1 + 113) = v2;
    sub_100EE7E38(a1);
  }
}

void sub_100EE7D2C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 112) != a2)
  {
    BOOL v2 = a2;
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
      uint64_t v6 = asStringBool(*(unsigned char *)(a1 + 112));
      int v7 = 136315906;
      uint64_t v8 = v5;
      __int16 v9 = 2080;
      int v10 = " ";
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      __int16 v13 = 2080;
      uint64_t v14 = asStringBool(v2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%shandleImsRegistrationStateChanged: isOnIWLanOverCellular %s => %s", (uint8_t *)&v7, 0x2Au);
    }
    *(unsigned char *)(a1 + 112) = v2;
    sub_100EE7E38(a1);
  }
}

void sub_100EE7E38(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 113) && *(unsigned char *)(a1 + 112))
  {
    if (!*(unsigned char *)(a1 + 114))
    {
      *(unsigned char *)(a1 + 114) = 1;
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), *(void *)(a1 + 56) + 24);
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80)) == 2)
    {
      BOOL v2 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
        int v5 = 136315394;
        uint64_t v6 = v3;
        __int16 v7 = 2080;
        uint64_t v8 = " ";
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sWe have been out of service for an extended period of time", (uint8_t *)&v5, 0x16u);
      }
      if (!*(unsigned char *)(a1 + 115))
      {
        *(unsigned char *)(a1 + 115) = 1;
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 56))(*(void *)(a1 + 72), a1 + 56);
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 115))
    {
      *(unsigned char *)(a1 + 115) = 0;
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 64))(*(void *)(a1 + 72), a1 + 56);
    }
    if (*(unsigned char *)(a1 + 114))
    {
      *(unsigned char *)(a1 + 114) = 0;
      uint64_t v4 = *(void (**)(void))(**(void **)(a1 + 72) + 48);
      v4();
    }
  }
}

uint64_t sub_100EE8058(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 32))();
}

uint64_t sub_100EE8080(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32))();
}

uint64_t *sub_100EE80A8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return Registry::getTimerService(a2, *(Registry **)(a1 + 40));
}

uint64_t *sub_100EE80B0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return Registry::getTimerService(a2, *(Registry **)(a1 + 8));
}

uint64_t sub_100EE80B8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))();
}

uint64_t sub_100EE80E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))();
}

uint64_t sub_100EE8108(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 24))();
}

uint64_t sub_100EE8130(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 24))();
}

uint64_t sub_100EE8158(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 96) + 88))(*(void *)(a1 + 96));
  BOOL v2 = *(uint64_t (**)(void))(**(void **)(a1 + 72) + 16);

  return v2();
}

uint64_t sub_100EE81D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v22 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 40));
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v23 = v9;
  __int16 v13 = sub_10004D37C(&v8[1].__m_.__sig, &v23);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, uint64_t, void, void))(*(void *)v15 + 96))(&v21, v15, *(unsigned int *)(*(void *)(a1 + 56) + 52), 1, a2, 0, 0);
  sub_1000842D0(&v22, &v21);
  sub_1000577C4(&v21);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (v22) {
    uint64_t v18 = sub_100081E58;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18
    && (LODWORD(v23) = 0, ctu::cf::assign((ctu::cf *)&v23, v22, v17), uint64_t v19 = v23, v23 < 4))
  {
    sub_1000570E8((const void **)&v22);
    return v19;
  }
  else
  {
    sub_1000570E8((const void **)&v22);
  }
  return a3;
}

void sub_100EE8370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100EE83AC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_100EE81D4(a1, @"MinRequiredInternetQualityIfPreferredDataSim", 1, a2);
}

uint64_t sub_100EE83BC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_100EE81D4(a1, @"MinRequiredInternetQualityIfNotDataPreferredSim", 2, a2);
}

BOOL sub_100EE83CC(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = a1 + 128;
  int v5 = sub_10025B63C(a1 + 128, 0);
  if (v5 != a2)
  {
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
      int v8 = sub_10025B63C(v4, 0);
      unint64_t v9 = "kDisabled";
      if (v8 == 1) {
        int v10 = "kEnabled";
      }
      else {
        int v10 = "kDisabled";
      }
      int v12 = 136315906;
      uint64_t v13 = v7;
      if (v8 == 2) {
        int v10 = "kUnknown";
      }
      __int16 v14 = 2080;
      uint64_t v15 = " ";
      __int16 v16 = 2080;
      CFNumberRef v17 = v10;
      if (a2) {
        unint64_t v9 = "kEnabled";
      }
      __int16 v18 = 2080;
      uint64_t v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sDynamicCellularDataSwitch %s==>%s", (uint8_t *)&v12, 0x2Au);
    }
    sub_10025CAD8(v4, a2);
  }
  return v5 != a2;
}

void sub_100EE8518(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(*(PersonalityInfo **)(a1 + 56));
    int v4 = 136315394;
    uint64_t v5 = v3;
    __int16 v6 = 2080;
    uint64_t v7 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sDetermined that there is low chance to come back in service", (uint8_t *)&v4, 0x16u);
  }
  if (*(unsigned char *)(a1 + 114))
  {
    if (!*(unsigned char *)(a1 + 115))
    {
      *(unsigned char *)(a1 + 115) = 1;
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 72) + 56))(*(void *)(a1 + 72), a1 + 56);
    }
  }
}

BOOL sub_100EE8614(uint64_t a1)
{
  uint64_t v2 = kIWLANSettingsKey;
  uint64_t v3 = kWifiCallingAllowedInRoamingKey;
  int v4 = (uint64_t *)operator new(0x10uLL);
  uint64_t v22 = v4 + 2;
  unint64_t v23 = v4 + 2;
  *int v4 = v2;
  v4[1] = v3;
  OsLogContext __p = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4 + 2, *(Registry **)(a1 + 40));
  __int16 v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v24 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v24);
  if (v11)
  {
    uint64_t v13 = v11[3];
    int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  int v12 = 0;
  char v14 = 1;
LABEL_9:
  int v15 = 1;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, void **, const CFBooleanRef, void))(*(void *)v13 + 104))(&cf, v13, *(unsigned int *)(*(void *)(a1 + 56) + 52), 1, &__p, kCFBooleanTrue, 0);
  __int16 v16 = (BOOL *)cf;
  LOBYTE(v24) = 1;
  if (cf)
  {
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v24, v16, v18);
      int v15 = v24;
    }
    else
    {
      int v15 = 1;
    }
  }
  sub_1000577C4(&cf);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (__p)
  {
    uint64_t v22 = __p;
    operator delete(__p);
  }
  return v15 != 0;
}

void sub_100EE87CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100EE8814(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)operator new(0x18uLL);
  uint64_t v19 = v2 + 3;
  int v20 = v2 + 3;
  *(_OWORD *)uint64_t v2 = *(_OWORD *)off_101A6AF78;
  void v2[2] = @"NoFallbackVoiceService";
  OsLogContext __p = v2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2 + 3, *(Registry **)(a1 + 40));
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    __int16 v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v21 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v21);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, void **, const CFBooleanRef, void))(*(void *)v11 + 104))(&cf, v11, *(unsigned int *)(*(void *)(a1 + 56) + 52), 1, &__p, kCFBooleanFalse, 0);
  char v13 = (BOOL *)cf;
  LOBYTE(v21) = 0;
  if (cf)
  {
    CFTypeID v14 = CFGetTypeID(cf);
    if (v14 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v21, v13, v15);
      LODWORD(v13) = v21;
    }
    else
    {
      LODWORD(v13) = 0;
    }
  }
  sub_1000577C4(&cf);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (__p)
  {
    uint64_t v19 = __p;
    operator delete(__p);
  }
  return v13 != 0;
}

void sub_100EE89C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EE8A0C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100EE8A98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100EE8B78((void **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100EE8AB4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100EE8AEC(uint64_t a1)
{
  double result = *(void **)(a1 + 24);
  if (result)
  {
    sub_100EE7A88(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100EE8B34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_100EE8B78(void **a1, void *a2)
{
  double result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100EE7A88(result);
    operator delete();
  }
  return result;
}

void sub_100EE8BC8(uint64_t a1, const char *a2)
{
  long long v44 = 0uLL;
  int64_t v45 = 0;
  memset(&v69, 0, sizeof(v69));
  time_t v51 = time(0);
  localtime_r(&v51, &v69);
  uint64_t v67 = 0;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  memset(v54, 0, sizeof(v54));
  memset(v53, 0, sizeof(v53));
  sub_10004DE24((uint64_t)v53);
  *(void *)&v53[*(void *)(*(void *)v53 - 24) + 24] = 4;
  char v50 = 48;
  sub_1004DC904(v53, &v50);
  int v4 = (void *)std::ostream::operator<<();
  char v52 = 45;
  unint64_t v5 = sub_10004B96C(v4, (uint64_t)&v52, 1);
  *(void *)((char *)v5 + *(void *)(*v5 - 24) + 24) = 2;
  char v49 = 48;
  sub_1004DC904(v5, &v49);
  __int16 v6 = (void *)std::ostream::operator<<();
  char v52 = 45;
  uint64_t v7 = sub_10004B96C(v6, (uint64_t)&v52, 1);
  *(void *)((char *)v7 + *(void *)(*v7 - 24) + 24) = 2;
  char v48 = 48;
  sub_1004DC904(v7, &v48);
  unsigned int v8 = (void *)std::ostream::operator<<();
  char v52 = 45;
  uint64_t v9 = sub_10004B96C(v8, (uint64_t)&v52, 1);
  *(void *)((char *)v9 + *(void *)(*v9 - 24) + 24) = 2;
  char v47 = 48;
  sub_1004DC904(v9, &v47);
  unsigned int v10 = (void *)std::ostream::operator<<();
  char v52 = 45;
  uint64_t v11 = sub_10004B96C(v10, (uint64_t)&v52, 1);
  *(void *)((char *)v11 + *(void *)(*v11 - 24) + 24) = 2;
  char v46 = 48;
  sub_1004DC904(v11, &v46);
  char v12 = (void *)std::ostream::operator<<();
  char v52 = 45;
  char v13 = sub_10004B96C(v12, (uint64_t)&v52, 1);
  *(void *)((char *)v13 + *(void *)(*v13 - 24) + 24) = 2;
  char v52 = 48;
  sub_1004DC904(v13, &v52);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)&v53[8], &v38);
  if (SHIBYTE(v56) < 0) {
    operator delete(*((void **)&v55 + 1));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  int v14 = *(char *)(a1 + 31);
  if (v14 >= 0) {
    CFBooleanRef v15 = (const std::string::value_type *)(a1 + 8);
  }
  else {
    CFBooleanRef v15 = *(const std::string::value_type **)(a1 + 8);
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    std::string::size_type v16 = *(void *)(a1 + 16);
  }
  CFTypeID v17 = std::string::insert(&v38, 0, v15, v16);
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v39.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v39, "_", 1uLL);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  std::to_string((std::string *)v53, *(unsigned __int16 *)(a1 + 32));
  if (v53[23] >= 0) {
    unint64_t v21 = v53;
  }
  else {
    unint64_t v21 = *(const std::string::value_type **)v53;
  }
  if (v53[23] >= 0) {
    std::string::size_type v22 = v53[23];
  }
  else {
    std::string::size_type v22 = *(void *)&v53[8];
  }
  unint64_t v23 = std::string::append(&v40, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  unint64_t v25 = std::string::append(&v41, "_", 1uLL);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  size_t v27 = strlen(a2);
  unint64_t v28 = std::string::append(&v42, a2, v27);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  unint64_t v30 = std::string::append(&v43, ".bin", 4uLL);
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  int64_t v45 = v30->__r_.__value_.__r.__words[2];
  long long v44 = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if ((v53[23] & 0x80000000) != 0) {
    operator delete(*(void **)v53);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  ++*(_WORD *)(a1 + 32);
  uid_t v32 = sub_1003F2870();
  gid_t v33 = sub_1003F28A8();
  sub_1003F28E0("/var/wireless/Library/Logs/vinylscratch/", v32, v33, 0x1EDu);
  bzero(&v53[8], 0x230uLL);
  *(void *)&v53[*(void *)(*(void *)v53 - 24)] = v34;
  long long v35 = (std::ios_base *)&v53[*(void *)(*(void *)v53 - 24)];
  std::ios_base::init(v35, &v53[8]);
  v35[1].__vftable = 0;
  v35[1].__fmtflags_ = -1;
  std::filebuf::basic_filebuf();
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)&v53[*(void *)(*(void *)v53 - 24)], *(_DWORD *)((char *)v54 + *(void *)(*(void *)v53 - 24)) | 4);
  }
  if (*(_DWORD *)((char *)v54 + *(void *)(*(void *)v53 - 24)))
  {
    long long v36 = **(NSObject ***)a1;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      uint64_t v37 = &v44;
      if (v45 < 0) {
        uint64_t v37 = (long long *)v44;
      }
      v69.tm_sec = 136315138;
      *(void *)&v69.tm_min = v37;
      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Unable to open log file for writing: %s", (uint8_t *)&v69, 0xCu);
    }
  }
  else
  {
    std::ostream::write();
    std::ostream::flush();
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)&v53[*(void *)(*(void *)v53 - 24)], *(_DWORD *)((char *)v54 + *(void *)(*(void *)v53 - 24)) | 4);
    }
  }
  std::filebuf::~filebuf();
  std::ostream::~ostream();
  std::ios::~ios();
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)v44);
  }
}

void sub_100EE9428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100EE97A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100EE99FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EE9B24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EE9C34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EE9C48(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EE9CC0;
  v4[3] = &unk_101A6B0B0;
  uint64_t v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EE9CC0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EE9DB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EE9E0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EE9E84;
  double v5[3] = &unk_101A6B100;
  uint64_t v3 = *(void **)(a1 + 32);
  void v5[5] = *(void *)(a1 + 40);
  void v5[6] = a2;
  v5[4] = a3;
  return [v3 notifyClient:v5];
}

uint64_t sub_100EE9E84(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[6], a1[4]);
}

uint64_t sub_100EE9F7C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EE9F90(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEA008;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEA008(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EEA100(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EEA114(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEA18C;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEA18C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EEA2B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEA304(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEA378;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEA378(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEA4B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEA504(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEA578;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEA578(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEA67C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEA6CC(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEA740;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEA740(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEA84C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEA89C(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEA910;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEA910(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEAA8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEAAE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEAB5C;
  void v6[3] = &unk_101A6B1A0;
  void v6[4] = v3;
  void v6[5] = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[6] = a3;
  v6[7] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEAB5C(uint64_t a1)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 40) count];
    uint64_t v4 = *(void **)(a1 + 48);
    *(_DWORD *)long long buf = 134218242;
    unint64_t v14 = (unint64_t)v3;
    __int16 v15 = 2112;
    id v16 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "response for planItemsWithCompletion: %lu plans, error: %@", buf, 0x16u);
  }
  if ([*(id *)(a1 + 40) count])
  {
    unint64_t v6 = 0;
    *(void *)&long long v5 = 134218242;
    long long v12 = v5;
    do
    {
      uint64_t v7 = *(NSObject **)(*(void *)(a1 + 32) + 32);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        id v8 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "objectAtIndexedSubscript:", v6), "customDescription");
        *(_DWORD *)long long buf = v12;
        unint64_t v14 = v6;
        __int16 v15 = 2112;
        id v16 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[%lu]:  %@", buf, 0x16u);
      }
      if (objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "objectAtIndexedSubscript:", v6, v12), "plan"))
      {
        uint64_t v9 = *(NSObject **)(*(void *)(a1 + 32) + 32);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          id v10 = objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "objectAtIndexedSubscript:", v6), "plan");
          *(_DWORD *)long long buf = v12;
          unint64_t v14 = v6;
          __int16 v15 = 2112;
          id v16 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[%lu]:         %@", buf, 0x16u);
        }
      }
      ++v6;
    }
    while (v6 < (unint64_t)[*(id *)(a1 + 40) count]);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_100EEAEBC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  id v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEAF10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEAF8C;
  void v6[3] = &unk_101A6B1A0;
  void v6[4] = v3;
  void v6[5] = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[6] = a3;
  v6[7] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEAF8C(uint64_t a1)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 40) count];
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v7 = 134218498;
    id v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "response for danglingPlanItemsShouldUpdate, %lu plans: %@, error: %@", (uint8_t *)&v7, 0x20u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_100EEB1C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  id v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEB21C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEB298;
  void v6[3] = &unk_101A6B1A0;
  void v6[4] = v3;
  void v6[5] = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[6] = a3;
  v6[7] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEB298(uint64_t a1)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 40) count];
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v7 = 134218498;
    id v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "response for getPlansPendingTransferWithCompletion, %lu plans: %@, error: %@", (uint8_t *)&v7, 0x20u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_100EEB4D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  id v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEB528(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEB5A4;
  void v6[3] = &unk_101A6B1A0;
  void v6[4] = v3;
  void v6[5] = a2;
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[6] = a3;
  v6[7] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEB5A4(uint64_t a1)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 40) count];
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    int v7 = 134218498;
    id v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "response for getPlansPendingTransferForTestabilityWithCompletion, %lu plans: %@, error: %@", (uint8_t *)&v7, 0x20u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_100EEB768(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  id v3 = *(uint64_t (**)(uint64_t, void, void, void, id))(v1 + 16);

  return v3(v1, 0, 0, 0, v2);
}

id sub_100EEB7C4(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  xpc_object_t v8[2] = sub_100EEB840;
  v8[3] = &unk_101A6B1F0;
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  char v9 = a2;
  v8[4] = a3;
  v8[5] = a4;
  void v8[6] = a5;
  v8[7] = v6;
  return [v5 notifyClient:v8];
}

uint64_t sub_100EEB840(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned __int8 *)(a1 + 64), *(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48));
}

uint64_t sub_100EEB920(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  id v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

uint64_t sub_100EEBA60(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  id v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEBAB0(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEBB24;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEBB24(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEBC28(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEBC78(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEBCEC;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEBCEC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEBDF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEBE48(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEBEBC;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEBEBC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEBFC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEC014(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEC08C;
  void v6[3] = &unk_101A6B240;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[5] = a3;
  void v6[6] = v4;
  void v6[4] = a2;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEC08C(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

uint64_t sub_100EEC1AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEC200(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEC278;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEC278(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEC388(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEC3DC(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEC454;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEC454(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEC55C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEC5B0(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEC628;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEC628(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEC738(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEC78C(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEC804;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEC804(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEC90C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEC960(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEC9D8;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEC9D8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EECAE0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EECB34(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EECBAC;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EECBAC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EECCB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EECD04(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EECD78;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EECD78(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EECEE0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EECF34(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EECFAC;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EECFAC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EED0A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EED0F8(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EED170;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EED170(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EED4A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EED4B4(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EED52C;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EED52C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EED634(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, void, void, id))(v1 + 16);

  return v3(v1, 0, 0, 0, v2);
}

id sub_100EED690(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  xpc_object_t v8[2] = sub_100EED70C;
  v8[3] = &unk_101A6B2B8;
  char v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  char v9 = a2;
  void v8[6] = v6;
  v8[7] = a3;
  v8[4] = a4;
  v8[5] = a5;
  return [v5 notifyClient:v8];
}

uint64_t sub_100EED70C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 64), *(void *)(a1 + 56), *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_100EED808(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EED81C(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EED894;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EED894(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EED98C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EED9A0(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEDA18;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEDA18(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EEDB20(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEDB74(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEDBEC;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEDBEC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEDD14(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEDD64(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEDDD8;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEDDD8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEDF14(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEDF64(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEDFD8;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEDFD8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEE11C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEE16C(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEE1E0;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEE1E0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEE2E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);

  return v3(v1, v2);
}

id sub_100EEE334(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  void v5[2] = sub_100EEE3A8;
  double v5[3] = &unk_101A6B150;
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v5[4] = a2;
  void v5[5] = v3;
  return [v2 notifyClient:v5];
}

uint64_t sub_100EEE3A8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_100EEE4AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEE500(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEE578;
  void v6[3] = &unk_101A6B240;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[5] = a3;
  void v6[6] = v4;
  void v6[4] = a2;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEE578(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

uint64_t sub_100EEE680(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEE6D4(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEE74C;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEE74C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEE854(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEE8A8(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEE920;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEE920(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEEA58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100EEEA6C(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEEAE4;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEEAE4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t sub_100EEECB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEED08(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEED80;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEED80(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEEEA0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEEEF4(uint64_t a1, char a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEEF6C;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  char v7 = a2;
  void v6[4] = a3;
  void v6[5] = v4;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEEF6C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

uint64_t sub_100EEF064(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEF0B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEF130;
  void v6[3] = &unk_101A6B240;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[5] = a3;
  void v6[6] = v4;
  void v6[4] = a2;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEF130(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

uint64_t sub_100EEF238(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEF28C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEF304;
  void v6[3] = &unk_101A6B240;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[5] = a3;
  void v6[6] = v4;
  void v6[4] = a2;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEF304(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

uint64_t sub_100EEF40C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[CTCellularPlanError errorForCode:8];
  uint64_t v3 = *(uint64_t (**)(uint64_t, void, id))(v1 + 16);

  return v3(v1, 0, v2);
}

id sub_100EEF460(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEF4D8;
  void v6[3] = &unk_101A6B240;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[5] = a3;
  void v6[6] = v4;
  void v6[4] = a2;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEF4D8(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

id sub_100EEF6B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEF728;
  void v6[3] = &unk_101A6B240;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[5] = a3;
  void v6[6] = v4;
  void v6[4] = a2;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEF728(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

id sub_100EEF7D8(uint64_t a1, uint64_t a2, char a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100EEF850;
  void v6[3] = &unk_101A6B268;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[4] = a2;
  void v6[5] = v4;
  char v7 = a3;
  return [v3 notifyClient:v6];
}

uint64_t sub_100EEF850(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 48));
}

id sub_100EEF8F0(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEF968;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEF968(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

id sub_100EEFA58(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEFAD0;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEFAD0(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

id sub_100EEFBC0(uint64_t a1, char a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_100EEFC38;
  v4[3] = &unk_101A6B0B0;
  id v2 = *(void **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  char v5 = a2;
  return [v2 notifyClient:v4];
}

uint64_t sub_100EEFC38(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_100EEFDA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EEFFA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF0098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF0234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF0314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF04B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF05D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF0750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF086C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF09AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF0B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF0D0C(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = **(NSObject ***)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v4 = a1[5] != 0;
    v16[0] = 67109120;
    v16[1] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I setting controller: %d", (uint8_t *)v16, 8u);
    uint64_t v2 = a1[4];
  }
  uint64_t v6 = a1[5];
  uint64_t v5 = a1[6];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  char v7 = *(std::__shared_weak_count **)(v2 + 80);
  *(void *)(v2 + 72) = v6;
  *(void *)(v2 + 80) = v5;
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = a1[4];
  uint64_t v10 = a1[7];
  uint64_t v9 = a1[8];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 16), 1uLL, memory_order_relaxed);
  }
  __int16 v11 = *(std::__shared_weak_count **)(v8 + 96);
  *(void *)(v8 + 88) = v10;
  *(void *)(v8 + 96) = v9;
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  uint64_t v12 = a1[4];
  uint64_t v14 = a1[9];
  uint64_t v13 = a1[10];
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 16), 1uLL, memory_order_relaxed);
  }
  __int16 v15 = *(std::__shared_weak_count **)(v12 + 112);
  *(void *)(v12 + 104) = v14;
  *(void *)(v12 + 112) = v13;
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
}

void *sub_100EF0E3C(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[10];
  result[9] = a2[9];
  result[10] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EF0E88(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_100EF10A8()
{
}

void sub_100EF15A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF15E4(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF17F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_10010B788((uint64_t)va);
  sub_10004D2C8(v8);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF181C(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, v2, v4);
}

void sub_100EF1A14(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF1A34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100EF1BF0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF1C10(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100EF1E00(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF1E20(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  id v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

void sub_100EF20B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10010B788((uint64_t)va);
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

const void **sub_100EF20EC(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = *(void *)(a1 + 56);
    id v5 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
    uint64_t v6 = *(uint64_t (**)(uint64_t, id))(v4 + 16);
    return (const void **)v6(v4, v5);
  }
  else
  {
    uint64_t v9 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v10)
      {
        *(_DWORD *)long long buf = 136315138;
        unint64_t v21 = "-[CTCellularPlanServer addNewPlanWithCardData:confirmationCode:triggerType:userConsent:completion:]_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s handleNewPlanWithCardDataTriggered", buf, 0xCu);
      }
      uint64_t v11 = *(void *)(a1 + 64);
      uint64_t v12 = *(void *)(a1 + 80);
      uint64_t v13 = *(const void **)(a1 + 40);
      uint64_t v19 = v13;
      if (v13) {
        CFRetain(v13);
      }
      uint64_t v14 = *(const void **)(a1 + 48);
      long long v18 = v14;
      if (v14) {
        CFRetain(v14);
      }
      BOOL v15 = *(void *)(a1 + 88) == 1;
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      v17[2] = sub_100EF2380;
      v17[3] = &unk_101A6B448;
      uint64_t v16 = *(void *)(a1 + 56);
      v17[4] = *(void *)(a1 + 32);
      v17[5] = v16;
      (*(void (**)(uint64_t, BOOL, BOOL, const void **, const void **, BOOL, void *))(*(void *)v11
                                                                                                  + 256))(v11, v12 == 1, v12 == 2, &v19, &v18, v15, v17);
      sub_1000558F4(&v18);
      return sub_1000558F4(&v19);
    }
    else
    {
      if (v10)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E add new plan not supported", buf, 2u);
      }
      return (const void **)(*(uint64_t (**)(void, id))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), +[CTCellularPlanError errorForCode:5]);
    }
  }
}

void sub_100EF2348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF2380(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100EF23C8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EF23E4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 72);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EF2650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10010B788((uint64_t)va);
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

const void **sub_100EF268C(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = *(void *)(a1 + 72);
    id v5 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
    uint64_t v6 = *(uint64_t (**)(uint64_t, id))(v4 + 16);
    return (const void **)v6(v4, v5);
  }
  else
  {
    uint64_t v9 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v10)
      {
        *(_DWORD *)long long buf = 136315138;
        size_t v27 = "-[CTCellularPlanServer addNewPlanWithAddress:matchingId:oid:confirmationCode:triggerType:userConsent:compl"
              "etion:]_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
      }
      uint64_t v11 = *(void *)(a1 + 80);
      uint64_t v12 = *(void *)(a1 + 96);
      uint64_t v13 = *(const void **)(a1 + 40);
      unint64_t v25 = v13;
      if (v13) {
        CFRetain(v13);
      }
      uint64_t v14 = *(const void **)(a1 + 48);
      long long v24 = v14;
      if (v14) {
        CFRetain(v14);
      }
      BOOL v15 = *(const void **)(a1 + 56);
      unint64_t v23 = v15;
      if (v15) {
        CFRetain(v15);
      }
      uint64_t v16 = *(const void **)(a1 + 64);
      std::string::size_type v22 = v16;
      if (v16) {
        CFRetain(v16);
      }
      BOOL v17 = *(void *)(a1 + 104) == 1;
      long long v20 = 0;
      unint64_t v21 = 0;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_100EF29B0;
      v19[3] = &unk_101A6B448;
      uint64_t v18 = *(void *)(a1 + 72);
      v19[4] = *(void *)(a1 + 32);
      v19[5] = v18;
      (*(void (**)(uint64_t, uint64_t, BOOL, void, BOOL, const void **, const void **, const void **, const void **, BOOL, const void **, const void **, void *))(*(void *)v11 + 272))(v11, 2, v12 == 1, 0, v12 == 2, &v25, &v24, &v23, &v22, v17, &v21, &v20, v19);
      sub_1000558F4(&v20);
      sub_1000558F4(&v21);
      sub_1000558F4(&v22);
      sub_1000558F4(&v23);
      sub_1000558F4(&v24);
      return sub_1000558F4(&v25);
    }
    else
    {
      if (v10)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#E add new plan not supported", buf, 2u);
      }
      return (const void **)(*(uint64_t (**)(void, id))(*(void *)(a1 + 72) + 16))(*(void *)(a1 + 72), +[CTCellularPlanError errorForCode:5]);
    }
  }
}

void sub_100EF2950(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF29B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100EF29F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 88);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(result + 88) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EF2A14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 88);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EF2BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10010B788((uint64_t)va);
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF2C18(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
    uint64_t v6 = *(uint64_t (**)(uint64_t, id))(v4 + 16);
    return v6(v4, v5);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 32);
    BOOL v10 = **(NSObject ***)(v9 + 40);
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v11)
      {
        *(_DWORD *)long long buf = 136315138;
        long long v20 = "-[CTCellularPlanServer resumePlanProvisioning:userConsent:completion:]_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
        uint64_t v9 = *(void *)(a1 + 32);
      }
      uint64_t v14 = *(unsigned __int8 *)(a1 + 72);
      BOOL v15 = *(void *)(a1 + 64) == 1;
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_100EF2E20;
      v18[3] = &unk_101A6B448;
      uint64_t v17 = *(void *)(a1 + 40);
      uint64_t v16 = *(void *)(a1 + 48);
      v18[4] = v9;
      v18[5] = v17;
      return (*(uint64_t (**)(uint64_t, uint64_t, BOOL, void *, uint64_t, uint64_t))(*(void *)v16 + 296))(v16, v14, v15, v18, v12, v13);
    }
    else
    {
      if (v11)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#E add new plan not supported", buf, 2u);
      }
      return (*(uint64_t (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), +[CTCellularPlanError errorForCode:5]);
    }
  }
}

uint64_t sub_100EF2E20(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100EF2E68(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EF2E84(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EF3194(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF31DC(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  id v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, v2, v4);
}

uint64_t sub_100EF3228(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  id v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, v2, v4);
}

void sub_100EF3398(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100EF33D8(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF3534(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF3574(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF36D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF3710(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF39C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF3A28(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF3C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_100EF3F2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF3F8C(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF4158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF454C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v26);
  _Unwind_Resume(a1);
}

void sub_100EF48A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF48E8(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF4C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1000558F4(&a15);
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF4CA8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  id v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EF5178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EF5230(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a2 == 0;
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  id v5 = *(uint64_t (**)(uint64_t, BOOL, id))(v3 + 16);

  return v5(v3, v2, v4);
}

uint64_t sub_100EF5284(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF5660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a23 < 0)
  {
    operator delete(__p);
    if (v26)
    {
LABEL_3:
      if (!v24) {
LABEL_8:
      }
        _Unwind_Resume(exception_object);
LABEL_7:
      sub_10004D2C8(v24);
      goto LABEL_8;
    }
  }
  else if (v26)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v25);
  if (!v24) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t sub_100EF5700(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF5E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  if ((v36 & 1) == 0) {
    sub_10004D2C8(v35);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF6354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a23 < 0)
  {
    operator delete(__p);
    if (v26)
    {
LABEL_3:
      if (!v24) {
LABEL_8:
      }
        _Unwind_Resume(exception_object);
LABEL_7:
      sub_10004D2C8(v24);
      goto LABEL_8;
    }
  }
  else if (v26)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v25);
  if (!v24) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t sub_100EF63F4(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF6940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  sub_10005CD2C(v12 - 128, *(char **)(v12 - 120));
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EF69C4(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF6E6C(_Unwind_Exception *a1)
{
  sub_10005CD2C(v2 - 128, *(char **)(v2 - 120));
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100EF6EE0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EF71B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF71F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  id v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EF754C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF7590(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  id v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

uint64_t sub_100EF75DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  id v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EF785C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF7C64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,char a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,char a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,char a45,int a46,__int16 a47,char a48,char a49,int a50,__int16 a51,char a52,char a53,int a54,__int16 a55,char a56,char a57)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF7D74()
{
  if (*(char *)(v0 - 153) < 0) {
    JUMPOUT(0x100EF7D34);
  }
  JUMPOUT(0x100EF7D3CLL);
}

void sub_100EF7FEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

id sub_100EF80C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = **(NSObject ***)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending plan info did update", buf, 2u);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = *(void **)(v2 + 16);
  id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v8);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        void v10[2] = sub_100EF825C;
        v10[3] = &unk_101A6B540;
        v10[4] = *(void *)(a1 + 32);
        objc_msgSend(objc_msgSend(v9, "remoteObjectProxyWithErrorHandler:", v10), "planInfoDidUpdate");
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
      id v6 = result;
    }
    while (result);
  }
  return result;
}

void sub_100EF825C(uint64_t a1, void *a2)
{
  id v3 = objc_msgSend(objc_msgSend(a2, "description"), "UTF8String");
  id v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315138;
    id v6 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error with proxy object %s", (uint8_t *)&v5, 0xCu);
  }
}

id sub_100EF838C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = **(NSObject ***)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    uint64_t v17 = asString();
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending plan info did update local : %s", buf, 0xCu);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = *(void **)(v2 + 16);
  id result = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v8);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        void v10[2] = sub_100EF8554;
        v10[3] = &unk_101A6B540;
        v10[4] = *(void *)(a1 + 32);
        objc_msgSend(objc_msgSend(v9, "remoteObjectProxyWithErrorHandler:", v10), "localPlanInfoDidUpdate:", objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:", *(unsigned __int8 *)(a1 + 40)));
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id result = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
      id v6 = result;
    }
    while (result);
  }
  return result;
}

void sub_100EF8554(uint64_t a1, void *a2)
{
  id v3 = objc_msgSend(objc_msgSend(a2, "description"), "UTF8String");
  id v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315138;
    id v6 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error with proxy object %s", (uint8_t *)&v5, 0xCu);
  }
}

id sub_100EF8680(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = **(NSObject ***)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I send pending transfer plan info did update", buf, 2u);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = *(void **)(v2 + 16);
  id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v8);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        void v10[2] = sub_100EF881C;
        v10[3] = &unk_101A6B540;
        v10[4] = *(void *)(a1 + 32);
        objc_msgSend(objc_msgSend(v9, "remoteObjectProxyWithErrorHandler:", v10), "pendingTransferPlanInfoDidUpdate");
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
      id v6 = result;
    }
    while (result);
  }
  return result;
}

void sub_100EF881C(uint64_t a1, void *a2)
{
  id v3 = objc_msgSend(objc_msgSend(a2, "description"), "UTF8String");
  id v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315138;
    id v6 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error with proxy object %s", (uint8_t *)&v5, 0xCu);
  }
}

id sub_100EF8948(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = **(NSObject ***)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending carrier info did update", buf, 2u);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = *(void **)(v2 + 16);
  id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v8);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        void v10[2] = sub_100EF8AE4;
        v10[3] = &unk_101A6B540;
        v10[4] = *(void *)(a1 + 32);
        objc_msgSend(objc_msgSend(v9, "remoteObjectProxyWithErrorHandler:", v10), "carrierInfoDidUpdate");
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
      id v6 = result;
    }
    while (result);
  }
  return result;
}

void sub_100EF8AE4(uint64_t a1, void *a2)
{
  id v3 = objc_msgSend(objc_msgSend(a2, "description"), "UTF8String");
  id v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315138;
    id v6 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error with proxy object %s", (uint8_t *)&v5, 0xCu);
  }
}

id sub_100EF8C10(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = **(NSObject ***)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I sending remote provisioning did become available", buf, 2u);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v4 = *(void **)(v2 + 16);
  id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
  if (result)
  {
    id v6 = result;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * (void)v8);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        void v10[2] = sub_100EF8DAC;
        v10[3] = &unk_101A6B540;
        v10[4] = *(void *)(a1 + 32);
        objc_msgSend(objc_msgSend(v9, "remoteObjectProxyWithErrorHandler:", v10), "remoteProvisioningDidBecomeAvailable");
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id result = [v4 countByEnumeratingWithState:&v11 objects:v16 count:16];
      id v6 = result;
    }
    while (result);
  }
  return result;
}

void sub_100EF8DAC(uint64_t a1, void *a2)
{
  id v3 = objc_msgSend(objc_msgSend(a2, "description"), "UTF8String");
  id v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v5 = 136315138;
    id v6 = v3;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error with proxy object %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100EF9024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EF92B0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EF9358(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EF9578(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF959C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100EF976C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF978C(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t a5)
{
  if ((*((char *)a4 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a4 + 23)) {
      goto LABEL_7;
    }
LABEL_6:
    uint64_t v9 = +[NSString stringWithUTF8String:a4];
    goto LABEL_8;
  }
  if (a4[1])
  {
    a4 = (uint64_t *)*a4;
    goto LABEL_6;
  }
LABEL_7:
  uint64_t v9 = 0;
LABEL_8:
  BOOL v10 = *(void ***)(a1 + 32);
  long long v11 = *v10[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = subscriber::asString();
    if (a2) {
      long long v13 = "true";
    }
    else {
      long long v13 = "false";
    }
    int v15 = 136315906;
    uint64_t v16 = v12;
    __int16 v17 = 2080;
    uint64_t v18 = v13;
    __int16 v19 = 1024;
    unsigned int v20 = a3;
    __int16 v21 = 2080;
    uint64_t v22 = asString();
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I shouldShowAddNewRemotePlanWithContext, slot - %s, shouldShowAddNewRemotePlan - %s , flowType - %d, error - %s", (uint8_t *)&v15, 0x26u);
    BOOL v10 = *(void ***)(a1 + 32);
  }
  return (*(uint64_t (**)(void, uint64_t, void, NSString *, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), a2, a3, v9, [v10 _getErrorFromCellularPlanError:a5]);
}

void sub_100EF9AE4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF9B04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100EF9CE8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EF9D08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100EF9F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100EFA214(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFA24C(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = **(NSObject ***)(v4 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I handleAddNewRemotePlanTapped", buf, 2u);
      uint64_t v4 = *(void *)(a1 + 32);
    }
    uint64_t v7 = *(unsigned int *)(a1 + 72);
    BOOL v8 = *(void *)(a1 + 64) == 1;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_100EFA3A8;
    v12[3] = &unk_101A6B448;
    uint64_t v10 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    void v12[4] = v4;
    v12[5] = v10;
    return (*(uint64_t (**)(uint64_t, uint64_t, BOOL, void *))(*(void *)v9 + 56))(v9, v7, v8, v12);
  }
  else
  {
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E remote plan not supported", buf, 2u);
    }
    return (*(uint64_t (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), +[CTCellularPlanError errorForCode:5]);
  }
}

uint64_t sub_100EFA3A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100EFA3F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EFA40C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EFA738(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_100EFA774(uint64_t a1, int a2)
{
  uint64_t v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleNewRemoteDataPlanFlowTriggered", buf, 2u);
    }
    uint64_t v6 = *(void *)(a1 + 64);
    uint64_t v7 = *(unsigned int *)(a1 + 88);
    int v8 = *(unsigned __int8 *)(a1 + 92);
    uint64_t v9 = *(const void **)(a1 + 40);
    uint64_t v16 = v9;
    if (v9) {
      CFRetain(v9);
    }
    uint64_t v10 = *(const void **)(a1 + 48);
    int v15 = v10;
    if (v10) {
      CFRetain(v10);
    }
    BOOL v11 = *(void *)(a1 + 80) == 1;
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_100EFA944;
    v14[3] = &unk_101A6B448;
    uint64_t v12 = *(void *)(a1 + 56);
    void v14[4] = *(void *)(a1 + 32);
    void v14[5] = v12;
    (*(void (**)(uint64_t, uint64_t, BOOL, const void **, const void **, BOOL, void *))(*(void *)v6 + 40))(v6, v7, v8 != 0, &v16, &v15, v11, v14);
    sub_1000558F4(&v15);
    return sub_1000558F4(&v16);
  }
  else
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E remote plan not supported", buf, 2u);
    }
    return (const void **)(*(uint64_t (**)(void, id))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), +[CTCellularPlanError errorForCode:5]);
  }
}

void sub_100EFA928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  int v8 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFA944(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100EFA98C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EFA9A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 72);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EFACA4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_100EFACE0(uint64_t a1, int a2)
{
  uint64_t v4 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleUserEnteredRemoteDataPlanFlowTriggered", buf, 2u);
    }
    uint64_t v6 = *(void *)(a1 + 80);
    uint64_t v7 = *(unsigned int *)(a1 + 104);
    int v8 = *(unsigned __int8 *)(a1 + 108);
    uint64_t v9 = *(const void **)(a1 + 40);
    unsigned int v20 = v9;
    if (v9) {
      CFRetain(v9);
    }
    uint64_t v10 = *(const void **)(a1 + 48);
    __int16 v19 = v10;
    if (v10) {
      CFRetain(v10);
    }
    BOOL v11 = *(const void **)(a1 + 56);
    uint64_t v18 = v11;
    if (v11) {
      CFRetain(v11);
    }
    uint64_t v12 = *(const void **)(a1 + 64);
    __int16 v17 = v12;
    if (v12) {
      CFRetain(v12);
    }
    BOOL v13 = *(void *)(a1 + 96) == 1;
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    _DWORD v16[2] = sub_100EFAF00;
    v16[3] = &unk_101A6B448;
    uint64_t v14 = *(void *)(a1 + 72);
    void v16[4] = *(void *)(a1 + 32);
    v16[5] = v14;
    (*(void (**)(uint64_t, uint64_t, BOOL, const void **, const void **, const void **, const void **, BOOL, void *))(*(void *)v6 + 48))(v6, v7, v8 != 0, &v20, &v19, &v18, &v17, v13, v16);
    sub_1000558F4(&v17);
    sub_1000558F4(&v18);
    sub_1000558F4(&v19);
    return sub_1000558F4(&v20);
  }
  else
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#E remote plan not supported", buf, 2u);
    }
    return (const void **)(*(uint64_t (**)(void, id))(*(void *)(a1 + 72) + 16))(*(void *)(a1 + 72), +[CTCellularPlanError errorForCode:5]);
  }
}

void sub_100EFAED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  BOOL v11 = va_arg(va1, const void *);
  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);
  sub_1000558F4((const void **)(v9 - 64));
  sub_1000558F4((const void **)(v9 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_100EFAF00(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100EFAF48(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 88);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(result + 88) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100EFAF64(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 88);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100EFB1C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFB1FC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _getErrorFromCellularPlanError:a2];
  uint64_t v4 = *(uint64_t (**)(uint64_t, id))(v2 + 16);

  return v4(v2, v3);
}

void sub_100EFB434(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFB454(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void ***)(a1 + 32);
  uint64_t v7 = *v6[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    uint64_t v10 = asString();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I -[remotePlanItemsWithUpdateFetch] error: (%s)", (uint8_t *)&v9, 0xCu);
    uint64_t v6 = *(void ***)(a1 + 32);
  }
  return (*(uint64_t (**)(void, void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *a2, [v6 _getErrorFromCellularPlanError:a3]);
}

void sub_100EFB794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EFB7D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  BOOL v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EFBA70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EFBAB4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  BOOL v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EFBD9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFBF60(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EFC0D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EFC240(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100EFC430(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFC450(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  BOOL v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EFC690(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EFC6DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  BOOL v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, a2, v4);
}

void sub_100EFC97C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, char a11)
{
  a10 = (void **)&a11;
  sub_100CC28AC(&a10);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(a1);
}

void sub_100EFCAD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15)
{
  sub_1000558F4(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

void sub_100EFCFFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EFD0C4(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFD2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000558F4(&a9);
  sub_10004D2C8(v9);
  _Unwind_Resume(a1);
}

void sub_100EFD370(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFD474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFD518(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFD61C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFD6C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFD7C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFD994(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100EFDB78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100EFDD44(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFDF3C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFDF5C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "_getErrorFromCellularPlanError:");
  BOOL v5 = *(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16);

  return v5(v3, v2, v4);
}

void sub_100EFE130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100057D78((const void **)va);
  sub_10004D2C8(v8);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFE158(uint64_t a1, uint64_t *a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    BOOL v5 = **(NSObject ***)(*(void *)(a1 + 32) + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E debugGetPhoneAuthToken failed", v9, 2u);
    }
  }
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = objc_alloc((Class)NSString);
  if (*((char *)a2 + 23) < 0) {
    a2 = (uint64_t *)*a2;
  }
  return (*(uint64_t (**)(uint64_t, id, uint64_t))(v6 + 16))(v6, [v7 initWithCString:a2 encoding:4], 1);
}

void sub_100EFE3D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3)
  {
    id v4 = **(NSObject ***)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Removing Invalidated Connection", v5, 2u);
      uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 16);
    }
    [v3 removeObject:*(void *)(a1 + 40)];
    uint64_t v2 = *(void *)(a1 + 32);
  }
  [(id)v2 setUserInPurchaseFlow:0 withConnection:*(void *)(a1 + 40)];
}

void sub_100EFE570(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100EFE5F8;
  block[3] = &unk_1019A1BF8;
  block[4] = a1;
  if (qword_101B12EE8[0] != -1) {
    dispatch_once(qword_101B12EE8, block);
  }
}

void sub_100EFE5F8(uint64_t a1)
{
  +[CTCellularPlanServer initializeServerWithRegistry:*(void *)(a1 + 32)];
}

void sub_100EFE644(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  id v6 = +[CTCellularPlanServer sharedServerInstance];
  id v7 = (std::__shared_weak_count *)a1[1];
  uint64_t v14 = *a1;
  int v15 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = (std::__shared_weak_count *)a2[1];
  uint64_t v12 = *a2;
  BOOL v13 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v10 = *a3;
  BOOL v11 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v6 setCellularPlanController:&v14 andPhoneController:&v12 andDebugController:&v10];
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
}

void sub_100EFE704(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100EFE734(id a1)
{
  qword_101B12EF8 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___CTCellularPlanClient];
  [(id)qword_101B12EF8 setClasses:CTCellularPlanXpcWhitelistSet() forSelector:"planItemsWithCompletion:" argumentIndex:0 ofReply:1];
  [(id)qword_101B12EF8 setClasses:CTCellularPlanXpcWhitelistSet() forSelector:"remotePlanItemsWithUpdateFetch:completion:" argumentIndex:0 ofReply:1];
  [(id)qword_101B12EF8 setClasses:CTCellularPlanCarrierItemXpcWhitelistSet() forSelector:"carrierItemsShouldUpdate:completion:" argumentIndex:0 ofReply:1];
  [(id)qword_101B12EF8 setClasses:CTCellularPlanXpcWhitelistSet() forSelector:"getPredefinedLabels:" argumentIndex:0 ofReply:1];
  uint64_t v1 = (void *)qword_101B12EF8;
  uint64_t v2 = objc_opt_class();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", +[NSSet setWithObjects:](NSSet, "setWithObjects:", v2, objc_opt_class(), 0), "getShortLabelsForLabels:completion:", 0, 0);
  [(id)qword_101B12EF8 setClasses:CTCellularPlanXpcWhitelistSet() forSelector:"didSelectPlansForIMessage:completion:" argumentIndex:0 ofReply:0];
  uint64_t v3 = (void *)qword_101B12EF8;
  uint64_t v4 = CTCellularPlanXpcWhitelistSet();

  [v3 setClasses:v4 forSelector:"didEnablePlanItems:completion:" argumentIndex:0 ofReply:0];
}

void sub_100EFE8BC(id a1)
{
  qword_101B12F08 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___CTCellularPlanClientDelegate];
}

void *sub_100EFE8F0(void *a1)
{
  *a1 = off_101A6B7C8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFE940(void *a1)
{
  *a1 = off_101A6B7C8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFE9B0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6B7C8;
  sub_100EFEB88(v2 + 1, v1);
  return v2;
}

void *sub_100EFEA04(uint64_t a1, void *a2)
{
  *a2 = off_101A6B7C8;
  return sub_100EFEB88(a2 + 1, (void *)(a1 + 8));
}

void sub_100EFEA30(uint64_t a1)
{
}

void sub_100EFEA38(const void **a1)
{
  sub_100EFEBC4(a1[2]);

  operator delete(a1);
}

uint64_t sub_100EFEA74(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = **(NSObject ***)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I should show plan setup: %d", (uint8_t *)v6, 8u);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16))();
}

uint64_t sub_100EFEB3C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6B828)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFEB7C()
{
  return &off_101A6B828;
}

void *sub_100EFEB88(void *a1, void *a2)
{
  int v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    int v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100EFEBC4(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFEBE4(void *a1)
{
  *a1 = off_101A6B848;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFEC34(void *a1)
{
  *a1 = off_101A6B848;
  uint64_t v1 = (const void *)a1[1];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFECA4(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 8);
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A6B848;
  sub_100EFF028(v2 + 1, v1);
  return v2;
}

void *sub_100EFECF8(uint64_t a1, void *a2)
{
  *a2 = off_101A6B848;
  return sub_100EFF028(a2 + 1, (void **)(a1 + 8));
}

void sub_100EFED24(uint64_t a1)
{
}

void sub_100EFED2C(const void **a1)
{
  sub_100EFF060(a1[1]);

  operator delete(a1);
}

void sub_100EFED68(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v26 = a1;
  id v29 = [objc_alloc((Class)NSMutableArray) initWithCapacity:0xF0F0F0F0F0F0F0F1 * (a2[1] - *a2)];
  uint64_t v4 = *a2;
  size_t v27 = a2[1];
  if (*a2 != v27)
  {
    do
    {
      BOOL v5 = (char *)v4[13];
      uint64_t v6 = *((unsigned __int8 *)v4 + 127);
      int v7 = (char)v6;
      if ((v6 & 0x80u) != 0) {
        uint64_t v6 = v4[14];
      }
      if (v7 >= 0) {
        BOOL v5 = (char *)(v4 + 13);
      }
      if (v6) {
        int v8 = v5;
      }
      else {
        int v8 = "<invalid>";
      }
      sub_100058DB0(__p, v8);
      int v9 = sub_100046F68(a3, __p);
      if (v31 < 0) {
        operator delete(__p[0]);
      }
      id v10 = objc_alloc((Class)CTDanglingPlanItem);
      uint64_t v11 = *((unsigned __int8 *)v4 + 127);
      BOOL v12 = (v11 & 0x80u) != 0;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = v4[14];
      }
      if (v12) {
        BOOL v13 = (const char *)v4[13];
      }
      else {
        BOOL v13 = (const char *)(v4 + 13);
      }
      if (v11) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = "<invalid>";
      }
      int v15 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14, v26);
      uint64_t v16 = v4 + 10;
      if (*((char *)v4 + 103) < 0) {
        uint64_t v16 = (void *)*v16;
      }
      __int16 v17 = +[NSString stringWithUTF8String:v16];
      id v18 = objc_alloc((Class)CTUserLabel);
      __int16 v19 = v4 + 3;
      if (*((char *)v4 + 47) < 0) {
        __int16 v19 = (void *)*v19;
      }
      unsigned int v20 = +[NSString stringWithUTF8String:v19];
      __int16 v21 = v4;
      if (*((char *)v4 + 23) < 0) {
        __int16 v21 = (uint64_t *)*v4;
      }
      uint64_t v22 = +[NSString stringWithUTF8String:v21];
      unint64_t v23 = v4 + 6;
      long long v24 = v4 + 6;
      if (*((char *)v4 + 71) < 0) {
        long long v24 = (void *)*v23;
      }
      id v25 = objc_msgSend(v18, "initWithKey:label:labelId:", v20, v22, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v24));
      if (*((char *)v4 + 71) < 0) {
        unint64_t v23 = (void *)*v23;
      }
      objc_msgSend(v29, "addObject:", objc_msgSend(v10, "initWithIccid:phoneNumber:label:labelID:isPrivateNetworkSim:", v15, v17, v25, +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v23), a3 + 8 != (void)v9));
      v4 += 17;
    }
    while (v4 != v27);
  }
  (*(void (**)(void))(*(void *)(v26 + 8) + 16))();
}

void sub_100EFEFC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100EFEFDC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6B8B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFF01C()
{
  return &off_101A6B8B8;
}

void *sub_100EFF028(void *a1, void **a2)
{
  int v3 = *a2;
  if (*a2) {
    int v3 = _Block_copy(v3);
  }
  *a1 = v3;
  return a1;
}

void sub_100EFF060(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFF080(void *a1)
{
  *a1 = off_101A6B8D8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFF0D0(void *a1)
{
  *a1 = off_101A6B8D8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFF140(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6B8D8;
  sub_100EFF2D0(v2 + 1, v1);
  return v2;
}

void *sub_100EFF194(uint64_t a1, void *a2)
{
  *a2 = off_101A6B8D8;
  return sub_100EFF2D0(a2 + 1, (void *)(a1 + 8));
}

void sub_100EFF1C0(uint64_t a1)
{
}

void sub_100EFF1C8(const void **a1)
{
  sub_100EFF30C(a1[2]);

  operator delete(a1);
}

const void **sub_100EFF204(uint64_t a1, const void **a2, unsigned char *a3)
{
  BOOL v5 = *a2;
  *a2 = 0;
  if (*a3) {
    objc_msgSend(*(id *)(a1 + 8), "_getErrorFromCellularPlanError:");
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  return sub_100044D00(&v5);
}

void sub_100EFF270(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFF284(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6B938)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFF2C4()
{
  return &off_101A6B938;
}

void *sub_100EFF2D0(void *a1, void *a2)
{
  int v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    int v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100EFF30C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFF32C(void *a1)
{
  *a1 = off_101A6B958;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFF37C(void *a1)
{
  *a1 = off_101A6B958;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFF3EC(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6B958;
  sub_100EFF57C(v2 + 1, v1);
  return v2;
}

void *sub_100EFF440(uint64_t a1, void *a2)
{
  *a2 = off_101A6B958;
  return sub_100EFF57C(a2 + 1, (void *)(a1 + 8));
}

void sub_100EFF46C(uint64_t a1)
{
}

void sub_100EFF474(const void **a1)
{
  sub_100EFF5B8(a1[2]);

  operator delete(a1);
}

const void **sub_100EFF4B0(uint64_t a1, const void **a2, unsigned char *a3)
{
  BOOL v5 = *a2;
  *a2 = 0;
  if (*a3) {
    objc_msgSend(*(id *)(a1 + 8), "_getErrorFromCellularPlanError:");
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  return sub_100044D00(&v5);
}

void sub_100EFF51C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFF530(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6B9B8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFF570()
{
  return &off_101A6B9B8;
}

void *sub_100EFF57C(void *a1, void *a2)
{
  int v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    int v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100EFF5B8(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFF5D8(void *a1)
{
  *a1 = off_101A6B9D8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFF628(void *a1)
{
  *a1 = off_101A6B9D8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFF698(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6B9D8;
  sub_100EFF91C(v2 + 1, v1);
  return v2;
}

void *sub_100EFF6EC(uint64_t a1, void *a2)
{
  *a2 = off_101A6B9D8;
  return sub_100EFF91C(a2 + 1, (void *)(a1 + 8));
}

void sub_100EFF718(uint64_t a1)
{
}

void sub_100EFF720(const void **a1)
{
  sub_100EFF958(a1[2]);

  operator delete(a1);
}

const void **sub_100EFF75C(uint64_t a1, unsigned __int8 *a2, const void **a3, const void **a4, unsigned char *a5)
{
  int v6 = *a2;
  int v7 = *a3;
  *a3 = 0;
  int v8 = *a4;
  BOOL v13 = *a4;
  uint64_t v14 = v7;
  *a4 = 0;
  if (*a5)
  {
    id v9 = objc_msgSend(*(id *)(a1 + 8), "_getErrorFromCellularPlanError:");
    int v8 = v13;
    int v7 = v14;
  }
  else
  {
    id v9 = 0;
  }
  id v10 = **(NSObject ***)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = "false";
    *(_DWORD *)long long buf = 136315906;
    if (v6) {
      uint64_t v11 = "true";
    }
    uint64_t v16 = v11;
    __int16 v17 = 2112;
    id v18 = v9;
    __int16 v19 = 2112;
    unsigned int v20 = v7;
    __int16 v21 = 2112;
    uint64_t v22 = v8;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I response for activatePlanPendingTransfer, transferComplete: %s, error: %@, url: %@, post-data: %@", buf, 0x2Au);
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  sub_100057D78(&v13);
  return sub_1000558F4(&v14);
}

void sub_100EFF8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_100EFF8D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BA38)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFF910()
{
  return &off_101A6BA38;
}

void *sub_100EFF91C(void *a1, void *a2)
{
  int v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    int v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100EFF958(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFF978(void *a1)
{
  *a1 = off_101A6BA58;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFF9C8(void *a1)
{
  *a1 = off_101A6BA58;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFFA38(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BA58;
  sub_100EFFC24(v2 + 1, v1);
  return v2;
}

void *sub_100EFFA8C(uint64_t a1, void *a2)
{
  *a2 = off_101A6BA58;
  return sub_100EFFC24(a2 + 1, (void *)(a1 + 8));
}

void sub_100EFFAB8(uint64_t a1)
{
}

void sub_100EFFAC0(const void **a1)
{
  sub_100EFFC60(a1[2]);

  operator delete(a1);
}

uint64_t sub_100EFFAFC(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = objc_msgSend(*(id *)(a1 + 8), "_getErrorFromCellularPlanError:");
  }
  else {
    id v3 = 0;
  }
  uint64_t v4 = **(NSObject ***)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I response for deletePlanPendingTransfer, error: %@", (uint8_t *)&v6, 0xCu);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16))();
}

uint64_t sub_100EFFBD8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BAB8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFFC18()
{
  return &off_101A6BAB8;
}

void *sub_100EFFC24(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100EFFC60(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFFC80(void *a1)
{
  *a1 = off_101A6BAD8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFFCD0(void *a1)
{
  *a1 = off_101A6BAD8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFFD40(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BAD8;
  sub_100EFFEC4(v2 + 1, v1);
  return v2;
}

void *sub_100EFFD94(uint64_t a1, void *a2)
{
  *a2 = off_101A6BAD8;
  return sub_100EFFEC4(a2 + 1, (void *)(a1 + 8));
}

void sub_100EFFDC0(uint64_t a1)
{
}

void sub_100EFFDC8(const void **a1)
{
  sub_100EFFF00(a1[2]);

  operator delete(a1);
}

const void **sub_100EFFE04(uint64_t a1, const void **a2, unsigned __int8 *a3)
{
  BOOL v5 = *a2;
  *a2 = 0;
  [*(id *)(a1 + 8) _getErrorFromCellularPlanError:*a3];
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  return sub_100044D00(&v5);
}

void sub_100EFFE64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100EFFE78(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BB38)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100EFFEB8()
{
  return &off_101A6BB38;
}

void *sub_100EFFEC4(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100EFFF00(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100EFFF20(void *a1)
{
  *a1 = off_101A6BB58;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100EFFF70(void *a1)
{
  *a1 = off_101A6BB58;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100EFFFE0(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BB58;
  sub_100F001F0(v2 + 1, v1);
  return v2;
}

void *sub_100F00034(uint64_t a1, void *a2)
{
  *a2 = off_101A6BB58;
  return sub_100F001F0(a2 + 1, (void *)(a1 + 8));
}

void sub_100F00060(uint64_t a1)
{
}

void sub_100F00068(const void **a1)
{
  sub_100F0022C(a1[2]);

  operator delete(a1);
}

uint64_t sub_100F000A4(uint64_t a1, unsigned char *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *a3;
  if (*a2)
  {
    [*(id *)(a1 + 8) _getErrorFromCellularPlanError:v4];
    BOOL v5 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);
LABEL_5:
    return v5();
  }
  int v6 = *(void **)(a1 + 8);
  if (v6)
  {
    [v6 _getErrorFromCellularPlanError:v4];
    BOOL v5 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);
    goto LABEL_5;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "No server object", v8, 2u);
  }
  +[CTCellularPlanError errorForCode:4];
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16))();
}

uint64_t sub_100F001A4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BBB8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F001E4()
{
  return &off_101A6BBB8;
}

void *sub_100F001F0(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100F0022C(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100F0024C(void *a1)
{
  *a1 = off_101A6BBD8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F0029C(void *a1)
{
  *a1 = off_101A6BBD8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100F0030C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BBD8;
  sub_100F0051C(v2 + 1, v1);
  return v2;
}

void *sub_100F00360(uint64_t a1, void *a2)
{
  *a2 = off_101A6BBD8;
  return sub_100F0051C(a2 + 1, (void *)(a1 + 8));
}

void sub_100F0038C(uint64_t a1)
{
}

void sub_100F00394(const void **a1)
{
  sub_100F00558(a1[2]);

  operator delete(a1);
}

uint64_t sub_100F003D0(uint64_t a1, unsigned char *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *a3;
  if (*a2)
  {
    [*(id *)(a1 + 8) _getErrorFromCellularPlanError:v4];
    BOOL v5 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);
LABEL_5:
    return v5();
  }
  int v6 = *(void **)(a1 + 8);
  if (v6)
  {
    [v6 _getErrorFromCellularPlanError:v4];
    BOOL v5 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);
    goto LABEL_5;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "No server object", v8, 2u);
  }
  +[CTCellularPlanError errorForCode:4];
  return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16))();
}

uint64_t sub_100F004D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BC38)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F00510()
{
  return &off_101A6BC38;
}

void *sub_100F0051C(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100F00558(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100F00578(void *a1)
{
  *a1 = off_101A6BC58;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F005C8(void *a1)
{
  *a1 = off_101A6BC58;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100F00638(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BC58;
  sub_100F00824(v2 + 1, v1);
  return v2;
}

void *sub_100F0068C(uint64_t a1, void *a2)
{
  *a2 = off_101A6BC58;
  return sub_100F00824(a2 + 1, (void *)(a1 + 8));
}

void sub_100F006B8(uint64_t a1)
{
}

void sub_100F006C0(const void **a1)
{
  sub_100F00860(a1[2]);

  operator delete(a1);
}

uint64_t sub_100F006FC(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    [v4 _getErrorFromCellularPlanError:*a3];
    BOOL v5 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);
    return v5();
  }
  else
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "No server object", v7, 2u);
    }
    +[CTCellularPlanError errorForCode:4];
    return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16))();
  }
}

uint64_t sub_100F007D8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BCB8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F00818()
{
  return &off_101A6BCB8;
}

void *sub_100F00824(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100F00860(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100F00880(void *a1)
{
  *a1 = off_101A6BCD8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F008D0(void *a1)
{
  *a1 = off_101A6BCD8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100F00940(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BCD8;
  sub_100F00B2C(v2 + 1, v1);
  return v2;
}

void *sub_100F00994(uint64_t a1, void *a2)
{
  *a2 = off_101A6BCD8;
  return sub_100F00B2C(a2 + 1, (void *)(a1 + 8));
}

void sub_100F009C0(uint64_t a1)
{
}

void sub_100F009C8(const void **a1)
{
  sub_100F00B68(a1[2]);

  operator delete(a1);
}

uint64_t sub_100F00A04(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    [v4 _getErrorFromCellularPlanError:*a3];
    BOOL v5 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);
    return v5();
  }
  else
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v7 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "No server object", v7, 2u);
    }
    +[CTCellularPlanError errorForCode:4];
    return (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 16))();
  }
}

uint64_t sub_100F00AE0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BD38)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F00B20()
{
  return &off_101A6BD38;
}

void *sub_100F00B2C(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100F00B68(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100F00B88(void *a1)
{
  *a1 = off_101A6BD58;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F00BD8(void *a1)
{
  *a1 = off_101A6BD58;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100F00C48(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BD58;
  sub_100F00DB8(v2 + 1, v1);
  return v2;
}

void *sub_100F00C9C(uint64_t a1, void *a2)
{
  *a2 = off_101A6BD58;
  return sub_100F00DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_100F00CC8(uint64_t a1)
{
}

void sub_100F00CD0(const void **a1)
{
  sub_100F00DF4(a1[2]);

  operator delete(a1);
}

uint64_t sub_100F00D0C(uint64_t a1, _WORD *a2)
{
  if ((unsigned __int16)*a2 >= 0x100u) {
    [*(id *)(a1 + 8) _getErrorFromCellularPlanError:*a2];
  }
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 16);

  return v3();
}

uint64_t sub_100F00D6C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BDB8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F00DAC()
{
  return &off_101A6BDB8;
}

void *sub_100F00DB8(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100F00DF4(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

void *sub_100F00E14(void *a1)
{
  *a1 = off_101A6BDD8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F00E64(void *a1)
{
  *a1 = off_101A6BDD8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    _Block_release(v1);
  }

  operator delete();
}

void *sub_100F00ED4(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A6BDD8;
  sub_100F01258(v2 + 1, v1);
  return v2;
}

void *sub_100F00F28(uint64_t a1, void *a2)
{
  *a2 = off_101A6BDD8;
  return sub_100F01258(a2 + 1, (void *)(a1 + 8));
}

void sub_100F00F54(uint64_t a1)
{
}

void sub_100F00F5C(const void **a1)
{
  sub_100F01294(a1[2]);

  operator delete(a1);
}

void sub_100F00F98(uint64_t a1, void *a2)
{
  id v4 = [objc_alloc((Class)NSMutableArray) initWithCapacity:(uint64_t)(a2[1] - *a2) >> 3];
  int v6 = (void *)*a2;
  BOOL v5 = (void *)a2[1];
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  unsigned int v20 = sub_100F012B4;
  __int16 v21 = &unk_101A6BE50;
  id v22 = v4;
  while (v6 != v5)
    v20((uint64_t)v19, v6++);
  id v7 = **(NSObject ***)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    unint64_t v28 = "operator()";
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s: Output short Labels: ", buf, 0xCu);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v8 = [v4 countByEnumeratingWithState:&v15 objects:buf count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v10) {
          objc_enumerationMutation(v4);
        }
        BOOL v12 = **(NSObject ***)(*(void *)(a1 + 8) + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          id v13 = [*(id *)(*((void *)&v15 + 1) + 8 * i) UTF8String];
          *(_DWORD *)unint64_t v23 = 136315394;
          long long v24 = "operator()";
          __int16 v25 = 2080;
          id v26 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: [%s]", v23, 0x16u);
        }
      }
      id v9 = [v4 countByEnumeratingWithState:&v15 objects:buf count:16];
    }
    while (v9);
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
}

uint64_t sub_100F0120C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A6BE70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F0124C()
{
  return &off_101A6BE70;
}

void *sub_100F01258(void *a1, void *a2)
{
  id v3 = (void *)a2[1];
  *a1 = *a2;
  if (v3) {
    id v3 = _Block_copy(v3);
  }
  a1[1] = v3;
  return a1;
}

void sub_100F01294(const void *a1)
{
  if (a1) {
    _Block_release(a1);
  }
}

id sub_100F012B4(uint64_t a1, void *a2)
{
  return [*(id *)(a1 + 32) addObject:*a2];
}

uint64_t sub_100F012C0()
{
  qword_101B13F38 = 0;
  return __cxa_atexit((void (*)(void *))sub_100200A44, &qword_101B13F38, (void *)&_mh_execute_header);
}

uint64_t sub_100F012E8(uint64_t a1)
{
  sub_1004EC6A0(a1 + 16, *(void **)(a1 + 24));
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }
  return a1;
}

const void **sub_100F01324(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v6 = (uint64_t **)(a1 + 2);
  id v7 = (uint64_t *)sub_100046F68((uint64_t)(a1 + 2), (void **)a2);
  id v8 = a1 + 3;
  if (a1 + 3 != v7)
  {
    id v9 = v7;
    sub_10006C514(v6, v7);
    sub_1001FEC1C((uint64_t)(v9 + 4));
    operator delete(v9);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v24, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long v24 = *(_OWORD *)a2;
    uint64_t v25 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v25) < 0)
  {
    sub_10004FC84(__dst, v24[0], (unint64_t)v24[1]);
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v24;
    uint64_t v29 = v25;
  }
  size_t v27 = 0;
  if (SHIBYTE(v29) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)__dst;
    uint64_t v33 = v29;
  }
  unint64_t v30 = 0;
  if (ctu::cf::convert_copy())
  {
    uint64_t v10 = v27;
    size_t v27 = v30;
    char v31 = v10;
    sub_1000558F4(&v31);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  id v26 = v27;
  size_t v27 = 0;
  sub_1000558F4(&v27);
  if (SHIBYTE(v29) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  uint64_t v11 = *a1;
  BOOL v12 = (char *)operator new(0x60uLL);
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  *(void *)BOOL v12 = off_101A6BE90;
  id v13 = v12 + 24;
  sub_100083DA4((const void **)__dst, &v26);
  uint64_t v14 = a1[1];
  if (v14) {
    dispatch_retain((dispatch_object_t)a1[1]);
  }
  sub_100661C4C((uint64_t)__p, a3);
  *id v13 = 0;
  *((void *)v12 + 4) = 0;
  *((void *)v12 + 5) = v11;
  sub_100083DA4((const void **)v12 + 6, (const void **)__dst);
  *((void *)v12 + 7) = v14;
  sub_100661C4C((uint64_t)(v12 + 64), (uint64_t)__p);
  CFNotificationCenterAddObserver(*((CFNotificationCenterRef *)v12 + 5), v13, (CFNotificationCallback)sub_100F01A34, *((CFStringRef *)v12 + 6), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_1001472DC(__p);
  sub_1000558F4((const void **)__dst);
  long long v15 = (std::__shared_weak_count *)*((void *)v12 + 4);
  if (!v15)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v12 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v12 + 2, 1uLL, memory_order_relaxed);
    *((void *)v12 + 3) = v12 + 24;
    *((void *)v12 + 4) = v12;
    goto LABEL_26;
  }
  if (v15->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v12 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v12 + 2, 1uLL, memory_order_relaxed);
    *((void *)v12 + 3) = v12 + 24;
    *((void *)v12 + 4) = v12;
    std::__shared_weak_count::__release_weak(v15);
LABEL_26:
    sub_10004D2C8((std::__shared_weak_count *)v12);
  }
  long long v16 = (void *)*v8;
  long long v17 = a1 + 3;
  long long v18 = a1 + 3;
  if (!*v8) {
    goto LABEL_37;
  }
  long long v17 = a1 + 3;
  while (1)
  {
    while (1)
    {
      long long v18 = v16;
      __int16 v19 = v16 + 4;
      if ((sub_100046FE8((void *)a2, (void **)v16 + 4) & 0x80) == 0) {
        break;
      }
      long long v16 = (void *)*v18;
      long long v17 = v18;
      if (!*v18) {
        goto LABEL_37;
      }
    }
    if ((sub_100046FE8(v19, (void **)a2) & 0x80) == 0) {
      break;
    }
    long long v17 = v18 + 1;
    long long v16 = (void *)v18[1];
    if (!v16) {
      goto LABEL_37;
    }
  }
  if (*v17)
  {
    sub_10004D2C8((std::__shared_weak_count *)v12);
  }
  else
  {
LABEL_37:
    uint64_t v33 = 0;
    unsigned int v20 = operator new(0x48uLL);
    __p[0] = v20;
    __p[1] = a1 + 3;
    __int16 v21 = v20 + 4;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v21, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)__int16 v21 = *(_OWORD *)a2;
      v20[6] = *(void *)(a2 + 16);
    }
    v20[7] = v13;
    char v20[8] = v12;
    LOBYTE(v33) = 1;
    *unsigned int v20 = 0;
    v20[1] = 0;
    v20[2] = v18;
    *long long v17 = v20;
    id v22 = (uint64_t *)**v6;
    if (v22)
    {
      *int v6 = v22;
      unsigned int v20 = (void *)*v17;
    }
    sub_100046C90((uint64_t *)a1[3], v20);
    ++a1[4];
    __p[0] = 0;
    sub_1001FEBC4((uint64_t)__p);
  }
  return sub_1000558F4(&v26);
}

void sub_100F016F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_1001FEBC4((uint64_t)&a29);
  sub_10004D2C8(v34);
  sub_1000558F4(&a16);
  _Unwind_Resume(a1);
}

void sub_100F017C8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  long long v7 = 0uLL;
  uint64_t v8 = 0;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext __p = 0uLL;
  uint64_t v6 = 0;
  sub_100661C4C((uint64_t)v9, a3);
  sub_100F01324(a1, (uint64_t)__p, (uint64_t)v9);
  sub_1001472DC(v9);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F01874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F018AC(uint64_t a1)
{
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext __p = 0uLL;
  uint64_t v3 = 0;
  sub_100F01CB8((uint64_t **)(a1 + 16), __p);
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F01910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F01940(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6BE90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F01960(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6BE90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F019B4(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 48);
  CFNotificationCenterRemoveObserver(*(CFNotificationCenterRef *)(a1 + 40), (const void *)(a1 + 24), *(CFNotificationName *)(a1 + 48), 0);
  sub_1001472DC((void *)(a1 + 64));
  uint64_t v3 = *(NSObject **)(a1 + 56);
  if (v3) {
    dispatch_release(v3);
  }
  sub_1000558F4(v2);
  long long v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_100F01A34(int a1, void *a2, int a3, int a4, ctu *this)
{
  if (a2 && a2[8])
  {
    ctu::cf_to_xpc((uint64_t *)&object, this, a2);
    xpc_object_t v6 = object;
    if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t v6 = xpc_null_create();
    }
    xpc_release(object);
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_null_create();
    }
    uint64_t v7 = a2[1];
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
    }
    operator new();
  }
}

void sub_100F01B68(void **a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      long long v4 = v3;
      uint64_t v5 = a1[1];
      if (v5)
      {
        xpc_object_t v6 = *a1;
        xpc_object_t object = v6;
        if (v6) {
          xpc_retain(v6);
        }
        else {
          xpc_object_t object = xpc_null_create();
        }
        uint64_t v7 = v5[8];
        if (!v7) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v7 + 48))(v7, &object);
        xpc_release(object);
        xpc_object_t object = 0;
      }
      sub_10004D2C8(v4);
    }
  }
  sub_100F01C58((uint64_t)a1);
}

void sub_100F01C2C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  sub_10004D2C8(v11);
  sub_100F01C58(v10);
}

void sub_100F01C58(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;

  operator delete();
}

uint64_t sub_100F01CB8(uint64_t **a1, void **a2)
{
  uint64_t v3 = (uint64_t *)sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  long long v4 = v3;
  sub_10006C514(a1, v3);
  sub_1001FEC1C((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1;
}

void *sub_100F01D14(void *a1)
{
  *a1 = off_101A6BEE0;
  a1[1] = 0;
  uint64_t Session = NEPolicyCreateSession();
  a1[1] = Session;
  if (!Session)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "NEPolicyCreateSession failed");
    goto LABEL_6;
  }
  if (!NEPolicySetSessionPriority())
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "NEPolicySetSessionPriority failed");
LABEL_6:
  }
  return a1;
}

void sub_100F01DD8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F01DF0(uint64_t a1)
{
  *(void *)a1 = off_101A6BEE0;
  if (*(void *)(a1 + 8))
  {
    NEPolicyDeleteAll();
    NEPolicyApply();
    CFRelease(*(CFTypeRef *)(a1 + 8));
    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

BOOL sub_100F01E54()
{
  return NEPolicyDeleteAll() != 0;
}

BOOL sub_100F01E78()
{
  return NEPolicyApply() != 0;
}

void sub_100F01EA0(uint64_t a1)
{
  sub_100F01DF0(a1);

  operator delete();
}

uint64_t sub_100F01ED8(uint64_t a1)
{
  return _NEPolicyAdd(*(void *)(a1 + 8));
}

void *sub_100F01EE0(void *a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, NSObject **a6, char *a7)
{
  id v13 = *a6;
  dispatch_object_t object = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  sub_100D81FD0((uint64_t)a1, (uint64_t *)&off_101A6C8F0, a2, a3, a4, a5, &object, a7, 2000);
  if (object) {
    dispatch_release(object);
  }
  *a1 = off_101A6BF58;
  a1[3] = off_101A6C458;
  return a1;
}

void sub_100F01FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  PersonalitySpecific::~PersonalitySpecific(v10);
  _Unwind_Resume(a1);
}

void sub_100F01FF4(uint64_t a1)
{
  sub_100D84338(a1, (uint64_t *)&off_101A6C8F0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100F02024(uint64_t a1)
{
  sub_100D84338(a1 - 24, (uint64_t *)&off_101A6C8F0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100F02058(uint64_t a1)
{
  sub_100D84338(a1, (uint64_t *)&off_101A6C8F0);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100F0209C(uint64_t a1)
{
}

BOOL sub_100F020A4(uint64_t a1, int a2)
{
  return a2 == 0;
}

void sub_100F020B0(Registry **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  if (!a2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1[9]);
    uint64_t v5 = ServiceMap;
    if ((v6 & 0x8000000000000000) != 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        unint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v15 = v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
    if (v10)
    {
      uint64_t v12 = v10[3];
      uint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
        if (!v12)
        {
LABEL_12:
          if ((v13 & 1) == 0) {
            sub_10004D2C8(v11);
          }
          return;
        }
LABEL_11:
        uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 960))(v12, v14, 1);
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
}

void sub_100F021DC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F021F4(Registry **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  if (!a2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1[9]);
    uint64_t v5 = ServiceMap;
    if ((v6 & 0x8000000000000000) != 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        unint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v16 = v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v16);
    if (v10)
    {
      uint64_t v12 = v10[3];
      uint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
        if (!v12)
        {
LABEL_12:
          if ((v13 & 1) == 0) {
            sub_10004D2C8(v11);
          }
          return;
        }
LABEL_11:
        uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 960))(v12, v14, 0);
        uint64_t v15 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v12 + 176))(v12, v15, 27, 0);
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
}

void sub_100F0235C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F02374(Registry **a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  if (!a2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(a3, a1[9]);
    uint64_t v5 = ServiceMap;
    if ((v6 & 0x8000000000000000) != 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        unint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v16 = v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v16);
    if (v10)
    {
      uint64_t v12 = v10[3];
      uint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
        if (!v12)
        {
LABEL_12:
          if ((v13 & 1) == 0) {
            sub_10004D2C8(v11);
          }
          return;
        }
LABEL_11:
        uint64_t v14 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 960))(v12, v14, 0);
        uint64_t v15 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v12 + 176))(v12, v15, 28, 0);
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
}

void sub_100F024DC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F024F4(uint64_t a1, int a2)
{
  return a2 == 0;
}

BOOL sub_100F02500(uint64_t a1, int a2)
{
  return a2 == 0;
}

void *sub_100F0250C(void *a1)
{
  *a1 = off_101A6DDB8;
  char v2 = a1[3];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100F02568(void *a1)
{
  sub_100F0250C(a1);

  operator delete();
}

void sub_100F025A0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F02650(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v33 = 0;
  uint64_t v34 = a5;
  uint64_t v32 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a6, *(Registry **)(a1 + 8));
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v26 = v12;
  unint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v26);
  if (v16)
  {
    uint64_t v18 = v16[3];
    long long v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  long long v17 = 0;
  char v19 = 1;
LABEL_9:
  unsigned int v20 = (capabilities::ct *)(*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(&v32, v18, a2);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if (!v32) {
    goto LABEL_38;
  }
  uint64_t v21 = *(unsigned __int8 *)(a3 + 23);
  if (*(char *)(a3 + 23) < 0)
  {
    if (*(void *)(a3 + 8)) {
      goto LABEL_20;
    }
  }
  else if (*(unsigned char *)(a3 + 23))
  {
    goto LABEL_20;
  }
  if (!*(unsigned char *)(a3 + 168))
  {
LABEL_20:
    if ((v21 & 0x80) != 0) {
      uint64_t v21 = *(void *)(a3 + 8);
    }
    if (!v21) {
      goto LABEL_38;
    }
    goto LABEL_23;
  }
  if (*(char *)(a3 + 127) < 0)
  {
    if (!*(void *)(a3 + 112)) {
      goto LABEL_38;
    }
  }
  else if (!*(unsigned char *)(a3 + 127))
  {
LABEL_38:
    uint64_t v23 = 0;
    long long v24 = 0;
    (*(void (**)(uint64_t, uint64_t *, void))(v34 + 16))(v34, &v23, 0);
    if (v24) {
      sub_10004D2C8(v24);
    }
    goto LABEL_40;
  }
LABEL_23:
  long long v26 = 0u;
  *(_OWORD *)size_t v27 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  BYTE3(v26) = a4;
  uint64_t v31 = 0;
  uint64_t v25 = 0;
  if (*(unsigned char *)(a3 + 168) && *(unsigned char *)(a3 + 140) && *(_DWORD *)(a3 + 136) == 3
    || capabilities::ct::supportsSIMProvisioningAsSignupDestination(v20))
  {
    int v22 = 11;
  }
  else
  {
    if ((*(uint64_t (**)(uint64_t, void, const __CFString *))(*(void *)v32 + 88))(v32, 0, @"SupportManageAccountUrlOverEntitlement"))goto LABEL_31; {
    int v22 = 10;
    }
  }
  LODWORD(v25) = v22;
  BYTE4(v25) = 1;
LABEL_31:
  (*(void (**)(uint64_t, void, long long *, uint64_t *, uint64_t, uint64_t, uint64_t *))(*(void *)v32 + 152))(v32, 0, &v26, &v25, a3, a1 + 24, &v34);
  if ((_BYTE)v31 && SHIBYTE(v30) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && SHIBYTE(v28) < 0) {
    operator delete(v27[1]);
  }
LABEL_40:
  if (v33) {
    sub_10004D2C8(v33);
  }
}

void sub_100F02918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, char a13)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (*(void *)(v13 - 96)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v13 - 96));
  }
  _Unwind_Resume(exception_object);
}

void sub_100F02950()
{
  if (v0) {
    JUMPOUT(0x100F02948);
  }
  JUMPOUT(0x100F02940);
}

void sub_100F02960(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v33 = 0;
  uint64_t v34 = a4;
  uint64_t v32 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a5, *(Registry **)(a1 + 8));
  unsigned int v9 = ServiceMap;
  if (v10 < 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v26 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v26);
  if (v14)
  {
    uint64_t v16 = v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v16 + 8))(&v32, v16, a2);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  uint64_t v18 = v32;
  if (v32)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      if (*(void *)(a3 + 8))
      {
LABEL_14:
        long long v26 = 0u;
        *(_OWORD *)size_t v27 = 0u;
        *(_OWORD *)OsLogContext __p = 0u;
        long long v30 = 0u;
        long long v28 = 0u;
        BYTE3(v26) = 1;
        uint64_t v31 = 0;
        uint64_t v25 = &_mh_execute_header;
        if (*(unsigned char *)(a3 + 216)
          && ((int v19 = *(char *)(a3 + 215), v19 >= 0)
            ? (size_t v20 = *(unsigned __int8 *)(a3 + 215))
            : (size_t v20 = *(void *)(a3 + 200)),
              v20 == strlen(entitlements::kServiceTypeiPadSignup)
           && (v19 >= 0 ? (uint64_t v21 = (const void *)(a3 + 192)) : (uint64_t v21 = *(const void **)(a3 + 192)),
               !memcmp(v21, entitlements::kServiceTypeiPadSignup, v20))))
        {
          int v22 = 16;
        }
        else if (*(unsigned char *)(a3 + 188) && (*(unsigned char *)(a3 + 184) & 2) != 0)
        {
          int v22 = 11;
        }
        else
        {
          int v22 = 10;
        }
        LODWORD(v25) = v22;
        (*(void (**)(uint64_t, void, long long *, const mach_header_64 **, uint64_t, uint64_t, uint64_t *))(*(void *)v18 + 160))(v18, 0, &v26, &v25, a3, a1 + 24, &v34);
        if ((_BYTE)v31 && SHIBYTE(v30) < 0) {
          operator delete(__p[1]);
        }
        if (LOBYTE(__p[0]) && SHIBYTE(v28) < 0) {
          operator delete(v27[1]);
        }
        goto LABEL_37;
      }
    }
    else if (*(unsigned char *)(a3 + 23))
    {
      goto LABEL_14;
    }
  }
  uint64_t v23 = 0;
  long long v24 = 0;
  (*(void (**)(uint64_t, uint64_t *, void))(v34 + 16))(v34, &v23, 0);
  if (v24) {
    sub_10004D2C8(v24);
  }
LABEL_37:
  if (v33) {
    sub_10004D2C8(v33);
  }
}

void sub_100F02BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10016A3E8((uint64_t)va);
  if (*(void *)(v5 - 80)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v5 - 80));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F02C40@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v18 = 0;
  int v19 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 8));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v20);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 8))(&v18, v14, a2);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (v18) {
    uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 304))(v18, a3);
  }
  else {
    uint64_t v16 = 3;
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  return v16;
}

void sub_100F02DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F02DDC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (Registry **)(a1 + 8);
  subscriber::makeSimSlotRange();
  uint64_t v5 = v23;
  long long v4 = v24;
  if (v23 != v24)
  {
    unint64_t v6 = v25;
    while ((v25(*v5) & 1) == 0)
    {
      if (++v5 == v24)
      {
        uint64_t v5 = v24;
        break;
      }
    }
    unint64_t v8 = v24;
    if (v5 != v24)
    {
      while (1)
      {
        uint64_t v9 = *v5;
        uint64_t v21 = 0;
        int v22 = 0;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *v3);
        unsigned int v11 = ServiceMap;
        if ((v12 & 0x8000000000000000) != 0)
        {
          unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v14 = 5381;
          do
          {
            unint64_t v12 = v14;
            unsigned int v15 = *v13++;
            uint64_t v14 = (33 * v14) ^ v15;
          }
          while (v15);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v26 = v12;
        uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v26);
        if (!v16) {
          break;
        }
        uint64_t v18 = v16[3];
        char v17 = (std::__shared_weak_count *)v16[4];
        if (!v17) {
          goto LABEL_14;
        }
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v9 = v9;
        sub_10004D2C8(v17);
        char v19 = 0;
LABEL_15:
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(&v21, v18, v9);
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        if (v21) {
          (*(void (**)(uint64_t, void))(*(void *)v21 + 312))(v21, a3);
        }
        if (v22) {
          sub_10004D2C8(v22);
        }
        uint64_t v7 = (uint64_t *)(v5 + 1);
        uint64_t v5 = v4;
        if (v7 != (uint64_t *)v4)
        {
          uint64_t v5 = (unsigned int *)v7;
          while ((v6(*v5) & 1) == 0)
          {
            if (++v5 == v4)
            {
              uint64_t v5 = v4;
              break;
            }
          }
        }
        if (v5 == v8) {
          return;
        }
      }
      uint64_t v18 = 0;
LABEL_14:
      std::mutex::unlock(v11);
      char v17 = 0;
      char v19 = 1;
      goto LABEL_15;
    }
  }
}

void sub_100F02FE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F03014(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v24 = a3;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 8));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v16 = v8;
  unint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v16);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v14 + 8))(&v22, v14, a2);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (v22)
  {
    long long v16 = 0u;
    *(_OWORD *)char v17 = 0u;
    *(_OWORD *)OsLogContext __p = 0u;
    long long v20 = 0u;
    long long v18 = 0u;
    BYTE3(v16) = 1;
    DWORD1(v16) = 15;
    BYTE8(v16) = 1;
    HIDWORD(v16) = 1;
    LOBYTE(v17[0]) = 1;
    uint64_t v21 = 0;
    (*(void (**)(uint64_t, uint64_t, long long *, char *, uint64_t, uint64_t *))(*(void *)v22 + 184))(v22, 8, &v16, &v25, a1 + 24, &v24);
    if ((_BYTE)v21 && SHIBYTE(v20) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && SHIBYTE(v18) < 0) {
      operator delete(v17[1]);
    }
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
}

void sub_100F031E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(a1);
}

void sub_100F03218(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v26 = a4;
  uint64_t v24 = 0;
  char v25 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a5, *(Registry **)(a1 + 8));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v18 = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&v18);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v16 + 8))(&v24, v16, a2);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v24)
  {
    long long v18 = 0u;
    *(_OWORD *)char v19 = 0u;
    *(_OWORD *)OsLogContext __p = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    BYTE3(v18) = 1;
    DWORD1(v18) = 15;
    BYTE8(v18) = 1;
    HIDWORD(v18) = 1;
    LOBYTE(v19[0]) = 1;
    uint64_t v23 = 0;
    (*(void (**)(uint64_t, uint64_t, long long *, uint64_t, uint64_t, uint64_t *))(*(void *)v24 + 192))(v24, 8, &v18, a3, a1 + 24, &v26);
    if ((_BYTE)v23 && SHIBYTE(v22) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && SHIBYTE(v20) < 0) {
      operator delete(v19[1]);
    }
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100F033EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(a1);
}

void sub_100F03420(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v28 = a5;
  uint64_t v26 = 0;
  size_t v27 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a6, *(Registry **)(a1 + 8));
  unsigned int v11 = ServiceMap;
  if ((v12 & 0x8000000000000000) != 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      unint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v20);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
LABEL_9:
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 8))(&v26, v18, a2);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if (v26)
  {
    long long v21 = 0u;
    long long v25 = 0u;
    *(_OWORD *)OsLogContext __p = 0u;
    long long v23 = 0u;
    *(_OWORD *)long long v22 = 0u;
    LOBYTE(v20) = a4;
    *(_WORD *)((char *)&v20 + 1) = 0;
    BYTE3(v20) = 1;
    HIDWORD(v20) = 15;
    LOBYTE(v21) = 1;
    DWORD1(v21) = 1;
    BYTE8(v21) = 1;
    BYTE8(v25) = 0;
    (*(void (**)(uint64_t, uint64_t, unint64_t *, uint64_t, uint64_t, uint64_t *))(*(void *)v26 + 200))(v26, 8, &v20, a3, a1 + 24, &v28);
    if (BYTE8(v25) && SBYTE7(v25) < 0) {
      operator delete(__p[0]);
    }
    if (BYTE8(v23) && SBYTE7(v23) < 0) {
      operator delete(v22[0]);
    }
  }
  if (v27) {
    sub_10004D2C8(v27);
  }
}

void sub_100F0360C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(a1);
}

void sub_100F03640(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F036A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F036E4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F0371C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F0374C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F03790(unsigned int *a1, char *a2, _DWORD *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t result = sub_1007E37A0(a1, (uint64_t)&v7, 0);
  if (!result)
  {
    if (v7 == 0x2000000000000010) {
      uint64_t result = sub_1007E3970((uint64_t)&v8, 6u, (uint64_t)&unk_10158CF38, a2, 0);
    }
    else {
      uint64_t result = 2;
    }
  }
  *a3 = v8 + v9 - *a1;
  return result;
}

void sub_100F03838(std::exception *a1)
{
  std::exception::~exception(a1);

  operator delete();
}

void sub_100F03874(std::exception *a1)
{
  std::exception::~exception(a1);

  operator delete();
}

void sub_100F038BC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12F18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12F18))
  {
    sub_10095400C((uint64_t)xmmword_101B12F20, " \f\n\r\t\v", "()=<>", 0);
    __cxa_atexit((void (*)(void *))sub_100953D88, xmmword_101B12F20, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B12F18);
  }
  memset(v36, 0, sizeof(v36));
  uint64_t v6 = sub_1009540A4((uint64_t)v36, a1, xmmword_101B12F20);
  *(_OWORD *)uint64_t v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  *(_OWORD *)long long v30 = 0u;
  long long v31 = 0u;
  *(_OWORD *)uint64_t v29 = 0u;
  sub_100953DCC(v6, (char *)v29);
  *(_OWORD *)size_t v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)long long v22 = 0u;
  sub_100953EC0((uint64_t)v36, (char *)v22);
  uint64_t v8 = *(void **)a2;
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 8);
  uint64_t v9 = operator new(0x68uLL);
  v9[1] = 0;
  void v9[2] = 0;
  void *v9 = off_101A6E098;
  v13[0] = v8;
  v13[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F04694((uint64_t)(v9 + 3), (uint64_t)v29, (uint64_t)v22, (uint64_t *)v13, a3);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  sub_100953EC0((uint64_t)v36, (char *)v13);
  if (v19 && LOBYTE(v34[0]))
  {
    if (v17 != (void)v33)
    {
      char v10 = 0;
      goto LABEL_14;
    }
    BOOL v11 = v18 == *((void *)&v33 + 1);
  }
  else
  {
    BOOL v11 = v19 == LOBYTE(v34[0]);
  }
  char v10 = v11;
LABEL_14:
  if (v21 < 0) {
    operator delete(__p);
  }
  if (v16 < 0) {
    operator delete(v15);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
  if (v10) {
    operator new();
  }
  exception = __cxa_allocate_exception(8uLL);
  void *exception = &off_101A6DFC8;
}

void sub_100F03C08(_Unwind_Exception *a1)
{
}

uint64_t sub_100F03C9C(std::locale::__imp **a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v52 = a5;
  if (*(unsigned char *)(a3 + 80))
  {
    if (!*(unsigned char *)(a2 + 80))
    {
      *a1 = 0;
      a1[1] = 0;
LABEL_83:
      __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
    }
    if (*(void *)(a3 + 64) == *(void *)(a2 + 64) && *(void *)(a3 + 72) == *(void *)(a2 + 72))
    {
LABEL_5:
      exception = __cxa_allocate_exception(8uLL);
      void *exception = &off_101A6DFC8;
    }
  }
  else if (!*(unsigned char *)(a2 + 80))
  {
    goto LABEL_5;
  }
  *a1 = 0;
  a1[1] = 0;
  std::locale::locale(&v51);
  std::locale::locale(v50, &v51);
  int v10 = *(char *)(a2 + 111);
  if (v10 >= 0) {
    BOOL v11 = (char *)(a2 + 88);
  }
  else {
    BOOL v11 = *(char **)(a2 + 88);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 111);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 96);
  }
  if (v12)
  {
    uint64_t v13 = v12 - 1;
    if ((unint64_t)(v12 - 1) >= 4) {
      uint64_t v13 = 4;
    }
    uint64_t v14 = v13 + 1;
    unsigned int v15 = "false";
    char v16 = v11;
    while (sub_100326220(v50, v16, v15))
    {
      ++v16;
      ++v15;
      if (!--v14) {
        goto LABEL_21;
      }
    }
    std::locale::~locale(v50);
    std::locale::~locale(&v51);
  }
  else
  {
    unsigned int v15 = "false";
    char v16 = v11;
LABEL_21:
    std::locale::~locale(v50);
    std::locale::~locale(&v51);
    if (v16 == &v11[v12] && v15 == "")
    {
      uint64_t v18 = *a4;
      unsigned __int8 v19 = (std::__shared_weak_count *)a4[1];
      char v20 = 0;
LABEL_46:
      sub_100F053FC(v50, v20, v18, v19, &v52);
      locale = v50[1].__locale_;
      *a1 = v50[0].__locale_;
LABEL_47:
      a1[1] = locale;
      return sub_1009545B0(a2);
    }
  }
  if (!*(unsigned char *)(a2 + 80)) {
    goto LABEL_83;
  }
  std::locale::locale(&v51);
  std::locale::locale(v50, &v51);
  int v21 = *(char *)(a2 + 111);
  if (v21 >= 0) {
    long long v22 = (char *)(a2 + 88);
  }
  else {
    long long v22 = *(char **)(a2 + 88);
  }
  if (v21 >= 0) {
    uint64_t v23 = *(unsigned __int8 *)(a2 + 111);
  }
  else {
    uint64_t v23 = *(void *)(a2 + 96);
  }
  if (v23)
  {
    uint64_t v24 = v23 - 1;
    if ((unint64_t)(v23 - 1) >= 3) {
      uint64_t v24 = 3;
    }
    uint64_t v25 = v24 + 1;
    long long v26 = "true";
    size_t v27 = v22;
    while (sub_100326220(v50, v27, v26))
    {
      ++v27;
      ++v26;
      if (!--v25) {
        goto LABEL_43;
      }
    }
    std::locale::~locale(v50);
    std::locale::~locale(&v51);
    goto LABEL_49;
  }
  long long v26 = "true";
  size_t v27 = v22;
LABEL_43:
  std::locale::~locale(v50);
  std::locale::~locale(&v51);
  if (v27 == &v22[v23] && v26 == "")
  {
    uint64_t v18 = *a4;
    unsigned __int8 v19 = (std::__shared_weak_count *)a4[1];
    char v20 = 1;
    goto LABEL_46;
  }
LABEL_49:
  if (!*(unsigned char *)(a2 + 80)) {
    goto LABEL_83;
  }
  if (*(char *)(a2 + 111) >= 0) {
    uint64_t v29 = (char *)(a2 + 88);
  }
  else {
    uint64_t v29 = *(char **)(a2 + 88);
  }
  int v30 = *v29;
  if ((v30 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[v30] & 0x400) != 0)
  {
    v50[0].__locale_ = 0;
    int v39 = std::stoi((const std::string *)(a2 + 88), (size_t *)v50, 10);
    if (!*(unsigned char *)(a2 + 80)) {
      __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
    }
    std::string v40 = (std::locale::__imp *)*(unsigned __int8 *)(a2 + 111);
    if ((char)v40 < 0) {
      std::string v40 = *(std::locale::__imp **)(a2 + 96);
    }
    if (v50[0].__locale_ < v40)
    {
      char v49 = __cxa_allocate_exception(8uLL);
      *char v49 = &off_101A6DFC8;
    }
    int v41 = v39;
    uint64_t v43 = *a4;
    std::string v42 = (std::__shared_weak_count *)a4[1];
    long long v44 = (std::locale::__imp *)operator new(0x50uLL);
    locale = v44;
    *((void *)v44 + 1) = 0;
    *((void *)v44 + 2) = 0;
    *(void *)long long v44 = off_101A6E160;
    int64_t v45 = (std::locale::__imp *)((char *)v44 + 24);
    if (v42)
    {
      atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *((_DWORD *)v44 + 6) = v41;
      *((_DWORD *)v44 + 7) = 1;
      *((void *)v44 + 4) = 0;
      *((void *)v44 + 5) = 0;
      *((void *)v44 + 6) = 0;
      *((void *)v44 + 7) = v43;
      *((void *)v44 + 8) = v42;
      atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      *((void *)v44 + 9) = a5;
      std::__shared_weak_count::__release_weak(v42);
    }
    else
    {
      *((_DWORD *)v44 + 6) = v41;
      *((_DWORD *)v44 + 7) = 1;
      *((void *)v44 + 4) = 0;
      *((void *)v44 + 5) = 0;
      *((void *)v44 + 6) = 0;
      *((void *)v44 + 7) = v43;
      *((void *)v44 + 8) = 0;
      *((void *)v44 + 9) = a5;
    }
    *a1 = v45;
    goto LABEL_47;
  }
  long long v31 = (std::__shared_weak_count *)a4[1];
  if (!v31 || (long long v32 = std::__shared_weak_count::lock(v31)) == 0 || !*a4)
  {
    char v47 = __cxa_allocate_exception(8uLL);
    *char v47 = &off_101A6DFC8;
  }
  if (!*(unsigned char *)(a2 + 80)) {
    __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
  }
  int v33 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*a4 + 16))(*a4, a2 + 88);
  if (v33 == 2)
  {
    char v48 = __cxa_allocate_exception(8uLL);
    void *v48 = &off_101A6DFC8;
  }
  if (!*(unsigned char *)(a2 + 80)) {
    __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
  }
  uint64_t v35 = *a4;
  uint64_t v34 = (std::__shared_weak_count *)a4[1];
  char v36 = (char *)operator new(0x50uLL);
  uint64_t v37 = v36;
  *((void *)v36 + 1) = 0;
  *((void *)v36 + 2) = 0;
  *(void *)char v36 = off_101A6E160;
  if (v34) {
    atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v36[24] = 0;
  *((_DWORD *)v36 + 7) = v33;
  std::string v38 = v36 + 32;
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84(v38, *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    *(_OWORD *)std::string v38 = *(_OWORD *)(a2 + 88);
    v37[6] = *(void *)(a2 + 104);
  }
  v37[7] = v35;
  v37[8] = v34;
  if (v34)
  {
    atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v37[9] = a5;
    std::__shared_weak_count::__release_weak(v34);
  }
  else
  {
    v37[9] = a5;
  }
  *a1 = (std::locale::__imp *)(v37 + 3);
  a1[1] = (std::locale::__imp *)v37;
  sub_10004D2C8(v32);
  return sub_1009545B0(a2);
}

void sub_100F042A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11)
{
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  std::__shared_weak_count::~__shared_weak_count(v12);
  operator delete(v16);
  sub_10004D2C8(v13);
  if (*(void *)(v11 + 8)) {
    sub_10004D2C8(*(std::__shared_weak_count **)(v11 + 8));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F04328(uint64_t result, char a2)
{
  if (*(_DWORD *)(result + 4))
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = &off_101A6DFF0;
  }
  *(unsigned char *)uint64_t result = a2;
  return result;
}

_DWORD *sub_100F04388(_DWORD *result, _DWORD *a2)
{
  if (result[1] != a2[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = &off_101A6DFF0;
  }
  *uint64_t result = *a2;
  return result;
}

void sub_100F043F4(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0)
  {
    if (!*(void *)(a1 + 16)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 31))
  {
    return;
  }
  char v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      long long v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 24))(v5, a1);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100F04494(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100F044A8(uint64_t a1)
{
  uint64_t v1 = *(int **)(a1 + 48);
  if (!v1)
  {
    uint64_t v7 = *(unsigned __int8 **)(a1 + 32);
    if (!*((_DWORD *)v7 + 1)) {
      return *v7 != 0;
    }
    goto LABEL_20;
  }
  int v2 = *(_DWORD *)(a1 + 64);
  if (v2 == 2)
  {
    uint64_t v9 = *(int **)(a1 + 32);
    if (v9[1] == 1 && v1[1] == 1)
    {
      sub_100F043F4(*(void *)(a1 + 32));
      sub_100F043F4((uint64_t)v1);
      return *v9 > *v1;
    }
    goto LABEL_20;
  }
  if (v2 == 1)
  {
    int v10 = *(int **)(a1 + 32);
    if (v10[1] == 1 && v1[1] == 1)
    {
      sub_100F043F4(*(void *)(a1 + 32));
      sub_100F043F4((uint64_t)v1);
      return *v10 < *v1;
    }
    goto LABEL_20;
  }
  if (v2) {
    return 0;
  }
  uint64_t v3 = *(int **)(a1 + 32);
  int v4 = v3[1];
  if (v4 == 2 || v4 != v1[1])
  {
LABEL_20:
    exception = __cxa_allocate_exception(8uLL);
    void *exception = &off_101A6DFF0;
  }
  sub_100F043F4(*(void *)(a1 + 32));
  sub_100F043F4((uint64_t)v1);
  if (v3[1])
  {
    int v5 = *v3;
    int v6 = *v1;
  }
  else
  {
    int v5 = *(unsigned __int8 *)v3;
    int v6 = *(unsigned __int8 *)v1;
  }
  return v5 == v6;
}

uint64_t sub_100F04618(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))();
}

uint64_t sub_100F04640(uint64_t a1)
{
  BOOL v1 = *(unsigned char *)(a1 + 32) != 0;
  return v1 ^ (*(unsigned int (**)(void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40));
}

uint64_t sub_100F04694(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = *a4;
  uint64_t v8 = (std::__shared_weak_count *)a4[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)a1 = off_101A6DED0;
  *(void *)(a1 + 8) = v9;
  long long v71 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = v8;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a1 + 24) = a5;
    int v10 = (uint64_t *)(a1 + 24);
    std::__shared_weak_count::__release_weak(v8);
  }
  else
  {
    *(void *)(a1 + 24) = a5;
    int v10 = (uint64_t *)(a1 + 24);
  }
  *(void *)a1 = off_101A6DFA0;
  *(_OWORD *)(a1 + 32) = 0u;
  BOOL v70 = (int64x2_t *)(a1 + 32);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  sub_100F056DC(v72, a2, a3, v71, v10);
  unint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(_OWORD **)(a1 + 40);
  if ((unint64_t)v12 >= v11)
  {
    uint64_t v14 = ((uint64_t)v12 - v70->i64[0]) >> 4;
    if ((unint64_t)(v14 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v15 = v11 - v70->i64[0];
    uint64_t v16 = v15 >> 3;
    if (v15 >> 3 <= (unint64_t)(v14 + 1)) {
      uint64_t v16 = v14 + 1;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v16;
    }
    uint64_t v76 = a1 + 48;
    uint64_t v18 = (char *)sub_1009C886C(v17);
    unsigned __int8 v19 = &v18[16 * v14];
    uint64_t v75 = &v18[16 * v20];
    *(_OWORD *)unsigned __int8 v19 = *(_OWORD *)&v72[0].__locale_;
    uint64_t v13 = v19 + 16;
    v74.i64[1] = (uint64_t)(v19 + 16);
    long long v22 = *(void **)(a1 + 32);
    int v21 = *(void **)(a1 + 40);
    if (v21 != v22)
    {
      do
      {
        long long v23 = *((_OWORD *)v21 - 1);
        v21 -= 2;
        *((_OWORD *)v19 - 1) = v23;
        v19 -= 16;
        *int v21 = 0;
        v21[1] = 0;
      }
      while (v21 != v22);
      int64x2_t v24 = *v70;
      uint64_t v13 = (_OWORD *)v74.i64[1];
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  *uint64_t v12 = *(_OWORD *)&v72[0].__locale_;
  uint64_t v13 = v12 + 1;
  while (1)
  {
    *(void *)(a1 + 40) = v13;
    if (*(unsigned char *)(a3 + 80))
    {
      if (!*(unsigned char *)(a2 + 80)) {
        goto LABEL_106;
      }
      if (*(void *)(a3 + 64) == *(void *)(a2 + 64) && *(void *)(a3 + 72) == *(void *)(a2 + 72)) {
        return a1;
      }
    }
    else if (!*(unsigned char *)(a2 + 80))
    {
      return a1;
    }
    std::locale::locale(v72);
    std::locale::locale(&v73, v72);
    int v26 = *(char *)(a2 + 111);
    uint64_t v27 = v26 >= 0 ? a2 + 88 : *(void *)(a2 + 88);
    uint64_t v28 = v26 >= 0 ? *(unsigned __int8 *)(a2 + 111) : *(void *)(a2 + 96);
    if (v28) {
      break;
    }
    long long v32 = (char *)v27;
    long long v31 = "and";
LABEL_39:
    std::locale::~locale(&v73);
    std::locale::~locale(v72);
    if (v32 != (char *)(v27 + v28) || v31 != "") {
      goto LABEL_47;
    }
    uint64_t v35 = *(char **)(a1 + 64);
    unint64_t v34 = *(void *)(a1 + 72);
    if ((unint64_t)v35 >= v34)
    {
      char v46 = *(char **)(a1 + 56);
      uint64_t v53 = (v35 - v46) >> 2;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v55 = v34 - (void)v46;
      if (v55 >> 1 > v54) {
        unint64_t v54 = v55 >> 1;
      }
      BOOL v50 = (unint64_t)v55 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v50) {
        unint64_t v51 = v54;
      }
      if (v51)
      {
        unint64_t v51 = (unint64_t)sub_1000492A8(v51);
        char v46 = *(char **)(a1 + 56);
        uint64_t v35 = *(char **)(a1 + 64);
      }
      else
      {
        uint64_t v52 = 0;
      }
      long long v56 = (_DWORD *)(v51 + 4 * v53);
      *long long v56 = 0;
      int64_t v45 = v56 + 1;
      while (v35 != v46)
      {
        int v58 = *((_DWORD *)v35 - 1);
        v35 -= 4;
        *--long long v56 = v58;
      }
      goto LABEL_90;
    }
    *(_DWORD *)uint64_t v35 = 0;
    char v36 = v35 + 4;
LABEL_67:
    int64_t v45 = v36;
LABEL_92:
    *(void *)(a1 + 64) = v45;
    sub_1009545B0(a2);
    sub_100F056DC(v72, a2, a3, v71, v10);
    long long v60 = *(_OWORD **)(a1 + 40);
    unint64_t v59 = *(void *)(a1 + 48);
    if ((unint64_t)v60 >= v59)
    {
      uint64_t v61 = ((uint64_t)v60 - v70->i64[0]) >> 4;
      if ((unint64_t)(v61 + 1) >> 60) {
        sub_10006A748();
      }
      uint64_t v62 = v59 - v70->i64[0];
      uint64_t v63 = v62 >> 3;
      if (v62 >> 3 <= (unint64_t)(v61 + 1)) {
        uint64_t v63 = v61 + 1;
      }
      if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v64 = v63;
      }
      uint64_t v76 = a1 + 48;
      long long v65 = (char *)sub_1009C886C(v64);
      unsigned __int8 v19 = &v65[16 * v61];
      uint64_t v75 = &v65[16 * v66];
      *(_OWORD *)unsigned __int8 v19 = *(_OWORD *)&v72[0].__locale_;
      uint64_t v13 = v19 + 16;
      v74.i64[1] = (uint64_t)(v19 + 16);
      uint64_t v67 = *(void **)(a1 + 32);
      int v21 = *(void **)(a1 + 40);
      if (v21 == v67)
      {
LABEL_17:
        int64x2_t v24 = vdupq_n_s64((unint64_t)v21);
      }
      else
      {
        do
        {
          long long v68 = *((_OWORD *)v21 - 1);
          v21 -= 2;
          *((_OWORD *)v19 - 1) = v68;
          v19 -= 16;
          *int v21 = 0;
          v21[1] = 0;
        }
        while (v21 != v67);
        int64x2_t v24 = *v70;
        uint64_t v13 = (_OWORD *)v74.i64[1];
      }
LABEL_18:
      *(void *)(a1 + 32) = v19;
      *(void *)(a1 + 40) = v13;
      int64x2_t v74 = v24;
      uint64_t v25 = *(char **)(a1 + 48);
      *(void *)(a1 + 48) = v75;
      uint64_t v75 = v25;
      v73.__locale_ = (std::locale::__imp *)v24.i64[0];
      sub_10019E528((uint64_t)&v73);
    }
    else
    {
      _OWORD *v60 = *(_OWORD *)&v72[0].__locale_;
      uint64_t v13 = v60 + 1;
    }
  }
  uint64_t v29 = v28 - 1;
  if ((unint64_t)(v28 - 1) >= 2) {
    uint64_t v29 = 2;
  }
  uint64_t v30 = v29 + 1;
  long long v31 = "and";
  long long v32 = (char *)v27;
  while (sub_100326220(&v73, v32, v31))
  {
    ++v32;
    ++v31;
    if (!--v30) {
      goto LABEL_39;
    }
  }
  std::locale::~locale(&v73);
  std::locale::~locale(v72);
LABEL_47:
  if (!*(unsigned char *)(a2 + 80)) {
LABEL_106:
  }
    __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
  std::locale::locale(v72);
  std::locale::locale(&v73, v72);
  int v37 = *(char *)(a2 + 111);
  if (v37 >= 0) {
    std::string v38 = (char *)(a2 + 88);
  }
  else {
    std::string v38 = *(char **)(a2 + 88);
  }
  if (v37 >= 0) {
    uint64_t v39 = *(unsigned __int8 *)(a2 + 111);
  }
  else {
    uint64_t v39 = *(void *)(a2 + 96);
  }
  if (!v39)
  {
    std::string v42 = v38;
    int v41 = "or";
LABEL_63:
    std::locale::~locale(&v73);
    std::locale::~locale(v72);
    if (v42 != &v38[v39] || v41 != "") {
      return a1;
    }
    long long v44 = *(char **)(a1 + 64);
    unint64_t v43 = *(void *)(a1 + 72);
    if ((unint64_t)v44 >= v43)
    {
      char v46 = *(char **)(a1 + 56);
      uint64_t v47 = (v44 - v46) >> 2;
      unint64_t v48 = v47 + 1;
      if ((unint64_t)(v47 + 1) >> 62) {
        sub_10006A748();
      }
      uint64_t v49 = v43 - (void)v46;
      if (v49 >> 1 > v48) {
        unint64_t v48 = v49 >> 1;
      }
      BOOL v50 = (unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL;
      unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v50) {
        unint64_t v51 = v48;
      }
      if (v51)
      {
        unint64_t v51 = (unint64_t)sub_1000492A8(v51);
        char v46 = *(char **)(a1 + 56);
        long long v44 = *(char **)(a1 + 64);
      }
      else
      {
        uint64_t v52 = 0;
      }
      long long v56 = (_DWORD *)(v51 + 4 * v47);
      *long long v56 = 1;
      int64_t v45 = v56 + 1;
      while (v44 != v46)
      {
        int v57 = *((_DWORD *)v44 - 1);
        v44 -= 4;
        *--long long v56 = v57;
      }
LABEL_90:
      *(void *)(a1 + 56) = v56;
      *(void *)(a1 + 64) = v45;
      *(void *)(a1 + 72) = v51 + 4 * v52;
      if (v46) {
        operator delete(v46);
      }
      goto LABEL_92;
    }
    *(_DWORD *)long long v44 = 1;
    char v36 = v44 + 4;
    goto LABEL_67;
  }
  if (v39 == 1) {
    uint64_t v40 = 1;
  }
  else {
    uint64_t v40 = 2;
  }
  int v41 = "or";
  std::string v42 = v38;
  while (sub_100326220(&v73, v42, v41))
  {
    ++v42;
    ++v41;
    if (!--v40) {
      goto LABEL_63;
    }
  }
  std::locale::~locale(&v73);
  std::locale::~locale(v72);
  return a1;
}

void sub_100F04CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale::__imp *a11, uint64_t a12, std::locale a13, uint64_t a14, uint64_t a15, std::locale a16)
{
  uint64_t v18 = (void *)v16[7];
  if (v18)
  {
    unsigned char v16[8] = v18;
    operator delete(v18);
  }
  a13.__locale_ = a11;
  sub_10077EE24((void ***)&a13);
  *uint64_t v16 = a9;
  unsigned __int8 v19 = (std::__shared_weak_count *)v16[2];
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F04D40(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(***(void ***)(a1 + 32) + 16))(**(void **)(a1 + 32));
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if ((unint64_t)(v3 - v4) >= 0x11)
  {
    unsigned int v5 = 2;
    unint64_t v6 = 1;
    while (*(_DWORD *)(*(void *)(a1 + 56) + 4 * (v5 - 2)))
    {
      if ((result & 1) == 0) {
        goto LABEL_7;
      }
      uint64_t result = 1;
LABEL_9:
      unint64_t v6 = v5++;
      if (v6 >= (v3 - v4) >> 4) {
        return result;
      }
    }
    if ((result & 1) == 0)
    {
      uint64_t result = 0;
      goto LABEL_9;
    }
LABEL_7:
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v4 + 16 * v6) + 16))(*(void *)(v4 + 16 * v6));
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v3 = *(void *)(a1 + 40);
    goto LABEL_9;
  }
  return result;
}

void *sub_100F04E10(void *a1)
{
  *a1 = off_101A6DF28;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  *a1 = off_101A6DED0;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_100F04E90(void *a1)
{
  *a1 = off_101A6DF28;
  int v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  *a1 = off_101A6DED0;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  operator delete();
}

void *sub_100F04F30(void *a1)
{
  *a1 = off_101A6DF50;
  int v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  *a1 = off_101A6DED0;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100F04FA4(void *a1)
{
  *a1 = off_101A6DF50;
  int v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  *a1 = off_101A6DED0;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100F05038(void *a1)
{
  *a1 = off_101A6DF78;
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  *a1 = off_101A6DED0;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100F050AC(void *a1)
{
  *a1 = off_101A6DF78;
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  *a1 = off_101A6DED0;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

uint64_t sub_100F05140(uint64_t a1)
{
  *(void *)a1 = off_101A6DFA0;
  int v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  unsigned int v5 = (void **)(a1 + 32);
  sub_10077EE24(&v5);
  *(void *)a1 = off_101A6DED0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100F051D0(uint64_t a1)
{
  *(void *)a1 = off_101A6DFA0;
  int v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)(a1 + 32);
  sub_10077EE24(&v4);
  *(void *)a1 = off_101A6DED0;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void sub_100F05280(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E098;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F052A0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E098;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F052F4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F05320(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F05358(uint64_t a1)
{
  return sub_100F053A4(*(void *)(a1 + 24));
}

uint64_t sub_100F05360(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F053A4(uint64_t result)
{
  if (result)
  {
    BOOL v1 = *(std::__shared_weak_count **)(result + 8);
    if (v1) {
      sub_10004D2C8(v1);
    }
    operator delete();
  }
  return result;
}

void sub_100F053FC(void *a1, char a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t *a5)
{
  int v10 = operator new(0x50uLL);
  unint64_t v11 = v10;
  v10[1] = 0;
  void v10[2] = 0;
  void *v10 = off_101A6E160;
  uint64_t v12 = (char *)(v10 + 3);
  if (a4)
  {
    atomic_fetch_add_explicit(&a4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v13 = *a5;
    *((unsigned char *)v10 + 24) = a2;
    *(void *)((char *)v10 + 28) = 0;
    *(void *)((char *)v10 + 44) = 0;
    *(void *)((char *)v10 + 36) = 0;
    *((_DWORD *)v10 + 13) = 0;
    v10[7] = a3;
    v10[8] = a4;
    atomic_fetch_add_explicit(&a4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v10[9] = v13;
    std::__shared_weak_count::__release_weak(a4);
  }
  else
  {
    uint64_t v14 = *a5;
    *((unsigned char *)v10 + 24) = a2;
    *(void *)((char *)v10 + 28) = 0;
    *(void *)((char *)v10 + 44) = 0;
    *(void *)((char *)v10 + 36) = 0;
    *((_DWORD *)v10 + 13) = 0;
    v10[7] = a3;
    v10[8] = 0;
    v10[9] = v14;
  }
  *a1 = v12;
  a1[1] = v11;
}

void sub_100F054D8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E160;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F054F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E160;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F0554C(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    operator delete(v3);
  }
}

void sub_100F055A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E1B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F055C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E1B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F05618(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F05640(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E200;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F05660(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E200;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F056B4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F056DC(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v9 = (char *)operator new(0x50uLL);
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  *(void *)uint64_t v9 = off_101A6E250;
  uint64_t v11 = *a4;
  int v10 = (std::__shared_weak_count *)a4[1];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v12 = *a5;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v12 = *a5;
  }
  *((void *)v9 + 3) = off_101A6DED0;
  *((void *)v9 + 4) = v11;
  *((void *)v9 + 5) = v10;
  tm v69 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *((void *)v9 + 6) = v12;
    uint64_t v13 = (uint64_t *)(v9 + 48);
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    *((void *)v9 + 6) = v12;
    uint64_t v13 = (uint64_t *)(v9 + 48);
  }
  *((void *)v9 + 3) = off_101A6DF78;
  v9[56] = 0;
  *((void *)v9 + 8) = 0;
  *((void *)v9 + 9) = 0;
  BOOL v70 = (unsigned char **)(a2 + 88);
  while (1)
  {
    if (*(unsigned char *)(a3 + 80))
    {
      if (!*(unsigned char *)(a2 + 80)) {
        __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
      }
      if (*(void *)(a3 + 64) == *(void *)(a2 + 64) && *(void *)(a3 + 72) == *(void *)(a2 + 72)) {
        goto LABEL_35;
      }
    }
    else if (!*(unsigned char *)(a2 + 80))
    {
      goto LABEL_35;
    }
    std::locale::locale(&v72);
    std::locale::locale(v74, &v72);
    int v14 = *(char *)(a2 + 111);
    uint64_t v15 = v14 >= 0 ? a2 + 88 : *(void *)(a2 + 88);
    uint64_t v16 = v14 >= 0 ? *(unsigned __int8 *)(a2 + 111) : *(void *)(a2 + 96);
    if (v16) {
      break;
    }
    uint64_t v20 = (char *)v15;
    unsigned __int8 v19 = "not";
LABEL_28:
    std::locale::~locale(v74);
    std::locale::~locale(&v72);
    if (v20 != (char *)(v15 + v16) || v19 != "") {
      goto LABEL_35;
    }
    v9[56] ^= 1u;
    sub_1009545B0(a2);
  }
  uint64_t v17 = v16 - 1;
  if ((unint64_t)(v16 - 1) >= 2) {
    uint64_t v17 = 2;
  }
  uint64_t v18 = v17 + 1;
  unsigned __int8 v19 = "not";
  uint64_t v20 = (char *)v15;
  while (sub_100326220(v74, v20, v19))
  {
    ++v20;
    ++v19;
    if (!--v18) {
      goto LABEL_28;
    }
  }
  std::locale::~locale(v74);
  std::locale::~locale(&v72);
LABEL_35:
  long long v22 = operator new(0x48uLL);
  long long v23 = v22;
  v22[1] = 0;
  v22[2] = 0;
  *long long v22 = off_101A6E200;
  int64x2_t v24 = v22 + 3;
  uint64_t v25 = *((void *)v9 + 4);
  int v26 = (std::__shared_weak_count *)*((void *)v9 + 5);
  if (v26)
  {
    atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v27 = *v13;
    atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v27 = *v13;
  }
  v22[3] = off_101A6DED0;
  uint8_t v22[4] = v25;
  v22[5] = v26;
  if (v26)
  {
    atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v22[6] = v27;
    uint64_t v28 = v22 + 6;
    std::__shared_weak_count::__release_weak(v26);
  }
  else
  {
    v22[6] = v27;
    uint64_t v28 = v22 + 6;
  }
  v23[3] = off_101A6DF50;
  v23[7] = 0;
  unsigned char v23[8] = 0;
  if (*(unsigned char *)(a3 + 80))
  {
    if (!*(unsigned char *)(a2 + 80)) {
      goto LABEL_144;
    }
    if (*(void *)(a3 + 64) == *(void *)(a2 + 64) && *(void *)(a3 + 72) == *(void *)(a2 + 72)) {
      goto LABEL_143;
    }
  }
  else if (!*(unsigned char *)(a2 + 80))
  {
    goto LABEL_143;
  }
  uint64_t v29 = *(unsigned __int8 *)(a2 + 111);
  int v30 = (char)v29;
  if ((v29 & 0x80u) != 0) {
    uint64_t v29 = *(void *)(a2 + 96);
  }
  uint64_t v67 = v24;
  if (v29 != 1 || (v30 >= 0 ? (long long v31 = (unsigned char *)(a2 + 88)) : (long long v31 = *v70), *v31 != 40))
  {
    uint64_t v66 = v26;
    std::string v38 = (std::locale::__imp *)v23[4];
    uint64_t v39 = (std::__shared_weak_count *)v23[5];
    uint64_t v40 = operator new(0x60uLL);
    int v41 = v40;
    v40[1] = 0;
    v40[2] = 0;
    void *v40 = off_101A6E1B0;
    std::string v42 = v40 + 3;
    if (v39)
    {
      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v43 = *v28;
      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      uint64_t v43 = *v28;
    }
    v40[3] = off_101A6DED0;
    v40[4] = v38;
    v40[5] = v39;
    if (v39)
    {
      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v40[6] = v43;
      long long v44 = v40 + 6;
      std::__shared_weak_count::__release_weak(v39);
      std::string v38 = (std::locale::__imp *)v41[4];
      int64_t v45 = (std::__shared_weak_count *)v41[5];
    }
    else
    {
      int64_t v45 = 0;
      v40[6] = v43;
      long long v44 = v40 + 6;
    }
    long long v65 = v42;
    *(_OWORD *)(v41 + 7) = 0u;
    char v46 = v41 + 7;
    v41[3] = off_101A6DF28;
    *(_OWORD *)(v41 + 9) = 0u;
    v72.__locale_ = v38;
    std::locale v73 = v45;
    if (v45) {
      atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F03C9C(&v74[0].__locale_, a2, a3, (uint64_t *)&v72, *v44);
    uint64_t v47 = (std::__shared_weak_count *)v41[8];
    *(_OWORD *)(v41 + 7) = *(_OWORD *)&v74[0].__locale_;
    if (v47) {
      sub_10004D2C8(v47);
    }
    if (v45) {
      std::__shared_weak_count::__release_weak(v45);
    }
    if (*(unsigned char *)(a3 + 80))
    {
      if (!*(unsigned char *)(a2 + 80)) {
        __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
      }
      if (*(void *)(a3 + 64) == *(void *)(a2 + 64) && *(void *)(a3 + 72) == *(void *)(a2 + 72)) {
        goto LABEL_126;
      }
    }
    else if (!*(unsigned char *)(a2 + 80))
    {
      goto LABEL_126;
    }
    uint64_t v48 = *(unsigned __int8 *)(a2 + 111);
    int v49 = (char)v48;
    if ((v48 & 0x80u) != 0) {
      uint64_t v48 = *(void *)(a2 + 96);
    }
    if (v48 != 1) {
      goto LABEL_92;
    }
    BOOL v50 = *v70;
    if (v49 >= 0) {
      BOOL v50 = (unsigned char *)(a2 + 88);
    }
    if (*v50 == 61)
    {
      int v51 = 0;
    }
    else
    {
LABEL_92:
      if (*(unsigned char *)(a3 + 80)
        && *(void *)(a3 + 64) == *(void *)(a2 + 64)
        && *(void *)(a3 + 72) == *(void *)(a2 + 72))
      {
        goto LABEL_126;
      }
      if (v48 != 1) {
        goto LABEL_99;
      }
      uint64_t v52 = *v70;
      if (v49 >= 0) {
        uint64_t v52 = (unsigned char *)(a2 + 88);
      }
      if (*v52 == 60)
      {
        int v51 = 1;
      }
      else
      {
LABEL_99:
        if (*(unsigned char *)(a3 + 80) && *(void *)(a3 + 64) == *(void *)(a2 + 64))
        {
          if (v48 != 1 || *(void *)(a3 + 72) == *(void *)(a2 + 72)) {
            goto LABEL_126;
          }
        }
        else if (v48 != 1)
        {
          goto LABEL_126;
        }
        long long v56 = *v70;
        if (v49 >= 0) {
          long long v56 = (unsigned char *)(a2 + 88);
        }
        if (*v56 != 62)
        {
LABEL_126:
          uint64_t v60 = *v46;
          if (!*(_DWORD *)(*v46 + 4))
          {
            if (*(char *)(v60 + 31) < 0)
            {
              if (!*(void *)(v60 + 16)) {
                goto LABEL_129;
              }
            }
            else if (!*(unsigned char *)(v60 + 31))
            {
LABEL_129:
              if (v39) {
                std::__shared_weak_count::__release_weak(v39);
              }
              uint64_t v61 = (std::__shared_weak_count *)v23[8];
              int v26 = v66;
              v23[7] = v65;
              unsigned char v23[8] = v41;
              int v37 = v67;
              if (v61) {
                sub_10004D2C8(v61);
              }
              goto LABEL_133;
            }
          }
LABEL_141:
          exception = __cxa_allocate_exception(8uLL);
          void *exception = &off_101A6DFC8;
        }
        int v51 = 2;
      }
    }
    *((_DWORD *)v41 + 22) = v51;
    sub_1009545B0(a2);
    int v57 = (std::__shared_weak_count *)v41[5];
    v71[0] = v41[4];
    v71[1] = (uint64_t)v57;
    if (v57) {
      atomic_fetch_add_explicit(&v57->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F03C9C(&v74[0].__locale_, a2, a3, v71, *v44);
    int v58 = (std::__shared_weak_count *)v41[10];
    *(_OWORD *)(v41 + 9) = *(_OWORD *)&v74[0].__locale_;
    if (v58) {
      sub_10004D2C8(v58);
    }
    if (v57) {
      std::__shared_weak_count::__release_weak(v57);
    }
    uint64_t v59 = v41[9];
    if (v59 && *(_DWORD *)(*v46 + 4) == *(_DWORD *)(v59 + 4)) {
      goto LABEL_129;
    }
    goto LABEL_141;
  }
  sub_1009545B0(a2);
  long long v32 = operator new(0x68uLL);
  int v33 = v32;
  v32[1] = 0;
  void v32[2] = 0;
  *long long v32 = off_101A6E098;
  unint64_t v34 = v32 + 3;
  uint64_t v35 = (atomic_ullong *)v23[5];
  v74[0] = (std::locale)v23[4];
  v74[1].__locale_ = (std::locale::__imp *)v35;
  if (v35) {
    atomic_fetch_add_explicit(v35 + 2, 1uLL, memory_order_relaxed);
  }
  sub_100F04694(v32 + 3, a2, a3, v74, *v28);
  if (v35) {
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v35);
  }
  char v36 = (std::__shared_weak_count *)v23[8];
  v23[7] = v34;
  unsigned char v23[8] = v33;
  if (v36) {
    sub_10004D2C8(v36);
  }
  int v37 = v67;
  if (*(unsigned char *)(a3 + 80))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      if (*(void *)(a3 + 64) == *(void *)(a2 + 64) && *(void *)(a3 + 72) == *(void *)(a2 + 72)) {
        goto LABEL_143;
      }
      goto LABEL_103;
    }
LABEL_144:
    __assert_rtn("dereference", "token_iterator.hpp", 59, "valid_");
  }
  if (!*(unsigned char *)(a2 + 80)) {
    goto LABEL_143;
  }
LABEL_103:
  uint64_t v53 = *(unsigned __int8 *)(a2 + 111);
  int v54 = (char)v53;
  if ((v53 & 0x80u) != 0) {
    uint64_t v53 = *(void *)(a2 + 96);
  }
  if (v53 != 1 || (v54 >= 0 ? (uint64_t v55 = (unsigned char *)(a2 + 88)) : (uint64_t v55 = *v70), *v55 != 41))
  {
LABEL_143:
    unint64_t v64 = __cxa_allocate_exception(8uLL);
    void *v64 = &off_101A6DFC8;
  }
  sub_1009545B0(a2);
LABEL_133:
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v62 = (std::__shared_weak_count *)*((void *)v9 + 9);
  *((void *)v9 + 8) = v37;
  *((void *)v9 + 9) = v23;
  if (v62) {
    sub_10004D2C8(v62);
  }
  if (v69) {
    std::__shared_weak_count::__release_weak(v69);
  }
  *a1 = v9 + 24;
  a1[1] = v9;
}

void sub_100F05F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count_vtbl *a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,std::locale a21)
{
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  std::__shared_weak_count::~__shared_weak_count(v23);
  operator delete(v28);
  shared_weak_owners = (std::__shared_weak_count *)v24[2].__shared_weak_owners_;
  if (shared_weak_owners) {
    sub_10004D2C8(shared_weak_owners);
  }
  v24[1].__vftable = v26;
  int v30 = (std::__shared_weak_count *)v24[1].__shared_weak_owners_;
  if (v30) {
    std::__shared_weak_count::__release_weak(v30);
  }
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  std::__shared_weak_count::~__shared_weak_count(v24);
  operator delete(v31);
  long long v32 = (std::__shared_weak_count *)v21[3].__vftable;
  if (v32) {
    sub_10004D2C8(v32);
  }
  v21[1].__vftable = a11;
  int v33 = (std::__shared_weak_count *)v21[1].__shared_weak_owners_;
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  std::__shared_weak_count::~__shared_weak_count(v21);
  operator delete(v34);
  _Unwind_Resume(a1);
}

void sub_100F060D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F060F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6E250;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F06144(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void CellularUsagePolicyController::createNEConfigurationStore_sync(uint64_t a1)
{
  v2[0] = off_101A6E300;
  v2[1] = a1;
  v2[3] = v2;
  sub_1007327A8(&v1);
}

void sub_100F0622C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void CellularUsagePolicyController::createNEPathEventObserver_sync(uint64_t a1, uint64_t *a2)
{
  id v4 = objc_alloc((Class)NEPathEventObserver);
  uint64_t v5 = *(void *)(a1 + 24);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3321888768;
  xpc_object_t v8[2] = sub_100F0630C;
  v8[3] = &unk_101A6E290;
  uint64_t v7 = *a2;
  unint64_t v6 = (std::__shared_weak_count *)a2[1];
  v8[4] = a1;
  v8[5] = v7;
  uint64_t v9 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 56) = [v4 initWithQueue:v5 eventHandler:v8];
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100F062F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0630C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2 && [a2 bundleID])
  {
    if ([a2 type] != (id)1 && objc_msgSend(a2, "type") != (id)3) {
      return;
    }
    id v5 = [a2 type];
    memset(&v20, 0, sizeof(v20));
    sub_100058DB0(&v20, (char *)objc_msgSend(objc_msgSend(a2, "bundleID"), "UTF8String"));
    memset(buf, 0, sizeof(buf));
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 40));
    uint64_t v7 = ServiceMap;
    if (v8 < 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    *(void *)int v21 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_15:
        (*(void (**)(unsigned char *__return_ptr, uint64_t, std::string *))(*(void *)v14 + 112))(buf, v14, &v20);
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        if (buf[24])
        {
          uint64_t v17 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
          {
            uint64_t v18 = buf;
            if (buf[23] < 0) {
              uint64_t v18 = *(unsigned char **)buf;
            }
            unsigned __int8 v19 = &v20;
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned __int8 v19 = (std::string *)v20.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)int v21 = 136446466;
            *(void *)&void v21[4] = v18;
            __int16 v22 = 2082;
            long long v23 = v19;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "Using parent bundleId %{public}s for network access denied callback of %{public}s", v21, 0x16u);
          }
          std::string::operator=(&v20, (const std::string *)buf);
          if (buf[24] && (buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        CellularUsagePolicyController::networkAccessDeniedCallback_sync(v3, (uint64_t)&v20, v5 == (id)3);
        if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v20.__r_.__value_.__l.__data_);
        }
        return;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    uint64_t v13 = 0;
    char v15 = 1;
    goto LABEL_15;
  }
  uint64_t v16 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218240;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = [a2 bundleID];
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Not processing network access denied callback event: %p bundle identifier: %p", buf, 0x16u);
  }
}

void sub_100F065E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a26 && a25 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F06650(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F0666C(uint64_t a1)
{
  long long v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void CellularUsagePolicyController::stop_sync(CellularUsagePolicyController *this)
{
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterRemoveObserver(DistributedCenter, this, @"com.apple.LaunchServices.applicationRegistered", 0);
  CFNotificationCenterRemoveObserver(DistributedCenter, this, @"com.apple.LaunchServices.applicationUnregistered", 0);
  uint64_t v3 = (CellularUsagePolicyController *)*((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v3 == (CellularUsagePolicyController *)((char *)this + 344))
  {
    (*(void (**)(char *))(*((void *)this + 43) + 32))((char *)this + 344);
  }
  else if (v3)
  {
    (*(void (**)(CellularUsagePolicyController *))(*(void *)v3 + 40))(v3);
  }
  ctu::RestModule::disconnect((CellularUsagePolicyController *)((char *)this + 328));
  id v4 = *((void *)this + 5);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Stopped cupolicy server", v5, 2u);
  }
}

void CellularUsagePolicyController::start_sync(NSObject **this)
{
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterAddObserver(DistributedCenter, this, (CFNotificationCallback)sub_100F06848, @"com.apple.LaunchServices.applicationRegistered", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  CFNotificationCenterAddObserver(DistributedCenter, this, (CFNotificationCallback)sub_100F06848, @"com.apple.LaunchServices.applicationUnregistered", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  uint64_t v3 = this[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Started cupolicy server", v4, 2u);
  }
}

void sub_100F06848(int a1, uint64_t a2, const void *a3, int a4, CFDictionaryRef theDict)
{
  if (theDict)
  {
    CFArrayRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"isPlaceholder");
    uint64_t v9 = Value;
    buf[0] = 0;
    if (Value)
    {
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v9, v11);
        LODWORD(v9) = buf[0];
      }
      else
      {
        LODWORD(v9) = 0;
      }
    }
    if (CFEqual(a3, @"com.apple.LaunchServices.applicationRegistered"))
    {
      *(void *)long long buf = CFDictionaryGetValue(theDict, @"bundleIDs");
      sub_100044D6C(&v14, (CFTypeRef *)buf);
      CellularUsagePolicyController::appsRegistered(a2, &v14, v9 != 0);
    }
    if (CFEqual(a3, @"com.apple.LaunchServices.applicationUnregistered"))
    {
      *(void *)long long buf = CFDictionaryGetValue(theDict, @"bundleIDs");
      sub_100044D6C(&v13, (CFTypeRef *)buf);
      CellularUsagePolicyController::appsUnRegistered(a2, &v13);
    }
  }
  else
  {
    uint64_t v12 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Not processing App Registered Notification - empty userInfo indicates an update", buf, 2u);
    }
  }
}

void sub_100F069B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void CellularUsagePolicyController::setupAwdMetrics_sync(CellularUsagePolicyController *this)
{
  sub_10003E168(&v2, (void *)this + 1);
  long long v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F06AB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F06AD4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    id v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      id v5 = v4;
      if (a1[5])
      {
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 3221225472;
        _DWORD v7[2] = sub_100F06C10;
        void v7[3] = &unk_1019A1BF8;
        v7[4] = v3;
        uint64_t v10 = 0;
        CFBooleanRef v11 = 0;
        sub_10003E168(&v10, (void *)(v3 + 8));
        unint64_t v6 = *(NSObject **)(v3 + 24);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768;
        block[2] = sub_100F081D0;
        block[3] = &unk_101A6E378;
        void block[5] = v10;
        uint64_t v9 = v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        block[4] = v7;
        dispatch_async(v6, block);
        if (v9) {
          sub_10004D2C8(v9);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_100F06C10(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 200) + 40))(*(void *)(*(void *)(a1 + 32) + 200), *(unsigned int *)(*(void *)(a1 + 32) + 272));

  return WISPostSimpleMetricWithUnsignedInteger();
}

uint64_t sub_100F06C70(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F06C8C(uint64_t a1)
{
  long long v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void CellularUsagePolicyController::sendDeprecatedRnfNotification_sync(uint64_t a1, int a2)
{
  sub_100F06D74(a2, &object);
  xpc_object_t v2 = object;
  xpc_object_t v6 = object;
  if (object)
  {
    xpc_retain(object);
  }
  else
  {
    xpc_object_t v2 = xpc_null_create();
    xpc_object_t v6 = v2;
  }
  xpc_object_t v3 = xpc_null_create();
  xpc_object_t v4 = v3;
  sub_1000452AC(155, &v6, &v4);
  xpc_release(v3);
  xpc_release(v2);
  xpc_object_t v6 = 0;
  xpc_release(object);
}

void sub_100F06D34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12)
{
  uint64_t v14 = v13;
  xpc_release(v14);
  xpc_release(v12);
  xpc_release(object);
  _Unwind_Resume(a1);
}

void sub_100F06D74(int a1@<W0>, void *a2@<X8>)
{
  *a2 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *a2 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *a2 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  *a2 = v6;
LABEL_9:
  xpc_release(v5);
  uint64_t v18 = 0;
  ctu::cf::assign();
  *(_OWORD *)char v15 = 0uLL;
  uint64_t v16 = 0;
  xpc_object_t v13 = xpc_BOOL_create(a1 == 1);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  uint64_t v7 = v15;
  if (v16 < 0) {
    uint64_t v7 = (void **)v15[0];
  }
  *(void *)&long long v17 = a2;
  *((void *)&v17 + 1) = v7;
  sub_100035E70((uint64_t)&v17, &v13, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  long long v17 = 0uLL;
  uint64_t v18 = 0;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext __p = v17;
  uint64_t v12 = v18;
  xpc_object_t v9 = xpc_BOOL_create(a1 != -1);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  uint64_t v8 = __p;
  if (v12 < 0) {
    uint64_t v8 = (void **)__p[0];
  }
  *(void *)&long long v17 = a2;
  *((void *)&v17 + 1) = v8;
  sub_100035E70((uint64_t)&v17, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
}

void sub_100F06F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (*(char *)(v23 - 33) < 0) {
    operator delete(*(void **)(v23 - 56));
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  sub_10017143C(v22);
  _Unwind_Resume(a1);
}

void sub_100F06FC8(Registry **a1, xpc_object_t *a2, void (**a3)(void, void))
{
  xpc_object_t v58 = 0;
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  if (v6)
  {
    xpc_object_t v7 = v6;
    xpc_object_t v58 = v6;
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v58 = v7;
    if (!v7)
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v7);
    goto LABEL_9;
  }
  xpc_object_t v8 = xpc_null_create();
LABEL_8:
  xpc_object_t v58 = v8;
LABEL_9:
  xpc_release(v7);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *a1);
  CFBooleanRef v11 = ServiceMap;
  if (v12 < 0)
  {
    xpc_object_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    long long v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_15;
      }
LABEL_23:
      v53[0] = 0;
      v53[1] = 0;
      uint64_t v54 = 0;
      v51[0] = a2;
      v51[1] = "kCUPolicyBundleName";
      sub_100048BAC((uint64_t)v51, &object);
      memset(buf, 0, sizeof(buf));
      *(void *)&long long v47 = 0;
      xpc::dyn_cast_or_default();
      if (SBYTE7(v47) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_release(object);
      int v21 = (void *)HIBYTE(v54);
      if (v54 < 0) {
        int v21 = v53[1];
      }
      if (!v21)
      {
        sub_100F07838();
        uint64_t v25 = qword_101B12F68;
        if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#E Arguments are invalid", buf, 2u);
        }
        xpc_object_t v49 = xpc_int64_create(22);
        if (!v49) {
          xpc_object_t v49 = xpc_null_create();
        }
        *(void *)long long buf = &v58;
        *(void *)&uint8_t buf[8] = "kPosixError";
        sub_100035E70((uint64_t)buf, &v49, &v50);
        xpc_release(v50);
        xpc_object_t v50 = 0;
        xpc_release(v49);
        xpc_object_t v48 = v58;
        xpc_object_t v49 = 0;
        if (v58) {
          xpc_retain(v58);
        }
        else {
          xpc_object_t v48 = xpc_null_create();
        }
        ((void (**)(void, xpc_object_t *))a3)[2](a3, &v48);
        xpc_release(v48);
        xpc_object_t v48 = 0;
LABEL_64:
        if (SHIBYTE(v54) < 0)
        {
          operator delete(v53[0]);
          if (v19) {
            goto LABEL_67;
          }
        }
        else if (v19)
        {
          goto LABEL_67;
        }
LABEL_66:
        sub_10004D2C8(v17);
        goto LABEL_67;
      }
      if (xpc_dictionary_get_value(*a2, "kCUPolicyKeyDataAllowed"))
      {
        *(void *)long long buf = a2;
        *(void *)&uint8_t buf[8] = "kCUPolicyKeyDataAllowed";
        sub_100048BAC((uint64_t)buf, v51);
        unsigned __int8 v23 = xpc::dyn_cast_or_default((xpc *)v51, 0, v22);
        xpc_release(v51[0]);
        __int16 v24 = 1;
      }
      else
      {
        unsigned __int8 v23 = 0;
        __int16 v24 = 0;
      }
      if (xpc_dictionary_get_value(*a2, "kCUPolicyKeyWiFiAllowed"))
      {
        *(void *)long long buf = a2;
        *(void *)&uint8_t buf[8] = "kCUPolicyKeyWiFiAllowed";
        sub_100048BAC((uint64_t)buf, v51);
        unsigned __int8 v27 = xpc::dyn_cast_or_default((xpc *)v51, 0, v26);
        xpc_release(v51[0]);
        __int16 v28 = 1;
        if (a3)
        {
LABEL_39:
          uint64_t v29 = _Block_copy(a3);
LABEL_42:
          *(_OWORD *)long long buf = 0u;
          long long v47 = 0u;
          __int16 v30 = v23 | (unsigned __int16)(v24 << 8);
          sub_1000D88A0((uint64_t)buf, (uint64_t)v53, v30, v27 | (unsigned __int16)(v28 << 8));
          *(void *)&long long v35 = v18;
          *((void *)&v35 + 1) = v17;
          if ((v19 & 1) == 0) {
            atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          xpc_object_t v36 = v58;
          if (v58) {
            xpc_retain(v58);
          }
          else {
            xpc_object_t v36 = xpc_null_create();
          }
          long long v38 = 0uLL;
          uint64_t v39 = 0;
          sub_1000302C0((char *)&v38, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
          int v40 = DWORD2(v47);
          if (SHIBYTE(v54) < 0)
          {
            sub_10004FC84(&__p, v53[0], (unint64_t)v53[1]);
          }
          else
          {
            long long __p = *(_OWORD *)v53;
            uint64_t v42 = v54;
          }
          LOWORD(v43) = v30;
          HIWORD(v43) = v27 | (unsigned __int16)(v28 << 8);
          char v44 = 1;
          if (v29) {
            long long v31 = _Block_copy(v29);
          }
          else {
            long long v31 = 0;
          }
          aBlock = v31;
          uint64_t v60 = 0;
          long long v32 = (char *)operator new(0x68uLL);
          *(void *)long long v32 = off_101A6E3B8;
          *(_OWORD *)(v32 + 8) = v35;
          *((void *)v32 + 3) = v36;
          xpc_object_t v33 = xpc_null_create();
          *((void *)v32 + 6) = v39;
          *((_DWORD *)v32 + 14) = v40;
          *((void *)v32 + 10) = v42;
          *((_OWORD *)v32 + 2) = v38;
          uint64_t v39 = 0;
          long long v38 = 0uLL;
          *((_OWORD *)v32 + 4) = __p;
          long long __p = 0uLL;
          uint64_t v42 = 0;
          int v34 = v43;
          v32[92] = v44;
          *((_DWORD *)v32 + 22) = v34;
          *((void *)v32 + 12) = aBlock;
          xpc_object_t v37 = v33;
          aBlock = 0;
          uint64_t v60 = v32;
          (*(void (**)(uint64_t, uint8_t *, void *))(*(void *)v18 + 24))(v18, buf, v59);
          sub_1000E0D60(v59);
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (SHIBYTE(v42) < 0) {
            operator delete((void *)__p);
          }
          v51[0] = &v38;
          sub_100047F64((void ***)v51);
          xpc_release(v37);
          v51[0] = buf;
          sub_100047F64((void ***)v51);
          if (v29) {
            _Block_release(v29);
          }
          goto LABEL_64;
        }
      }
      else
      {
        unsigned __int8 v27 = 0;
        __int16 v28 = 0;
        if (a3) {
          goto LABEL_39;
        }
      }
      uint64_t v29 = 0;
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  long long v17 = 0;
  char v19 = 1;
  if (v18) {
    goto LABEL_23;
  }
LABEL_15:
  sub_100F07838();
  std::string v20 = qword_101B12F68;
  if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#E Policy server is not valid", buf, 2u);
  }
  xpc_object_t v56 = xpc_int64_create(19);
  if (!v56) {
    xpc_object_t v56 = xpc_null_create();
  }
  *(void *)long long buf = &v58;
  *(void *)&uint8_t buf[8] = "kPosixError";
  sub_100035E70((uint64_t)buf, &v56, &v57);
  xpc_release(v57);
  xpc_object_t v57 = 0;
  xpc_release(v56);
  xpc_object_t v55 = v58;
  xpc_object_t v56 = 0;
  if (v58) {
    xpc_retain(v58);
  }
  else {
    xpc_object_t v55 = xpc_null_create();
  }
  ((void (**)(void, xpc_object_t *))a3)[2](a3, &v55);
  xpc_release(v55);
  xpc_object_t v55 = 0;
  if ((v19 & 1) == 0) {
    goto LABEL_66;
  }
LABEL_67:
  xpc_release(v58);
}

void sub_100F07664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,xpc_object_t a28,uint64_t a29,uint64_t a30,xpc_object_t a31,uint64_t a32,xpc_object_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100F07838()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B12F70, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B12F70))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B12F68, kCtLoggingSystemName, "cu.policy.xpc");
    __cxa_guard_release(&qword_101B12F70);
  }
}

void sub_100F078B8(_Unwind_Exception *a1)
{
}

uint64_t sub_100F078D0(uint64_t a1)
{
  xpc_object_t v2 = *(const void **)(a1 + 88);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  xpc_object_t v5 = (void **)(a1 + 24);
  sub_100047F64(&v5);
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void doCUPolicyGet(Registry **a1, uint64_t a2, void **a3, void (**a4)(void, void))
{
  xpc_object_t v44 = 0;
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v9 = v8;
  if (v8)
  {
    xpc_object_t v44 = v8;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v44 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_9;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_8:
  xpc_object_t v44 = v10;
LABEL_9:
  xpc_release(v9);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v13;
  long long v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_15;
      }
LABEL_23:
      v39[0] = 0;
      v39[1] = 0;
      uint64_t v40 = 0;
      v37[0] = a2;
      v37[1] = "kCUPolicyBundleName";
      sub_100048BAC((uint64_t)v37, &v38);
      *(void *)long long buf = 0;
      char v46 = 0;
      uint64_t v47 = 0;
      xpc::dyn_cast_or_default();
      if (SHIBYTE(v47) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_release(v38);
      unsigned __int8 v23 = (void *)HIBYTE(v40);
      if (v40 < 0) {
        unsigned __int8 v23 = v39[1];
      }
      if (v23)
      {
        if (a4 && (__int16 v24 = _Block_copy(a4), (a4 = (void (**)(void, void))v24) != 0))
        {
          uint64_t v25 = _Block_copy(v24);
          char v26 = 0;
        }
        else
        {
          uint64_t v25 = 0;
          char v26 = 1;
        }
        aBlock[0] = v25;
        aBlock[1] = v44;
        if (v44) {
          xpc_retain(v44);
        }
        else {
          aBlock[1] = xpc_null_create();
        }
        if (SHIBYTE(v40) < 0)
        {
          sub_10004FC84(&__p, v39[0], (unint64_t)v39[1]);
        }
        else
        {
          long long __p = *(_OWORD *)v39;
          uint64_t v33 = v40;
        }
        xpc_object_t v49 = 0;
        uint64_t v29 = (char *)operator new(0x30uLL);
        *(void *)uint64_t v29 = off_101A6E438;
        *(_OWORD *)(v29 + 8) = *(_OWORD *)aBlock;
        xpc_object_t aBlock_8 = xpc_null_create();
        *(_OWORD *)(v29 + 24) = __p;
        *((void *)v29 + 5) = v33;
        long long __p = 0uLL;
        uint64_t v33 = 0;
        xpc_object_t v49 = v29;
        (*(void (**)(uint64_t, void **, void **, void *))(*(void *)v19 + 16))(v19, v39, a3, v48);
        sub_1000EA288(v48);
        if (SHIBYTE(v33) < 0) {
          operator delete((void *)__p);
        }
        xpc_release(aBlock_8);
        if ((v26 & 1) == 0) {
          _Block_release(a4);
        }
      }
      else
      {
        sub_100F07838();
        unsigned __int8 v27 = qword_101B12F68;
        if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#E Bundle name is not valid", buf, 2u);
        }
        xpc_object_t v35 = xpc_int64_create(22);
        if (!v35) {
          xpc_object_t v35 = xpc_null_create();
        }
        *(void *)long long buf = &v44;
        char v46 = "kPosixError";
        sub_100035E70((uint64_t)buf, &v35, &v36);
        xpc_release(v36);
        xpc_object_t v36 = 0;
        xpc_release(v35);
        __int16 v28 = *a3;
        xpc_object_t v34 = v28;
        xpc_object_t v35 = 0;
        if (v28) {
          xpc_retain(v28);
        }
        else {
          xpc_object_t v34 = xpc_null_create();
        }
        ((void (**)(void, xpc_object_t *))a4)[2](a4, &v34);
        xpc_release(v34);
        xpc_object_t v34 = 0;
      }
      if (SHIBYTE(v40) < 0)
      {
        operator delete(v39[0]);
        if (v20) {
          goto LABEL_56;
        }
      }
      else if (v20)
      {
        goto LABEL_56;
      }
LABEL_55:
      sub_10004D2C8(v18);
      goto LABEL_56;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
  if (v19) {
    goto LABEL_23;
  }
LABEL_15:
  sub_100F07838();
  int v21 = qword_101B12F68;
  if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#E Policy server is not valid", buf, 2u);
  }
  xpc_object_t v42 = xpc_int64_create(19);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  *(void *)long long buf = &v44;
  char v46 = "kPosixError";
  sub_100035E70((uint64_t)buf, &v42, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v42);
  uint64_t v22 = *a3;
  xpc_object_t v41 = v22;
  xpc_object_t v42 = 0;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    xpc_object_t v41 = xpc_null_create();
  }
  ((void (**)(void, xpc_object_t *))a4)[2](a4, &v41);
  xpc_release(v41);
  xpc_object_t v41 = 0;
  if ((v20 & 1) == 0) {
    goto LABEL_55;
  }
LABEL_56:
  xpc_release(v44);
}

void sub_100F07E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,xpc_object_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100F07FC4(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
  return a1;
}

void sub_100F0801C()
{
}

void *sub_100F08030(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A6E300;
  result[1] = v3;
  return result;
}

uint64_t sub_100F08078(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6E300;
  a2[1] = v2;
  return result;
}

void *sub_100F080A4(uint64_t a1)
{
  long long v1 = *(CellularUsagePolicyController **)(a1 + 8);
  uint64_t v2 = *((void *)v1 + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Handling NE configuration change", buf, 2u);
  }
  xpc_object_t v3 = xpc_null_create();
  *(void *)long long buf = v3;
  xpc_object_t v4 = xpc_null_create();
  xpc_object_t v6 = v4;
  sub_1000452AC(166, (xpc_object_t *)buf, &v6);
  xpc_release(v4);
  xpc_release(v3);
  return CellularUsagePolicyController::updateClientsWithPolicyChange_sync(v1);
}

void sub_100F08158(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F08184(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F081C4()
{
}

uint64_t sub_100F081D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100F081E0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F081FC(uint64_t a1)
{
  long long v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_100F0820C(uint64_t a1)
{
  *(void *)a1 = off_101A6E3B8;
  uint64_t v2 = *(const void **)(a1 + 96);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  xpc_object_t v5 = (void **)(a1 + 32);
  sub_100047F64(&v5);
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100F082A0(uint64_t a1)
{
  *(void *)a1 = off_101A6E3B8;
  uint64_t v2 = *(const void **)(a1 + 96);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  xpc_object_t v4 = (void **)(a1 + 32);
  sub_100047F64(&v4);
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  operator delete();
}

void *sub_100F08348(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  void *v2 = off_101A6E3B8;
  sub_100F086A8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F0839C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F083B0(uint64_t a1, void *a2)
{
  *a2 = off_101A6E3B8;
  return sub_100F086A8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100F083DC(uint64_t a1)
{
}

void sub_100F083E4(void *a1)
{
  sub_100F087D8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F08420(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  sub_1000DB02C(v9, a2);
  if (*a3)
  {
    if (!*(unsigned char *)(a1 + 92)) {
      goto LABEL_18;
    }
    uint64_t v5 = *(void *)(a1 + 8);
    if (*(char *)(a1 + 87) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 64);
      uint64_t v11 = *(void *)(a1 + 80);
    }
    (*(void (**)(uint64_t, void **, void, void))(*(void *)v5 + 96))(v5, __p, *(unsigned __int16 *)(a1 + 88), *(unsigned __int16 *)(a1 + 90));
    goto LABEL_16;
  }
  xpc_object_t v12 = xpc_int64_create(35);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  __p[0] = (void *)(a1 + 24);
  __p[1] = "kPosixError";
  sub_100035E70((uint64_t)__p, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  sub_100F07838();
  xpc_object_t v6 = qword_101B12F68;
  if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_ERROR))
  {
    asString(a1 + 32, __p);
    if (v11 >= 0) {
      xpc_object_t v7 = __p;
    }
    else {
      xpc_object_t v7 = (void **)__p[0];
    }
    uint64_t v8 = a1 + 64;
    if (*(char *)(a1 + 87) < 0) {
      uint64_t v8 = *(void *)(a1 + 64);
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v15 = v7;
    __int16 v16 = 2082;
    uint64_t v17 = v8;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to save policy: %{public}s for bundle id: %{public}s", buf, 0x16u);
LABEL_16:
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_18:
  sub_10071E540((uint64_t *)(a1 + 96), (void **)(a1 + 24));
  sub_10005CD2C((uint64_t)v9, (char *)v9[1]);
}

void sub_100F08608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F0865C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F0869C()
{
}

uint64_t sub_100F086A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void **)(a2 + 16);
  *(void *)(a1 + 16) = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *(void *)(a1 + 16) = xpc_null_create();
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_1000302C0((char *)(a1 + 24), *(long long **)(a2 + 24), *(long long **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3));
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  xpc_object_t v6 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)xpc_object_t v6 = v7;
  }
  int v8 = *(_DWORD *)(a2 + 80);
  *(unsigned char *)(a1 + 84) = *(unsigned char *)(a2 + 84);
  *(_DWORD *)(a1 + 80) = v8;
  xpc_object_t v9 = *(void **)(a2 + 88);
  if (v9) {
    xpc_object_t v9 = _Block_copy(v9);
  }
  *(void *)(a1 + 88) = v9;
  return a1;
}

void sub_100F08794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  xpc_release(*(xpc_object_t *)(v2 + 16));
  *(void *)(v2 + 16) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100F087D8(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 88);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v4 = (void **)(a1 + 24);
  sub_100047F64(&v4);
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
}

uint64_t sub_100F0884C(uint64_t a1)
{
  *(void *)a1 = off_101A6E438;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F088BC(uint64_t a1)
{
  *(void *)a1 = off_101A6E438;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }

  operator delete();
}

void *sub_100F0894C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = off_101A6E438;
  sub_100F08F2C(v2 + 1, v1);
  return v2;
}

void sub_100F089A0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100F089B4(uint64_t a1, void *a2)
{
  *a2 = off_101A6E438;
  return sub_100F08F2C(a2 + 1, a1 + 8);
}

void sub_100F089E0(uint64_t a1)
{
}

void sub_100F089E8(void *a1)
{
  sub_100F08FE8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F08A24(uint64_t a1, long long *a2, unsigned char *a3)
{
  sub_1000D8424(&v13, a2);
  if (*a3)
  {
    xpc_object_t v30 = xpc_int64_create(value);
    if (!v30) {
      xpc_object_t v30 = xpc_null_create();
    }
    *(void *)&long long buf = a1 + 16;
    *((void *)&buf + 1) = "kCUPolicyKeyDataAllowed";
    sub_100035E70((uint64_t)&buf, &v30, &v31);
    xpc_release(v31);
    xpc_object_t v31 = 0;
    xpc_release(v30);
    xpc_object_t v30 = 0;
    xpc_object_t object = xpc_int64_create(value_1);
    if (!object) {
      xpc_object_t object = xpc_null_create();
    }
    *(void *)&long long buf = a1 + 16;
    *((void *)&buf + 1) = "kCUPolicyKeyWiFiAllowed";
    sub_100035E70((uint64_t)&buf, &object, &v29);
    xpc_release(v29);
    xpc_object_t v29 = 0;
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_object_t v26 = xpc_BOOL_create(v19);
    if (!v26) {
      xpc_object_t v26 = xpc_null_create();
    }
    *(void *)&long long buf = a1 + 16;
    *((void *)&buf + 1) = "kCUPolicyKeyIsManaged";
    sub_100035E70((uint64_t)&buf, &v26, &v27);
    xpc_release(v27);
    xpc_object_t v27 = 0;
    xpc_release(v26);
    xpc_object_t v26 = 0;
    xpc_object_t v24 = xpc_BOOL_create(v20);
    if (!v24) {
      xpc_object_t v24 = xpc_null_create();
    }
    *(void *)&long long buf = a1 + 16;
    *((void *)&buf + 1) = "kCUPolicyKeyIsRestricted";
    sub_100035E70((uint64_t)&buf, &v24, &v25);
    xpc_release(v25);
    xpc_object_t v25 = 0;
    xpc_release(v24);
    xpc_object_t v24 = 0;
    long long buf = 0uLL;
    uint64_t v33 = 0;
    sub_1000D84B8(&buf, __p, (uint64_t)v18, v18 - (unsigned char *)__p);
    uint64_t v5 = (void *)buf;
    if ((void)buf != *((void *)&buf + 1))
    {
      xpc_object_t v6 = xpc_array_create(0, 0);
      if (v6 || (xpc_object_t v6 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v6);
          xpc_object_t v7 = v6;
        }
        else
        {
          xpc_object_t v7 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v7 = xpc_null_create();
        xpc_object_t v6 = 0;
      }
      xpc_release(v6);
      uint64_t v11 = (unsigned __int8 *)*((void *)&buf + 1);
      for (uint64_t i = (unsigned __int8 *)buf; i != v11; ++i)
      {
        xpc_object_t v12 = xpc_int64_create(*i);
        if (!v12) {
          xpc_object_t v12 = xpc_null_create();
        }
        xpc_array_append_value(v7, v12);
        xpc_release(v12);
      }
      xpc_object_t v22 = v7;
      if (v7) {
        xpc_retain(v7);
      }
      else {
        xpc_object_t v22 = xpc_null_create();
      }
      v21[0] = (xpc_object_t)(a1 + 16);
      v21[1] = "kCUPolicyKeyDisallowedPolicies";
      sub_10017AC14((uint64_t)v21, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_release(v7);
      uint64_t v5 = (void *)buf;
    }
    if (v5)
    {
      *((void *)&buf + 1) = v5;
      operator delete(v5);
    }
  }
  else
  {
    xpc_object_t v31 = xpc_int64_create(35);
    if (!v31) {
      xpc_object_t v31 = xpc_null_create();
    }
    *(void *)&long long buf = a1 + 16;
    *((void *)&buf + 1) = "kPosixError";
    sub_100035E70((uint64_t)&buf, &v31, v21);
    xpc_release(v21[0]);
    v21[0] = 0;
    xpc_release(v31);
    xpc_object_t v31 = 0;
    sub_100F07838();
    int v8 = qword_101B12F68;
    if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = a1 + 24;
      if (*(char *)(a1 + 47) < 0) {
        uint64_t v9 = *(void *)(a1 + 24);
      }
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to get policy for bundle id: %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  sub_10071E540((uint64_t *)(a1 + 8), (void **)(a1 + 16));
  if (__p)
  {
    uint64_t v18 = __p;
    operator delete(__p);
  }
  if (v14 < 0) {
    operator delete(v13);
  }
}

void sub_100F08DF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100F08EE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F08F20()
{
}

void *sub_100F08F2C(void *a1, uint64_t a2)
{
  if (*(void *)a2) {
    uint64_t v4 = _Block_copy(*(const void **)a2);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(void **)(a2 + 8);
  *a1 = v4;
  a1[1] = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    a1[1] = xpc_null_create();
  }
  xpc_object_t v6 = a1 + 2;
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 16);
    a1[4] = *(void *)(a2 + 32);
    *(_OWORD *)xpc_object_t v6 = v7;
  }
  return a1;
}

void sub_100F08FB4(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(void *)(v1 + 8) = 0;
  if (*(void *)v1) {
    _Block_release(*(const void **)v1);
  }
  _Unwind_Resume(a1);
}

void sub_100F08FE8(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  xpc_release(*(xpc_object_t *)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  if (*(void *)a1) {
    _Block_release(*(const void **)a1);
  }
}

uint64_t *sub_100F09038(uint64_t a1)
{
  sub_100C62700(a1, "kCUPolicySet", (unint64_t)sub_100F0915C, 0xCu);
  sub_100C62700(a1, "kCUPolicyGet", (unint64_t)sub_100F0920C, 0xCu);
  sub_100C62630(a1, "kCUReliableNetworkFallbackSet", (unint64_t)sub_100F09378, 3u);
  sub_100C62700(a1, "kCUReliableNetworkFallbackGet", (unint64_t)sub_100F095D0, 3u);
  sub_100C62700(a1, "kCUPolicySetOsVersion", (unint64_t)sub_100F09838, 0xCu);
  sub_100C62700(a1, "kCUPolicySetEx", (unint64_t)sub_100F09B48, 0xCu);

  return sub_100C62700(a1, "kCUPolicyGetEx", (unint64_t)sub_100F09BF8, 0xCu);
}

void sub_100F0915C(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  v6[0] = (void (*)(void, void))_NSConcreteStackBlock;
  v6[1] = (void (*)(void, void))3321888768;
  _DWORD v6[2] = (void (*)(void, void))sub_100F0A230;
  void v6[3] = (void (*)(void, void))&unk_1019FF548;
  uint64_t v5 = *(std::__shared_weak_count **)(a5 + 8);
  void v6[4] = *(void (**)(void, void))a5;
  long long v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F06FC8(a1, a4, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F091F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0920C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = *(xpc_object_t **)a5;
  if (*(void *)a5 && (xpc_object_t v9 = *v8) != 0)
  {
    xpc_retain(*v8);
    char v14 = v9;
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    char v14 = v9;
    if (!v9)
    {
      xpc_object_t v10 = xpc_null_create();
      xpc_object_t v9 = 0;
      goto LABEL_9;
    }
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v9);
    goto LABEL_10;
  }
  xpc_object_t v10 = xpc_null_create();
LABEL_9:
  char v14 = v10;
LABEL_10:
  v12[0] = (void (*)(void, void))_NSConcreteStackBlock;
  v12[1] = (void (*)(void, void))3321888768;
  v12[2] = (void (*)(void, void))sub_100F0A314;
  v12[3] = (void (*)(void, void))&unk_1019FF548;
  uint64_t v11 = *(std::__shared_weak_count **)(a5 + 8);
  void v12[4] = *(void (**)(void, void))a5;
  uint64_t v13 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  doCUPolicyGet(a1, a4, &v14, v12);
  xpc_release(v14);
  if (v13) {
    sub_10004D2C8(v13);
  }
  xpc_release(v9);
}

void sub_100F09340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  xpc_release(*(xpc_object_t *)(v16 - 40));
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100F09378(Registry **a1@<X0>, unint64_t a2@<X3>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    long long v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v22 = (const char *)v6;
  xpc_object_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v22);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    sub_100F07838();
    char v14 = qword_101B12F68;
    if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v22) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Policy server is not valid", (uint8_t *)&v22, 2u);
    }
    goto LABEL_23;
  }
LABEL_11:
  xpc_object_t v22 = (const char *)a2;
  xpc_object_t v23 = "kCUReliableNetworkFallbackUserSetting";
  sub_100048BAC((uint64_t)&v22, &object);
  uint64_t v16 = xpc::dyn_cast_or_default((xpc *)&object, 0, v15);
  xpc_release(object);
  subscriber::makeSimSlotRange();
  uint64_t v18 = (unsigned int *)v22;
  uint64_t v17 = (unsigned int *)v23;
  if (v22 != v23)
  {
    BOOL v19 = v24;
    while ((v19(*v18) & 1) == 0)
    {
      if (++v18 == v17)
      {
        uint64_t v18 = v17;
        break;
      }
    }
    BOOL v20 = (unsigned int *)v23;
LABEL_17:
    while (v18 != v20)
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v12 + 120))(v12, *v18, v16);
      int v21 = v18 + 1;
      uint64_t v18 = v17;
      if (v21 != v17)
      {
        uint64_t v18 = v21;
        while ((v19(*v18) & 1) == 0)
        {
          if (++v18 == v17)
          {
            uint64_t v18 = v17;
            goto LABEL_17;
          }
        }
      }
    }
  }
LABEL_23:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100F09588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F095D0(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  long long v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v19[0] = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, v19);
  if (v12)
  {
    uint64_t v14 = v12[3];
    char v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  char v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    sub_100F07838();
    uint64_t v16 = qword_101B12F68;
    if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v19[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Policy server is not valid", (uint8_t *)v19, 2u);
    }
    xpc_object_t v20 = xpc_int64_create(19);
    if (!v20) {
      xpc_object_t v20 = xpc_null_create();
    }
    v19[0] = *a5;
    v19[1] = (unint64_t)"kPosixError";
    sub_100035E70((uint64_t)v19, &v20, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v20);
    xpc_object_t v20 = 0;
    if (v15) {
      return;
    }
LABEL_18:
    sub_10004D2C8(v13);
    return;
  }
LABEL_15:
  unint64_t v18 = *a5;
  unint64_t v17 = a5[1];
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  v22[0] = off_101A6E4B8;
  v22[1] = v18;
  v22[2] = v17;
  v22[3] = v22;
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 104))(v14, v22);
  sub_1000D9250(v22);
  if ((v15 & 1) == 0) {
    goto LABEL_18;
  }
}

void sub_100F097E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100F09838(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_100F07838();
  unint64_t v6 = qword_101B12F68;
  if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I cu policy set os version", (uint8_t *)&buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *a1);
  unsigned int v9 = ServiceMap;
  if (v10 < 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_9;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_9:
    sub_100F07838();
    unint64_t v18 = qword_101B12F68;
    if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Policy server is not valid", (uint8_t *)&buf, 2u);
      if (v17) {
        return;
      }
      goto LABEL_22;
    }
LABEL_21:
    if (v17) {
      return;
    }
    goto LABEL_22;
  }
LABEL_14:
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v24 = 0;
  v21[0] = a4;
  v21[1] = "kCUPolicyOsVersion";
  sub_100048BAC((uint64_t)v21, &object);
  long long buf = 0uLL;
  uint64_t v26 = 0;
  xpc::dyn_cast_or_default();
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)buf);
  }
  xpc_release(object);
  sub_100F07838();
  BOOL v19 = qword_101B12F68;
  if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v20 = __p;
    if (v24 < 0) {
      xpc_object_t v20 = (void **)__p[0];
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I cu policy set os version to %{public}s", (uint8_t *)&buf, 0xCu);
  }
  (*(void (**)(uint64_t, void **))(*(void *)v16 + 128))(v16, __p);
  if ((SHIBYTE(v24) & 0x80000000) == 0) {
    goto LABEL_21;
  }
  operator delete(__p[0]);
  if (v17) {
    return;
  }
LABEL_22:
  sub_10004D2C8(v15);
}

void sub_100F09AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F09B48(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5)
{
  v6[0] = (void (*)(void, void))_NSConcreteStackBlock;
  v6[1] = (void (*)(void, void))3321888768;
  _DWORD v6[2] = (void (*)(void, void))sub_100F0A6BC;
  void v6[3] = (void (*)(void, void))&unk_1019FF548;
  uint64_t v5 = *(std::__shared_weak_count **)(a5 + 8);
  void v6[4] = *(void (**)(void, void))a5;
  long long v7 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F06FC8(a1, a4, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F09BE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F09BF8(Registry **a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, void **a5)
{
  memset(&v50, 0, sizeof(v50));
  *(void *)long long buf = a4;
  *(void *)&uint8_t buf[8] = "kCUPolicyBundleName";
  sub_100048BAC((uint64_t)buf, &object);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v46 = 0;
  xpc::dyn_cast_or_default();
  xpc_release(object);
  std::string::size_type size = HIBYTE(v50.__r_.__value_.__r.__words[2]);
  if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v50.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)size, *a1);
    uint64_t v10 = ServiceMap;
    if (v11 < 0)
    {
      uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v11;
    char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)__p);
    if (v15)
    {
      uint64_t v17 = v15[3];
      uint64_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        if (!v17)
        {
LABEL_60:
          if ((v18 & 1) == 0) {
            sub_10004D2C8(v16);
          }
          goto LABEL_62;
        }
LABEL_18:
        xpc_object_t object = 0;
        xpc_object_t v20 = xpc_copy(*a4);
        xpc_object_t v21 = v20;
        if (v20)
        {
          xpc_object_t object = v20;
        }
        else
        {
          xpc_object_t v21 = xpc_null_create();
          xpc_object_t object = v21;
          if (!v21)
          {
            xpc_object_t v22 = xpc_null_create();
            xpc_object_t v21 = 0;
            goto LABEL_25;
          }
        }
        if (xpc_get_type(v21) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v21);
          goto LABEL_26;
        }
        xpc_object_t v22 = xpc_null_create();
LABEL_25:
        xpc_object_t object = v22;
LABEL_26:
        xpc_release(v21);
        *(_OWORD *)long long __p = 0u;
        long long v46 = 0u;
        char v24 = (std::mutex *)Registry::getServiceMap(v23, *a1);
        xpc_object_t v25 = v24;
        if (v26 < 0)
        {
          xpc_object_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v28 = 5381;
          do
          {
            uint64_t v26 = v28;
            unsigned int v29 = *v27++;
            uint64_t v28 = (33 * v28) ^ v29;
          }
          while (v29);
        }
        std::mutex::lock(v24);
        *(void *)long long buf = v26;
        xpc_object_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
        if (v30)
        {
          uint64_t v32 = v30[3];
          xpc_object_t v31 = (std::__shared_weak_count *)v30[4];
          if (v31)
          {
            atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v25);
            atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v31);
            char v33 = 0;
LABEL_34:
            (*(void (**)(void **__return_ptr, uint64_t, std::string *))(*(void *)v32 + 48))(__p, v32, &v50);
            if ((v33 & 1) == 0) {
              sub_10004D2C8(v31);
            }
            if (!BYTE8(v46)) {
              sub_100093B44((std::string *)__p, &v50);
            }
            sub_100F07838();
            xpc_object_t v34 = qword_101B12F68;
            if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
            {
              xpc_object_t v35 = &v50;
              if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                xpc_object_t v35 = (std::string *)v50.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v36 = __p;
              if (SBYTE7(v46) < 0) {
                xpc_object_t v36 = (void **)__p[0];
              }
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = v35;
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v36;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Phone bundleID: [%{public}s] translated into watch bundleID: [%{public}s]", buf, 0x16u);
            }
            if ((SBYTE7(v46) & 0x80u) == 0) {
              xpc_object_t v37 = __p;
            }
            else {
              xpc_object_t v37 = (void **)__p[0];
            }
            xpc_object_t v43 = xpc_string_create((const char *)v37);
            if (!v43) {
              xpc_object_t v43 = xpc_null_create();
            }
            *(void *)long long buf = &object;
            *(void *)&uint8_t buf[8] = "kCUPolicyBundleName";
            sub_100035E70((uint64_t)buf, &v43, &v44);
            xpc_release(v44);
            xpc_object_t v44 = 0;
            xpc_release(v43);
            xpc_object_t v38 = *a4;
            xpc_object_t v42 = v38;
            xpc_object_t v43 = 0;
            if (v38) {
              xpc_retain(v38);
            }
            else {
              xpc_object_t v42 = xpc_null_create();
            }
            uint64_t v39 = (std::__shared_weak_count *)a5[1];
            uint64_t v40 = *a5;
            xpc_object_t v41 = v39;
            if (v39) {
              atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, const char *, xpc_object_t *, void **))(*(void *)v17 + 56))(v17, "kCUPolicyGetEx", &v42, &v40);
            if (v41) {
              sub_10004D2C8(v41);
            }
            xpc_release(v42);
            xpc_object_t v42 = 0;
            if (BYTE8(v46) && SBYTE7(v46) < 0) {
              operator delete(__p[0]);
            }
            xpc_release(object);
            goto LABEL_60;
          }
        }
        else
        {
          uint64_t v32 = 0;
        }
        std::mutex::unlock(v25);
        xpc_object_t v31 = 0;
        char v33 = 1;
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    uint64_t v16 = 0;
    char v18 = 1;
    if (!v17) {
      goto LABEL_60;
    }
    goto LABEL_18;
  }
  sub_100F07838();
  BOOL v19 = qword_101B12F68;
  if (os_log_type_enabled((os_log_t)qword_101B12F68, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Bundle name is not valid", (uint8_t *)__p, 2u);
  }
  xpc_object_t v47 = xpc_int64_create(22);
  if (!v47) {
    xpc_object_t v47 = xpc_null_create();
  }
  __p[0] = *a5;
  __p[1] = "kPosixError";
  sub_100035E70((uint64_t)__p, &v47, &v48);
  xpc_release(v48);
  xpc_object_t v48 = 0;
  xpc_release(v47);
  xpc_object_t v47 = 0;
LABEL_62:
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
}

void sub_100F0A110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,uint64_t a23,xpc_object_t object,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0A230(uint64_t a1, void **a2)
{
  xpc_object_t v3 = *a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _DWORD v6[2] = sub_100F0A2E4;
  void v6[3] = &unk_1019FF4E8;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  void v6[4] = v5;
  long long v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_dictionary_apply(v3, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F0A2CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F0A2E4(uint64_t a1, const char *a2, void *a3)
{
  xpc_object_t v3 = *(void ***)(a1 + 32);
  if (v3) {
    uint64_t v4 = *v3;
  }
  else {
    uint64_t v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

void sub_100F0A314(uint64_t a1, void **a2)
{
  xpc_object_t v3 = *a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _DWORD v6[2] = sub_100F0A3C8;
  void v6[3] = &unk_1019FF4E8;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  void v6[4] = v5;
  long long v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_dictionary_apply(v3, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F0A3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F0A3C8(uint64_t a1, const char *a2, void *a3)
{
  xpc_object_t v3 = *(void ***)(a1 + 32);
  if (v3) {
    uint64_t v4 = *v3;
  }
  else {
    uint64_t v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

void *sub_100F0A3F8(void *a1)
{
  *a1 = off_101A6E4B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F0A444(void *a1)
{
  *a1 = off_101A6E4B8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_100F0A4B0(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A6E4B8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F0A50C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A6E4B8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F0A544(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100F0A554(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100F0A594(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v3 = *a2;
  if (v3 >= 0x100)
  {
    sub_100F06D74((char)v3, &v6);
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = "kCUReliableNetworkFallbackGet";
    sub_10014E03C((uint64_t)&v4, &v6, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v6);
  }
  else
  {
    xpc_object_t v6 = xpc_int64_create(35);
    if (!v6) {
      xpc_object_t v6 = xpc_null_create();
    }
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = "kPosixError";
    sub_100035E70((uint64_t)&v4, &v6, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v6);
  }
}

uint64_t sub_100F0A670(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F0A6B0()
{
}

void sub_100F0A6BC(uint64_t a1, void **a2)
{
  unsigned int v3 = *a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3321888768;
  _DWORD v6[2] = sub_100F0A770;
  void v6[3] = &unk_1019FF4E8;
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  void v6[4] = v5;
  long long v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  xpc_dictionary_apply(v3, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F0A758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F0A770(uint64_t a1, const char *a2, void *a3)
{
  unsigned int v3 = *(void ***)(a1 + 32);
  if (v3) {
    uint64_t v4 = *v3;
  }
  else {
    uint64_t v4 = 0;
  }
  xpc_dictionary_set_value(v4, a2, a3);
  return 1;
}

uint64_t sub_100F0A7A0()
{
  return sub_100C624B8((uint64_t)&unk_101B12F62, (uint64_t)sub_100F09038);
}

void sub_100F0A7BC(void **a1)
{
  *a1 = off_101A6E538;
  uint64_t v2 = a1 + 1;
  sub_100465E6C(&v2);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100F0A818(void **a1)
{
  *a1 = off_101A6E538;
  uint64_t v2 = a1 + 1;
  sub_100465E6C(&v2);
  PB::Base::~Base((PB::Base *)a1);
  operator delete();
}

uint64_t sub_100F0A888(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 36)) {
    PB::TextFormatter::format(this, "pendingInstallStatus", *(_DWORD *)(a1 + 32));
  }
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  xpc_object_t v6 = *(uint64_t **)(a1 + 16);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, this, "slotInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100F0A93C(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 2)
      {
        *(unsigned char *)(a1 + 36) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 > 0xFFFFFFFFFFFFFFF5 || v22 + 10 > v23)
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v27 = 0;
          if (v23 <= v22) {
            unint64_t v23 = *((void *)this + 1);
          }
          while (1)
          {
            if (v23 == v22)
            {
              LODWORD(v27) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_43;
            }
            unint64_t v32 = v22 + 1;
            char v33 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v32;
            v27 |= (unint64_t)(v33 & 0x7F) << v30;
            if ((v33 & 0x80) == 0) {
              break;
            }
            v30 += 7;
            unint64_t v22 = v32;
            BOOL v14 = v31++ > 8;
            if (v14)
            {
LABEL_39:
              LODWORD(v27) = 0;
              goto LABEL_43;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v27) = 0;
          }
        }
        else
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          while (1)
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              break;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
            if (v14) {
              goto LABEL_39;
            }
          }
        }
LABEL_43:
        *(_DWORD *)(a1 + 32) = v27;
      }
      else
      {
        if (v20 == 1) {
          sub_100465C64();
        }
LABEL_24:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100F0ABFC(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Base ***)(result + 8);
  uint64_t v5 = *(const PB::Base ***)(result + 16);
  while (v4 != v5)
  {
    xpc_object_t v6 = *v4++;
    uint64_t result = PB::Writer::writeSubmessage(this, v6, 1u);
  }
  if (*(unsigned char *)(v3 + 36))
  {
    unsigned int v7 = *(_DWORD *)(v3 + 32);
    return PB::Writer::writeVarInt(this, v7, 2u);
  }
  return result;
}

void sub_100F0AC7C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_100F0AD08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A6E648;
  v8[1] = &v7;
  xpc_object_t v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100F0ADB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100F0ADCC(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v5 = a2;
  v6[0] = off_101A6E6C8;
  v6[1] = &v5;
  void v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100F0AE70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100F0AE8C(void *a1)
{
  *a1 = off_101A6E588;
  unint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F0AED8(void *a1)
{
  *a1 = off_101A6E588;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100F0AF44(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F0AFAC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0AFE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F0B020(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100F0B050(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100F0B098()
{
}

__n128 sub_100F0B0AC(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = off_101A6E648;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F0B0F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6E648;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F0B128(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder cfUuid:**(void **)(a1 + 8)];
  [v4 context:v3 capabilitiesChanged:**(void **)(a1 + 16)];
}

void sub_100F0B1A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100F0B1C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F0B204()
{
}

void sub_100F0B214()
{
}

void *sub_100F0B228(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A6E6C8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F0B270(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6E6C8;
  a2[1] = v2;
  return result;
}

id sub_100F0B29C(uint64_t a1, id *a2)
{
  return [*a2 phoneServicesCapabilitiesChanged:**(void **)(a1 + 8)];
}

uint64_t sub_100F0B2B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F0B2F0()
{
}

void sub_100F0B2FC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F0B408(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0B478(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2 || (v3 = *(void *)(a1 + 504), uint64_t v4 = *(void *)(a1 + 8), (v5 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v6 = v4 + 48;
  if (!v4) {
    uint64_t v6 = 0;
  }
  uint64_t v9 = v6;
  unsigned int v10 = v5;
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t *))(*(void *)v3 + 568))(&v11, v3, &v9);
  long long v7 = v11;
  long long v11 = 0uLL;
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 560);
  *(_OWORD *)(a1 + 552) = v7;
  if (v8)
  {
    sub_10004D2C8(v8);
    if (*((void *)&v11 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v11 + 1));
    }
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_100F0B540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F0B558(uint64_t a1, NSObject **a2, void *a3, void *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v19, kCtLoggingSystemName, "cp.sc.w");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v8 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v8) {
    dispatch_retain(v8);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v20, &v19);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v19);
  *(void *)a1 = off_101A6E748;
  *(void *)(a1 + 48) = off_101A6E800;
  *(void *)(a1 + 56) = off_101A6E840;
  sub_100058DB0(&__p, "CellularPlanSelectionControllerWatch");
  uint64_t v9 = *a2;
  dispatch_object_t v16 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  v15[1] = 0;
  ctu::RestModule::RestModule();
  if (v16) {
    dispatch_release(v16);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 248) = a1 + 256;
  *(void *)(a1 + 80) = a1 + 80;
  *(void *)(a1 + 88) = a1 + 80;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 480) = a1 + 488;
  *(void *)(a1 + 504) = *a3;
  uint64_t v10 = a3[1];
  *(void *)(a1 + 512) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 520) = *a4;
  uint64_t v11 = a4[1];
  *(void *)(a1 + 528) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *a3;
  char v13 = *a2;
  v15[0] = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v12 + 608))(v12, v15);
  if (v15[0]) {
    dispatch_release(v15[0]);
  }
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(void *)(a1 + 600) = a1 + 608;
  *(void *)(a1 + 624) = a1 + 632;
  *(void *)(a1 + 648) = a1 + 656;
  *(void *)(a1 + 752) = 0;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(void *)(a1 + 800) = 0;
  *(void *)(a1 + 832) = 0;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 729) = 0u;
  return a1;
}

void sub_100F0B858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, CellularPlanProvisioningMonitorModeDelegate *a12, ctu::OsLogLogger *a13, dispatch_object_t object, dispatch_object_t a15, dispatch_object_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23)
{
  if (object) {
    dispatch_release(object);
  }
  unsigned int v31 = *(std::__shared_weak_count **)(v24 + 528);
  if (v31) {
    std::__shared_weak_count::__release_weak(v31);
  }
  unint64_t v32 = *(std::__shared_weak_count **)(v24 + 512);
  if (v32) {
    sub_10004D2C8(v32);
  }
  sub_10019D614(v26, *(void **)(v24 + 488));
  a23 = a10;
  sub_1000C56F4((void ***)&a23);
  sub_1001509E4(v25);
  sub_10030AAD0(v28, *(void **)(v24 + 256));
  sub_1003C8134(v29);
  sub_100D151FC(a11);
  sub_100160A84(v27);
  char v33 = *(std::__shared_weak_count **)(v24 + 72);
  if (v33) {
    sub_10004D2C8(v33);
  }
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(a12);
  ctu::OsLogLogger::~OsLogLogger(a13);
  sub_100087E88(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_100F0B954(uint64_t a1)
{
  *(void *)a1 = off_101A6E748;
  *(void *)(a1 + 48) = off_101A6E800;
  uint64_t v2 = (CellularPlanProvisioningMonitorModeDelegate *)(a1 + 56);
  *(void *)(a1 + 56) = off_101A6E840;
  sub_100F18AC4((void *)(a1 + 808));
  if (*(char *)(a1 + 807) < 0) {
    operator delete(*(void **)(a1 + 784));
  }
  if (*(char *)(a1 + 775) < 0) {
    operator delete(*(void **)(a1 + 752));
  }
  if (*(char *)(a1 + 743) < 0) {
    operator delete(*(void **)(a1 + 720));
  }
  if (*(char *)(a1 + 719) < 0) {
    operator delete(*(void **)(a1 + 696));
  }
  if (*(char *)(a1 + 695) < 0) {
    operator delete(*(void **)(a1 + 672));
  }
  sub_10023A548(*(void **)(a1 + 656));
  sub_10005CD2C(a1 + 624, *(char **)(a1 + 632));
  sub_1003DDCEC(a1 + 600, *(void **)(a1 + 608));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 592);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 576);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 560);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 544);
  if (v6) {
    sub_10004D2C8(v6);
  }
  long long v7 = *(std::__shared_weak_count **)(a1 + 528);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 512);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_10019D614(a1 + 480, *(void **)(a1 + 488));
  uint64_t v11 = (void **)(a1 + 456);
  sub_1000C56F4(&v11);
  sub_1001509E4(a1 + 272);
  sub_10030AAD0(a1 + 248, *(void **)(a1 + 256));
  sub_1003C8134((unsigned char *)(a1 + 136));
  sub_100D151FC((void *)(a1 + 104));
  sub_100160A84((atomic_uint **)(a1 + 80));
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 72);
  if (v9) {
    sub_10004D2C8(v9);
  }
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100F0BB1C(uint64_t a1)
{
  return sub_100F0B954(a1 - 48);
}

uint64_t sub_100F0BB24(uint64_t a1)
{
  return sub_100F0B954(a1 - 56);
}

void sub_100F0BB2C(uint64_t a1)
{
  sub_100F0B954(a1);

  operator delete();
}

void sub_100F0BB64(uint64_t a1)
{
  sub_100F0B954(a1 - 48);

  operator delete();
}

void sub_100F0BBA0(uint64_t a1)
{
  sub_100F0B954(a1 - 56);

  operator delete();
}

void sub_100F0BBDC(uint64_t a1)
{
  (***(void (****)(long long *__return_ptr))(a1 + 504))(&v39);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, (Registry *)v39);
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
LABEL_9:
  *(void *)(a1 + 568) = v11;
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 576);
  *(void *)(a1 + 576) = v10;
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (*((void *)&v39 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v39 + 1));
  }
  (***(void (****)(long long *__return_ptr))(a1 + 504))(&v39);
  Registry::createRestModuleOneTimeUseConnection(&v20, (Registry *)v39);
  ctu::RestModule::connect();
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (*((void *)&v39 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v39 + 1));
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  char v13 = operator new(0x20uLL);
  *char v13 = off_101A6E9F0;
  v13[1] = a1;
  void v13[2] = sub_100F0CBB4;
  void v13[3] = 0;
  *((void *)&v40 + 1) = v13;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v39);
  if (SHIBYTE(v34) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  xpc_object_t v34 = sub_100F1977C;
  xpc_object_t v35 = &unk_101A6ECE0;
  uint64_t v36 = a1 + 8;
  xpc_object_t v37 = sub_100F0EEA4;
  uint64_t v38 = 0;
  BOOL v14 = _Block_copy(__p);
  char v15 = *(std::__shared_weak_count **)(a1 + 16);
  if (v15)
  {
    dispatch_object_t v16 = std::__shared_weak_count::lock(v15);
    if (v16)
    {
      unint64_t v17 = v16;
      char v18 = *(NSObject **)(a1 + 24);
      unint64_t v22 = v18;
      if (v14) {
        OsLogContext v19 = _Block_copy(v14);
      }
      else {
        OsLogContext v19 = 0;
      }
      unint64_t v23 = v19;
      dispatch_retain(v18);
      long long v39 = 0u;
      long long v40 = 0u;
      sub_100F1982C(v24, v18, v19);
      sub_100F1982C(v25, v24[0], v24[1]);
      sub_100F1982C(v26, v25[0], v25[1]);
      CFDictionaryRef theDict = 0;
      sub_100F1982C((NSObject **)aBlock, v26[0], v26[1]);
      sub_100F1982C(v28, aBlock[0], aBlock[1]);
      sub_100F1982C(v29, v28[0], v28[1]);
      sub_100F1982C(v30, v29[0], v29[1]);
      sub_100F1982C(&v32, v30[0], v30[1]);
      sub_100F1A01C((uint64_t)v30);
      sub_100F1A01C((uint64_t)v29);
      sub_100F1A01C((uint64_t)v28);
      CFDictionaryRef theDict = (CFDictionaryRef)&off_101A6ED00;
      sub_100F1A01C((uint64_t)aBlock);
      sub_100F1A01C((uint64_t)v26);
      sub_100A35D00((uint64_t *)&theDict, (uint64_t *)&v40 + 1);
      sub_100A36CB8((uint64_t *)&theDict);
      sub_100F1A01C((uint64_t)v25);
      sub_100F1A01C((uint64_t)v24);
      atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F0C8F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0CBB4(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (void *)(a1 + 672);
    if (*(char *)(a1 + 695) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136315138;
    long long v39 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Calculated selection: (%s)", buf, 0xCu);
    uint64_t v3 = *v2;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)(a1 + 696);
    if (*(char *)(a1 + 719) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    *(_DWORD *)long long buf = 136315138;
    long long v39 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I User selection: (%s)", buf, 0xCu);
  }
  char v6 = *(unsigned char *)(a1 + 743);
  if (v6 < 0)
  {
    if (!*(void *)(a1 + 728)) {
      goto LABEL_17;
    }
  }
  else if (!*(unsigned char *)(a1 + 743))
  {
    goto LABEL_17;
  }
  uint64_t v7 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = (void *)(a1 + 720);
    if (v6 < 0) {
      unsigned int v8 = (void *)*v8;
    }
    *(_DWORD *)long long buf = 136315138;
    long long v39 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I WARNING: System selection set to: %s", buf, 0xCu);
  }
LABEL_17:
  char v9 = *(unsigned char *)(a1 + 775);
  if (v9 < 0) {
    uint64_t v10 = *(void *)(a1 + 760);
  }
  else {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 775);
  }
  uint64_t v11 = *v2;
  if (v10 && os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = (void *)(a1 + 752);
    if (v9 < 0) {
      uint64_t v12 = (void *)*v12;
    }
    char v13 = "";
    if (!*(unsigned char *)(a1 + 776)) {
      char v13 = "does not ";
    }
    *(_DWORD *)long long buf = 136315394;
    long long v39 = v12;
    __int16 v40 = 2080;
    xpc_object_t v41 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I ICCID: (%s) %srequire active status", buf, 0x16u);
    uint64_t v11 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v14 = *(void **)(a1 + 616);
    *(_DWORD *)long long buf = 134217984;
    long long v39 = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Subscription Details (%lu)", buf, 0xCu);
  }
  char v15 = *(void **)(a1 + 600);
  if (v15 != (void *)(a1 + 608))
  {
    do
    {
      CellularPlanEntitlementSubscriptionDetails::dumpState((CellularPlanEntitlementSubscriptionDetails *)(v15 + 7), (const ctu::OsLogLogger *)v2);
      dispatch_object_t v16 = (void *)v15[1];
      if (v16)
      {
        do
        {
          unint64_t v17 = v16;
          dispatch_object_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          unint64_t v17 = (void *)v15[2];
          BOOL v18 = *v17 == (void)v15;
          char v15 = v17;
        }
        while (!v18);
      }
      char v15 = v17;
    }
    while (v17 != (void *)(a1 + 608));
  }
  OsLogContext v19 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = *(void **)(a1 + 640);
    *(_DWORD *)long long buf = 134217984;
    long long v39 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Selectable ICCIDs (%lu)", buf, 0xCu);
  }
  xpc_object_t v21 = *(void **)(a1 + 624);
  if (v21 != (void *)(a1 + 632))
  {
    do
    {
      unint64_t v22 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v23 = v21 + 4;
        if (*((char *)v21 + 55) < 0) {
          unint64_t v23 = (void *)*v23;
        }
        *(_DWORD *)long long buf = 136315138;
        long long v39 = v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s", buf, 0xCu);
      }
      uint64_t v24 = (void *)v21[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v21[2];
          BOOL v18 = *v25 == (void)v21;
          xpc_object_t v21 = v25;
        }
        while (!v18);
      }
      xpc_object_t v21 = v25;
    }
    while (v25 != (void *)(a1 + 632));
  }
  uint64_t v26 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = *(void **)(a1 + 664);
    *(_DWORD *)long long buf = 134217984;
    long long v39 = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Companion Info (%lu)", buf, 0xCu);
  }
  uint64_t v28 = *(void **)(a1 + 648);
  if (v28 != (void *)(a1 + 656))
  {
    do
    {
      char v29 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        char v30 = v28 + 4;
        if (*((char *)v28 + 55) < 0) {
          char v30 = (void *)*v30;
        }
        unsigned int v31 = (const char *)(v28 + 7);
        if (*((char *)v28 + 79) < 0) {
          unsigned int v31 = *(const char **)v31;
        }
        unint64_t v32 = v28 + 10;
        if (*((char *)v28 + 103) < 0) {
          unint64_t v32 = (void *)*v32;
        }
        *(_DWORD *)long long buf = 136315650;
        long long v39 = v30;
        __int16 v40 = 2080;
        xpc_object_t v41 = v31;
        __int16 v42 = 2080;
        xpc_object_t v43 = v32;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s: %s (%s)", buf, 0x20u);
      }
      char v33 = (void *)v28[1];
      if (v33)
      {
        do
        {
          xpc_object_t v34 = v33;
          char v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          xpc_object_t v34 = (void *)v28[2];
          BOOL v18 = *v34 == (void)v28;
          uint64_t v28 = v34;
        }
        while (!v18);
      }
      uint64_t v28 = v34;
    }
    while (v34 != (void *)(a1 + 656));
  }
  uint64_t v35 = *(void *)(a1 + 584);
  if (v35)
  {
    uint64_t v36 = *v2;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      int v37 = *(unsigned __int8 *)(a1 + 744);
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v39) = v37;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Check for initial plan activation: %d", buf, 8u);
      uint64_t v35 = *(void *)(a1 + 584);
    }
    (*(void (**)(uint64_t))(*(void *)v35 + 32))(v35);
  }
}

void sub_100F0D124(uint64_t a1, uint64_t *a2, size_t a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 456);
  uint64_t v5 = *(void *)(a1 + 464);
  uint64_t v6 = *a2;
  if (v5 - v4 == a2[1] - *a2)
  {
    while (1)
    {
      if (v4 == v5) {
        return;
      }
      if (!VinylInfo::operator==()) {
        break;
      }
      v4 += 88;
      v6 += 88;
    }
    uint64_t v4 = *(void *)(v3 + 456);
    uint64_t v5 = *(void *)(v3 + 464);
  }
  if (v4 != v5)
  {
    uint64_t v66 = v3 + 456;
    std::locale v73 = (std::string *)(v3 + 696);
    uint64_t v75 = (std::string *)(v3 + 672);
    uint64_t v67 = v3;
    while (1)
    {
      if (*(_DWORD *)(v4 + 12) != 3 || !*(unsigned char *)(v4 + 80)) {
        goto LABEL_133;
      }
      uint64_t v76 = 0;
      uint64_t v77 = 0;
      uint64_t v78 = 0;
      uint64_t v7 = *a2;
      uint64_t v8 = a2[1];
      if (*a2 != v8)
      {
        while (*(_DWORD *)(v7 + 4) != *(_DWORD *)(v4 + 4))
        {
          v7 += 88;
          if (v7 == v8) {
            goto LABEL_53;
          }
        }
      }
      if (v7 == v8 || !*(unsigned char *)(v7 + 80))
      {
LABEL_53:
        if (&v76 != (uint64_t *)(v4 + 56)) {
          sub_1000C87AC((uint64_t)&v76, *(void *)(v4 + 56), *(void *)(v4 + 64), 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v4 + 64) - *(void *)(v4 + 56)) >> 3));
        }
        goto LABEL_55;
      }
      uint64_t v10 = *(void *)(v4 + 56);
      uint64_t v9 = *(void *)(v4 + 64);
      uint64_t v12 = v7 + 56;
      uint64_t v11 = *(void *)(v7 + 56);
      uint64_t v71 = *(void *)(v12 + 8);
      if (0x84BDA12F684BDA13 * ((v9 - v10) >> 3) <= 0x84BDA12F684BDA13 * ((v71 - v11) >> 3)) {
        goto LABEL_55;
      }
      v87[0] = *(void *)(v4 + 56);
      uint64_t v84 = v11;
      char v13 = &v76;
      uint64_t v81 = &v76;
      if (v10 == v9)
      {
        uint64_t v10 = v9;
        goto LABEL_136;
      }
      uint64_t v69 = v5;
      do
      {
        uint64_t v14 = v84;
        if (v84 == v71) {
          goto LABEL_52;
        }
        char v15 = *(unsigned char *)(v10 + 39);
        a3 = *(void *)(v10 + 24);
        if (v15 >= 0) {
          uint64_t v16 = *(unsigned __int8 *)(v10 + 39);
        }
        else {
          uint64_t v16 = *(void *)(v10 + 24);
        }
        uint64_t v17 = *(unsigned __int8 *)(v84 + 39);
        size_t v18 = *(void *)(v84 + 24);
        if ((v17 & 0x80u) == 0) {
          uint64_t v19 = *(unsigned __int8 *)(v84 + 39);
        }
        else {
          uint64_t v19 = *(void *)(v84 + 24);
        }
        if (v16 != v19) {
          goto LABEL_37;
        }
        uint64_t v20 = (const void **)(v10 + 16);
        xpc_object_t v21 = *(const void **)(v84 + 16);
        if ((v17 & 0x80u) == 0) {
          unint64_t v22 = (unsigned __int8 *)(v84 + 16);
        }
        else {
          unint64_t v22 = *(unsigned __int8 **)(v84 + 16);
        }
        if ((*(unsigned char *)(v10 + 39) & 0x80) != 0)
        {
          if (memcmp(*v20, v22, a3)) {
            goto LABEL_37;
          }
        }
        else if (*(unsigned char *)(v10 + 39))
        {
          unint64_t v23 = (unsigned __int8 *)(v10 + 16);
          uint64_t v24 = *(unsigned __int8 *)(v10 + 39);
          while (*v23 == *v22)
          {
            ++v23;
            ++v22;
            if (!--v24) {
              goto LABEL_38;
            }
          }
LABEL_37:
          sub_100F1879C(&v81, v10);
          uint64_t v25 = v87;
          uint64_t v14 = v10;
          goto LABEL_50;
        }
LABEL_38:
        if (v15 >= 0) {
          uint64_t v26 = (unsigned __int8 *)(v10 + 16);
        }
        else {
          uint64_t v26 = (unsigned __int8 *)*v20;
        }
        if ((v17 & 0x80) == 0)
        {
          if (v17)
          {
            uint64_t v27 = 0;
            while (*(unsigned __int8 *)(v14 + v27 + 16) == v26[v27])
            {
              if (v17 == ++v27) {
                goto LABEL_48;
              }
            }
            goto LABEL_49;
          }
LABEL_48:
          v87[0] = v10 + 216;
          goto LABEL_49;
        }
        if (!memcmp(v21, v26, v18)) {
          goto LABEL_48;
        }
LABEL_49:
        uint64_t v25 = &v84;
LABEL_50:
        uint64_t v5 = v69;
        uint64_t *v25 = v14 + 216;
        uint64_t v10 = v87[0];
      }
      while (v87[0] != v9);
      uint64_t v10 = v9;
LABEL_52:
      char v13 = v81;
      uint64_t v3 = v67;
LABEL_136:
      for (*(void *)long long buf = v13; v10 != v9; v10 += 216)
        sub_100F1879C((uint64_t **)buf, v10);
      if (v77 - v76 == 216) {
        sub_100F163D4(v3, v76);
      }
LABEL_55:
      if (v76 == v77) {
        goto LABEL_132;
      }
      uint64_t v84 = 0;
      unint64_t v85 = 0;
      unint64_t v86 = 0;
      uint64_t v81 = 0;
      long long v82 = 0;
      unint64_t v83 = 0;
      memset(&__str, 0, sizeof(__str));
      ctu::hex((uint64_t *)&__str, (ctu *)(v4 + 16), (const void *)0x10, a3);
      uint64_t v29 = v76;
      uint64_t v28 = v77;
      while (2)
      {
        if (v29 != v28)
        {
          if (*(unsigned char *)(v29 + 88))
          {
LABEL_59:
            v29 += 216;
            continue;
          }
          for (uint64_t i = *(void ***)(v3 + 608); i; uint64_t i = (void **)*i)
          {
            if ((sub_100046FE8((void *)(v29 + 16), i + 4) & 0x80) == 0)
            {
              if ((sub_100046FE8(i + 4, (void **)(v29 + 16)) & 0x80) == 0) {
                goto LABEL_59;
              }
              ++i;
            }
          }
          uint64_t v111 = 0;
          *(_OWORD *)long long v109 = 0u;
          long long v110 = 0u;
          *(_OWORD *)long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          *(_OWORD *)long long v106 = 0u;
          *(_OWORD *)long long v103 = 0u;
          *(_OWORD *)long long v104 = 0u;
          *(_OWORD *)char v101 = 0u;
          long long v102 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v100 = 0u;
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 536) + 80))(buf);
          if ((_BYTE)v111)
          {
            unint64_t v31 = v85;
            if (v85 >= v86)
            {
              uint64_t v32 = sub_1003DBC84(&v84, (uint64_t)buf);
            }
            else
            {
              sub_10023FB90(v85, (uint64_t)buf);
              uint64_t v32 = v31 + 192;
            }
            unint64_t v85 = v32;
            goto LABEL_95;
          }
          uint64_t v98 = 256;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          memset(v87, 0, sizeof(v87));
          std::string::operator=((std::string *)((char *)&v88 + 8), (const std::string *)(v29 + 16));
          std::string::operator=((std::string *)&v87[1], &__str);
          if (*(char *)(v29 + 63) < 0)
          {
            if (!*(void *)(v29 + 48))
            {
LABEL_78:
              unint64_t v35 = v85;
              if (v85 >= v86)
              {
                uint64_t v36 = sub_1003DBC84(&v84, (uint64_t)v87);
              }
              else
              {
                sub_10023FB90(v85, (uint64_t)v87);
                uint64_t v36 = v35 + 192;
              }
              unint64_t v85 = v36;
              if (SHIBYTE(v97) < 0) {
                operator delete(*((void **)&v96 + 1));
              }
              if (SBYTE7(v96) < 0) {
                operator delete((void *)v95);
              }
              if (SHIBYTE(v94) < 0) {
                operator delete(*((void **)&v93 + 1));
              }
              if (SBYTE7(v93) < 0) {
                operator delete((void *)v92);
              }
              if (SHIBYTE(v91) < 0) {
                operator delete(*((void **)&v90 + 1));
              }
              if (SHIBYTE(v89) < 0) {
                operator delete(*((void **)&v88 + 1));
              }
              if (SBYTE7(v88) < 0) {
                operator delete((void *)v87[1]);
              }
LABEL_95:
              if ((_BYTE)v111)
              {
                if (SBYTE7(v110) < 0) {
                  operator delete(v109[0]);
                }
                if (SHIBYTE(v108) < 0) {
                  operator delete(v107[1]);
                }
                if (SHIBYTE(v107[0]) < 0) {
                  operator delete(v106[0]);
                }
                if (SHIBYTE(v105) < 0) {
                  operator delete(v104[1]);
                }
                if (SHIBYTE(v104[0]) < 0) {
                  operator delete(v103[0]);
                }
                if (SBYTE7(v102) < 0) {
                  operator delete(v101[0]);
                }
                if (SHIBYTE(v100) < 0) {
                  operator delete(*(void **)&buf[8]);
                }
              }
              if (!*(unsigned char *)(v29 + 89)) {
                goto LABEL_59;
              }
              std::string::operator=(v75, (const std::string *)(v29 + 16));
              if (*(char *)(v3 + 719) < 0)
              {
                if (*(void *)(v3 + 704)) {
                  goto LABEL_59;
                }
              }
              else if (*(unsigned char *)(v3 + 719))
              {
                goto LABEL_59;
              }
              int v37 = *(NSObject **)(v3 + 40);
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v38 = v29 + 16;
                if (*(char *)(v29 + 39) < 0) {
                  uint64_t v38 = *(void *)(v29 + 16);
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v38;
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Missing user selection - allowing (%s)", buf, 0xCu);
              }
              std::string::operator=(v73, (const std::string *)(v29 + 16));
              long long v39 = *(std::__shared_weak_count **)(v3 + 576);
              v79[0] = *(void *)(v3 + 568);
              v79[1] = v39;
              if (v39) {
                atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_100F0F92C(v79, @"RemotePlanSelectedKey", (uint64_t)v73);
              if (v39) {
                sub_10004D2C8(v39);
              }
              goto LABEL_59;
            }
          }
          else if (!*(unsigned char *)(v29 + 63))
          {
            goto LABEL_78;
          }
          LOWORD(v90) = bswap32(sub_100CCD574(v29 + 40)) >> 16;
          char v33 = v82;
          if ((unint64_t)v82 >= v83)
          {
            xpc_object_t v34 = (uint64_t *)sub_1003DBC84((uint64_t *)&v81, (uint64_t)v87);
          }
          else
          {
            sub_10023FB90((uint64_t)v82, (uint64_t)v87);
            xpc_object_t v34 = v33 + 24;
          }
          long long v82 = v34;
          goto LABEL_78;
        }
        break;
      }
      sub_100F13CCC(v3, &v84);
      if (v82 != v81)
      {
        (*(void (**)(void, uint64_t **, uint64_t))(**(void **)(v3 + 536) + 112))(*(void *)(v3 + 536), &v81, 1);
        __int16 v40 = *(std::__shared_weak_count **)(v3 + 528);
        if (v40)
        {
          xpc_object_t v41 = std::__shared_weak_count::lock(v40);
          if (v41)
          {
            __int16 v42 = v41;
            uint64_t v43 = *(void *)(v3 + 520);
            if (v43) {
              (*(void (**)(uint64_t, uint64_t, uint64_t **))(*(void *)v43 + 64))(v43, v4 + 16, &v81);
            }
            sub_10004D2C8(v42);
          }
        }
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      *(void *)long long buf = &v81;
      sub_10023FDC8((void ***)buf);
      *(void *)long long buf = &v84;
      sub_10023FDC8((void ***)buf);
LABEL_132:
      *(void *)long long buf = &v76;
      sub_1000C57C8((void ***)buf);
LABEL_133:
      v4 += 88;
      if (v4 == v5)
      {
        sub_100F0FC20(v3);
        if (*a2 == a2[1]) {
          sub_100F110AC(v3, v75);
        }
        xpc_object_t v44 = *(std::__shared_weak_count **)(v3 + 528);
        if (!v44) {
          return;
        }
        int64_t v45 = std::__shared_weak_count::lock(v44);
        if (!v45) {
          return;
        }
        long long v46 = v45;
        uint64_t v47 = *(void *)(v3 + 520);
        if (!v47) {
          goto LABEL_194;
        }
        if (*(char *)(v3 + 695) < 0)
        {
          if (!*(void *)(v3 + 680)) {
            goto LABEL_149;
          }
        }
        else
        {
          if (*(unsigned char *)(v3 + 695)) {
            goto LABEL_151;
          }
LABEL_149:
          if ((*(char *)(v3 + 775) & 0x80000000) == 0)
          {
            if (*(unsigned char *)(v3 + 775)) {
              goto LABEL_151;
            }
LABEL_197:
            (*(void (**)(uint64_t, uint64_t))(*(void *)v47 + 16))(v47, v66);
LABEL_194:
            sub_10004D2C8(v46);
            return;
          }
          if (!*(void *)(v3 + 760)) {
            goto LABEL_197;
          }
        }
LABEL_151:
        BOOL v70 = *(std::string **)(v3 + 520);
        std::locale v72 = v46;
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v100 = 0;
        sub_100311ED8(buf, *(void *)(v3 + 456), *(void *)(v3 + 464), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(v3 + 464) - *(void *)(v3 + 456)) >> 3));
        uint64_t v48 = *(void *)buf;
        uint64_t v49 = *(void *)&buf[8];
        if (*(void *)buf != *(void *)&buf[8])
        {
          int64x2_t v74 = (std::string *)(v3 + 752);
          do
          {
            if (!*(unsigned char *)(v48 + 80)) {
              goto LABEL_192;
            }
            uint64_t v51 = *(void *)(v48 + 56);
            uint64_t v50 = *(void *)(v48 + 64);
            if (v51 != v50)
            {
              int v52 = *(char *)(v67 + 695);
              if (v52 >= 0) {
                uint64_t v53 = *(unsigned __int8 *)(v67 + 695);
              }
              else {
                uint64_t v53 = *(void *)(v67 + 680);
              }
              for (uint64_t j = *(void *)(v48 + 56); j != v50; j += 216)
              {
                uint64_t v55 = *(unsigned __int8 *)(j + 39);
                size_t v56 = *(void *)(j + 24);
                if ((v55 & 0x80u) == 0) {
                  uint64_t v57 = *(unsigned __int8 *)(j + 39);
                }
                else {
                  uint64_t v57 = *(void *)(j + 24);
                }
                if (v57 == v53)
                {
                  if (v52 >= 0) {
                    xpc_object_t v58 = v75;
                  }
                  else {
                    xpc_object_t v58 = (std::string *)v75->__r_.__value_.__r.__words[0];
                  }
                  if ((v55 & 0x80) != 0)
                  {
                    if (!memcmp(*(const void **)(j + 16), v58, *(void *)(j + 24))) {
                      goto LABEL_191;
                    }
                  }
                  else
                  {
                    if (!*(unsigned char *)(j + 39)) {
                      goto LABEL_191;
                    }
                    uint64_t v59 = 0;
                    while (*(unsigned __int8 *)(j + v59 + 16) == v58->__r_.__value_.__s.__data_[v59])
                    {
                      if (v55 == ++v59) {
                        goto LABEL_191;
                      }
                    }
                  }
                }
                uint64_t v60 = *(unsigned __int8 *)(v67 + 775);
                int v61 = (char)v60;
                if ((v60 & 0x80u) != 0) {
                  uint64_t v60 = *(void *)(v67 + 760);
                }
                if (v57 == v60)
                {
                  if (v61 >= 0) {
                    uint64_t v62 = v74;
                  }
                  else {
                    uint64_t v62 = (std::string *)v74->__r_.__value_.__r.__words[0];
                  }
                  if ((v55 & 0x80) != 0)
                  {
                    if (!memcmp(*(const void **)(j + 16), v62, v56))
                    {
                      do
                      {
LABEL_191:
                        *(unsigned char *)(v51 + 89) = sub_100F109FC(v67, (unsigned __int8 *)(v51 + 16));
                        v51 += 216;
                      }
                      while (v51 != v50);
                      goto LABEL_192;
                    }
                  }
                  else
                  {
                    if (!v55) {
                      goto LABEL_191;
                    }
                    uint64_t v63 = 0;
                    while (*(unsigned __int8 *)(j + v63 + 16) == v62->__r_.__value_.__s.__data_[v63])
                    {
                      if (v55 == ++v63) {
                        goto LABEL_191;
                      }
                    }
                  }
                }
              }
            }
            unint64_t v64 = *(NSObject **)(v67 + 40);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
            {
              long long v65 = v75;
              if (*(char *)(v67 + 695) < 0) {
                long long v65 = (std::string *)v75->__r_.__value_.__r.__words[0];
              }
              LODWORD(v87[0]) = 136315138;
              *(void *)((char *)v87 + 4) = v65;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Missing profile for override: (%s)", (uint8_t *)v87, 0xCu);
            }
LABEL_192:
            v48 += 88;
          }
          while (v48 != v49);
        }
        (*(void (**)(std::string *, uint8_t *))(v70->__r_.__value_.__r.__words[0] + 16))(v70, buf);
        v87[0] = buf;
        sub_1000C56F4((void ***)v87);
        long long v46 = v72;
        goto LABEL_194;
      }
    }
  }
}

void sub_100F0DBE4(_Unwind_Exception *a1)
{
  uint64_t v3 = v1;
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_100F0DCF0(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 272);
  if (*a2 != v4)
  {
    if (v4 == 2)
    {
      sub_10023A548(*(void **)(a1 + 656));
      *(void *)(a1 + 648) = a1 + 656;
      *(void *)(a1 + 664) = 0;
      *(void *)(a1 + 656) = 0;
    }
    uint64_t v5 = *(void **)(a1 + 600);
    if (v5 != (void *)(a1 + 608))
    {
      BOOL v6 = 0;
      while (1)
      {
        uint64_t v7 = (const void **)(v5 + 11);
        if (sub_100F11C04(a1, (uint64_t)(v5 + 7)))
        {
          sub_100046BAC((uint64_t **)(a1 + 624), (void **)v5 + 11, (uint64_t)(v5 + 11));
          int v9 = (v8 | v6) & 1;
        }
        else
        {
          int v9 = v6 | (sub_1000E9358((uint64_t **)(a1 + 624), (void **)v5 + 11) != 0);
          if (*(unsigned char *)(a1 + 272) != 2) {
            goto LABEL_35;
          }
          uint64_t v10 = *((unsigned __int8 *)v5 + 111);
          if ((v10 & 0x80u) == 0) {
            uint64_t v11 = *((unsigned __int8 *)v5 + 111);
          }
          else {
            uint64_t v11 = v5[12];
          }
          uint64_t v12 = *(unsigned __int8 *)(a1 + 719);
          int v13 = (char)v12;
          if ((v12 & 0x80u) != 0) {
            uint64_t v12 = *(void *)(a1 + 704);
          }
          if (v11 != v12) {
            goto LABEL_35;
          }
          if (v13 >= 0) {
            uint64_t v14 = (unsigned __int8 *)(a1 + 696);
          }
          else {
            uint64_t v14 = *(unsigned __int8 **)(a1 + 696);
          }
          if ((v10 & 0x80) == 0)
          {
            if (*((unsigned char *)v5 + 111))
            {
              char v15 = v14;
              while (*(unsigned __int8 *)v7 == *v15)
              {
                uint64_t v7 = (const void **)((char *)v7 + 1);
                ++v15;
                if (!--v10) {
                  goto LABEL_25;
                }
              }
              goto LABEL_35;
            }
LABEL_25:
            uint64_t v16 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v14;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Disabling (%s) due to pairing mode", (uint8_t *)&buf, 0xCu);
              LOBYTE(v13) = *(unsigned char *)(a1 + 719);
            }
            if ((v13 & 0x80) != 0)
            {
              **(unsigned char **)(a1 + 696) = 0;
              *(void *)(a1 + 704) = 0;
            }
            else
            {
              *(unsigned char *)(a1 + 696) = 0;
              *(unsigned char *)(a1 + 719) = 0;
            }
            uint64_t v17 = *(std::__shared_weak_count **)(a1 + 576);
            v29[0] = *(void *)(a1 + 568);
            v29[1] = v17;
            if (v17) {
              atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            sub_100F0F92C(v29, @"RemotePlanSelectedKey", a1 + 696);
            if (v17) {
              sub_10004D2C8(v17);
            }
            sub_100F0FC20(a1);
            goto LABEL_35;
          }
          if (!memcmp(*v7, v14, v5[12])) {
            goto LABEL_25;
          }
        }
LABEL_35:
        BOOL v6 = v9 != 0;
        size_t v18 = (void *)v5[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            size_t v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v19 = (void *)v5[2];
            BOOL v20 = *v19 == (void)v5;
            uint64_t v5 = v19;
          }
          while (!v20);
        }
        uint64_t v5 = v19;
        if (v19 == (void *)(a1 + 608))
        {
          if (v9)
          {
            xpc_object_t v21 = *(std::__shared_weak_count **)(a1 + 528);
            if (v21)
            {
              unint64_t v22 = std::__shared_weak_count::lock(v21);
              if (v22)
              {
                unint64_t v23 = v22;
                uint64_t v24 = *(void *)(a1 + 520);
                if (v24) {
                  (*(void (**)(uint64_t))(*(void *)v24 + 32))(v24);
                }
                sub_10004D2C8(v23);
              }
            }
          }
          break;
        }
      }
    }
  }
  if (a2[177] != 2 && *(unsigned char *)(a1 + 449) == 2 && *(void *)(a1 + 456) != *(void *)(a1 + 464))
  {
    uint64_t v25 = *(std::__shared_weak_count **)(a1 + 528);
    if (v25)
    {
      uint64_t v26 = std::__shared_weak_count::lock(v25);
      if (v26)
      {
        uint64_t v27 = v26;
        uint64_t v28 = *(void *)(a1 + 520);
        if (v28)
        {
          long long v33 = *(_OWORD *)(*(void *)(a1 + 456) + 16);
          long long buf = 0uLL;
          uint64_t v32 = 0;
          (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 536) + 104))(&buf);
          (*(void (**)(uint64_t, long long *, long long *))(*(void *)v28 + 64))(v28, &v33, &buf);
          p_long long buf = (void **)&buf;
          sub_10023FDC8(&p_buf);
        }
        sub_10004D2C8(v27);
      }
    }
  }
}

void sub_100F0E098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10023FDC8((void ***)va);
  sub_10004D2C8(v6);
  _Unwind_Resume(a1);
}

void sub_100F0E0D8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 272) == 2 && *(void *)(a1 + 456) != *(void *)(a1 + 464) && !*(void *)(a1 + 584))
  {
    long long __dst = 0uLL;
    uint64_t v41 = 0;
    if (*(char *)(a1 + 719) < 0)
    {
      sub_10004FC84(&__dst, *(void **)(a1 + 696), *(void *)(a1 + 704));
    }
    else
    {
      long long __dst = *(_OWORD *)(a1 + 696);
      uint64_t v41 = *(void *)(a1 + 712);
    }
    int v4 = sub_100046F68(a1 + 248, (void **)&__dst);
    uint64_t v5 = v4;
    if ((void **)(a1 + 256) != v4 && (*((unsigned char *)v4 + 57) & 8) != 0)
    {
      BOOL v6 = sub_100046F68(a2, (void **)&__dst);
      if ((void **)(a2 + 8) == v6 || (*((unsigned char *)v6 + 57) & 8) == 0)
      {
        int v9 = (char *)v5[9];
        int v8 = v5 + 9;
        uint64_t v7 = v9;
        if (!v9) {
          goto LABEL_28;
        }
        uint64_t v10 = v8;
        do
        {
          int v11 = *((_DWORD *)v7 + 7);
          BOOL v12 = v11 < 11;
          if (v11 >= 11) {
            int v13 = (char **)v7;
          }
          else {
            int v13 = (char **)(v7 + 8);
          }
          if (!v12) {
            uint64_t v10 = (void **)v7;
          }
          uint64_t v7 = *v13;
        }
        while (*v13);
        if (v10 != v8
          && *((int *)v10 + 7) <= 11
          && ((int v14 = *((_DWORD *)v10 + 8), v14 != 6) ? (v15 = v14 == 1) : (v15 = 1), v15))
        {
          uint64_t v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Invalid entiltement result", buf, 2u);
          }
        }
        else
        {
LABEL_28:
          uint64_t v17 = *(void *)(a1 + 504);
          size_t v18 = *(NSObject **)(a1 + 24);
          dispatch_object_t v39 = v18;
          if (v18) {
            dispatch_retain(v18);
          }
          uint64_t v19 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v19 || (uint64_t v20 = *(void *)(a1 + 8), (v21 = std::__shared_weak_count::lock(v19)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v22 = v20 + 56;
          if (!v20) {
            uint64_t v22 = 0;
          }
          uint64_t v37 = v22;
          uint64_t v38 = v21;
          (*(void (**)(uint8_t *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *, uint64_t, uint64_t, BOOL))(*(void *)v17 + 496))(buf, v17, &v39, &v37, *(void *)(a1 + 456) + 16, a1 + 696, *(unsigned char *)(a1 + 744) == 0);
          unint64_t v23 = (uint64_t *)(a1 + 584);
          long long v24 = *(_OWORD *)buf;
          memset(buf, 0, sizeof(buf));
          uint64_t v25 = *(std::__shared_weak_count **)(a1 + 592);
          *(_OWORD *)(a1 + 584) = v24;
          if (v25)
          {
            sub_10004D2C8(v25);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          if (v38) {
            sub_10004D2C8(v38);
          }
          if (v39) {
            dispatch_release(v39);
          }
          uint64_t v26 = *v23;
          if (*v23)
          {
            if (*(unsigned char *)(a1 + 744))
            {
              memset(buf, 0, sizeof(buf));
              uint64_t v36 = 0;
              (***(void (****)(Registry **__return_ptr))(a1 + 504))(&v31);
              sub_1008FB518(v31, &v33);
              sub_100F15EEC(buf, v33);
              if (v34) {
                sub_10004D2C8(v34);
              }
              if (v32) {
                sub_10004D2C8(v32);
              }
              uint64_t v27 = *v23;
              uint64_t v29 = 0;
              uint64_t v30 = 0;
              long long __p = 0;
              sub_10015C7D4(&__p, *(const void **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
              (*(void (**)(uint64_t, void **))(*(void *)v27 + 16))(v27, &__p);
              if (__p)
              {
                uint64_t v29 = __p;
                operator delete(__p);
              }
              if (*(void *)buf)
              {
                *(void *)&uint8_t buf[8] = *(void *)buf;
                operator delete(*(void **)buf);
              }
              uint64_t v26 = *v23;
            }
            (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
          }
        }
      }
    }
    if (SHIBYTE(v41) < 0) {
      operator delete((void *)__dst);
    }
  }
}

void sub_100F0E420(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  if (*(char *)(v21 - 41) < 0) {
    operator delete(*(void **)(v21 - 64));
  }
  _Unwind_Resume(exception_object);
}

void sub_100F0E4C8(uint64_t a1)
{
  if (*(void *)(a1 + 456) == *(void *)(a1 + 464))
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unint64_t v31 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I No vinyl info available", v31, 2u);
    }
  }
  else
  {
    uint64_t v2 = *(void **)(a1 + 480);
    uint64_t v3 = (void *)(a1 + 488);
    if (v2 != (void *)(a1 + 488))
    {
      do
      {
        if (*((char *)v2 + 103) < 0)
        {
          if (v2[11])
          {
LABEL_7:
            *(_OWORD *)uint64_t v26 = 0u;
            long long v27 = 0u;
            *(_OWORD *)long long v24 = 0u;
            long long v25 = 0u;
            *(_OWORD *)__n = 0u;
            *(_OWORD *)unint64_t v23 = 0u;
            *(_OWORD *)uint64_t v20 = 0u;
            *(_OWORD *)__s1 = 0u;
            *(_OWORD *)size_t v18 = 0u;
            long long v19 = 0u;
            memset(__p, 0, sizeof(__p));
            BYTE9(v27) = 1;
            uint64_t v43 = 0;
            *(_OWORD *)uint64_t v41 = 0u;
            long long v42 = 0u;
            *(_OWORD *)dispatch_object_t v39 = 0u;
            long long v40 = 0u;
            long long v37 = 0u;
            *(_OWORD *)uint64_t v38 = 0u;
            *(_OWORD *)unint64_t v35 = 0u;
            *(_OWORD *)uint64_t v36 = 0u;
            *(_OWORD *)uint64_t v33 = 0u;
            long long v34 = 0u;
            *(_OWORD *)unint64_t v31 = 0u;
            long long v32 = 0u;
            (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 536) + 88))(v31);
            if ((_BYTE)v43)
            {
              __p[0] = *(void **)v31;
              std::string::operator=((std::string *)&__p[1], (const std::string *)&v31[8]);
              std::string::operator=((std::string *)v18, (const std::string *)v33);
              WORD4(v19) = WORD4(v34);
              std::string::operator=((std::string *)v20, (const std::string *)v35);
              std::string::operator=((std::string *)&__s1[1], (const std::string *)&v36[1]);
              std::string::operator=((std::string *)v23, (const std::string *)v38);
              std::string::operator=((std::string *)&v24[1], (const std::string *)&v39[1]);
              std::string::operator=((std::string *)v26, (const std::string *)v41);
              WORD4(v27) = WORD4(v42);
            }
            else
            {
              int v4 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
              {
                if ((SBYTE7(v19) & 0x80u) == 0) {
                  BOOL v6 = v18;
                }
                else {
                  BOOL v6 = (void **)v18[0];
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v6;
                _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I No details (%s) creating empty record", buf, 0xCu);
              }
              ctu::hex((uint64_t *)buf, (ctu *)(*(void *)(a1 + 456) + 16), (const void *)0x10, v5);
              if (SHIBYTE(__p[3]) < 0) {
                operator delete(__p[1]);
              }
              *(_OWORD *)&__p[1] = *(_OWORD *)buf;
              __p[3] = v30;
              std::string::operator=((std::string *)v18, (const std::string *)(v2 + 4));
            }
            if ((_BYTE)v43)
            {
              if (SBYTE7(v42) < 0) {
                operator delete(v41[0]);
              }
              if (SHIBYTE(v40) < 0) {
                operator delete(v39[1]);
              }
              if (SHIBYTE(v39[0]) < 0) {
                operator delete(v38[0]);
              }
              if (SHIBYTE(v37) < 0) {
                operator delete(v36[1]);
              }
              if (SHIBYTE(v36[0]) < 0) {
                operator delete(v35[0]);
              }
              if (SBYTE7(v34) < 0) {
                operator delete(v33[0]);
              }
              if (SHIBYTE(v32) < 0) {
                operator delete(*(void **)&v31[8]);
              }
            }
            uint64_t v7 = HIBYTE(__n[1]);
            if ((__n[1] & 0x8000000000000000) == 0) {
              size_t v8 = HIBYTE(__n[1]);
            }
            else {
              size_t v8 = __n[0];
            }
            uint64_t v9 = *((unsigned __int8 *)v2 + 103);
            int v10 = (char)v9;
            if ((v9 & 0x80u) != 0) {
              uint64_t v9 = v2[11];
            }
            if (v8 != v9) {
              goto LABEL_48;
            }
            if (v10 >= 0) {
              int v11 = (unsigned __int8 *)(v2 + 10);
            }
            else {
              int v11 = (unsigned __int8 *)v2[10];
            }
            if ((__n[1] & 0x8000000000000000) != 0)
            {
              if (memcmp(__s1[1], v11, __n[0])) {
                goto LABEL_48;
              }
            }
            else if (HIBYTE(__n[1]))
            {
              BOOL v12 = &__s1[1];
              while (*(unsigned __int8 *)v12 == *v11)
              {
                BOOL v12 = (void **)((char *)v12 + 1);
                ++v11;
                if (!--v7) {
                  goto LABEL_62;
                }
              }
LABEL_48:
              std::string::operator=((std::string *)&__s1[1], (const std::string *)(v2 + 10));
              sub_10023FB90((uint64_t)v31, (uint64_t)__p);
              memset(buf, 0, sizeof(buf));
              uint64_t v30 = 0;
              v28[0] = (void **)buf;
              v28[1] = 0;
              *(void *)long long buf = operator new(0xC0uLL);
              *(void *)&uint8_t buf[8] = *(void *)buf;
              uint64_t v30 = (void *)(*(void *)buf + 192);
              *(void *)&uint8_t buf[8] = sub_10037AC44((uint64_t)&v30, (uint64_t)v31, (uint64_t)&v43, *(uint64_t *)buf);
              sub_100F16C88(a1, (uint64_t *)buf);
              v28[0] = (void **)buf;
              sub_10023FDC8(v28);
              if (SBYTE7(v42) < 0) {
                operator delete(v41[0]);
              }
              if (SHIBYTE(v40) < 0) {
                operator delete(v39[1]);
              }
              if (SHIBYTE(v39[0]) < 0) {
                operator delete(v38[0]);
              }
              if (SHIBYTE(v37) < 0) {
                operator delete(v36[1]);
              }
              if (SHIBYTE(v36[0]) < 0) {
                operator delete(v35[0]);
              }
              if (SBYTE7(v34) < 0) {
                operator delete(v33[0]);
              }
              if (SHIBYTE(v32) < 0) {
                operator delete(*(void **)&v31[8]);
              }
            }
LABEL_62:
            if (SBYTE7(v27) < 0) {
              operator delete(v26[0]);
            }
            if (SHIBYTE(v25) < 0) {
              operator delete(v24[1]);
            }
            if (SHIBYTE(v24[0]) < 0) {
              operator delete(v23[0]);
            }
            if (SHIBYTE(__n[1]) < 0) {
              operator delete(__s1[1]);
            }
            if (SHIBYTE(__s1[0]) < 0) {
              operator delete(v20[0]);
            }
            if (SBYTE7(v19) < 0) {
              operator delete(v18[0]);
            }
            if (SHIBYTE(__p[3]) < 0) {
              operator delete(__p[1]);
            }
          }
        }
        else if (*((unsigned char *)v2 + 103))
        {
          goto LABEL_7;
        }
        int v13 = (void *)v2[1];
        if (v13)
        {
          do
          {
            int v14 = v13;
            int v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            int v14 = (void *)v2[2];
            BOOL v15 = *v14 == (void)v2;
            uint64_t v2 = v14;
          }
          while (!v15);
        }
        uint64_t v2 = v14;
      }
      while (v14 != v3);
    }
  }
}

void sub_100F0EA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (LOBYTE(STACK[0x220])) {
    sub_1000C62D8((uint64_t)&a53);
  }
  sub_1000C62D8((uint64_t)&a23);
  _Unwind_Resume(a1);
}

void sub_100F0EA7C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 528);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v13 = *(void *)(a1 + 520);
      if (v13)
      {
        uint64_t v5 = *(void *)(a1 + 456);
        uint64_t v12 = *(void *)(a1 + 464);
        if (v5 != v12)
        {
          while (1)
          {
            if (*(unsigned char *)(v5 + 80))
            {
              uint64_t v7 = *(void *)(v5 + 56);
              uint64_t v6 = *(void *)(v5 + 64);
              if (v7 != v6) {
                break;
              }
            }
LABEL_34:
            v5 += 88;
            if (v5 == v12) {
              goto LABEL_35;
            }
          }
          while (1)
          {
            if (*(char *)(v7 + 63) < 0)
            {
              if (!*(void *)(v7 + 48))
              {
LABEL_11:
                size_t v8 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v9 = (void *)(v7 + 16);
                  if (*(char *)(v7 + 39) < 0) {
                    uint64_t v9 = (void *)*v9;
                  }
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = v9;
                  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I nickname is empty for profile (%s) - defaulting to kSecondary", buf, 0xCu);
                }
                *(_OWORD *)long long __p = 0u;
                long long v28 = 0u;
                *(_OWORD *)long long v25 = 0u;
                long long v26 = 0u;
                long long v23 = 0u;
                *(_OWORD *)long long v24 = 0u;
                *(_OWORD *)uint64_t v21 = 0u;
                *(_OWORD *)uint64_t v22 = 0u;
                *(_OWORD *)long long v19 = 0u;
                *(_OWORD *)__val = 0u;
                memset(buf, 0, sizeof(buf));
                BYTE9(v28) = 1;
                std::string::operator=((std::string *)v19, (const std::string *)(v7 + 16));
                ctu::hex((uint64_t *)&v16, (ctu *)(v5 + 16), (const void *)0x10, v10);
                if ((char)buf[31] < 0) {
                  operator delete(*(void **)&buf[8]);
                }
                *(_OWORD *)&uint8_t buf[8] = v16;
                *(void *)&unsigned char buf[24] = v17;
                LOWORD(__val[2]) = 256;
                uint64_t v14 = v13;
                BOOL v15 = v4;
                atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_100F16A14(&v14, v5 + 16, v7, BYTE1(__val[2]), LOBYTE(__val[2]));
                if (v15) {
                  sub_10004D2C8(v15);
                }
                *(void *)&long long v16 = v19;
                int v11 = sub_1003DF1C0((uint64_t **)(a1 + 600), v19, (uint64_t)&unk_10144E20E, (long long **)&v16);
                CellularPlanEntitlementSubscriptionDetails::merge((CellularPlanEntitlementSubscriptionDetails *)(v11 + 7), (const CellularPlanEntitlementSubscriptionDetails *)buf);
                if (SBYTE7(v28) < 0) {
                  operator delete(__p[0]);
                }
                if (SHIBYTE(v26) < 0) {
                  operator delete(v25[1]);
                }
                if (SHIBYTE(v25[0]) < 0) {
                  operator delete(v24[0]);
                }
                if (SHIBYTE(v23) < 0) {
                  operator delete(v22[1]);
                }
                if (SHIBYTE(v22[0]) < 0) {
                  operator delete(v21[0]);
                }
                if (SHIBYTE(__val[1]) < 0) {
                  operator delete(v19[0]);
                }
                if ((char)buf[31] < 0) {
                  operator delete(*(void **)&buf[8]);
                }
              }
            }
            else if (!*(unsigned char *)(v7 + 63))
            {
              goto LABEL_11;
            }
            v7 += 216;
            if (v7 == v6) {
              goto LABEL_34;
            }
          }
        }
      }
LABEL_35:
      sub_10004D2C8(v4);
    }
  }
}

void sub_100F0ED24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  if (a9) {
    sub_10004D2C8(a9);
  }
  sub_1000C62D8((uint64_t)va);
  sub_10004D2C8(v13);
  _Unwind_Resume(a1);
}

const void **sub_100F0ED58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef theDict = 0;
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, void, const CFStringRef, const CFStringRef))(*(void *)a2 + 40))(&v7, a2, a3, kRemoteCellularPlanStorage, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_10004EFE4(&theDict, (CFTypeRef *)&v7);
  sub_1000577C4((const void **)&v7);
  if (theDict) {
    int v4 = sub_100080778;
  }
  else {
    int v4 = 0;
  }
  if (v4 && CFDictionaryContainsKey(theDict, @"iccid"))
  {
    CFDictionaryGetValue(theDict, @"iccid");
    long long v7 = 0uLL;
    uint64_t v8 = 0;
    ctu::cf::assign();
    *(_OWORD *)a1 = v7;
    *(void *)(a1 + 16) = v8;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100F0EE68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100057D78((const void **)&a9);
  _Unwind_Resume(a1);
}

void sub_100F0EEA4(uint64_t a1, long long *a2, int a3, uint64_t *a4)
{
  void (***v12)(Registry **__return_ptr);
  std::__shared_weak_count *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  void *v17[2];
  long long v18;
  void *v19[2];
  long long v20;
  void *v21[2];
  void *v22[2];
  long long v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  uint64_t v29;
  long long __dst;
  uint64_t v31;
  void **v32[2];
  std::string buf;
  char v34;
  void *v35;
  char v36;
  void *v37;
  char v38;
  void *v39;
  char v40;
  void *v41;
  char v42;
  void *v43;
  char v44;
  void *__p;
  char v46;
  unsigned char v47[8];

  if (*(unsigned char *)(a1 + 272) == 2)
  {
    long long __dst = 0uLL;
    unint64_t v31 = 0;
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long __dst = *a2;
      unint64_t v31 = *((void *)a2 + 2);
    }
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v24 = 0u;
    *(_OWORD *)uint64_t v22 = 0u;
    long long v23 = 0u;
    uint64_t v20 = 0u;
    *(_OWORD *)uint64_t v21 = 0u;
    size_t v18 = 0u;
    *(_OWORD *)long long v19 = 0u;
    *(_OWORD *)uint64_t v17 = 0u;
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 536) + 88))(v17);
    if ((_BYTE)v29)
    {
      if (BYTE9(v20) != 2) {
        goto LABEL_11;
      }
      uint64_t v7 = HIBYTE(v26);
      if (v26 < 0) {
        uint64_t v7 = v26;
      }
      if (!v7 || BYTE8(v28))
      {
        if (a3 != 2)
        {
          uint64_t v9 = *a4;
          if (*a4 && *(_DWORD *)v9 == 6000)
          {
            uint64_t v11 = *(void *)(v9 + 8);
            unint64_t v10 = *(std::__shared_weak_count **)(v9 + 16);
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v11 && *(unsigned char *)(v11 + 24))
            {
              uint64_t v12 = *(void (****)(Registry **__return_ptr))(a1 + 504);
              uint64_t v13 = *(std::__shared_weak_count **)(a1 + 512);
              if (v13) {
                atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v17[0] = COERCE_VOID_(sub_100F12924(v12));
              if (v13) {
                sub_10004D2C8(v13);
              }
              std::string::operator=((std::string *)((char *)&v25 + 8), (const std::string *)v11);
              if (*(unsigned char *)(v11 + 56))
              {
                if (*(char *)(v11 + 55) < 0) {
                  sub_10004FC84(&buf, *(void **)(v11 + 32), *(void *)(v11 + 40));
                }
                else {
                  long long buf = *(std::string *)(v11 + 32);
                }
              }
              else
              {
                memset(&buf, 0, sizeof(buf));
              }
              std::string::operator=((std::string *)&v27, &buf);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              BYTE8(v28) = 1;
            }
          }
          else
          {
            unint64_t v10 = 0;
          }
          sub_100F16D70(a1, (unsigned __int8 *)&__dst, (uint64_t)v17);
          if (!(_BYTE)v29) {
            sub_10016C840();
          }
          sub_10023FB90((uint64_t)&buf, (uint64_t)v17);
          uint64_t v14 = 0;
          BOOL v15 = 0;
          long long v16 = 0;
          v32[0] = (void **)&v14;
          v32[1] = 0;
          uint64_t v14 = (char *)operator new(0xC0uLL);
          BOOL v15 = (uint64_t)v14;
          long long v16 = v14 + 192;
          BOOL v15 = sub_10037AC44((uint64_t)&v16, (uint64_t)&buf, (uint64_t)v47, (uint64_t)v14);
          sub_100F16C88(a1, (uint64_t *)&v14);
          v32[0] = (void **)&v14;
          sub_10023FDC8(v32);
          if (v46 < 0) {
            operator delete(__p);
          }
          if (v44 < 0) {
            operator delete(v43);
          }
          if (v42 < 0) {
            operator delete(v41);
          }
          if (v40 < 0) {
            operator delete(v39);
          }
          if (v38 < 0) {
            operator delete(v37);
          }
          if (v36 < 0) {
            operator delete(v35);
          }
          if (v34 < 0) {
            operator delete((void *)buf.__r_.__value_.__l.__size_);
          }
          if (v10) {
            sub_10004D2C8(v10);
          }
        }
      }
      else
      {
LABEL_11:
        sub_100F16D70(a1, (unsigned __int8 *)&__dst, (uint64_t)v17);
      }
    }
    else
    {
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Local subscription details not found in database", (uint8_t *)&buf, 2u);
      }
      buf.__r_.__value_.__s.__data_[0] = 0;
      v47[0] = 0;
      sub_100F16D70(a1, (unsigned __int8 *)&__dst, (uint64_t)&buf);
      if (v47[0])
      {
        if (v46 < 0) {
          operator delete(__p);
        }
        if (v44 < 0) {
          operator delete(v43);
        }
        if (v42 < 0) {
          operator delete(v41);
        }
        if (v40 < 0) {
          operator delete(v39);
        }
        if (v38 < 0) {
          operator delete(v37);
        }
        if (v36 < 0) {
          operator delete(v35);
        }
        if (v34 < 0) {
          operator delete((void *)buf.__r_.__value_.__l.__size_);
        }
      }
    }
    if ((_BYTE)v29)
    {
      if (SBYTE7(v28) < 0) {
        operator delete((void *)v27);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(*((void **)&v25 + 1));
      }
      if (SBYTE7(v25) < 0) {
        operator delete((void *)v24);
      }
      if (SHIBYTE(v23) < 0) {
        operator delete(v22[1]);
      }
      if (SHIBYTE(v22[0]) < 0) {
        operator delete(v21[0]);
      }
      if (SBYTE7(v20) < 0) {
        operator delete(v19[0]);
      }
      if (SHIBYTE(v18) < 0) {
        operator delete(v17[1]);
      }
    }
    if (SHIBYTE(v31) < 0) {
      operator delete((void *)__dst);
    }
  }
}

void sub_100F0F348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,void *__p,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (v44) {
    sub_10004D2C8(v44);
  }
  if (a37) {
    sub_1000C62D8((uint64_t)&a13);
  }
  if (a44 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F0F414(uint64_t a1, uint64_t *a2)
{
  if (*(char *)(a1 + 775) < 0)
  {
    if (!*(void *)(a1 + 760)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 775))
  {
    return;
  }
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  sub_100F17018((uint64_t)&v19, *(void *)(a1 + 456), *(void *)(a1 + 464), a1 + 752);
  if (!BYTE8(v33)) {
    return;
  }
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 == v5) {
    goto LABEL_36;
  }
  do
  {
    if (*(unsigned char *)(v4 + 8) != 4)
    {
      CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)v4);
      if (v6 != CFDictionaryGetTypeID()) {
        goto LABEL_29;
      }
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v16 = 0;
    CFDictionaryGetValue(*(CFDictionaryRef *)v4, @"IntegratedCircuitCardIdentity");
    long long v17 = 0uLL;
    uint64_t v18 = 0;
    ctu::cf::assign();
    uint64_t v16 = v18;
    *(_OWORD *)long long __p = v17;
    char v7 = HIBYTE(v18);
    if (*(unsigned char *)(a1 + 776)) {
      goto LABEL_25;
    }
    if (v18 >= 0) {
      uint64_t v8 = (void *)HIBYTE(v18);
    }
    else {
      uint64_t v8 = __p[1];
    }
    uint64_t v9 = (void *)BYTE7(v22);
    if (SBYTE7(v22) < 0) {
      uint64_t v9 = (void *)*((void *)&v21 + 1);
    }
    if (v8 != v9) {
      goto LABEL_25;
    }
    if ((SBYTE7(v22) & 0x80u) == 0) {
      unint64_t v10 = (unsigned __int8 *)&v21;
    }
    else {
      unint64_t v10 = (unsigned __int8 *)v21;
    }
    if (v18 < 0)
    {
      uint64_t v14 = __p[0];
      if (memcmp(__p[0], v10, (size_t)__p[1]))
      {
        char v13 = 0;
        goto LABEL_27;
      }
    }
    else if (HIBYTE(v18))
    {
      uint64_t v11 = __p;
      uint64_t v12 = HIBYTE(v18);
      while (*(unsigned __int8 *)v11 == *v10)
      {
        uint64_t v11 = (void **)((char *)v11 + 1);
        ++v10;
        if (!--v12) {
          goto LABEL_33;
        }
      }
LABEL_25:
      char v13 = 0;
      if ((v18 & 0x8000000000000000) == 0) {
        goto LABEL_28;
      }
LABEL_26:
      uint64_t v14 = __p[0];
LABEL_27:
      operator delete(v14);
      goto LABEL_28;
    }
LABEL_33:
    sub_100F163D4(a1, (uint64_t)&v20);
    sub_100F0FC20(a1);
    char v13 = 1;
    if (v7 < 0) {
      goto LABEL_26;
    }
LABEL_28:
    if (v13) {
      break;
    }
LABEL_29:
    v4 += 16;
  }
  while (v4 != v5);
  if (BYTE8(v33)) {
LABEL_36:
  }
    sub_1000C584C((uint64_t)&v20);
}

void sub_100F0F64C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

void sub_100F0F69C(uint64_t a1)
{
  uint64_t v1 = (atomic_uint **)(a1 + 80);
  for (uint64_t i = *(void *)(a1 + 88); (atomic_uint **)i != v1; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));

  sub_100160A84(v1);
}

BOOL sub_100F0F6EC(uint64_t a1, std::string *__str)
{
  uint64_t v4 = (std::string *)(a1 + 720);
  uint64_t v5 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  size_t size = __str->__r_.__value_.__l.__size_;
  if ((v5 & 0x80u) == 0) {
    std::string::size_type v7 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v7 = __str->__r_.__value_.__l.__size_;
  }
  uint64_t v8 = *(unsigned __int8 *)(a1 + 743);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 728);
  }
  if (v7 == v8)
  {
    if (v9 >= 0) {
      unint64_t v10 = (unsigned __int8 *)(a1 + 720);
    }
    else {
      unint64_t v10 = (unsigned __int8 *)v4->__r_.__value_.__r.__words[0];
    }
    if ((v5 & 0x80) != 0)
    {
      int v12 = memcmp(__str->__r_.__value_.__l.__data_, v10, size);
      std::string::size_type v7 = size;
      if (!v12) {
        return 1;
      }
    }
    else
    {
      if (!v5) {
        return 1;
      }
      for (uint64_t i = __str; i->__r_.__value_.__s.__data_[0] == *v10; uint64_t i = (std::string *)((char *)i + 1))
      {
        ++v10;
        if (!--v5) {
          return 1;
        }
      }
    }
  }
  if (v7)
  {
    sGetProfileDetails();
    if (v22)
    {
      sub_1000C584C((uint64_t)buf);
    }
    else
    {
      for (uint64_t j = *(_DWORD **)(a1 + 456); j != *(_DWORD **)(a1 + 464); j += 22)
      {
        if (*j)
        {
          long long v17 = *(NSObject **)(a1 + 40);
          BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
          if (result)
          {
            if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v18 = __str;
            }
            else {
              uint64_t v18 = (std::string *)__str->__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)long long buf = 136315138;
            long long v21 = v18;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Missing system selection (%s)", buf, 0xCu);
            return 0;
          }
          return result;
        }
      }
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Physical SIM override, updating system selection to default use", buf, 2u);
      }
    }
  }
  std::string::operator=(v4, __str);
  char v13 = *(std::__shared_weak_count **)(a1 + 576);
  v19[0] = *(void *)(a1 + 568);
  v19[1] = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F0F92C(v19, @"RemotePlanSelectedOverrideKey", (uint64_t)v4);
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100F0FC20(a1);
  return 1;
}

void sub_100F0F90C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F0F92C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  if (v5)
  {
    *(void *)uint64_t v16 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      uint64_t v8 = *(__CFDictionary **)v16;
      *(void *)uint64_t v16 = Mutable;
      __p[0] = v8;
      sub_10005717C((const void **)__p);
    }
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v13, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)char v13 = *(_OWORD *)a3;
      uint64_t v14 = *(void *)(a3 + 16);
    }
    if (SHIBYTE(v14) < 0)
    {
      sub_10004FC84(__dst, v13[0], (unint64_t)v13[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v13;
      uint64_t v19 = v14;
    }
    long long v17 = 0;
    if (SHIBYTE(v19) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)__dst;
      uint64_t v21 = v19;
    }
    char v22 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v11 = v17;
      long long v17 = v22;
      long long v23 = v11;
      sub_1000558F4(&v23);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v12 = (uint64_t)v17;
    BOOL v15 = v17;
    long long v17 = 0;
    sub_1000558F4(&v17);
    if (SHIBYTE(v19) < 0) {
      operator delete(__dst[0]);
    }
    sub_10010F3F0(*(__CFDictionary **)v16, @"iccid", v12);
    sub_1000558F4(&v15);
    if (SHIBYTE(v14) < 0) {
      operator delete(v13[0]);
    }
    (*(void (**)(void, uint64_t, void, void, const CFStringRef, const CFStringRef))(*(void *)*a1 + 16))(*a1, a2, *(void *)v16, kRemoteCellularPlanStorage, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    return sub_10005717C((const void **)v16);
  }
  else
  {
    int v9 = *(uint64_t (**)(void))(*(void *)*a1 + 16);
    return (const void **)v9();
  }
}

void sub_100F0FBA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100F0FC20(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 456); i != *(void *)(a1 + 464); i += 88)
  {
    if (*(_DWORD *)(i + 12) == 5)
    {
      if ((*(char *)(a1 + 695) & 0x80000000) == 0)
      {
        uint64_t v5 = 0;
LABEL_67:
        *(unsigned char *)(a1 + 672) = 0;
        *(unsigned char *)(a1 + 695) = 0;
        return v5;
      }
      uint64_t v5 = 0;
      goto LABEL_68;
    }
  }
  char v3 = *(unsigned char *)(a1 + 743);
  if (v3 < 0) {
    uint64_t v4 = *(void *)(a1 + 728);
  }
  else {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 743);
  }
  CFTypeID v6 = (const void **)(a1 + 672);
  if (v4)
  {
    std::string::size_type v7 = (const std::string *)(a1 + 720);
    uint64_t v8 = *(unsigned __int8 *)(a1 + 695);
    if ((v8 & 0x80u) == 0) {
      uint64_t v9 = *(unsigned __int8 *)(a1 + 695);
    }
    else {
      uint64_t v9 = *(void *)(a1 + 680);
    }
    if (v3 >= 0) {
      uint64_t v10 = *(unsigned __int8 *)(a1 + 743);
    }
    else {
      uint64_t v10 = *(void *)(a1 + 728);
    }
    if (v9 == v10)
    {
      if (v3 >= 0) {
        uint64_t v11 = (unsigned __int8 *)(a1 + 720);
      }
      else {
        uint64_t v11 = (unsigned __int8 *)v7->__r_.__value_.__r.__words[0];
      }
      if ((v8 & 0x80) == 0)
      {
        if (*(unsigned char *)(a1 + 695))
        {
          uint64_t v12 = (unsigned __int8 *)(a1 + 672);
          while (*v12 == *v11)
          {
            ++v12;
            ++v11;
            if (!--v8) {
              goto LABEL_48;
            }
          }
          goto LABEL_44;
        }
LABEL_48:
        uint64_t v5 = 0;
        goto LABEL_61;
      }
      if (!memcmp(*v6, v11, *(void *)(a1 + 680))) {
        goto LABEL_48;
      }
    }
LABEL_44:
    long long v20 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_55;
    }
    std::string::size_type v21 = a1 + 720;
    if (v3 < 0) {
      std::string::size_type v21 = v7->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v21;
    char v22 = "#I Calculated plan updated - System: (%s)";
    goto LABEL_54;
  }
  std::string::size_type v7 = (const std::string *)(a1 + 696);
  uint64_t v13 = *(unsigned __int8 *)(a1 + 695);
  uint64_t v14 = *(void *)(a1 + 680);
  if ((v13 & 0x80u) == 0) {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 695);
  }
  else {
    uint64_t v15 = *(void *)(a1 + 680);
  }
  uint64_t v16 = *(unsigned __int8 *)(a1 + 719);
  int v17 = (char)v16;
  if ((v16 & 0x80u) != 0) {
    uint64_t v16 = *(void *)(a1 + 704);
  }
  if (v15 != v16) {
    goto LABEL_50;
  }
  if (v17 >= 0) {
    uint64_t v18 = (unsigned __int8 *)(a1 + 696);
  }
  else {
    uint64_t v18 = (unsigned __int8 *)v7->__r_.__value_.__r.__words[0];
  }
  if ((v13 & 0x80) == 0)
  {
    if (!*(unsigned char *)(a1 + 695)) {
      return 0;
    }
    uint64_t v19 = (unsigned __int8 *)(a1 + 672);
    while (*v19 == *v18)
    {
      ++v19;
      ++v18;
      if (!--v13) {
        goto LABEL_48;
      }
    }
    goto LABEL_50;
  }
  if (memcmp(*v6, v18, *(void *)(a1 + 680)))
  {
LABEL_50:
    long long v20 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_55;
    }
    std::string::size_type v23 = a1 + 696;
    if (v17 < 0) {
      std::string::size_type v23 = v7->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v23;
    char v22 = "#I Calculated plan updated - User: (%s)";
LABEL_54:
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v22, buf, 0xCu);
LABEL_55:
    std::string::operator=((std::string *)(a1 + 672), v7);
    long long v24 = *(std::__shared_weak_count **)(a1 + 528);
    if (v24)
    {
      long long v25 = std::__shared_weak_count::lock(v24);
      if (v25)
      {
        long long v26 = v25;
        uint64_t v27 = *(void *)(a1 + 520);
        if (v27) {
          (*(void (**)(uint64_t))(*(void *)v27 + 32))(v27);
        }
        sub_10004D2C8(v26);
      }
    }
    uint64_t v5 = 1;
    goto LABEL_61;
  }
  uint64_t v5 = 0;
  if (!v14) {
    return v5;
  }
LABEL_61:
  uint64_t v28 = *(void *)(a1 + 456);
  if (v28 == *(void *)(a1 + 464))
  {
    long long v31 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 695) < 0) {
        CFTypeID v6 = (const void **)*v6;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Missing vinyl info, abort sending (%s)", buf, 0xCu);
    }
    if ((*(char *)(a1 + 695) & 0x80000000) == 0) {
      goto LABEL_67;
    }
LABEL_68:
    **(unsigned char **)(a1 + 672) = 0;
    *(void *)(a1 + 680) = 0;
    return v5;
  }
  *(_OWORD *)long long buf = 0u;
  long long v56 = 0u;
  sub_1000C5E38((uint64_t)buf, v28 + 56);
  if (!BYTE8(v56))
  {
    long long v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 695) < 0) {
        CFTypeID v6 = (const void **)*v6;
      }
      LODWORD(v53) = 136315138;
      *(void *)((char *)&v53 + 4) = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "No profiles in vinyl info, abort sending, resetting (%s)", (uint8_t *)&v53, 0xCu);
    }
    if (*(char *)(a1 + 695) < 0) {
      goto LABEL_105;
    }
    goto LABEL_71;
  }
  int v29 = *(char *)(a1 + 695);
  if (v29 < 0) {
    uint64_t v30 = *(void *)(a1 + 680);
  }
  else {
    uint64_t v30 = *(unsigned __int8 *)(a1 + 695);
  }
  uint64_t v33 = *(void *)buf;
  uint64_t v34 = *(void *)&buf[8];
  BOOL v35 = *(void *)buf == *(void *)&buf[8];
  if (!v30)
  {
    while (!v35)
    {
      if (*(unsigned char *)(v33 + 89)) {
        goto LABEL_106;
      }
      v33 += 216;
      BOOL v35 = v33 == *(void *)&buf[8];
    }
    goto LABEL_117;
  }
  if (*(void *)buf == *(void *)&buf[8])
  {
LABEL_99:
    if (v33 != v34)
    {
      if (*(unsigned char *)(v33 + 89))
      {
        uint64_t v41 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v53) = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Calculated profile already enabled", (uint8_t *)&v53, 2u);
        }
      }
      else
      {
LABEL_106:
        uint64_t v43 = *(void *)(a1 + 584);
        if (v43)
        {
          *(unsigned char *)(a1 + 744) = 0;
          (*(void (**)(uint64_t, uint64_t))(*(void *)v43 + 40))(v43, 257);
        }
        xpc_object_t v44 = *(std::__shared_weak_count **)(a1 + 528);
        if (v44)
        {
          int64_t v45 = std::__shared_weak_count::lock(v44);
          if (v45)
          {
            long long v46 = v45;
            uint64_t v47 = *(void *)(a1 + 520);
            if (v47)
            {
              uint64_t v48 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v49 = (const void *)(a1 + 672);
                if (*(char *)(a1 + 695) < 0) {
                  uint64_t v49 = *v6;
                }
                LODWORD(v53) = 136315138;
                *(void *)((char *)&v53 + 4) = v49;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Activating: (%s)", (uint8_t *)&v53, 0xCu);
              }
              uint64_t v50 = *(void *)(a1 + 456);
              *(void *)&long long v53 = off_101A6F158;
              *((void *)&v53 + 1) = a1;
              uint64_t v54 = &v53;
              (*(void (**)(uint64_t, uint64_t, uint64_t, long long *))(*(void *)v47 + 80))(v47, v50 + 16, a1 + 672, &v53);
              sub_1000C6B58(&v53);
            }
            sub_10004D2C8(v46);
          }
        }
      }
      goto LABEL_117;
    }
  }
  else
  {
    if (v29 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a1 + 695);
    }
    else {
      uint64_t v36 = *(void *)(a1 + 680);
    }
    do
    {
      uint64_t v37 = *(unsigned __int8 *)(v33 + 39);
      if ((v37 & 0x80u) == 0) {
        uint64_t v38 = *(unsigned __int8 *)(v33 + 39);
      }
      else {
        uint64_t v38 = *(void *)(v33 + 24);
      }
      if (v38 == v36)
      {
        if (v29 >= 0) {
          dispatch_object_t v39 = (unsigned __int8 *)(a1 + 672);
        }
        else {
          dispatch_object_t v39 = (unsigned __int8 *)*v6;
        }
        if ((v37 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v33 + 16), v39, *(void *)(v33 + 24))) {
            goto LABEL_99;
          }
        }
        else
        {
          if (!*(unsigned char *)(v33 + 39)) {
            goto LABEL_99;
          }
          uint64_t v40 = 0;
          while (*(unsigned __int8 *)(v33 + v40 + 16) == v39[v40])
          {
            if (v37 == ++v40) {
              goto LABEL_99;
            }
          }
        }
      }
      v33 += 216;
    }
    while (v33 != v34);
  }
  long long v42 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
  {
    if (v29 < 0) {
      CFTypeID v6 = (const void **)*v6;
    }
    LODWORD(v53) = 136315138;
    *(void *)((char *)&v53 + 4) = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Calculated profile missing, abort sending, resetting (%s)", (uint8_t *)&v53, 0xCu);
    if ((*(unsigned char *)(a1 + 695) & 0x80) != 0) {
      goto LABEL_105;
    }
LABEL_71:
    *(unsigned char *)(a1 + 672) = 0;
    *(unsigned char *)(a1 + 695) = 0;
    goto LABEL_117;
  }
  if ((v29 & 0x80) == 0) {
    goto LABEL_71;
  }
LABEL_105:
  **(unsigned char **)(a1 + 672) = 0;
  *(void *)(a1 + 680) = 0;
LABEL_117:
  if (BYTE8(v56))
  {
    int v52 = buf;
    sub_1000C57C8((void ***)&v52);
  }
  return v5;
}

void sub_100F102AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  sub_1000C6B58(&a11);
  sub_10004D2C8(v18);
  if (a18)
  {
    a10 = (void **)&a15;
    sub_1000C57C8(&a10);
  }
  _Unwind_Resume(a1);
}

void sub_100F10300(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  unint64_t v35 = 0;
  uint64_t v3 = *(void *)(a1 + 456);
  uint64_t v30 = *(void *)(a1 + 464);
  if (v3 != v30)
  {
    long long v31 = (unsigned __int8 **)(a1 + 720);
    uint64_t v32 = a1 + 624;
    uint64_t v28 = a1 + 600;
    uint64_t v29 = a1 + 648;
    uint64_t v27 = (void **)(a1 + 608);
    while (*(_DWORD *)(v3 + 12) != 3 || !*(unsigned char *)(v3 + 80))
    {
LABEL_58:
      v3 += 88;
      if (v3 == v30) {
        goto LABEL_59;
      }
    }
    uint64_t v4 = *(void *)(v3 + 56);
    uint64_t v5 = *(void *)(v3 + 64);
    while (1)
    {
      if (v4 == v5) {
        goto LABEL_58;
      }
      memset(&v64, 0, sizeof(v64));
      memset(v63, 0, sizeof(v63));
      long long v61 = 0u;
      memset(v62, 0, sizeof(v62));
      long long v60 = 0u;
      *(_OWORD *)__s1 = 0u;
      memset(v59, 0, sizeof(v59));
      long long v57 = 0u;
      sub_1000C5AB4((uint64_t)&v57, v4);
      if (BYTE8(v61)) {
        goto LABEL_8;
      }
      uint64_t v6 = BYTE7(v59[0]);
      if ((SBYTE7(v59[0]) & 0x80u) == 0) {
        std::string::size_type v7 = (void *)BYTE7(v59[0]);
      }
      else {
        std::string::size_type v7 = __s1[1];
      }
      uint64_t v8 = (void *)*(unsigned __int8 *)(a1 + 743);
      int v9 = (char)v8;
      if ((char)v8 < 0) {
        uint64_t v8 = *(void **)(a1 + 728);
      }
      if (v7 == v8)
      {
        if (v9 >= 0) {
          uint64_t v10 = (unsigned __int8 *)v31;
        }
        else {
          uint64_t v10 = *v31;
        }
        if ((BYTE7(v59[0]) & 0x80) != 0)
        {
          if (!memcmp(__s1[0], v10, (size_t)__s1[1])) {
            goto LABEL_26;
          }
        }
        else
        {
          if (!BYTE7(v59[0])) {
            goto LABEL_26;
          }
          uint64_t v11 = __s1;
          while (*(unsigned __int8 *)v11 == *v10)
          {
            uint64_t v11 = (void **)((char *)v11 + 1);
            ++v10;
            if (!--v6) {
              goto LABEL_26;
            }
          }
        }
      }
      if (!sub_10010E128(v32, __s1)) {
        goto LABEL_8;
      }
LABEL_26:
      uint64_t v12 = v34;
      if ((unint64_t)v34 >= v35)
      {
        uint64_t v13 = (std::string *)sub_1003DC28C(&v33);
      }
      else
      {
        bzero(v34, 0x338uLL);
        sub_1003DC3A8((uint64_t)v12);
        uint64_t v13 = (std::string *)((char *)v12 + 824);
      }
      uint64_t v34 = v13;
      v13[-11].__r_.__value_.__s.__data_[3] = 1;
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      char v44 = 0;
      uint64_t v43 = 0;
      long long v45 = 0u;
      long long v46 = 0u;
      uint64_t v47 = 0;
      memset(buf, 0, sizeof(buf));
      long long v38 = 0u;
      long long v39 = 0u;
      memset(v40, 0, 28);
      memset(&v40[32], 0, 124);
      char v48 = 2;
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      int v52 = 0;
      uint64_t v49 = 0;
      uint64_t v14 = v13 - 29;
      long long __p = 0u;
      long long v54 = 0u;
      memset(v55, 0, sizeof(v55));
      char v56 = 0;
      sub_1003DD760(&v13[-29], (uint64_t)buf);
      uint64_t v36 = (void **)&v55[1] + 1;
      sub_10030FEEC(&v36);
      uint64_t v36 = (void **)v55;
      sub_100047F64(&v36);
      if (SBYTE7(v54) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v51) < 0) {
        operator delete(v49);
      }
      if (SHIBYTE(v47) < 0) {
        operator delete((void *)v46);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete(v41);
      }
      sub_1000C584C((uint64_t)buf);
      if (!v14->__r_.__value_.__s.__data_[0]) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      *(_OWORD *)&v13[-29].__r_.__value_.__r.__words[1] = v57;
      std::string::operator=(v13 - 28, (const std::string *)__s1);
      std::string::operator=(v13 - 27, (const std::string *)((char *)v59 + 8));
      std::string::operator=(v13 - 26, (const std::string *)&v60);
      LODWORD(v13[-25].__r_.__value_.__l.__data_) = DWORD2(v61);
      std::string::operator=((std::string *)((char *)v13 - 592), v62);
      std::string::operator=((std::string *)((char *)v13 - 568), &v62[1]);
      std::string::operator=((std::string *)((char *)v13 - 544), v63);
      std::string::operator=((std::string *)((char *)v13 - 520), &v63[1]);
      std::string::operator=((std::string *)((char *)v13 - 496), &v64);
      LODWORD(v13[-7].__r_.__value_.__l.__data_) = 2;
      v13[-11].__r_.__value_.__s.__data_[4] = 0;
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 504) + 160))(buf);
      if (!v14->__r_.__value_.__s.__data_[0]) {
        __assert_rtn("operator->", "optional.hpp", 1222, "this->is_initialized()");
      }
      uint64_t v15 = (void **)&v13[-18].__r_.__value_.__r.__words[2];
      if (v13[-17].__r_.__value_.__s.__data_[15] < 0) {
        operator delete(*v15);
      }
      long long v16 = *(_OWORD *)buf;
      v13[-17].__r_.__value_.__l.__size_ = *(void *)&buf[16];
      *(_OWORD *)uint64_t v15 = v16;
      v13[-11].__r_.__value_.__s.__data_[2] = sub_100F109FC(a1, (unsigned __int8 *)__s1);
      int v17 = *(unsigned __int8 *)(a1 + 272);
      if (v17 == 1)
      {
        if (sub_10010E194(*(void ***)(a1 + 656), __s1))
        {
          std::string::size_type v21 = (const std::string *)sub_100ECD30C(v29, __s1);
          std::string::operator=(v13 - 9, v21);
          char v22 = (const std::string *)sub_100ECD30C(v29, __s1);
          std::string::operator=(v13 - 8, v22 + 1);
          goto LABEL_8;
        }
        if (*(char *)(a1 + 743) < 0)
        {
          if (*(void *)(a1 + 728)) {
            goto LABEL_8;
          }
        }
        else if (*(unsigned char *)(a1 + 743))
        {
          goto LABEL_8;
        }
        std::string::size_type v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          if ((SBYTE7(v59[0]) & 0x80u) == 0) {
            long long v24 = __s1;
          }
          else {
            long long v24 = (void **)__s1[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v24;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Missing companion info, how is this selectable [%s]", buf, 0xCu);
        }
      }
      else if (v17 == 2)
      {
        uint64_t v18 = sub_100046F68(v28, __s1);
        if (v27 != v18)
        {
          sub_100CD6B88((const void **)v18 + 18, (uint64_t)v62, (uint64_t)buf);
          p_size_t size = (void **)&v13[-7].__r_.__value_.__l.__size_;
          if (v13[-6].__r_.__value_.__s.__data_[7] < 0) {
            operator delete(*p_size);
          }
          long long v20 = *(_OWORD *)buf;
          v13[-6].__r_.__value_.__r.__words[0] = *(void *)&buf[16];
          *(_OWORD *)p_size_t size = v20;
        }
      }
LABEL_8:
      sub_1000C584C((uint64_t)&v57);
      v4 += 216;
    }
  }
LABEL_59:
  *a2 = 0;
  sub_100CCE0B0(&v33, a2);
  long long v25 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s%sPlan list:", buf, 0x16u);
  }
  *(void *)long long buf = off_101A6EE00;
  *(void *)&uint8_t buf[8] = a1;
  *(void *)&unsigned char buf[24] = buf;
  logger::CFTypeRefLogger();
  sub_10012C330(buf);
  *(void *)long long buf = &v33;
  sub_1003DCCE8((void ***)buf);
}

void sub_100F10970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p)
{
  sub_10012C330(&__p);
  sub_100044D00(v33);
  long long __p = &a29;
  sub_1003DCCE8((void ***)&__p);
  _Unwind_Resume(a1);
}

BOOL sub_100F109FC(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = a2[23];
  size_t v5 = *((void *)a2 + 1);
  if ((v4 & 0x80u) == 0) {
    uint64_t v6 = a2[23];
  }
  else {
    uint64_t v6 = *((void *)a2 + 1);
  }
  int v7 = *(char *)(a1 + 695);
  if (v7 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 695);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 680);
  }
  if (v6 == v8)
  {
    if (v7 >= 0) {
      int v9 = (unsigned __int8 *)(a1 + 672);
    }
    else {
      int v9 = *(unsigned __int8 **)(a1 + 672);
    }
    if ((v4 & 0x80) != 0)
    {
      if (!memcmp(*(const void **)a2, v9, v5)) {
        return 1;
      }
    }
    else
    {
      if (!v4) {
        return 1;
      }
      uint64_t v10 = a2;
      uint64_t v11 = v4;
      while (*v10 == *v9)
      {
        ++v10;
        ++v9;
        if (!--v11) {
          return 1;
        }
      }
    }
  }
  if (v8) {
    return 0;
  }
  uint64_t v12 = *(unsigned __int8 *)(a1 + 775);
  uint64_t v13 = (v12 & 0x80u) == 0 ? *(unsigned __int8 *)(a1 + 775) : *(void *)(a1 + 760);
  if (v13 != v6) {
    return 0;
  }
  uint64_t v14 = (const void **)(a1 + 752);
  if ((v4 & 0x80u) == 0) {
    uint64_t v15 = a2;
  }
  else {
    uint64_t v15 = *(unsigned __int8 **)a2;
  }
  if ((v12 & 0x80) != 0) {
    return !memcmp(*v14, v15, *(void *)(a1 + 760));
  }
  if (*(unsigned char *)(a1 + 775))
  {
    BOOL result = 1;
    while (*(unsigned __int8 *)v14 == *v15)
    {
      uint64_t v14 = (const void **)((char *)v14 + 1);
      ++v15;
      if (!--v12) {
        return result;
      }
    }
    return 0;
  }
  return 1;
}

char *sub_100F10B2C@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[695] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 84), *((void *)result + 85));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 42);
  *(void *)(a2 + 16) = *((void *)result + 86);
  return result;
}

void sub_100F10B5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(&__str, 0, sizeof(__str));
  int v7 = (const void **)(a3 + 16);
  if (*(char *)(a3 + 39) < 0)
  {
    sub_10004FC84(&__str, *(void **)(a3 + 16), *(void *)(a3 + 24));
  }
  else
  {
    *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *(_OWORD *)v7;
    __str.__r_.__value_.__r.__words[2] = *(void *)(a3 + 32);
  }
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size && !sub_10010E128(a1 + 624, (void **)&__str.__r_.__value_.__l.__data_))
  {
    uint64_t v15 = (void *)(a1 + 696);
    uint64_t v16 = sub_10010E128(a1 + 624, (void **)(a1 + 696));
    int v17 = *(NSObject **)(a1 + 40);
    if (v16 == 1)
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a3 + 39) >= 0) {
          long long v39 = v7;
        }
        else {
          long long v39 = *(const void ***)(a3 + 16);
        }
        if (*(char *)(a1 + 719) < 0) {
          uint64_t v15 = (void *)*v15;
        }
        *(_DWORD *)long long buf = 136315394;
        uint64_t v47 = v39;
        __int16 v48 = 2080;
        uint64_t v49 = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Selection not deemed selectable (%s), profile cannot be activated, keeping (%s)", buf, 0x16u);
      }
      sub_100F110AC(a1, (std::string *)(a1 + 672));
      __int16 v44 = 258;
      uint64_t v18 = *(void *)(a4 + 24);
      if (!v18) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, __int16 *))(*(void *)v18 + 48))(v18, &v44);
      LOBYTE(v44) = 0;
      goto LABEL_69;
    }
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Current plan no longer selectable, clearing", buf, 2u);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      *__str.__r_.__value_.__l.__data_ = 0;
      __str.__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      __str.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = 0;
    }
  }
  int v9 = (const void **)(a1 + 696);
  uint64_t v10 = *(unsigned __int8 *)(a1 + 719);
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = *(unsigned __int8 *)(a1 + 719);
  }
  else {
    uint64_t v11 = *(void *)(a1 + 704);
  }
  std::string::size_type v12 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v12 = __str.__r_.__value_.__l.__size_;
  }
  if (v11 == v12)
  {
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if ((v10 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 719))
      {
        uint64_t v14 = (unsigned __int8 *)(a1 + 696);
        while (*v14 == p_str->__r_.__value_.__s.__data_[0])
        {
          ++v14;
          p_str = (std::string *)((char *)p_str + 1);
          if (!--v10) {
            goto LABEL_37;
          }
        }
        goto LABEL_28;
      }
LABEL_37:
      __int16 v43 = 257;
      uint64_t v23 = *(void *)(a4 + 24);
      if (!v23) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, __int16 *))(*(void *)v23 + 48))(v23, &v43);
      LOBYTE(v43) = 0;
      sub_100F110AC(a1, (std::string *)(a1 + 672));
      goto LABEL_69;
    }
    if (!memcmp(*v9, p_str, *(void *)(a1 + 704))) {
      goto LABEL_37;
    }
  }
LABEL_28:
  std::string::operator=((std::string *)(a1 + 696), &__str);
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 576);
  v42[0] = *(void *)(a1 + 568);
  v42[1] = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F0F92C(v42, @"RemotePlanSelectedKey", a1 + 696);
  if (v19) {
    sub_10004D2C8(v19);
  }
  *(unsigned char *)(a1 + 744) = 0;
  char v20 = *(unsigned char *)(a1 + 743);
  if (v20 < 0)
  {
    if (*(void *)(a1 + 728)) {
      goto LABEL_34;
    }
  }
  else if (*(unsigned char *)(a1 + 743))
  {
LABEL_34:
    std::string::size_type v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a1 + 719) < 0) {
        int v9 = (const void **)*v9;
      }
      long long v38 = (void *)(a1 + 720);
      if (v20 < 0) {
        long long v38 = (void *)*v38;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v47 = v9;
      __int16 v48 = 2080;
      uint64_t v49 = v38;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "WARNING: Attempting to activate (%s) when system selection is set to: (%s)", buf, 0x16u);
    }
    __int16 v41 = 257;
    uint64_t v22 = *(void *)(a4 + 24);
    if (!v22) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, __int16 *))(*(void *)v22 + 48))(v22, &v41);
    LOBYTE(v41) = 0;
    goto LABEL_69;
  }
  sub_100F0FC20(a1);
  uint64_t v24 = *(unsigned __int8 *)(a3 + 39);
  if ((v24 & 0x80u) == 0) {
    uint64_t v25 = *(unsigned __int8 *)(a3 + 39);
  }
  else {
    uint64_t v25 = *(void *)(a3 + 24);
  }
  uint64_t v26 = *(unsigned __int8 *)(a1 + 719);
  int v27 = (char)v26;
  if ((v26 & 0x80u) != 0) {
    uint64_t v26 = *(void *)(a1 + 704);
  }
  if (v25 == v26)
  {
    if (v27 >= 0) {
      uint64_t v28 = (unsigned __int8 *)(a1 + 696);
    }
    else {
      uint64_t v28 = (unsigned __int8 *)*v9;
    }
    if ((v24 & 0x80) != 0)
    {
      BOOL v36 = memcmp(*v7, v28, *(void *)(a3 + 24)) == 0;
    }
    else if (*(unsigned char *)(a3 + 39))
    {
      uint64_t v29 = v24 - 1;
      do
      {
        int v31 = *(unsigned __int8 *)v7;
        int v7 = (const void **)((char *)v7 + 1);
        int v30 = v31;
        int v33 = *v28++;
        int v32 = v33;
        BOOL v35 = v29-- != 0;
        BOOL v36 = v30 == v32;
      }
      while (v36 && v35);
    }
    else
    {
      BOOL v36 = 1;
    }
  }
  else
  {
    BOOL v36 = 0;
  }
  v40[0] = 1;
  v40[1] = v36;
  uint64_t v37 = *(void *)(a4 + 24);
  if (!v37) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v37 + 48))(v37, v40);
  v40[0] = 0;
LABEL_69:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_100F11044(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, char a11, char a12, uint64_t a13, uint64_t a14, int a15, char a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F110AC(uint64_t a1, std::string *a2)
{
  uint64_t v37 = 0;
  *(_OWORD *)BOOL v35 = 0u;
  long long v36 = 0u;
  *(_OWORD *)int v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)int v31 = 0u;
  long long v32 = 0u;
  sub_10032AFC0(v33, a2);
  DWORD2(v32) = 1;
  uint64_t v4 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  if ((v4 & 0x80u) == 0) {
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (!size) {
    goto LABEL_46;
  }
  uint64_t v6 = *(unsigned __int8 *)(a1 + 743);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a1 + 728);
  }
  if (size != v6) {
    goto LABEL_18;
  }
  if (v7 >= 0) {
    uint64_t v8 = (unsigned __int8 *)(a1 + 720);
  }
  else {
    uint64_t v8 = *(unsigned __int8 **)(a1 + 720);
  }
  if ((v4 & 0x80) == 0)
  {
    if (*((unsigned char *)&a2->__r_.__value_.__s + 23))
    {
      int v9 = a2;
      while (v9->__r_.__value_.__s.__data_[0] == *v8)
      {
        int v9 = (std::string *)((char *)v9 + 1);
        ++v8;
        if (!--v4) {
          goto LABEL_22;
        }
      }
      goto LABEL_18;
    }
LABEL_22:
    int v11 = 3;
    goto LABEL_23;
  }
  if (!memcmp(a2->__r_.__value_.__l.__data_, v8, a2->__r_.__value_.__l.__size_)) {
    goto LABEL_22;
  }
LABEL_18:
  uint64_t v10 = sub_100046F68(a1 + 600, (void **)&a2->__r_.__value_.__l.__data_);
  if ((void **)(a1 + 608) == v10) {
    goto LABEL_24;
  }
  if (*((unsigned char *)v10 + 112) == 4) {
    int v11 = 4;
  }
  else {
    int v11 = 3;
  }
LABEL_23:
  DWORD2(v32) = v11;
LABEL_24:
  if (sub_10010E194(*(void ***)(a1 + 656), (void **)(a1 + 672)))
  {
    *(void *)&long long __dst = a1 + 672;
    std::string::size_type v12 = sub_100F19664(a1 + 648, (void **)(a1 + 672), (long long **)&__dst);
    if (v12[79] < 0)
    {
      if (!*((void *)v12 + 8)) {
        goto LABEL_46;
      }
    }
    else if (!v12[79])
    {
      goto LABEL_46;
    }
    *(void *)&long long __dst = a1 + 672;
    uint64_t v13 = sub_100F19664(a1 + 648, (void **)(a1 + 672), (long long **)&__dst);
    if (v13[79] < 0)
    {
      sub_10004FC84(v23, *((void **)v13 + 7), *((void *)v13 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v23 = *(_OWORD *)(v13 + 56);
      uint64_t v24 = *((void *)v13 + 9);
    }
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(__p, v23[0], (unint64_t)v23[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v23;
      uint64_t v28 = v24;
    }
    uint64_t v26 = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      uint64_t v39 = v28;
    }
    uint64_t v29 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v14 = v26;
      uint64_t v26 = v29;
      int v30 = v14;
      sub_1000558F4(&v30);
    }
    if (SHIBYTE(v39) < 0) {
      operator delete((void *)__dst);
    }
    uint64_t v15 = (subscriber *)v26;
    uint64_t v25 = v26;
    uint64_t v26 = 0;
    sub_1000558F4((const void **)&v26);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    LODWORD(v37) = subscriber::getSlotIdFromUuidStr(v15, v16);
    sub_1000558F4(&v25);
    if (SHIBYTE(v24) < 0) {
      operator delete(v23[0]);
    }
  }
LABEL_46:
  LOBYTE(__dst) = 0;
  sub_1003C8068((uint64_t)&__dst, (long long *)v31);
  char v17 = (*(unsigned char *)(a1 + 136) == 0) == ((_BYTE)__dst == 0);
  if (*(unsigned char *)(a1 + 136) && (_BYTE)__dst) {
    char v17 = cellplan::operator==();
  }
  sub_1003C8134(&__dst);
  if ((v17 & 1) == 0)
  {
    sub_1003DF15C(a1 + 136, (uint64_t)v31);
    uint64_t v18 = *(void *)(a1 + 128);
    if (v18) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v18 + 48))(v18, a1 + 136);
    }
    uint64_t v19 = *(std::__shared_weak_count **)(a1 + 528);
    if (v19)
    {
      char v20 = std::__shared_weak_count::lock(v19);
      if (v20)
      {
        std::string::size_type v21 = v20;
        uint64_t v22 = *(void *)(a1 + 520);
        if (v22) {
          (*(void (**)(uint64_t, void))(*(void *)v22 + 40))(v22, DWORD2(v32));
        }
        sub_10004D2C8(v21);
      }
    }
  }
  if (LOBYTE(v35[0]))
  {
    if (SHIBYTE(v36) < 0) {
      operator delete(v35[1]);
    }
    LOBYTE(v35[0]) = 0;
  }
  if (LOBYTE(v33[0]))
  {
    if (SHIBYTE(v34) < 0) {
      operator delete(v33[1]);
    }
    LOBYTE(v33[0]) = 0;
  }
  if (SBYTE7(v32) < 0) {
    operator delete(v31[0]);
  }
}

void sub_100F11484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1003C81D8((uint64_t)&a28);
  _Unwind_Resume(a1);
}

const void **sub_100F11520(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v6 = a6;
  if (*(unsigned char *)(a1 + 272) == 2)
  {
    return (const void **)sub_1000607A8(a6, 1);
  }
  uint64_t v11 = a1 + 656;
  sub_10023A548(*(void **)(a1 + 656));
  *(void *)(a1 + 648) = v11;
  *(void *)(a1 + 664) = 0;
  *(void *)(a1 + 656) = 0;
  sub_10005CD2C(a1 + 624, *(char **)(a1 + 632));
  *(void *)(a1 + 624) = a1 + 632;
  *(void *)(a1 + 640) = 0;
  *(void *)(a1 + 632) = 0;
  uint64_t v13 = *a5;
  uint64_t v12 = a5[1];
  if (*a5 != v12)
  {
    uint64_t v36 = v6;
    uint64_t v14 = a1 + 648;
    uint64_t v15 = a1 + 600;
    uint64_t v37 = (const void **)(a3 + 16);
    while (1)
    {
      CFStringRef v16 = sub_100046F68(v15, (void **)v13);
      if ((void **)(a1 + 608) != v16) {
        goto LABEL_25;
      }
      uint64_t v17 = *(unsigned __int8 *)(a3 + 39);
      if ((v17 & 0x80u) == 0) {
        uint64_t v18 = *(unsigned __int8 *)(a3 + 39);
      }
      else {
        uint64_t v18 = *(void *)(a3 + 24);
      }
      uint64_t v19 = *(unsigned __int8 *)(v13 + 23);
      int v20 = (char)v19;
      if ((v19 & 0x80u) != 0) {
        uint64_t v19 = *(void *)(v13 + 8);
      }
      if (v18 != v19) {
        goto LABEL_25;
      }
      if (v20 >= 0) {
        std::string::size_type v21 = (unsigned __int8 *)v13;
      }
      else {
        std::string::size_type v21 = *(unsigned __int8 **)v13;
      }
      if ((v17 & 0x80) != 0)
      {
        uint64_t v24 = (void *)*v37;
        if (memcmp(*v37, v21, *(void *)(a3 + 24))) {
          goto LABEL_25;
        }
        uint64_t v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_66;
        }
      }
      else
      {
        if (*(unsigned char *)(a3 + 39))
        {
          uint64_t v22 = v37;
          while (*(unsigned __int8 *)v22 == *v21)
          {
            uint64_t v22 = (const void **)((char *)v22 + 1);
            ++v21;
            if (!--v17)
            {
              uint64_t v23 = *(NSObject **)(a1 + 40);
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
                goto LABEL_61;
              }
              goto LABEL_64;
            }
          }
LABEL_25:
          if (*(_DWORD *)(v13 + 24) == 3 && *((unsigned char *)v16 + 112) != 2)
          {
            uint64_t v25 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v26 = v13;
              if (*(char *)(v13 + 23) < 0) {
                uint64_t v26 = *(void *)v13;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v26;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Update plan status from selectable plan: (%s)", buf, 0xCu);
            }
            uint64_t v27 = v12;
            *(_OWORD *)BOOL v70 = 0u;
            long long v71 = 0u;
            *(_OWORD *)long long v68 = 0u;
            long long v69 = 0u;
            long long v66 = 0u;
            *(_OWORD *)uint64_t v67 = 0u;
            *(_OWORD *)std::string v64 = 0u;
            *(_OWORD *)long long v65 = 0u;
            *(_OWORD *)uint64_t v62 = 0u;
            long long v63 = 0u;
            *(_OWORD *)long long buf = 0u;
            long long v61 = 0u;
            sub_10023FB90((uint64_t)buf, (uint64_t)(v16 + 7));
            uint64_t v28 = a3;
            *((_WORD *)v16 + 56) = 258;
            uint64_t v29 = *(void *)(a1 + 536);
            sub_10023FB90((uint64_t)v46, (uint64_t)(v16 + 7));
            uint64_t v39 = 0;
            uint64_t v40 = 0;
            __int16 v41 = 0;
            v42[0] = (void **)&v39;
            v42[1] = 0;
            uint64_t v39 = (char *)operator new(0xC0uLL);
            uint64_t v40 = (uint64_t)v39;
            __int16 v41 = v39 + 192;
            uint64_t v40 = sub_10037AC44((uint64_t)&v41, (uint64_t)v46, (uint64_t)buf, (uint64_t)v39);
            v30.n128_u64[0] = (unint64_t)v16[7];
            (*(void (**)(uint64_t, char **, BOOL, __n128))(*(void *)v29 + 112))(v29, &v39, v30.n128_f64[0] == 0.0, v30);
            v42[0] = (void **)&v39;
            sub_10023FDC8(v42);
            a3 = v28;
            if (v59 < 0) {
              operator delete(__p);
            }
            uint64_t v12 = v27;
            if (v57 < 0) {
              operator delete(v56);
            }
            uint64_t v15 = a1 + 600;
            uint64_t v14 = a1 + 648;
            if (v55 < 0) {
              operator delete(v54);
            }
            if (v53 < 0) {
              operator delete(v52);
            }
            if (v51 < 0) {
              operator delete(v50);
            }
            if (v49 < 0) {
              operator delete(v48);
            }
            if (v47 < 0) {
              operator delete((void *)v46[1]);
            }
            if (SBYTE7(v71) < 0) {
              operator delete(v70[0]);
            }
            if (SHIBYTE(v69) < 0) {
              operator delete(v68[1]);
            }
            if (SHIBYTE(v68[0]) < 0) {
              operator delete(v67[0]);
            }
            if (SHIBYTE(v66) < 0) {
              operator delete(v65[1]);
            }
            if (SHIBYTE(v65[0]) < 0) {
              operator delete(v64[0]);
            }
            if (SBYTE7(v63) < 0) {
              operator delete(v62[0]);
            }
            if (SHIBYTE(v61) < 0) {
              operator delete(*(void **)&buf[8]);
            }
          }
          *(void *)long long buf = v13;
          int v31 = sub_100F19664(v14, (void **)v13, (long long **)buf);
          std::string::operator=((std::string *)(v31 + 56), (const std::string *)(v13 + 32));
          *(void *)long long buf = v13;
          long long v32 = sub_100F19664(v14, (void **)v13, (long long **)buf);
          std::string::operator=((std::string *)(v32 + 80), (const std::string *)(v13 + 56));
          if (sub_100F11C04(a1, (uint64_t)(v16 + 7))) {
            sub_100046BAC((uint64_t **)(a1 + 624), (void **)v13, v13);
          }
          goto LABEL_61;
        }
        uint64_t v23 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
LABEL_64:
          uint64_t v24 = v37;
LABEL_66:
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v24;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No details for selected profile (%s)", buf, 0xCu);
        }
      }
LABEL_61:
      v13 += 88;
      if (v13 == v12)
      {
        uint64_t v33 = *a5;
        uint64_t v13 = a5[1];
        uint64_t v6 = v36;
        goto LABEL_68;
      }
    }
  }
  uint64_t v33 = *a5;
LABEL_68:
  v46[0] = 0;
  memset(v38, 0, sizeof(v38));
  sub_10037C544(v38, v33, v13, 0x2E8BA2E8BA2E8BA3 * ((v13 - v33) >> 3));
  sub_1003F0230(v38, v46);
  *(void *)long long buf = v38;
  sub_10037AB58((void ***)buf);
  (*(void (**)(void, const __CFString *, const void *, void, const CFStringRef, const CFStringRef))(**(void **)(a1 + 568) + 16))(*(void *)(a1 + 568), @"SelectablePlansKey", v46[0], kRemoteCellularPlanStorage, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1000DFC90((uint64_t)v43, v6);
  long long v45 = 0;
  long long v34 = operator new(0x28uLL);
  *long long v34 = off_101A6EE80;
  sub_100023950((uint64_t)(v34 + 1), (uint64_t)v43);
  long long v45 = v34;
  sub_100F10B5C(a1, v35, a3, (uint64_t)v44);
  sub_1000C752C(v44);
  sub_100060644(v43);
  return sub_100044D00(v46);
}

void sub_100F11B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,const void *a35)
{
}

uint64_t sub_100F11C04(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 272)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 272) == 2)
  {
    if (*(unsigned char *)(a2 + 57) != 1)
    {
      BOOL v2 = *(unsigned char *)(a2 + 56) == 5;
      return !v2;
    }
    return 0;
  }
  if (*(unsigned char *)(a2 + 57) != 1 || *(unsigned char *)(a2 + 56) != 2 || *(unsigned char *)(a2 + 185) == 0) {
    return 0;
  }
  BOOL v2 = sub_10010E194(*(void ***)(a1 + 656), (void **)(a2 + 32)) == 0;
  return !v2;
}

void sub_100F11C80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 456);
  if (v5 != *(void *)(a1 + 464))
  {
    if (!*(unsigned char *)(a2 + 16))
    {
      *(_OWORD *)a2 = *(_OWORD *)(v5 + 16);
      *(unsigned char *)(a2 + 16) = 1;
    }
    int v9 = (_OWORD *)(a3 + 16);
    uint64_t v10 = *(unsigned __int8 *)(a1 + 719);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 719);
    }
    else {
      uint64_t v11 = *(void *)(a1 + 704);
    }
    uint64_t v12 = *(unsigned __int8 *)(a3 + 39);
    int v13 = (char)v12;
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = *(void *)(a3 + 24);
    }
    if (v11 == v12)
    {
      uint64_t v14 = (const void **)(a1 + 696);
      if (v13 >= 0) {
        uint64_t v15 = (unsigned __int8 *)(a3 + 16);
      }
      else {
        uint64_t v15 = *(unsigned __int8 **)v9;
      }
      if ((v10 & 0x80) != 0)
      {
        if (!memcmp(*v14, v15, *(void *)(a1 + 704))) {
          goto LABEL_25;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 719)) {
          goto LABEL_25;
        }
        while (*(unsigned __int8 *)v14 == *v15)
        {
          uint64_t v14 = (const void **)((char *)v14 + 1);
          ++v15;
          if (!--v10) {
            goto LABEL_25;
          }
        }
      }
    }
    sub_1002EF958((uint64_t)buf);
    int v17 = sub_1003D5918(a3, (uint64_t)buf);
    int v18 = v17;
    if (v41 < 0)
    {
      operator delete(v40);
      if (!v18)
      {
LABEL_27:
        int v20 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a3 + 39) >= 0) {
            uint64_t v21 = a3 + 16;
          }
          else {
            uint64_t v21 = *(void *)(a3 + 16);
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v39 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Deleting: (%s)", buf, 0xCu);
        }
        uint64_t v22 = *(std::__shared_weak_count **)(a1 + 528);
        if (v22)
        {
          uint64_t v23 = std::__shared_weak_count::lock(v22);
          if (v23)
          {
            uint64_t v24 = v23;
            uint64_t v25 = *(void *)(a1 + 520);
            if (v25)
            {
              uint64_t v30 = a1;
              long long v31 = *(_OWORD *)a3;
              if (*(char *)(a3 + 39) < 0)
              {
                sub_10004FC84(&__p, *(void **)(a3 + 16), *(void *)(a3 + 24));
              }
              else
              {
                long long __p = *v9;
                uint64_t v33 = *(void *)(a3 + 32);
              }
              char v34 = *(unsigned char *)(a3 + 40);
              sub_1000C7494((uint64_t)v35, a4);
              uint64_t v37 = 0;
              uint64_t v26 = (char *)operator new(0x60uLL);
              uint64_t v27 = v30;
              *(void *)uint64_t v26 = off_101A6EF00;
              *((void *)v26 + 1) = v27;
              *((_OWORD *)v26 + 1) = v31;
              uint64_t v28 = v26 + 32;
              if (SHIBYTE(v33) < 0)
              {
                sub_10004FC84(v28, (void *)__p, *((unint64_t *)&__p + 1));
              }
              else
              {
                *(_OWORD *)uint64_t v28 = __p;
                *((void *)v26 + 6) = v33;
              }
              v26[56] = v34;
              sub_10037D228((uint64_t)(v26 + 64), (uint64_t)v35);
              uint64_t v37 = v26;
              (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v25 + 88))(v25, a2, a3, v36);
              sub_1000C752C(v36);
              sub_1000C752C(v35);
              if (SHIBYTE(v33) < 0) {
                operator delete((void *)__p);
              }
            }
            sub_10004D2C8(v24);
          }
        }
        return;
      }
    }
    else if (!v17)
    {
      goto LABEL_27;
    }
LABEL_25:
    uint64_t v19 = *(void *)(a1 + 584);
    if (v19)
    {
      *(unsigned char *)(a1 + 744) = 0;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 40))(v19, 256);
    }
    goto LABEL_27;
  }
  __int16 v29 = 3074;
  uint64_t v16 = *(void *)(a4 + 24);
  if (!v16) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, __int16 *))(*(void *)v16 + 48))(v16, &v29);
}

void sub_100F11FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  operator delete(v35);
  sub_100F1206C((uint64_t)&a10);
  sub_10004D2C8(v36);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1206C(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100F120A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (***v8)(Registry **__return_ptr);
  std::__shared_weak_count *v9;
  double v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint8_t *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unsigned char *v23;
  void *v24;
  void v25[3];
  char v26;
  void *v27;
  char v28;
  void *v29;
  char v30;
  void *v31;
  char v32;
  void *v33;
  char v34;
  void *v35;
  char v36;
  void *v37;
  char v38;
  char v39;
  char v40[8];
  void *v41;
  char v42;
  void *v43;
  char v44;
  void *v45;
  char v46;
  void *v47;
  char v48;
  void *v49;
  char v50;
  void *v51;
  char v52;
  void *__p;
  char v54;
  char v55;
  char v56[8];
  void *v57;
  char v58;
  void *v59;
  char v60;
  void *v61;
  char v62;
  void *v63;
  char v64;
  void *v65;
  char v66;
  void *v67;
  char v68;
  void *v69;
  char v70;
  char v71;
  char v72[8];
  void *v73;
  char v74;
  void *v75;
  char v76;
  void *v77;
  char v78;
  void *v79;
  char v80;
  void *v81;
  char v82;
  void *v83;
  char v84;
  void *v85;
  char v86;
  char v87;
  uint64_t v88;
  long long v89;
  uint64_t v90;
  void v91[3];
  void *v92;
  void v93[3];
  void *v94;
  uint8_t buf[24];
  uint8_t *v96;
  void v97[3];

  uint64_t v6 = sub_100046F68(a1 + 600, (void **)a2);
  if ((void **)(a1 + 608) != v6)
  {
    int v7 = v6;
    if (*(unsigned char *)(a1 + 272) != 2)
    {
      sub_10023FB90((uint64_t)v56, (uint64_t)(v6 + 7));
      long long v71 = 1;
      uint64_t v14 = *(void *)(a3 + 24);
      if (!v14) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, char *))(*(void *)v14 + 48))(v14, v56);
      if (v71)
      {
        if (v70 < 0) {
          operator delete(v69);
        }
        if (v68 < 0) {
          operator delete(v67);
        }
        if (v66 < 0) {
          operator delete(v65);
        }
        if (v64 < 0) {
          operator delete(v63);
        }
        if (v62 < 0) {
          operator delete(v61);
        }
        if (v60 < 0) {
          operator delete(v59);
        }
        if (v58 < 0)
        {
          uint64_t v12 = v57;
          goto LABEL_94;
        }
      }
      return;
    }
    uint64_t v8 = *(void (****)(Registry **__return_ptr))(a1 + 504);
    int v9 = *(std::__shared_weak_count **)(a1 + 512);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v10 = sub_100F12924(v8) - *((double *)v7 + 7);
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (v10 < 25200.0)
    {
      sub_10023FB90((uint64_t)v40, (uint64_t)(v7 + 7));
      char v55 = 1;
      uint64_t v11 = *(void *)(a3 + 24);
      if (!v11) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, char *))(*(void *)v11 + 48))(v11, v40);
      if (v55)
      {
        if (v54 < 0) {
          operator delete(__p);
        }
        if (v52 < 0) {
          operator delete(v51);
        }
        if (v50 < 0) {
          operator delete(v49);
        }
        if (v48 < 0) {
          operator delete(v47);
        }
        if (v46 < 0) {
          operator delete(v45);
        }
        if (v44 < 0) {
          operator delete(v43);
        }
        if (v42 < 0)
        {
          uint64_t v12 = v41;
LABEL_94:
          operator delete(v12);
          return;
        }
      }
      return;
    }
    if (*((unsigned char *)v7 + 240))
    {
      if (sub_100F12AA4(a1, a2))
      {
        std::string::operator=((std::string *)(a1 + 784), (const std::string *)a2);
        uint64_t v15 = sub_100F1ADB8((uint64_t)buf, a3);
        uint64_t v16 = a1 + 808;
        if (buf != (uint8_t *)(a1 + 808))
        {
          int v17 = v96;
          int v18 = *(void *)(a1 + 832);
          if (v96 == buf)
          {
            if (v18 == v16)
            {
              memset(v97, 0, sizeof(v97));
              (*(void (**)(uint64_t, void *))(*(void *)buf + 24))(v15, v97);
              (*(void (**)(uint8_t *))(*(void *)v96 + 32))(v96);
              long long v96 = 0;
              (*(void (**)(void, uint8_t *))(**(void **)(a1 + 832) + 24))(*(void *)(a1 + 832), buf);
              (*(void (**)(void))(**(void **)(a1 + 832) + 32))(*(void *)(a1 + 832));
              *(void *)(a1 + 832) = 0;
              long long v96 = buf;
              (*(void (**)(void *, uint64_t))(v97[0] + 24))(v97, a1 + 808);
              (*(void (**)(void *))(v97[0] + 32))(v97);
            }
            else
            {
              (*(void (**)(uint64_t, uint64_t))(*(void *)buf + 24))(v15, a1 + 808);
              (*(void (**)(uint8_t *))(*(void *)v96 + 32))(v96);
              long long v96 = *(uint8_t **)(a1 + 832);
            }
            *(void *)(a1 + 832) = v16;
          }
          else if (v18 == v16)
          {
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v16 + 24))(a1 + 808, buf);
            (*(void (**)(void))(**(void **)(a1 + 832) + 32))(*(void *)(a1 + 832));
            *(void *)(a1 + 832) = v96;
            long long v96 = buf;
          }
          else
          {
            long long v96 = *(uint8_t **)(a1 + 832);
            *(void *)(a1 + 832) = v17;
          }
        }
        sub_100F18AC4(buf);
      }
      else
      {
        sub_10023FB90((uint64_t)v25, (uint64_t)(v7 + 7));
        uint64_t v39 = 1;
        int v20 = *(void *)(a3 + 24);
        if (!v20) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, void *))(*(void *)v20 + 48))(v20, v25);
        if (v39)
        {
          if (v38 < 0) {
            operator delete(v37);
          }
          if (v36 < 0) {
            operator delete(v35);
          }
          if (v34 < 0) {
            operator delete(v33);
          }
          if (v32 < 0) {
            operator delete(v31);
          }
          if (v30 < 0) {
            operator delete(v29);
          }
          if (v28 < 0) {
            operator delete(v27);
          }
          if (v26 < 0)
          {
            uint64_t v12 = (void *)v25[1];
            goto LABEL_94;
          }
        }
      }
      return;
    }
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Trying subscription update via entitlement flow", buf, 2u);
    }
    long long v88 = a1;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v89, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v89 = *(_OWORD *)a2;
      long long v90 = *(void *)(a2 + 16);
    }
    sub_100F1ADB8((uint64_t)v91, a3);
    long long v94 = 0;
    uint64_t v21 = operator new(0x48uLL);
    uint64_t v22 = v88;
    *uint64_t v21 = off_101A6EF80;
    v21[1] = v22;
    uint64_t v23 = v21 + 2;
    if (SHIBYTE(v90) < 0)
    {
      sub_10004FC84(v23, (void *)v89, *((unint64_t *)&v89 + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v23 = v89;
      void v21[4] = v90;
    }
    if (v92)
    {
      if (v92 == v91)
      {
        v21[8] = v21 + 5;
        (*(void (**)(void *))(v91[0] + 24))(v91);
        goto LABEL_92;
      }
      uint64_t v24 = &v92;
      v21[8] = v92;
    }
    else
    {
      uint64_t v24 = v21 + 8;
    }
    *uint64_t v24 = 0;
LABEL_92:
    long long v94 = v21;
    sub_100F12FC0(a1, (const std::string *)a2, (uint64_t)v93);
    sub_100F1B5FC(v93);
    sub_100F18AC4(v91);
    if ((SHIBYTE(v90) & 0x80000000) == 0) {
      return;
    }
    uint64_t v12 = (void *)v89;
    goto LABEL_94;
  }
  v72[0] = 0;
  uint64_t v87 = 0;
  int v13 = *(void *)(a3 + 24);
  if (!v13) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char *))(*(void *)v13 + 48))(v13, v72);
  if (v87)
  {
    if (v86 < 0) {
      operator delete(v85);
    }
    if (v84 < 0) {
      operator delete(v83);
    }
    if (v82 < 0) {
      operator delete(v81);
    }
    if (v80 < 0) {
      operator delete(v79);
    }
    if (v78 < 0) {
      operator delete(v77);
    }
    if (v76 < 0) {
      operator delete(v75);
    }
    if (v74 < 0)
    {
      uint64_t v12 = v73;
      goto LABEL_94;
    }
  }
}

void sub_100F12854(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

double sub_100F12924(void (***a1)(Registry **__return_ptr))
{
  (**a1)(&v15);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v1, v15);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v17);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
LABEL_9:
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 96))(v10);
  }
  else {
    double Current = CFAbsoluteTimeGetCurrent();
  }
  double v13 = Current;
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return v13;
}

void sub_100F12A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13 = v12;
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F12AA4(uint64_t a1, uint64_t a2)
{
  void (***v23)(uint64_t *__return_ptr, void, uint8_t *);
  char v24;
  NSObject *v25;
  NSObject *v26;
  const BOOL *v27;
  uint64_t v29;
  uint8_t *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint8_t *v34;
  const char *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  unsigned char v38[12];
  __int16 v39;
  const char *v40;
  long long v41;
  uint64_t v42;
  uint8_t buf[16];
  uint64_t v44;

  BOOL v2 = (void *)a2;
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  size_t v5 = *(void *)(a2 + 8);
  if ((v4 & 0x80u) == 0) {
    uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = *(unsigned __int8 *)(a1 + 695);
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(a1 + 680);
  }
  if (v6 != v7) {
    goto LABEL_16;
  }
  if (v8 >= 0) {
    int v9 = (unsigned __int8 *)(a1 + 672);
  }
  else {
    int v9 = *(unsigned __int8 **)(a1 + 672);
  }
  if ((v4 & 0x80) != 0)
  {
    BOOL v2 = (void *)*v2;
    if (memcmp(v2, v9, v5))
    {
      char v12 = *(NSObject **)(a1 + 40);
      BOOL v13 = 0;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        return v13;
      }
      goto LABEL_19;
    }
    memset(buf, 0, sizeof(buf));
    __int16 v44 = 0;
    sub_10004FC84(buf, v2, v5);
LABEL_24:
    (***(void (****)(long long *__return_ptr))(a1 + 504))(&v41);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v14, (Registry *)v41);
    uint64_t v16 = ServiceMap;
    if (v17 < 0)
    {
      int v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v38 = v17;
    uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)v38);
    if (v21)
    {
      uint64_t v23 = (void (***)(uint64_t *__return_ptr, void, uint8_t *))v21[3];
      uint64_t v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        uint64_t v24 = 0;
LABEL_32:
        if (*((void *)&v41 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v41 + 1));
        }
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        (**v23)(&v36, v23, buf);
        if (v36)
        {
          char v41 = 0uLL;
          uint64_t v42 = 0;
          (*(void (**)(long long *__return_ptr))(*(void *)v36 + 40))(&v41);
          BOOL v13 = (_BYTE)v42 != 0;
          uint64_t v25 = *(NSObject **)(a1 + 40);
          if ((_BYTE)v42)
          {
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long v38 = 0;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Force PSAS update", v38, 2u);
            }
            (*(void (**)(uint64_t, void, void))(*(void *)v36 + 80))(v36, 0, 0);
          }
          else if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            long long v32 = printers::asString((printers *)&v42, v27);
            uint64_t v33 = HIBYTE(v44);
            if (v44 < 0) {
              uint64_t v33 = *(void *)&buf[8];
            }
            char v34 = buf;
            if (v44 < 0) {
              char v34 = *(uint8_t **)buf;
            }
            if (v33) {
              uint64_t v35 = (const char *)v34;
            }
            else {
              uint64_t v35 = "<invalid>";
            }
            *(_DWORD *)long long v38 = 136315394;
            *(void *)&v38[4] = v32;
            uint64_t v39 = 2080;
            uint64_t v40 = v35;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "WiFi calling service is not ready (%s) for personality (%s)", v38, 0x16u);
          }
          sub_100057D78((const void **)&v41 + 1);
        }
        else
        {
          uint64_t v26 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            __int16 v29 = HIBYTE(v44);
            if (v44 < 0) {
              __int16 v29 = *(void *)&buf[8];
            }
            uint64_t v30 = buf;
            if (v44 < 0) {
              uint64_t v30 = *(uint8_t **)buf;
            }
            if (v29) {
              long long v31 = (const char *)v30;
            }
            else {
              long long v31 = "<invalid>";
            }
            LODWORD(v41) = 136315138;
            *(void *)((char *)&v41 + 4) = v31;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Phone service not found for personality (%s)", (uint8_t *)&v41, 0xCu);
          }
          BOOL v13 = 0;
        }
        if (v37) {
          sub_10004D2C8(v37);
        }
        if ((v24 & 1) == 0) {
          sub_10004D2C8(v22);
        }
        if (SHIBYTE(v44) < 0) {
          operator delete(*(void **)buf);
        }
        return v13;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    uint64_t v22 = 0;
    uint64_t v24 = 1;
    goto LABEL_32;
  }
  if (!v4)
  {
LABEL_15:
    *(_OWORD *)long long buf = *(_OWORD *)v2;
    __int16 v44 = v2[2];
    goto LABEL_24;
  }
  uint64_t v10 = (unsigned __int8 *)v2;
  uint64_t v11 = v4;
  while (*v10 == *v9)
  {
    ++v10;
    ++v9;
    if (!--v11) {
      goto LABEL_15;
    }
  }
LABEL_16:
  char v12 = *(NSObject **)(a1 + 40);
  BOOL v13 = 0;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    if ((v4 & 0x80u) != 0) {
      BOOL v2 = (void *)*v2;
    }
LABEL_19:
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Profile (%s) is not selected , cannot run PSAS update", buf, 0xCu);
    return 0;
  }
  return v13;
}

void sub_100F12F3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_100057D78((const void **)&a16);
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F12FC0(uint64_t a1, const std::string *a2, uint64_t a3)
{
  void (***v32)(uint64_t *__return_ptr, void, long long *);
  char v33;
  const std::string *v34;
  char *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  NSObject *v39;
  void *v40;
  NSObject *v41;
  void *v42;
  uint8_t v43[16];
  void *v44[2];
  long long v45;
  void *v46[2];
  long long v47;
  uint64_t v48;
  char v49;
  void *v50;
  char v51;
  void *v52;
  char v53;
  void *v54;
  char v55;
  void *v56;
  char v57;
  void *v58;
  char v59;
  void *v60;
  char v61;
  void *v62;
  char v63;
  char v64;
  uint64_t v65;
  char v66;
  void *v67;
  char v68;
  void *v69;
  char v70;
  void *v71;
  char v72;
  void *v73;
  char v74;
  void *v75;
  char v76;
  void *v77;
  char v78;
  void *v79;
  char v80;
  char v81;
  std::string __str[3];
  char v83;
  void *v84;
  char v85;
  void *v86;
  char v87;
  void *v88;
  char v89;
  void *v90;
  char v91;
  void *v92;
  char v93;
  void *v94;
  char v95;
  void *v96;
  char v97;
  char v98;
  uint64_t v99;
  std::__shared_weak_count *v100;
  char v101;
  char v102;
  void v103[5];
  void v104[4];
  std::string v105;
  void v106[2];
  long long v107;
  std::string::size_type v108;
  long long buf;
  long long v110;
  long long v111;
  long long v112;
  long long v113;
  long long v114;
  long long v115;
  long long v116;
  long long v117;
  long long v118;
  long long v119;

  if (*(void *)(a3 + 24))
  {
    size_t v5 = a2;
    int v6 = SHIBYTE(a2->__r_.__value_.__r.__words[2]);
    unint64_t size = a2->__r_.__value_.__l.__size_;
    if (v6 >= 0) {
      std::string::size_type v8 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v8 = a2->__r_.__value_.__l.__size_;
    }
    if (v8)
    {
      uint64_t v9 = *(unsigned __int8 *)(a1 + 695);
      uint64_t v10 = (v9 & 0x80u) == 0 ? *(unsigned __int8 *)(a1 + 695) : *(void *)(a1 + 680);
      if (v10 == v8)
      {
        uint64_t v11 = (const void **)(a1 + 672);
        char v12 = (void *)a2->__r_.__value_.__r.__words[0];
        if (v6 < 0) {
          a2 = (const std::string *)a2->__r_.__value_.__r.__words[0];
        }
        if ((v9 & 0x80) == 0)
        {
          if (*(unsigned char *)(a1 + 695))
          {
            while (*(unsigned __int8 *)v11 == a2->__r_.__value_.__s.__data_[0])
            {
              uint64_t v11 = (const void **)((char *)v11 + 1);
              a2 = (const std::string *)((char *)a2 + 1);
              if (!--v9) {
                goto LABEL_23;
              }
            }
            goto LABEL_20;
          }
LABEL_23:
          if (v6 < 0)
          {
            sub_10004FC84(&buf, v12, size);
          }
          else
          {
            long long buf = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
            *(void *)&long long v110 = *((void *)&v5->__r_.__value_.__l + 2);
          }
          uint64_t v15 = sub_100046F68(a1 + 248, (void **)&buf);
          if (SBYTE7(v110) < 0) {
            operator delete((void *)buf);
          }
          if ((void **)(a1 + 256) == v15) {
            goto LABEL_21;
          }
          if ((*((unsigned char *)v15 + 57) & 8) == 0) {
            goto LABEL_21;
          }
          int v18 = (char *)v15[9];
          uint64_t v17 = v15 + 9;
          uint64_t v16 = v18;
          if (!v18) {
            goto LABEL_21;
          }
          uint64_t v19 = v17;
          do
          {
            int v20 = *((_DWORD *)v16 + 7);
            BOOL v21 = v20 < 11;
            if (v20 >= 11) {
              uint64_t v22 = (void **)v16;
            }
            else {
              uint64_t v22 = (void **)(v16 + 8);
            }
            if (!v21) {
              uint64_t v19 = (void **)v16;
            }
            uint64_t v16 = (char *)*v22;
          }
          while (*v22);
          if (v19 == v17 || *((int *)v19 + 7) > 11 || *((_DWORD *)v19 + 8) != 2)
          {
LABEL_21:
            char v101 = 0;
            long long v102 = 0;
            sub_100F17288(*(void *)(a3 + 24), 0);
            return;
          }
          long long v100 = 0;
          v99 = 0;
          (***(void (****)(uint8_t *__return_ptr))(a1 + 504))(v43);
          ServiceMap = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)v43);
          char v25 = ServiceMap;
          if (v26 < 0)
          {
            uint64_t v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v28 = 5381;
            do
            {
              uint64_t v26 = v28;
              unsigned int v29 = *v27++;
              uint64_t v28 = (33 * v28) ^ v29;
            }
            while (v29);
          }
          std::mutex::lock(ServiceMap);
          *(void *)&long long buf = v26;
          uint64_t v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)&buf);
          if (v30)
          {
            long long v32 = (void (***)(uint64_t *__return_ptr, void, long long *))v30[3];
            long long v31 = (std::__shared_weak_count *)v30[4];
            if (v31)
            {
              atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v25);
              atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v31);
              uint64_t v33 = 0;
              goto LABEL_52;
            }
          }
          else
          {
            long long v32 = 0;
          }
          std::mutex::unlock(v25);
          long long v31 = 0;
          uint64_t v33 = 1;
LABEL_52:
          if (SHIBYTE(v5->__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(&buf, v5->__r_.__value_.__l.__data_, v5->__r_.__value_.__l.__size_);
          }
          else
          {
            long long buf = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
            *(void *)&long long v110 = *((void *)&v5->__r_.__value_.__l + 2);
          }
          (**v32)(&v99, v32, &buf);
          if (SBYTE7(v110) < 0) {
            operator delete((void *)buf);
          }
          if ((v33 & 1) == 0) {
            sub_10004D2C8(v31);
          }
          if (*(void *)&v43[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v43[8]);
          }
          if (!v99)
          {
            unint64_t v83 = 0;
            uint64_t v98 = 0;
            sub_100F17288(*(void *)(a3 + 24), 0);
            if (!v98) {
              goto LABEL_153;
            }
            if (v97 < 0) {
              operator delete(v96);
            }
            if (v95 < 0) {
              operator delete(v94);
            }
            if (v93 < 0) {
              operator delete(v92);
            }
            if (v91 < 0) {
              operator delete(v90);
            }
            if (v89 < 0) {
              operator delete(v88);
            }
            if (v87 < 0) {
              operator delete(v86);
            }
            if ((v85 & 0x80000000) == 0) {
              goto LABEL_153;
            }
            uint64_t v37 = v84;
            goto LABEL_152;
          }
          memset(__str, 0, 64);
          std::string::operator=(__str, v5);
          std::string v118 = 0u;
          uint64_t v119 = 0u;
          long long v116 = 0u;
          uint64_t v117 = 0u;
          long long v114 = 0u;
          long long v115 = 0u;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v110 = 0u;
          uint64_t v111 = 0u;
          long long buf = 0u;
          uint64_t v35 = sub_100CB6240((char *)&v115 + 8, __str);
          if ((SBYTE7(v110) & 0x80u) == 0) {
            uint64_t v36 = BYTE7(v110);
          }
          else {
            uint64_t v36 = *((void *)&buf + 1);
          }
          if (!v36 && BYTE8(v119))
          {
            if (SHIBYTE(v116) < 0) {
              uint64_t v36 = v116;
            }
            else {
              uint64_t v36 = HIBYTE(v116);
            }
          }
          if (v36)
          {
            long long v65 = 0;
            if (BYTE8(v119) && BYTE12(v117) && DWORD2(v117) == 3
              || (capabilities::ct::supportsSIMProvisioningAsSignupDestination((capabilities::ct *)v35) & 1) != 0)
            {
              LODWORD(v65) = 11;
              BYTE4(v65) = 1;
              __int16 v48 = 0;
              *(_OWORD *)long long v46 = 0u;
              char v47 = 0u;
              *(_OWORD *)__int16 v44 = 0u;
              long long v45 = 0u;
              *(_OWORD *)__int16 v43 = 0u;
              v43[3] = 1;
              long long v38 = v99;
              v103[0] = _NSConcreteStackBlock;
              v103[1] = 1174405120;
              v103[2] = sub_100F172D8;
              v103[3] = &unk_101A6E888;
              v103[4] = a1;
              sub_100F1BCE4((uint64_t)v104, a3);
              if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                sub_10004FC84(&v105, __str[0].__r_.__value_.__l.__data_, __str[0].__r_.__value_.__l.__size_);
              }
              else {
                long long v105 = __str[0];
              }
              v106[0] = __str[1].__r_.__value_.__l.__data_;
              *(void *)((char *)v106 + 5) = *(std::string::size_type *)((char *)__str[1].__r_.__value_.__r.__words + 5);
              if (__str[2].__r_.__value_.__s.__data_[15] < 0)
              {
                sub_10004FC84(&v107, (void *)__str[1].__r_.__value_.__r.__words[2], __str[2].__r_.__value_.__r.__words[0]);
              }
              else
              {
                long long v107 = *(_OWORD *)&__str[1].__r_.__value_.__r.__words[2];
                long long v108 = __str[2].__r_.__value_.__l.__size_;
              }
              uint64_t v42 = v103;
              (*(void (**)(uint64_t, void, uint8_t *, uint64_t *, long long *, uint64_t, void **))(*(void *)v38 + 152))(v38, 0, v43, &v65, &buf, a1 + 24, &v42);
              if (SHIBYTE(v108) < 0) {
                operator delete((void *)v107);
              }
              if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v105.__r_.__value_.__l.__data_);
              }
              sub_100F1B5FC(v104);
              if ((_BYTE)v48 && SHIBYTE(v47) < 0) {
                operator delete(v46[1]);
              }
              if (!LOBYTE(v46[0]) || (SHIBYTE(v45) & 0x80000000) == 0) {
                goto LABEL_141;
              }
              uint64_t v40 = v44[1];
            }
            else
            {
              char v41 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)__int16 v43 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "Unsupported action", v43, 2u);
              }
              char v49 = 0;
              std::string v64 = 0;
              sub_100F17288(*(void *)(a3 + 24), 0);
              if (!v64) {
                goto LABEL_141;
              }
              if (v63 < 0) {
                operator delete(v62);
              }
              if (v61 < 0) {
                operator delete(v60);
              }
              if (v59 < 0) {
                operator delete(v58);
              }
              if (v57 < 0) {
                operator delete(v56);
              }
              if (v55 < 0) {
                operator delete(v54);
              }
              if (v53 < 0) {
                operator delete(v52);
              }
              if ((v51 & 0x80000000) == 0) {
                goto LABEL_141;
              }
              uint64_t v40 = v50;
            }
          }
          else
          {
            uint64_t v39 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)__int16 v43 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "request is not valid", v43, 2u);
            }
            long long v66 = 0;
            uint64_t v81 = 0;
            sub_100F17288(*(void *)(a3 + 24), 0);
            if (!v81) {
              goto LABEL_141;
            }
            if (v80 < 0) {
              operator delete(v79);
            }
            if (v78 < 0) {
              operator delete(v77);
            }
            if (v76 < 0) {
              operator delete(v75);
            }
            if (v74 < 0) {
              operator delete(v73);
            }
            if (v72 < 0) {
              operator delete(v71);
            }
            if (v70 < 0) {
              operator delete(v69);
            }
            if ((v68 & 0x80000000) == 0) {
              goto LABEL_141;
            }
            uint64_t v40 = v67;
          }
          operator delete(v40);
LABEL_141:
          sub_10019EFB4((uint64_t)&v115 + 8);
          *(void *)__int16 v43 = &v114;
          sub_100047F64((void ***)v43);
          if (SHIBYTE(v113) < 0) {
            operator delete(*((void **)&v112 + 1));
          }
          if ((_BYTE)v112 && SHIBYTE(v111) < 0) {
            operator delete(*((void **)&v110 + 1));
          }
          if (SBYTE7(v110) < 0) {
            operator delete((void *)buf);
          }
          if (__str[2].__r_.__value_.__s.__data_[15] < 0) {
            operator delete((void *)__str[1].__r_.__value_.__r.__words[2]);
          }
          if ((SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_153;
          }
          uint64_t v37 = (void *)__str[0].__r_.__value_.__r.__words[0];
LABEL_152:
          operator delete(v37);
LABEL_153:
          if (v100) {
            sub_10004D2C8(v100);
          }
          return;
        }
        if (!memcmp(*v11, a2, *(void *)(a1 + 680))) {
          goto LABEL_23;
        }
      }
    }
LABEL_20:
    uint64_t v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      char v34 = (const std::string *)v5->__r_.__value_.__r.__words[0];
      if (v6 >= 0) {
        char v34 = v5;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v34;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Profile is not selected (%s)", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_21;
  }
  BOOL v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "callback is not available", (uint8_t *)&buf, 2u);
  }
}

void sub_100F138E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (SLOBYTE(STACK[0x447]) < 0) {
    operator delete((void *)STACK[0x430]);
  }
  sub_100F1B5FC(v3);
  sub_10016A3E8((uint64_t)va);
  sub_100CB68DC((uint64_t)&STACK[0x470]);
  sub_1002E4140((uint64_t)&STACK[0x200]);
  if (STACK[0x318]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x318]);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F13A30(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_100F13A6C(void *result)
{
  if (!result[73])
  {
    if (*((char *)result + 695) < 0)
    {
      if (!result[85]) {
        return result;
      }
    }
    else if (!*((unsigned char *)result + 695))
    {
      return result;
    }
    v1[0] = off_101A6F010;
    v1[3] = v1;
    sub_100F120A8((uint64_t)result, (uint64_t)(result + 84), (uint64_t)v1);
    return sub_100F18AC4(v1);
  }
  return result;
}

void sub_100F13B18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100F18AC4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F13B2C(uint64_t a1, uint64_t a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v10 = 0;
  if (*(void *)(a1 + 456) != *(void *)(a1 + 464))
  {
    (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 536) + 104))(&v7);
    uint64_t v3 = __p[0];
    if (__p[0])
    {
      uint64_t v4 = __p[1];
      size_t v5 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v4 = (void *)sub_1000C62D8((uint64_t)v4 - 192);
        while (v4 != v3);
        size_t v5 = __p[0];
      }
      __p[1] = v3;
      operator delete(v5);
    }
    *(_OWORD *)long long __p = v7;
    uint64_t v10 = v8;
    uint64_t v8 = 0;
    long long v7 = 0uLL;
    uint64_t v11 = (void **)&v7;
    sub_10023FDC8(&v11);
  }
  uint64_t v6 = *(void *)(a2 + 24);
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v6 + 48))(v6, __p);
  *(void *)&long long v7 = __p;
  sub_10023FDC8((void ***)&v7);
}

void sub_100F13C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  a9 = (void **)&a13;
  sub_10023FDC8(&a9);
  _Unwind_Resume(a1);
}

void sub_100F13C64(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(void, uint64_t *, void))(**(void **)(a1 + 536) + 112))(*(void *)(a1 + 536), a2, 0);

  sub_100F13CCC(a1, a2);
}

void sub_100F13CCC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 528);
  if (v4 && (uint64_t v4 = std::__shared_weak_count::lock(v4)) != 0) {
    uint64_t v91 = *(void *)(a1 + 520);
  }
  else {
    uint64_t v91 = 0;
  }
  long long v90 = v4;
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  long long v88 = a2;
  if (*a2 != v5)
  {
    int v7 = 0;
    long long v89 = (const void **)(a1 + 752);
    while (1)
    {
      if (*(char *)(v6 + 55) < 0)
      {
        if (!*(void *)(v6 + 40))
        {
LABEL_13:
          uint64_t v11 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Received empty ICCID, skipping update", buf, 2u);
          }
          goto LABEL_105;
        }
      }
      else if (!*(unsigned char *)(v6 + 55))
      {
        goto LABEL_13;
      }
      uint64_t v8 = (std::string::size_type *)(v6 + 32);
      *(void *)long long buf = v6 + 32;
      uint64_t v9 = sub_1003DF1C0((uint64_t **)(a1 + 600), (void **)(v6 + 32), (uint64_t)&unk_10144E20E, (long long **)buf);
      if (CellularPlanEntitlementSubscriptionDetails::merge((CellularPlanEntitlementSubscriptionDetails *)(v9 + 7), (const CellularPlanEntitlementSubscriptionDetails *)v6))
      {
        if (sub_100F11C04(a1, v6))
        {
          sub_100046BAC((uint64_t **)(a1 + 624), (void **)(v6 + 32), v6 + 32);
          int v7 = (v10 | v7) & 1;
        }
        else
        {
          v7 |= sub_1000E9358((uint64_t **)(a1 + 624), (void **)(v6 + 32)) != 0;
        }
        if (v91) {
          break;
        }
      }
LABEL_105:
      v6 += 192;
      if (v6 == v5) {
        goto LABEL_108;
      }
    }
    long long v102 = 0u;
    memset(v101, 0, sizeof(v101));
    *(_OWORD *)long long buf = 0u;
    sub_100F17018((uint64_t)buf, *(void *)(a1 + 456), *(void *)(a1 + 464), v6 + 32);
    int v12 = (int)v90;
    if (BYTE8(v102))
    {
      uint64_t v13 = *(unsigned __int8 *)(a1 + 775);
      if ((v13 & 0x80u) == 0) {
        uint64_t v14 = *(unsigned __int8 *)(a1 + 775);
      }
      else {
        uint64_t v14 = *(void *)(a1 + 760);
      }
      uint64_t v15 = *(unsigned __int8 *)(v6 + 55);
      int v16 = (char)v15;
      if ((v15 & 0x80u) != 0) {
        uint64_t v15 = *(void *)(v6 + 40);
      }
      if (v14 == v15)
      {
        if (v16 >= 0) {
          uint64_t v17 = (unsigned __int8 *)(v6 + 32);
        }
        else {
          uint64_t v17 = (unsigned __int8 *)*v8;
        }
        if ((v13 & 0x80) != 0)
        {
          BOOL v26 = memcmp(*v89, v17, *(void *)(a1 + 760)) == 0;
        }
        else if (*(unsigned char *)(a1 + 775))
        {
          uint64_t v18 = v13 - 1;
          uint64_t v19 = (unsigned __int8 *)(a1 + 752);
          do
          {
            int v21 = *v19++;
            int v20 = v21;
            int v23 = *v17++;
            int v22 = v23;
            BOOL v25 = v18-- != 0;
            BOOL v38 = v20 == v22;
            BOOL v26 = v20 == v22;
          }
          while (v38 && v25);
        }
        else
        {
          BOOL v26 = 1;
        }
      }
      else
      {
        BOOL v26 = 0;
      }
      int v36 = *(unsigned __int8 *)(v6 + 56);
      int v37 = *(unsigned __int8 *)(v6 + 57);
      BOOL v38 = !v26 && v36 == 0;
      if (!v38 || v37 != 0)
      {
        v94[0] = v91;
        v94[1] = v90;
        if (v90)
        {
          atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
          int v37 = *(unsigned __int8 *)(v6 + 57);
          int v36 = *(unsigned __int8 *)(v6 + 56);
        }
        sub_100F16A14(v94, (uint64_t)buf, (uint64_t)v101, v37, v36);
        if (v90)
        {
          sub_10004D2C8(v90);
          int v12 = 0;
        }
        goto LABEL_101;
      }
      uint64_t v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        if (v16 < 0) {
          uint64_t v8 = (std::string::size_type *)*v8;
        }
        LODWORD(v99.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v99.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Skipping profile status update (%s)", (uint8_t *)&v99, 0xCu);
      }
    }
    else
    {
      uint64_t v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v28 = v6 + 32;
        if (*(char *)(v6 + 55) < 0) {
          std::string::size_type v28 = *v8;
        }
        LODWORD(v99.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v99.__r_.__value_.__r.__words + 4) = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Profile not found (%s)", (uint8_t *)&v99, 0xCu);
      }
      if (*(void *)(a1 + 456) == *(void *)(a1 + 464))
      {
        uint64_t v35 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v99.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Missing vinyl info", (uint8_t *)&v99, 2u);
        }
        int v12 = 1;
LABEL_101:
        if (BYTE8(v102)) {
          sub_1000C584C((uint64_t)v101);
        }
        if (v12 != 3 && v12) {
          goto LABEL_214;
        }
        goto LABEL_105;
      }
      uint64_t v29 = *(unsigned __int8 *)(a1 + 775);
      if ((v29 & 0x80u) == 0) {
        uint64_t v30 = *(unsigned __int8 *)(a1 + 775);
      }
      else {
        uint64_t v30 = *(void *)(a1 + 760);
      }
      int v31 = *(char *)(v6 + 55);
      if (v31 >= 0) {
        uint64_t v32 = *(unsigned __int8 *)(v6 + 55);
      }
      else {
        uint64_t v32 = *(void *)(v6 + 40);
      }
      if (v30 == v32)
      {
        if (v31 >= 0) {
          uint64_t v33 = (unsigned __int8 *)(v6 + 32);
        }
        else {
          uint64_t v33 = (unsigned __int8 *)*v8;
        }
        if ((v29 & 0x80) != 0)
        {
          if (!memcmp(*v89, v33, *(void *)(a1 + 760))) {
            goto LABEL_100;
          }
        }
        else
        {
          if (!*(unsigned char *)(a1 + 775)) {
            goto LABEL_100;
          }
          char v34 = (unsigned __int8 *)(a1 + 752);
          while (*v34 == *v33)
          {
            ++v34;
            ++v33;
            int v12 = 3;
            if (!--v29) {
              goto LABEL_101;
            }
          }
        }
      }
      if (*(char *)(v6 + 135) < 0)
      {
        if (!*(void *)(v6 + 120)) {
          goto LABEL_100;
        }
      }
      else if (!*(unsigned char *)(v6 + 135))
      {
        goto LABEL_100;
      }
      int v12 = 3;
      if (!v32 || !*(unsigned char *)(v6 + 185) || *(unsigned __int8 *)(v6 + 56) - 5 < 3) {
        goto LABEL_101;
      }
      long long v97 = 0;
      uint64_t v98 = 0;
      sub_100324590(&v97);
      std::string::operator=(v97, (const std::string *)(v6 + 112));
      char v41 = v97;
      uint64_t v42 = v97 + 4;
      std::string::size_type size = v97[4].__r_.__value_.__l.__size_;
      if (size >= v97[4].__r_.__value_.__r.__words[2])
      {
        uint64_t v44 = sub_10030E9EC((uint64_t *)v42, (long long *)(v6 + 32));
      }
      else
      {
        sub_1000D87F8(v42, (long long *)(v6 + 32));
        uint64_t v44 = size + 24;
      }
      v41[4].__r_.__value_.__l.__size_ = v44;
      long long v45 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v6 + 55) < 0) {
          uint64_t v8 = (std::string::size_type *)*v8;
        }
        uint64_t v46 = asString();
        LODWORD(v99.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v99.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
        WORD2(v99.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v99.__r_.__value_.__r.__words[1] + 6) = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Attempt to Install profile (%s) via subscription details with status %s", (uint8_t *)&v99, 0x16u);
      }
      uint64_t v47 = *(void *)(a1 + 456);
      long long v95 = v97;
      long long v96 = v98;
      if (v98) {
        atomic_fetch_add_explicit(&v98->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t, std::string **))(*(void *)v91 + 96))(v91, v47 + 16, &v95);
      if (v96) {
        sub_10004D2C8(v96);
      }
      if (v98) {
        sub_10004D2C8(v98);
      }
    }
LABEL_100:
    int v12 = 3;
    goto LABEL_101;
  }
  LOBYTE(v7) = 0;
LABEL_108:
  memset(&v99, 0, sizeof(v99));
  if (*(char *)(a1 + 775) < 0)
  {
    if (!*(void *)(a1 + 760)) {
      goto LABEL_118;
    }
  }
  else if (!*(unsigned char *)(a1 + 775))
  {
    goto LABEL_118;
  }
  if (*(unsigned char *)(a1 + 776))
  {
    sub_100F17018((uint64_t)buf, *(void *)(a1 + 456), *(void *)(a1 + 464), a1 + 752);
    if (BYTE8(v102))
    {
      sub_1000C584C((uint64_t)v101);
      __int16 v48 = sub_100046F68(a1 + 600, (void **)(a1 + 752));
      if ((void **)(a1 + 608) != v48 && *((unsigned char *)v48 + 112) == 2 && sub_10010E128(a1 + 624, (void **)(a1 + 752)))
      {
        std::string::operator=(&v99, (const std::string *)(a1 + 752));
        sub_100F1574C(a1, &v99, 1);
      }
      goto LABEL_167;
    }
  }
LABEL_118:
  if (*(void *)(a1 + 584) && (sIsAnyUserProfileActive() & 1) == 0)
  {
    uint64_t v57 = *v88;
    uint64_t v58 = v88[1];
    if (*v88 == v58) {
      goto LABEL_167;
    }
    char v59 = (const void **)(a1 + 696);
    uint64_t v60 = *(unsigned __int8 *)(a1 + 719);
    size_t v61 = *(void *)(a1 + 704);
    if ((v60 & 0x80u) == 0) {
      uint64_t v62 = *(unsigned __int8 *)(a1 + 719);
    }
    else {
      uint64_t v62 = *(void *)(a1 + 704);
    }
    while (1)
    {
      uint64_t v63 = *(unsigned __int8 *)(v57 + 55);
      int v64 = (char)v63;
      if ((v63 & 0x80u) != 0) {
        uint64_t v63 = *(void *)(v57 + 40);
      }
      if (v62 != v63) {
        goto LABEL_152;
      }
      if (v64 >= 0) {
        long long v65 = (unsigned __int8 *)(v57 + 32);
      }
      else {
        long long v65 = *(unsigned __int8 **)(v57 + 32);
      }
      if ((v60 & 0x80) != 0)
      {
        if (memcmp(*v59, v65, v61)) {
          goto LABEL_152;
        }
      }
      else
      {
        long long v66 = (unsigned __int8 *)(a1 + 696);
        uint64_t v67 = v60;
        if (v60)
        {
          while (*v66 == *v65)
          {
            ++v66;
            ++v65;
            if (!--v67) {
              goto LABEL_151;
            }
          }
          goto LABEL_152;
        }
      }
LABEL_151:
      if (*(unsigned char *)(v57 + 56) == 2)
      {
        BOOL v70 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
        {
          long long v71 = (const void *)(a1 + 696);
          if ((v60 & 0x80) != 0) {
            long long v71 = *v59;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v71;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I User requested profile (%s) is not enabled but plan is now active, should activate the profile)", buf, 0xCu);
        }
        std::string::operator=(&v99, (const std::string *)(a1 + 696));
        sub_100F1574C(a1, &v99, 1);
        if (*(char *)(a1 + 695) < 0)
        {
          **(unsigned char **)(a1 + 672) = 0;
          *(void *)(a1 + 680) = 0;
        }
        else
        {
          *(unsigned char *)(a1 + 672) = 0;
          *(unsigned char *)(a1 + 695) = 0;
        }
        goto LABEL_167;
      }
LABEL_152:
      v57 += 192;
      if (v57 == v58) {
        goto LABEL_167;
      }
    }
  }
  if (*(void *)(a1 + 640) != 1) {
    goto LABEL_167;
  }
  uint64_t v49 = *(void *)(a1 + 624);
  uint64_t v50 = (const std::string *)(v49 + 32);
  uint64_t v51 = *(unsigned __int8 *)(a1 + 719);
  if ((v51 & 0x80u) == 0) {
    uint64_t v52 = *(unsigned __int8 *)(a1 + 719);
  }
  else {
    uint64_t v52 = *(void *)(a1 + 704);
  }
  uint64_t v53 = *(unsigned __int8 *)(v49 + 55);
  uint64_t v54 = *(void *)(v49 + 40);
  if ((v53 & 0x80u) == 0) {
    uint64_t v54 = v53;
  }
  if (v52 == v54)
  {
    char v55 = (const void **)(a1 + 696);
    if ((v53 & 0x80u) == 0) {
      char v56 = v50;
    }
    else {
      char v56 = (const std::string *)v50->__r_.__value_.__r.__words[0];
    }
    if ((v51 & 0x80) != 0)
    {
      if (!memcmp(*v55, v56, *(void *)(a1 + 704))) {
        goto LABEL_167;
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 719)) {
        goto LABEL_167;
      }
      while (*(unsigned __int8 *)v55 == v56->__r_.__value_.__s.__data_[0])
      {
        char v55 = (const void **)((char *)v55 + 1);
        char v56 = (const std::string *)((char *)v56 + 1);
        if (!--v51) {
          goto LABEL_167;
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 272) == 1)
  {
    std::string::operator=(&v99, v50);
    long long v68 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      long long v69 = &v99;
      if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v69 = (std::string *)v99.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v69;
      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I Enable the single selectable profile (%s)", buf, 0xCu);
    }
  }
LABEL_167:
  std::string::size_type v72 = HIBYTE(v99.__r_.__value_.__r.__words[2]);
  int v73 = SHIBYTE(v99.__r_.__value_.__r.__words[2]);
  std::string::size_type v74 = v99.__r_.__value_.__l.__size_;
  if ((v99.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v75 = HIBYTE(v99.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v75 = v99.__r_.__value_.__l.__size_;
  }
  if (v75)
  {
    uint64_t v76 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v77 = (std::string *)v99.__r_.__value_.__r.__words[0];
      if (v73 >= 0) {
        uint64_t v77 = &v99;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v77;
      _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "#I Enabling profile [Subscription Update] (%s)", buf, 0xCu);
      std::string::size_type v72 = HIBYTE(v99.__r_.__value_.__r.__words[2]);
      std::string::size_type v74 = v99.__r_.__value_.__l.__size_;
      LOBYTE(v73) = *((unsigned char *)&v99.__r_.__value_.__s + 23);
    }
    uint64_t v78 = *(unsigned __int8 *)(a1 + 719);
    if ((v78 & 0x80u) == 0) {
      uint64_t v79 = *(unsigned __int8 *)(a1 + 719);
    }
    else {
      uint64_t v79 = *(void *)(a1 + 704);
    }
    if ((v73 & 0x80u) == 0) {
      std::string::size_type v80 = v72;
    }
    else {
      std::string::size_type v80 = v74;
    }
    if (v79 == v80)
    {
      if ((v73 & 0x80u) == 0) {
        uint64_t v81 = &v99;
      }
      else {
        uint64_t v81 = (std::string *)v99.__r_.__value_.__r.__words[0];
      }
      if ((v78 & 0x80) == 0)
      {
        if (*(unsigned char *)(a1 + 719))
        {
          long long v82 = (unsigned __int8 *)(a1 + 696);
          while (*v82 == v81->__r_.__value_.__s.__data_[0])
          {
            ++v82;
            uint64_t v81 = (std::string *)((char *)v81 + 1);
            if (!--v78) {
              goto LABEL_207;
            }
          }
          goto LABEL_203;
        }
LABEL_207:
        char v86 = sub_100F0FC20(a1);
LABEL_208:
        LOBYTE(v7) = v86 ^ 1;
        goto LABEL_209;
      }
      if (!memcmp(*(const void **)(a1 + 696), v81, *(void *)(a1 + 704))) {
        goto LABEL_207;
      }
    }
LABEL_203:
    std::string::operator=((std::string *)(a1 + 696), &v99);
    unint64_t v85 = *(std::__shared_weak_count **)(a1 + 576);
    v93[0] = *(void *)(a1 + 568);
    v93[1] = v85;
    if (v85) {
      atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F0F92C(v93, @"RemotePlanSelectedKey", a1 + 696);
    if (v85) {
      sub_10004D2C8(v85);
    }
    goto LABEL_207;
  }
  if (*(char *)(a1 + 719) < 0)
  {
    if (!*(void *)(a1 + 704)) {
      goto LABEL_209;
    }
    goto LABEL_195;
  }
  if (*(unsigned char *)(a1 + 719))
  {
LABEL_195:
    if (sub_10010E128(a1 + 624, (void **)(a1 + 696))) {
      goto LABEL_209;
    }
    unint64_t v83 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v84 = a1 + 696;
      if (*(char *)(a1 + 719) < 0) {
        uint64_t v84 = *(void *)(a1 + 696);
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v84;
      _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "#I Disabling profile [Subscription Update] (%s)", buf, 0xCu);
    }
    if (*(char *)(a1 + 719) < 0)
    {
      **(unsigned char **)(a1 + 696) = 0;
      *(void *)(a1 + 704) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 696) = 0;
      *(unsigned char *)(a1 + 719) = 0;
    }
    uint64_t v87 = *(std::__shared_weak_count **)(a1 + 576);
    v92[0] = *(void *)(a1 + 568);
    v92[1] = v87;
    if (v87) {
      atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F0F92C(v92, @"RemotePlanSelectedKey", a1 + 696);
    if (v87) {
      sub_10004D2C8(v87);
    }
    char v86 = sub_100F0FC20(a1);
    goto LABEL_208;
  }
LABEL_209:
  if (v91 && (v7 & 1) != 0) {
    (*(void (**)(uint64_t))(*(void *)v91 + 32))(v91);
  }
  if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v99.__r_.__value_.__l.__data_);
  }
LABEL_214:
  if (v90) {
    sub_10004D2C8(v90);
  }
}

void sub_100F14854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,void *__p,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  if (a28) {
    sub_10004D2C8(a28);
  }
  if (a62) {
    sub_1000C584C(a16);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

void sub_100F1490C(uint64_t a1, std::string *__str, char a3)
{
  uint64_t v4 = __str;
  uint64_t v6 = (std::string *)(a1 + 752);
  char v7 = *(unsigned char *)(a1 + 775);
  size_t v8 = *(void *)(a1 + 760);
  if (v7 >= 0) {
    size_t v9 = *(unsigned __int8 *)(a1 + 775);
  }
  else {
    size_t v9 = *(void *)(a1 + 760);
  }
  std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  int v11 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  if (v9 == size)
  {
    if (v11 < 0) {
      std::string __str = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    if ((*(unsigned char *)(a1 + 775) & 0x80) != 0)
    {
      int v14 = memcmp(v6->__r_.__value_.__l.__data_, __str, v8);
      size_t v9 = v8;
      if (!v14) {
        return;
      }
    }
    else
    {
      if (!*(unsigned char *)(a1 + 775)) {
        return;
      }
      int v12 = (unsigned __int8 *)(a1 + 752);
      uint64_t v13 = *(unsigned __int8 *)(a1 + 775);
      while (*v12 == __str->__r_.__value_.__s.__data_[0])
      {
        ++v12;
        std::string __str = (std::string *)((char *)__str + 1);
        if (!--v13) {
          return;
        }
      }
    }
  }
  if (v9)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = v6;
      if (v7 < 0) {
        uint64_t v18 = (std::string *)v6->__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      int v21 = v18;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Overrwriting last installed ICCID (%s)", buf, 0xCu);
    }
  }
  std::string::operator=(v6, v4);
  *(unsigned char *)(a1 + 776) = a3 ^ 1;
  uint64_t v16 = *(void *)(a1 + 568);
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 576);
  v19[0] = v16;
  v19[1] = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F14AC4(v19, (uint64_t)v6);
  if (v17) {
    sub_10004D2C8(v17);
  }
}

void sub_100F14AA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F14AC4(void *a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (v3)
  {
    *(void *)uint64_t v15 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      uint64_t v6 = *(__CFDictionary **)v15;
      *(void *)uint64_t v15 = Mutable;
      __p[0] = v6;
      sub_10005717C((const void **)__p);
    }
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)int v12 = *(_OWORD *)a2;
      uint64_t v13 = *(void *)(a2 + 16);
    }
    if (SHIBYTE(v13) < 0)
    {
      sub_10004FC84(__dst, v12[0], (unint64_t)v12[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v12;
      uint64_t v18 = v13;
    }
    uint64_t v16 = 0;
    if (SHIBYTE(v18) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)__dst;
      uint64_t v20 = v18;
    }
    int v21 = 0;
    if (ctu::cf::convert_copy())
    {
      size_t v9 = v16;
      uint64_t v16 = v21;
      int v22 = v9;
      sub_1000558F4(&v22);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = (uint64_t)v16;
    int v14 = v16;
    uint64_t v16 = 0;
    sub_1000558F4(&v16);
    if (SHIBYTE(v18) < 0) {
      operator delete(__dst[0]);
    }
    sub_10010F3F0(*(__CFDictionary **)v15, @"iccid", v10);
    sub_1000558F4(&v14);
    if (SHIBYTE(v13) < 0) {
      operator delete(v12[0]);
    }
    if (*(unsigned char *)(a2 + 24)) {
      int v11 = (uint64_t *)&kCFBooleanTrue;
    }
    else {
      int v11 = (uint64_t *)&kCFBooleanFalse;
    }
    sub_10012C97C(*(__CFDictionary **)v15, @"requireActiveStatus", *v11);
    (*(void (**)(void, const __CFString *, void, void, const CFStringRef, const CFStringRef))(*(void *)*a1 + 16))(*a1, @"LastInstallingPlan", *(void *)v15, kRemoteCellularPlanStorage, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    return sub_10005717C((const void **)v15);
  }
  else
  {
    char v7 = *(uint64_t (**)(void))(*(void *)*a1 + 16);
    return (const void **)v7();
  }
}

void sub_100F14D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a17);
  _Unwind_Resume(a1);
}

void sub_100F14DF0(void *a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  _DWORD v7[2] = sub_100F14F08;
  void v7[3] = &unk_101A6E868;
  v7[4] = a1;
  BOOL v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = a1[1], (uint64_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  uint64_t v6 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100F1B7E0;
  block[3] = &unk_101A6F098;
  void block[5] = v3;
  size_t v9 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v7;
  dispatch_async(v6, block);
  if (v9) {
    sub_10004D2C8(v9);
  }
  sub_10004D2C8(v5);
}

void sub_100F14F08(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  BOOL v2 = *(VinylInfo **)(v1 + 456);
  if (v2 == *(VinylInfo **)(v1 + 464)) {
    return;
  }
  uint64_t v29 = 0;
  long long v30 = 0uLL;
  memset(&v28, 0, sizeof(v28));
  VinylInfo::getActiveUserProfile((uint64_t *)&v28, v2);
  std::string::size_type v3 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  char v4 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  std::string::size_type size = v28.__r_.__value_.__l.__size_;
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v6 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v6 = v28.__r_.__value_.__l.__size_;
  }
  if (v6)
  {
    uint64_t v27 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(v1 + 504) + 128))(&v27);
    if (v27) {
      char v7 = sub_1000810B8;
    }
    else {
      char v7 = 0;
    }
    if (v7)
    {
      int v31 = 0;
      long long v32 = 0uLL;
      ctu::cf::assign();
      uint64_t v29 = v31;
      *(void *)&long long v30 = v32;
      *(void *)((char *)&v30 + 7) = *(void *)((char *)&v32 + 7);
      HIBYTE(v30) = HIBYTE(v32);
    }
    sub_1000558F4(&v27);
    std::string::size_type v3 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v28.__r_.__value_.__l.__size_;
    char v4 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
  }
  if (v4 < 0) {
    std::string::size_type v3 = size;
  }
  if (!v3)
  {
    size_t v8 = (const std::string *)(v1 + 672);
    if (*(char *)(v1 + 695) < 0)
    {
      if (!*(void *)(v1 + 680))
      {
LABEL_19:
        if (!*(unsigned char *)(v1 + 776)) {
          goto LABEL_22;
        }
        size_t v8 = (const std::string *)(v1 + 752);
      }
    }
    else if (!*(unsigned char *)(v1 + 695))
    {
      goto LABEL_19;
    }
    std::string::operator=(&v28, v8);
  }
LABEL_22:
  size_t v9 = sub_100046F68(v1 + 600, (void **)&v28.__r_.__value_.__l.__data_);
  if ((void **)(v1 + 608) == v9)
  {
    uint64_t v10 = 0;
LABEL_26:
    sub_100150AFC((uint64_t)v12, v1 + 272);
    if (v12[0] == 2) {
      uint64_t v11 = 2;
    }
    else {
      uint64_t v11 = v12[0] == 1;
    }
    if (v26 < 0) {
      operator delete(__p);
    }
    if (v24 < 0) {
      operator delete(v23);
    }
    if (v22 < 0) {
      operator delete(v21);
    }
    if (v20 < 0) {
      operator delete(v19);
    }
    if (v18 < 0) {
      operator delete(v17);
    }
    if (v16 < 0) {
      operator delete(v15);
    }
    if (v14 < 0) {
      operator delete(v13);
    }
    goto LABEL_43;
  }
  uint64_t v10 = *((unsigned __int8 *)v9 + 112);
  uint64_t v11 = *((unsigned __int8 *)v9 + 113);
  if (!*((unsigned char *)v9 + 113)) {
    goto LABEL_26;
  }
LABEL_43:
  (*(void (**)(void, uint64_t, void **, uint64_t, uint64_t))(**(void **)(v1 + 552) + 120))(*(void *)(v1 + 552), v10, &v29, 1, v11);
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29);
  }
}

void sub_100F15160(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  if (*(char *)(v1 - 57) < 0) {
    operator delete(*(void **)(v1 - 80));
  }
  _Unwind_Resume(exception_object);
}

void sub_100F151C0(uint64_t a1)
{
}

void sub_100F151C8(uint64_t a1@<X0>, NSObject **a2@<X8>)
{
  BOOL v2 = *(NSObject **)(a1 + 24);
  *a2 = v2;
  if (v2) {
    dispatch_retain(v2);
  }
}

void sub_100F151DC(uint64_t a1@<X0>, NSObject **a2@<X8>)
{
  BOOL v2 = *(NSObject **)(a1 - 24);
  *a2 = v2;
  if (v2) {
    dispatch_retain(v2);
  }
}

void sub_100F151F0(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 528);
  if (v5)
  {
    size_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 520);
      if (v11)
      {
        if ((*(unsigned int (**)(void))(*(void *)v11 + 56))(*(void *)(a1 + 520)))
        {
          sub_1000C26BC(a4, 0);
        }
        else
        {
          sub_100F110AC(a1, a3);
          sub_1000C6AC0((uint64_t)v12, a4);
          (*(void (**)(uint64_t, uint64_t, std::string *, void *))(*(void *)v11 + 80))(v11, a2, a3, v12);
          sub_1000C6B58(v12);
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_100F15314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000C6B58((uint64_t *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_100F15338(uint64_t a1, uint64_t a2, std::string *a3, uint64_t a4)
{
}

void sub_100F15340(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  sub_1000DFC90((uint64_t)&v8, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F154E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void sub_100F15524(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100F1552C(uint64_t a1, __int16 a2)
{
  __int16 v13 = a2;
  if ((_BYTE)a2) {
    BOOL v3 = (a2 & 0xFF00) != 0;
  }
  else {
    BOOL v3 = 0;
  }
  char v4 = (_OWORD *)(a1 + 584);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 592);
  *char v4 = 0u;
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*(unsigned char *)(a1 + 744))
  {
    long long __p = 0;
    long long v12 = 0uLL;
    uint64_t v10 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 504) + 128))(&v10);
    if (v10) {
      uint64_t v6 = sub_1000810B8;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      long long __p = *(void **)buf;
      *(void *)&long long v12 = *(void *)&buf[8];
      *(void *)((char *)&v12 + 7) = *(void *)&buf[15];
      HIBYTE(v12) = buf[23];
    }
    uint64_t v7 = *(void *)(a1 + 552);
    buf[0] = 0;
    (*(void (**)(uint64_t, uint64_t, void **, uint64_t, BOOL, void, uint8_t *))(*(void *)v7 + 208))(v7, 1, &__p, 2, v3, 0, buf);
    *(unsigned char *)(a1 + 744) = 0;
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = printers::asString();
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MM Completed: %s", buf, 0xCu);
    }
    sub_100F1574C(a1, (const std::string *)(a1 + 672), v3);
    sub_1000558F4(&v10);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p);
    }
  }
}

void sub_100F15700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F1574C(uint64_t a1, const std::string *a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 272) == 2)
  {
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 528);
    if (v6)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)(a1 + 520);
        if (v9) {
          (*(void (**)(uint64_t, uint64_t, const std::string *, uint64_t))(*(void *)v9 + 72))(v9, *(void *)(a1 + 456) + 16, a2, a3);
        }
        sub_10004D2C8(v8);
      }
    }
    (***(void (****)(std::string *__return_ptr))(a1 + 504))(&v44);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, (Registry *)v44.__r_.__value_.__l.__data_);
    long long v12 = ServiceMap;
    if (v13 < 0)
    {
      char v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&long long v55 = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&v55);
    if (v17)
    {
      uint64_t v19 = v17[3];
      char v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    char v18 = 0;
    char v20 = 1;
LABEL_15:
    if (v44.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)v44.__r_.__value_.__l.__size_);
    }
    if (!v19) {
      goto LABEL_60;
    }
    HIBYTE(v45[2]) = 22;
    long long v46 = 0u;
    *(_OWORD *)uint64_t v47 = 0u;
    long long v48 = 0u;
    memset(&v44, 0, sizeof(v44));
    strcpy((char *)v45, "com.apple.NanoSettings");
    LOBYTE(v46) = 1;
    std::string::operator=(&v44, a2);
    if (a3)
    {
      uint64_t v21 = kCBMessageLocalizationTable;
      (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v19 + 40))(__p, v19, kCBMessageLocalizationTable, @"CELLULAR_PLAN_SETUP_READY_FOR_USE_TITLE_WATCH", @"CELLULAR_PLAN_SETUP_READY_FOR_USE_TITLE_WATCH");
      *(void *)&long long v55 = *((void *)&v46 + 1);
      *((void **)&v46 + 1) = __p[0];
      __p[0] = 0;
      sub_1000558F4((const void **)&v55);
      sub_1000558F4((const void **)__p);
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v19 + 40))(__p, v19, v21, @"CELLULAR_PLAN_SETUP_READY_FOR_USE_MESSAGE_WATCH", @"CELLULAR_PLAN_SETUP_READY_FOR_USE_MESSAGE_WATCH");
      *(void **)&long long v55 = v47[0];
      v47[0] = __p[0];
      __p[0] = 0;
      sub_1000558F4((const void **)&v55);
      char v22 = __p;
    }
    else
    {
      uint64_t v23 = kCBMessageLocalizationTable;
      (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, const __CFString *))(*(void *)v19 + 40))(__p, v19, kCBMessageLocalizationTable, @"CELLULAR_PLAN_SETUP_FAILURE_TITLE_WATCH", @"CELLULAR_PLAN_SETUP_FAILURE_TITLE_WATCH");
      *(void *)&long long v55 = *((void *)&v46 + 1);
      *((void **)&v46 + 1) = __p[0];
      __p[0] = 0;
      sub_1000558F4((const void **)&v55);
      sub_1000558F4((const void **)__p);
      CFStringRef v43 = 0;
      (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v19 + 40))(&v43, v19, v23, @"CELLULAR_PLAN_SETUP_FAILURE_MESSAGE_WATCH_%@", @"CELLULAR_PLAN_SETUP_FAILURE_MESSAGE_WATCH_%@");
      CFStringRef v24 = v43;
      if (*(char *)(a1 + 399) < 0)
      {
        sub_10004FC84(__dst, *(void **)(a1 + 376), *(void *)(a1 + 384));
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)(a1 + 376);
        char v41 = *(void **)(a1 + 392);
      }
      if (SHIBYTE(v41) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)__dst;
        uint64_t v51 = v41;
      }
      uint64_t v49 = 0;
      if (SHIBYTE(v51) < 0)
      {
        sub_10004FC84(&v55, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v55 = *(_OWORD *)__p;
        char v56 = v51;
      }
      uint64_t v52 = 0;
      if (ctu::cf::convert_copy())
      {
        BOOL v25 = v49;
        uint64_t v49 = v52;
        uint64_t v53 = v25;
        sub_1000558F4(&v53);
      }
      if (SHIBYTE(v56) < 0) {
        operator delete((void *)v55);
      }
      uint64_t v42 = v49;
      uint64_t v49 = 0;
      sub_1000558F4(&v49);
      if (SHIBYTE(v51) < 0) {
        operator delete(__p[0]);
      }
      CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0, @"%@", v24, 0, v42);
      uint64_t v27 = v47[0];
      v47[0] = (void *)StringWithValidatedFormat;
      *(void *)&long long v55 = v27;
      sub_1000558F4((const void **)&v55);
      sub_1000558F4(&v42);
      if (SHIBYTE(v41) < 0) {
        operator delete(__dst[0]);
      }
      sub_1005DE3DC((uint64_t)&v55);
      v54[0] = off_101A6F1D8;
      v54[3] = v54;
      sub_100F10B5C(a1, v28, (uint64_t)&v55, (uint64_t)v54);
      sub_1000C752C(v54);
      if (v57 < 0) {
        operator delete(v56);
      }
      char v22 = (void **)&v43;
    }
    sub_1000558F4((const void **)v22);
    (***(void (****)(long long *__return_ptr))(a1 + 504))(&v55);
    long long v30 = (std::mutex *)Registry::getServiceMap(v29, (Registry *)v55);
    int v31 = v30;
    if (v32 < 0)
    {
      uint64_t v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v34 = 5381;
      do
      {
        uint64_t v32 = v34;
        unsigned int v35 = *v33++;
        uint64_t v34 = (33 * v34) ^ v35;
      }
      while (v35);
    }
    std::mutex::lock(v30);
    __p[0] = (void *)v32;
    int v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)__p);
    if (v36)
    {
      uint64_t v38 = v36[3];
      int v37 = (std::__shared_weak_count *)v36[4];
      if (v37)
      {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v31);
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v37);
        char v39 = 0;
LABEL_48:
        if (*((void *)&v55 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v55 + 1));
        }
        if (v38) {
          (*(void (**)(uint64_t, std::string *))(*(void *)v38 + 16))(v38, &v44);
        }
        if ((v39 & 1) == 0) {
          sub_10004D2C8(v37);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete(v47[1]);
        }
        sub_1000558F4((const void **)v47);
        sub_1000558F4((const void **)&v46 + 1);
        if (SHIBYTE(v45[2]) < 0) {
          operator delete(v45[0]);
        }
        if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v44.__r_.__value_.__l.__data_);
        }
LABEL_60:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        return;
      }
    }
    else
    {
      uint64_t v38 = 0;
    }
    std::mutex::unlock(v31);
    int v37 = 0;
    char v39 = 1;
    goto LABEL_48;
  }
}

void sub_100F15DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,const void *a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  sub_1000558F4(&a36);
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1000558F4(&a20);
  sub_100D11A70((uint64_t)&a21);
  if ((v43 & 1) == 0) {
    sub_10004D2C8(v42);
  }
  _Unwind_Resume(a1);
}

void sub_100F15EE0(uint64_t a1, __int16 a2)
{
}

const void **sub_100F15EEC(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CFDictionaryRef theDict = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)a2 + 144))(&v57, a2, 1, @"CellularPlanProvisioningSettings", 0);
  sub_10004EFE4(&theDict, &v57);
  sub_1000577C4(&v57);
  if (theDict) {
    BOOL v3 = sub_100080778;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3 && CFDictionaryContainsKey(theDict, @"ProvisioningStatusCheckIntervals"))
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"ProvisioningStatusCheckIntervals");
    CFArrayRef v5 = Value;
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 != CFArrayGetTypeID()) {
        CFArrayRef v5 = 0;
      }
    }
    v59.length = CFArrayGetCount(v5);
    v59.location = 0;
    CFArrayApplyFunction(v5, v59, (CFArrayApplierFunction)sub_100F1867C, a1);
  }
  uint64_t v7 = (char *)*a1;
  if (*a1 == a1[1])
  {
    uint64_t v9 = (char **)(a1 + 2);
    uint64_t v8 = (char *)a1[2];
    if (v7 >= v8)
    {
      unint64_t v11 = v8 - v7;
      unint64_t v12 = (v8 - v7) >> 2;
      if (v12 <= 1) {
        unint64_t v12 = 1;
      }
      if (v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      char v14 = sub_10004EF74((uint64_t)(a1 + 2), v13);
      uint64_t v15 = (void *)*a1;
      unsigned int v16 = (void *)a1[1];
      uint64_t v8 = (char *)&v14[v17];
      *char v14 = 60;
      uint64_t v10 = (char *)(v14 + 1);
      while (v16 != v15)
      {
        uint64_t v18 = *--v16;
        *--char v14 = v18;
      }
      *a1 = v14;
      a1[1] = v10;
      a1[2] = v8;
      if (v15)
      {
        operator delete(v15);
        uint64_t v8 = *v9;
      }
    }
    else
    {
      *(void *)uint64_t v7 = 60;
      uint64_t v10 = v7 + 8;
    }
    a1[1] = v10;
    if (v10 >= v8)
    {
      char v20 = (char *)*a1;
      uint64_t v21 = (uint64_t)&v10[-*a1] >> 3;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v23 = v8 - v20;
      if (v23 >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24)
      {
        BOOL v25 = (char *)sub_10004EF74((uint64_t)(a1 + 2), v24);
        char v20 = (char *)*a1;
        uint64_t v10 = (char *)a1[1];
      }
      else
      {
        BOOL v25 = 0;
      }
      char v26 = &v25[8 * v21];
      uint64_t v8 = &v25[8 * v24];
      *(void *)char v26 = 120;
      uint64_t v19 = v26 + 8;
      while (v10 != v20)
      {
        uint64_t v27 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v26 - 1) = v27;
        v26 -= 8;
      }
      *a1 = v26;
      a1[1] = v19;
      a1[2] = v8;
      if (v20)
      {
        operator delete(v20);
        uint64_t v8 = *v9;
      }
    }
    else
    {
      *(void *)uint64_t v10 = 120;
      uint64_t v19 = v10 + 8;
    }
    a1[1] = v19;
    if (v19 >= v8)
    {
      uint64_t v29 = (char *)*a1;
      uint64_t v30 = (uint64_t)&v19[-*a1] >> 3;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v32 = v8 - v29;
      if (v32 >> 2 > v31) {
        unint64_t v31 = v32 >> 2;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v31;
      }
      if (v33)
      {
        uint64_t v34 = (char *)sub_10004EF74((uint64_t)(a1 + 2), v33);
        uint64_t v29 = (char *)*a1;
        uint64_t v19 = (char *)a1[1];
      }
      else
      {
        uint64_t v34 = 0;
      }
      unsigned int v35 = &v34[8 * v30];
      uint64_t v8 = &v34[8 * v33];
      *(void *)unsigned int v35 = 300;
      uint64_t v28 = v35 + 8;
      while (v19 != v29)
      {
        uint64_t v36 = *((void *)v19 - 1);
        v19 -= 8;
        *((void *)v35 - 1) = v36;
        v35 -= 8;
      }
      *a1 = v35;
      a1[1] = v28;
      a1[2] = v8;
      if (v29)
      {
        operator delete(v29);
        uint64_t v8 = *v9;
      }
    }
    else
    {
      *(void *)uint64_t v19 = 300;
      uint64_t v28 = v19 + 8;
    }
    a1[1] = v28;
    if (v28 >= v8)
    {
      uint64_t v38 = (char *)*a1;
      uint64_t v39 = (uint64_t)&v28[-*a1] >> 3;
      unint64_t v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v41 = v8 - v38;
      if (v41 >> 2 > v40) {
        unint64_t v40 = v41 >> 2;
      }
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v40;
      }
      if (v42)
      {
        char v43 = (char *)sub_10004EF74((uint64_t)(a1 + 2), v42);
        uint64_t v38 = (char *)*a1;
        uint64_t v28 = (char *)a1[1];
      }
      else
      {
        char v43 = 0;
      }
      std::string v44 = &v43[8 * v39];
      uint64_t v8 = &v43[8 * v42];
      *(void *)std::string v44 = 900;
      int v37 = v44 + 8;
      while (v28 != v38)
      {
        uint64_t v45 = *((void *)v28 - 1);
        v28 -= 8;
        *((void *)v44 - 1) = v45;
        v44 -= 8;
      }
      *a1 = v44;
      a1[1] = v37;
      a1[2] = v8;
      if (v38)
      {
        operator delete(v38);
        uint64_t v8 = *v9;
      }
    }
    else
    {
      *(void *)uint64_t v28 = 900;
      int v37 = v28 + 8;
    }
    a1[1] = v37;
    if (v37 >= v8)
    {
      uint64_t v47 = (char *)*a1;
      uint64_t v48 = (uint64_t)&v37[-*a1] >> 3;
      unint64_t v49 = v48 + 1;
      if ((unint64_t)(v48 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v50 = v8 - v47;
      if (v50 >> 2 > v49) {
        unint64_t v49 = v50 >> 2;
      }
      if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v51 = v49;
      }
      if (v51)
      {
        uint64_t v52 = (char *)sub_10004EF74((uint64_t)(a1 + 2), v51);
        uint64_t v47 = (char *)*a1;
        int v37 = (char *)a1[1];
      }
      else
      {
        uint64_t v52 = 0;
      }
      uint64_t v53 = &v52[8 * v48];
      uint64_t v54 = &v52[8 * v51];
      *(void *)uint64_t v53 = 1800;
      long long v46 = v53 + 8;
      while (v37 != v47)
      {
        uint64_t v55 = *((void *)v37 - 1);
        v37 -= 8;
        *((void *)v53 - 1) = v55;
        v53 -= 8;
      }
      *a1 = v53;
      a1[1] = v46;
      a1[2] = v54;
      if (v47) {
        operator delete(v47);
      }
    }
    else
    {
      *(void *)int v37 = 1800;
      long long v46 = v37 + 8;
    }
    a1[1] = v46;
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100F1637C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  char v4 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100F163D4(uint64_t a1, uint64_t a2)
{
  char v4 = (const std::string *)(a2 + 16);
  CFArrayRef v5 = sub_100046F68(a1 + 600, (void **)(a2 + 16));
  if ((void **)(a1 + 608) != v5)
  {
    CFTypeID v6 = v5;
    uint64_t v45 = 0;
    long long v46 = 0;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 528);
    if (v7)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v7);
      long long v46 = v8;
      if (v8) {
        uint64_t v45 = *(void *)(a1 + 520);
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    sub_100F16A14(&v45, *(void *)(a1 + 456) + 16, a2, *((unsigned __int8 *)v6 + 113), *((unsigned __int8 *)v6 + 112));
    if (v8) {
      sub_10004D2C8(v8);
    }
    if (*((unsigned char *)v6 + 112) == 2)
    {
      int v9 = sub_100F11C04(a1, (uint64_t)(v6 + 7));
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (v9)
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a2 + 39) >= 0) {
            unint64_t v11 = v4;
          }
          else {
            unint64_t v11 = *(const std::string **)(a2 + 16);
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Enabling profile [Status Known] (%s)", buf, 0xCu);
        }
        *(unsigned char *)(a1 + 744) = 0;
        std::string::operator=((std::string *)(a1 + 696), v4);
        unint64_t v12 = *(std::__shared_weak_count **)(a1 + 576);
        v44[0] = *(void *)(a1 + 568);
        v44[1] = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100F0F92C(v44, @"RemotePlanSelectedKey", a1 + 696);
      }
      else
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Status active, but is not allowed for selection - profile mismatch (clearing)", buf, 2u);
        }
        if (*(char *)(a1 + 775) < 0)
        {
          **(unsigned char **)(a1 + 752) = 0;
          *(void *)(a1 + 760) = 0;
        }
        else
        {
          *(unsigned char *)(a1 + 752) = 0;
          *(unsigned char *)(a1 + 775) = 0;
        }
        unint64_t v12 = *(std::__shared_weak_count **)(a1 + 576);
        v43[0] = *(void *)(a1 + 568);
        v43[1] = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100F14AC4(v43, a1 + 752);
      }
      if (v12) {
        sub_10004D2C8(v12);
      }
      return;
    }
  }
  char v13 = *(unsigned char *)(a1 + 775);
  if (v13 >= 0) {
    uint64_t v14 = *(unsigned __int8 *)(a1 + 775);
  }
  else {
    uint64_t v14 = *(void *)(a1 + 760);
  }
  uint64_t v15 = *(unsigned __int8 *)(a2 + 39);
  int v16 = (char)v15;
  if ((v15 & 0x80u) != 0) {
    uint64_t v15 = *(void *)(a2 + 24);
  }
  if (v14 != v15)
  {
LABEL_43:
    uint64_t v22 = *(void *)(a1 + 584);
    if (v22)
    {
      *(unsigned char *)(a1 + 744) = 0;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 40))(v22, 256);
    }
    *(void *)unint64_t v42 = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      unint64_t v24 = *(__CFArray **)v42;
      *(void *)unint64_t v42 = Mutable;
      *(void *)long long buf = v24;
      sub_1000440D4((const void **)buf);
    }
    sub_1001C6B94(*(__CFArray **)v42, @"CarrierEntitlements");
    CFDictionaryRef theDict = 0;
    uint64_t v25 = *(void *)(a1 + 504);
    sub_100044D6C(&v40, (CFTypeRef *)v42);
    (*(void (**)(CFDictionaryRef *__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const std::string *, const void **))(*(void *)v25 + 152))(&theDict, v25, a2 + 96, a2 + 120, a2 + 144, a2 + 168, v4, &v40);
    sub_100044D00(&v40);
    if (theDict) {
      char v26 = sub_1000C06D0;
    }
    else {
      char v26 = 0;
    }
    if (v26)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CarrierEntitlements");
      CFDictionaryRef v28 = Value;
      if (Value)
      {
        CFTypeID v29 = CFGetTypeID(Value);
        if (v29 != CFDictionaryGetTypeID()) {
          CFDictionaryRef v28 = 0;
        }
      }
      if (CFDictionaryContainsKey(v28, @"SupportedEntitlementsStandaloneMode"))
      {
        uint64_t v30 = (int *)CFDictionaryGetValue(v28, @"SupportedEntitlementsStandaloneMode");
        unint64_t v31 = v30;
        *(_DWORD *)long long buf = 0;
        if (v30)
        {
          CFTypeID v32 = CFGetTypeID(v30);
          if (v32 == CFNumberGetTypeID())
          {
            ctu::cf::assign((ctu::cf *)buf, v31, v33);
            if ((*(_WORD *)buf & 0x800) != 0)
            {
              uint64_t v34 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(a2 + 39) >= 0) {
                  unsigned int v35 = v4;
                }
                else {
                  unsigned int v35 = *(const std::string **)(a2 + 16);
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v35;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Enabling profile [Entitlement] (%s)", buf, 0xCu);
              }
              *(unsigned char *)(a1 + 744) = 1;
              std::string::operator=((std::string *)(a1 + 696), v4);
              uint64_t v36 = *(std::__shared_weak_count **)(a1 + 576);
              v39[0] = *(void *)(a1 + 568);
              v39[1] = v36;
              if (v36) {
                atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_100F0F92C(v39, @"RemotePlanSelectedKey", a1 + 696);
              if (v36) {
                sub_10004D2C8(v36);
              }
            }
          }
        }
        goto LABEL_72;
      }
      int v37 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v38 = "#I Entitlement not supported";
        goto LABEL_71;
      }
    }
    else
    {
      int v37 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v38 = "#I Carrier entitlements not found";
LABEL_71:
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 2u);
      }
    }
LABEL_72:
    sub_10005717C((const void **)&theDict);
    sub_1000440D4((const void **)v42);
    return;
  }
  uint64_t v17 = (const void **)(a1 + 752);
  if (v16 >= 0) {
    uint64_t v18 = v4;
  }
  else {
    uint64_t v18 = (const std::string *)v4->__r_.__value_.__r.__words[0];
  }
  if ((*(unsigned char *)(a1 + 775) & 0x80) != 0)
  {
    if (memcmp(*v17, v18, *(void *)(a1 + 760))) {
      goto LABEL_43;
    }
  }
  else if (*(unsigned char *)(a1 + 775))
  {
    uint64_t v19 = (unsigned __int8 *)(a1 + 752);
    uint64_t v20 = *(unsigned __int8 *)(a1 + 775);
    while (*v19 == v18->__r_.__value_.__s.__data_[0])
    {
      ++v19;
      uint64_t v18 = (const std::string *)((char *)v18 + 1);
      if (!--v20) {
        goto LABEL_38;
      }
    }
    goto LABEL_43;
  }
LABEL_38:
  if (!*(unsigned char *)(a1 + 776)) {
    goto LABEL_43;
  }
  uint64_t v21 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    if (v13 < 0) {
      uint64_t v17 = (const void **)*v17;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Waiting for remote status: (%s)", buf, 0xCu);
  }
}

void sub_100F16990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, const void *);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10005717C((const void **)va);
  sub_1000440D4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100F16A14(void *a1, uint64_t a2, uint64_t a3, int __val, int a5)
{
  if (*a1)
  {
    std::to_string(&v24, __val);
    int v9 = std::string::insert(&v24, 0, "v:1_t:", 6uLL);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    unint64_t v11 = std::string::append(&v25, "_s:", 3uLL);
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, a5);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v15 = std::string::append(&v26, (const std::string::value_type *)p_p, size);
    long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    int64_t v28 = v15->__r_.__value_.__r.__words[2];
    long long v27 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    uint64_t v17 = *(unsigned __int8 *)(a3 + 63);
    if ((v17 & 0x80u) == 0) {
      uint64_t v18 = *(unsigned __int8 *)(a3 + 63);
    }
    else {
      uint64_t v18 = *(void *)(a3 + 48);
    }
    uint64_t v19 = HIBYTE(v28);
    char v20 = HIBYTE(v28);
    if (v28 < 0) {
      uint64_t v19 = *((void *)&v27 + 1);
    }
    if (v18 == v19)
    {
      uint64_t v21 = (const void **)(a3 + 40);
      if (v28 >= 0) {
        uint64_t v22 = (unsigned __int8 *)&v27;
      }
      else {
        uint64_t v22 = (unsigned __int8 *)v27;
      }
      if ((v17 & 0x80) != 0)
      {
        if (!memcmp(*v21, v22, *(void *)(a3 + 48))) {
          goto LABEL_32;
        }
      }
      else
      {
        if (!*(unsigned char *)(a3 + 63)) {
          goto LABEL_32;
        }
        while (*(unsigned __int8 *)v21 == *v22)
        {
          uint64_t v21 = (const void **)((char *)v21 + 1);
          ++v22;
          if (!--v17) {
            goto LABEL_32;
          }
        }
      }
    }
    (*(void (**)(void, uint64_t, uint64_t, long long *))(*(void *)*a1 + 24))(*a1, a2, a3 + 16, &v27);
    char v20 = HIBYTE(v28);
LABEL_32:
    if (v20 < 0) {
      operator delete((void *)v27);
    }
  }
}

void sub_100F16C10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 57) < 0) {
    operator delete(*(void **)(v33 - 80));
  }
  _Unwind_Resume(exception_object);
}

void sub_100F16C88(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 536) + 112))(*(void *)(a1 + 536), a2, 1);
  sub_100F13CCC(a1, a2);
  char v4 = *(std::__shared_weak_count **)(a1 + 528);
  if (v4)
  {
    CFArrayRef v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      CFTypeID v6 = v5;
      uint64_t v7 = *(void *)(a1 + 520);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 64))(v7, *(void *)(a1 + 456) + 16, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100F16D5C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100F16D70(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (!*(void *)(a1 + 832)) {
    return;
  }
  CFArrayRef v5 = (unsigned __int8 **)(a1 + 784);
  uint64_t v6 = a2[23];
  if ((v6 & 0x80u) == 0) {
    uint64_t v7 = a2[23];
  }
  else {
    uint64_t v7 = *((void *)a2 + 1);
  }
  uint64_t v8 = *(unsigned __int8 *)(a1 + 807);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a1 + 792);
  }
  if (v7 != v8) {
    goto LABEL_16;
  }
  long long v10 = *v5;
  if (v9 >= 0) {
    long long v10 = (unsigned __int8 *)(a1 + 784);
  }
  if ((v6 & 0x80) == 0)
  {
    if (a2[23])
    {
      while (*a2 == *v10)
      {
        ++a2;
        ++v10;
        if (!--v6) {
          goto LABEL_20;
        }
      }
      goto LABEL_16;
    }
LABEL_20:
    long long v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      char v32 = *(unsigned char *)(a3 + 192);
      uint64_t v14 = printers::asString((printers *)&v32, v13);
      *(_DWORD *)long long buf = 136315138;
      uint64_t v34 = (unsigned __int8 **)v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Invoking fetch subscription callback, details valid:(%s)", buf, 0xCu);
    }
    sub_100CC26CC(v16, a3);
    uint64_t v15 = *(void *)(a1 + 832);
    if (!v15) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v15 + 48))(v15, v16);
    if (v31)
    {
      if (v30 < 0) {
        operator delete(__p);
      }
      if (v28 < 0) {
        operator delete(v27);
      }
      if (v26 < 0) {
        operator delete(v25);
      }
      if (v24 < 0) {
        operator delete(v23);
      }
      if (v22 < 0) {
        operator delete(v21);
      }
      if (v20 < 0) {
        operator delete(v19);
      }
      if (v18 < 0) {
        operator delete(v17);
      }
    }
    sub_100F1BC5C((void *)(a1 + 808));
    if (*(char *)(a1 + 807) < 0)
    {
      **(unsigned char **)(a1 + 784) = 0;
      *(void *)(a1 + 792) = 0;
    }
    else
    {
      *(unsigned char *)(a1 + 784) = 0;
      *(unsigned char *)(a1 + 807) = 0;
    }
    return;
  }
  if (!memcmp(*(const void **)a2, v10, *((void *)a2 + 1))) {
    goto LABEL_20;
  }
LABEL_16:
  unint64_t v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (v9 < 0) {
      CFArrayRef v5 = (unsigned __int8 **)*v5;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v34 = v5;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I PSAS update for a different profile, expected (%s)", buf, 0xCu);
  }
}

void sub_100F16FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_100F17018(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3)
  {
LABEL_31:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 232) = 0;
  }
  else
  {
    uint64_t v7 = a2;
    while (1)
    {
      if (*(unsigned char *)(v7 + 80))
      {
        uint64_t v8 = *(void *)(v7 + 56);
        uint64_t v9 = *(void *)(v7 + 64);
        if (*(char *)(a4 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)a4;
          uint64_t v24 = *(void *)(a4 + 16);
        }
        char v10 = HIBYTE(v24);
        if (v8 != v9)
        {
          if (v24 >= 0) {
            unint64_t v11 = (void *)HIBYTE(v24);
          }
          else {
            unint64_t v11 = __p[1];
          }
          if (v24 >= 0) {
            long long v12 = __p;
          }
          else {
            long long v12 = (void **)__p[0];
          }
          do
          {
            uint64_t v13 = *(unsigned __int8 *)(v8 + 39);
            if ((v13 & 0x80u) == 0) {
              uint64_t v14 = (void *)*(unsigned __int8 *)(v8 + 39);
            }
            else {
              uint64_t v14 = *(void **)(v8 + 24);
            }
            if (v14 == v11)
            {
              if ((v13 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v8 + 16), v12, *(void *)(v8 + 24))) {
                  goto LABEL_27;
                }
              }
              else
              {
                if (!*(unsigned char *)(v8 + 39)) {
                  goto LABEL_27;
                }
                uint64_t v15 = 0;
                while (*(unsigned __int8 *)(v8 + v15 + 16) == *((unsigned __int8 *)v12 + v15))
                {
                  if (v13 == ++v15) {
                    goto LABEL_27;
                  }
                }
              }
            }
            v8 += 216;
          }
          while (v8 != v9);
          uint64_t v8 = v9;
        }
LABEL_27:
        if (v10 < 0) {
          operator delete(__p[0]);
        }
        if (v8 != *(void *)(v7 + 64)) {
          break;
        }
      }
      v7 += 88;
      if (v7 == a3) {
        goto LABEL_31;
      }
    }
    long long v25 = *(_OWORD *)(v7 + 16);
    long long v16 = (long long *)sub_1000C5AB4((uint64_t)&v26, v8);
    long long v17 = *v16;
    long long v18 = v27;
    *(_OWORD *)a1 = v25;
    *(_OWORD *)(a1 + 16) = v17;
    *(void *)(a1 + 48) = v28;
    *(void *)(a1 + 72) = v30;
    *(void *)(a1 + 96) = v32;
    *(_DWORD *)(a1 + 104) = v33;
    uint64_t v19 = v37;
    *(void *)(a1 + 128) = v35;
    *(void *)(a1 + 152) = v19;
    uint64_t v20 = v41;
    *(void *)(a1 + 176) = v39;
    *(_OWORD *)(a1 + 32) = v18;
    long long v27 = 0uLL;
    *(_OWORD *)(a1 + 56) = v29;
    uint64_t v28 = 0;
    long long v29 = 0uLL;
    uint64_t v30 = 0;
    *(_OWORD *)(a1 + 80) = v31;
    long long v31 = 0uLL;
    *(_OWORD *)(a1 + 112) = v34;
    uint64_t v32 = 0;
    long long v34 = 0uLL;
    *(_OWORD *)(a1 + 136) = v36;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    long long v36 = 0uLL;
    *(_OWORD *)(a1 + 160) = v38;
    long long v38 = 0uLL;
    long long v21 = v40;
    *(void *)(a1 + 200) = v20;
    *(_OWORD *)(a1 + 184) = v21;
    uint64_t v41 = 0;
    uint64_t v39 = 0;
    long long v40 = 0uLL;
    long long v22 = v42;
    *(void *)(a1 + 224) = v43;
    *(_OWORD *)(a1 + 208) = v22;
    long long v42 = 0uLL;
    uint64_t v43 = 0;
    *(unsigned char *)(a1 + 232) = 1;
    sub_1000C584C((uint64_t)v16);
  }
}

uint64_t sub_100F17288(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_100F172D8(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  void (***v11)(Registry **__return_ptr);
  std::__shared_weak_count *v12;
  char v13;
  long long v14;
  char v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  long long *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t *v24;
  std::mutex *ServiceMap;
  std::mutex *v26;
  uint64_t v27;
  unsigned __int8 *v28;
  uint64_t v29;
  unsigned int v30;
  void *v31;
  std::__shared_weak_count *v32;
  uint64_t v33;
  char v34;
  uint64_t (*v35)(uint64_t);
  BOOL *Value;
  BOOL *v37;
  CFTypeID v38;
  CFBooleanRef v39;
  NSObject *v40;
  void *v41;
  uint64_t v42;
  unint64_t v43;
  void **v44;
  void (***v45)(Registry **__return_ptr);
  std::__shared_weak_count *v46;
  void (***v47)(CFStringRef *__return_ptr, void, void **);
  std::__shared_weak_count *v48;
  uint64_t v49;
  unint64_t v50;
  const std::string *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  unsigned __int8 *v57;
  uint64_t v58;
  uint64_t v59;
  NSObject *v60;
  long long *v61;
  unsigned char v62[8];
  void *v63;
  char v64;
  void *v65;
  char v66;
  void *v67;
  char v68;
  void *v69;
  char v70;
  void *v71;
  char v72;
  void *v73;
  char v74;
  void *v75;
  char v76;
  char v77;
  void *__dst[2];
  uint64_t v79;
  char v80;
  char v81;
  char v82;
  char v83;
  const void *v84;
  CFDictionaryRef theDict;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  char v89;
  char v90;
  char v91;
  char v92;
  void buf[4];
  long long v94;
  long long v95;
  long long v96;
  long long v97;
  long long v98;
  long long v99;
  long long v100;
  long long v101;
  long long v102;
  long long v103;
  uint64_t v104;
  unsigned char v105[24];
  uint64_t v106;

  uint64_t v4 = *(void *)(a1 + 32);
  if (!a3 || (uint64_t v5 = *a2) == 0)
  {
    uint64_t v23 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Not successful / No response failure", (uint8_t *)buf, 2u);
    }
    uint64_t v91 = 0;
    long long v92 = 0;
    sub_100F17288(*(void *)(a1 + 64), 0);
    return;
  }
  if (*(_DWORD *)v5 != 6000)
  {
    long long v89 = 0;
    long long v90 = 0;
    sub_100F17288(*(void *)(a1 + 64), 0);
    return;
  }
  long long v88 = 0;
  uint64_t v87 = 0;
  char v86 = 0;
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6 && *(unsigned char *)(v6 + 120))
  {
    uint64_t v7 = *(void *)(v6 + 96);
    uint64_t v8 = *(void *)(v6 + 104);
    if (v7 != v8)
    {
      while (1)
      {
        if (!*(unsigned char *)(v7 + 88))
        {
          uint64_t v9 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "No iccid, skipping", (uint8_t *)buf, 2u);
          }
          goto LABEL_67;
        }
        long long v102 = 0u;
        long long v103 = 0u;
        long long v100 = 0u;
        char v101 = 0u;
        uint64_t v98 = 0u;
        std::string v99 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        long long v94 = 0u;
        long long v95 = 0u;
        memset(buf, 0, sizeof(buf));
        BYTE9(v103) = 1;
        if (*(unsigned char *)(v7 + 24))
        {
          std::string::operator=((std::string *)&buf[1], (const std::string *)v7);
        }
        else
        {
          uint64_t v10 = *(void *)(v4 + 456);
          if (v10 == *(void *)(v4 + 464))
          {
            long long v22 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v105 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Missing Vinyl Info - skipping?", v105, 2u);
            }
            goto LABEL_53;
          }
          ctu::hex((uint64_t *)v105, (ctu *)(v10 + 16), (const void *)0x10, a3);
          if (SHIBYTE(buf[3]) < 0) {
            operator delete((void *)buf[1]);
          }
          *(_OWORD *)&buf[1] = *(_OWORD *)v105;
          buf[3] = *(void *)&v105[16];
        }
        unint64_t v11 = *(void (****)(Registry **__return_ptr))(v4 + 504);
        long long v12 = *(std::__shared_weak_count **)(v4 + 512);
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        buf[0] = sub_100F12924(v11);
        if (v12) {
          sub_10004D2C8(v12);
        }
        if (!*(unsigned char *)(v7 + 88)) {
          sub_10016C840();
        }
        std::string::operator=((std::string *)&v94, (const std::string *)(v7 + 64));
        if (*(unsigned char *)(v7 + 132))
        {
          if (*(_DWORD *)(v7 + 128) == 1) {
            uint64_t v13 = 1;
          }
          else {
            uint64_t v13 = 2;
          }
          BYTE9(v95) = v13;
        }
        if (*(unsigned char *)(v7 + 120))
        {
          if (*(char *)(v7 + 119) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v7 + 96), *(void *)(v7 + 104));
          }
          else
          {
            uint64_t v14 = *(_OWORD *)(v7 + 96);
            uint64_t v79 = *(void *)(v7 + 112);
            *(_OWORD *)long long __dst = v14;
          }
          BYTE8(v95) = sub_10109A710((unsigned __int16 *)__dst);
          if (SHIBYTE(v79) < 0) {
            operator delete(__dst[0]);
          }
        }
        if (*(unsigned char *)(v7 + 224))
        {
          std::string::operator=((std::string *)((char *)&v100 + 8), (const std::string *)(v7 + 200));
          if (*(unsigned char *)(v7 + 256)) {
            std::string::operator=((std::string *)&v102, (const std::string *)(v7 + 232));
          }
        }
        if (*(unsigned char *)(v7 + 160)) {
          std::string::operator=((std::string *)&v96, (const std::string *)(v7 + 136));
        }
        if (*(unsigned char *)(v7 + 132))
        {
          if (*(_DWORD *)(v7 + 128) == 1) {
            uint64_t v15 = 1;
          }
          else {
            uint64_t v15 = 2;
          }
          BYTE9(v95) = v15;
        }
        if (sub_100F11C04(v4, (uint64_t)buf))
        {
          long long v16 = v87;
          if (v87 >= v88)
          {
            long long v17 = sub_1003DBC84(&v86, (uint64_t)buf);
          }
          else
          {
            sub_10023FB90(v87, (uint64_t)buf);
            long long v17 = v16 + 192;
          }
          uint64_t v87 = v17;
        }
        else
        {
          long long v18 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
          {
            uint64_t v19 = &v94;
            if (SBYTE7(v95) < 0) {
              uint64_t v19 = (long long *)v94;
            }
            size_t v61 = v19;
            uint64_t v20 = asString();
            long long v21 = asString();
            *(_DWORD *)long long v105 = 136315650;
            *(void *)&v105[4] = v61;
            *(_WORD *)&v105[12] = 2080;
            *(void *)&v105[14] = v20;
            *(_WORD *)&v105[22] = 2080;
            long long v106 = v21;
            _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "Local GSS response attempting to disable (%s) with %s-%s", v105, 0x20u);
          }
        }
LABEL_53:
        if (SBYTE7(v103) < 0) {
          operator delete((void *)v102);
        }
        if (SHIBYTE(v101) < 0) {
          operator delete(*((void **)&v100 + 1));
        }
        if (SBYTE7(v100) < 0) {
          operator delete((void *)v99);
        }
        if (SHIBYTE(v98) < 0) {
          operator delete(*((void **)&v97 + 1));
        }
        if (SBYTE7(v97) < 0) {
          operator delete((void *)v96);
        }
        if (SBYTE7(v95) < 0) {
          operator delete((void *)v94);
        }
        if (SHIBYTE(buf[3]) < 0) {
          operator delete((void *)buf[1]);
        }
LABEL_67:
        v7 += 264;
        if (v7 == v8) {
          goto LABEL_114;
        }
      }
    }
    goto LABEL_114;
  }
  CFDictionaryRef theDict = 0;
  (***(void (****)(void *__return_ptr))(v4 + 504))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24, (Registry *)buf[0]);
  uint64_t v26 = ServiceMap;
  if (v27 < 0)
  {
    uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
    long long v29 = 5381;
    do
    {
      long long v27 = v29;
      uint64_t v30 = *v28++;
      long long v29 = (33 * v29) ^ v30;
    }
    while (v30);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long v105 = v27;
  long long v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)v105);
  if (v31)
  {
    int v33 = v31[3];
    uint64_t v32 = (std::__shared_weak_count *)v31[4];
    if (v32)
    {
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v26);
      atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v32);
      long long v34 = 0;
      goto LABEL_81;
    }
  }
  else
  {
    int v33 = 0;
  }
  std::mutex::unlock(v26);
  uint64_t v32 = 0;
  long long v34 = 1;
LABEL_81:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void))(*(void *)v33
                                                                                                  + 144))(&v84, v33, 1, @"CellularPlanProvisioningSettings", 0);
  sub_10004EFE4(&theDict, &v84);
  sub_1000577C4(&v84);
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  if (buf[1]) {
    sub_10004D2C8((std::__shared_weak_count *)buf[1]);
  }
  if (theDict) {
    uint64_t v35 = sub_100080778;
  }
  else {
    uint64_t v35 = 0;
  }
  if (!v35) {
    goto LABEL_177;
  }
  CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"AllowSelectionWithoutActiveSubStatusInStandaloneMode");
  uint64_t v37 = Value;
  v105[0] = 0;
  if (!Value) {
    goto LABEL_177;
  }
  long long v38 = CFGetTypeID(Value);
  if (v38 == CFBooleanGetTypeID()) {
    ctu::cf::assign((ctu::cf *)v105, v37, v39);
  }
  if (!v105[0])
  {
LABEL_177:
    std::string::size_type v80 = 0;
    uint64_t v81 = 0;
    sub_100F17288(*(void *)(a1 + 64), 0);
LABEL_181:
    sub_100057D78((const void **)&theDict);
    goto LABEL_182;
  }
  long long v40 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v41 = (void *)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      uint64_t v41 = (void *)*v41;
    }
    LODWORD(buf[0]) = 136315138;
    *(void *)((char *)buf + 4) = v41;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Valid empty subscription - (%s) is active", (uint8_t *)buf, 0xCu);
  }
  if (*(void *)(v4 + 456) == *(void *)(v4 + 464))
  {
    uint64_t v60 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Missing Vinyl info", (uint8_t *)buf, 2u);
    }
    long long v82 = 0;
    unint64_t v83 = 0;
    sub_100F17288(*(void *)(a1 + 64), 0);
    goto LABEL_181;
  }
  long long v42 = sub_100F180D0(&v86);
  ctu::hex(buf, (ctu *)(*(void *)(v4 + 456) + 16), (const void *)0x10, v43);
  std::string v44 = (void **)(v42 + 8);
  if (*(char *)(v42 + 31) < 0) {
    operator delete(*v44);
  }
  *(_OWORD *)std::string v44 = *(_OWORD *)buf;
  *(void *)(v42 + 24) = buf[2];
  uint64_t v45 = *(void (****)(Registry **__return_ptr))(v4 + 504);
  long long v46 = *(std::__shared_weak_count **)(v4 + 512);
  if (v46) {
    atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(double *)long long v42 = sub_100F12924(v45);
  if (v46) {
    sub_10004D2C8(v46);
  }
  std::string::operator=((std::string *)(v42 + 32), (const std::string *)(a1 + 72));
  *(_WORD *)(v42 + 56) = 514;
  buf[1] = 0;
  buf[0] = 0;
  (***(void (****)(unsigned char *__return_ptr))(v4 + 504))(v105);
  sub_10034FCA4(*(Registry **)v105, buf);
  if (*(void *)&v105[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v105[8]);
  }
  uint64_t v47 = (void (***)(CFStringRef *__return_ptr, void, void **))buf[0];
  if (buf[0])
  {
    uint64_t v48 = (std::__shared_weak_count *)buf[1];
    if (buf[1]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(buf[1] + 8), 1uLL, memory_order_relaxed);
    }
    sub_100F18210(v47, v42);
    if (v48) {
      sub_10004D2C8(v48);
    }
  }
  if (buf[1]) {
    sub_10004D2C8((std::__shared_weak_count *)buf[1]);
  }
  sub_100057D78((const void **)&theDict);
LABEL_114:
  long long v104 = 0;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  char v101 = 0u;
  uint64_t v98 = 0u;
  std::string v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  memset(buf, 0, sizeof(buf));
  unint64_t v49 = v86;
  uint64_t v50 = v87;
  if (v86 == v87) {
    goto LABEL_147;
  }
  do
  {
    if (*(char *)(v49 + 159) < 0)
    {
      if (*(void *)(v49 + 144)) {
        goto LABEL_122;
      }
    }
    else if (*(unsigned char *)(v49 + 159))
    {
      goto LABEL_122;
    }
    unint64_t v51 = *(const std::string **)(v5 + 8);
    if (v51[1].__r_.__value_.__s.__data_[0])
    {
      std::string::operator=((std::string *)(v49 + 136), v51);
      uint64_t v52 = *(void *)(v5 + 8);
      if (*(unsigned char *)(v52 + 56)) {
        std::string::operator=((std::string *)(v49 + 160), (const std::string *)(v52 + 32));
      }
    }
LABEL_122:
    uint64_t v53 = *(unsigned __int8 *)(v49 + 55);
    if ((v53 & 0x80u) == 0) {
      uint64_t v54 = *(unsigned __int8 *)(v49 + 55);
    }
    else {
      uint64_t v54 = *(void *)(v49 + 40);
    }
    uint64_t v55 = *(unsigned __int8 *)(a1 + 95);
    char v56 = (char)v55;
    if ((v55 & 0x80u) != 0) {
      uint64_t v55 = *(void *)(a1 + 80);
    }
    if (v54 == v55)
    {
      if (v56 >= 0) {
        char v57 = (unsigned __int8 *)(a1 + 72);
      }
      else {
        char v57 = *(unsigned __int8 **)(a1 + 72);
      }
      if ((v53 & 0x80) != 0)
      {
        if (memcmp(*(const void **)(v49 + 32), v57, *(void *)(v49 + 40))) {
          goto LABEL_144;
        }
LABEL_138:
        sub_100CAE99C((uint64_t)buf, v49);
        if (*(void *)(v4 + 584))
        {
          CFRange v59 = HIBYTE(v101);
          if (v101 < 0) {
            CFRange v59 = v101;
          }
          if (!v59 && sub_100F12AA4(v4, (uint64_t)&v94))
          {
            sub_100F1BC5C((void *)(v4 + 808));
            std::string::operator=((std::string *)(v4 + 784), (const std::string *)&v94);
          }
        }
        goto LABEL_144;
      }
      if (!*(unsigned char *)(v49 + 55)) {
        goto LABEL_138;
      }
      uint64_t v58 = 0;
      while (*(unsigned __int8 *)(v49 + v58 + 32) == v57[v58])
      {
        if (v53 == ++v58) {
          goto LABEL_138;
        }
      }
    }
LABEL_144:
    v49 += 192;
  }
  while (v49 != v50);
  if (v86 != v87) {
    sub_100F16C88(v4, &v86);
  }
LABEL_147:
  sub_100CC26CC(v62, (uint64_t)buf);
  sub_100F17288(*(void *)(a1 + 64), 1);
  if (v77)
  {
    if (v76 < 0) {
      operator delete(v75);
    }
    if (v74 < 0) {
      operator delete(v73);
    }
    if (v72 < 0) {
      operator delete(v71);
    }
    if (v70 < 0) {
      operator delete(v69);
    }
    if (v68 < 0) {
      operator delete(v67);
    }
    if (v66 < 0) {
      operator delete(v65);
    }
    if (v64 < 0) {
      operator delete(v63);
    }
  }
  if ((_BYTE)v104)
  {
    if (SBYTE7(v103) < 0) {
      operator delete((void *)v102);
    }
    if (SHIBYTE(v101) < 0) {
      operator delete(*((void **)&v100 + 1));
    }
    if (SBYTE7(v100) < 0) {
      operator delete((void *)v99);
    }
    if (SHIBYTE(v98) < 0) {
      operator delete(*((void **)&v97 + 1));
    }
    if (SBYTE7(v97) < 0) {
      operator delete((void *)v96);
    }
    if (SBYTE7(v95) < 0) {
      operator delete((void *)v94);
    }
    if (SHIBYTE(buf[3]) < 0) {
      operator delete((void *)buf[1]);
    }
  }
LABEL_182:
  buf[0] = &v86;
  sub_10023FDC8((void ***)buf);
}

void sub_100F17F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (LOBYTE(STACK[0x2B0])) {
    sub_1000C62D8((uint64_t)&a71);
  }
  sub_100057D78((const void **)&STACK[0x2C0]);
  STACK[0x470] = (unint64_t)&STACK[0x2C8];
  sub_10023FDC8((void ***)&STACK[0x470]);
  _Unwind_Resume(a1);
}

uint64_t sub_100F180D0(uint64_t *a1)
{
  unint64_t v4 = a1[2];
  uint64_t v2 = (uint64_t)(a1 + 2);
  unint64_t v3 = v4;
  unint64_t v5 = *(void *)(v2 - 8);
  if (v5 >= v4)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 6);
    unint64_t v8 = v7 + 1;
    if (v7 + 1 > 0x155555555555555) {
      sub_10006A748();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v3 - *a1) >> 6);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x155555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    void v15[4] = v2;
    unint64_t v11 = (char *)sub_10034036C(v2, v10);
    long long v12 = &v11[192 * v7];
    v15[0] = v11;
    v15[1] = v12;
    v15[3] = &v11[192 * v13];
    *(_OWORD *)long long v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 6) = 0u;
    *((_OWORD *)v12 + 7) = 0u;
    *((_OWORD *)v12 + 8) = 0u;
    *((_OWORD *)v12 + 9) = 0u;
    *((_OWORD *)v12 + 10) = 0u;
    *((_OWORD *)v12 + 11) = 0u;
    v12[185] = 1;
    int v15[2] = v12 + 192;
    sub_1003DBD8C(a1, v15);
    uint64_t v6 = a1[1];
    sub_1003DBEF8((uint64_t)v15);
  }
  else
  {
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 176) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)unint64_t v5 = 0u;
    *(_OWORD *)(v5 + 16) = 0u;
    *(unsigned char *)(v5 + 185) = 1;
    uint64_t v6 = v5 + 192;
    a1[1] = v5 + 192;
  }
  a1[1] = v6;
  return v6 - 192;
}

void sub_100F181FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003DBEF8((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_100F18210(void (***a1)(CFStringRef *__return_ptr, void, void **), uint64_t a2)
{
  CFDictionaryRef theDict = 0;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(__p, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 32);
    uint64_t v28 = *(void *)(a2 + 48);
  }
  (**a1)(&v21, a1, __p);
  (*((void (**)(uint64_t *__return_ptr))v21->isa + 5))(&v24);
  CFDictionaryRef v26 = theDict;
  CFDictionaryRef theDict = (CFDictionaryRef)v25;
  *(void *)&long long v25 = 0;
  sub_100057D78((const void **)&v26);
  int v4 = BYTE8(v25);
  sub_100057D78((const void **)&v25);
  if (v22) {
    sub_10004D2C8(v22);
  }
  if (SHIBYTE(v28) < 0)
  {
    operator delete(__p[0]);
    if (!v4) {
      return sub_100057D78((const void **)&theDict);
    }
  }
  else if (!v4)
  {
    return sub_100057D78((const void **)&theDict);
  }
  if (theDict) {
    unint64_t v5 = sub_100080778;
  }
  else {
    unint64_t v5 = 0;
  }
  if (v5)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, kCTProvisioningURL);
    CFDictionaryRef v7 = Value;
    if (Value)
    {
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFDictionaryGetTypeID())
      {
        CFDictionaryGetValue(v7, kCTWebSheetURL);
        uint64_t v24 = 0;
        long long v25 = 0uLL;
        ctu::cf::assign();
        uint64_t v9 = v24;
        __p[0] = (void *)v25;
        *(void **)((char *)__p + 7) = *(void **)((char *)&v25 + 7);
        uint64_t v10 = HIBYTE(v25);
        int v11 = SHIBYTE(v25);
        if (*(char *)(a2 + 159) < 0) {
          operator delete(*(void **)(a2 + 136));
        }
        long long v12 = __p[0];
        *(void *)(a2 + 136) = v9;
        *(void *)(a2 + 144) = v12;
        *(void **)(a2 + 151) = *(void **)((char *)__p + 7);
        *(unsigned char *)(a2 + 159) = v11;
        uint64_t v13 = *(void *)(a2 + 144);
        if (v11 >= 0) {
          uint64_t v13 = v10;
        }
        if (v13)
        {
          CFDataRef v14 = (const __CFData *)CFDictionaryGetValue(v7, kCTWebSheetPostData);
          CFDataRef v15 = v14;
          if (v14)
          {
            CFTypeID v16 = CFGetTypeID(v14);
            if (v16 == CFDataGetTypeID())
            {
              CFStringRef v21 = CFStringCreateFromExternalRepresentation(0, v15, 0x600u);
              uint64_t v24 = 0;
              long long v25 = 0uLL;
              ctu::cf::assign();
              uint64_t v17 = v24;
              __p[0] = (void *)v25;
              *(void **)((char *)__p + 7) = *(void **)((char *)&v25 + 7);
              char v18 = HIBYTE(v25);
              if (*(char *)(a2 + 183) < 0) {
                operator delete(*(void **)(a2 + 160));
              }
              uint64_t v19 = __p[0];
              *(void *)(a2 + 160) = v17;
              *(void *)(a2 + 168) = v19;
              *(void **)(a2 + 175) = *(void **)((char *)__p + 7);
              *(unsigned char *)(a2 + 183) = v18;
              sub_1000558F4((const void **)&v21);
            }
          }
          *(unsigned char *)(a2 + 184) = 1;
        }
      }
    }
  }
  return sub_100057D78((const void **)&theDict);
}

void sub_100F184D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  sub_100057D78(&a12);
  _Unwind_Resume(a1);
}

unsigned char *sub_100F18554(uint64_t a1, uint64_t a2)
{
  sub_100F1BCE4(a1 + 40, a2 + 40);
  if (*(char *)(a2 + 95) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 72), *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v4;
  }
  uint64_t v5 = *(void *)(a2 + 96);
  *(void *)(a1 + 101) = *(void *)(a2 + 101);
  *(void *)(a1 + 96) = v5;
  BOOL result = (unsigned char *)(a1 + 112);
  if (*(char *)(a2 + 135) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  long long v7 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)BOOL result = v7;
  return result;
}

void sub_100F185FC(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 95) < 0) {
    operator delete(*v3);
  }
  sub_100F1B5FC(v1);
  _Unwind_Resume(a1);
}

void *sub_100F18628(uint64_t a1)
{
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }

  return sub_100F1B5FC((void *)(a1 + 40));
}

void sub_100F1867C(unsigned int *cf, uint64_t a2)
{
  unint64_t v3 = cf;
  unsigned int v18 = 0;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v18, v3, v5);
      unint64_t v3 = (unsigned int *)v18;
    }
    else
    {
      unint64_t v3 = 0;
    }
  }
  unint64_t v6 = *(void *)(a2 + 16);
  long long v7 = *(void **)(a2 + 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = *(void **)a2;
    uint64_t v10 = ((uint64_t)v7 - *(void *)a2) >> 3;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 61) {
      sub_10006A748();
    }
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      CFDataRef v14 = (char *)sub_10004EF74(a2 + 16, v13);
      uint64_t v9 = *(void **)a2;
      long long v7 = *(void **)(a2 + 8);
    }
    else
    {
      CFDataRef v14 = 0;
    }
    CFDataRef v15 = &v14[8 * v10];
    CFTypeID v16 = &v14[8 * v13];
    *(void *)CFDataRef v15 = v3;
    CFTypeID v8 = v15 + 8;
    while (v7 != v9)
    {
      uint64_t v17 = *--v7;
      *((void *)v15 - 1) = v17;
      v15 -= 8;
    }
    *(void *)a2 = v15;
    *(void *)(a2 + 8) = v8;
    *(void *)(a2 + 16) = v16;
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *long long v7 = v3;
    CFTypeID v8 = v7 + 1;
  }
  *(void *)(a2 + 8) = v8;
}

uint64_t **sub_100F1879C(uint64_t **a1, uint64_t a2)
{
  CFTypeID v4 = *a1;
  unint64_t v5 = (*a1)[1];
  unint64_t v6 = *a1;
  unint64_t v9 = v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  unint64_t v8 = v9;
  if (v5 >= v9)
  {
    unint64_t v11 = 0x84BDA12F684BDA13 * ((uint64_t)(v5 - *v4) >> 3);
    if (v11 + 1 > 0x12F684BDA12F684) {
      sub_10006A748();
    }
    unint64_t v12 = 0x84BDA12F684BDA13 * ((uint64_t)(v8 - *v4) >> 3);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x97B425ED097B42) {
      unint64_t v14 = 0x12F684BDA12F684;
    }
    else {
      unint64_t v14 = v13;
    }
    uint64_t v21 = v7;
    if (v14) {
      CFDataRef v15 = (char *)sub_1000C5FD0(v7, v14);
    }
    else {
      CFDataRef v15 = 0;
    }
    uint64_t v17 = v15;
    unsigned int v18 = &v15[216 * v11];
    uint64_t v20 = &v15[216 * v14];
    sub_1000C5AB4((uint64_t)v18, a2);
    uint64_t v19 = v18 + 216;
    sub_1003F229C(v4, &v17);
    unint64_t v10 = v4[1];
    sub_1003F2414((uint64_t)&v17);
  }
  else
  {
    sub_1000C5AB4(v5, a2);
    unint64_t v10 = v5 + 216;
    v4[1] = v5 + 216;
  }
  v4[1] = v10;
  return a1;
}

void sub_100F188D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void sub_100F188F4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F189C0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100F18A98);
  __cxa_rethrow();
}

void sub_100F189E8(_Unwind_Exception *a1)
{
}

void sub_100F18A00(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F18A38(uint64_t a1)
{
}

uint64_t sub_100F18A54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F18A98(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void *sub_100F18AC4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F18B4C()
{
}

__n128 sub_100F18B60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A6E9F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F18BB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6E9F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F18BEC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  unint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F18C34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F18C74()
{
}

void sub_100F18C84()
{
}

__n128 sub_100F18C98(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6EA70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F18CEC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6EA70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F18D24(void *a1, xpc_object_t *a2)
{
  unint64_t v3 = (uint64_t *)a1[1];
  long long v7 = *(_OWORD *)v3;
  uint64_t v8 = v3[2];
  uint64_t *v3 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  sub_10010C4E0(v3, a2);
  CFTypeID v4 = (void (*)(void *, long long *))a1[3];
  uint64_t v5 = a1[4];
  unint64_t v6 = (void *)(a1[2] + (v5 >> 1));
  if (v5) {
    CFTypeID v4 = *(void (**)(void *, long long *))(*v6 + v4);
  }
  v4(v6, &v7);
  unint64_t v9 = (void **)&v7;
  sub_1000C56F4(&v9);
}

void sub_100F18DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1000C56F4(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100F18DE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F18E24()
{
}

void sub_100F18E34()
{
}

__n128 sub_100F18E48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6EAF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F18E9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6EAF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F18ED4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  long long v24 = 0uLL;
  uint64_t v25 = 0;
  sub_1008EA904((uint64_t *)&v24, a2);
  uint64_t v23 = 0;
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)uint64_t v21 = 0u;
  *(_OWORD *)uint64_t v19 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v18, 0, sizeof(v18));
  *(_OWORD *)&v16[16] = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  *(_OWORD *)CFTypeID v16 = 0u;
  v16[0] = *(unsigned char *)v3;
  uint64_t v4 = *(void *)(v3 + 24);
  *(_OWORD *)&unsigned char v16[8] = *(_OWORD *)(v3 + 8);
  *(void *)&v16[24] = v4;
  *(void *)(v3 + 16) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 8) = 0;
  uint64_t v5 = *(void **)(v3 + 48);
  *(_OWORD *)uint64_t v17 = *(_OWORD *)(v3 + 32);
  v18[0] = v5;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 32) = 0;
  long long v6 = *(_OWORD *)(v3 + 56);
  v18[3] = *(void **)(v3 + 72);
  *(_OWORD *)&v18[1] = v6;
  *(void *)(v3 + 56) = 0;
  *(void *)(v3 + 64) = 0;
  *(void *)(v3 + 72) = 0;
  long long v7 = *(_OWORD *)(v3 + 80);
  v20[0] = *(void **)(v3 + 96);
  *(_OWORD *)uint64_t v19 = v7;
  *(void *)(v3 + 80) = 0;
  *(void *)(v3 + 88) = 0;
  *(void *)(v3 + 96) = 0;
  long long v8 = *(_OWORD *)(v3 + 104);
  v20[3] = *(void **)(v3 + 120);
  *(_OWORD *)&v20[1] = v8;
  *(void *)(v3 + 104) = 0;
  *(void *)(v3 + 112) = 0;
  *(void *)(v3 + 120) = 0;
  long long v9 = *(_OWORD *)(v3 + 128);
  __p[0] = *(void **)(v3 + 144);
  *(_OWORD *)uint64_t v21 = v9;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 136) = 0;
  *(void *)(v3 + 144) = 0;
  long long v10 = *(_OWORD *)(v3 + 152);
  __p[3] = *(void **)(v3 + 168);
  *(_OWORD *)&__p[1] = v10;
  *(void *)(v3 + 152) = 0;
  *(void *)(v3 + 160) = 0;
  *(void *)(v3 + 168) = 0;
  LOWORD(v23) = *(_WORD *)(v3 + 176);
  long long v14 = v24;
  uint64_t v15 = v25;
  long long v24 = 0uLL;
  uint64_t v25 = 0;
  sub_10064B404(v3, (uint64_t *)&v14);
  CFDictionaryRef v26 = (void **)&v14;
  sub_100150960(&v26);
  if (!sub_1008EA06C(v16, (unsigned __int8 *)v3))
  {
    uint64_t v11 = (void (*)(void *, unsigned char *))a1[3];
    uint64_t v12 = a1[4];
    uint64_t v13 = (void *)(a1[2] + (v12 >> 1));
    if (v12) {
      uint64_t v11 = *(void (**)(void *, unsigned char *))(*v13 + v11);
    }
    v11(v13, v16);
  }
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v21[0]);
  }
  if (SHIBYTE(v20[3]) < 0) {
    operator delete(v20[1]);
  }
  if (SHIBYTE(v20[0]) < 0) {
    operator delete(v19[0]);
  }
  if (SHIBYTE(v18[3]) < 0) {
    operator delete(v18[1]);
  }
  if (SHIBYTE(v18[0]) < 0) {
    operator delete(v17[0]);
  }
  if ((v16[31] & 0x80000000) != 0) {
    operator delete(*(void **)&v16[8]);
  }
  *(void *)CFTypeID v16 = &v24;
  sub_100150960((void ***)v16);
}

void sub_100F19104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (a55 < 0) {
    operator delete(__p);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  a13 = v55 - 64;
  sub_100150960((void ***)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100F191AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F191EC()
{
}

void sub_100F191FC()
{
}

__n128 sub_100F19210(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6EB70;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F19264(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6EB70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F1929C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  long long v9 = (void **)*v3;
  long long v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    long long v9 = &v10;
  }
  sub_10031A644((uint64_t)v3, a2);
  long long v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    long long v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10030AAD0((uint64_t)&v9, v10);
}

void sub_100F1935C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F19374(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F193B4()
{
}

void sub_100F193C4()
{
}

__n128 sub_100F193D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6EBF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F1942C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6EBF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F19464(uint64_t *a1, xpc_object_t *a2)
{
  sub_1001A6D14(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100F194E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F19520()
{
}

void sub_100F19530()
{
}

__n128 sub_100F19544(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A6EC70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F19598(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6EC70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F195D0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F19618(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F19658()
{
}

char *sub_100F19664(uint64_t a1, void **a2, long long **a3)
{
  uint64_t v17 = 0;
  uint64_t v5 = (void **)sub_100046ED4(a1, &v17, a2);
  long long v6 = (char *)*v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    long long v8 = *a3;
    uint64_t v16 = 0;
    long long v6 = (char *)operator new(0x68uLL);
    v15[0] = v6;
    v15[1] = a1 + 8;
    long long v9 = v6 + 32;
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84(v9, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v10 = *v8;
      *((void *)v6 + 6) = *((void *)v8 + 2);
      *(_OWORD *)long long v9 = v10;
    }
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    LOBYTE(v16) = 1;
    uint64_t v11 = v17;
    *(void *)long long v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v11;
    *uint64_t v7 = v6;
    uint64_t v12 = **(void **)a1;
    uint64_t v13 = (uint64_t *)v6;
    if (v12)
    {
      *(void *)a1 = v12;
      uint64_t v13 = (uint64_t *)*v7;
    }
    sub_100046C90(*(uint64_t **)(a1 + 8), v13);
    ++*(void *)(a1 + 16);
    v15[0] = 0;
    sub_10023C9C4((uint64_t)v15);
  }
  return v6;
}

void sub_100F19768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100F1977C(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = (void (*)(void *, uint64_t, uint64_t, uint64_t *))a1[5];
  uint64_t v5 = a1[6];
  long long v6 = (void *)(a1[4] + (v5 >> 1) - 8);
  if (v5) {
    uint64_t v4 = *(void (**)(void *, uint64_t, uint64_t, uint64_t *))(*v6 + v4);
  }
  uint64_t v7 = (std::__shared_weak_count *)a4[1];
  uint64_t v8 = *a4;
  long long v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v4(v6, a2, a3, &v8);
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100F19814(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

NSObject **sub_100F1982C(NSObject **a1, NSObject *a2, void *aBlock)
{
  *a1 = a2;
  if (aBlock)
  {
    uint64_t v4 = _Block_copy(aBlock);
    a2 = *a1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  a1[1] = v4;
  dispatch_retain(a2);
  return a1;
}

uint64_t sub_100F1987C(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    __n128 result = (uint64_t)sub_100F1982C((NSObject **)a2, *(NSObject **)result, *(void **)(result + 8));
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_100F1A01C(v6);
  }
  __n128 result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitleme"
                                    "nts10EventCauseENSt3__110shared_ptrIKNS6_17EntActionResponseINS6_13GetPSASResultEEEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (__n128 result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitlements10EventCauseENSt3__110shared_ptrIKNS6_17EntActionResponseINS6_13GetPSASResultEEEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

void sub_100F19954(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v21 = *(void *)(a2 + 16);
  }
  uint64_t v7 = *a4;
  uint64_t v6 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v8 = *(const void **)(a1 + 8);
  if (v8 && (v9 = _Block_copy(v8)) != 0 && (v10 = _Block_copy(v9), (uint64_t v11 = v10) != 0))
  {
    uint64_t v12 = _Block_copy(v10);
    uint64_t v13 = v12;
    if (v12)
    {
      long long v14 = _Block_copy(v12);
      uint64_t v15 = v14;
      if (v14)
      {
        uint64_t v16 = _Block_copy(v14);
        uint64_t v17 = v16;
        if (v16)
        {
          unsigned int v18 = _Block_copy(v16);
          uint64_t v19 = v18;
          if (v18)
          {
            uint64_t v25 = _Block_copy(v18);
            _Block_release(v19);
          }
          else
          {
            uint64_t v25 = 0;
          }
          _Block_release(v17);
        }
        else
        {
          uint64_t v25 = 0;
        }
        _Block_release(v15);
      }
      else
      {
        uint64_t v25 = 0;
      }
      long long v24 = off_101A6ED20;
      _Block_release(v13);
    }
    else
    {
      long long v24 = off_101A6ED20;
      uint64_t v25 = 0;
    }
    _Block_release(v11);
  }
  else
  {
    long long v24 = off_101A6ED20;
    uint64_t v25 = 0;
  }
  uint64_t v22 = v7;
  uint64_t v23 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100A36054();
}

void sub_100F19B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_100A36CB8(&a18);
  if ((v20 & 1) == 0) {
    _Block_release(v19);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F19BA8(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitlements10E"
                                                  "ventCauseENSt3__110shared_ptrIKNS4_17EntActionResponseINS4_13GetPSASResultEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvRK13PersonalityIDN12entitlements10EventCauseENSt3__110shared_ptrIKNS4_17EntActionResponseINS4_13GetPSASResultEEEEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else
    {
      if (a3 != 2)
      {
LABEL_2:
        a2[4] = 0;
        return;
      }
      uint64_t v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_9:
      }
        _Block_release(v7);
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      uint64_t v7 = *a1;
      if (*a1) {
        goto LABEL_9;
      }
    }
  }
}

void sub_100F19C84(uint64_t *a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v4 = *a1;
  long long v5 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  (*(void (**)(uint64_t))(v4 + 16))(v4);
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_100F19CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F19CEC(void *a1)
{
  *a1 = off_101A6ED50;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F19D38(void *a1)
{
  *a1 = off_101A6ED50;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100F19DA4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100F19E54(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F19E6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100F19E8C()
{
}

void *sub_100F19EF8(void *a1)
{
  *a1 = off_101A6EDA0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F19F44(void *a1)
{
  *a1 = off_101A6EDA0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100F19FB0()
{
}

uint64_t sub_100F1A01C(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_100F1A058(void *a1, uint64_t *a2)
{
  uint64_t v3 = (void (*)(void *, const void **))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v4 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    uint64_t v3 = *(void (**)(void *, const void **))(*v4 + v3);
  }
  memset(v5, 0, sizeof(v5));
  sub_10055D914(v5, *a2, a2[1], (a2[1] - *a2) >> 4);
  v3(v4, v5);
  uint64_t v6 = v5;
  sub_10055D640((void ***)&v6);
}

void sub_100F1A108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10055D640((void ***)va);
  _Unwind_Resume(a1);
}

void sub_100F1A124()
{
}

void *sub_100F1A138(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A6EE00;
  result[1] = v3;
  return result;
}

uint64_t sub_100F1A180(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6EE00;
  a2[1] = v2;
  return result;
}

void sub_100F1A1AC(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    uint64_t v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    long long v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100F1A278(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F1A2B8()
{
}

void *sub_100F1A2C4(void *a1)
{
  *a1 = off_101A6EE80;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_100F1A308(void *a1)
{
  *a1 = off_101A6EE80;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_100F1A36C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A6EE80;
  sub_1000DFC90((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F1A3C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1A3D4(uint64_t a1, void *a2)
{
  *a2 = off_101A6EE80;
  return sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100F1A400(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_100F1A408(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100F1A444(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = a1 + 8;
  char v4 = *a2 == 1 && a2[1] != 0;
  return sub_1000607A8(v2, v4);
}

uint64_t sub_100F1A460(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1A4A0()
{
}

uint64_t sub_100F1A4AC(uint64_t a1)
{
  *(void *)a1 = off_101A6EF00;
  sub_1000C752C((void *)(a1 + 64));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

void sub_100F1A500(uint64_t a1)
{
  *(void *)a1 = off_101A6EF00;
  sub_1000C752C((void *)(a1 + 64));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  operator delete();
}

void *sub_100F1A574(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x60uLL);
  void *v2 = off_101A6EF00;
  sub_100F1ACC8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F1A5C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1A5DC(uint64_t a1, void *a2)
{
  *a2 = off_101A6EF00;
  return sub_100F1ACC8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100F1A608(uint64_t a1)
{
}

void sub_100F1A610(void *a1)
{
  sub_100F1AD68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F1A64C(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if ((v3 - 1) >= 2)
  {
    int v3 = 0;
    int v4 = 0;
    uint64_t v5 = *(void *)(a1 + 8);
    __int16 v46 = 0;
  }
  else
  {
    int v4 = a2[1];
    uint64_t v5 = *(void *)(a1 + 8);
    LOBYTE(v46) = *a2;
    HIBYTE(v46) = v4;
  }
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, __int16 *))(*(void *)v6 + 48))(v6, &v46);
  LOBYTE(v46) = 0;
  if (v3 != 1)
  {
    if (v3 != 2)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    return;
  }
  if (!v4) {
    return;
  }
  sub_1002EF958((uint64_t)buf);
  int v8 = sub_1003D5918(a1 + 16, (uint64_t)buf);
  int v9 = v8;
  if (v49 < 0)
  {
    operator delete(__p);
    if (v9) {
      goto LABEL_11;
    }
  }
  else if (v8)
  {
LABEL_11:
    long long v10 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Clearing all ICCIDs", buf, 2u);
    }
    if (*(char *)(v5 + 695) < 0)
    {
      **(unsigned char **)(v5 + 672) = 0;
      *(void *)(v5 + 680) = 0;
    }
    else
    {
      *(unsigned char *)(v5 + 672) = 0;
      *(unsigned char *)(v5 + 695) = 0;
    }
    if (*(char *)(v5 + 743) < 0)
    {
      **(unsigned char **)(v5 + 720) = 0;
      *(void *)(v5 + 728) = 0;
    }
    else
    {
      *(unsigned char *)(v5 + 720) = 0;
      *(unsigned char *)(v5 + 743) = 0;
    }
    if (*(char *)(v5 + 719) < 0)
    {
      **(unsigned char **)(v5 + 696) = 0;
      *(void *)(v5 + 704) = 0;
    }
    else
    {
      *(unsigned char *)(v5 + 696) = 0;
      *(unsigned char *)(v5 + 719) = 0;
    }
    sub_1003DDCEC(v5 + 600, *(void **)(v5 + 608));
    *(void *)(v5 + 600) = v5 + 608;
    *(void *)(v5 + 616) = 0;
    *(void *)(v5 + 608) = 0;
    sub_10005CD2C(v5 + 624, *(char **)(v5 + 632));
    *(void *)(v5 + 624) = v5 + 632;
    *(void *)(v5 + 640) = 0;
    *(void *)(v5 + 632) = 0;
    uint64_t v19 = *(std::__shared_weak_count **)(v5 + 576);
    v45[0] = *(void *)(v5 + 568);
    v45[1] = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F0F92C(v45, @"RemotePlanSelectedKey", v5 + 696);
    if (v19) {
      sub_10004D2C8(v19);
    }
    char v20 = *(std::__shared_weak_count **)(v5 + 576);
    v44[0] = *(void *)(v5 + 568);
    v44[1] = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F0F92C(v44, @"RemotePlanSelectedOverrideKey", v5 + 720);
    if (v20) {
      sub_10004D2C8(v20);
    }
    sub_100F110AC(v5, (std::string *)(v5 + 672));
    uint64_t v21 = *(std::__shared_weak_count **)(v5 + 528);
    if (v21)
    {
      uint64_t v22 = std::__shared_weak_count::lock(v21);
      if (v22)
      {
        uint64_t v23 = v22;
        uint64_t v24 = *(void *)(v5 + 520);
        if (v24) {
          (*(void (**)(uint64_t))(*(void *)v24 + 32))(v24);
        }
        sub_10004D2C8(v23);
      }
    }
    return;
  }
  uint64_t v11 = (unsigned __int8 **)(a1 + 32);
  sub_1003DF568((uint64_t **)(v5 + 600), (void **)(a1 + 32));
  sub_1000E9358((uint64_t **)(v5 + 624), (void **)(a1 + 32));
  uint64_t v12 = *(unsigned __int8 *)(v5 + 743);
  char v13 = v12;
  if ((v12 & 0x80u) == 0) {
    uint64_t v14 = *(unsigned __int8 *)(v5 + 743);
  }
  else {
    uint64_t v14 = *(void *)(v5 + 728);
  }
  uint64_t v15 = *(unsigned __int8 *)(a1 + 55);
  int v16 = (char)v15;
  if ((v15 & 0x80u) != 0) {
    uint64_t v15 = *(void *)(a1 + 40);
  }
  if (v14 == v15)
  {
    if (v16 >= 0) {
      uint64_t v17 = (unsigned __int8 *)(a1 + 32);
    }
    else {
      uint64_t v17 = *v11;
    }
    if ((char)v12 < 0)
    {
      if (memcmp(*(const void **)(v5 + 720), v17, *(void *)(v5 + 728))) {
        goto LABEL_61;
      }
    }
    else if ((_BYTE)v12)
    {
      unsigned int v18 = (unsigned __int8 *)(v5 + 720);
      while (*v18 == *v17)
      {
        ++v18;
        ++v17;
        if (!--v12) {
          goto LABEL_52;
        }
      }
      goto LABEL_61;
    }
LABEL_52:
    uint64_t v25 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Clearing system ICCID", buf, 2u);
      char v13 = *(unsigned char *)(v5 + 743);
    }
    if (v13 < 0)
    {
      **(unsigned char **)(v5 + 720) = 0;
      *(void *)(v5 + 728) = 0;
    }
    else
    {
      *(unsigned char *)(v5 + 720) = 0;
      *(unsigned char *)(v5 + 743) = 0;
    }
    CFDictionaryRef v26 = *(std::__shared_weak_count **)(v5 + 576);
    v43[0] = *(void *)(v5 + 568);
    v43[1] = v26;
    if (v26) {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F0F92C(v43, @"RemotePlanSelectedOverrideKey", v5 + 720);
    if (v26) {
      sub_10004D2C8(v26);
    }
  }
LABEL_61:
  uint64_t v27 = *(unsigned __int8 *)(v5 + 719);
  char v28 = v27;
  if ((v27 & 0x80u) == 0) {
    uint64_t v29 = *(unsigned __int8 *)(v5 + 719);
  }
  else {
    uint64_t v29 = *(void *)(v5 + 704);
  }
  uint64_t v30 = *(unsigned __int8 *)(a1 + 55);
  int v31 = (char)v30;
  if ((v30 & 0x80u) != 0) {
    uint64_t v30 = *(void *)(a1 + 40);
  }
  if (v29 != v30) {
    goto LABEL_86;
  }
  if (v31 >= 0) {
    uint64_t v32 = (unsigned __int8 *)(a1 + 32);
  }
  else {
    uint64_t v32 = *v11;
  }
  if ((char)v27 < 0)
  {
    if (memcmp(*(const void **)(v5 + 696), v32, *(void *)(v5 + 704))) {
      goto LABEL_86;
    }
    goto LABEL_77;
  }
  if (!(_BYTE)v27)
  {
LABEL_77:
    long long v34 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Clearing user ICCID", buf, 2u);
      char v28 = *(unsigned char *)(v5 + 719);
    }
    if (v28 < 0)
    {
      **(unsigned char **)(v5 + 696) = 0;
      *(void *)(v5 + 704) = 0;
    }
    else
    {
      *(unsigned char *)(v5 + 696) = 0;
      *(unsigned char *)(v5 + 719) = 0;
    }
    uint64_t v35 = *(std::__shared_weak_count **)(v5 + 576);
    v42[0] = *(void *)(v5 + 568);
    v42[1] = v35;
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100F0F92C(v42, @"RemotePlanSelectedKey", v5 + 696);
    if (v35) {
      sub_10004D2C8(v35);
    }
    goto LABEL_86;
  }
  int v33 = (unsigned __int8 *)(v5 + 696);
  while (*v33 == *v32)
  {
    ++v33;
    ++v32;
    if (!--v27) {
      goto LABEL_77;
    }
  }
LABEL_86:
  uint64_t v36 = *(unsigned __int8 *)(v5 + 695);
  if ((v36 & 0x80u) == 0) {
    uint64_t v37 = *(unsigned __int8 *)(v5 + 695);
  }
  else {
    uint64_t v37 = *(void *)(v5 + 680);
  }
  uint64_t v38 = *(unsigned __int8 *)(a1 + 55);
  int v39 = (char)v38;
  if ((v38 & 0x80u) != 0) {
    uint64_t v38 = *(void *)(a1 + 40);
  }
  if (v37 != v38) {
    return;
  }
  long long v40 = (const void **)(v5 + 672);
  if (v39 >= 0) {
    uint64_t v41 = (unsigned __int8 *)(a1 + 32);
  }
  else {
    uint64_t v41 = *v11;
  }
  if ((v36 & 0x80) != 0)
  {
    if (memcmp(*v40, v41, *(void *)(v5 + 680))) {
      return;
    }
    goto LABEL_101;
  }
  if (!*(unsigned char *)(v5 + 695))
  {
LABEL_101:
    sub_100F0FC20(v5);
    return;
  }
  while (*(unsigned __int8 *)v40 == *v41)
  {
    long long v40 = (const void **)((char *)v40 + 1);
    ++v41;
    if (!--v36) {
      goto LABEL_101;
    }
  }
}

void sub_100F1AC08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_10004D2C8(v26);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1AC7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1ACBC()
{
}

uint64_t sub_100F1ACC8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v4;
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  sub_1000C7494(a1 + 56, a2 + 56);
  return a1;
}

void sub_100F1AD4C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1AD68(uint64_t a1)
{
  sub_1000C752C((void *)(a1 + 56));
  if (*(char *)(a1 + 47) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

uint64_t sub_100F1ADB8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100F1AE50(uint64_t a1)
{
  *(void *)a1 = off_101A6EF80;
  sub_100F18AC4((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100F1AEA4(uint64_t a1)
{
  *(void *)a1 = off_101A6EF80;
  sub_100F18AC4((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100F1AF18(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_101A6EF80;
  sub_100F1B414((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F1AF6C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1AF80(uint64_t a1, void *a2)
{
  *a2 = off_101A6EF80;
  return sub_100F1B414((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100F1AFAC(uint64_t a1)
{
}

void sub_100F1AFB4(void *a1)
{
  sub_100F1B4A4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F1AFF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100F1B4F4(v10, a3);
  if (v25)
  {
    sub_100CC26CC(v54, (uint64_t)v10);
    uint64_t v4 = *(void *)(a1 + 64);
    if (!v4) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v4 + 48))(v4, v54);
    if (v67)
    {
      if (v66 < 0) {
        operator delete(v65);
      }
      if (v64 < 0) {
        operator delete(v63);
      }
      if (v62 < 0) {
        operator delete(v61);
      }
      if (v60 < 0) {
        operator delete(v59);
      }
      if (v58 < 0) {
        operator delete(v57);
      }
      if (v56 < 0) {
        operator delete(v55);
      }
      if ((v54[31] & 0x80000000) != 0)
      {
        uint64_t v5 = (void **)v54;
LABEL_51:
        operator delete(v5[1]);
      }
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    __int16 v7 = sub_100046F68(v6 + 600, (void **)(a1 + 16));
    if ((void **)(v6 + 608) == v7)
    {
      v26[0] = 0;
      char v39 = 0;
      uint64_t v9 = *(void *)(a1 + 64);
      if (!v9) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v9 + 48))(v9, v26);
      if (v39)
      {
        if (v38 < 0) {
          operator delete(v37);
        }
        if (v36 < 0) {
          operator delete(v35);
        }
        if (v34 < 0) {
          operator delete(v33);
        }
        if (v32 < 0) {
          operator delete(v31);
        }
        if (v30 < 0) {
          operator delete(v29);
        }
        if (v28 < 0) {
          operator delete(v27);
        }
        if ((v26[31] & 0x80000000) != 0)
        {
          uint64_t v5 = (void **)v26;
          goto LABEL_51;
        }
      }
    }
    else
    {
      sub_10023FB90((uint64_t)v40, (uint64_t)(v7 + 7));
      char v53 = 1;
      uint64_t v8 = *(void *)(a1 + 64);
      if (!v8) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v8 + 48))(v8, v40);
      if (v53)
      {
        if (v52 < 0) {
          operator delete(__p);
        }
        if (v50 < 0) {
          operator delete(v49);
        }
        if (v48 < 0) {
          operator delete(v47);
        }
        if (v46 < 0) {
          operator delete(v45);
        }
        if (v44 < 0) {
          operator delete(v43);
        }
        if (v42 < 0) {
          operator delete(v41);
        }
        if ((v40[31] & 0x80000000) != 0)
        {
          uint64_t v5 = (void **)v40;
          goto LABEL_51;
        }
      }
    }
  }
  if (v25)
  {
    if (v24 < 0) {
      operator delete(v23);
    }
    if (v22 < 0) {
      operator delete(v21);
    }
    if (v20 < 0) {
      operator delete(v19);
    }
    if (v18 < 0) {
      operator delete(v17);
    }
    if (v16 < 0) {
      operator delete(v15);
    }
    if (v14 < 0) {
      operator delete(v13);
    }
    if (v12 < 0) {
      operator delete(v11);
    }
  }
}

void sub_100F1B304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,char a54,int a55,__int16 a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a72) {
    sub_1000C62D8((uint64_t)&a56);
  }
  if (a54)
  {
    if (a52 < 0) {
      operator delete(__p);
    }
    if (a46 < 0) {
      operator delete(a41);
    }
    if (a40 < 0) {
      operator delete(a35);
    }
    if (a34 < 0) {
      operator delete(a29);
    }
    if (a28 < 0) {
      operator delete(a23);
    }
    if (a21 < 0) {
      operator delete(a16);
    }
    if (a15 < 0) {
      operator delete(a10);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F1B3C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1B408()
{
}

uint64_t sub_100F1B414(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_100F1ADB8(a1 + 32, a2 + 32);
  return a1;
}

void sub_100F1B488(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1B4A4(uint64_t a1)
{
  sub_100F18AC4((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

unsigned char *sub_100F1B4F4(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[192] = 0;
  sub_100F1B528((uint64_t)a1, a2);
  return a1;
}

__n128 sub_100F1B528(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 192))
  {
    *(void *)a1 = *(void *)a2;
    long long v2 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v2;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    long long v3 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v3;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 32) = 0;
    *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
    long long v4 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v4;
    *(void *)(a2 + 72) = 0;
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 64) = 0;
    long long v5 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = v5;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 104) = 0;
    *(void *)(a2 + 88) = 0;
    long long v6 = *(_OWORD *)(a2 + 112);
    *(void *)(a1 + 128) = *(void *)(a2 + 128);
    *(_OWORD *)(a1 + 112) = v6;
    *(void *)(a2 + 120) = 0;
    *(void *)(a2 + 128) = 0;
    *(void *)(a2 + 112) = 0;
    long long v7 = *(_OWORD *)(a2 + 136);
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(_OWORD *)(a1 + 136) = v7;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 144) = 0;
    *(void *)(a2 + 152) = 0;
    __n128 result = *(__n128 *)(a2 + 160);
    *(void *)(a1 + 176) = *(void *)(a2 + 176);
    *(__n128 *)(a1 + 160) = result;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 168) = 0;
    *(void *)(a2 + 176) = 0;
    *(_WORD *)(a1 + 184) = *(_WORD *)(a2 + 184);
    *(unsigned char *)(a1 + 192) = 1;
  }
  return result;
}

void *sub_100F1B5FC(void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F1B684()
{
}

void *sub_100F1B698()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A6F010;
  return result;
}

void sub_100F1B6D0(uint64_t a1, void *a2)
{
  *a2 = off_101A6F010;
}

void sub_100F1B6F8(uint64_t a1, uint64_t a2)
{
  sub_100F1B4F4(v2, a2);
  if (v17)
  {
    if (v16 < 0) {
      operator delete(__p);
    }
    if (v14 < 0) {
      operator delete(v13);
    }
    if (v12 < 0) {
      operator delete(v11);
    }
    if (v10 < 0) {
      operator delete(v9);
    }
    if (v8 < 0) {
      operator delete(v7);
    }
    if (v6 < 0) {
      operator delete(v5);
    }
    if (v4 < 0) {
      operator delete(v3);
    }
  }
}

uint64_t sub_100F1B794(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1B7D4()
{
}

uint64_t sub_100F1B7E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100F1B7F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F1B80C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_100F1B81C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  sub_1000DFC90((uint64_t)v7, v1 + 32);
  uint64_t v9 = 0;
  long long v3 = operator new(0x28uLL);
  void *v3 = off_101A6F0D8;
  sub_100023950((uint64_t)(v3 + 1), (uint64_t)v7);
  uint64_t v9 = v3;
  sub_100F12FC0(v2, (const std::string *)(v1 + 8), (uint64_t)v8);
  sub_100F1B5FC(v8);
  sub_100060644(v7);
  sub_10012C844(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F1B8F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, void);
  uint64_t v9 = va_arg(va3, void);
  uint64_t v10 = va_arg(va3, void);
  uint64_t v11 = va_arg(va3, void);
  sub_100F1B5FC((uint64_t *)va3);
  sub_100060644((uint64_t *)va2);
  sub_10012C844((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100F1B930(void *a1)
{
  *a1 = off_101A6F0D8;
  sub_100060644(a1 + 1);
  return a1;
}

void sub_100F1B974(void *a1)
{
  *a1 = off_101A6F0D8;
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_100F1B9D8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A6F0D8;
  sub_1000DFC90((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100F1BA2C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1BA40(uint64_t a1, void *a2)
{
  *a2 = off_101A6F0D8;
  return sub_1000DFC90((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100F1BA6C(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 8));
}

void sub_100F1BA74(void *a1)
{
  sub_100060644(a1 + 1);

  operator delete(a1);
}

void sub_100F1BAB0(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = a1 + 8;
  int v4 = *a2;
  sub_100F1B4F4(v7, a3);
  if (v4) {
    BOOL v5 = v23 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v6 = !v5 && v12 == 2;
  sub_1000607A8(v3, v6);
  if (v23)
  {
    if (v22 < 0) {
      operator delete(__p);
    }
    if (v20 < 0) {
      operator delete(v19);
    }
    if (v18 < 0) {
      operator delete(v17);
    }
    if (v16 < 0) {
      operator delete(v15);
    }
    if (v14 < 0) {
      operator delete(v13);
    }
    if (v11 < 0) {
      operator delete(v10);
    }
    if (v9 < 0) {
      operator delete(v8);
    }
  }
}

void sub_100F1BB8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53,uint64_t a54,char a55)
{
  if (a55)
  {
    if (a53 < 0) {
      operator delete(__p);
    }
    if (a47 < 0) {
      operator delete(a42);
    }
    if (a41 < 0) {
      operator delete(a36);
    }
    if (a35 < 0) {
      operator delete(a30);
    }
    if (a29 < 0) {
      operator delete(a24);
    }
    if (a22 < 0) {
      operator delete(a17);
    }
    if (a16 < 0) {
      operator delete(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F1BC10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1BC50()
{
}

void *sub_100F1BC5C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100F1BCE4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_100F1BD80()
{
}

void *sub_100F1BD94(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A6F158;
  result[1] = v3;
  return result;
}

uint64_t sub_100F1BDDC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6F158;
  a2[1] = v2;
  return result;
}

void sub_100F1BE08(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*a2 >= 0x100u)
  {
    if (*(char *)(v2 + 695) < 0)
    {
      **(unsigned char **)(v2 + 672) = 0;
      *(void *)(v2 + 680) = 0;
    }
    else
    {
      *(unsigned char *)(v2 + 672) = 0;
      *(unsigned char *)(v2 + 695) = 0;
    }
    return;
  }
  uint64_t v3 = (unsigned __int8 **)(v2 + 672);
  uint64_t v4 = *(unsigned __int8 *)(v2 + 775);
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = *(unsigned __int8 *)(v2 + 775);
  }
  else {
    uint64_t v5 = *(void *)(v2 + 760);
  }
  uint64_t v6 = *(unsigned __int8 *)(v2 + 695);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(v2 + 680);
  }
  if (v5 == v6)
  {
    char v8 = (const void **)(v2 + 752);
    if (v7 >= 0) {
      char v9 = (unsigned __int8 *)(v2 + 672);
    }
    else {
      char v9 = *v3;
    }
    if ((v4 & 0x80) == 0)
    {
      if (*(unsigned char *)(v2 + 775))
      {
        uint64_t v10 = (unsigned __int8 *)(v2 + 752);
        while (*v10 == *v9)
        {
          ++v10;
          ++v9;
          if (!--v4) {
            goto LABEL_16;
          }
        }
        goto LABEL_26;
      }
LABEL_16:
      *(unsigned char *)(v2 + 752) = 0;
      *(unsigned char *)(v2 + 775) = 0;
      goto LABEL_22;
    }
    char v11 = *v8;
    if (!memcmp(*v8, v9, *(void *)(v2 + 760)))
    {
      *char v11 = 0;
      *(void *)(v2 + 760) = 0;
LABEL_22:
      char v12 = *(std::__shared_weak_count **)(v2 + 576);
      v17[0] = *(void *)(v2 + 568);
      v17[1] = v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100F14AC4(v17, v2 + 752);
      if (v12) {
        sub_10004D2C8(v12);
      }
    }
  }
LABEL_26:
  sub_100F110AC(v2, (std::string *)(v2 + 672));
  if (*(char *)(v2 + 695) < 0)
  {
    if (!*(void *)(v2 + 680)) {
      return;
    }
  }
  else if (!*(unsigned char *)(v2 + 695))
  {
    return;
  }
  char v13 = *(std::__shared_weak_count **)(v2 + 528);
  if (v13)
  {
    char v14 = std::__shared_weak_count::lock(v13);
    if (v14)
    {
      uint64_t v15 = v14;
      uint64_t v16 = *(void *)(v2 + 520);
      if (v16)
      {
        v18[0] = 0;
        if (*(char *)(v2 + 695) < 0)
        {
          sub_10004FC84(&__p, *(void **)(v2 + 672), *(void *)(v2 + 680));
        }
        else
        {
          long long __p = *(_OWORD *)v3;
          uint64_t v20 = *(void *)(v2 + 688);
        }
        v18[0] = 1;
        (*(void (**)(uint64_t, char *))(*(void *)v16 + 48))(v16, v18);
        if (v18[0])
        {
          if (SHIBYTE(v20) < 0) {
            operator delete((void *)__p);
          }
        }
      }
      sub_10004D2C8(v15);
    }
  }
}

void sub_100F1C028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1C06C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1C0AC()
{
}

void sub_100F1C0BC()
{
}

void *sub_100F1C0D0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A6F1D8;
  return result;
}

void sub_100F1C108(uint64_t a1, void *a2)
{
  *a2 = off_101A6F1D8;
}

uint64_t sub_100F1C134(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F1C174()
{
}

uint64_t OOSGeofenceManager::OOSGeofenceManager(uint64_t a1, void *a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "oos.geo.mgr");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v17, &v16);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  *(void *)a1 = off_101A6F268;
  *(void *)(a1 + 48) = off_101A6F300;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 104) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "OOSGeofenceManager");
  char v8 = *(NSObject **)(a1 + 24);
  char v13 = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  char v9 = *(NSObject **)(a1 + 32);
  xpc_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  uint64_t v10 = *a3;
  *(void *)(a1 + 128) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(_WORD *)(a1 + 152) = 0;
  return a1;
}

void sub_100F1C320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  char v23 = (std::__shared_weak_count *)*((void *)v19 + 13);
  if (v23) {
    sub_10004D2C8(v23);
  }
  char v24 = (std::__shared_weak_count *)*((void *)v19 + 11);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10005CBF0((void ***)&a17);
  OOSGeofenceManagerInterface::~OOSGeofenceManagerInterface(v19);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1C3C0(uint64_t a1)
{
  *(void *)a1 = off_101A6F268;
  *(void *)(a1 + 48) = off_101A6F300;
  sub_100F1C4EC((void *)a1);
  uint64_t v2 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 128);
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7) {
    sub_10004D2C8(v7);
  }
  char v9 = (void **)(a1 + 56);
  sub_10005CBF0(&v9);
  OOSGeofenceManagerInterface::~OOSGeofenceManagerInterface((OOSGeofenceManagerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100F1C4EC(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Beginning to shut down and unload all OOS geofences", buf, 2u);
  }
  sub_100A38F28(a1[10]);
  sub_10019E028(a1 + 7);
  uint64_t v3 = a1[5];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shut down and unloaded all OOS geofences.", v4, 2u);
  }
  sub_100F1CF14((uint64_t)a1);
}

uint64_t sub_100F1C5A8(uint64_t a1)
{
  return sub_100F1C3C0(a1 - 48);
}

void sub_100F1C5B0(uint64_t a1)
{
  sub_100F1C3C0(a1);

  operator delete();
}

void sub_100F1C5E8(uint64_t a1)
{
  sub_100F1C3C0(a1 - 48);

  operator delete();
}

void sub_100F1C624(void *a1, void *a2, char *a3)
{
  uint64_t v6 = (void *)a2[7];
  uint64_t v7 = (void *)a2[8];
  if (v6 == v7)
  {
LABEL_26:
    uint64_t v21 = a2[5];
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      if (a3[23] >= 0) {
        char v25 = a3;
      }
      else {
        char v25 = *(char **)a3;
      }
      LODWORD(__s1) = 136642819;
      *(void *)((char *)&__s1 + 4) = v25;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not match regionId for %{sensitive}s", (uint8_t *)&__s1, 0xCu);
    }
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  while (1)
  {
    id v8 = *(id *)(*v6 + 8);
    id v9 = [v8 identifier];
    sub_100058DB0(&__s1, (char *)[v9 UTF8String]);
    if ((v27 & 0x80u) == 0) {
      uint64_t v10 = v27;
    }
    else {
      uint64_t v10 = *((void *)&__s1 + 1);
    }
    uint64_t v11 = a3[23];
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *((void *)a3 + 1);
    }
    if (v10 != v11)
    {
      if ((v27 & 0x80) != 0) {
        operator delete((void *)__s1);
      }

      goto LABEL_25;
    }
    if (v12 >= 0) {
      char v13 = a3;
    }
    else {
      char v13 = *(char **)a3;
    }
    if ((v27 & 0x80) != 0)
    {
      uint64_t v19 = (void *)__s1;
      BOOL v20 = memcmp((const void *)__s1, v13, *((size_t *)&__s1 + 1)) == 0;
      operator delete(v19);

      if (v20) {
        goto LABEL_30;
      }
      goto LABEL_25;
    }
    if (!v27) {
      break;
    }
    uint64_t v14 = 0;
    do
    {
      int v15 = *((unsigned __int8 *)&__s1 + v14);
      int v16 = v13[v14];
    }
    while (v15 == v16 && v27 - 1 != v14++);
    BOOL v18 = v15 == v16;

    if (v18) {
      goto LABEL_30;
    }
LABEL_25:
    v6 += 2;
    if (v6 == v7) {
      goto LABEL_26;
    }
  }

LABEL_30:
  char v22 = a2[5];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    if (a3[23] >= 0) {
      char v23 = a3;
    }
    else {
      char v23 = *(char **)a3;
    }
    LODWORD(__s1) = 136642819;
    *(void *)((char *)&__s1 + 4) = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Matched regionId for OOS region %{sensitive}s", (uint8_t *)&__s1, 0xCu);
  }
  uint64_t v24 = v6[1];
  *a1 = *v6;
  a1[1] = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_100F1C890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100F1C8B4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 152);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I OOS Geofence Manager is loaded: %d", buf, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(unsigned __int8 *)(a1 + 153);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I OOS Geofence Manager perceives service as: %d", buf, 8u);
  }
  uint64_t v5 = *(int ***)(a1 + 56);
  for (uint64_t i = *(int ***)(a1 + 64); v5 != i; v5 += 2)
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = *((id *)*v5 + 1);
      id v9 = [v8 identifier];
      id v10 = [v9 UTF8String];
      uint64_t v11 = **v5;
      int v12 = "Invalid value";
      if (v11 <= 3) {
        int v12 = off_101A6F508[v11];
      }
      sub_100058DB0(buf, v12);
      char v13 = buf;
      if (v15 < 0) {
        char v13 = *(uint8_t **)buf;
      }
      *(_DWORD *)int v16 = 136315394;
      id v17 = v10;
      __int16 v18 = 2080;
      uint64_t v19 = v13;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I OOS Region %s has status %s", v16, 0x16u);
      if (v15 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
}

void sub_100F1CABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100F1CAE4(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_101A6F448;
  v2[1] = a1;
  void v2[2] = sub_100F1C8B4;
  v2[3] = 0;
  double v5[3] = v2;
  ctu::RestModule::observeEvent();
  sub_10003F600(v5);
  if (v4 < 0) {
    operator delete(__p);
  }
}

void sub_100F1CBB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F1CBE4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 152)) {
    return;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2 || (v3 = *(void *)(a1 + 8), (char v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  dispatch_queue_t v6 = dispatch_queue_create("OOS Geofence Queue", 0);
  uint64_t v7 = *(NSObject **)(a1 + 128);
  id v8 = (std::__shared_weak_count *)operator new(0x68uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A6F4C8;
  dispatch_object_t object = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  uint64_t v9 = v3 + 48;
  if (!v3) {
    uint64_t v9 = 0;
  }
  v16[0] = v9;
  v16[1] = v5;
  sub_100058DB0(__p, "/System/Library/LocationBundles/Oos.bundle");
  id v10 = v8 + 1;
  sub_100A386B0((uint64_t)&v8[1], &object, v16, (uint64_t)v6, (uint64_t *)__p, 0);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  sub_10004D2C8(v5);
  if (object) {
    dispatch_release(object);
  }
  uint64_t v11 = (std::__shared_weak_count *)v8[2].__vftable;
  if (!v11)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__shared_weak_owners_ = (uint64_t)v10;
    v8[2].__vftable = (std::__shared_weak_count_vtbl *)v8;
    goto LABEL_16;
  }
  if (v11->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__shared_weak_owners_ = (uint64_t)v10;
    v8[2].__vftable = (std::__shared_weak_count_vtbl *)v8;
    std::__shared_weak_count::__release_weak(v11);
LABEL_16:
    sub_10004D2C8(v8);
  }
  int v12 = *(std::__shared_weak_count **)(a1 + 88);
  *(void *)(a1 + 80) = v10;
  *(void *)(a1 + 88) = v8;
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100F1C4EC((void *)a1);
  char v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Finished loading permanent OOS geofences...", (uint8_t *)__p, 2u);
  }
  *(unsigned char *)(a1 + 152) = 1;
}

void sub_100F1CDA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, dispatch_object_t object)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v18);
  if (object) {
    dispatch_release(object);
  }
  std::__shared_weak_count::~__shared_weak_count(v17);
  operator delete(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1CDFC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

void sub_100F1CE04(void *a1, char *a2)
{
  dispatch_queue_t v6 = 0;
  uint64_t v7 = 0;
  sub_100F1C624(&v6, a1, a2);
  if (v6)
  {
    *dispatch_queue_t v6 = 2;
    char v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (a2[23] >= 0) {
        uint64_t v5 = a2;
      }
      else {
        uint64_t v5 = *(char **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Entered OOS Region %s", buf, 0xCu);
    }
    sub_100F1CF14((uint64_t)a1);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F1CEF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1CF14(uint64_t a1)
{
  uint64_t v3 = *(_DWORD ***)(a1 + 56);
  uint64_t v2 = *(_DWORD ***)(a1 + 64);
  if (v2 == v3)
  {
    char v4 = *(NSObject **)(a1 + 40);
    int v5 = 0;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    *(_WORD *)long long buf = 0;
    dispatch_queue_t v6 = "#I No OOS geofence regions are loaded.";
  }
  else
  {
    do
    {
      if (**v3 == 2)
      {
        uint64_t v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Device is in at least one OOS region...", buf, 2u);
        }
        int v5 = 1;
        goto LABEL_12;
      }
      v3 += 2;
    }
    while (v3 != v2);
    char v4 = *(NSObject **)(a1 + 40);
    int v5 = 0;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    *(_WORD *)long long buf = 0;
    dispatch_queue_t v6 = "#I Device is not in any OOS regions...";
  }
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
  int v5 = 0;
LABEL_12:
  id v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "true";
    if (*(unsigned char *)(a1 + 153)) {
      id v10 = "true";
    }
    else {
      id v10 = "false";
    }
    if (!v5) {
      uint64_t v9 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I OOS Status: Device has service [%s] and device is in an OOS Area [%s]", buf, 0x16u);
  }
  char v11 = v5 ^ 1;
  if (*(unsigned char *)(a1 + 153)) {
    char v11 = 1;
  }
  if ((v11 & 1) == 0)
  {
    int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Device is now in an OOS Zone with no Service...", buf, 2u);
    }
    uint64_t v13 = *(void *)(a1 + 136);
    if (v13)
    {
      int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 24))(v13);
      char v15 = *(NSObject **)(a1 + 40);
      if (!v14)
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          int v16 = "#I OOS countdown timer is active...";
LABEL_56:
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
          return;
        }
        return;
      }
    }
    else
    {
      char v15 = *(NSObject **)(a1 + 40);
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Beginning countdown to dispatch any queued WEA due to being OOS.", buf, 2u);
    }
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    Registry::getTimerService(&v46, *(Registry **)(a1 + 96));
    uint64_t v19 = v46;
    BOOL v20 = *(NSObject **)(a1 + 40);
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      if (v21)
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = 60;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Setting OOS timer to %llds seconds...", buf, 0xCu);
      }
      char v23 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v23 || (uint64_t v24 = *(void *)(a1 + 8), (v25 = std::__shared_weak_count::lock(v23)) == 0)) {
        sub_100088B9C();
      }
      CFDictionaryRef v26 = v25;
      p_shared_weak_owners = &v25->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v25);
      sub_100058DB0(v43, "OOS Countdown to WEA Delivery");
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3321888768;
      *(void *)&uint8_t buf[16] = sub_100F1E4D8;
      unint64_t v51 = &unk_101A6F350;
      uint64_t v52 = a1;
      uint64_t v53 = v24;
      uint64_t v54 = v26;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      char v28 = objc_retainBlock(buf);
      *(_OWORD *)long long __p = *(_OWORD *)v43;
      uint64_t v49 = v44;
      v43[0] = 0;
      v43[1] = 0;
      uint64_t v44 = 0;
      ctu::TimerService::createOneShotTimerImpl();
      if (SHIBYTE(v49) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v29 = v45;
      uint64_t v45 = 0;
      uint64_t v30 = *(void *)(a1 + 136);
      *(void *)(a1 + 136) = v29;
      if (v30)
      {
        (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
        uint64_t v31 = v45;
        uint64_t v45 = 0;
        if (v31) {
          (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
        }
      }

      if (SHIBYTE(v44) < 0) {
        operator delete(v43[0]);
      }
      char v32 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I OOS countdown has begun...", (uint8_t *)__p, 2u);
      }
      if (v54) {
        std::__shared_weak_count::__release_weak(v54);
      }
      std::__shared_weak_count::__release_weak(v26);
LABEL_71:
      if (v47) {
        sub_10004D2C8(v47);
      }
      return;
    }
    if (v21)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Could not create OOS countdown timer.", buf, 2u);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v22, *(Registry **)(a1 + 96));
    char v34 = ServiceMap;
    if (v35 < 0)
    {
      char v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v37 = 5381;
      do
      {
        uint64_t v35 = v37;
        unsigned int v38 = *v36++;
        uint64_t v37 = (33 * v37) ^ v38;
      }
      while (v38);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v35;
    char v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)buf);
    if (v39)
    {
      uint64_t v41 = v39[3];
      long long v40 = (std::__shared_weak_count *)v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v40);
        char v42 = 0;
        if (!v41)
        {
LABEL_69:
          if ((v42 & 1) == 0) {
            sub_10004D2C8(v40);
          }
          goto LABEL_71;
        }
LABEL_68:
        (*(void (**)(uint64_t))(*(void *)v41 + 112))(v41);
        sub_100F1C4EC(a1);
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    std::mutex::unlock(v34);
    long long v40 = 0;
    char v42 = 1;
    if (!v41) {
      goto LABEL_69;
    }
    goto LABEL_68;
  }
  uint64_t v17 = *(void *)(a1 + 136);
  if (v17)
  {
    char v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 24))(v17);
    char v15 = *(NSObject **)(a1 + 40);
    if ((v18 & 1) == 0)
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Device is not OOS; aborting active OOS countdown...",
          buf,
          2u);
      }
      (*(void (**)(void))(**(void **)(a1 + 136) + 16))(*(void *)(a1 + 136));
      return;
    }
  }
  else
  {
    char v15 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    int v16 = "#I Device is not OOS, and no OOS countdown is active...";
    goto LABEL_56;
  }
}

void sub_100F1D5C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1D658(uint64_t a1, char *a2)
{
}

void sub_100F1D660(void *a1, char *a2)
{
  dispatch_queue_t v6 = 0;
  uint64_t v7 = 0;
  sub_100F1C624(&v6, a1, a2);
  if (v6)
  {
    *dispatch_queue_t v6 = 3;
    char v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (a2[23] >= 0) {
        int v5 = a2;
      }
      else {
        int v5 = *(char **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Exited OOS Region %s", buf, 0xCu);
    }
    sub_100F1CF14((uint64_t)a1);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F1D750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1D770(uint64_t a1, char *a2)
{
}

void sub_100F1D778(void *a1, char *a2, int *a3)
{
  char v15 = 0;
  int v16 = 0;
  sub_100F1C624(&v15, a1, a2);
  if (v15)
  {
    *char v15 = *a3;
    dispatch_queue_t v6 = a1[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *a3;
      id v8 = v7 > 3 ? "Invalid value" : off_101A6F508[v7];
      int v9 = a2[23];
      id v10 = *(char **)a2;
      sub_100058DB0(__p, v8);
      char v11 = v9 >= 0 ? a2 : v10;
      int v12 = v14 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136315394;
      char v18 = v11;
      __int16 v19 = 2080;
      BOOL v20 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Determined state for OOS Region %s as %s", buf, 0x16u);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_100F1CF14((uint64_t)a1);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_100F1D8D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1D8F4(uint64_t a1, char *a2, int *a3)
{
}

BOOL sub_100F1D8FC(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double v12 = sub_100F1D9A4(a2, a3, a5, a6);
  BOOL v13 = v12 > 50.0 && v12 > a4 + a7;
  return !v13
      && ((*(uint64_t (**)(uint64_t, double, double, double))(*(void *)a1 + 40))(a1, a5, a6, a7) & 1) != 0;
}

long double sub_100F1D9A4(double a1, double a2, double a3, double a4)
{
  long double v4 = a1 * 0.0174532925;
  long double v5 = a3 * 0.0174532925;
  double v6 = a2 * 0.0174532925 - a4 * 0.0174532925;
  long double v7 = sin((a1 * 0.0174532925 - a3 * 0.0174532925) * 0.5);
  long double v8 = v7 * v7;
  double v9 = cos(v4);
  long double v10 = v9 * cos(v5);
  long double v11 = sin(v6 * 0.5);
  long double v12 = asin(sqrt(v8 + v10 * (v11 * v11)));
  return (v12 + v12) * 6371.0 * 1000.0;
}

BOOL sub_100F1DA4C(uint64_t a1, double a2, double a3, double a4)
{
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
    uint64_t v9 = *(void *)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  long double v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = 24;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Setting Clear Regions Timer to %lld hours...", (uint8_t *)&buf, 0xCu);
  }
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = 0uLL;
  Registry::getTimerService((uint64_t *)&v64, *(Registry **)(a1 + 96));
  long double v11 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v11 || (uint64_t v12 = *(void *)(a1 + 8), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  char v14 = v13;
  p_shared_weak_owners = &v13->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  sub_100058DB0(&v73, "Clear OOS Regions Timer");
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3321888768;
  double v68 = COERCE_DOUBLE(sub_100F1E744);
  long long v69 = &unk_101A6F350;
  uint64_t v70 = a1;
  uint64_t v71 = v12;
  std::string::size_type v72 = v14;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  int v16 = objc_retainBlock(&buf);
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = xmmword_101590B20;
  ctu::TimerService::throwIfPeriodIsZero();
  std::string __p = v73;
  memset(&v73, 0, sizeof(v73));
  ctu::TimerService::createPeriodicTimerImpl();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string::size_type v17 = v63.__r_.__value_.__r.__words[0];
  v63.__r_.__value_.__r.__words[0] = 0;
  uint64_t v18 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    std::string::size_type v19 = v63.__r_.__value_.__r.__words[0];
    v63.__r_.__value_.__r.__words[0] = 0;
    if (v19) {
      (*(void (**)(std::string::size_type))(*(void *)v19 + 8))(v19);
    }
  }

  if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v73.__r_.__value_.__l.__data_);
  }
  BOOL v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Finished setting up Clear OOS Regions Timer...", (uint8_t *)&__p, 2u);
  }
  if (v72) {
    std::__shared_weak_count::__release_weak(v72);
  }
  std::__shared_weak_count::__release_weak(v14);
  if (v64.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v64.__r_.__value_.__l.__size_);
  }
  *(double *)&long long buf = a2;
  *((double *)&buf + 1) = a3;
  double v68 = a4;
  memset(&__p, 0, sizeof(__p));
  std::to_string(&v63, a2);
  BOOL v21 = std::string::append(&v63, "|", 1uLL);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v64.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v62, a3);
  if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v23 = &v62;
  }
  else {
    char v23 = (std::string *)v62.__r_.__value_.__r.__words[0];
  }
  if ((v62.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v62.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v62.__r_.__value_.__l.__size_;
  }
  char v25 = std::string::append(&v64, (const std::string::value_type *)v23, size);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v65.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  unsigned __int8 v27 = std::string::append(&v65, "|", 1uLL);
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v73.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v73.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v61, a4);
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v29 = &v61;
  }
  else {
    uint64_t v29 = (std::string *)v61.__r_.__value_.__r.__words[0];
  }
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v30 = HIBYTE(v61.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v30 = v61.__r_.__value_.__l.__size_;
  }
  uint64_t v31 = std::string::append(&v73, (const std::string::value_type *)v29, v30);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v73.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v65.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v62.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v64.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v63.__r_.__value_.__l.__data_);
  }
  int v33 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(v73.__r_.__value_.__l.__data_) = 136642819;
    *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Attempting to add geofence for OOS region %{sensitive}s...", (uint8_t *)&v73, 0xCu);
  }
  sub_100F1C624(&v73, (void *)a1, (char *)&__p);
  std::string::size_type v35 = v73.__r_.__value_.__r.__words[0];
  if (v73.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v73.__r_.__value_.__l.__size_);
  }
  if (v35)
  {
    char v36 = *(NSObject **)(a1 + 40);
    BOOL v37 = 0;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v38 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned int v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(v73.__r_.__value_.__l.__data_) = 136642819;
      *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I OOS Geofence %{sensitive}s is already loaded...", (uint8_t *)&v73, 0xCu);
      BOOL v37 = 0;
    }
  }
  else
  {
    *(_OWORD *)&v65.__r_.__value_.__l.__data_ = 0uLL;
    sub_100A38B8C(*(void *)(a1 + 80), (double *)&buf, (uint64_t *)&__p, &v65);
    std::string::size_type v39 = v65.__r_.__value_.__r.__words[0];
    BOOL v37 = v65.__r_.__value_.__r.__words[0] != 0;
    if (v65.__r_.__value_.__r.__words[0])
    {
      std::string::size_type v40 = v65.__r_.__value_.__l.__size_;
      char v42 = *(char **)(a1 + 64);
      unint64_t v41 = *(void *)(a1 + 72);
      if ((unint64_t)v42 >= v41)
      {
        uint64_t v46 = *(char **)(a1 + 56);
        uint64_t v47 = (v42 - v46) >> 4;
        unint64_t v48 = v47 + 1;
        if ((unint64_t)(v47 + 1) >> 60) {
          sub_10006A748();
        }
        uint64_t v49 = v41 - (void)v46;
        if (v49 >> 3 > v48) {
          unint64_t v48 = v49 >> 3;
        }
        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v50 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v50 = v48;
        }
        if (v50 >> 60) {
          sub_10006A7CC();
        }
        unint64_t v51 = (char *)operator new(16 * v50);
        uint64_t v52 = (std::string::size_type *)&v51[16 * v47];
        *uint64_t v52 = v39;
        v52[1] = v40;
        if (v40)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
          uint64_t v46 = *(char **)(a1 + 56);
          char v42 = *(char **)(a1 + 64);
        }
        uint64_t v53 = &v51[16 * v50];
        uint64_t v43 = v52 + 2;
        if (v42 == v46)
        {
          *(void *)(a1 + 56) = v52;
          *(void *)(a1 + 64) = v43;
          *(void *)(a1 + 72) = v53;
        }
        else
        {
          do
          {
            long long v54 = *((_OWORD *)v42 - 1);
            v42 -= 16;
            *((_OWORD *)v52 - 1) = v54;
            v52 -= 2;
            *(void *)char v42 = 0;
            *((void *)v42 + 1) = 0;
          }
          while (v42 != v46);
          uint64_t v46 = *(char **)(a1 + 56);
          uint64_t v55 = *(char **)(a1 + 64);
          *(void *)(a1 + 56) = v52;
          *(void *)(a1 + 64) = v43;
          *(void *)(a1 + 72) = v53;
          while (v55 != v46)
          {
            char v56 = (std::__shared_weak_count *)*((void *)v55 - 1);
            if (v56) {
              sub_10004D2C8(v56);
            }
            v55 -= 16;
          }
        }
        if (v46) {
          operator delete(v46);
        }
      }
      else
      {
        *(void *)char v42 = v65.__r_.__value_.__r.__words[0];
        *((void *)v42 + 1) = v40;
        if (v40) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v43 = v42 + 16;
      }
      *(void *)(a1 + 64) = v43;
      char v57 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        char v58 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          char v58 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v59 = ((uint64_t)v43 - *(void *)(a1 + 56)) >> 4;
        LODWORD(v73.__r_.__value_.__l.__data_) = 136643075;
        *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)v58;
        WORD2(v73.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&v73.__r_.__value_.__r.__words[1] + 6) = v59;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Loaded new OOS Geofence %{sensitive}s, now monitoring %lu...", (uint8_t *)&v73, 0x16u);
      }
      sub_100F1CF14(a1);
    }
    else
    {
      uint64_t v44 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v45 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v45 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        LODWORD(v73.__r_.__value_.__l.__data_) = 136642819;
        *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)v45;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Failed to add OOS Geofence %{sensitive}s...", (uint8_t *)&v73, 0xCu);
      }
    }
    if (v65.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)v65.__r_.__value_.__l.__size_);
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v37;
}

void sub_100F1E1E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,std::__shared_weak_count *a55)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F1E30C(uint64_t a1, int a2, int a3)
{
  double v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 136315394;
    uint64_t v16 = asString();
    __int16 v17 = 2080;
    uint64_t v18 = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I OOS Module showing rats as %s and %s...", (uint8_t *)&v15, 0x16u);
  }
  if ((a2 == 11 || a2 == -1) && (a3 == 11 || a3 == -1))
  {
    int v7 = *(unsigned __int8 *)(a1 + 153);
    uint64_t v8 = *(NSObject **)(a1 + 40);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v9)
      {
        LOWORD(v15) = 0;
        long double v10 = "#I Device has lost service";
LABEL_19:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v15, 2u);
      }
    }
    else if (v9)
    {
      LOWORD(v15) = 0;
      long double v10 = "#I Device still has no service";
      goto LABEL_19;
    }
    *(unsigned char *)(a1 + 153) = 0;
    goto LABEL_21;
  }
  int v11 = *(unsigned __int8 *)(a1 + 153);
  uint64_t v12 = *(NSObject **)(a1 + 40);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v11)
  {
    if (v13)
    {
      LOWORD(v15) = 0;
      char v14 = "#I Device still has service";
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v15, 2u);
    }
  }
  else if (v13)
  {
    LOWORD(v15) = 0;
    char v14 = "#I Device has gained service";
    goto LABEL_15;
  }
  *(unsigned char *)(a1 + 153) = 1;
LABEL_21:
  sub_100F1CF14(a1);
}

void sub_100F1E4D8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long double v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long double v5 = v4;
      if (!a1[5])
      {
LABEL_25:
        sub_10004D2C8(v5);
        return;
      }
      int v6 = *(unsigned __int8 *)(v3 + 153);
      int v7 = *(NSObject **)(v3 + 40);
      BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      if (v6)
      {
        if (v8)
        {
          *(_WORD *)long long v22 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Device has regained service; cancelling delivery of any queued alerts...",
            v22,
            2u);
        }
        goto LABEL_25;
      }
      if (v8)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I OOS countdown has hit zero; dispatching any queued alerts...",
          buf,
          2u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(v3 + 96));
      int v11 = ServiceMap;
      if ((v12 & 0x8000000000000000) != 0)
      {
        BOOL v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          unint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v24 = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, &v24);
      if (v16)
      {
        uint64_t v18 = v16[3];
        __int16 v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          if (!v18) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      __int16 v17 = 0;
      char v19 = 1;
      if (!v18)
      {
LABEL_19:
        uint64_t v20 = *(void *)(v3 + 136);
        *(void *)(v3 + 136) = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
        }
        sub_100F1C4EC(v3);
        uint64_t v21 = *(void *)(v3 + 144);
        if (v21) {
          (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
        }
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        goto LABEL_25;
      }
LABEL_18:
      (*(void (**)(uint64_t))(*(void *)v18 + 112))(v18);
      goto LABEL_19;
    }
  }
}

void sub_100F1E6F0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1E718(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F1E734(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F1E744(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    long double v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long double v5 = v4;
      if (a1[5])
      {
        int v6 = v3[5];
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Clear OOS regions timer has hit zero; clearing all OOS geofences...",
            v7,
            2u);
        }
        sub_100F1C4EC(v3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100F1E7E0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F1E7F4(void *a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double v13 = sub_100F1D9A4(a4, a3, a2, a3);
  double v14 = sub_100F1D9A4(a2, a6, a2, a3);
  double v15 = sub_100F1D9A4(a5, a3, a2, a3);
  double v16 = sub_100F1D9A4(a2, a7, a2, a3);
  double v17 = (v13 + v14 + v15 + v16) * 0.25;
  uint64_t v18 = a1[5];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = 134218752;
    double v21 = v13 - v17;
    __int16 v22 = 2048;
    double v23 = v14 - v17;
    __int16 v24 = 2048;
    double v25 = v15 - v17;
    __int16 v26 = 2048;
    double v27 = v16 - v17;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I OOS Module approximated WEA geofence polygon radius with accuracy: N(%f), E(%f), S(%f), W(%f)", (uint8_t *)&v20, 0x2Au);
  }
  return (*(uint64_t (**)(void *, double, double, double))(*a1 + 24))(a1, a2, a3, v17);
}

void sub_100F1E9BC(uint64_t a1, double a2, double a3, double a4)
{
  BOOL v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    *(double *)v226 = a2;
    *(_WORD *)&v226[8] = 2048;
    *(double *)&v226[10] = a3;
    *(_WORD *)&v226[18] = 2048;
    *(double *)&v226[20] = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Attempting to load all OOS Geofences in proximity to WEA geofence point %f, %f, %f...", buf, 0x20u);
  }
  BOOL v207 = sub_100F1D8FC(a1, a2, a3, a4, 37.103384, -119.63562, 3890.55709);
  BOOL v206 = sub_100F1D8FC(a1, a2, a3, a4, 38.2079717, -118.657837, 2875.21697);
  BOOL v205 = sub_100F1D8FC(a1, a2, a3, a4, 34.4748635, -118.712769, 2848.5006);
  BOOL v204 = sub_100F1D8FC(a1, a2, a3, a4, 34.048108, -119.558716, 1838.35782);
  BOOL v203 = sub_100F1D8FC(a1, a2, a3, a4, 41.9799108, -115.427856, 2828.41633);
  BOOL v202 = sub_100F1D8FC(a1, a2, a3, a4, 32.8195947, -118.405151, 1479.5603);
  BOOL v201 = sub_100F1D8FC(a1, a2, a3, a4, 36.3991782, -121.876831, 2781.82243);
  BOOL v200 = sub_100F1D8FC(a1, a2, a3, a4, 40.3339831, -123.678589, 5012.10879);
  BOOL v199 = sub_100F1D8FC(a1, a2, a3, a4, 41.2901898, -116.251831, 2296.24251);
  BOOL v198 = sub_100F1D8FC(a1, a2, a3, a4, 41.8327349, -119.558716, 5475.6327);
  BOOL v197 = sub_100F1D8FC(a1, a2, a3, a4, 32.6347489, -118.064575, 6270.3423);
  BOOL v196 = sub_100F1D8FC(a1, a2, a3, a4, 36.6551994, -121.118774, 6209.28435);
  BOOL v195 = sub_100F1D8FC(a1, a2, a3, a4, 40.9342651, -121.723022, 5532.31555);
  BOOL v194 = sub_100F1D8FC(a1, a2, a3, a4, 41.5866882, -115.20813, 6402.18978);
  BOOL v193 = sub_100F1D8FC(a1, a2, a3, a4, 37.6533831, -119.899292, 2736.66073);
  BOOL v192 = sub_100F1D8FC(a1, a2, a3, a4, 40.2920966, -122.601929, 3850.49979);
  BOOL v191 = sub_100F1D8FC(a1, a2, a3, a4, 41.2075889, -121.272583, 2764.29171);
  BOOL v190 = sub_100F1D8FC(a1, a2, a3, a4, 41.86547, -116.010132, 5830.58718);
  BOOL v189 = sub_100F1D8FC(a1, a2, a3, a4, 33.9752534, -119.624634, 3818.89925);
  BOOL v188 = sub_100F1D8FC(a1, a2, a3, a4, 39.499802, -114.691772, 2667.77789);
  BOOL v187 = sub_100F1D8FC(a1, a2, a3, a4, 35.2680468, -122.371216, 1000.0);
  BOOL v186 = sub_100F1D8FC(a1, a2, a3, a4, 41.8736511, -115.427856, 3439.32709);
  BOOL v185 = sub_100F1D8FC(a1, a2, a3, a4, 34.3298282, -118.119507, 6392.08253);
  BOOL v184 = sub_100F1D8FC(a1, a2, a3, a4, 41.7344293, -123.986206, 3656.00197);
  BOOL v183 = sub_100F1D8FC(a1, a2, a3, a4, 39.9981638, -123.931274, 4192.92669);
  BOOL v182 = sub_100F1D8FC(a1, a2, a3, a4, 41.7917926, -123.755493, 10368.5502);
  BOOL v181 = sub_100F1D8FC(a1, a2, a3, a4, 41.9962427, -120.723267, 2000.0);
  BOOL v180 = sub_100F1D8FC(a1, a2, a3, a4, 36.0180036, -117.789917, 7130.23409);
  BOOL v179 = sub_100F1D8FC(a1, a2, a3, a4, 40.7680616, -121.503296, 2771.47775);
  BOOL v178 = sub_100F1D8FC(a1, a2, a3, a4, 38.6039931, -120.140991, 3440.07338);
  BOOL v177 = sub_100F1D8FC(a1, a2, a3, a4, 40.8761413, -122.305298, 3330.72813);
  BOOL v176 = sub_100F1D8FC(a1, a2, a3, a4, 38.6469081, -114.6698, 2699.94747);
  BOOL v175 = sub_100F1D8FC(a1, a2, a3, a4, 33.1421507, -116.790161, 1000.0);
  BOOL v174 = sub_100F1D8FC(a1, a2, a3, a4, 41.7754083, -123.041382, 11131.0791);
  BOOL v173 = sub_100F1D8FC(a1, a2, a3, a4, 40.0822744, -119.745483, 5125.71665);
  BOOL v172 = sub_100F1D8FC(a1, a2, a3, a4, 35.8222672, -114.702759, 1152.53366);
  BOOL v171 = sub_100F1D8FC(a1, a2, a3, a4, 39.1598817, -123.64563, 2680.67089);
  BOOL v170 = sub_100F1D8FC(a1, a2, a3, a4, 35.1693179, -120.426636, 2824.18759);
  BOOL v169 = sub_100F1D8FC(a1, a2, a3, a4, 41.1745192, -120.151978, 5887.47949);
  BOOL v168 = sub_100F1D8FC(a1, a2, a3, a4, 41.86547, -119.020386, 6558.09369);
  BOOL v167 = sub_100F1D8FC(a1, a2, a3, a4, 35.5992522, -120.910034, 2973.90783);
  BOOL v166 = sub_100F1D8FC(a1, a2, a3, a4, 40.1914629, -121.525269, 4750.91361);
  BOOL v165 = sub_100F1D8FC(a1, a2, a3, a4, 33.224903, -117.581177, 1174.33696);
  BOOL v164 = sub_100F1D8FC(a1, a2, a3, a4, 35.920196, -114.505005, 1409.27083);
  BOOL v163 = sub_100F1D8FC(a1, a2, a3, a4, 36.1245646, -113.977661, 1928.06813);
  BOOL v162 = sub_100F1D8FC(a1, a2, a3, a4, 41.257162, -123.612671, 2910.69928);
  BOOL v161 = sub_100F1D8FC(a1, a2, a3, a4, 40.3423573, -117.614136, 1983.39301);
  BOOL v160 = sub_100F1D8FC(a1, a2, a3, a4, 39.0063789, -120.525513, 3008.25182);
  BOOL v159 = sub_100F1D8FC(a1, a2, a3, a4, 41.2323801, -122.65686, 5507.57456);
  BOOL v158 = sub_100F1D8FC(a1, a2, a3, a4, 35.2590764, -120.50354, 3214.56888);
  BOOL v157 = sub_100F1D8FC(a1, a2, a3, a4, 36.3637984, -116.724243, 9089.62536);
  BOOL v156 = sub_100F1D8FC(a1, a2, a3, a4, 33.3534732, -118.427124, 3674.50302);
  BOOL v155 = sub_100F1D8FC(a1, a2, a3, a4, 38.8268704, -123.217163, 2730.17151);
  BOOL v154 = sub_100F1D8FC(a1, a2, a3, a4, 37.5489325, -122.426147, 2038.86896);
  BOOL v153 = sub_100F1D8FC(a1, a2, a3, a4, 41.3149498, -120.042114, 2759.76835);
  BOOL v152 = sub_100F1D8FC(a1, a2, a3, a4, 35.6439051, -120.206909, 7242.11046);
  BOOL v151 = sub_100F1D8FC(a1, a2, a3, a4, 35.7866268, -115.933228, 2207.91229);
  BOOL v150 = sub_100F1D8FC(a1, a2, a3, a4, 37.4007099, -115.53772, 2648.1002);
  BOOL v149 = sub_100F1D8FC(a1, a2, a3, a4, 35.7152979, -118.064575, 5349.62303);
  BOOL v148 = sub_100F1D8FC(a1, a2, a3, a4, 37.0770931, -121.470337, 3907.69299);
  BOOL v147 = sub_100F1D8FC(a1, a2, a3, a4, 40.3004759, -124.30481, 3358.01115);
  BOOL v146 = sub_100F1D8FC(a1, a2, a3, a4, 39.0234513, -122.338257, 3007.52925);
  BOOL v145 = sub_100F1D8FC(a1, a2, a3, a4, 33.7745812, -118.55896, 1931.9518);
  BOOL v144 = sub_100F1D8FC(a1, a2, a3, a4, 37.4792173, -121.536255, 3061.75551);
  BOOL v143 = sub_100F1D8FC(a1, a2, a3, a4, 36.8224775, -118.910522, 6267.12604);
  BOOL v142 = sub_100F1D8FC(a1, a2, a3, a4, 35.3039184, -118.427124, 5376.95079);
  BOOL v141 = sub_100F1D8FC(a1, a2, a3, a4, 33.5459729, -117.394409, 1050.4742);
  BOOL v140 = sub_100F1D8FC(a1, a2, a3, a4, 41.4962352, -116.098022, 3203.22894);
  BOOL v139 = sub_100F1D8FC(a1, a2, a3, a4, 32.9487585, -117.328491, 1249.09616);
  BOOL v138 = sub_100F1D8FC(a1, a2, a3, a4, 38.0264586, -114.197388, 4083.26082);
  BOOL v137 = sub_100F1D8FC(a1, a2, a3, a4, 38.655488, -114.801636, 6023.7809);
  BOOL v136 = sub_100F1D8FC(a1, a2, a3, a4, 37.4356123, -115.449829, 5045.81452);
  BOOL v135 = sub_100F1D8FC(a1, a2, a3, a4, 41.7344293, -116.207886, 8163.15452);
  BOOL v134 = sub_100F1D8FC(a1, a2, a3, a4, 38.8782049, -120.228882, 2691.28269);
  BOOL v133 = sub_100F1D8FC(a1, a2, a3, a4, 38.7583668, -114.043579, 1089.77915);
  BOOL v132 = sub_100F1D8FC(a1, a2, a3, a4, 38.2770008, -121.744995, 1000.0);
  BOOL v131 = sub_100F1D8FC(a1, a2, a3, a4, 37.9571921, -114.230347, 2496.49588);
  BOOL v130 = sub_100F1D8FC(a1, a2, a3, a4, 38.2511226, -115.724487, 4001.76095);
  BOOL v129 = sub_100F1D8FC(a1, a2, a3, a4, 41.2323801, -120.393677, 3899.67676);
  BOOL v128 = sub_100F1D8FC(a1, a2, a3, a4, 35.4472459, -120.811157, 2814.58556);
  BOOL v127 = sub_100F1D8FC(a1, a2, a3, a4, 33.2432817, -119.470825, 5490.04615);
  BOOL v126 = sub_100F1D8FC(a1, a2, a3, a4, 40.8927533, -121.085815, 6532.04983);
  BOOL v125 = sub_100F1D8FC(a1, a2, a3, a4, 36.6287537, -120.514526, 2773.65546);
  BOOL v124 = sub_100F1D8FC(a1, a2, a3, a4, 38.2597497, -120.415649, 3462.89199);
  BOOL v123 = sub_100F1D8FC(a1, a2, a3, a4, 34.7280696, -119.207153, 7114.85239);
  BOOL v122 = sub_100F1D8FC(a1, a2, a3, a4, 41.7426272, -122.140503, 5841.7059);
  BOOL v121 = sub_100F1D8FC(a1, a2, a3, a4, 36.9279389, -116.636353, 1000.0);
  BOOL v120 = sub_100F1D8FC(a1, a2, a3, a4, 41.4138954, -114.713745, 2755.59091);
  BOOL v119 = sub_100F1D8FC(a1, a2, a3, a4, 40.5597212, -122.052612, 3939.23586);
  BOOL v118 = sub_100F1D8FC(a1, a2, a3, a4, 36.3106987, -115.680542, 2784.95803);
  BOOL v117 = sub_100F1D8FC(a1, a2, a3, a4, 40.7347709, -123.19519, 5404.78826);
  BOOL v116 = sub_100F1D8FC(a1, a2, a3, a4, 38.3804215, -114.746704, 3310.43295);
  BOOL v115 = sub_100F1D8FC(a1, a2, a3, a4, 37.3483259, -115.658569, 2893.60385);
  BOOL v114 = sub_100F1D8FC(a1, a2, a3, a4, 38.9038582, -114.515991, 3939.13183);
  BOOL v113 = sub_100F1D8FC(a1, a2, a3, a4, 39.3640322, -113.988647, 1124.41275);
  BOOL v112 = sub_100F1D8FC(a1, a2, a3, a4, 33.6466354, -118.141479, 1945.12875);
  BOOL v111 = sub_100F1D8FC(a1, a2, a3, a4, 33.9752534, -120.075073, 1766.18765);
  BOOL v110 = sub_100F1D8FC(a1, a2, a3, a4, 36.3284026, -117.713013, 3117.87973);
  BOOL v109 = sub_100F1D8FC(a1, a2, a3, a4, 37.514083, -114.252319, 1652.54055);
  BOOL v108 = sub_100F1D8FC(a1, a2, a3, a4, 38.8696517, -117.493286, 2390.32147);
  BOOL v107 = sub_100F1D8FC(a1, a2, a3, a4, 36.1334382, -120.602417, 3555.31653);
  BOOL v106 = sub_100F1D8FC(a1, a2, a3, a4, 33.6923522, -118.591919, 2061.29748);
  BOOL v105 = sub_100F1D8FC(a1, a2, a3, a4, 32.5977338, -117.350464, 1235.8409);
  BOOL v104 = sub_100F1D8FC(a1, a2, a3, a4, 33.6466354, -118.086548, 1893.71217);
  BOOL v103 = sub_100F1D8FC(a1, a2, a3, a4, 40.1998548, -119.185181, 1301.07311);
  BOOL v102 = sub_100F1D8FC(a1, a2, a3, a4, 39.0405195, -114.647827, 3006.44523);
  BOOL v101 = sub_100F1D8FC(a1, a2, a3, a4, 41.8163611, -115.010376, 4051.28587);
  BOOL v100 = sub_100F1D8FC(a1, a2, a3, a4, 37.7490006, -122.843628, 3737.18804);
  BOOL v99 = sub_100F1D8FC(a1, a2, a3, a4, 37.7490006, -123.019409, 2995.75174);
  BOOL v98 = sub_100F1D8FC(a1, a2, a3, a4, 40.7181192, -115.08728, 2934.11401);
  BOOL v97 = sub_100F1D8FC(a1, a2, a3, a4, 41.0254992, -120.042114, 4973.7915);
  BOOL v96 = sub_100F1D8FC(a1, a2, a3, a4, 39.0831721, -119.415894, 1128.3857);
  BOOL v95 = sub_100F1D8FC(a1, a2, a3, a4, 37.4617784, -118.712769, 5805.13049);
  BOOL v94 = sub_100F1D8FC(a1, a2, a3, a4, 36.05354, -114.01062, 4065.51403);
  BOOL v213 = sub_100F1D8FC(a1, a2, a3, a4, 38.2338653, -114.702759, 4801.81957);
  BOOL v93 = sub_100F1D8FC(a1, a2, a3, a4, 41.7016272, -115.08728, 5195.4763);
  BOOL v92 = sub_100F1D8FC(a1, a2, a3, a4, 38.96368, -117.57019, 3429.30875);
  BOOL v91 = sub_100F1D8FC(a1, a2, a3, a4, 33.8384826, -120.009155, 1810.7869);
  BOOL v90 = sub_100F1D8FC(a1, a2, a3, a4, 39.9813293, -122.799683, 6540.26303);
  BOOL v89 = sub_100F1D8FC(a1, a2, a3, a4, 39.8970942, -114.87854, 6643.65794);
  BOOL v88 = sub_100F1D8FC(a1, a2, a3, a4, 40.5012693, -120.756226, 4150.80966);
  BOOL v209 = sub_100F1D8FC(a1, a2, a3, a4, 41.2323801, -116.032104, 6157.7353);
  BOOL v87 = sub_100F1D8FC(a1, a2, a3, a4, 35.3128839, -115.109253, 2040.30802);
  BOOL v86 = sub_100F1D8FC(a1, a2, a3, a4, 36.8664374, -115.9552, 1000.0);
  BOOL v211 = sub_100F1D8FC(a1, a2, a3, a4, 37.5489325, -113.933716, 3426.72679);
  BOOL v85 = sub_100F1D8FC(a1, a2, a3, a4, 40.6431355, -121.239624, 2937.40144);
  BOOL v84 = sub_100F1D8FC(a1, a2, a3, a4, 40.834593, -114.867554, 2779.93099);
  BOOL v83 = sub_100F1D8FC(a1, a2, a3, a4, 37.3483259, -113.988647, 1449.33625);
  BOOL v210 = sub_100F1D8FC(a1, a2, a3, a4, 38.655488, -120.404663, 4855.5858);
  BOOL v82 = sub_100F1D8FC(a1, a2, a3, a4, 34.5110831, -120.481567, 5122.99133);
  BOOL v81 = sub_100F1D8FC(a1, a2, a3, a4, 38.2252351, -115.010376, 2874.5436);
  BOOL v80 = sub_100F1D8FC(a1, a2, a3, a4, 38.7926268, -114.559937, 3007.78547);
  BOOL v79 = sub_100F1D8FC(a1, a2, a3, a4, 41.9799108, -114.021606, 12860.8947);
  BOOL v78 = sub_100F1D8FC(a1, a2, a3, a4, 38.4750942, -116.054077, 6061.56642);
  BOOL v77 = sub_100F1D8FC(a1, a2, a3, a4, 34.9354819, -120.2948, 2998.03497);
  BOOL v76 = sub_100F1D8FC(a1, a2, a3, a4, 37.2521936, -118.174438, 5821.16617);
  BOOL v75 = sub_100F1D8FC(a1, a2, a3, a4, 39.219487, -113.999634, 1124.41275);
  BOOL v74 = sub_100F1D8FC(a1, a2, a3, a4, 32.7364616, -117.537231, 1628.61336);
  BOOL v73 = sub_100F1D8FC(a1, a2, a3, a4, 40.3256079, -116.724243, 1047.50463);
  BOOL v72 = sub_100F1D8FC(a1, a2, a3, a4, 41.9717432, -122.195435, 5538.93425);
  BOOL v71 = sub_100F1D8FC(a1, a2, a3, a4, 41.0172104, -120.844116, 7829.17805);
  BOOL v70 = sub_100F1D8FC(a1, a2, a3, a4, 40.0906797, -120.020142, 2997.09914);
  BOOL v69 = sub_100F1D8FC(a1, a2, a3, a4, 35.9468828, -115.669556, 4020.44214);
  BOOL v68 = sub_100F1D8FC(a1, a2, a3, a4, 35.8935001, -117.383423, 4922.96735);
  BOOL v67 = sub_100F1D8FC(a1, a2, a3, a4, 38.7754989, -114.823608, 7083.3572);
  BOOL v66 = sub_100F1D8FC(a1, a2, a3, a4, 38.1647952, -114.724731, 4094.68056);
  BOOL v65 = sub_100F1D8FC(a1, a2, a3, a4, 40.2250241, -118.306274, 2010.05963);
  BOOL v64 = sub_100F1D8FC(a1, a2, a3, a4, 37.2521936, -122.217407, 3881.22242);
  BOOL v63 = sub_100F1D8FC(a1, a2, a3, a4, 39.4064887, -122.997437, 5735.36059);
  BOOL v62 = sub_100F1D8FC(a1, a2, a3, a4, 39.6183835, -120.591431, 5947.146);
  BOOL v61 = sub_100F1D8FC(a1, a2, a3, a4, 41.6934241, -115.856323, 3658.6703);
  BOOL v219 = sub_100F1D8FC(a1, a2, a3, a4, 39.2620313, -114.691772, 7643.58434);
  BOOL v60 = sub_100F1D8FC(a1, a2, a3, a4, 33.6191936, -115.999146, 3255.85208);
  BOOL v59 = sub_100F1D8FC(a1, a2, a3, a4, 37.5315098, -115.603638, 6436.01791);
  BOOL v58 = sub_100F1D8FC(a1, a2, a3, a4, 35.3487356, -116.845093, 1000.0);
  BOOL v57 = sub_100F1D8FC(a1, a2, a3, a4, 34.6015631, -119.767456, 4697.25793);
  BOOL v56 = sub_100F1D8FC(a1, a2, a3, a4, 37.78374, -122.887573, 3690.46764);
  BOOL v55 = sub_100F1D8FC(a1, a2, a3, a4, 42.0370542, -114.933472, 2568.57945);
  BOOL v54 = sub_100F1D8FC(a1, a2, a3, a4, 35.0974397, -114.450073, 1000.0);
  BOOL v53 = sub_100F1D8FC(a1, a2, a3, a4, 37.7142448, -123.052368, 2492.38831);
  BOOL v52 = sub_100F1D8FC(a1, a2, a3, a4, 40.1494881, -114.34021, 1000.0);
  BOOL v51 = sub_100F1D8FC(a1, a2, a3, a4, 36.1600529, -118.624878, 4074.67122);
  BOOL v50 = sub_100F1D8FC(a1, a2, a3, a4, 36.1866585, -116.339722, 3123.51304);
  BOOL v49 = sub_100F1D8FC(a1, a2, a3, a4, 32.7457024, -118.042603, 2969.91351);
  BOOL v48 = sub_100F1D8FC(a1, a2, a3, a4, 38.0351123, -116.07605, 15179.5766);
  BOOL v47 = sub_100F1D8FC(a1, a2, a3, a4, 33.2065203, -117.877808, 1072.12796);
  BOOL v214 = sub_100F1D8FC(a1, a2, a3, a4, 35.8133586, -121.085815, 3138.2572);
  BOOL v220 = sub_100F1D8FC(a1, a2, a3, a4, 38.6039931, -115.691528, 3677.16264);
  BOOL v46 = sub_100F1D8FC(a1, a2, a3, a4, 41.5373659, -121.591187, 2587.87098);
  BOOL v45 = sub_100F1D8FC(a1, a2, a3, a4, 33.9205714, -115.900269, 3198.74008);
  BOOL v44 = sub_100F1D8FC(a1, a2, a3, a4, 40.6848035, -121.810913, 4150.70334);
  BOOL v43 = sub_100F1D8FC(a1, a2, a3, a4, 38.1561568, -122.788696, 3851.62585);
  BOOL v42 = sub_100F1D8FC(a1, a2, a3, a4, 37.7576869, -122.77771, 3505.04919);
  BOOL v41 = sub_100F1D8FC(a1, a2, a3, a4, 38.5180862, -116.350708, 12420.8634);
  BOOL v40 = sub_100F1D8FC(a1, a2, a3, a4, 33.9934729, -116.658325, 3045.14158);
  BOOL v221 = sub_100F1D8FC(a1, a2, a3, a4, 40.3339831, -118.800659, 1147.07684);
  BOOL v39 = sub_100F1D8FC(a1, a2, a3, a4, 38.5782318, -115.735474, 2850.07857);
  BOOL v38 = sub_100F1D8FC(a1, a2, a3, a4, 40.8096515, -122.162476, 5235.07936);
  BOOL v37 = sub_100F1D8FC(a1, a2, a3, a4, 35.9913408, -114.373169, 1546.27578);
  BOOL v222 = sub_100F1D8FC(a1, a2, a3, a4, 35.8489871, -116.251831, 3125.44252);
  BOOL v36 = sub_100F1D8FC(a1, a2, a3, a4, 38.2856248, -119.701538, 4798.01371);
  BOOL v212 = sub_100F1D8FC(a1, a2, a3, a4, 33.6923522, -118.504028, 2529.10398);
  BOOL v216 = sub_100F1D8FC(a1, a2, a3, a4, 39.8970942, -123.491821, 6285.21792);
  BOOL v35 = sub_100F1D8FC(a1, a2, a3, a4, 32.7549423, -117.460327, 1446.35701);
  BOOL v34 = sub_100F1D8FC(a1, a2, a3, a4, 37.7229353, -122.920532, 3096.08505);
  BOOL v33 = sub_100F1D8FC(a1, a2, a3, a4, 41.3974149, -115.043335, 6496.5515);
  BOOL v32 = sub_100F1D8FC(a1, a2, a3, a4, 36.3903347, -117.284546, 13031.8173);
  BOOL v31 = sub_100F1D8FC(a1, a2, a3, a4, 38.0783655, -118.284302, 1511.26049);
  BOOL v30 = sub_100F1D8FC(a1, a2, a3, a4, 40.9923378, -122.294312, 2773.33134);
  BOOL v29 = sub_100F1D8FC(a1, a2, a3, a4, 40.1746761, -120.569458, 3857.62841);
  BOOL v28 = sub_100F1D8FC(a1, a2, a3, a4, 40.4511271, -118.02063, 4659.8097);
  BOOL v27 = sub_100F1D8FC(a1, a2, a3, a4, 40.5930994, -115.383911, 5859.16441);
  BOOL v224 = sub_100F1D8FC(a1, a2, a3, a4, 35.3487356, -120.042114, 4226.76241);
  BOOL v218 = sub_100F1D8FC(a1, a2, a3, a4, 34.211802, -113.999634, 10883.0231);
  BOOL v26 = sub_100F1D8FC(a1, a2, a3, a4, 37.7924223, -123.118286, 4161.18314);
  BOOL v217 = sub_100F1D8FC(a1, a2, a3, a4, 37.9051994, -114.043579, 2886.98391);
  BOOL v215 = sub_100F1D8FC(a1, a2, a3, a4, 38.4578902, -114.724731, 4023.36168);
  BOOL v208 = sub_100F1D8FC(a1, a2, a3, a4, 40.9176635, -118.394165, 1000.0);
  BOOL v24 = sub_100F1D8FC(a1, a2, a3, a4, 38.7240903, -117.702026, 1704.35686);
  BOOL v25 = sub_100F1D8FC(a1, a2, a3, a4, 41.6523928, -114.977417, 6025.96476);
  BOOL v23 = sub_100F1D8FC(a1, a2, a3, a4, 40.9674557, -119.701538, 2918.4141);
  BOOL v22 = sub_100F1D8FC(a1, a2, a3, a4, 37.5663511, -114.373169, 1747.19047);
  BOOL v21 = sub_100F1D8FC(a1, a2, a3, a4, 36.0890603, -116.295776, 4061.89008);
  BOOL v20 = sub_100F1D8FC(a1, a2, a3, a4, 37.9398653, -114.977417, 5198.30921);
  BOOL v223 = sub_100F1D8FC(a1, a2, a3, a4, 40.9840448, -121.876831, 3914.34481);
  BOOL v9 = sub_100F1D8FC(a1, a2, a3, a4, 41.3149498, -114.75769, 2597.33793);
  BOOL v10 = sub_100F1D8FC(a1, a2, a3, a4, 39.9055224, -115.471802, 1445.43892);
  BOOL v11 = sub_100F1D8FC(a1, a2, a3, a4, 40.0822744, -115.691528, 3708.78011);
  BOOL v12 = sub_100F1D8FC(a1, a2, a3, a4, 33.9479168, -119.734497, 5079.6738);
  BOOL v13 = sub_100F1D8FC(a1, a2, a3, a4, 35.0524836, -120.305786, 2993.81144);
  BOOL v14 = sub_100F1D8FC(a1, a2, a3, a4, 36.3461025, -117.4823, 5997.90737);
  BOOL v15 = sub_100F1D8FC(a1, a2, a3, a4, 40.5430259, -117.130737, 1347.45793);
  BOOL v16 = sub_100F1D8FC(a1, a2, a3, a4, 35.7420537, -115.263062, 1086.61871);
  BOOL v17 = sub_100F1D8FC(a1, a2, a3, a4, 37.7403132, -122.689819, 3069.43685);
  uint64_t v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = v206
        + v207
        + v205
        + v204
        + v203
        + v202
        + v201
        + v200
        + v199
        + v198
        + v197
        + v196
        + v195
        + v194
        + v193
        + v192
        + v191
        + v190
        + v189
        + v188
        + v187
        + v186
        + v185
        + v184
        + v183
        + v182
        + v181
        + v180
        + v179
        + v178
        + v177
        + v176
        + v175
        + v174
        + v173
        + v172
        + v171
        + v170
        + v169
        + v168
        + v167
        + v166
        + v165
        + v164
        + v163
        + v162
        + v161
        + v160
        + v159
        + v158
        + v157
        + v156
        + v155
        + v154
        + v153
        + v152
        + v151
        + v150
        + v149
        + v148
        + v147
        + v146
        + v145
        + v144
        + v143
        + v142
        + v141
        + v140
        + v139
        + v138
        + v137
        + v136
        + v135
        + v134
        + v133
        + v132
        + v131
        + v130
        + v129
        + v128
        + v127
        + v126
        + v125
        + v124
        + v123
        + v122
        + v121
        + v120
        + v119
        + v118
        + v117
        + v116
        + v115
        + v114
        + v113
        + v112
        + v111
        + v110
        + v109
        + v108
        + v107
        + v106
        + v105
        + v104
        + v103
        + v102
        + v101
        + v100
        + v99
        + v98
        + v97
        + v96
        + v95
        + v94
        + v213
        + v93
        + v92
        + v91
        + v90
        + v89
        + v88;
    *(_DWORD *)long long buf = 67109888;
    *(_DWORD *)v226 = v19
                    + v209
                    + v87
                    + v86
                    + v211
                    + v85
                    + v84
                    + v83
                    + v210
                    + v82
                    + v81
                    + v80
                    + v79
                    + v78
                    + v77
                    + v76
                    + v75
                    + v74
                    + v73
                    + v72
                    + v71
                    + v70
                    + v69
                    + v68
                    + v67
                    + v66
                    + v65
                    + v64
                    + v63
                    + v62
                    + v61
                    + v219
                    + v60
                    + v59
                    + v58
                    + v57
                    + v56
                    + v55
                    + v54
                    + v53
                    + v52
                    + v51
                    + v50
                    + v49
                    + v48
                    + v47
                    + v214
                    + v220
                    + v46
                    + v45
                    + v44
                    + v43
                    + v42
                    + v41
                    + v40
                    + v221
                    + v39
                    + v38
                    + v37
                    + v222
                    + v36
                    + v212
                    + v216
                    + v35
                    + v34
                    + v33
                    + v32
                    + v31
                    + v30
                    + v29
                    + v28
                    + v27
                    + v224
                    + v218
                    + v26
                    + v217
                    + v215
                    + v208
                    + v24
                    + v25
                    + v23
                    + v22
                    + v21
                    + v20
                    + v223
                    + v9
                    + v10
                    + v11
                    + v12
                    + v13
                    + v14
                    + v15
                    + v16
                    + v17;
    *(_WORD *)&v226[4] = 2048;
    *(double *)&v226[6] = a2;
    *(_WORD *)&v226[14] = 2048;
    *(double *)&v226[16] = a3;
    *(_WORD *)&v226[24] = 2048;
    *(double *)&v226[26] = a4;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Loaded %d new OOS Geofences in proximity to WEA geofence point %f, %f, %f.", buf, 0x26u);
  }
}

void sub_100F219A4()
{
}

__n128 sub_100F219B8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A6F448;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F21A0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6F448;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F21A44(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F21A8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F21ACC()
{
}

void sub_100F21AD8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6F4C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F21AF8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6F4C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F21B4C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 64))();
}

void BasebandSettings::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F22294(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, dispatch_object_t object, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, dispatch_object_t a18, dispatch_object_t a19, dispatch_object_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_100F22678(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va1);
  JUMPOUT(0x100F225B8);
}

void sub_100F226A0()
{
}

const char *sub_100F226A8(int a1)
{
  uint64_t v1 = "set.bb.?";
  if (a1 == 2) {
    uint64_t v1 = "set.bb.2";
  }
  if (a1 == 1) {
    return "set.bb.1";
  }
  else {
    return v1;
  }
}

void *sub_100F226D4(uint64_t a1)
{
  sub_1000346F8(a1 + 40, *(void **)(a1 + 48));

  return sub_100F27A10((void *)a1);
}

void sub_100F22714(uint64_t a1)
{
  *(void *)a1 = off_101A6F538;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 808);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000346F8(a1 + 776, *(void **)(a1 + 784));
  sub_10094E754((void *)(a1 + 736));
  sub_1000346F8(a1 + 712, *(void **)(a1 + 720));
  sub_100F27A10((void *)(a1 + 672));
  sub_1000346F8(a1 + 648, *(void **)(a1 + 656));
  sub_100119D90(*(void **)(a1 + 632));
  sub_10005D0E4(a1 + 600, *(void **)(a1 + 608));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 592);
  if (v3) {
    sub_10004D2C8(v3);
  }
  long double v4 = *(std::__shared_weak_count **)(a1 + 576);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long double v5 = *(std::__shared_weak_count **)(a1 + 560);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 544);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 520);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  BOOL v8 = *(std::__shared_weak_count **)(a1 + 504);
  if (v8) {
    sub_10004D2C8(v8);
  }
  BOOL v9 = *(std::__shared_weak_count **)(a1 + 488);
  if (v9) {
    sub_10004D2C8(v9);
  }
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 296));
  int v19 = (void **)(a1 + 264);
  sub_10008A88C(&v19);
  sub_1000346F8(a1 + 240, *(void **)(a1 + 248));
  sub_100060644((void *)(a1 + 208));
  sub_10081A370((void *)(a1 + 176));
  uint64_t v10 = *(NSObject **)(a1 + 168);
  if (v10)
  {
    dispatch_group_leave(v10);
    BOOL v11 = *(NSObject **)(a1 + 168);
    if (v11) {
      dispatch_release(v11);
    }
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 152);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 120);
  if (v14) {
    sub_10004D2C8(v14);
  }
  BOOL v15 = *(std::__shared_weak_count **)(a1 + 104);
  if (v15) {
    sub_10004D2C8(v15);
  }
  sub_100160A84((atomic_uint **)(a1 + 72));
  uint64_t v16 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  BOOL v17 = *(NSObject **)(a1 + 56);
  if (v17) {
    dispatch_release(v17);
  }
  uint64_t v18 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  BasebandSettingsInterface::~BasebandSettingsInterface((BasebandSettingsInterface *)a1);
}

void sub_100F22914(uint64_t a1)
{
  sub_100F22714(a1);

  operator delete();
}

void sub_100F2294C(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_100F22A44(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = 0uLL;
  sub_10003E168(&v4, (void *)(a1 + 8));
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = 0uLL;
  operator new();
}

uint64_t sub_100F22BA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  BOOL v11 = 0;
  BasebandSettings::getModel_sync(a1, a2, &v10);
  if (v10)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 80))(v10, a3);
  }
  else
  {
    int v7 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = asString(a3);
      *(_DWORD *)long long buf = 136315138;
      uint64_t v13 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find model. Not lining up file %s", buf, 0xCu);
    }
    uint64_t v6 = 0;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v6;
}

void sub_100F22CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BasebandSettings::getModel_sync@<X0>(uint64_t result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 608);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = result + 608;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != result + 608 && *(_DWORD *)(v4 + 32) <= a2)
  {
    uint64_t v9 = *(void *)(v4 + 40);
    uint64_t v8 = *(void *)(v4 + 48);
    *a3 = v9;
    a3[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

void BasebandSettings::compareAndLineupFile_sync(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((sub_100F22BA0((uint64_t)a1, a2, a3) & 1) == 0)
  {
    uint64_t v14 = 0;
    BOOL v15 = 0;
    uint64_t v8 = a1[8];
    uint64_t v9 = sub_100F22BA0((uint64_t)a1, a2, 0);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 48))(&v14, v8, a3, a4, v9);
    uint64_t v10 = v14;
    if (!v14) {
      goto LABEL_17;
    }
    BOOL v11 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = (std::__shared_weak_count *)a1[2];
    uint64_t v17 = a1[1];
    if (v12)
    {
      uint64_t v18 = std::__shared_weak_count::lock(v12);
      if (v18)
      {
        sub_10094E7D8((uint64_t)v19, (uint64_t)(a1 + 92));
        int v13 = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t *, void *))(*(void *)v10 + 32))(v10, a1 + 12, a2, &v17, v19);
        sub_10094E754(v19);
        if (v18) {
          sub_10004D2C8(v18);
        }
        if (v13 && (*(unsigned int (**)(uint64_t))(*(void *)v10 + 24))(v10))
        {
          v16[0] = v10;
          v16[1] = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_100F23458((uint64_t)a1, a2, v16);
          if (!v11) {
            goto LABEL_17;
          }
          sub_10004D2C8(v11);
        }
        else if (!v11)
        {
          goto LABEL_17;
        }
        sub_10004D2C8(v11);
LABEL_17:
        if (v15) {
          sub_10004D2C8(v15);
        }
        return;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    sub_100088B9C();
  }
}

void sub_100F22F44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (v16)
  {
    sub_10004D2C8(v16);
    sub_10004D2C8(v16);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F22FA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

void sub_100F230F4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v9 = v5;
  if (!v4 || (uint64_t v10 = std::__shared_weak_count::lock(v4)) == 0) {
    sub_100088B9C();
  }
  sub_10094E7D8((uint64_t)v11, a1 + 736);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, void *))(*(void *)v3 + 32))(v3, a1 + 96, 1, &v9, v11);
  sub_10094E754(v11);
  if (v10) {
    sub_10004D2C8(v10);
  }
  int v7 = (std::__shared_weak_count *)a2[1];
  v8[0] = *a2;
  v8[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100F23458(a1, 1, v8);
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100F23204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void BasebandSettings::lineupFile_sync(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((sub_100F22BA0((uint64_t)a1, a2, a3) & 1) == 0)
  {
    uint64_t v14 = 0;
    BOOL v15 = 0;
    uint64_t v8 = a1[8];
    uint64_t v9 = sub_100F22BA0((uint64_t)a1, a2, 0);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 48))(&v14, v8, a3, a4, v9);
    uint64_t v10 = v14;
    if (!v14) {
      goto LABEL_16;
    }
    BOOL v11 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = (std::__shared_weak_count *)a1[2];
    uint64_t v17 = a1[1];
    if (v12)
    {
      uint64_t v18 = std::__shared_weak_count::lock(v12);
      if (v18)
      {
        sub_10094E7D8((uint64_t)v19, (uint64_t)(a1 + 92));
        int v13 = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t *, void *))(*(void *)v10 + 32))(v10, a1 + 12, a2, &v17, v19);
        sub_10094E754(v19);
        if (v18) {
          sub_10004D2C8(v18);
        }
        if (v13)
        {
          v16[0] = v10;
          v16[1] = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_100F23458((uint64_t)a1, a2, v16);
          if (!v11) {
            goto LABEL_16;
          }
          sub_10004D2C8(v11);
        }
        else if (!v11)
        {
          goto LABEL_16;
        }
        sub_10004D2C8(v11);
LABEL_16:
        if (v15) {
          sub_10004D2C8(v15);
        }
        return;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    sub_100088B9C();
  }
}

void sub_100F233F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (v16)
  {
    sub_10004D2C8(v16);
    sub_10004D2C8(v16);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F23458(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3)
  {
    uint64_t v49 = 0;
    BOOL v50 = 0;
    BasebandSettings::getModel_sync(a1, a2, &v49);
    uint64_t v6 = v49;
    if (!v49)
    {
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = subscriber::asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v18;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get model %s", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_61;
    }
    int v7 = (std::__shared_weak_count *)a3[1];
    uint64_t v8 = *(unsigned __int8 *)(*a3 + 84);
    uint64_t v47 = *a3;
    BOOL v48 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v6 + 48))(v6, v8, &v47);
    if (v48) {
      sub_10004D2C8(v48);
    }
    if (!v9)
    {
LABEL_61:
      if (v50) {
        sub_10004D2C8(v50);
      }
      return;
    }
    uint64_t v54 = 0;
    BOOL v55 = 0;
    BasebandSettings::getModel_sync(a1, a2, &v54);
    uint64_t v10 = v54;
    if (!v54)
    {
      int v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = subscriber::asString();
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v20;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Could not get model %s to prepare file push transaction", (uint8_t *)&buf, 0xCu);
      }
      goto LABEL_59;
    }
    BOOL v11 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
    if (v12 != 1)
    {
      if (!v12)
      {
        os_log_t v13 = *v11;
        if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          uint64_t v14 = "#E Attempt to prepare file push transaction with no file to push";
          BOOL v15 = v13;
LABEL_13:
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&buf, 2u);
          goto LABEL_59;
        }
      }
      goto LABEL_59;
    }
    BOOL v21 = (void **)(a1 + 624);
    BOOL v22 = (uint64_t **)(a1 + 632);
    uint64_t v23 = *(void *)(a1 + 632);
    if (v23)
    {
      uint64_t v24 = a1 + 632;
      do
      {
        int v25 = *(_DWORD *)(v23 + 32);
        BOOL v26 = v25 < (int)a2;
        if (v25 >= (int)a2) {
          BOOL v27 = (uint64_t *)v23;
        }
        else {
          BOOL v27 = (uint64_t *)(v23 + 8);
        }
        if (!v26) {
          uint64_t v24 = v23;
        }
        uint64_t v23 = *v27;
      }
      while (*v27);
      if ((uint64_t **)v24 != v22 && *(_DWORD *)(v24 + 32) <= (int)a2)
      {
        uint64_t v28 = *(void *)(v24 + 40);
        BOOL v29 = *v11;
        BOOL v30 = os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT);
        if (v28)
        {
          if (v30)
          {
            LOWORD(buf) = 0;
            uint64_t v14 = "#E Attempt to prepare multiple file push transactions";
            BOOL v15 = v29;
            goto LABEL_13;
          }
LABEL_59:
          if (v55) {
            sub_10004D2C8(v55);
          }
          goto LABEL_61;
        }
        if (v30)
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#E Pruning pending file push transaction", (uint8_t *)&buf, 2u);
        }
        sub_100F2C73C((uint64_t **)(a1 + 624), (uint64_t *)v24);
      }
    }
    uint64_t v31 = *(void *)(a1 + 264);
    for (uint64_t i = *(void *)(a1 + 272); v31 != i; v31 += 168)
      ;
    uint64_t v52 = 0;
    BOOL v53 = 0;
    BOOL v33 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v33 || (uint64_t v34 = *(void *)(a1 + 8), (v35 = std::__shared_weak_count::lock(v33)) == 0)) {
      sub_100088B9C();
    }
    BOOL v36 = v35;
    atomic_fetch_add_explicit(&v35->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v35);
    *(void *)&long long buf = off_101A70298;
    *((void *)&buf + 1) = v34;
    BOOL v57 = v36;
    p_long long buf = &buf;
    BasebandSettingsDriver::prepareFilePushTransaction();
    sub_100F2D04C(&buf);
    uint64_t v37 = v52;
    BOOL v38 = *v11;
    BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
    if (v37)
    {
      if (v39)
      {
        *(_WORD *)BOOL v51 = 0;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I File push transaction created", v51, 2u);
        uint64_t v37 = v52;
      }
      BOOL v40 = v53;
      BOOL v41 = *v22;
      BOOL v42 = (uint64_t **)(a1 + 632);
      if (*v22)
      {
        while (1)
        {
          while (1)
          {
            BOOL v42 = (uint64_t **)v41;
            int v43 = *((_DWORD *)v41 + 8);
            if (v43 <= (int)a2) {
              break;
            }
            BOOL v41 = *v42;
            BOOL v22 = v42;
            if (!*v42) {
              goto LABEL_50;
            }
          }
          if (v43 >= (int)a2) {
            break;
          }
          BOOL v41 = v42[1];
          if (!v41)
          {
            BOOL v22 = v42 + 1;
            goto LABEL_50;
          }
        }
      }
      else
      {
LABEL_50:
        BOOL v44 = (uint64_t *)operator new(0x38uLL);
        BOOL v45 = v44;
        *((_DWORD *)v44 + 8) = a2;
        v44[5] = v37;
        v44[6] = (uint64_t)v40;
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *BOOL v44 = 0;
        v44[1] = 0;
        void v44[2] = (uint64_t)v42;
        *BOOL v22 = v44;
        BOOL v46 = (void *)**v21;
        if (v46)
        {
          *BOOL v21 = v46;
          BOOL v45 = *v22;
        }
        sub_100046C90(*(uint64_t **)(a1 + 632), v45);
        ++*(void *)(a1 + 640);
      }
    }
    else if (v39)
    {
      *(_WORD *)BOOL v51 = 0;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#E Failed to create file push transaction", v51, 2u);
    }
    if (v53) {
      sub_10004D2C8(v53);
    }
    goto LABEL_59;
  }
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid FileHandlerBase!", (uint8_t *)&buf, 2u);
  }
}

void sub_100F23988(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, char a19)
{
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F239F4(uint64_t a1, int a2)
{
  xpc_object_t v8 = 0;
  uint64_t v2 = (ctu::rest::detail *)a2;
  uint64_t v3 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v8, v2, v3, v4);
  sub_100058DB0(&__p, "/cc/events/baseband_refresh_complete");
  xpc_object_t object = v8;
  xpc_object_t v8 = xpc_null_create();
  ctu::RestModule::sendEvent();
  xpc_release(object);
  if (v7 < 0) {
    operator delete(__p);
  }
  xpc_release(v8);
}

void sub_100F23A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

void sub_100F23ADC(uint64_t a1)
{
  if (capabilities::ct::supportsCompleteCleanupOnFilePushFailure((capabilities::ct *)a1))
  {
    uint64_t v2 = *(void **)(a1 + 600);
    if (v2 != (void *)(a1 + 608))
    {
      do
      {
        uint64_t v3 = v2[5];
        uint64_t v4 = (std::__shared_weak_count *)v2[6];
        if (v4) {
          atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
        if (v4) {
          sub_10004D2C8(v4);
        }
        uint64_t v5 = (void *)v2[1];
        if (v5)
        {
          do
          {
            uint64_t v6 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v6 = (void *)v2[2];
            BOOL v7 = *v6 == (void)v2;
            uint64_t v2 = v6;
          }
          while (!v7);
        }
        uint64_t v2 = v6;
      }
      while (v6 != (void *)(a1 + 608));
    }
    xpc_object_t v8 = *(uint64_t **)(a1 + 624);
    if (v8 != (uint64_t *)(a1 + 632))
    {
      do
      {
        BOOL v9 = v8[5] == 0;
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v8 + 8));
        BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
        if (v9)
        {
          if (v11)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Clearing pending transaction", buf, 2u);
          }
          BOOL v15 = sub_100F2C73C((uint64_t **)(a1 + 624), v8);
        }
        else
        {
          if (v11)
          {
            uint64_t v12 = asString();
            *(_DWORD *)long long buf = 136315138;
            uint64_t v17 = v12;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Aborting transaction with result: %s", buf, 0xCu);
          }
          FilePushTransaction::markFailureWithResult();
          os_log_t v13 = (std::__shared_weak_count *)v8[6];
          v8[5] = 0;
          void v8[6] = 0;
          if (v13) {
            sub_10004D2C8(v13);
          }
          uint64_t v14 = (uint64_t *)v8[1];
          if (v14)
          {
            do
            {
              BOOL v15 = v14;
              uint64_t v14 = (uint64_t *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              BOOL v15 = (uint64_t *)v8[2];
              BOOL v7 = *v15 == (void)v8;
              xpc_object_t v8 = v15;
            }
            while (!v7);
          }
        }
        xpc_object_t v8 = v15;
      }
      while (v15 != (uint64_t *)(a1 + 632));
    }
  }
}

void sub_100F23D2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F23D4C(uint64_t a1, int a2)
{
  (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 584) + 40))(*(void *)(a1 + 584), 128, 0);
  if (a2) {
    (*(void (**)(void, void))(**(void **)(a1 + 584) + 48))(*(void *)(a1 + 584), 0);
  }
  uint64_t v4 = *(NSObject **)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v4)
  {
    dispatch_group_leave(v4);
    dispatch_release(v4);
  }
  *(unsigned char *)(a1 + 292) = 3;
  uint64_t v5 = *(void *)(a1 + 200);
  if (v5)
  {
    LODWORD(v9[0]) = a2;
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v9);
    uint64_t v6 = *(void *)(a1 + 200);
    uint64_t v10 = 0;
    *(void *)(a1 + 200) = 0;
    if (v6 == a1 + 176)
    {
      (*(void (**)(uint64_t))(*(void *)(a1 + 176) + 32))(a1 + 176);
    }
    else if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  *(void *)(a1 + 200) = 0;
  sub_10081A370(v9);
  BOOL v7 = *(std::__shared_weak_count **)(a1 + 504);
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  if (v7) {
    sub_10004D2C8(v7);
  }
  xpc_object_t v8 = *(std::__shared_weak_count **)(a1 + 488);
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 488) = 0;
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void BasebandSettings::sendLinedupFiles_sync(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void **)(a1 + 600);
  uint64_t v5 = (void *)(a1 + 608);
  if (v4 != (void *)(a1 + 608))
  {
    do
    {
      if ((*(unsigned int (**)(void, void))(*(void *)v4[5] + 80))(v4[5], 0))
      {
        uint64_t v6 = *((unsigned int *)v4 + 8);
        BOOL v7 = (std::__shared_weak_count *)v4[6];
        v41[0] = v4[5];
        v41[1] = v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100F24798((void *)a1, v6, v41);
        if (v7) {
          sub_10004D2C8(v7);
        }
      }
      if ((*(unsigned int (**)(void, uint64_t))(*(void *)v4[5] + 80))(v4[5], 8))
      {
        uint64_t v8 = *((unsigned int *)v4 + 8);
        BOOL v9 = (std::__shared_weak_count *)v4[6];
        v40[0] = v4[5];
        v40[1] = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100F24798((void *)a1, v8, v40);
        if (v9) {
          sub_10004D2C8(v9);
        }
      }
      uint64_t v10 = (void *)v4[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v4[2];
          BOOL v12 = *v11 == (void)v4;
          uint64_t v4 = v11;
        }
        while (!v12);
      }
      uint64_t v4 = v11;
    }
    while (v11 != v5);
  }
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 584) + 56))(*(void *)(a1 + 584)))
  {
    os_log_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf) = 0;
    uint64_t v14 = "#E File transfer is already in progress";
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&buf, 2u);
    return;
  }
  BOOL v15 = (void *)a2[3];
  if (v15)
  {
    if (v15 == a2)
    {
      p_long long buf = &buf;
      (*(void (**)(void *, long long *))(*a2 + 24))(a2, &buf);
    }
    else
    {
      p_long long buf = (long long *)(*(uint64_t (**)(void *))(*v15 + 16))(v15);
    }
    sub_100F2D0D0(&buf, (void *)(a1 + 176));
    sub_10081A370(&buf);
  }
  if (*(unsigned char *)(a1 + 472))
  {
    os_log_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(buf) = 0;
    uint64_t v14 = "#I Radio is down. Pending file transfer until it's ready";
    goto LABEL_29;
  }
  uint64_t v16 = dispatch_group_create();
  uint64_t v17 = v16;
  if (v16)
  {
    dispatch_retain(v16);
    dispatch_group_enter(v17);
  }
  uint64_t v18 = *(NSObject **)(a1 + 168);
  *(void *)(a1 + 168) = v17;
  if (v18)
  {
    dispatch_group_leave(v18);
    dispatch_release(v18);
  }
  if (v17) {
    dispatch_release(v17);
  }
  int v19 = *(void **)(a1 + 600);
  if (v19 == v5)
  {
LABEL_70:
    BOOL v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I No files to push after all", (uint8_t *)&buf, 2u);
    }
    sub_100F23D4C(a1, 1);
  }
  else
  {
    char v20 = 0;
    while (1)
    {
      (*(void (**)(long long *__return_ptr))(*(void *)v19[5] + 96))(&buf);
      uint64_t v21 = buf;
      if (*((void *)&buf + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
      }
      if (v21) {
        break;
      }
      BOOL v22 = (void *)v19[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          BOOL v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v19[2];
          BOOL v12 = *v23 == (void)v19;
          int v19 = v23;
        }
        while (!v12);
      }
      v20 |= v21 != 0;
      int v19 = v23;
      if (v23 == v5)
      {
        if ((v20 & 1) == 0) {
          goto LABEL_70;
        }
        break;
      }
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 584) + 48))(*(void *)(a1 + 584), 1);
    uint64_t v24 = *(void **)(a1 + 600);
    if (v24 != v5)
    {
      do
      {
        (*(void (**)(void, uint64_t, void))(*(void *)v24[5] + 104))(v24[5], a1 + 96, *(unsigned __int8 *)(a1 + 292));
        int v25 = (void *)v24[1];
        if (v25)
        {
          do
          {
            BOOL v26 = v25;
            int v25 = (void *)*v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            BOOL v26 = (void *)v24[2];
            BOOL v12 = *v26 == (void)v24;
            uint64_t v24 = v26;
          }
          while (!v12);
        }
        uint64_t v24 = v26;
      }
      while (v26 != v5);
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 584) + 56))(*(void *)(a1 + 584)))
    {
      BOOL v27 = dispatch_group_create();
      if (!*(void *)(a1 + 480))
      {
        sub_100058DB0(&buf, "/cc/exclusive_assertions/baseband_operation");
        ctu::rest::AssertionHandle::create();
        if (SHIBYTE(v46) < 0) {
          operator delete((void *)buf);
        }
        long long v28 = v44;
        long long v44 = 0uLL;
        BOOL v29 = *(std::__shared_weak_count **)(a1 + 488);
        *(_OWORD *)(a1 + 480) = v28;
        if (v29)
        {
          sub_10004D2C8(v29);
          if (*((void *)&v44 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v44 + 1));
          }
        }
        uint64_t v42 = a1;
        if (v27)
        {
          dispatch_retain(v27);
          dispatch_group_enter(v27);
        }
        uint64_t v43 = 0;
        long long v44 = (unint64_t)a1;
        *(void *)&long long buf = off_101A70348;
        *((void *)&buf + 1) = a1;
        BOOL v46 = v27;
        p_long long buf = &buf;
        ctu::rest::AssertionHandle::setHandler_impl();
        sub_100060644(&buf);
      }
      if (!*(void *)(a1 + 496))
      {
        BOOL v30 = *(std::__shared_weak_count **)(a1 + 520);
        if (v30 && (BOOL v30 = std::__shared_weak_count::lock(v30)) != 0) {
          uint64_t v31 = *(void *)(a1 + 512);
        }
        else {
          uint64_t v31 = 0;
        }
        BOOL v33 = *(std::__shared_weak_count **)(a1 + 504);
        *(void *)(a1 + 496) = v31;
        *(void *)(a1 + 504) = v30;
        if (v33)
        {
          sub_10004D2C8(v33);
          uint64_t v31 = *(void *)(a1 + 496);
        }
        if (v31)
        {
          uint64_t v34 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            if (*(_DWORD *)(v31 + 68) == 2) {
              BOOL v35 = "true";
            }
            else {
              BOOL v35 = "false";
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v35;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Shared prevent baseband reset assertion used. Acquired: %s", (uint8_t *)&buf, 0xCu);
          }
          (*(void (**)(void, uint64_t, const char *))(**(void **)(a1 + 584) + 40))(*(void *)(a1 + 584), 8, "Prevent baseband reset assertion shared");
        }
        else
        {
          sub_100058DB0(&buf, "/cc/assertions/prevent_baseband_reset");
          ctu::rest::AssertionHandle::create();
          if (SHIBYTE(v46) < 0) {
            operator delete((void *)buf);
          }
          unint64_t v36 = *((void *)&v44 + 1);
          unint64_t v37 = v44;
          long long v44 = 0uLL;
          BOOL v38 = *(std::__shared_weak_count **)(a1 + 504);
          *(_OWORD *)(a1 + 496) = __PAIR128__(v36, v37);
          if (v38)
          {
            sub_10004D2C8(v38);
            if (*((void *)&v44 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v44 + 1));
            }
            unint64_t v37 = *(void *)(a1 + 496);
            unint64_t v36 = *(void *)(a1 + 504);
          }
          if (v36) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 16), 1uLL, memory_order_relaxed);
          }
          *(void *)(a1 + 512) = v37;
          BOOL v39 = *(std::__shared_weak_count **)(a1 + 520);
          *(void *)(a1 + 520) = v36;
          if (v39) {
            std::__shared_weak_count::__release_weak(v39);
          }
          if (capabilities::ct::supportsCompleteCleanupOnFilePushFailure((capabilities::ct *)v39)
            && *(_DWORD *)(*(void *)(a1 + 496) + 68) != 2)
          {
            uint64_t v42 = a1;
            if (v27)
            {
              dispatch_retain(v27);
              dispatch_group_enter(v27);
            }
            uint64_t v43 = 0;
            long long v44 = (unint64_t)a1;
            *(void *)&long long buf = off_101A703C8;
            *((void *)&buf + 1) = a1;
            BOOL v46 = v27;
            p_long long buf = &buf;
            ctu::rest::AssertionHandle::setHandler_impl();
            sub_100060644(&buf);
          }
        }
      }
      operator new();
    }
  }
}

void sub_100F24670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_100060644(&__p);
  sub_1000D4350((uint64_t)&a15);
  sub_1000D4350((uint64_t)&a13);
  if (v22) {
    dispatch_release(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100F24710(uint64_t a1, uint64_t a2)
{
  v4[0] = a1;
  v4[1] = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100F2D344;
  block[3] = &unk_101A70318;
  block[4] = a1 + 8;
  void block[5] = v4;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8)) {
    dispatch_async_and_wait(v2, block);
  }
  else {
    dispatch_sync(v2, block);
  }
}

void sub_100F24798(void *a1, uint64_t a2, void *a3)
{
  if (((*(uint64_t (**)(void, uint64_t))(*(void *)*a3 + 80))(*a3, 6) & 1) == 0) {
    BasebandSettings::lineupFile_sync(a1, a2, 6, 0);
  }
  if (((*(uint64_t (**)(void, uint64_t))(*(void *)*a3 + 80))(*a3, 8) & 1) == 0) {
    BasebandSettings::lineupFile_sync(a1, a2, 8, 0);
  }
  if (((*(uint64_t (**)(void, uint64_t))(*(void *)*a3 + 80))(*a3, 9) & 1) == 0) {
    BasebandSettings::lineupFile_sync(a1, a2, 9, 0);
  }
  if (((*(uint64_t (**)(void, uint64_t))(*(void *)*a3 + 80))(*a3, 10) & 1) == 0)
  {
    BasebandSettings::lineupFile_sync(a1, a2, 10, 0);
  }
}

void sub_100F248F4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 600);
  uint64_t v3 = (void *)(a1 + 608);
  if (v2 != (void *)(a1 + 608))
  {
    uint64_t v4 = 0;
    while (1)
    {
      (*(void (**)(uint8_t *__return_ptr))(*(void *)v2[5] + 96))(buf);
      uint64_t v5 = *(std::__shared_weak_count **)&buf[8];
      uint64_t v6 = *(unsigned __int8 **)buf;
      *(_OWORD *)long long buf = 0uLL;
      if (v4)
      {
        sub_10004D2C8(v4);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      if (v6) {
        break;
      }
      BOOL v7 = (void *)v2[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v2[2];
          BOOL v9 = *v8 == (void)v2;
          uint64_t v2 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v5;
      uint64_t v2 = v8;
      if (v8 == v3) {
        goto LABEL_15;
      }
    }
    int v21 = *((_DWORD *)v2 + 8);
    uint64_t v22 = *(void *)(a1 + 584);
    uint64_t v23 = asString(v6[84]);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22 + 40))(v22, 16, v23);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v24 = operator new(0x28uLL);
    *uint64_t v24 = off_101A70448;
    v24[1] = a1;
    *((_DWORD *)v24 + 4) = v21;
    v24[3] = v6;
    v24[4] = v5;
    v25[3] = v24;
    (*(void (**)(unsigned __int8 *, void *))(*(void *)v6 + 8))(v6, v25);
    sub_100060644(v25);
    if (!v5) {
      return;
    }
LABEL_38:
    sub_10004D2C8(v5);
    return;
  }
  uint64_t v5 = 0;
LABEL_15:
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I No more files to push", buf, 2u);
  }
  (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 584) + 40))(*(void *)(a1 + 584), 32, 0);
  BasebandSettingsDriver::handleFileTransferComplete(*(BasebandSettingsDriver **)(a1 + 128));
  BOOL v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 640);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N All files have been pushed. Resetting %lu transaction(s)", buf, 0xCu);
  }
  (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 584) + 40))(*(void *)(a1 + 584), 64, 0);
  os_log_t v13 = *(void **)(a1 + 624);
  if (v13 != (void *)(a1 + 632))
  {
    do
    {
      BasebandSettings::getModel_sync(a1, *((_DWORD *)v13 + 8), buf);
      uint64_t v14 = (*(uint64_t (**)(void))(**(void **)buf + 88))(*(void *)buf);
      BOOL v15 = *(capabilities::ct **)&buf[8];
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v14)
      {
        uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v13 + 8));
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Found uncommenced transaction. Will have to be handled next time", buf, 2u);
        }
      }
      else
      {
        if (capabilities::ct::supportsNVRAMUpdateWithoutBasebandReboot(v15))
        {
          uint64_t v17 = (FilePushTransaction *)v13[5];
          if (v17)
          {
            if ((FilePushTransaction::hasFailed(v17) & 1) == 0) {
              BasebandSettings::triggerPriRefreshStart_sync(a1, *((_DWORD *)v13 + 8));
            }
          }
        }
        uint64_t v18 = (std::__shared_weak_count *)v13[6];
        v13[5] = 0;
        void v13[6] = 0;
        if (v18) {
          sub_10004D2C8(v18);
        }
      }
      int v19 = (void *)v13[1];
      if (v19)
      {
        do
        {
          char v20 = v19;
          int v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          char v20 = (void *)v13[2];
          BOOL v9 = *v20 == (void)v13;
          os_log_t v13 = v20;
        }
        while (!v9);
      }
      os_log_t v13 = v20;
    }
    while (v20 != (void *)(a1 + 632));
  }
  if (v5) {
    goto LABEL_38;
  }
}

void sub_100F24D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100060644(&a9);
  if (v9) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F24D60(uint64_t a1, uint64_t a2)
{
  return sub_100F24D68(*(void *)(a1 + 32), a2);
}

uint64_t sub_100F24D68(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "false";
    if (a2) {
      uint64_t v5 = "true";
    }
    int v7 = 136315138;
    uint64_t v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received call on tethering up: %s", (uint8_t *)&v7, 0xCu);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 128) + 112))(*(void *)(a1 + 128), a2);
}

void sub_100F24E54(uint64_t a1, unsigned __int8 *a2)
{
  if (!*(unsigned char *)(a1 + 472))
  {
    int v4 = *(unsigned __int8 *)(a1 + 473);
    if (*a2 != v4)
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = "true";
        if (!v4) {
          uint64_t v6 = "false";
        }
        int v16 = 136315138;
        uint64_t v17 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Received call on Screen status: %s", (uint8_t *)&v16, 0xCu);
        int v4 = *(unsigned __int8 *)(a1 + 473);
      }
      (*(void (**)(void, BOOL))(**(void **)(a1 + 128) + 96))(*(void *)(a1 + 128), v4 != 0);
    }
    if (a2[1]) {
      BOOL v7 = *(unsigned char *)(a1 + 474) == 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v16) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Display is now unlocked", (uint8_t *)&v16, 2u);
      }
      uint64_t v9 = *(void *)(a1 + 248);
      if (!v9) {
        goto LABEL_26;
      }
      uint64_t v10 = a1 + 248;
      do
      {
        int v11 = *(_DWORD *)(v9 + 28);
        BOOL v12 = v11 < 1;
        if (v11 >= 1) {
          os_log_t v13 = (uint64_t *)v9;
        }
        else {
          os_log_t v13 = (uint64_t *)(v9 + 8);
        }
        if (!v12) {
          uint64_t v10 = v9;
        }
        uint64_t v9 = *v13;
      }
      while (*v13);
      if (v10 == a1 + 248 || *(int *)(v10 + 28) > 1) {
LABEL_26:
      }
        BOOL v14 = 1;
      else {
        BOOL v14 = *(_DWORD *)(v10 + 32) < 2u;
      }
      if (*(unsigned char *)(a1 + 161)) {
        BOOL v15 = 1;
      }
      else {
        BOOL v15 = !v14;
      }
      if (!v15) {
        (*(void (**)(void))(**(void **)(a1 + 128) + 40))(*(void *)(a1 + 128));
      }
    }
  }
}

void sub_100F2503C(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100F25120(uint64_t a1, uint64_t a2)
{
  v3[4] = a1;
  sub_1000DFC90((uint64_t)&v4, a2);
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_100F25250(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void *sub_100F25268(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Time is being set on baseband", (uint8_t *)v5, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 128);
  v5[0] = off_101A704F8;
  double v5[3] = v5;
  (*(void (**)(uint64_t, void *))(*(void *)v3 + 64))(v3, v5);
  return sub_100F2E704(v5);
}

void sub_100F25350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100F25364(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 288);
  if (v2 != a2) {
    return (*(uint64_t (**)(void, BOOL))(**(void **)(result + 128) + 152))(*(void *)(result + 128), v2 != 0);
  }
  return result;
}

uint64_t sub_100F253A4(uint64_t result, int a2)
{
  int v2 = *(unsigned __int8 *)(result + 289);
  if (v2 != a2) {
    return (*(uint64_t (**)(void, BOOL))(**(void **)(result + 128) + 176))(*(void *)(result + 128), v2 != 0);
  }
  return result;
}

void sub_100F253E4(uint64_t a1)
{
  *(unsigned char *)(a1 + 162) = 1;
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    uint64_t v3 = "true";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I RF is being disabled, setting user initiated airplane mode on to %s", (uint8_t *)&v2, 0xCu);
  }
}

void sub_100F2548C(uint64_t a1)
{
  if ((operator==() & 1) == 0)
  {
    int v2 = *(NSObject **)(a1 + 40);
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      uint64_t v4 = asString();
      uint64_t v5 = "true";
      if (!*(unsigned char *)(a1 + 468)) {
        uint64_t v5 = "false";
      }
      int v9 = 136315394;
      uint64_t v10 = (const char *)v4;
      __int16 v11 = 2080;
      BOOL v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Received radio mode update (%s) with in reset (%s)", (uint8_t *)&v9, 0x16u);
    }
    int v6 = *(_DWORD *)(a1 + 464);
    if (v6)
    {
      if (v6 == 2)
      {
        *(_WORD *)(a1 + 161) = 0;
        if (capabilities::ct::supportsBatterySaverMode((capabilities::ct *)v3))
        {
          BOOL v7 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v9) = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Sending battery saver mode since BB came online", (uint8_t *)&v9, 2u);
          }
          (*(void (**)(void, void))(**(void **)(a1 + 128) + 152))(*(void *)(a1 + 128), *(unsigned __int8 *)(a1 + 288));
        }
      }
    }
    else
    {
      *(unsigned char *)(a1 + 161) = 1;
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 136315138;
        uint64_t v10 = "true";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I RF has been disabled, setting airplane mode on to %s", (uint8_t *)&v9, 0xCu);
      }
    }
  }
}

void *sub_100F2564C(void *result, int a2)
{
  int v2 = *((unsigned __int8 *)result + 472);
  if (v2 != a2)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = result[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "down";
      if (!v2) {
        uint64_t v5 = "up";
      }
      int v12 = 136315138;
      os_log_t v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received radio going '%s'", (uint8_t *)&v12, 0xCu);
    }
    (*(void (**)(void, void))(**(void **)(v3 + 584) + 48))(*(void *)(v3 + 584), 0);
    if (v2)
    {
      sub_100F23ADC(v3);
      int v6 = *(void **)(v3 + 600);
      if (v6 != (void *)(v3 + 608))
      {
        do
        {
          uint64_t v7 = v6[5];
          uint64_t v8 = (std::__shared_weak_count *)v6[6];
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t))(*(void *)v7 + 72))(v7);
          if (v8) {
            sub_10004D2C8(v8);
          }
          int v9 = (void *)v6[1];
          if (v9)
          {
            do
            {
              uint64_t v10 = v9;
              int v9 = (void *)*v9;
            }
            while (v9);
          }
          else
          {
            do
            {
              uint64_t v10 = (void *)v6[2];
              BOOL v11 = *v10 == (void)v6;
              int v6 = v10;
            }
            while (!v11);
          }
          int v6 = v10;
        }
        while (v10 != (void *)(v3 + 608));
      }
      return (void *)(*(uint64_t (**)(void))(**(void **)(v3 + 128) + 192))(*(void *)(v3 + 128));
    }
    else
    {
      uint64_t v14 = 0;
      BasebandSettings::sendLinedupFiles_sync(v3, &v12);
      return sub_10081A370(&v12);
    }
  }
  return result;
}

void sub_100F25830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100F25860(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 792))
  {
    uint64_t v4 = a2 + 1;
    uint64_t v5 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    int v6 = *(void **)(a1 + 776);
    while (*((_DWORD *)v5 + 7) == *((_DWORD *)v6 + 7) && rest::operator==())
    {
      uint64_t v7 = (void *)v5[1];
      uint64_t v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          uint64_t v8 = v5;
        }
        while (!v9);
      }
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          int v6 = v11;
        }
        while (!v9);
      }
      int v6 = v11;
      if (v5 == v4) {
        return;
      }
    }
  }
  int v12 = *(void **)(a1 + 776);
  if (v12 != (void *)(a1 + 784))
  {
    os_log_t v13 = a2 + 1;
    do
    {
      uint64_t v14 = *v13;
      int v15 = *((_DWORD *)v12 + 7);
      if (!*v13) {
        goto LABEL_31;
      }
      int v16 = v13;
      do
      {
        int v17 = *(_DWORD *)(v14 + 28);
        BOOL v18 = v17 < v15;
        if (v17 >= v15) {
          int v19 = (uint64_t *)v14;
        }
        else {
          int v19 = (uint64_t *)(v14 + 8);
        }
        if (!v18) {
          int v16 = (void *)v14;
        }
        uint64_t v14 = *v19;
      }
      while (*v19);
      if (v16 == v13 || v15 < *((_DWORD *)v16 + 7) || (rest::operator==() & 1) == 0) {
LABEL_31:
      }
        sub_100F259EC(a1);
      char v20 = (void *)v12[1];
      if (v20)
      {
        do
        {
          int v21 = v20;
          char v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          int v21 = (void *)v12[2];
          BOOL v9 = *v21 == (void)v12;
          int v12 = v21;
        }
        while (!v9);
      }
      int v12 = v21;
    }
    while (v21 != (void *)(a1 + 784));
  }
}

void sub_100F259EC(uint64_t a1)
{
  if (capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sending smart data mode settings for %s to baseband", (uint8_t *)&buf, 0xCu);
    }
    subscriber::makeSimSlotRange();
    uint64_t v3 = (unsigned int *)*((void *)&buf + 1);
    uint64_t v4 = (unsigned int *)buf;
    if ((void)buf != *((void *)&buf + 1))
    {
      uint64_t v5 = v18;
      while ((v5(*v4) & 1) == 0)
      {
        if (++v4 == v3)
        {
          uint64_t v4 = v3;
          break;
        }
      }
      int v6 = (unsigned int *)*((void *)&buf + 1);
      if (v4 != *((unsigned int **)&buf + 1))
      {
        uint64_t v7 = (uint64_t *)(a1 + 784);
        do
        {
          uint64_t v8 = *v4;
          uint64_t v9 = *v7;
          if (!*v7) {
            goto LABEL_21;
          }
          uint64_t v10 = a1 + 784;
          do
          {
            int v11 = *(_DWORD *)(v9 + 28);
            BOOL v12 = v11 < (int)v8;
            if (v11 >= (int)v8) {
              os_log_t v13 = (uint64_t *)v9;
            }
            else {
              os_log_t v13 = (uint64_t *)(v9 + 8);
            }
            if (!v12) {
              uint64_t v10 = v9;
            }
            uint64_t v9 = *v13;
          }
          while (*v13);
          if ((uint64_t *)v10 != v7 && (int)v8 >= *(_DWORD *)(v10 + 28))
          {
            (*(void (**)(void))(**(void **)(a1 + 128) + 160))(*(void *)(a1 + 128));
          }
          else
          {
LABEL_21:
            uint64_t v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)int v16 = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#N Smart data mode settings unavailable", v16, 2u);
            }
          }
          int v15 = v4 + 1;
          uint64_t v4 = v3;
          if (v15 != v3)
          {
            uint64_t v4 = v15;
            while ((v5(*v4) & 1) == 0)
            {
              if (++v4 == v3)
              {
                uint64_t v4 = v3;
                break;
              }
            }
          }
        }
        while (v4 != v6);
      }
    }
  }
}

void sub_100F25C1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  v3[0] = 0;
  v3[1] = 0;
  sub_10003E168(v3, (void *)(a1 + 8));
  operator new();
}

void sub_100F25D14(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B12F80, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_101B12F80))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B12F78, kCtLoggingSystemName, "set.bb");
    __cxa_guard_release(qword_101B12F80);
  }
  uint64_t v2 = qword_101B12F78;
  if (os_log_type_enabled((os_log_t)qword_101B12F78, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    uint64_t v4 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_100F25E04(_Unwind_Exception *a1)
{
}

uint64_t sub_100F25E1C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 160)) {
      int v3 = "true";
    }
    else {
      int v3 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fRegisteredForCallbacks: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 161)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fAirplaneModeOn: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 162)) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fUserInitiatedAirplaneMode: %s", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 248);
  if (v6)
  {
    uint64_t v7 = a1 + 248;
    do
    {
      int v8 = *(_DWORD *)(v6 + 28);
      BOOL v9 = v8 < 1;
      if (v8 >= 1) {
        uint64_t v10 = (uint64_t *)v6;
      }
      else {
        uint64_t v10 = (uint64_t *)(v6 + 8);
      }
      if (!v9) {
        uint64_t v7 = v6;
      }
      uint64_t v6 = *v10;
    }
    while (*v10);
    if (v7 != a1 + 248 && *(int *)(v7 + 28) <= 1)
    {
      int v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I fRegStatus: %s", buf, 0xCu);
      }
    }
  }
  os_log_t v13 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I fFilePushReason: %s", buf, 0xCu);
    os_log_t v13 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a1 + 496);
    if (v15)
    {
      if (*(_DWORD *)(v15 + 68) == 2) {
        int v16 = "granted";
      }
      else {
        int v16 = "waiting";
      }
    }
    else
    {
      int v16 = "none";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Prevent baseband reset assertion: %s", buf, 0xCu);
    os_log_t v13 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void *)(a1 + 480);
    if (v17)
    {
      if (*(_DWORD *)(v17 + 68) == 2) {
        BOOL v18 = "granted";
      }
      else {
        BOOL v18 = "waiting";
      }
    }
    else
    {
      BOOL v18 = "none";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Exclusive baseband operation assertion: %s", buf, 0xCu);
  }
  int v19 = *(void **)(a1 + 624);
  if (v19 != (void *)(a1 + 632))
  {
    do
    {
      char v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v19 + 8));
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if (v19[5]) {
          int v21 = "Active";
        }
        else {
          int v21 = "Pending";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s file push transaction", buf, 0xCu);
      }
      uint64_t v22 = (void *)v19[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v19[2];
          BOOL v24 = *v23 == (void)v19;
          int v19 = v23;
        }
        while (!v24);
      }
      int v19 = v23;
    }
    while (v23 != (void *)(a1 + 632));
  }
  int v25 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = asString();
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I fLTEWithCDRXState: %s", buf, 0xCu);
  }
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  *(_OWORD *)BOOL v46 = 0u;
  long long v47 = 0u;
  memset(v45, 0, sizeof(v45));
  *(_OWORD *)long long buf = 0u;
  sub_10004BD84((uint64_t)buf);
  BOOL v27 = *(void **)(a1 + 648);
  if (v27 != (void *)(a1 + 656))
  {
    do
    {
      long long v28 = (const char *)subscriber::asString();
      size_t v29 = strlen(v28);
      BOOL v30 = sub_10004B96C(v45, (uint64_t)v28, v29);
      sub_10004B96C(v30, (uint64_t)", ", 2);
      uint64_t v31 = (void *)v27[1];
      if (v31)
      {
        do
        {
          BOOL v32 = v31;
          uint64_t v31 = (void *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          BOOL v32 = (void *)v27[2];
          BOOL v24 = *v32 == (void)v27;
          BOOL v27 = v32;
        }
        while (!v24);
      }
      BOOL v27 = v32;
    }
    while (v32 != (void *)(a1 + 656));
  }
  BOOL v33 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)v45 + 8, __p);
    uint64_t v34 = v41 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)uint64_t v42 = 136446210;
    uint64_t v43 = v34;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I fTurnedOffCellular: [%{public}s]", v42, 0xCu);
    if (v41 < 0) {
      operator delete(__p[0]);
    }
  }
  BOOL v35 = *(void **)(a1 + 600);
  if (v35 != (void *)(a1 + 608))
  {
    do
    {
      (*(void (**)(void))(*(void *)v35[5] + 16))(v35[5]);
      unint64_t v36 = (void *)v35[1];
      if (v36)
      {
        do
        {
          unint64_t v37 = v36;
          unint64_t v36 = (void *)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          unint64_t v37 = (void *)v35[2];
          BOOL v24 = *v37 == (void)v35;
          BOOL v35 = v37;
        }
        while (!v24);
      }
      BOOL v35 = v37;
    }
    while (v37 != (void *)(a1 + 608));
  }
  (*(void (**)(void))(**(void **)(a1 + 584) + 32))(*(void *)(a1 + 584));
  (*(void (**)(void))(**(void **)(a1 + 128) + 200))(*(void *)(a1 + 128));
  *(void *)&v45[0] = v38;
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100F265CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10008248C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100F265F4(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[71];
  if (v3)
  {
    sub_1000DFC90((uint64_t)v15, a3);
    uint64_t v5 = v15;
    (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v3 + 32))(v3, a2, v15);
  }
  else
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 1174405120;
    void v13[2] = sub_100F267CC;
    void v13[3] = &unk_101A6F640;
    void v13[4] = a1;
    uint64_t v5 = v14;
    sub_1000DFC90((uint64_t)v14, a3);
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    sub_10003E168(&v11, a1 + 1);
    uint64_t v7 = a1[3];
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    block[2] = sub_100F2E898;
    block[3] = &unk_101A70580;
    void block[5] = v11;
    uint64_t v10 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v13;
    dispatch_async(v7, block);
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
  return sub_100060644(v5);
}

void sub_100F267A0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F267CC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Attach APN module is not present, editing not allowed", v4, 2u);
  }
  return sub_1000607A8(a1 + 40, 0);
}

void sub_100F26840(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 568);
  if (v4)
  {
    sub_1000F0058((uint64_t)v9, a4);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v4 + 64))(v4, a2, a3, v9);
    sub_10003B34C(v9);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I No Attach APN Manager", v8, 2u);
    }
  }
}

void sub_100F26930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F2694C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 568);
  if (result) {
    return AttachApnModuleInterface::isAttachAPNTypeSupported();
  }
  return result;
}

void sub_100F2695C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_100F26A84(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  sub_10069AF38((uint64_t *)&v3 + 1, a2);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_100F26BC0(uint64_t a1)
{
  if (_os_feature_enabled_impl())
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    subscriber::makeSimSlotRange();
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    long long v3 = &v4;
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sending %zu active subs to baseband", buf, 0xCu);
    }
    (*(void (**)(void, void ***))(**(void **)(a1 + 128) + 168))(*(void *)(a1 + 128), &v3);
    sub_1000346F8((uint64_t)&v3, v4);
  }
}

void sub_100F26DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

uint64_t sub_100F26DD4(uint64_t a1)
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    v3[0] = 0;
    v3[1] = 0;
    sub_10003E168(v3, (void *)(a1 + 8));
    operator new();
  }
  return result;
}

uint64_t sub_100F26ED8(uint64_t a1, int a2)
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    uint64_t v6 = a1;
    int v7 = a2;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    void v8[2] = sub_100F2F5D4;
    void v8[3] = &unk_101A70630;
    void v8[4] = a1 + 8;
    v8[5] = &v6;
    BOOL v9 = v8;
    uint64_t v5 = *(NSObject **)(a1 + 24);
    if (*(void *)(a1 + 32))
    {
      char v16 = 0;
      block = _NSConcreteStackBlock;
      uint64_t v11 = 0x40000000;
      uint64_t v12 = sub_10005B3B0;
      os_log_t v13 = &unk_101A70670;
      uint64_t v14 = &v16;
      uint64_t v15 = &v9;
      dispatch_async_and_wait(v5, &block);
    }
    else
    {
      char v16 = 0;
      block = _NSConcreteStackBlock;
      uint64_t v11 = 0x40000000;
      uint64_t v12 = sub_10005A64C;
      os_log_t v13 = &unk_101A70650;
      uint64_t v14 = &v16;
      uint64_t v15 = &v9;
      dispatch_sync(v5, &block);
    }
    return v16 != 0;
  }
  return result;
}

uint64_t sub_100F27038()
{
  return _os_feature_enabled_impl();
}

uint64_t sub_100F2704C(uint64_t a1, uint64_t a2, PersonalityInfo **a3)
{
  uint64_t result = _os_feature_enabled_impl();
  if (result)
  {
    uint64_t result = isReal();
    if (result)
    {
      int v7 = *a3;
      if (!*((unsigned char *)*a3 + 49))
      {
        uint64_t v8 = (uint64_t *)*(unsigned __int8 *)(a2 + 24);
        if (*(unsigned char *)(a2 + 24))
        {
          if (v8 == 6)
          {
            int v19 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = PersonalityInfo::logPrefix(v7);
              __int16 v28 = 2080;
              uint64_t v29 = asString();
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s %s: turnOffCellular reset to OFF", buf, 0x16u);
              int v7 = *a3;
            }
            sub_100A37530((uint64_t **)(a1 + 648), *((_DWORD *)v7 + 13));
            int v20 = 0;
LABEL_29:
            sub_100F27384(a1, a3, v20);
            return sub_100F2752C(a1);
          }
          if (v8 != 5) {
            return sub_100F2752C(a1);
          }
        }
        ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 96));
        uint64_t v10 = ServiceMap;
        if (v11 < 0)
        {
          uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v13 = 5381;
          do
          {
            uint64_t v11 = v13;
            unsigned int v14 = *v12++;
            uint64_t v13 = (33 * v13) ^ v14;
          }
          while (v14);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v11;
        uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
        if (v15)
        {
          uint64_t v17 = v15[3];
          char v16 = (std::__shared_weak_count *)v15[4];
          if (v16)
          {
            atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v10);
            atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v16);
            char v18 = 0;
LABEL_18:
            (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v17 + 64))(&v26, v17, a2, @"TurnedOffCellular", 0, 0, 1);
            if (v26) {
              int v21 = sub_100080934;
            }
            else {
              int v21 = 0;
            }
            sub_1000577C4(&v26);
            if ((v18 & 1) == 0) {
              sub_10004D2C8(v16);
            }
            uint64_t v22 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v23 = PersonalityInfo::logPrefix(*a3);
              uint64_t v24 = asString();
              int v25 = "ON";
              *(_DWORD *)long long buf = 136315650;
              *(void *)&uint8_t buf[4] = v23;
              __int16 v28 = 2080;
              if (!v21) {
                int v25 = "OFF";
              }
              uint64_t v29 = v24;
              __int16 v30 = 2080;
              uint64_t v31 = v25;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s %s: turnOffCellular is %s", buf, 0x20u);
            }
            if (!v21) {
              return sub_100F2752C(a1);
            }
            sub_10078C71C((uint64_t **)(a1 + 648), (int *)*a3 + 13, (_DWORD *)*a3 + 13);
            int v20 = 1;
            goto LABEL_29;
          }
        }
        else
        {
          uint64_t v17 = 0;
        }
        std::mutex::unlock(v10);
        char v16 = 0;
        char v18 = 1;
        goto LABEL_18;
      }
    }
  }
  return result;
}

void sub_100F27354(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F27384(uint64_t a1, PersonalityInfo **a2, int a3)
{
  CFMutableDictionaryRef theDict = 0;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v7 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    CFMutableDictionaryRef v15 = v7;
    sub_10005717C((const void **)&v15);
  }
  CFDictionarySetValue(theDict, kCTCapabilityCanSet, kCFBooleanTrue);
  if (a3) {
    CFBooleanRef v8 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v8 = kCFBooleanFalse;
  }
  CFDictionarySetValue(theDict, kCTCapabilityStatus, v8);
  uint64_t v13 = 0;
  CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9)
  {
    uint64_t v10 = v13;
    uint64_t v13 = v9;
    CFMutableDictionaryRef v15 = v10;
    sub_10005717C((const void **)&v15);
  }
  CFDictionarySetValue(v13, kCTCapabilityTurnOffCellular, theDict);
  uint64_t v11 = *(void *)(a1 + 800);
  PersonalityInfo::uuid((uint64_t *)&v15, *a2);
  (*(void (**)(uint64_t, CFMutableDictionaryRef, __CFDictionary *))(*(void *)v11 + 16))(v11, v15, v13);
  sub_10012577C((const void **)&v15);
  sub_10005717C((const void **)&v13);
  return sub_10005717C((const void **)&theDict);
}

void sub_100F274F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  long long v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  sub_10012577C((const void **)va2);
  sub_10005717C((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F2752C(uint64_t a1)
{
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  subscriber::makeSimSlotRange();
  v29[0] = 1;
  v29[1] = a1 + 672;
  uint64_t v30 = 0;
  LOBYTE(v30) = *(unsigned char *)(a1 + 704);
  BOOL v32 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = &v32;
  char v2 = *(int **)(a1 + 712);
  if (v2 != (int *)(a1 + 720))
  {
    do
    {
      sub_100602B88((uint64_t **)&v31, (uint64_t *)&v32, v2 + 7, v2 + 7);
      long long v3 = (int *)*((void *)v2 + 1);
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          long long v3 = *(int **)v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (int *)*((void *)v2 + 2);
          BOOL v5 = *(void *)v4 == (void)v2;
          char v2 = v4;
        }
        while (!v5);
      }
      char v2 = v4;
    }
    while (v4 != (int *)(a1 + 720));
  }
  LOBYTE(v30) = 0;
  if (&v31 == (uint64_t ***)(a1 + 648)) {
    return sub_100F2F630((uint64_t)v29);
  }
  uint64_t v6 = *(void **)(a1 + 648);
  CFMutableDictionaryRef v7 = (void *)(a1 + 656);
  if (v33)
  {
    CFBooleanRef v8 = (uint64_t *)v31;
    uint64_t v31 = &v32;
    void v32[2] = 0;
    BOOL v32 = 0;
    uint64_t v33 = 0;
    if (v8[1]) {
      CFMutableDictionaryRef v9 = (uint64_t *)v8[1];
    }
    else {
      CFMutableDictionaryRef v9 = v8;
    }
    if (v9)
    {
      uint64_t v10 = sub_1000EA590((uint64_t)v9);
      if (v6 == v7)
      {
        uint64_t v6 = v7;
      }
      else
      {
        uint64_t v11 = v9;
        uint64_t v12 = v6;
        do
        {
          CFMutableDictionaryRef v9 = v10;
          int v13 = *((_DWORD *)v12 + 7);
          *((_DWORD *)v11 + 7) = v13;
          unsigned int v14 = v32;
          CFMutableDictionaryRef v15 = &v32;
          char v16 = &v32;
          if (v32)
          {
            do
            {
              while (1)
              {
                CFMutableDictionaryRef v15 = (uint64_t **)v14;
                if (v13 >= *((_DWORD *)v14 + 7)) {
                  break;
                }
                unsigned int v14 = (uint64_t *)*v14;
                char v16 = v15;
                if (!*v15) {
                  goto LABEL_22;
                }
              }
              unsigned int v14 = (uint64_t *)v14[1];
            }
            while (v14);
            char v16 = v15 + 1;
          }
LABEL_22:
          *uint64_t v11 = 0;
          v11[1] = 0;
          dispatch_object_t v11[2] = (uint64_t)v15;
          *char v16 = v11;
          if (*v31)
          {
            uint64_t v31 = (uint64_t **)*v31;
            uint64_t v11 = *v16;
          }
          sub_100046C90(v32, v11);
          ++v33;
          if (v10) {
            uint64_t v10 = sub_1000EA590((uint64_t)v10);
          }
          else {
            uint64_t v10 = 0;
          }
          uint64_t v17 = (void *)v12[1];
          if (v17)
          {
            do
            {
              uint64_t v6 = v17;
              uint64_t v17 = (void *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              uint64_t v6 = (void *)v12[2];
              BOOL v5 = *v6 == (void)v12;
              uint64_t v12 = v6;
            }
            while (!v5);
          }
          if (!v9) {
            break;
          }
          uint64_t v11 = v9;
          uint64_t v12 = v6;
        }
        while (v6 != v7);
      }
      sub_1000346F8((uint64_t)&v31, v9);
      if (!v10) {
        goto LABEL_42;
      }
      for (uint64_t i = (uint64_t *)v10[2]; i; uint64_t i = (uint64_t *)i[2])
        uint64_t v10 = i;
      char v18 = v10;
    }
    else
    {
      char v18 = 0;
    }
    sub_1000346F8((uint64_t)&v31, v18);
  }
LABEL_42:
  if (v6 != v7)
  {
    do
    {
      int v20 = *((_DWORD *)v6 + 7);
      int v21 = (uint64_t *)operator new(0x20uLL);
      uint64_t v22 = v21;
      *((_DWORD *)v21 + 7) = v20;
      uint64_t v23 = v32;
      uint64_t v24 = &v32;
      int v25 = &v32;
      if (v32)
      {
        do
        {
          while (1)
          {
            uint64_t v24 = (uint64_t **)v23;
            if (*((_DWORD *)v23 + 7) <= v20) {
              break;
            }
            uint64_t v23 = (uint64_t *)*v23;
            int v25 = v24;
            if (!*v24) {
              goto LABEL_49;
            }
          }
          uint64_t v23 = (uint64_t *)v23[1];
        }
        while (v23);
        int v25 = v24 + 1;
      }
LABEL_49:
      *int v21 = 0;
      v21[1] = 0;
      void v21[2] = (uint64_t)v24;
      const char *v25 = v21;
      if (*v31)
      {
        uint64_t v31 = (uint64_t **)*v31;
        uint64_t v22 = *v25;
      }
      sub_100046C90(v32, v22);
      ++v33;
      uint64_t v26 = (void *)v6[1];
      if (v26)
      {
        do
        {
          BOOL v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          BOOL v27 = (void *)v6[2];
          BOOL v5 = *v27 == (void)v6;
          uint64_t v6 = v27;
        }
        while (!v5);
      }
      uint64_t v6 = v27;
    }
    while (v27 != v7);
  }
  return sub_100F2F630((uint64_t)v29);
}

void sub_100F279D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F27A10(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F27A98(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F27AD0(uint64_t a1)
{
}

uint64_t sub_100F27AEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F27B30(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F27B5C(ServiceManager::Service *this)
{
  *(void *)this = off_101A6F860;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F27BB8(ServiceManager::Service *this)
{
  *(void *)this = off_101A6F860;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F27C28@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "BasebandSettings");
}

unsigned char *sub_100F27C38@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  char v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F27C78(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  long long v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F2294C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F2294C(v4, 0);
}

uint64_t sub_100F27CFC()
{
  return 1;
}

uint64_t sub_100F27D04()
{
  return 1;
}

uint64_t sub_100F27D0C()
{
  return 2;
}

void sub_100F27D14(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_null_create();
  }
  BOOL v5 = *a3;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
    sub_100F22A44(v4, v5);
  }
  sub_100F22A44(v4, 0);
}

void sub_100F27DB0(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_100F27E8C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

void sub_100F27FA0(ServiceManager::Service *this)
{
  *(void *)this = off_101A6F860;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F27FFC(ServiceManager::Service *this)
{
  *(void *)this = off_101A6F860;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100F2806C()
{
  return 0;
}

uint64_t sub_100F28074()
{
  return 0;
}

void sub_100F28084()
{
}

uint64_t sub_100F28098(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100F280A4(void **a1)
{
  uint64_t v1 = *a1;
  CFBooleanRef v8 = a1;
  CFMutableDictionaryRef v9 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 128);
  BOOL v5 = v1[1];
  *(void *)long long buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  (*(void (**)(void))(**(void **)(v2 + 584) + 24))(*(void *)(v2 + 584));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 144));
  for (uint64_t i = *(void *)(v2 + 80); i != v2 + 72; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 72));
  sub_100088C88((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100F281E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100F28224(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 128) + 24))(*(void *)(v1 + 128));
  operator delete();
}

void sub_100F282E0()
{
}

void sub_100F2830C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  uint64_t v4 = *(void *)(v1 + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      CFMutableDictionaryRef v7 = (std::__shared_weak_count *)operator new(0x30uLL);
      v7->__shared_weak_owners_ = 0;
      v7->__shared_owners_ = 0;
      v7->__vftable = (std::__shared_weak_count_vtbl *)off_101A6F908;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v7[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A6F958;
      v7[1].__shared_owners_ = v4;
      v7[1].__shared_weak_owners_ = (uint64_t)v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_weak(v6);
      sub_10004D2C8(v6);
      uint64_t v8 = *(void *)(v1 + 128);
      CFMutableDictionaryRef v15 = v7 + 1;
      char v16 = v7;
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      (*(void (**)(uint64_t, std::__shared_weak_count **))(*(void *)v8 + 16))(v8, &v15);
      if (v16) {
        sub_10004D2C8(v16);
      }
      (*(void (**)(void))(**(void **)(v1 + 584) + 16))(*(void *)(v1 + 584));
      sub_100058DB0(__p, "/cc/props/display_status");
      CFMutableDictionaryRef v9 = operator new(0x28uLL);
      void *v9 = off_101A6F9D8;
      v9[1] = v1 + 473;
      void v9[2] = v1;
      void v9[3] = sub_100F24E54;
      void v9[4] = 0;
      uint64_t v26 = v9;
      ctu::RestModule::observeProperty();
      sub_10003F600(&buf);
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      sub_100058DB0(__p, "/cc/events/dump_state");
      uint64_t v10 = operator new(0x20uLL);
      void *v10 = off_101A6FA58;
      v10[1] = v1;
      void v10[2] = sub_100F25E1C;
      v10[3] = 0;
      uint64_t v26 = v10;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      sub_100058DB0(__p, "/cc/events/significant_time_change");
      uint64_t v11 = operator new(0x20uLL);
      *uint64_t v11 = off_101A6FAD8;
      v11[1] = v1;
      dispatch_object_t v11[2] = sub_100F25268;
      void v11[3] = 0;
      uint64_t v26 = v11;
      ctu::RestModule::observeEvent();
      sub_10003F600(&buf);
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      aBlock = 0;
      __p[0] = _NSConcreteStackBlock;
      __p[1] = (void *)0x40000000;
      int v20 = sub_100F2A2EC;
      int v21 = &unk_101A6FB48;
      uint64_t v22 = v1 + 8;
      uint64_t v23 = sub_100F253E4;
      uint64_t v24 = 0;
      aBlock = _Block_copy(__p);
      uint64_t v12 = *(std::__shared_weak_count **)(v1 + 16);
      if (v12)
      {
        int v13 = std::__shared_weak_count::lock(v12);
        if (v13)
        {
          unsigned int v14 = v13;
          sub_1001644F8(&v18, &aBlock, *(dispatch_object_t *)(v1 + 24));
          sub_100164540(&buf, &v18);
          atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_100F28F68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F2914C(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/is_postponement_ticket_available");
  v4[0] = off_101A6FF98;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_100F29200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100F2922C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A6F908;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F2924C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A6F908;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F292A0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F292C8(BasebandSettingsDriverEventHandlerInterface *this)
{
  *(void *)this = off_101A6F958;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  BasebandSettingsDriverEventHandlerInterface::~BasebandSettingsDriverEventHandlerInterface(this);
}

void sub_100F29324(BasebandSettingsDriverEventHandlerInterface *this)
{
  *(void *)this = off_101A6F958;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  BasebandSettingsDriverEventHandlerInterface::~BasebandSettingsDriverEventHandlerInterface(this);

  operator delete();
}

void sub_100F29394(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100F294C8(uint64_t a1, NSObject *a2)
{
  char v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        if (a2)
        {
          dispatch_retain(a2);
          dispatch_retain(a2);
          dispatch_group_enter(a2);
        }
        v7[0] = 0;
        v7[1] = 0;
        sub_10003E168(v7, (void *)(v6 + 8));
        operator new();
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100F29624(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100F29750(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    CFMutableDictionaryRef v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        sub_100F29D48(&v9, a3);
        BasebandSettings::bandCapability(v8, a2, (uint64_t)&v9);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100F297D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_1000346F8((uint64_t)&a10, a11);
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_100F297FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    CFMutableDictionaryRef v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        sub_100F29D48(&v9, a3);
        BasebandSettings::activeBands(v8, a2, (uint64_t)&v9);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100F29880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_1000346F8((uint64_t)&a10, a11);
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_100F298A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

void sub_100F299DC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    CFMutableDictionaryRef v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint64_t v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 48) + 16))(*(void *)(v9 + 48), a2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = "failure";
          if (a3) {
            uint64_t v11 = "success";
          }
          int v12 = 136315138;
          int v13 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I File transfer complete: %s", (uint8_t *)&v12, 0xCu);
        }
        if (*(void *)(v9 + 232))
        {
          sub_1000607A8(v9 + 208, a3);
          uint64_t v14 = 0;
          sub_100555EB4((void *)(v9 + 208), (uint64_t)&v12);
          sub_100060644(&v12);
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100F29B58(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F29B7C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      CFMutableDictionaryRef v7 = v6;
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        if ((a3 & 1) == 0)
        {
          uint64_t v9 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136315138;
            uint64_t v11 = asString();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N AP %s status failed", (uint8_t *)&v10, 0xCu);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100F29C90(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100F29CA4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 8);
      if (v5)
      {
        uint64_t v6 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CFMutableDictionaryRef v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I File transfer waiting for confirmation", v7, 2u);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t *sub_100F29D48(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100F29DA0(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100F29D88(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100F29DA0(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100F29E2C(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      CFMutableDictionaryRef v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          CFMutableDictionaryRef v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100F29E2C(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v6 = sub_1000262C0(a1, a2, &v11, &v10, a3);
  CFMutableDictionaryRef v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    CFMutableDictionaryRef v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_100046C38(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

void sub_100F29EBC()
{
}

__n128 sub_100F29ED0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6F9D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F29F24(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6F9D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F29F5C(uint64_t a1, void **a2)
{
  char v3 = *a2;
  int v9 = **(_DWORD **)(a1 + 8);
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
  uint64_t v4 = *(uint64_t (**)(void *, int *))(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = (void *)(*(void *)(a1 + 16) + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, int *))(*v6 + v4);
  }
  return v4(v6, &v9);
}

void sub_100F2A014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
}

uint64_t sub_100F2A030(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2A070()
{
}

void sub_100F2A080()
{
}

__n128 sub_100F2A094(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A6FA58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F2A0E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FA58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2A120(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  char v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F2A168(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2A1A8()
{
}

void sub_100F2A1B8()
{
}

__n128 sub_100F2A1CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A6FAD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F2A220(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FAD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2A258(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  char v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F2A2A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2A2E0()
{
}

uint64_t sub_100F2A2EC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  char v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100F2A338(void *a1)
{
  *a1 = off_101A6FB78;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F2A384(void *a1)
{
  *a1 = off_101A6FB78;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100F2A3F0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100F2A4A0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F2A4B8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100F2A4D8()
{
}

void *sub_100F2A544(void *a1)
{
  *a1 = off_101A6FBC8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F2A590(void *a1)
{
  *a1 = off_101A6FBC8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100F2A5FC()
{
}

void sub_100F2A66C()
{
}

__n128 sub_100F2A680(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6FC08;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F2A6D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FC08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2A70C(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  char v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    char v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100F2A788(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2A7C8()
{
}

void sub_100F2A7D8()
{
}

__n128 sub_100F2A7EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6FC88;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F2A840(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FC88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2A878(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100F2A914(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2A954()
{
}

void sub_100F2A964()
{
}

__n128 sub_100F2A978(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6FD08;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F2A9CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FD08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2AA04(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100F2AAA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2AAE0()
{
}

void sub_100F2AAF0()
{
}

void *sub_100F2AB04(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A6FD88;
  result[1] = v3;
  return result;
}

uint64_t sub_100F2AB4C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6FD88;
  a2[1] = v2;
  return result;
}

void *sub_100F2AB78(uint64_t a1, unsigned int *a2, unsigned __int8 *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *a2;
  FileType v12 = *a3;
  sub_100023950((uint64_t)v47, a8);
  uint64_t v13 = *(void *)(a1 + 8);
  sub_1000DFC90((uint64_t)v48, (uint64_t)v47);
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v40 = 0;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a4;
    uint64_t v40 = *(void *)(a4 + 16);
  }
  uint64_t v14 = (CBSignUtilityLogger *)ctu::path_join_impl();
  CFTypeRef cf = 0;
  MyInstance = (CBSignUtilityLogger *)CBSignUtilityLogger::getMyInstance(v14);
  CBSignUtilityLogger::setLogFunction(MyInstance, (void (*)(const char *))sub_100F25D14);
  v45[0] = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v43[0] = 0;
  v43[1] = 0;
  uint64_t v44 = 0;
  ctu::path_split();
  v42[0] = v45;
  v42[1] = v43;
  char v16 = (capabilities::ct *)sub_100294590(v42, (long long *)buf);
  if (v56 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v52) < 0) {
    operator delete(*(void **)buf);
  }
  uint64_t v17 = (capabilities::ct *)capabilities::ct::supportsECDSASignatures(v16);
  if (v17)
  {
    char v18 = *(NSObject **)(v13 + 40);
    BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      int v20 = v43;
      if (v44 < 0) {
        int v20 = (void **)v43[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Extracting version 3 of the %s signature", buf, 0xCu);
    }
  }
  else
  {
    int v21 = (const void **)capabilities::ct::supportsSHA2Signature(v17);
    if (!v21) {
      goto LABEL_21;
    }
    uint64_t v22 = *(NSObject **)(v13 + 40);
    BOOL v19 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      uint64_t v23 = v43;
      if (v44 < 0) {
        uint64_t v23 = (void **)v43[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Extracting version 2 of the %s signature", buf, 0xCu);
    }
  }
  capabilities::ct::compatibleHardwareConfigurationString((uint64_t *)buf, (capabilities::ct *)v19);
  copyPRISignatureForDeviceNameOnSHA();
  CFTypeRef cf = v41;
  char v41 = 0;
  v42[0] = 0;
  sub_100030068(v42);
  int v21 = sub_100030068(&v41);
  if (SHIBYTE(v52) < 0) {
    operator delete(*(void **)buf);
  }
LABEL_21:
  if (cf) {
    uint64_t v24 = sub_10008324C;
  }
  else {
    uint64_t v24 = 0;
  }
  if (!v24)
  {
    int v25 = *(NSObject **)(v13 + 40);
    int v21 = (const void **)os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if (v21)
    {
      uint64_t v36 = v45;
      if (v46 < 0) {
        uint64_t v36 = (void **)v45[0];
      }
      unint64_t v37 = v43;
      if (v44 < 0) {
        unint64_t v37 = (void **)v43[0];
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v36;
      __int16 v50 = 2080;
      uint64_t v51 = (uint64_t)v37;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "There is no raw signature for the in directory %s for file %s", buf, 0x16u);
    }
  }
  uint64_t v26 = (CBSignUtilityLogger *)CBSignUtilityLogger::getMyInstance((CBSignUtilityLogger *)v21);
  CBSignUtilityLogger::destroyMyInstance(v26);
  if (SHIBYTE(v44) < 0) {
    operator delete(v43[0]);
  }
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[0]);
  }
  BOOL v27 = sub_1005B6DE8();
  sub_10033A644((void *)(v13 + 208), (uint64_t)v48);
  __int16 v28 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v13 + 48) + 16))(*(void *)(v13 + 48), v11);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a5 + 23) >= 0) {
      uint64_t v29 = a5;
    }
    else {
      uint64_t v29 = (uint64_t *)*a5;
    }
    FileType v30 = v12;
    uint64_t v31 = asString(v12);
    BOOL v32 = (void *)asString();
    if (*(char *)(a4 + 23) >= 0) {
      uint64_t v33 = (void *)a4;
    }
    else {
      uint64_t v33 = *(void **)a4;
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v29;
    __int16 v50 = 2080;
    uint64_t v51 = v31;
    __int16 v52 = 2080;
    std::string __p = v32;
    __int16 v54 = 2082;
    long long v55 = v33;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Preparing to send the file %s (%s) format %s from %{public}s", buf, 0x2Au);
    FileType v12 = v30;
  }
  BasebandSettingsDriver::sendFile((uint64_t *)buf, *(BasebandSettingsDriver **)(v13 + 128));
  SendFileProxy::fileType((SendFileProxy *)buf, v12);
  SendFileProxy::fileName();
  SendFileProxy::bundlePath();
  SendFileProxy::filePathToBaseband();
  SendFileProxy::fileFormat();
  v45[0] = (void *)cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v34 = (SendFileProxy *)SendFileProxy::signature();
  SendFileProxy::bypassValidation(v34, v27);
  SendFileProxy::simInstance();
  sub_100030068((const void **)v45);
  SendFileProxy::~SendFileProxy((SendFileProxy *)buf);
  sub_100030068(&cf);
  if (SHIBYTE(v40) < 0) {
    operator delete(__dst[0]);
  }
  sub_100060644(v48);
  return sub_100060644(v47);
}

void sub_100F2B0A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  sub_100030068(&a10);
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100060644(&a36);
  sub_100060644(&a32);
  _Unwind_Resume(a1);
}

uint64_t sub_100F2B180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2B1C0()
{
}

void sub_100F2B1D0()
{
}

__n128 sub_100F2B1E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A6FE18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F2B238(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FE18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2B270(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_100F2B2C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2B300()
{
}

void sub_100F2B310()
{
}

__n128 sub_100F2B324(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6FE98;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F2B378(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FE98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2B3B0(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 8);
  read_rest_value();
  uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }

  return v3(v5, v2);
}

uint64_t sub_100F2B434(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2B474()
{
}

void sub_100F2B484()
{
}

__n128 sub_100F2B498(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A6FF18;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F2B4EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A6FF18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F2B524(void *a1, xpc *this, uint64_t a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  int v6 = *v4;
  unint64_t v7 = 0x10101000000uLL >> (8 * result);
  if (result >= 7) {
    LOBYTE(v7) = 1;
  }
  *uint64_t v4 = v7;
  if (v6 != (v7 & 1))
  {
    uint64_t v8 = (uint64_t (*)(void *, BOOL))a1[3];
    uint64_t v9 = a1[4];
    uint64_t v10 = (void *)(a1[2] + (v9 >> 1));
    if (v9) {
      uint64_t v8 = *(uint64_t (**)(void *, BOOL))(*v10 + v8);
    }
    return v8(v10, v6 != 0);
  }
  return result;
}

uint64_t sub_100F2B5E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2B628()
{
}

void sub_100F2B638()
{
}

void *sub_100F2B64C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A6FF98;
  result[1] = v3;
  return result;
}

uint64_t sub_100F2B694(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A6FF98;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F2B6C0(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  unsigned char *v3 = result;
  return result;
}

uint64_t sub_100F2B6F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2B730()
{
}

void sub_100F2B740()
{
}

void *sub_100F2B754(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A70018;
  result[1] = v3;
  return result;
}

uint64_t sub_100F2B79C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A70018;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F2B7C8(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  unsigned char *v3 = result;
  return result;
}

uint64_t sub_100F2B7F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2B838()
{
}

void sub_100F2B848()
{
}

__n128 sub_100F2B85C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A70098;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F2B8B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A70098;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F2B8E8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1000DF110((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100F2B9A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F2B9C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2BA00()
{
}

void sub_100F2BA10()
{
}

void *sub_100F2BA24(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A70118;
  result[1] = v3;
  return result;
}

uint64_t sub_100F2BA6C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A70118;
  a2[1] = v2;
  return result;
}

void sub_100F2BA98()
{
  xpc_object_t v3 = 0;
  rest::write_rest_value();
  sub_100058DB0(&__p, "/cc/props/turned_off_cellular");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v2 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100F2BB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F2BB80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2BBC0()
{
}

uint64_t *sub_100F2BBCC(uint64_t a1)
{
  uint64_t v2 = a1;
  (*(void (**)(void, const __CFString *, void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(*(void *)a1 + 112) + 16))(*(void *)(*(void *)a1 + 112), @"ICCID", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  return sub_1003C2130(&v2);
}

void sub_100F2BC54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003C2130((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100F2BC68(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (!*((unsigned char *)*a1 + 8))
  {
    uint64_t v13 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Device Config Driver went down", buf, 2u);
    }
LABEL_29:
    operator delete();
  }
  if (*(unsigned char *)(v1 + 160))
  {
LABEL_28:
    (*(void (**)(void))(**(void **)(v1 + 128) + 120))(*(void *)(v1 + 128));
    (*(void (**)(void, uint64_t))(**(void **)(v1 + 128) + 48))(*(void *)(v1 + 128), 3);
    sub_100F25268(v1);
    (*(void (**)(void, void))(**(void **)(v1 + 128) + 96))(*(void *)(v1 + 128), *(unsigned __int8 *)(v1 + 473));
    sub_100F259EC(v1);
    sub_100F26BC0(v1);
    goto LABEL_29;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(v1 + 160), *(Registry **)(v1 + 96));
  xpc_object_t v3 = ServiceMap;
  uint64_t v4 = "11CCXpcServer";
  if (((unint64_t)"11CCXpcServer" & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)((unint64_t)"11CCXpcServer" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_9;
      }
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_9:
    FileType v12 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Could not get XPC Server to register tethering assertion status", buf, 2u);
    }
LABEL_25:
    if ((v11 & 1) == 0) {
      sub_10004D2C8(v9);
    }
    *(unsigned char *)(v1 + 160) = 1;
    goto LABEL_28;
  }
LABEL_15:
  sub_100058DB0(__p, "tethering");
  uint64_t v14 = *(NSObject **)(v1 + 24);
  dispatch_object_t object = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v16 = 0x40000000;
  uint64_t v17 = sub_100F24D60;
  char v18 = &unk_101A6F620;
  uint64_t v19 = v1;
  aBlock = _Block_copy(buf);
  sub_100C65D5C((uint64_t *)__p, &object, &aBlock, &v24);
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  goto LABEL_25;
}

void sub_100F2BF68(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *aBlock, dispatch_object_t object, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  operator delete();
}

uint64_t *sub_100F2BFE4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  int v2 = *(unsigned __int8 *)(v1 + 8);
  if (*(char *)(v1 + 39) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 16), *(void *)(v1 + 24));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(v1 + 16);
    uint64_t v11 = *(void *)(v1 + 32);
  }
  switch(v2)
  {
    case 1:
      xpc_object_t v3 = operator new(0x98uLL);
      v3[1] = 0;
      void v3[2] = 0;
      void *v3 = off_101A70248;
      if (SHIBYTE(v11) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        uint64_t v13 = v11;
      }
      if (SHIBYTE(v13) < 0)
      {
        sub_10004FC84(&v14, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v14 = *(_OWORD *)__p;
        uint64_t v15 = v13;
      }
      sub_100F2C584(v3 + 3);
    case 2:
      uint64_t v4 = operator new(0x98uLL);
      v4[1] = 0;
      void v4[2] = 0;
      *uint64_t v4 = off_101A32BF0;
      if (SHIBYTE(v11) < 0)
      {
        sub_10004FC84(&v14, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        long long v14 = *(_OWORD *)__dst;
        uint64_t v15 = v11;
      }
      sub_100945004(v4 + 3);
    case 3:
      uint64_t v5 = operator new(0x98uLL);
      v5[1] = 0;
      void v5[2] = 0;
      void *v5 = off_101A701A8;
      if (SHIBYTE(v11) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        uint64_t v13 = v11;
      }
      if (SHIBYTE(v13) < 0)
      {
        sub_10004FC84(&v14, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v14 = *(_OWORD *)__p;
        uint64_t v15 = v13;
      }
      sub_100F2C584(v5 + 3);
    case 4:
      uint64_t v6 = operator new(0x98uLL);
      v6[1] = 0;
      _DWORD v6[2] = 0;
      *uint64_t v6 = off_101A701F8;
      if (SHIBYTE(v11) < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)__dst;
        uint64_t v13 = v11;
      }
      if (SHIBYTE(v13) < 0)
      {
        sub_10004FC84(&v14, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        long long v14 = *(_OWORD *)__p;
        uint64_t v15 = v13;
      }
      sub_100F2C584(v6 + 3);
    default:
      if (SHIBYTE(v11) < 0) {
        operator delete(__dst[0]);
      }
      sub_10033CAD4(&v9);
      return sub_100046B58((uint64_t *)&v8);
  }
}

void sub_100F2C404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_100945408(v24);
  if (*(char *)(v25 - 41) < 0) {
    operator delete(*(void **)(v25 - 64));
  }
  std::__shared_weak_count::~__shared_weak_count(v23);
  operator delete(v27);
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10033CAD4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100F2C4E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A701A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F2C508(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A701A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F2C55C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100F2C584(void *a1)
{
}

void sub_100F2C5F0(_Unwind_Exception *a1)
{
  sub_100945408(v1);
  _Unwind_Resume(a1);
}

void sub_100F2C604(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A701F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F2C624(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A701F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F2C678(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100F2C6A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A70248;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F2C6C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A70248;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F2C714(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

uint64_t *sub_100F2C73C(uint64_t **a1, uint64_t *a2)
{
  xpc_object_t v3 = (uint64_t *)a2[1];
  if (v3)
  {
    do
    {
      uint64_t v4 = v3;
      xpc_object_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t v4 = (uint64_t *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      uint64_t v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  unsigned int v7 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_10005EE6C(v7, a2);
  uint64_t v8 = (std::__shared_weak_count *)a2[6];
  if (v8) {
    sub_10004D2C8(v8);
  }
  operator delete(a2);
  return v4;
}

void *sub_100F2C7CC(void *a1)
{
  *a1 = off_101A70298;
  int v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F2C818(void *a1)
{
  *a1 = off_101A70298;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100F2C884(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A70298;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F2C8E0(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A70298;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F2C918(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F2C928(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100F2C968(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100F2CA90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2CAD0()
{
}

uint64_t *sub_100F2CADC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v37 = a1;
  uint64_t v38 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 16);
  uint64_t v4 = *(void *)(v1 + 20);
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v3);
  uint64_t v6 = *(void *)(v2 + 632);
  if (v6)
  {
    unsigned int v7 = v5;
    uint64_t v8 = (void *)(v2 + 632);
    uint64_t v9 = v2 + 632;
    do
    {
      int v10 = *(_DWORD *)(v6 + 32);
      BOOL v11 = v10 < (int)v3;
      if (v10 >= (int)v3) {
        FileType v12 = (uint64_t *)v6;
      }
      else {
        FileType v12 = (uint64_t *)(v6 + 8);
      }
      if (!v11) {
        uint64_t v9 = v6;
      }
      uint64_t v6 = *v12;
    }
    while (*v12);
    if ((void *)v9 != v8 && *(_DWORD *)(v9 + 32) <= (int)v3)
    {
      BOOL v13 = v4 == 0;
      uint64_t v14 = *(void *)(v9 + 40);
      uint64_t v15 = *v5;
      BOOL v16 = os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT);
      if (v14)
      {
        if (!v16) {
          goto LABEL_26;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        uint64_t v17 = "#I Ignoring stale file transfer transaction result: %s";
        char v18 = v15;
        uint32_t v19 = 12;
        goto LABEL_25;
      }
      if (v16)
      {
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N File transfer transaction result: %s", buf, 0xCu);
      }
      if (v4)
      {
        sub_100F23ADC(v2);
        sub_100119D90(*(void **)(v2 + 632));
        *(void *)(v2 + 624) = v8;
        *(_OWORD *)(v2 + 632) = 0u;
      }
      else
      {
        int v20 = sub_100F2C73C((uint64_t **)(v2 + 624), (uint64_t *)v9);
        if (capabilities::ct::supportsNVRAMUpdateWithoutBasebandReboot((capabilities::ct *)v20))
        {
          int v21 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Triggering PRI refresh complete", buf, 2u);
          }
          sub_100F239F4(v2 + 144, v3);
        }
      }
      uint64_t v22 = *(void *)(v2 + 640);
      char v23 = *(NSObject **)(v2 + 40);
      BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
      if (v22)
      {
        if (!v24) {
          goto LABEL_26;
        }
        *(_WORD *)long long buf = 0;
        uint64_t v17 = "#N Waiting for all pending transactions(s) to complete";
        char v18 = v23;
        uint32_t v19 = 2;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
LABEL_26:
        uint64_t v25 = *(void *)(v2 + 640);
        if (v25)
        {
          uint64_t v26 = *(void **)(v2 + 624);
          if (v26 == v8)
          {
            uint64_t v27 = 0;
          }
          else
          {
            uint64_t v27 = 0;
            do
            {
              memset(buf, 0, sizeof(buf));
              BasebandSettings::getModel_sync(v2, *((_DWORD *)v26 + 8), buf);
              if (*(void *)buf) {
                BOOL v28 = (*(uint64_t (**)(void))(**(void **)buf + 88))(*(void *)buf) != 0;
              }
              else {
                BOOL v28 = 0;
              }
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
              uint64_t v29 = (void *)v26[1];
              if (v29)
              {
                do
                {
                  FileType v30 = v29;
                  uint64_t v29 = (void *)*v29;
                }
                while (v29);
              }
              else
              {
                do
                {
                  FileType v30 = (void *)v26[2];
                  BOOL v31 = *v30 == (void)v26;
                  uint64_t v26 = v30;
                }
                while (!v31);
              }
              v27 += v28;
              uint64_t v26 = v30;
            }
            while (v30 != v8);
          }
          if (v27 == v25)
          {
            uint64_t v34 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v25;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I %zu uncommenced transaction(s) remaining. Triggering push again", buf, 0xCu);
            }
            *(_OWORD *)long long buf = 0u;
            long long v40 = 0u;
            sub_100F2D0D0(buf, (void *)(v2 + 176));
            sub_100F23D4C(v2, v13);
            (*(void (**)(void, void))(**(void **)(v2 + 584) + 48))(*(void *)(v2 + 584), 0);
            BasebandSettings::sendLinedupFiles_sync(v2, buf);
            sub_10081A370(buf);
          }
        }
        else
        {
          BOOL v32 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v33;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I No pending transaction. Cleaning up with result: %s", buf, 0xCu);
          }
          sub_100F23D4C(v2, 1);
          (*(void (**)(void, void))(**(void **)(v2 + 584) + 48))(*(void *)(v2 + 584), 0);
        }
        goto LABEL_56;
      }
      if (v24)
      {
        uint64_t v35 = asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v35;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Final file transfer result: %s", buf, 0xCu);
      }
      if (v4)
      {
        BasebandSettings::resetBBAfterFileTransferComplete_sync((BasebandSettings *)v2);
      }
      else if ((v4 & 0x100000000) != 0)
      {
        BasebandSettings::triggerRFSSync_sync((Registry **)v2);
      }
      sub_100F23D4C(v2, v4 == 0);
    }
  }
LABEL_56:
  sub_100F2CFF8(&v38);
  return sub_100046B58((uint64_t *)&v37);
}

void sub_100F2CFB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t *sub_100F2CFF8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_100F2D04C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F2D0D0(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100F2D338(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F2D344(uint64_t a1)
{
}

void *sub_100F2D350(void *a1)
{
  *a1 = off_101A70348;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100F2D3A8(void *a1)
{
  *a1 = off_101A70348;
  uint64_t v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100F2D420(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A70348;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_100F2D474(uint64_t a1, void *a2)
{
  *a2 = off_101A70348;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_100F2D4A0(uint64_t a1)
{
}

void sub_100F2D4A8(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F2D4E4(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "granted";
    if (!v2) {
      uint64_t v5 = "not granted";
    }
    int v6 = 136315138;
    unsigned int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Exclusive baseband operation assertion %s", (uint8_t *)&v6, 0xCu);
  }
  if (v2)
  {
    uint64_t v8 = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&v6);
    (*(void (**)(void, uint64_t, const char *))(**(void **)(v3 + 584) + 40))(*(void *)(v3 + 584), 4, "Exclusive baseband assertion acquired");
  }
}

void sub_100F2D5F4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100F2D610(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F2D650()
{
}

void *sub_100F2D65C(void *a1)
{
  *a1 = off_101A703C8;
  int v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100F2D6B4(void *a1)
{
  *a1 = off_101A703C8;
  int v2 = a1[2];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[2];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100F2D72C(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  int v2 = operator new(0x18uLL);
  void *v2 = off_101A703C8;
  sub_1000E6DB8(v2 + 1, v1);
  return v2;
}

void *sub_100F2D780(uint64_t a1, void *a2)
{
  *a2 = off_101A703C8;
  return sub_1000E6DB8(a2 + 1, (void *)(a1 + 8));
}

void sub_100F2D7AC(uint64_t a1)
{
}

void sub_100F2D7B4(void *a1)
{
  sub_1000E1A10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F2D7F0(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "granted";
    if (!v2) {
      uint64_t v5 = "not granted";
    }
    int v6 = 136315138;
    unsigned int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Prevent baseband reset assertion %s", (uint8_t *)&v6, 0xCu);
  }
  if (v2)
  {
    uint64_t v8 = 0;
    ctu::rest::AssertionHandle::setHandler_impl();
    sub_100060644(&v6);
    (*(void (**)(void, uint64_t, const char *))(**(void **)(v3 + 584) + 40))(*(void *)(v3 + 584), 8, "Prevent baseband reset assertion acquired");
  }
}

void sub_100F2D900(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100F2D91C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F2D95C()
{
}

void sub_100F2D968(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((*(uint64_t (**)(void))(**(void **)(*a1 + 584) + 56))(*(void *)(*a1 + 584)))
  {
    sub_100F248F4(v1);
  }
  else
  {
    int v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "File transfer not in progress. Not expecting to hold baseband assertions", v3, 2u);
    }
  }
  operator delete();
}

void sub_100F2DA24()
{
}

void *sub_100F2DA48(void *a1)
{
  *a1 = off_101A70448;
  int v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F2DA94(void *a1)
{
  *a1 = off_101A70448;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_100F2DB00(uint64_t a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A70448;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  result[3] = *(void *)(a1 + 24);
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100F2DB68(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A70448;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F2DBB0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100F2DBC0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100F2DC00(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_100F2DD00(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F2DD40()
{
}

void sub_100F2DD4C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)*a1 + 2));
  uint64_t v4 = v3;
  if (!*((unsigned char *)v1 + 12))
  {
    uint64_t v5 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = asString(*((unsigned __int8 *)v1 + 13));
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#E Pushing %s failed, soldiering on", buf, 0xCu);
    }
    sub_100F23ADC(v2);
  }
  if (!*((unsigned char *)v1 + 13))
  {
    unsigned int v7 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I PRI was pushed. Notify AttachAPN manager", buf, 2u);
    }
    uint64_t v8 = *(void *)(v2 + 568);
    if (v8) {
      (*(void (**)(uint64_t, void))(*(void *)v8 + 80))(v8, *((unsigned int *)v1 + 2));
    }
  }
  *(_OWORD *)long long buf = 0uLL;
  BasebandSettings::getModel_sync(v2, *((_DWORD *)v1 + 2), buf);
  if (*(void *)buf)
  {
    (*(void (**)(void, void, void))(**(void **)buf + 56))(*(void *)buf, *((unsigned __int8 *)v1 + 13), *((unsigned __int8 *)v1 + 12));
  }
  else
  {
    uint64_t v9 = *v4;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not get model %s", __p, 0xCu);
    }
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (*((unsigned char *)v1 + 12)) {
    goto LABEL_17;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*((unsigned __int8 *)v1 + 12), *(Registry **)(v2 + 96));
  BOOL v11 = ServiceMap;
  if (v12 < 0)
  {
    BOOL v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v12;
  BOOL v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
LABEL_26:
      uint32_t v19 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
      char v20 = (char)v19;
      if (v17)
      {
        sub_10004D2C8(v17);
        if ((v20 & 1) == 0) {
          goto LABEL_17;
        }
      }
      else if (!v19)
      {
        goto LABEL_17;
      }
      if (capabilities::ct::supportsLogDumpForFailedBundlePush(v19))
      {
        sub_100058DB0(__p, "Carrier Bundle file push failed");
        RequestDumpStatePayload::RequestDumpStatePayload();
        sub_10097E680();
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        if (v22 < 0) {
          operator delete(*(void **)__p);
        }
      }
LABEL_17:
      sub_100F248F4(v2);
      operator delete();
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  goto LABEL_26;
}

void sub_100F2E0E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  operator delete();
}

uint64_t *sub_100F2E17C(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = (dispatch_group_t *)v1;
  uint64_t v2 = *(void *)(v1 + 8);
  uint64_t v3 = *(NSObject **)(v2 + 168);
  if (v3)
  {
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I File transfer in progress while sleep-cycle starts; delaying sleep until file transfer complete.",
        buf,
        2u);
      uint64_t v3 = *(NSObject **)(v2 + 168);
    }
    uint64_t v5 = *(NSObject **)(v2 + 24);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v11 = 1174405120;
    uint64_t v12 = sub_100F2E2E8;
    BOOL v13 = &unk_101A704B8;
    uint64_t v14 = v2;
    uint64_t v6 = *(NSObject **)v1;
    dispatch_group_t group = v6;
    if (v6)
    {
      dispatch_retain(v6);
      if (group) {
        dispatch_group_enter(group);
      }
    }
    dispatch_group_notify(v3, v5, buf);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  else
  {
    (*(void (**)(void, void))(**(void **)(v2 + 128) + 104))(*(void *)(v2 + 128), 0);
  }
  sub_10062AF08(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100F2E2CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, dispatch_group_t *a10)
{
}

uint64_t sub_100F2E2E8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I File transfer complete; letting sleep cycle continue",
      v4,
      2u);
  }
  return (*(uint64_t (**)(void, void))(**(void **)(v1 + 128) + 104))(*(void *)(v1 + 128), 0);
}

void sub_100F2E378(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, uint64_t))(**(void **)(**(void **)a1 + 128) + 104))(*(void *)(**(void **)a1 + 128), 1);
  operator delete();
}

void sub_100F2E3F4()
{
}

void sub_100F2E420(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100F24D68(**a1, *((unsigned __int8 *)*a1 + 8));
  operator delete();
}

void sub_100F2E478()
{
}

uint64_t *sub_100F2E4A4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v9 = a1;
  int v10 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (capabilities::ct *)sub_1000DFC90((uint64_t)v11, (uint64_t)(v1 + 1));
  int v4 = capabilities::ct::supportsTurboMode(v3);
  uint64_t v5 = *(NSObject **)(v2 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Activating turbo mode.", buf, 2u);
    }
    uint64_t v7 = *(void *)(v2 + 128);
    sub_1000DFC90((uint64_t)buf, (uint64_t)v11);
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v7 + 184))(v7, buf);
    sub_100060644(buf);
  }
  else
  {
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I This device does not support turbo mode.", buf, 2u);
    }
    sub_1000607A8((uint64_t)v11, 0);
  }
  sub_100060644(v11);
  sub_1003F5954((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_100F2E5F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
}

void sub_100F2E630()
{
}

void *sub_100F2E644()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A704F8;
  return result;
}

void sub_100F2E67C(uint64_t a1, void *a2)
{
  *a2 = off_101A704F8;
}

uint64_t sub_100F2E6A4@<X0>(_OWORD *a1@<X8>)
{
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return CSIGetGmtTime(a1);
}

uint64_t sub_100F2E6B8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F2E6F8()
{
}

void *sub_100F2E704(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F2E788(_DWORD **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *a1;
  int v2 = v1[2];
  if (v2 != *(_DWORD *)(*(void *)v1 + 528)) {
    *(_DWORD *)(*(void *)v1 + 528) = v2;
  }
  operator delete();
}

void sub_100F2E7E0(uint64_t *a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = *a1;
  xpc_object_t object = xpc_int64_create(*(int *)(*(void *)*a1 + 528));
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  v4[0] = *(void *)(v1 + 8);
  v4[1] = "kLTEWithCDRXState";
  sub_100035E70((uint64_t)v4, &object, &v6);
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(object);
  int v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

uint64_t sub_100F2E898(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t *sub_100F2E8A8(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  xpc_object_t v6 = v1;
  uint64_t v2 = *(void *)(*v1 + 568);
  if (v2)
  {
    uint64_t v3 = v1[1];
    dispatch_group_t group = v3;
    if (v3)
    {
      dispatch_retain(v3);
      dispatch_group_enter(v3);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 48))(v2, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  sub_100088C88((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F2E950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F2E984(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v34 = a1;
  uint64_t v35 = v1;
  uint64_t v2 = *v1;
  int v4 = v1 + 2;
  uint64_t v3 = v1[2];
  if (v3)
  {
    uint64_t v5 = v1 + 2;
    uint64_t v6 = v1[2];
    do
    {
      int v7 = *(_DWORD *)(v6 + 32);
      BOOL v8 = v7 < 2;
      if (v7 >= 2) {
        uint64_t v9 = (uint64_t *)v6;
      }
      else {
        uint64_t v9 = (uint64_t *)(v6 + 8);
      }
      if (!v8) {
        uint64_t v5 = (uint64_t *)v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && *((int *)v5 + 8) <= 2)
    {
      if (*((unsigned char *)v5 + 240) == 2)
      {
        BasebandSettings::lineupFile_sync((void *)*v1, 2, 0, 0);
        BasebandSettings::compareAndLineupFile_sync((void *)v2, 2, 6, 0);
        BasebandSettings::lineupFile_sync((void *)v2, 2, 8, 0);
      }
      else
      {
        BasebandSettings::bbset_checkForCBFilesUpdate_sync(*v1, 2, 0);
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      BasebandSettings::getModel_sync(v2, 2, buf);
      uint64_t v10 = *(void *)buf;
      if (*(void *)buf)
      {
        sub_100058198(&v38, (const void **)v5 + 33);
        unsigned int v11 = (*(unsigned __int16 (**)(uint64_t, const void **))(*(void *)v10 + 112))(v10, &v38);
        sub_100057D78(&v38);
        if (v11 >= 0x100) {
          BasebandSettings::lineupFile_sync((void *)v2, 2, 0, 0);
        }
      }
      else
      {
        uint64_t v12 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), 2);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)BOOL v39 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not find model for PRI mismatch detection", v39, 2u);
        }
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      uint64_t v3 = *v4;
    }
    if (v3)
    {
      BOOL v13 = v1 + 2;
      do
      {
        int v14 = *(_DWORD *)(v3 + 32);
        BOOL v15 = v14 < 1;
        if (v14 >= 1) {
          BOOL v16 = (uint64_t *)v3;
        }
        else {
          BOOL v16 = (uint64_t *)(v3 + 8);
        }
        if (!v15) {
          BOOL v13 = (uint64_t *)v3;
        }
        uint64_t v3 = *v16;
      }
      while (*v16);
      if (v13 != v4 && *((int *)v13 + 8) <= 1)
      {
        char v17 = *((unsigned char *)v13 + 160);
        char v18 = *((unsigned char *)v13 + 240);
        uint32_t v19 = (const void **)(v13 + 33);
        sub_100058198(&v37, (const void **)v13 + 32);
        sub_100058198((const void **)&theDict, v19);
        char v20 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), 1);
        int v21 = *v20;
        if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = asString();
          uint64_t v23 = asString();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v22;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v23;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle setup with bundle type (%s) and change type (%s)", buf, 0x16u);
        }
        if (theDict) {
          BOOL v24 = sub_100080778;
        }
        else {
          BOOL v24 = 0;
        }
        if (!v24)
        {
          BOOL v31 = *v20;
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#N Missing activation info dictionary", buf, 2u);
          }
          goto LABEL_54;
        }
        CFDictionaryRef Value = CFDictionaryGetValue(theDict, kCTPostponementInfoAvailable);
        uint64_t v26 = Value;
        if (!Value || (CFTypeID v27 = CFGetTypeID(Value), v27 != CFStringGetTypeID()))
        {
          FileType v30 = *v20;
          if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Missing postponement info from activation dictionary", buf, 2u);
          }
          goto LABEL_54;
        }
        if (CFEqual(v26, @"CarrierInfo"))
        {
          sub_100058198((const void **)buf, &v37);
          sub_100058198((const void **)v39, (const void **)&theDict);
          BasebandSettings::handleCarrierInfo_sync(v2, 1, v17, v18, (const __CFDictionary **)buf, (const __CFDictionary **)v39);
        }
        else if (CFEqual(v26, @"DefaultCarrierInfo"))
        {
          sub_100058198((const void **)buf, &v37);
          sub_100058198((const void **)v39, (const void **)&theDict);
          BasebandSettings::handleDefaultCarrierInfo_sync(v2, 1, v17, v18, (CFDictionaryRef *)buf, (CFDictionaryRef *)v39);
        }
        else
        {
          if (!CFEqual(v26, @"SIMCarrierInfo"))
          {
            BOOL v32 = *v20;
            if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
            {
              memset(buf, 0, sizeof(buf));
              ctu::cf::assign();
              *(_OWORD *)BOOL v39 = *(_OWORD *)buf;
              uint64_t v40 = *(void *)&buf[16];
              uint64_t v33 = v39;
              if ((buf[23] & 0x80u) != 0) {
                uint64_t v33 = *(uint8_t **)buf;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v33;
              _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Unhandled postponement info in activation dictionary: %s", buf, 0xCu);
              if (SHIBYTE(v40) < 0) {
                operator delete(*(void **)v39);
              }
            }
            goto LABEL_54;
          }
          sub_100058198((const void **)buf, &v37);
          sub_100058198((const void **)v39, (const void **)&theDict);
          BasebandSettings::handleSIMCarrierInfo_sync(v2, 1u, v17, v18, (CFDictionaryRef *)buf, (CFDictionaryRef *)v39);
        }
        sub_100057D78((const void **)v39);
        sub_100057D78((const void **)buf);
LABEL_54:
        sub_100057D78((const void **)&theDict);
        sub_100057D78(&v37);
        goto LABEL_44;
      }
    }
  }
  uint64_t v28 = v1[1];
  if ((uint64_t *)v28 != v4)
  {
    (*(void (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(v28 + 32));
    *(void *)long long buf = off_101A705C0;
    *(void *)&uint8_t buf[8] = v2;
    uint64_t v42 = buf;
    BasebandSettings::sendLinedupFiles_sync(v2, buf);
    sub_10081A370(buf);
  }
LABEL_44:
  sub_100F2F00C((uint64_t *)&v35);
  return sub_100046B58((uint64_t *)&v34);
}

void sub_100F2EF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a12);
  sub_100057D78(&a13);
  sub_100F2F00C(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F2F00C(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10069AE60(v1 + 8, *(const void ***)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_100F2F064()
{
}

void *sub_100F2F078(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A705C0;
  result[1] = v3;
  return result;
}

uint64_t sub_100F2F0C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A705C0;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F2F0EC(uint64_t a1)
{
  return BasebandSettings::fireBasebandPostponementStatus_sync(*(Registry ***)(a1 + 8));
}

uint64_t sub_100F2F0F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F2F134()
{
}

void sub_100F2F140(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (int *)(*a1 + 1);
  uint64_t v3 = **a1;
  int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *v2);
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v5 = *(PersonalityInfo ****)(v3 + 448);
  uint64_t v6 = *v5;
  int v7 = v5[1];
  if (v6 != v7)
  {
    while (*((unsigned char *)*v6 + 49) || *((_DWORD *)*v6 + 13) != *v2)
    {
      v6 += 2;
      if (v6 == v7) {
        goto LABEL_22;
      }
    }
  }
  if (v6 == v7)
  {
LABEL_22:
    BOOL v8 = 0;
  }
  else
  {
    uint64_t v9 = *v6;
    BOOL v8 = (std::__shared_weak_count *)v6[1];
    uint64_t v35 = *v6;
    uint64_t v36 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v9 && isReal())
    {
      uint64_t v10 = *v4;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = PersonalityInfo::logPrefix(v9);
        uint64_t v12 = "ON";
        if (!*((unsigned char *)v1 + 12)) {
          uint64_t v12 = "OFF";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v11;
        __int16 v38 = 2080;
        BOOL v39 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s: setting turnOffCellular to %s", buf, 0x16u);
      }
      BOOL v13 = (uint64_t **)(v3 + 648);
      if (*((unsigned char *)v1 + 12))
      {
        sub_10078C71C(v13, v2, v2);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(v3 + 96));
        BOOL v16 = ServiceMap;
        if (v17 < 0)
        {
          char v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v19 = 5381;
          do
          {
            uint64_t v17 = v19;
            unsigned int v20 = *v18++;
            uint64_t v19 = (33 * v19) ^ v20;
          }
          while (v20);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v17;
        int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
        if (v21)
        {
          uint64_t v23 = v21[3];
          uint64_t v22 = (std::__shared_weak_count *)v21[4];
          if (v22)
          {
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v16);
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v22);
            char v24 = 0;
LABEL_36:
            (*(void (**)(uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void, void, uint64_t, void))(*(void *)v23 + 48))(v23, (uint64_t)v9 + 24, @"TurnedOffCellular", kCFBooleanTrue, 0, 0, 1, 0);
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v23 = 0;
        }
        std::mutex::unlock(v16);
        uint64_t v22 = 0;
        char v24 = 1;
        goto LABEL_36;
      }
      sub_100A37530(v13, *v2);
      CFTypeID v27 = (std::mutex *)Registry::getServiceMap(v26, *(Registry **)(v3 + 96));
      uint64_t v28 = v27;
      if (v29 < 0)
      {
        FileType v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v31 = 5381;
        do
        {
          uint64_t v29 = v31;
          unsigned int v32 = *v30++;
          uint64_t v31 = (33 * v31) ^ v32;
        }
        while (v32);
      }
      std::mutex::lock(v27);
      *(void *)long long buf = v29;
      uint64_t v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
      if (v33)
      {
        uint64_t v34 = v33[3];
        uint64_t v22 = (std::__shared_weak_count *)v33[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v28);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v24 = 0;
LABEL_39:
          (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v34 + 72))(v34, (uint64_t)v9 + 24, @"TurnedOffCellular", 0, 0, 1);
LABEL_40:
          if ((v24 & 1) == 0) {
            sub_10004D2C8(v22);
          }
          sub_100F2752C(v3);
          sub_100F26BC0(v3);
          sub_100F27384(v3, &v35, *((unsigned __int8 *)v1 + 12));
          BOOL v8 = v36;
          if (!v36) {
LABEL_27:
          }
            operator delete();
LABEL_26:
          sub_10004D2C8(v8);
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v34 = 0;
      }
      std::mutex::unlock(v28);
      uint64_t v22 = 0;
      char v24 = 1;
      goto LABEL_39;
    }
  }
  uint64_t v25 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I turnOffCellular: failed to find persona", buf, 2u);
  }
  if (!v8) {
    goto LABEL_27;
  }
  goto LABEL_26;
}

void sub_100F2F55C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  operator delete();
}

BOOL sub_100F2F5D4(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 40);
  uint64_t v2 = (uint64_t *)(*(void *)v1 + 656);
  uint64_t v3 = *v2;
  if (!*v2) {
    goto LABEL_11;
  }
  int v4 = v1[2];
  uint64_t v5 = *(void *)v1 + 656;
  do
  {
    int v6 = *(_DWORD *)(v3 + 28);
    BOOL v7 = v6 < v4;
    if (v6 >= v4) {
      BOOL v8 = (uint64_t *)v3;
    }
    else {
      BOOL v8 = (uint64_t *)(v3 + 8);
    }
    if (!v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if ((uint64_t *)v5 == v2 || v4 < *(_DWORD *)(v5 + 28)) {
LABEL_11:
  }
    uint64_t v5 = (uint64_t)v2;
  return v5 != (void)v2;
}

uint64_t sub_100F2F630(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (rest::operator!=())
    {
      uint64_t v4 = v2 + 48;
      uint64_t v3 = *(void **)(v2 + 48);
      *(unsigned char *)(v2 + 32) = *(unsigned char *)(a1 + 16);
      sub_1000346F8(v2 + 40, v3);
      *(void *)(v2 + 40) = *(void *)(a1 + 24);
      uint64_t v5 = (void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 32);
      *(void *)(v2 + 48) = v6;
      uint64_t v7 = *(void *)(a1 + 40);
      *(void *)(v2 + 56) = v7;
      if (v7)
      {
        *(void *)(v6 + 16) = v4;
        *(void *)(a1 + 24) = v5;
        void *v5 = 0;
        *(void *)(a1 + 40) = 0;
      }
      else
      {
        *(void *)(v2 + 40) = v4;
      }
      uint64_t v8 = *(void *)(v2 + 24);
      if (v8) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, v2 + 32);
      }
    }
  }
  sub_1000346F8(a1 + 24, *(void **)(a1 + 32));
  return a1;
}

id sub_100F2F714(uint64_t a1)
{
  uint64_t v2 = objc_opt_new();
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v3 = objc_opt_new();
    [v2 setModelVector:v3];

    uint64_t v4 = objc_opt_new();
    uint64_t v5 = [v2 modelVector];
    [v5 setDefaultVector:v4];

    if (*(int *)(a1 + 4) >= 1)
    {
      uint64_t v6 = objc_opt_new();
      uint64_t v7 = [v2 modelVector];
      uint64_t v8 = [v7 defaultVector];
      [v8 setX:v6];

      uint64_t v9 = +[NSNumber numberWithDouble:(double)*(int *)a1];
      uint64_t v10 = [v2 modelVector];
      uint64_t v11 = [v10 defaultVector];
      uint64_t v12 = [v11 x];
      [v12 setOffset:v9];

      char v13 = +[NSNumber numberWithDouble:(double)*(int *)(a1 + 4)];
      int v14 = [v2 modelVector];
      BOOL v15 = [v14 defaultVector];
      BOOL v16 = [v15 x];
      [v16 setRange:v13];
    }
    if (*(int *)(a1 + 12) >= 1)
    {
      uint64_t v17 = objc_opt_new();
      char v18 = [v2 modelVector];
      uint64_t v19 = [v18 defaultVector];
      [v19 setY:v17];

      unsigned int v20 = +[NSNumber numberWithDouble:(double)*(int *)(a1 + 8)];
      int v21 = [v2 modelVector];
      uint64_t v22 = [v21 defaultVector];
      uint64_t v23 = [v22 y];
      [v23 setOffset:v20];

      char v24 = +[NSNumber numberWithDouble:(double)*(int *)(a1 + 12)];
      uint64_t v25 = [v2 modelVector];
      uint64_t v26 = [v25 defaultVector];
      CFTypeID v27 = [v26 y];
      [v27 setRange:v24];
    }
  }

  return v2;
}

void sub_100F2F9C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100F2FA54(uint64_t a1)
{
  id v139 = objc_alloc_init((Class)CTConnectionAssistantState);
  [v139 setVersion:*(void *)a1];
  id v2 = [objc_alloc((Class)CTStewieState) initWithStewieState:a1 + 8];
  [v139 setStewieState:v2];

  int v3 = *(_DWORD *)(a1 + 380);
  if (v3 == 2) {
    uint64_t v4 = 2;
  }
  else {
    uint64_t v4 = v3 == 1;
  }
  [v139 setInternetInterface:v4];
  if (*(unsigned char *)(a1 + 56))
  {
    id v5 = objc_alloc_init((Class)CTCATarget);
    [v139 setCurrentTarget:v5];

    uint64_t v6 = +[NSNumber numberWithUnsignedInteger:*(unsigned int *)(a1 + 32)];
    uint64_t v7 = [v139 currentTarget];
    [v7 setTargetId:v6];

    uint64_t v8 = +[NSNumber numberWithDouble:*(double *)(a1 + 40)];
    uint64_t v9 = [v139 currentTarget];
    [v9 setX:v8];

    uint64_t v10 = +[NSNumber numberWithDouble:*(double *)(a1 + 48)];
    uint64_t v11 = [v139 currentTarget];
    [v11 setY:v10];
  }
  if (*(unsigned char *)(a1 + 128))
  {
    id v12 = objc_alloc_init((Class)CTCAServiceIntervals);
    [v139 setServiceIntervals:v12];

    if (!*(unsigned char *)(a1 + 128)) {
      sub_10016C840();
    }
    char v13 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)(a1 + 80) / 1000000)];
    int v14 = [v139 serviceIntervals];
    [v14 setStartsAt:v13];

    BOOL v15 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)(a1 + 88) / 1000000)];
    BOOL v16 = [v139 serviceIntervals];
    [v16 setEndsAt:v15];

    int v17 = *(unsigned __int8 *)(a1 + 96);
    char v18 = [v139 serviceIntervals];
    [v18 setAtStart:v17 != 0];

    if (*(void *)(a1 + 104) != *(void *)(a1 + 112))
    {
      uint64_t v19 = objc_opt_new();
      unsigned int v20 = *(void **)(a1 + 104);
      int v21 = *(void **)(a1 + 112);
      while (v20 != v21)
      {
        uint64_t v22 = +[NSDate dateWithTimeIntervalSince1970:(double)(*v20 / 1000000)];
        [v19 addObject:v22];

        ++v20;
      }
      uint64_t v23 = +[NSArray arrayWithArray:v19];
      char v24 = [v139 serviceIntervals];
      [v24 setChangesAt:v23];
    }
  }
  if (*(unsigned char *)(a1 + 152))
  {
    uint64_t v25 = objc_opt_new();
    [v139 setSilenceInterval:v25];

    if (!*(unsigned char *)(a1 + 152)) {
      sub_10016C840();
    }
    uint64_t v26 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)(a1 + 136) / 1000000)];
    CFTypeID v27 = [v139 silenceInterval];
    [v27 setStartsAt:v26];

    uint64_t v28 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)(a1 + 144) / 1000000)];
    uint64_t v29 = [v139 silenceInterval];
    [v29 setEndsAt:v28];
  }
  if (*(unsigned char *)(a1 + 68))
  {
    id v30 = objc_alloc_init((Class)CTCATargetVisibility);
    [v139 setTargetVisibility:v30];

    int v31 = *(_DWORD *)(a1 + 64);
    unsigned int v32 = [v139 targetVisibility];
    uint64_t v33 = v32;
    uint64_t v34 = (v31 - 1);
    if (v34 < 3) {
      uint64_t v35 = v34 + 1;
    }
    else {
      uint64_t v35 = 0;
    }
    [v32 setAggregateVisibility:v35];
  }
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v36 = objc_opt_new();
    [v139 setLocationState:v36];

    unint64_t v37 = [v139 locationState];
    [v37 setLocationAcquisitionStatus:1];
  }
  if (*(unsigned char *)(a1 + 240))
  {
    id v38 = objc_alloc_init((Class)CTCAConnectionState);
    [v139 setConnectionState:v38];

    int v39 = *(_DWORD *)(a1 + 160);
    uint64_t v40 = [v139 connectionState];
    char v41 = v40;
    uint64_t v42 = (v39 - 1);
    if (v42 < 3) {
      uint64_t v43 = v42 + 1;
    }
    else {
      uint64_t v43 = 0;
    }
    [v40 setConnectionStatus:v43];

    int v44 = *(_DWORD *)(a1 + 164);
    BOOL v45 = [v139 connectionState];
    uint64_t v46 = v45;
    if (v44 == 2) {
      uint64_t v47 = 2;
    }
    else {
      uint64_t v47 = v44 == 1;
    }
    [v45 setSyncStatus:v47];

    int v48 = *(_DWORD *)(a1 + 168);
    long long v49 = [v139 connectionState];
    __int16 v50 = v49;
    if (v48 == 2) {
      uint64_t v51 = 2;
    }
    else {
      uint64_t v51 = v48 == 1;
    }
    [v49 setRegistrationStatus:v51];

    if (*(unsigned char *)(a1 + 176))
    {
      int v52 = *(_DWORD *)(a1 + 172);
      long long v53 = [v139 connectionState];
      __int16 v54 = v53;
      uint64_t v55 = (v52 - 1);
      if (v55 < 4) {
        uint64_t v56 = v55 + 1;
      }
      else {
        uint64_t v56 = 0;
      }
      [v53 setCongestionStatus:v56];
    }
    else
    {
      __int16 v54 = [v139 connectionState];
      [v54 setCongestionStatus:0];
    }

    if (*(unsigned char *)(a1 + 184))
    {
      long long v57 = +[NSNumber numberWithInteger:*(int *)(a1 + 180)];
      uint64_t v58 = [v139 connectionState];
      [v58 setRssi:v57];
    }
    if (*(unsigned char *)(a1 + 232))
    {
      id v59 = objc_alloc_init((Class)CTCATransmissionProgress);
      BOOL v60 = [v139 connectionState];
      [v60 setCurrentTransmissionProgress:v59];

      CFUUIDRef v61 = *(const __CFUUID **)(a1 + 192);
      if (v61) {
        BOOL v62 = sub_100136254;
      }
      else {
        BOOL v62 = 0;
      }
      if (v62)
      {
        BOOL v63 = (__CFString *)CFUUIDCreateString(kCFAllocatorDefault, v61);
        BOOL v64 = [v139 connectionState];
        BOOL v65 = [v64 currentTransmissionProgress];
        [v65 setMessageId:v63];
      }
      if (*(unsigned char *)(a1 + 208))
      {
        BOOL v66 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)(a1 + 200) / 1000000)];
        BOOL v67 = [v139 connectionState];
        BOOL v68 = [v67 currentTransmissionProgress];
        [v68 setStartedAt:v66];
      }
      if (*(unsigned char *)(a1 + 220))
      {
        BOOL v69 = +[NSNumber numberWithUnsignedInteger:*(unsigned int *)(a1 + 216)];
        BOOL v70 = [v139 connectionState];
        BOOL v71 = [v70 currentTransmissionProgress];
        [v71 setEstimatedDurationSeconds:v69];
      }
      if (*(unsigned char *)(a1 + 225))
      {
        BOOL v72 = +[NSNumber numberWithUnsignedInteger:*(unsigned __int8 *)(a1 + 224)];
        BOOL v73 = [v139 connectionState];
        BOOL v74 = [v73 currentTransmissionProgress];
        [v74 setProgressPercents:v72];
      }
      uint64_t v75 = (*(_DWORD *)(a1 + 228) - 1);
      if (v75 < 7) {
        uint64_t v76 = v75 + 1;
      }
      else {
        uint64_t v76 = 0;
      }
      BOOL v77 = [v139 connectionState];
      BOOL v78 = [v77 currentTransmissionProgress];
      [v78 setPayloadType:v76];
    }
  }
  if (*(unsigned char *)(a1 + 260))
  {
    id v79 = objc_alloc_init((Class)CTCAConversationState);
    [v139 setConversationState:v79];

    int v80 = *(_DWORD *)(a1 + 248);
    BOOL v81 = [v139 conversationState];
    BOOL v82 = v81;
    uint64_t v83 = (v80 - 1);
    if (v83 < 4) {
      uint64_t v84 = v83 + 1;
    }
    else {
      uint64_t v84 = 0;
    }
    [v81 setRequestReason:v84];

    BOOL v85 = +[NSNumber numberWithInt:*(unsigned __int8 *)(a1 + 252)];
    BOOL v86 = [v139 conversationState];
    [v86 setConversationId:v85];

    int v87 = *(unsigned __int8 *)(a1 + 253);
    BOOL v88 = [v139 conversationState];
    [v88 setCommitted:v87 != 0];

    LODWORD(v86) = *(unsigned __int8 *)(a1 + 256);
    uint64_t v89 = *(unsigned __int16 *)(a1 + 254);
    BOOL v90 = [v139 conversationState];
    BOOL v91 = v90;
    if (v86) {
      uint64_t v92 = v89;
    }
    else {
      uint64_t v92 = 0;
    }
    [v90 setFromService:v92];
  }
  if (*(unsigned char *)(a1 + 296))
  {
    BOOL v93 = objc_opt_new();
    [v139 setRoadsideConversationState:v93];

    BOOL v94 = +[NSNumber numberWithInt:*(unsigned __int8 *)(a1 + 264)];
    BOOL v95 = [v139 roadsideConversationState];
    [v95 setConversationId:v94];

    int v96 = *(unsigned __int8 *)(a1 + 265);
    BOOL v97 = [v139 roadsideConversationState];
    [v97 setCommitted:v96 != 0];

    if (*(unsigned char *)(a1 + 280))
    {
      BOOL v98 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 272)];
      BOOL v99 = [v139 roadsideConversationState];
      [v99 setProviderId:v98];
    }
    int v100 = *(unsigned __int8 *)(a1 + 290);
    uint64_t v101 = *(unsigned __int16 *)(a1 + 288);
    BOOL v102 = [v139 roadsideConversationState];
    BOOL v103 = v102;
    if (v100) {
      uint64_t v104 = v101;
    }
    else {
      uint64_t v104 = 0;
    }
    [v102 setFromService:v104];
  }
  BOOL v105 = (void *)(a1 + 304);
  if (*(char *)(a1 + 327) < 0)
  {
    if (!*(void *)(a1 + 312)) {
      goto LABEL_78;
    }
    BOOL v105 = (void *)*v105;
    goto LABEL_77;
  }
  if (*(unsigned char *)(a1 + 327))
  {
LABEL_77:
    BOOL v106 = +[NSString stringWithUTF8String:v105];
    [v139 setIso3166Alpha3CountryCode:v106];
  }
LABEL_78:
  if (*(void *)(a1 + 328))
  {
    BOOL v107 = objc_opt_new();
    [v139 setServicePartners:v107];

    uint64_t v108 = *(void *)(a1 + 328);
    if (*(unsigned char *)(v108 + 24))
    {
      BOOL v109 = objc_opt_new();
      uint64_t v110 = *(void *)(a1 + 328);
      if (!*(unsigned char *)(v110 + 24)) {
        sub_10016C840();
      }
      BOOL v113 = *(void **)v110;
      BOOL v112 = (void *)(v110 + 8);
      BOOL v111 = v113;
      if (v113 != v112)
      {
        do
        {
          BOOL v114 = objc_opt_new();
          BOOL v116 = (uint64_t *)v111[5];
          BOOL v115 = (uint64_t *)v111[6];
          while (v116 != v115)
          {
            BOOL v117 = v116;
            if (*((char *)v116 + 23) < 0) {
              BOOL v117 = (uint64_t *)*v116;
            }
            BOOL v118 = +[NSString stringWithUTF8String:v117];
            [v114 addObject:v118];

            v116 += 3;
          }
          BOOL v119 = +[NSNumber numberWithUnsignedShort:*((unsigned __int16 *)v111 + 16)];
          [v109 setObject:v114 forKeyedSubscript:v119];

          BOOL v120 = (void *)v111[1];
          if (v120)
          {
            do
            {
              BOOL v121 = v120;
              BOOL v120 = (void *)*v120;
            }
            while (v120);
          }
          else
          {
            do
            {
              BOOL v121 = (void *)v111[2];
              BOOL v122 = *v121 == (void)v111;
              BOOL v111 = v121;
            }
            while (!v122);
          }
          BOOL v111 = v121;
        }
        while (v121 != v112);
      }
      BOOL v123 = [v139 servicePartners];
      [v123 setPartners:v109];

      uint64_t v108 = *(void *)(a1 + 328);
    }
    __int16 v124 = *(_WORD *)(v108 + 32);
    if (v124)
    {
      BOOL v125 = [v139 servicePartners];
      [v125 setFootnotesToShowMask:v124 & 7];
    }
  }
  if (*(unsigned char *)(a1 + 368))
  {
    BOOL v126 = objc_opt_new();
    [v139 setConnectionClosedState:v126];

    int v127 = *(_DWORD *)(a1 + 344) - 1;
    if (v127 > 0xF) {
      uint64_t v128 = 0;
    }
    else {
      uint64_t v128 = qword_101593120[v127];
    }
    BOOL v129 = [v139 connectionClosedState];
    [v129 setReason:v128];

    BOOL v130 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)(a1 + 352) / 1000000)];
    BOOL v131 = [v139 connectionClosedState];
    [v131 setClosedAt:v130];

    uint64_t v132 = *(unsigned __int16 *)(a1 + 360);
    BOOL v133 = [v139 connectionClosedState];
    [v133 setWasActiveServices:v132];
  }
  if (*(unsigned char *)(a1 + 377))
  {
    BOOL v134 = objc_opt_new();
    [v139 setTryOutState:v134];

    int v135 = *(unsigned __int8 *)(a1 + 376);
    BOOL v136 = [v139 tryOutState];
    [v136 setTryOutOfferPending:v135 != 0];
  }
  [v139 setIsEmergencyVoiceCallCapable:*(unsigned __int8 *)(a1 + 378)];
  id v137 = v139;

  return v137;
}

void sub_100F30654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id sub_100F30810(void *a1)
{
  uint64_t v22 = objc_opt_new();
  id v2 = objc_opt_new();
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  if (v3 == v4) {
    goto LABEL_10;
  }
  id v5 = 0;
  do
  {
    if (v5)
    {
      uint64_t v6 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)v3 / 1000000)];
      uint64_t v7 = [v5 at];

      if (v6 == v7) {
        goto LABEL_7;
      }
      uint64_t v8 = +[NSArray arrayWithArray:v2];
      [v5 setTargets:v8];

      [v22 addObject:v5];
    }
    uint64_t v9 = objc_opt_new();
    uint64_t v10 = +[NSDate dateWithTimeIntervalSince1970:(double)(*(void *)v3 / 1000000)];
    [v9 setAt:v10];

    uint64_t v11 = objc_opt_new();
    id v5 = v9;
    id v2 = (void *)v11;
LABEL_7:
    id v12 = objc_opt_new();
    char v13 = +[NSNumber numberWithUnsignedInteger:*(unsigned int *)(v3 + 8)];
    [v12 setTargetId:v13];

    int v14 = +[NSNumber numberWithDouble:*(double *)(v3 + 16)];
    [v12 setX:v14];

    BOOL v15 = +[NSNumber numberWithDouble:*(double *)(v3 + 24)];
    [v12 setY:v15];

    [v2 addObject:v12];
    v3 += 32;
  }
  while (v3 != v4);
  if (v5)
  {
    BOOL v16 = +[NSArray arrayWithArray:v2];
    [v5 setTargets:v16];

    [v22 addObject:v5];
  }
LABEL_10:
  int v17 = objc_opt_new();
  char v18 = +[NSDate dateWithTimeIntervalSince1970:(double)(a1[1] / 1000000)];
  [v17 setStartsAt:v18];

  uint64_t v19 = +[NSDate dateWithTimeIntervalSince1970:(double)(a1[2] / 1000000)];
  [v17 setEndsAt:v19];

  unsigned int v20 = +[NSArray arrayWithArray:v22];
  [v17 setReadings:v20];

  return v17;
}

void sub_100F30B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100F30B98(Registry **a1@<X0>, os_log_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  v31[0] = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, v31);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_11:
    std::mutex::unlock(v8);
    int v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v15 = v13[3];
  int v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15)
  {
LABEL_7:
    int v17 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v31[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to parse chatbot render information JSON - client factory not present", (uint8_t *)v31, 2u);
    }
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 688) = 0;
    goto LABEL_37;
  }
LABEL_12:
  int v18 = *((char *)a3 + 23);
  if (v18 >= 0) {
    uint64_t v19 = a3;
  }
  else {
    uint64_t v19 = (uint64_t *)*a3;
  }
  if (v18 >= 0) {
    uint64_t v20 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v20 = a3[1];
  }
  int v21 = +[NSData nonOwningDataWithBytes:v19 length:v20];
  uint64_t v22 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v31[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Decoding chatbot render information JSON document using BlastDoor", (uint8_t *)v31, 2u);
  }
  uint64_t v35 = 0;
  uint64_t v34 = 0;
  uint64_t v33 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v15 + 16))(&v33, v15);
  bzero(v31, 0x2B0uLL);
  *(void *)&buf[0] = 0;
  *((void *)&buf[0] + 1) = &v35;
  (*(void (**)(unint64_t *__return_ptr))(*(void *)v33 + 104))(v31);
  sub_100128064((const void **)buf);
  uint64_t v23 = v35;
  if (v35) {
    char v24 = sub_10039195C;
  }
  else {
    char v24 = 0;
  }
  if (v24)
  {
    uint64_t v25 = *a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    LODWORD(buf[0]) = 138412290;
    *(void *)((char *)buf + 4) = v23;
    uint64_t v28 = "Failed to unpack chatbot render information JSON document: %@";
    uint64_t v29 = v25;
    uint32_t v30 = 12;
LABEL_43:
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v28, (uint8_t *)buf, v30);
    goto LABEL_25;
  }
  if (v32)
  {
    sub_1011DF5A0(v31, (uint64_t)buf);
    sub_10045B770(a4, (uint64_t)buf);
    *(unsigned char *)(a4 + 568) = 0;
    *(unsigned char *)(a4 + 592) = 0;
    int v26 = v40;
    if (v40)
    {
      *(void *)(a4 + 568) = v38;
      *(_OWORD *)(a4 + 576) = v39;
      long long v39 = 0uLL;
      uint64_t v38 = 0;
      *(unsigned char *)(a4 + 592) = 1;
    }
    *(unsigned char *)(a4 + 600) = v41;
    *(_OWORD *)(a4 + 608) = v42;
    *(void *)(a4 + 624) = v43;
    long long v42 = 0uLL;
    uint64_t v43 = 0;
    *(void *)(a4 + 648) = v45;
    *(_OWORD *)(a4 + 632) = v44;
    long long v44 = 0uLL;
    uint64_t v45 = 0;
    *(unsigned char *)(a4 + 656) = 0;
    *(unsigned char *)(a4 + 680) = 0;
    if (v48)
    {
      *(_OWORD *)(a4 + 656) = v46;
      *(void *)(a4 + 672) = v47;
      long long v46 = 0uLL;
      uint64_t v47 = 0;
      *(unsigned char *)(a4 + 680) = 1;
    }
    *(unsigned char *)(a4 + 688) = 1;
    if (v26)
    {
      uint64_t v36 = (void **)&v38;
      sub_1001F9EFC(&v36);
    }
    sub_1001F9FD8((uint64_t)buf);
    goto LABEL_34;
  }
  CFTypeID v27 = *a2;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf[0]) = 0;
    uint64_t v28 = "Render information JSON document unpacking succeeded, but there was no payload";
    uint64_t v29 = v27;
    uint32_t v30 = 2;
    goto LABEL_43;
  }
LABEL_25:
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 688) = 0;
LABEL_34:
  sub_100F31544((uint64_t)v31);
  if (v34) {
    sub_10004D2C8(v34);
  }
  sub_100127D74(&v35);

LABEL_37:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_100F30FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100F31544((uint64_t)&a9);
  if (STACK[0x2B8]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x2B8]);
  }
  sub_100127D74((const void **)&STACK[0x2C0]);

  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100F31060(Registry **a1@<X0>, os_log_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = *((unsigned __int8 *)a3 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = a3[1];
  }
  if (v6)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    unint64_t v9 = ServiceMap;
    if (v10 < 0)
    {
      char v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v10;
    int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        if (!v16)
        {
LABEL_10:
          int v18 = *a2;
          if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to parse chatbot suggestions JSON - client factory not present", buf, 2u);
          }
          *(unsigned char *)a4 = 0;
          *(unsigned char *)(a4 + 24) = 0;
LABEL_49:
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
          return;
        }
LABEL_18:
        int v20 = *((char *)a3 + 23);
        if (v20 >= 0) {
          int v21 = a3;
        }
        else {
          int v21 = (uint64_t *)*a3;
        }
        if (v20 >= 0) {
          uint64_t v22 = *((unsigned __int8 *)a3 + 23);
        }
        else {
          uint64_t v22 = a3[1];
        }
        uint64_t v23 = +[NSData nonOwningDataWithBytes:v21 length:v22];
        char v24 = *a2;
        if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Decoding suggestions JSON document using BlastDoor, with options: ", buf, 2u);
        }
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        uint64_t v32 = 0;
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v16 + 16))(&v32, v16);
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        *(_OWORD *)long long buf = 0u;
        long long v39 = 0u;
        *(void *)uint64_t v36 = 0;
        *(void *)&v36[8] = &v34;
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v32 + 112))(buf);
        sub_100128064((const void **)v36);
        uint64_t v25 = v34;
        if (v34) {
          int v26 = sub_10039195C;
        }
        else {
          int v26 = 0;
        }
        if (v26)
        {
          CFTypeID v27 = *a2;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v36 = 138412290;
            *(void *)&v36[4] = v25;
            uint64_t v28 = "Failed to unpack suggestions JSON document: %@";
            uint64_t v29 = v27;
            uint32_t v30 = 12;
LABEL_41:
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v28, v36, v30);
          }
LABEL_42:
          *(unsigned char *)a4 = 0;
          *(unsigned char *)(a4 + 24) = 0;
LABEL_43:
          if (BYTE8(v59) && (_BYTE)v59) {
            sub_100B916C0((uint64_t)buf);
          }
          if (v33) {
            sub_10004D2C8(v33);
          }
          sub_100127D74(&v34);

          goto LABEL_49;
        }
        if (BYTE8(v59) && (_BYTE)v59)
        {
          if (DWORD2(v58) == 2)
          {
            sub_1011E13F8(buf, (uint64_t *)v36);
            *(_OWORD *)a4 = *(_OWORD *)v36;
            *(void *)(a4 + 16) = v37;
            uint64_t v37 = 0;
            uint64_t v35 = v36;
            memset(v36, 0, sizeof(v36));
            *(unsigned char *)(a4 + 24) = 1;
            sub_100155494((void ***)&v35);
            goto LABEL_43;
          }
          int v31 = *a2;
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            goto LABEL_42;
          }
          *(_WORD *)uint64_t v36 = 0;
          uint64_t v28 = "Suggestions JSON document unpacking succeeded, but the message was of unexpected type";
        }
        else
        {
          int v31 = *a2;
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
            goto LABEL_42;
          }
          *(_WORD *)uint64_t v36 = 0;
          uint64_t v28 = "Suggestions JSON document unpacking succeeded, but there was no payload";
        }
        uint64_t v29 = v31;
        uint32_t v30 = 2;
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_10;
    }
    goto LABEL_18;
  }
  uint64_t v19 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to parse suggestions: body was empty", buf, 2u);
  }
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 24) = 0;
}

void sub_100F314A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, const void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,int a60,char a61)
{
  if (a61 && a59) {
    sub_100B916C0((uint64_t)&a17);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_100127D74(&a11);

  if ((v63 & 1) == 0) {
    sub_10004D2C8(v61);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F31544(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 680))
  {
    if (*(unsigned char *)(a1 + 672) && *(char *)(a1 + 671) < 0) {
      operator delete(*(void **)(a1 + 648));
    }
    if (*(char *)(a1 + 647) < 0) {
      operator delete(*(void **)(a1 + 624));
    }
    if (*(char *)(a1 + 623) < 0) {
      operator delete(*(void **)(a1 + 600));
    }
    if (*(unsigned char *)(a1 + 584))
    {
      uint64_t v2 = *(void *)(a1 + 560);
      if (v2)
      {
        uint64_t v3 = *(void *)(a1 + 568);
        uint64_t v4 = *(void **)(a1 + 560);
        if (v3 != v2)
        {
          do
          {
            uint64_t v5 = *(unsigned int *)(v3 - 8);
            if (v5 != -1) {
              ((void (*)(char *, uint64_t))off_101A70690[v5])(&v22, v3 - 240);
            }
            *(_DWORD *)(v3 - 8) = -1;
            v3 -= 248;
          }
          while (v3 != v2);
          uint64_t v4 = *(void **)(a1 + 560);
        }
        *(void *)(a1 + 568) = v2;
        operator delete(v4);
      }
    }
    if (*(unsigned char *)(a1 + 552))
    {
      uint64_t v6 = *(void *)(a1 + 528);
      if (v6)
      {
        uint64_t v7 = *(void *)(a1 + 536);
        uint64_t v8 = *(void **)(a1 + 528);
        if (v7 != v6)
        {
          do
          {
            if (*(char *)(v7 - 1) < 0) {
              operator delete(*(void **)(v7 - 24));
            }
            if (*(char *)(v7 - 25) < 0) {
              operator delete(*(void **)(v7 - 48));
            }
            v7 -= 48;
          }
          while (v7 != v6);
          uint64_t v8 = *(void **)(a1 + 528);
        }
        *(void *)(a1 + 536) = v6;
        operator delete(v8);
      }
    }
    if (*(unsigned char *)(a1 + 520) && *(char *)(a1 + 519) < 0) {
      operator delete(*(void **)(a1 + 496));
    }
    if (*(unsigned char *)(a1 + 488) && *(char *)(a1 + 487) < 0) {
      operator delete(*(void **)(a1 + 464));
    }
    if (*(unsigned char *)(a1 + 456) && *(char *)(a1 + 455) < 0) {
      operator delete(*(void **)(a1 + 432));
    }
    if (*(unsigned char *)(a1 + 424) && *(char *)(a1 + 423) < 0) {
      operator delete(*(void **)(a1 + 400));
    }
    if (*(unsigned char *)(a1 + 392) && *(char *)(a1 + 391) < 0) {
      operator delete(*(void **)(a1 + 368));
    }
    if (*(unsigned char *)(a1 + 360) && *(char *)(a1 + 359) < 0) {
      operator delete(*(void **)(a1 + 336));
    }
    if (*(unsigned char *)(a1 + 328) && *(char *)(a1 + 327) < 0) {
      operator delete(*(void **)(a1 + 304));
    }
    if (*(unsigned char *)(a1 + 296) && *(char *)(a1 + 295) < 0) {
      operator delete(*(void **)(a1 + 272));
    }
    if (*(unsigned char *)(a1 + 264))
    {
      if (*(unsigned char *)(a1 + 256))
      {
        uint64_t v9 = *(void *)(a1 + 232);
        if (v9)
        {
          uint64_t v10 = *(void *)(a1 + 240);
          char v11 = *(void **)(a1 + 232);
          if (v10 != v9)
          {
            do
            {
              if (*(char *)(v10 - 1) < 0) {
                operator delete(*(void **)(v10 - 24));
              }
              if (*(char *)(v10 - 25) < 0) {
                operator delete(*(void **)(v10 - 48));
              }
              v10 -= 48;
            }
            while (v10 != v9);
            char v11 = *(void **)(a1 + 232);
          }
          *(void *)(a1 + 240) = v9;
          operator delete(v11);
        }
      }
      if (*(unsigned char *)(a1 + 224))
      {
        uint64_t v23 = (void **)(a1 + 200);
        sub_100047F64(&v23);
      }
      if (*(unsigned char *)(a1 + 192) && *(char *)(a1 + 191) < 0) {
        operator delete(*(void **)(a1 + 168));
      }
      if (*(unsigned char *)(a1 + 160))
      {
        uint64_t v12 = *(void *)(a1 + 136);
        if (v12)
        {
          uint64_t v13 = *(void *)(a1 + 144);
          int v14 = *(void **)(a1 + 136);
          if (v13 != v12)
          {
            do
            {
              if (*(char *)(v13 - 9) < 0) {
                operator delete(*(void **)(v13 - 32));
              }
              v13 -= 32;
            }
            while (v13 != v12);
            int v14 = *(void **)(a1 + 136);
          }
          *(void *)(a1 + 144) = v12;
          operator delete(v14);
        }
      }
      if (*(unsigned char *)(a1 + 128))
      {
        uint64_t v15 = *(void *)(a1 + 104);
        if (v15)
        {
          uint64_t v16 = *(void *)(a1 + 112);
          char v17 = *(void **)(a1 + 104);
          if (v16 != v15)
          {
            do
            {
              if (*(unsigned char *)(v16 - 16) && *(char *)(v16 - 17) < 0) {
                operator delete(*(void **)(v16 - 40));
              }
              if (*(char *)(v16 - 41) < 0) {
                operator delete(*(void **)(v16 - 64));
              }
              v16 -= 72;
            }
            while (v16 != v15);
            char v17 = *(void **)(a1 + 104);
          }
          *(void *)(a1 + 112) = v15;
          operator delete(v17);
        }
      }
      if (*(unsigned char *)(a1 + 96))
      {
        uint64_t v18 = *(void *)(a1 + 72);
        if (v18)
        {
          uint64_t v19 = *(void *)(a1 + 80);
          int v20 = *(void **)(a1 + 72);
          if (v19 != v18)
          {
            do
            {
              if (*(unsigned char *)(v19 - 16) && *(char *)(v19 - 17) < 0) {
                operator delete(*(void **)(v19 - 40));
              }
              v19 -= 40;
            }
            while (v19 != v18);
            int v20 = *(void **)(a1 + 72);
          }
          *(void *)(a1 + 80) = v18;
          operator delete(v20);
        }
        if (*(char *)(a1 + 71) < 0) {
          operator delete(*(void **)(a1 + 48));
        }
        if (*(char *)(a1 + 47) < 0) {
          operator delete(*(void **)(a1 + 24));
        }
        if (*(char *)(a1 + 23) < 0) {
          operator delete(*(void **)a1);
        }
      }
    }
  }
  return a1;
}

uint64_t sub_100F318FC(uint64_t a1, uint64_t a2)
{
  return sub_100B918B0(a2 + 8);
}

void sub_100F31904(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    uint64_t v5 = *(void **)(a2 + 24);
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = *(unsigned int *)(v4 - 8);
        if (v6 != -1) {
          ((void (*)(char *, uint64_t))off_101A706A0[v6])(&v7, v4 - 240);
        }
        *(_DWORD *)(v4 - 8) = -1;
        v4 -= 248;
      }
      while (v4 != v3);
      uint64_t v5 = *(void **)(a2 + 24);
    }
    *(void *)(a2 + 32) = v3;
    operator delete(v5);
  }
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

uint64_t sub_100F319B0(uint64_t a1, uint64_t a2)
{
  return sub_100B918B0(a2 + 8);
}

void sub_100F319B8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    uint64_t v5 = *(void **)(a2 + 24);
    if (v4 != v3)
    {
      do
      {
        uint64_t v6 = v4 - 232;
        sub_100B918B0(v4 - 224);
        uint64_t v4 = v6;
      }
      while (v6 != v3);
      uint64_t v5 = *(void **)(a2 + 24);
    }
    *(void *)(a2 + 32) = v3;
    operator delete(v5);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    char v7 = *(void **)a2;
    operator delete(v7);
  }
}

void sub_100F31A48(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (capabilities::ct *)capabilities::ct::supportsSubwayDetection(a1);
  if v4 && (capabilities::ct::supportsP2PAsPhone(v4)) {
    goto LABEL_13;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)a1);
  char v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v17);
  if (v12)
  {
    int v14 = (GestaltUtilityInterface *)v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      goto LABEL_11;
    }
  }
  else
  {
    int v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
LABEL_11:
  int isWatch = GestaltUtilityInterface::isWatch(v14);
  char v16 = isWatch;
  if (!v13)
  {
    if (!isWatch) {
      goto LABEL_15;
    }
LABEL_13:
    operator new();
  }
  sub_10004D2C8(v13);
  if (v16) {
    goto LABEL_13;
  }
LABEL_15:
  *a2 = 0;
  a2[1] = 0;
}

void sub_100F31BC4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F31C10(uint64_t a1, void *a2, NSObject **a3)
{
  uint64_t v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "set.sync");
  *uint64_t v6 = 0;
  v6[1] = 0;
  char v7 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_101A706C0;
  *(void *)(a1 + 48) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CompanionInMetroStatusSyncHandler");
  uint64_t v9 = *a3;
  dispatch_object_t v14 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  v13[1] = 0;
  ctu::RestModule::RestModule();
  if (v14) {
    dispatch_release(v14);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  uint64_t v10 = *(NSObject **)(a1 + 24);
  v13[0] = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  v11.fObj.fObuint64_t j = (dispatch_object_s *)v13;
  NotifySubscription::NotifySubscription((NotifySubscription *)(a1 + 120), "com.apple.commcenter.CompanionInMetroStatusChangedNotification", v11);
  if (v13[0]) {
    dispatch_release(v13[0]);
  }
  return a1;
}

void sub_100F31DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  uint64_t v23 = (std::__shared_weak_count *)*((void *)v19 + 14);
  if (v23) {
    sub_10004D2C8(v23);
  }
  char v24 = (std::__shared_weak_count *)*((void *)v19 + 12);
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v25 = (std::__shared_weak_count *)*((void *)v19 + 9);
  if (v25) {
    sub_10004D2C8(v25);
  }
  int v26 = (std::__shared_weak_count *)*((void *)v19 + 7);
  if (v26) {
    sub_10004D2C8(v26);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  CompanionInMetroStatusSyncInterface::~CompanionInMetroStatusSyncInterface(v19);
  _Unwind_Resume(a1);
}

void sub_100F31E80(uint64_t a1)
{
  Registry::getMobileHelper((uint64_t *)&handler, *(Registry **)(a1 + 48));
  long long v2 = handler;
  long long handler = 0uLL;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v2;
  if (v3)
  {
    sub_10004D2C8(v3);
    if (*((void *)&handler + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&handler + 1));
    }
  }
  Registry::createRestModuleOneTimeUseConnection(&v26, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v27) {
    sub_10004D2C8(v27);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 48));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long handler = v7;
  queue v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&handler);
  if (v11)
  {
    uint64_t v13 = (GestaltUtilityInterface *)v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_14:
  int isWatch = (capabilities::ct *)GestaltUtilityInterface::isWatch(v13);
  int v16 = (int)isWatch;
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v16)
  {
    sub_100058DB0(&__p, "/cc/props/in_metro_status");
    OsLogContext v17 = operator new(0x28uLL);
    *OsLogContext v17 = off_101A70808;
    v17[1] = a1 + 80;
    void v17[2] = a1;
    v17[3] = sub_100F32238;
    v17[4] = 0;
    uint64_t v32 = v17;
    ctu::RestModule::observeProperty();
    int isWatch = (capabilities::ct *)sub_10003F600(&handler);
    if (v29 < 0) {
      operator delete(__p);
    }
  }
  if (capabilities::ct::supportsP2PAsPhone(isWatch))
  {
    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v18 || (uint64_t v19 = *(std::__shared_weak_count_vtbl **)(a1 + 8), (v20 = std::__shared_weak_count::lock(v18)) == 0)) {
      sub_100088B9C();
    }
    int v21 = v20;
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    p_shared_weak_owners = &v20->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v20);
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    NotifySubscription::cancel((NotifySubscription *)(a1 + 120));
    uint64_t v23 = (std::__shared_weak_count *)operator new(0x38uLL);
    v23->__shared_weak_owners_ = 0;
    v23->__shared_owners_ = 0;
    v23->__vftable = (std::__shared_weak_count_vtbl *)off_101A708B8;
    v23[1].__vftable = v19;
    v23[1].__shared_owners_ = (uint64_t)v21;
    v23[1].__shared_weak_owners_ = (uint64_t)sub_100F32274;
    v23[2].__vftable = 0;
    char v24 = *(const char **)(a1 + 120);
    uint64_t v25 = *(NSObject **)(a1 + 128);
    *(void *)&long long handler = _NSConcreteStackBlock;
    *((void *)&handler + 1) = 1174405120;
    int v31 = sub_100F32EA4;
    uint64_t v32 = &unk_101A70878;
    uint64_t v33 = v23 + 1;
    uint64_t v34 = v23;
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    notify_register_dispatch(v24, (int *)(a1 + 136), v25, &handler);
    if (v34) {
      sub_10004D2C8(v34);
    }
    sub_10004D2C8(v23);
    std::__shared_weak_count::__release_weak(v21);
    sub_10004D2C8(v21);
  }
}

void sub_100F3219C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  sub_10004D2C8(v24);
  std::__shared_weak_count::__release_weak(v23);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_100F32238(unsigned __int8 *result, int a2)
{
  int v2 = result[80];
  if (v2 != a2) {
    return (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, BOOL))(*(void *)result + 40))(result, v2 != 0);
  }
  return result;
}

void sub_100F32274(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Companion InMetroStatus changed", buf, 2u);
  }
  uint64_t v3 = *(void *)(a1 + 88);
  if (v3)
  {
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v3 + 16))(&cf);
    uint64_t v4 = (BOOL *)cf;
    if (cf) {
      uint64_t v5 = sub_100080934;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      unsigned __int8 v24 = 0;
      if (cf)
      {
        CFTypeID v6 = CFGetTypeID(cf);
        if (v6 == CFBooleanGetTypeID() && (ctu::cf::assign((ctu::cf *)&v24, v4, v7) & 1) != 0)
        {
          int v8 = v24;
          sub_1000577C4(&cf);
          ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 48));
          queue v11 = ServiceMap;
          if (v12 < 0)
          {
            uint64_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v14 = 5381;
            do
            {
              uint64_t v12 = v14;
              unsigned int v15 = *v13++;
              uint64_t v14 = (33 * v14) ^ v15;
            }
            while (v15);
          }
          std::mutex::lock(ServiceMap);
          *(void *)long long buf = v12;
          int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
          if (v16)
          {
            uint64_t v18 = v16[3];
            OsLogContext v17 = (std::__shared_weak_count *)v16[4];
            if (v17)
            {
              atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v11);
              atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v17);
              char v19 = 0;
              goto LABEL_31;
            }
          }
          else
          {
            uint64_t v18 = 0;
          }
          std::mutex::unlock(v11);
          OsLogContext v17 = 0;
          char v19 = 1;
LABEL_31:
          (*(void (**)(uint64_t, BOOL))(*(void *)v18 + 72))(v18, v8 != 0);
          if ((v19 & 1) == 0) {
            sub_10004D2C8(v17);
          }
          return;
        }
      }
      int v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v29 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v26 = v29;
        int v21 = __p;
        if (v29 < 0) {
          int v21 = *(void ***)buf;
        }
        *(_DWORD *)uint32_t v30 = 136315138;
        int v31 = v21;
        char v22 = "#N Could not assign key '%s' value to a CFType for copying";
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v22, v30, 0xCu);
        if (SHIBYTE(v26) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    else
    {
      int v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uint64_t v29 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v26 = v29;
        uint64_t v23 = __p;
        if (v29 < 0) {
          uint64_t v23 = *(void ***)buf;
        }
        *(_DWORD *)uint32_t v30 = 136315138;
        int v31 = v23;
        char v22 = "#N Could not convert key '%s' value to a CFType for copying";
        goto LABEL_25;
      }
    }
    sub_1000577C4(&cf);
  }
}

void sub_100F325A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  char v22 = v20;
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F32600(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    CFTypeID v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v15 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v15);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
  if (!v11) {
    goto LABEL_13;
  }
LABEL_10:
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v11 + 16))(&v15, v11);
  long long v13 = v15;
  long long v15 = 0uLL;
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 112);
  *(_OWORD *)(a1 + 104) = v13;
  if (v14)
  {
    sub_10004D2C8(v14);
    if (*((void *)&v15 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
    }
  }
LABEL_13:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100F32734(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F32750(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

const void **sub_100F32758(uint64_t a1, int a2)
{
  uint64_t v3 = &kCFBooleanTrue;
  if (!a2) {
    uint64_t v3 = &kCFBooleanFalse;
  }
  CFBooleanRef v4 = *v3;
  *(void *)&long long v18 = 0;
  sub_100062778((const void **)&v18);
  CFBooleanRef v17 = v4;
  *(void *)&long long v18 = 0;
  sub_100062778((const void **)&v18);
  if (v4) {
    uint64_t v5 = sub_100084B4C;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    uint64_t v6 = kCommCenterSharedSettingsBundleId;
    if ((*(uint64_t (**)(void, void, const __CFString *, CFBooleanRef))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88), kCommCenterSharedSettingsBundleId, @"CompanionInMetroStatus", v4))
    {
      uint64_t v7 = *(void *)(a1 + 104);
      if (v7)
      {
        unsigned int v8 = operator new(8uLL);
        *(void *)&long long v18 = v8;
        void *v8 = @"CompanionInMetroStatus";
        *((void *)&v18 + 1) = v8 + 1;
        char v19 = v8 + 1;
        (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v7 + 16))(v7, v6, &v18);
        uint64_t v9 = (void *)v18;
        if ((void)v18)
        {
          *((void *)&v18 + 1) = v18;
LABEL_21:
          operator delete(v9);
          return sub_100062778((const void **)&v17);
        }
      }
      return sub_100062778((const void **)&v17);
    }
    unsigned int v10 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return sub_100062778((const void **)&v17);
    }
    long long v18 = 0uLL;
    char v19 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v18;
    int v16 = v19;
    long long v13 = __p;
    if (SHIBYTE(v19) < 0) {
      long long v13 = (void **)v18;
    }
    *(_DWORD *)long long buf = 136315138;
    int v21 = v13;
    char v12 = "#N Could not save key '%s' value to shared settings";
  }
  else
  {
    unsigned int v10 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return sub_100062778((const void **)&v17);
    }
    long long v18 = 0uLL;
    char v19 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = v18;
    int v16 = v19;
    uint64_t v11 = __p;
    if (SHIBYTE(v19) < 0) {
      uint64_t v11 = (void **)v18;
    }
    *(_DWORD *)long long buf = 136315138;
    int v21 = v11;
    char v12 = "#N Could not convert key '%s' value to a CFType for saving";
  }
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 0xCu);
  if (SHIBYTE(v16) < 0)
  {
    uint64_t v9 = __p[0];
    goto LABEL_21;
  }
  return sub_100062778((const void **)&v17);
}

void sub_100F329BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100062778(&a13);
  _Unwind_Resume(a1);
}

void sub_100F32A04(void *a1)
{
  *a1 = off_101A706C0;
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 15));
  char v2 = (std::__shared_weak_count *)a1[14];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFBooleanRef v4 = (std::__shared_weak_count *)a1[9];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  CompanionInMetroStatusSyncInterface::~CompanionInMetroStatusSyncInterface((CompanionInMetroStatusSyncInterface *)a1);
}

void sub_100F32A9C(void *a1)
{
  *a1 = off_101A706C0;
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 15));
  char v2 = (std::__shared_weak_count *)a1[14];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFBooleanRef v4 = (std::__shared_weak_count *)a1[9];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  CompanionInMetroStatusSyncInterface::~CompanionInMetroStatusSyncInterface((CompanionInMetroStatusSyncInterface *)a1);

  operator delete();
}

void sub_100F32B48(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100F32C14(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100F32CEC);
  __cxa_rethrow();
}

void sub_100F32C3C(_Unwind_Exception *a1)
{
}

void sub_100F32C54(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F32C8C(uint64_t a1)
{
}

uint64_t sub_100F32CA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F32CEC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F32D1C()
{
}

__n128 sub_100F32D30(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A70808;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F32D84(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A70808;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F32DBC(void *a1, xpc *this, BOOL a3)
{
  CFBooleanRef v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  *CFBooleanRef v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  unsigned int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_100F32E58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F32E98()
{
}

void sub_100F32EA4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  char v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFBooleanRef v4 = v3;
      if (*v1)
      {
        int v5 = (void (*)(void *))v1[2];
        uint64_t v6 = v1[3];
        uint64_t v7 = (void *)(*v1 + (v6 >> 1));
        if (v6) {
          int v5 = *(void (**)(void *))(*v7 + v5);
        }
        v5(v7);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100F32F44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F32F58(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F32F74(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100F32F84(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A708B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F32FA4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A708B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F32FF8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t DataConnectionAgentPolicyInterface::create@<X0>(uint64_t result@<X0>, uint64_t a2@<X4>, void *a3@<X8>)
{
  if (!*(unsigned char *)(*(void *)a2 + 49))
  {
    uint64_t v3 = *(void *)(result + 8);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
    sub_100887B00();
  }
  *a3 = 0;
  a3[1] = 0;
  return result;
}

void sub_100F33098(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F330B0(uint64_t result, int a2)
{
  if (!*(unsigned char *)(result + 961) || *(unsigned __int8 *)(result + 960) != a2) {
    *(_WORD *)(result + 960) = a2 | 0x100;
  }
  return result;
}

uint64_t sub_100F330D0(uint64_t result, int a2)
{
  if (!*(unsigned char *)(result + 913) || *(unsigned __int8 *)(result + 912) != a2) {
    *(_WORD *)(result + 912) = a2 | 0x100;
  }
  return result;
}

void sub_100F330F0()
{
}

void sub_100F33118(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F33490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t a12, dispatch_object_t a13, uint64_t a14, xpc_object_t object, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_100F33628(ctu::LogServer *this)
{
  *(void *)this = &off_101A70940;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFBooleanRef v4 = *((void *)this + 28);
  if (v4) {
    dispatch_release(v4);
  }

  ctu::LogServer::~LogServer(this);
}

void sub_100F336A0(ctu::LogServer *a1)
{
  sub_100F33628(a1);

  operator delete();
}

void sub_100F336D8(uint64_t a1, NSObject **a2)
{
  uint64_t v3 = *(ctu::LogServer **)(a1 + 32);
  if (qword_101B12FA0 != -1) {
    dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
  }
  CFBooleanRef v4 = qword_101B12F98;
  if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CTLogServer shut down", buf, 2u);
  }
  *(void *)long long buf = 0;
  ctu::LogServer::flush((uint64_t *)buf, v3);
  int v5 = *(NSObject **)buf;
  uint64_t v6 = *((void *)v3 + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = nullsub_4007;
  block[3] = &unk_101A70978;
  uint64_t v7 = *a2;
  dispatch_group_t group = v7;
  if (v7)
  {
    dispatch_retain(v7);
    dispatch_group_enter(group);
  }
  dispatch_group_notify(v5, v6, block);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  if (*(void *)buf) {
    dispatch_release(*(dispatch_object_t *)buf);
  }
}

void sub_100F33824(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(NSObject **)(a2 + 32);
  *(void *)(a1 + 32) = v3;
  if (v3)
  {
    dispatch_retain(v3);
    CFBooleanRef v4 = *(NSObject **)(a1 + 32);
    if (v4)
    {
      dispatch_group_enter(v4);
    }
  }
}

void sub_100F33878(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 32);
    if (v3)
    {
      dispatch_release(v3);
    }
  }
}

void sub_100F338C8(int a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  operator new();
}

const void **sub_100F33964@<X0>(xpc_object_t *a1@<X8>)
{
  uint64_t v9 = 0;
  if (!sub_10121F67C() && !sub_10121F6B4()) {
    goto LABEL_13;
  }
  CFTypeRef v8 = CFPreferencesCopyValue(@"LoggingSettings", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  xpc_object_t object = 0;
  sub_100084068(&object, &v8);
  uint64_t v2 = v9;
  uint64_t v9 = (ctu *)object;
  xpc_object_t object = v2;
  sub_100057D78((const void **)&object);
  CFBooleanRef v4 = v9;
  if (!(v9 ? sub_100080778 : 0)) {
    goto LABEL_13;
  }
  *a1 = 0;
  ctu::cf_to_xpc((uint64_t *)&object, v4, v3);
  xpc_object_t v6 = object;
  *a1 = object;
  if (v6 && xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v6);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(object);
  if (xpc_get_type(*a1) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_release(*a1);
    *a1 = 0;
LABEL_13:
    sub_100F33AC8(a1);
  }
  return sub_100057D78((const void **)&v9);
}

void sub_100F33A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10017143C(v3);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100F33AC8(xpc_object_t *a1)
{
  *a1 = 0;
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v3 = v2;
  if (v2)
  {
    *a1 = v2;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    *a1 = v3;
    if (!v3)
    {
      xpc_object_t v4 = xpc_null_create();
      xpc_object_t v3 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    goto LABEL_9;
  }
  xpc_object_t v4 = xpc_null_create();
LABEL_8:
  *a1 = v4;
LABEL_9:
  xpc_release(v3);
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v5;
  if (v5)
  {
    xpc_object_t v14 = v5;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    xpc_object_t v14 = v6;
    if (!v6)
    {
      xpc_object_t v7 = xpc_null_create();
      xpc_object_t v6 = 0;
      goto LABEL_16;
    }
  }
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v6);
    goto LABEL_17;
  }
  xpc_object_t v7 = xpc_null_create();
LABEL_16:
  xpc_object_t v14 = v7;
LABEL_17:
  xpc_release(v6);
  xpc_object_t v12 = xpc_int64_create(255);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  unsigned int v10 = &v14;
  uint64_t v11 = "atcs.client.PDS";
  sub_100035E70((uint64_t)&v10, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v8 = v14;
  if (v14) {
    xpc_retain(v14);
  }
  else {
    xpc_object_t v8 = xpc_null_create();
  }
  unsigned int v10 = a1;
  uint64_t v11 = "kDomainLogLevels";
  sub_10014E03C((uint64_t)&v10, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_release(v14);
}

uint64_t sub_100F33CBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = ctu::LogServer::getCurrentLogLevel();
  if (result)
  {
    xpc_object_t v5 = *(uint64_t (**)(void))(**(void **)a3 + 16);
    return v5();
  }
  return result;
}

uint64_t sub_100F33D28(void *a1, uint64_t a2)
{
  xpc_object_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    xpc_object_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = a1[5];
      if (v7 && *(_DWORD *)(a2 + 16) == 3)
      {
        char v19 = 0;
        char v20 = "sysdiagnose state capture";
        long long v18 = 0;
        sub_100058DB0(&__p, "sysdiagnose state capture");
        Registry::createXpcJetsamAssertion();
        if (v17 < 0) {
          operator delete(__p);
        }
        if (qword_101B12FA0 != -1) {
          dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
        }
        xpc_object_t v8 = qword_101B12F98;
        if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = "sysdiagnose state capture";
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Dumping state in response to: %s", (uint8_t *)&buf, 0xCu);
        }
        v15[0] = v5;
        v15[1] = (uint64_t)&v20;
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 0x40000000;
        char v22 = sub_100F35418;
        uint64_t v23 = (atomic_ullong *)&unk_101A70C60;
        uint64_t v24 = v7 + 8;
        uint64_t v25 = v15;
        xpc_object_t v9 = *(NSObject **)(v7 + 24);
        if (*(void *)(v7 + 32)) {
          dispatch_async_and_wait(v9, &buf);
        }
        else {
          dispatch_sync(v9, &buf);
        }
        sleep(1u);
        if (qword_101B12FA0 != -1) {
          dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
        }
        unsigned int v10 = qword_101B12F98;
        if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "State dump complete", (uint8_t *)&buf, 2u);
        }
        dispatch_object_t object = 0;
        Registry::getLogServer((uint64_t *)&buf, *(Registry **)(v5 + 248));
        ctu::LogServer::flush((uint64_t *)&object, (ctu::LogServer *)buf);
        if (*((void *)&buf + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
        }
        Registry::getLogServer(v15, *(Registry **)(v5 + 248));
        uint64_t v12 = a1[5];
        uint64_t v11 = a1[6];
        *(void *)&long long buf = v12;
        *((void *)&buf + 1) = v11;
        if (v11) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
        }
        char v22 = v18;
        uint64_t v23 = v19;
        if (v19) {
          atomic_fetch_add_explicit(v19 + 1, 1uLL, memory_order_relaxed);
        }
        operator new();
      }
      sub_10004D2C8(v6);
    }
  }
  return 0;
}

void sub_100F34088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23)
{
  sub_1007D9AD0((uint64_t)&a22);
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

uint64_t sub_100F34110(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F3412C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F3413C(ctu::LogServer *a1)
{
  xpc_object_t v8 = 0;
  ctu::LogServer::getSimpleConfig((uint64_t *)&v8, a1);
  CFPropertyListRef value = 0;
  xpc_object_t object = v8;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  xpc::bridge((uint64_t *)buf, (xpc *)&object, v1);
  sub_10004EFE4(&value, buf);
  sub_1000577C4(buf);
  xpc_release(object);
  if (value) {
    uint64_t v2 = sub_100080778;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    CFPreferencesSetValue(@"LoggingSettings", value, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    CFPreferencesSynchronize(@"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    xpc_object_t v3 = sCTOsLogDefault;
    if (os_log_type_enabled(sCTOsLogDefault, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      xpc_object_t v4 = "#N Saving current config to com.apple.commcenter";
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)buf, 2u);
    }
  }
  else
  {
    xpc_object_t v3 = sCTOsLogDefault;
    if (os_log_type_enabled(sCTOsLogDefault, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      xpc_object_t v4 = "#E Unable to save current config to com.apple.commcenter";
      goto LABEL_12;
    }
  }
  sub_100057D78(&value);
  xpc_release(v8);
}

void sub_100F342AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, const void *a11, uint64_t a12, char a13)
{
  sub_1000577C4(&a11);
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v13 - 24));
  _Unwind_Resume(a1);
}

void sub_100F342F4(ctu::LogServer *a1)
{
  CFPreferencesSetValue(@"LoggingSettings", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFPreferencesSynchronize(@"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  xpc_object_t v13 = 0;
  sub_100F33AC8(&v13);
  xpc_object_t v12 = 0;
  ctu::LogServer::getSimpleConfig((uint64_t *)&v12, a1);
  if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v11 = 0;
    *(void *)long long buf = &v13;
    unsigned int v10 = "kDomainLogLevels";
    sub_10000CB28((uint64_t)buf, &v11);
    xpc_object_t object = 0;
    *(void *)long long buf = &v12;
    unsigned int v10 = "kDomainLogLevels";
    sub_10000CB28((uint64_t)buf, &object);
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t v2 = object;
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 1174405120;
      applier[2] = sub_100F345A8;
      applier[3] = &unk_101A709F8;
      xpc_object_t v7 = v11;
      if (v11) {
        xpc_retain(v11);
      }
      else {
        xpc_object_t v7 = xpc_null_create();
      }
      xpc_dictionary_apply(v2, applier);
      xpc_release(v7);
      xpc_object_t v7 = 0;
    }
    xpc_release(object);
    xpc_release(v11);
  }
  xpc_object_t v3 = sCTOsLogDefault;
  if (os_log_type_enabled(sCTOsLogDefault, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Restoring default config", buf, 2u);
  }
  xpc_object_t v5 = v13;
  if (v13) {
    xpc_retain(v13);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  v4.fObj.fObuint64_t j = (dispatch_object_s *)&v5;
  ctu::LogServer::updateConfig(a1, v4);
  xpc_release(v5);
  xpc_object_t v5 = 0;
  xpc_release(v12);
  xpc_release(v13);
}

void sub_100F34504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, xpc_object_t a16)
{
  xpc_release(object);
  xpc_release(a16);
  xpc_release(*(xpc_object_t *)(v16 - 56));
  xpc_release(*(xpc_object_t *)(v16 - 48));
  xpc_release(*(xpc_object_t *)(v16 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_100F345A8(uint64_t a1, uint64_t a2)
{
  xpc_object_t v9 = 0;
  uint64_t v3 = a1 + 32;
  uint64_t v7 = a1 + 32;
  uint64_t v8 = a2;
  sub_100048BAC((uint64_t)&v7, &v9);
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_null)
  {
    xpc_object_t v5 = xpc_int64_create(0);
    if (!v5) {
      xpc_object_t v5 = xpc_null_create();
    }
    uint64_t v7 = v3;
    uint64_t v8 = a2;
    sub_100035E70((uint64_t)&v7, &v5, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v5);
    xpc_object_t v5 = 0;
  }
  xpc_release(v9);
  return 1;
}

void sub_100F34664(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100F3467C(ctu::LogServer *a1, char a2)
{
  *((unsigned char *)a1 + 264) = a2;
  BOOL v2 = (a2 & 1) != 0 || *((unsigned char *)a1 + 265) != 0;
  return ctu::LogServer::setEnabled(a1, v2);
}

uint64_t sub_100F3469C(ctu::LogServer *a1, BOOL a2)
{
  *((unsigned char *)a1 + 265) = a2;
  if (*((unsigned char *)a1 + 264)) {
    a2 = 1;
  }
  return ctu::LogServer::setEnabled(a1, a2);
}

void sub_100F346B0(id a1)
{
  qword_101B12F98 = (uint64_t)os_log_create(kCtLoggingSystemName, "log");
}

void sub_100F346E8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F34720(uint64_t a1)
{
}

uint64_t sub_100F3473C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F34780(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void sub_100F347AC(ServiceManager::Service *this)
{
  *(void *)this = off_101A70B40;
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F34808(ServiceManager::Service *this)
{
  *(void *)this = off_101A70B40;
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void **sub_100F34878@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (void **)ctu::LogServer::getName(*(ctu::LogServer **)(a1 + 8));
  if (*((char *)result + 23) < 0)
  {
    xpc_object_t v5 = *result;
    unint64_t v6 = (unint64_t)result[1];
    return (void **)sub_10004FC84((unsigned char *)a2, v5, v6);
  }
  else
  {
    long long v4 = *(_OWORD *)result;
    *(void *)(a2 + 16) = result[2];
    *(_OWORD *)a2 = v4;
  }
  return result;
}

unsigned char *sub_100F348DC@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  BOOL v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 6;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F3491C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F338C8(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F338C8(v4, 0);
}

uint64_t sub_100F349A0()
{
  return 0;
}

uint64_t sub_100F349A8()
{
  return 1;
}

uint64_t sub_100F349B0()
{
  return 0;
}

uint64_t sub_100F349BC(uint64_t a1)
{
  return ctu::LogServer::setEnabled(*(ctu::LogServer **)(a1 + 8), 0);
}

void sub_100F349C8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F34B5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100F34B7C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 232));
  if (*(void *)(v2 + 272))
  {
    os_state_remove_handler();
    *(void *)(v2 + 272) = 0;
  }
  sub_100088C88(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100F34BD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100F34BF0(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(Registry **)(*(void *)a1 + 248);
  if (v2)
  {
    Registry::createRestModuleOneTimeUseConnection(&v8, v2);
    ctu::RestModule::connect();
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  uint64_t v4 = v1[1];
  uint64_t v3 = (std::__shared_weak_count *)v1[2];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      p_shared_weak_owners = &v5->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v5);
      dispatch_get_global_queue(0, 0);
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 1174405120;
      void v10[2] = sub_100F33D28;
      v10[3] = &unk_101A709C8;
      v10[4] = v1;
      void v10[5] = v4;
      xpc_object_t v11 = v6;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      v1[34] = os_state_add_handler();
      if (v11) {
        std::__shared_weak_count::__release_weak(v11);
      }
      std::__shared_weak_count::__release_weak(v6);
      sub_100F34DA4((uint64_t)v10, (uint64_t)(v1 + 1), (uint64_t)&event::logging::csi_logging_enabled, (uint64_t)sub_100F3467C, 0);
    }
  }
  sub_100088B9C();
}

void sub_100F34D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_100088C88(&a9);
  _Unwind_Resume(a1);
}

void sub_100F34DA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v9[6] = a5;
  aBlock = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_100F3509C;
  void v9[3] = &unk_101A70BB0;
  void v9[4] = a2;
  v9[5] = a4;
  aBlock = _Block_copy(v9);
  unint64_t v6 = *(std::__shared_weak_count **)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      sub_10097FEF0(v11, &aBlock, *(dispatch_object_t *)(a2 + 16));
      sub_10097FF38(&v12, v11);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F34FE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20)
{
  if (a2)
  {
    sub_100163BC8(v21 - 80);
    uint64_t v23 = *(void *)(v21 - 88);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    std::__shared_weak_count::__release_weak(v20);
    sub_10097F2DC((uint64_t)&a19);
    sub_100980DC8((uint64_t)&a17);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F3509C(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

void *sub_100F350E8(void *a1)
{
  *a1 = off_101A70BE0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100F35134(void *a1)
{
  *a1 = off_101A70BE0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100F351A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100F35250(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F35268(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100F35288()
{
}

void *sub_100F352F4(void *a1)
{
  *a1 = off_101A70C30;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100F35340(void *a1)
{
  *a1 = off_101A70C30;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100F353AC()
{
}

void sub_100F35418()
{
  if (qword_101B12FA0 != -1) {
    dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
  }
  char v0 = qword_101B12F98;
  if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = kCTProjectVersion;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Version: CoreTelephony-%s", buf, 0xCu);
    if (qword_101B12FA0 != -1) {
      dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
    }
  }
  uint64_t v1 = qword_101B12F98;
  if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = kCTProjectBuildRevision;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Build revision: %s", buf, 0xCu);
    if (qword_101B12FA0 != -1) {
      dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
    }
  }
  uint64_t v2 = qword_101B12F98;
  if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = kCTProjectBuildReason;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Build reason: %s", buf, 0xCu);
    if (qword_101B12FA0 != -1) {
      dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
    }
  }
  uint64_t v3 = qword_101B12F98;
  if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BAC634((uint64_t)buf);
    if (v10 >= 0) {
      uint64_t v4 = buf;
    }
    else {
      uint64_t v4 = *(unsigned char **)buf;
    }
    *(_DWORD *)std::string __p = 136446210;
    *(void *)&__p[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "OS-Version: %{public}s", __p, 0xCu);
    if (v10 < 0) {
      operator delete(*(void **)buf);
    }
    if (qword_101B12FA0 != -1) {
      dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
    }
  }
  uint64_t v5 = qword_101B12F98;
  if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BAC598((uint64_t)buf);
    unint64_t v6 = v10 >= 0 ? buf : *(unsigned char **)buf;
    *(_DWORD *)std::string __p = 136446210;
    *(void *)&__p[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Hardware-Model: %{public}s", __p, 0xCu);
    if (v10 < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_100058DB0(__p, "sysdiagnose state capture");
  RequestDumpStatePayload::RequestDumpStatePayload();
  sub_10097E680();
  if (v10 < 0) {
    operator delete(*(void **)buf);
  }
  if (v8 < 0) {
    operator delete(*(void **)__p);
  }
}

void sub_100F35774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100F357B0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100F35810(void *a1)
{
  char v8 = a1;
  uint64_t v2 = (std::__shared_weak_count *)a1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*a1)
      {
        if (qword_101B12FA0 != -1) {
          dispatch_once(&qword_101B12FA0, &stru_101A70AB0);
        }
        uint64_t v5 = qword_101B12F98;
        if (os_log_type_enabled((os_log_t)qword_101B12F98, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Releasing jetsam assertion", buf, 2u);
        }
        unint64_t v6 = (std::__shared_weak_count *)a1[3];
        a1[2] = 0;
        a1[3] = 0;
        if (v6) {
          sub_10004D2C8(v6);
        }
      }
      sub_10004D2C8(v4);
    }
  }
  return sub_100F357B0((uint64_t *)&v8);
}

uint64_t sub_100F358EC()
{
  if ((byte_101B0B120 & 1) == 0)
  {
    byte_101B0B120 = 1;
    return __cxa_atexit((void (*)(void *))sub_100B15780, &unk_101B0B0D0, (void *)&_mh_execute_header);
  }
  return result;
}

void sub_100F35928()
{
  qword_101B12F90 = ctu::MemoryBufferedLogWriter::UNLIMITED;
}

void sub_100F35AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100433030((uint64_t *)va);
  if (a7) {
    sub_10004D2C8(a7);
  }

  _Unwind_Resume(a1);
}

void sub_100F35B30(void *a1@<X0>, void *a2@<X1>, Registry **a3@<X2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *a3);
  char v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v29 = v9;
  xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, &v29);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_9:
    std::mutex::unlock(v8);
    xpc_object_t v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_7;
    }
    goto LABEL_10;
  }
  uint64_t v15 = v13[3];
  xpc_object_t v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15)
  {
LABEL_7:
    id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:1 userInfo:0];
LABEL_19:
    *a2 = v17;
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_20;
  }
LABEL_10:
  if (((*(uint64_t (**)(uint64_t))(*(void *)v15 + 32))(v15) & 1) == 0)
  {
    id v17 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:13 userInfo:0];
    goto LABEL_19;
  }
  char v19 = (std::mutex *)Registry::getServiceMap(v18, *a3);
  char v20 = v19;
  if ((v21 & 0x8000000000000000) != 0)
  {
    char v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v23 = 5381;
    do
    {
      unint64_t v21 = v23;
      unsigned int v24 = *v22++;
      uint64_t v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  unint64_t v29 = v21;
  uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, &v29);
  if (!v25)
  {
    std::mutex::unlock(v20);
LABEL_24:
    uint64_t v26 = 0;
    char v28 = 1;
    goto LABEL_28;
  }
  uint64_t v27 = v25[3];
  uint64_t v26 = (std::__shared_weak_count *)v25[4];
  if (!v26)
  {
    std::mutex::unlock(v20);
    if (v27)
    {
      *a1 = v27;
      a1[1] = 0;
      goto LABEL_20;
    }
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v20);
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v26);
  if (!v27)
  {
    char v28 = 0;
LABEL_28:
    *a2 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    *a1 = 0;
    a1[1] = 0;
    if (v28) {
      goto LABEL_20;
    }
    goto LABEL_29;
  }
  *a1 = v27;
  a1[1] = v26;
  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_29:
  sub_10004D2C8(v26);
LABEL_20:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_100F35DAC(_Unwind_Exception *exception_object)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F35FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  sub_100433188((void *)(v30 - 88));
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a26) {
    sub_10004D2C8(a26);
  }

  _Unwind_Resume(a1);
}

void sub_100F3631C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }

  _Unwind_Resume(a1);
}

void sub_100F363B4(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (v3 != 1)
  {
    if (v3 != 2)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    if (a2[8] == 19)
    {
      char v4 = *(void **)(a1 + 32);
      if (v4)
      {
        [v4 getLogContext];
        uint64_t v5 = v26;
      }
      else
      {
        uint64_t v5 = 0;
        *(void *)long long buf = 0;
        char v26 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "EOS Driver not ready", buf, 2u);
      }
      uint64_t v19 = *(void *)(a1 + 40);
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
      (*(void (**)(uint64_t, void, id))(v19 + 16))(v19, 0, v20);
    }
    else
    {
      uint64_t v15 = *(void **)(a1 + 32);
      if (v15)
      {
        [v15 getLogContext];
        char v16 = v26;
      }
      else
      {
        char v16 = 0;
        *(void *)long long buf = 0;
        char v26 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Get Vinyl EOS FW Update Info error", buf, 2u);
      }
      uint64_t v21 = *(void *)(a1 + 40);
      id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
      (*(void (**)(uint64_t, void, id))(v21 + 16))(v21, 0, v20);
    }
LABEL_29:

    return;
  }
  unint64_t v6 = (void *)*((void *)a2 + 1);
  if (v6) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7)
  {
    id v17 = *(void **)(a1 + 32);
    if (v17)
    {
      [v17 getLogContext];
      long long v18 = v26;
    }
    else
    {
      long long v18 = 0;
      *(void *)long long buf = 0;
      char v26 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "No result", buf, 2u);
    }
    uint64_t v22 = *(void *)(a1 + 40);
    id v20 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*(void (**)(uint64_t, void, id))(v22 + 16))(v22, 0, v20);
    goto LABEL_29;
  }
  id v24 = v6;
  id v8 = objc_alloc((Class)CTEOSFirmwareInfo);
  unint64_t v9 = +[NSString stringWithUTF8String:kVinylFwUpdateCurrentVersion];
  char v10 = [v24 objectForKey:v9];
  [v8 setCurrentVersion:v10];

  uint64_t v11 = +[NSString stringWithUTF8String:kVinylFwUpdateUserProfiles];
  unsigned int v12 = [v24 objectForKey:v11];
  [v8 setUserProfiles:v12];

  xpc_object_t v13 = +[NSString stringWithUTF8String:kVinylFwUpdateCsn];
  xpc_object_t v14 = [v24 objectForKey:v13];
  [v8 setUpdateCsn:v14];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100F36790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100F367FC(uint64_t a1)
{
  return a1;
}

void sub_100F36828(uint64_t a1)
{
  operator delete();
}

void *sub_100F36874(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A70C90;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100F368CC(uint64_t a1, void *a2)
{
  *a2 = off_101A70C90;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100F36914(uint64_t a1)
{
}

void sub_100F3691C(id *a1)
{
  operator delete(a1);
}

void sub_100F36958(uint64_t a1, const void **a2)
{
  char v10 = 0;
  CFTypeRef cf = 0;
  int v3 = *(unsigned __int8 *)a2;
  if (v3 == 2)
  {
    LOBYTE(v10) = 2;
    LOBYTE(cf) = *((unsigned char *)a2 + 8);
  }
  else if (v3 == 1)
  {
    sub_1000C7FE8(&v10, a2 + 1);
    if (v10 == 1)
    {
      CFTypeRef v12 = cf;
      if (cf) {
        CFRetain(cf);
      }
      (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
      sub_100057D78(&v12);
      goto LABEL_10;
    }
  }
  uint64_t v4 = *(void *)(a1 + 8);
  id v5 = objc_alloc((Class)NSError);
  if (v10 != 2)
  {
    if (v10 == 1)
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      id v8 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(exception);
    }
    else
    {
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      id v8 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    __cxa_throw(exception, v9, (void (*)(void *))v8);
  }
  id v6 = [v5 initWithDomain:NSPOSIXErrorDomain code:cf userInfo:0];
  (*(void (**)(uint64_t, void, id))(v4 + 16))(v4, 0, v6);

LABEL_10:
  if (v10 == 1) {
    sub_100057D78(&cf);
  }
}

void sub_100F36ACC(_Unwind_Exception *a1, uint64_t a2, char a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_100057D78((const void **)va1);
  if (a3 == 1) {
    sub_100057D78((const void **)va);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F36B28(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A70D00)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F36B68()
{
  return &off_101A70D00;
}

uint64_t sub_100F36B74(uint64_t a1)
{
  return a1;
}

void sub_100F36BA0(uint64_t a1)
{
  operator delete();
}

void *sub_100F36BEC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A70D20;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100F36C44(uint64_t a1, void *a2)
{
  *a2 = off_101A70D20;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100F36C8C(uint64_t a1)
{
}

void sub_100F36C94(id *a1)
{
  operator delete(a1);
}

void sub_100F36CD0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (v2 == 5)
  {
    uint64_t v4 = *(void (**)(uint64_t, uint64_t, void))(v3 + 16);
    uint64_t v5 = *(void *)(a1 + 8);
    v4(v5, 1, 0);
  }
  else
  {
    id v6 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:v2 userInfo:0];
    (*(void (**)(uint64_t, void))(v3 + 16))(v3, 0);
  }
}

void sub_100F36D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100F36DA4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A70D90)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F36DE4()
{
  return &off_101A70D90;
}

void sub_100F36DF0()
{
}

uint64_t sub_100F36E18()
{
  return 0;
}

uint64_t sub_100F36E20()
{
  return 0;
}

uint64_t sub_100F36E28(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  uint64_t v4 = *a3;
  if (os_log_type_enabled(*a3, OS_LOG_TYPE_ERROR))
  {
    id v6 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    int v7 = 136315138;
    id v8 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "[%s] Do not invoke this function. Decompression is NOT required for this message. message.", (uint8_t *)&v7, 0xCu);
  }
  return __TUAssertTrigger();
}

uint64_t sub_100F36EDC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_100F36EE4(uint64_t a1, uint64_t a2, os_log_t *a3)
{
  return sub_100F36E28(a1 - 16, a2, a3);
}

BOOL sub_100F36EEC(uint64_t a1, os_log_t *a2, uint64_t a3)
{
  id v6 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [%s] Decoding", buf, 0xCu);
  }
  *(void *)(a1 + 32) = 0;
  *(_WORD *)long long buf = 0;
  if ((sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL) & 1) != 0
    && (unsigned __int16 v31 = 0, sub_10036C2D8((uint64_t *)a3, &v31, 0x10uLL))
    && (uint64_t v8 = *(unsigned __int16 *)buf, v9 = v31,
                                       *(_WORD *)long long buf = 0,
                                       (sub_10036C2D8((uint64_t *)a3, buf, 0x10uLL) & 1) != 0)
    && (unsigned __int16 v31 = 0, (sub_10036C2D8((uint64_t *)a3, &v31, 0x10uLL) & 1) != 0))
  {
    int v10 = 0;
    *(void *)(a1 + 32) |= (v8 << 48) | (v9 << 32) | v31 | ((unint64_t)*(unsigned __int16 *)buf << 16);
    uint64_t v11 = *(void *)a3;
    unint64_t v12 = *(void *)(a3 + 8) - *(void *)a3;
    unint64_t v13 = *(void *)(a3 + 32);
    unint64_t v14 = *(void *)(a3 + 40);
    unint64_t v15 = 8;
    while (1)
    {
      if (!v14)
      {
        *(void *)(a3 + 32) = ++v13;
        *(void *)(a3 + 40) = 8;
        unint64_t v14 = 8;
      }
      if (v13 >= v12) {
        break;
      }
      unint64_t v16 = v15 - v14;
      if (v15 <= v14)
      {
        *(void *)(a3 + 40) = v14 - v15;
        int v18 = *(unsigned __int8 *)(v11 + v13) >> (v14 - v15);
        if (v15 < 8) {
          char v19 = ~(-1 << v15);
        }
        else {
          char v19 = -1;
        }
        unsigned __int8 v20 = v10 | v18 & v19;
        if ((v20 & 0xFE) != 0) {
          char v21 = 2;
        }
        else {
          char v21 = v20;
        }
        *(unsigned char *)(a1 + 40) = v21;
        if (v20 < 2u) {
          return 1;
        }
        uint64_t v22 = *a2;
        BOOL result = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        id v24 = sub_10093AA58(*(_DWORD *)(a1 + 12));
        *(_DWORD *)long long buf = 136315394;
        uint64_t v33 = v24;
        __int16 v34 = 1024;
        int v35 = v20;
        uint64_t v25 = "[%s] Invalid errorCode: %hhu";
        char v26 = v22;
        uint32_t v27 = 18;
        goto LABEL_23;
      }
      unsigned int v17 = *(unsigned __int8 *)(v11 + v13) & ~(-1 << v14);
      *(void *)(a3 + 40) = 0;
      v10 |= v17 << v16;
      unint64_t v15 = v16;
      unint64_t v14 = 0;
      if (v16 - 9 < 0xFFFFFFFFFFFFFFF8) {
        __assert_rtn("read", "CTBitwise.h", 193, "N > 0 && N <= 8");
      }
    }
    *(unsigned char *)(a3 + 24) = 1;
    char v28 = *a2;
    BOOL result = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    unint64_t v29 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = v29;
    uint64_t v25 = "[%s] Failed to read errorCode";
  }
  else
  {
    char v28 = *a2;
    BOOL result = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v30 = sub_10093AA58(*(_DWORD *)(a1 + 12));
    *(_DWORD *)long long buf = 136315138;
    uint64_t v33 = v30;
    uint64_t v25 = "[%s] Failed to read timestamp";
  }
  char v26 = v28;
  uint32_t v27 = 12;
LABEL_23:
  _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v25, buf, v27);
  return 0;
}

BOOL sub_100F3720C(uint64_t a1, os_log_t *a2, uint64_t a3)
{
  return sub_100F36EEC(a1 - 16, a2, a3);
}

uint64_t sub_100F37214(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

void sub_100F37220()
{
}

void sub_100F37238()
{
}

void sub_100F37250()
{
}

void sub_100F37268(PB::Base *this)
{
  *(void *)this = &off_101A71018;
  uint64_t v2 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }

  PB::Base::~Base(this);
}

void sub_100F3740C(PB::Base *a1)
{
  sub_100F37268(a1);

  operator delete();
}

uint64_t sub_100F37444(void *a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = a1[1];
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, this, "genericTransferPayload");
  }
  uint64_t v6 = a1[2];
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, this, "profileStatusInfo");
  }
  uint64_t v7 = a1[3];
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, this, "purchasePlanInfo");
  }
  uint64_t v8 = a1[4];
  if (v8) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "transferConsent");
  }
  uint64_t v9 = a1[5];
  if (v9) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "transferProfile");
  }
  uint64_t v10 = a1[6];
  if (v10) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, this, "updateSubscriptionInfo");
  }
  uint64_t v11 = a1[7];
  if (v11) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, this, "vinylInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100F37610(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_22:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      switch((v10 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          operator new();
        case 3u:
          operator new();
        case 4u:
          operator new();
        case 5u:
          operator new();
        case 6u:
          operator new();
        case 7u:
          operator new();
        default:
          break;
      }
LABEL_20:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_22;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100F37B74(uint64_t result, PB::Writer *this)
{
  unint64_t v3 = (void *)result;
  int v4 = *(const PB::Base **)(result + 56);
  if (v4) {
    uint64_t result = PB::Writer::writeSubmessage(this, v4, 1u);
  }
  uint64_t v5 = (const PB::Base *)v3[5];
  if (v5) {
    uint64_t result = PB::Writer::writeSubmessage(this, v5, 2u);
  }
  uint64_t v6 = (const PB::Base *)v3[6];
  if (v6) {
    uint64_t result = PB::Writer::writeSubmessage(this, v6, 3u);
  }
  uint64_t v7 = (const PB::Base *)v3[2];
  if (v7) {
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 4u);
  }
  char v8 = (const PB::Base *)v3[3];
  if (v8) {
    uint64_t result = PB::Writer::writeSubmessage(this, v8, 5u);
  }
  unsigned int v9 = (const PB::Base *)v3[4];
  if (v9) {
    uint64_t result = PB::Writer::writeSubmessage(this, v9, 6u);
  }
  unint64_t v10 = (const PB::Base *)v3[1];
  if (v10)
  {
    return PB::Writer::writeSubmessage(this, v10, 7u);
  }
  return result;
}

uint64_t sub_100F37C3C(uint64_t result)
{
  if (!*(void *)(result + 56)) {
    operator new();
  }
  return result;
}

uint64_t sub_100F37CEC(uint64_t result)
{
  if (!*(void *)(result + 40)) {
    operator new();
  }
  return result;
}

uint64_t sub_100F37DAC(uint64_t result)
{
  if (!*(void *)(result + 48)) {
    operator new();
  }
  return result;
}

uint64_t sub_100F37E60(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_100F37F18(uint64_t result)
{
  if (!*(void *)(result + 24)) {
    operator new();
  }
  return result;
}

uint64_t sub_100F37FC8(uint64_t result)
{
  if (!*(void *)(result + 32)) {
    operator new();
  }
  return result;
}

void sub_100F38080(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F386F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, ctu::OsLogLogger *a11, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (*(char *)(v29 - 153) < 0) {
    operator delete(*(void **)(v29 - 176));
  }
  ctu::OsLogLogger::~OsLogLogger(a11);
  sub_100087E88(v28);
  IsoMccCacheInterface::~IsoMccCacheInterface(v27);
  operator delete();
}

void sub_100F388A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100F38854);
}

void sub_100F388C4()
{
}

void sub_100F388D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a45 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100F38864);
}

void sub_100F388F4()
{
}

void sub_100F38900()
{
}

void sub_100F38908()
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 - 216));
  sub_100087E88(v0);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v1 - 152));
  JUMPOUT(0x100F3887CLL);
}

void sub_100F38930()
{
}

void sub_100F38938(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  char v26 = 0;
  size_t v27 = 0;
  uint64_t v28 = 0;
  sub_100F3A8E8(&v26, v5);
  char v6 = HIBYTE(v28);
  if (v28 >= 0) {
    size_t v7 = HIBYTE(v28);
  }
  else {
    size_t v7 = v27;
  }
  if (!v7)
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
    if ((v6 & 0x80) == 0) {
      return;
    }
    goto LABEL_48;
  }
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v25 = 0;
  char v8 = v24;
  sub_1000C140C((uint64_t)v24, v7 + 14);
  if (v25 < 0) {
    char v8 = (void **)v24[0];
  }
  if (v28 >= 0) {
    unsigned int v9 = &v26;
  }
  else {
    unsigned int v9 = v26;
  }
  memmove(v8, v9, v7);
  strcpy((char *)v8 + v7, "/MCC2ISO.plist");
  CFDictionaryRef theDict = 0;
  unint64_t v10 = (os_log_t *)(v5 + 40);
  sub_1007B946C((os_log_t *)(v5 + 40), (Registry **)(v5 + 464), (const UInt8 *)v24, (const void **)&theDict);
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (theDict) {
    unint64_t v11 = sub_100080778;
  }
  else {
    unint64_t v11 = 0;
  }
  if (v11)
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v20, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)unsigned __int8 v20 = *(_OWORD *)a2;
      uint64_t v21 = *(void *)(a2 + 16);
    }
    if (SHIBYTE(v21) < 0)
    {
      sub_10004FC84(__p, v20[0], (unint64_t)v20[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v20;
      uint64_t v31 = v21;
    }
    uint64_t v29 = 0;
    if (SHIBYTE(v31) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)__p;
      uint64_t v35 = v31;
    }
    uint64_t v32 = 0;
    if (ctu::cf::convert_copy())
    {
      char v14 = v29;
      uint64_t v29 = v32;
      uint64_t v33 = v14;
      sub_1000558F4(&v33);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(*(void **)buf);
    }
    unsigned int v15 = v29;
    uint64_t v22 = v29;
    uint64_t v29 = 0;
    sub_1000558F4(&v29);
    if (SHIBYTE(v31) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(v20[0]);
    }
    __p[0] = 0;
    *(void *)long long buf = CFDictionaryGetValue(theDict, v15);
    sub_100056248(__p, (CFTypeRef *)buf);
    if (__p[0]) {
      unint64_t v16 = sub_1000810B8;
    }
    else {
      unint64_t v16 = 0;
    }
    if (v16)
    {
      memset(buf, 0, sizeof(buf));
      uint64_t v35 = 0;
      ctu::cf::assign();
      unsigned __int8 v18 = *(void **)buf;
      uint64_t v17 = *(void *)&buf[8];
      LODWORD(v33) = v35;
      *(_DWORD *)((char *)&v33 + 3) = *(_DWORD *)((char *)&v35 + 3);
      char v19 = HIBYTE(v35);
      if (SHIBYTE(v35) < 0)
      {
        sub_10004FC84((unsigned char *)a3, *(void **)buf, *(unint64_t *)&buf[8]);
        *(unsigned char *)(a3 + 24) = 1;
        operator delete(v18);
      }
      else
      {
        *(void *)a3 = *(void *)buf;
        *(void *)(a3 + 8) = v17;
        *(_DWORD *)(a3 + 16) = v33;
        *(_DWORD *)(a3 + 19) = *(_DWORD *)((char *)&v33 + 3);
        *(unsigned char *)(a3 + 23) = v19;
        *(unsigned char *)(a3 + 24) = 1;
      }
    }
    sub_1000558F4((const void **)__p);
    sub_1000558F4(&v22);
  }
  else
  {
    char v12 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v13 = v24;
      if (v25 < 0) {
        BOOL v13 = (void **)v24[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Could not load %s as dictionary", buf, 0xCu);
    }
  }
  sub_100057D78((const void **)&theDict);
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  if (v28 < 0) {
LABEL_48:
  }
    operator delete(v26);
}

void sub_100F38CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, const void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  operator delete(v36);
  sub_1000558F4((const void **)&a30);
  sub_1000558F4(&a15);
  if (*(unsigned char *)(v35 + 24) && *(char *)(v35 + 23) < 0) {
    operator delete(*(void **)v35);
  }
  sub_100057D78(&a16);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

const void **sub_100F38DC4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFArrayRef theArray = 0;
  sub_100F3A9F4(&theArray, v5, a2);
  *a3 = 0u;
  a3[1] = 0u;
  CFArrayRef v6 = theArray;
  if (theArray) {
    size_t v7 = sub_100083F10;
  }
  else {
    size_t v7 = 0;
  }
  if (v7)
  {
    CFIndex v8 = 0;
    uint64_t v17 = 0;
    unsigned __int8 v18 = 0;
    unint64_t v19 = 0;
    while (CFArrayGetCount(v6) > v8)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v8);
      if (ValueAtIndex)
      {
        CFTypeID v10 = CFGetTypeID(ValueAtIndex);
        if (v10 == CFStringGetTypeID())
        {
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v16 = 0;
          long long v21 = 0uLL;
          uint64_t v22 = 0;
          ctu::cf::assign();
          *(_OWORD *)std::string __p = v21;
          uint64_t v16 = v22;
          unint64_t v11 = v18;
          if ((unint64_t)v18 >= v19)
          {
            BOOL v13 = (unsigned char *)sub_100048008((uint64_t *)&v17, (long long *)__p);
          }
          else
          {
            if (SHIBYTE(v16) < 0)
            {
              sub_10004FC84(v18, __p[0], (unint64_t)__p[1]);
            }
            else
            {
              long long v12 = *(_OWORD *)__p;
              *((void *)v18 + 2) = v16;
              *unint64_t v11 = v12;
            }
            BOOL v13 = (char *)v11 + 24;
          }
          unsigned __int8 v18 = v13;
          if (SHIBYTE(v16) < 0) {
            operator delete(__p[0]);
          }
        }
      }
      ++v8;
      CFArrayRef v6 = theArray;
    }
    sub_100F3ADB4((uint64_t)a3, &v17);
    *(void *)&long long v21 = &v17;
    sub_100047F64((void ***)&v21);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100F38F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void ***a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, const void *a15)
{
  a9 = &a12;
  sub_100047F64((void ***)&a9);
  if (*(unsigned char *)(v15 + 24))
  {
    a12 = (void **)v15;
    sub_100047F64(&a12);
  }
  sub_100044D00(&a15);
  _Unwind_Resume(a1);
}

const void **sub_100F38FA8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFArrayRef theArray = 0;
  sub_100F3A9F4(&theArray, v5, a2);
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  CFArrayRef v6 = theArray;
  if (theArray) {
    size_t v7 = sub_100083F10;
  }
  else {
    size_t v7 = 0;
  }
  if (v7)
  {
    CFIndex v8 = 0;
    std::string __p = 0;
    char v26 = 0;
    size_t v27 = 0;
    while (CFArrayGetCount(v6) > v8)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v8);
      CFStringRef v10 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v11 = CFGetTypeID(ValueAtIndex);
        if (v11 == CFStringGetTypeID())
        {
          __int16 IntValue = CFStringGetIntValue(v10);
          __int16 v13 = IntValue;
          char v14 = v26;
          if (v26 >= v27)
          {
            uint64_t v16 = __p;
            uint64_t v17 = v26 - __p;
            if (v26 - __p <= -3) {
              sub_10006A748();
            }
            uint64_t v18 = v17 >> 1;
            if (v27 - __p <= (unint64_t)((v17 >> 1) + 1)) {
              uint64_t v19 = v18 + 1;
            }
            else {
              uint64_t v19 = v27 - __p;
            }
            if ((unint64_t)(v27 - __p) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v20 = v19;
            }
            if (v20)
            {
              long long v21 = (char *)sub_10006E5B8((uint64_t)&v27, v20);
              uint64_t v16 = __p;
              char v14 = v26;
            }
            else
            {
              long long v21 = 0;
            }
            uint64_t v22 = &v21[2 * v18];
            *(_WORD *)uint64_t v22 = v13;
            uint64_t v15 = v22 + 2;
            while (v14 != v16)
            {
              __int16 v23 = *((_WORD *)v14 - 1);
              v14 -= 2;
              *((_WORD *)v22 - 1) = v23;
              v22 -= 2;
            }
            std::string __p = v22;
            size_t v27 = &v21[2 * v20];
            if (v16) {
              operator delete(v16);
            }
          }
          else
          {
            *(_WORD *)char v26 = IntValue;
            uint64_t v15 = v26 + 2;
          }
          char v26 = v15;
        }
      }
      ++v8;
      CFArrayRef v6 = theArray;
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    sub_1003A10E0((void *)a3, __p, (uint64_t)v26, (v26 - __p) >> 1);
    *(unsigned char *)(a3 + 24) = 1;
    if (__p) {
      operator delete(__p);
    }
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100F39170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, const void *a12)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v12 + 24))
  {
    char v14 = *(void **)v12;
    if (*(void *)v12)
    {
      *(void *)(v12 + 8) = v14;
      operator delete(v14);
    }
  }
  sub_100044D00(&a12);
  _Unwind_Resume(a1);
}

const void **sub_100F391BC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFArrayRef theArray = 0;
  v41[0] = 0;
  v41[1] = 0;
  uint64_t v42 = 0;
  sub_100F3A8E8(v41, v5);
  if (v42 >= 0) {
    size_t v6 = HIBYTE(v42);
  }
  else {
    size_t v6 = (size_t)v41[1];
  }
  if (!v6)
  {
    CFArrayRef theArray = 0;
    if ((v42 & 0x8000000000000000) == 0) {
      goto LABEL_70;
    }
    goto LABEL_69;
  }
  v39[0] = 0;
  v39[1] = 0;
  uint64_t v40 = 0;
  size_t v7 = v39;
  sub_1000C140C((uint64_t)v39, v6 + 14);
  if (v40 < 0) {
    size_t v7 = (void **)v39[0];
  }
  if (v42 >= 0) {
    CFIndex v8 = v41;
  }
  else {
    CFIndex v8 = (void **)v41[0];
  }
  memmove(v7, v8, v6);
  strcpy((char *)v7 + v6, "/MNC2ISO.plist");
  CFDictionaryRef theDict = 0;
  unsigned int v9 = (os_log_t *)(v5 + 40);
  sub_1007B946C((os_log_t *)(v5 + 40), (Registry **)(v5 + 464), (const UInt8 *)v39, (const void **)&theDict);
  CFArrayRef v37 = 0;
  if (theDict) {
    CFStringRef v10 = sub_100080778;
  }
  else {
    CFStringRef v10 = 0;
  }
  if (!v10)
  {
    CFTypeID v11 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v39;
      if (v40 < 0) {
        uint64_t v12 = (void **)v39[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Could not load %s as dictionary", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_65;
  }
  key = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    unint64_t v35 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v35) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    unint64_t v45 = v35;
  }
  long long v46 = 0;
  if (SHIBYTE(v45) < 0)
  {
    sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long buf = __dst;
    unint64_t v49 = v45;
  }
  long long v47 = 0;
  if (ctu::cf::convert_copy())
  {
    __int16 v13 = v46;
    long long v46 = v47;
    v31[0] = v13;
    sub_1000558F4((const void **)v31);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)buf);
  }
  key = v46;
  long long v46 = 0;
  sub_1000558F4((const void **)&v46);
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__p[0]);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v31, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)uint64_t v31 = *(_OWORD *)(a2 + 24);
    unint64_t v32 = *(void *)(a2 + 40);
  }
  if (SHIBYTE(v32) < 0)
  {
    sub_10004FC84(&__dst, v31[0], (unint64_t)v31[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v31;
    unint64_t v45 = v32;
  }
  long long v43 = 0;
  if (SHIBYTE(v45) < 0)
  {
    sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long buf = __dst;
    unint64_t v49 = v45;
  }
  long long v46 = 0;
  if (ctu::cf::convert_copy())
  {
    char v14 = v43;
    long long v43 = v46;
    long long v47 = v14;
    sub_1000558F4((const void **)&v47);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v33 = v43;
  long long v43 = 0;
  sub_1000558F4((const void **)&v43);
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, key);
  uint64_t v16 = Value;
  if (Value && (CFTypeID v17 = CFGetTypeID(Value), v17 == CFDictionaryGetTypeID()))
  {
    *(void *)&long long __dst = v16;
    CFRetain(v16);
  }
  else
  {
    uint64_t v16 = 0;
    *(void *)&long long __dst = 0;
  }
  if (v16) {
    uint64_t v18 = sub_100080778;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18)
  {
    long long v47 = (void *)CFDictionaryGetValue((CFDictionaryRef)v16, v33);
    *(void *)&long long buf = 0;
    uint64_t v19 = (const void **)sub_100044D6C(&buf, (CFTypeRef *)&v47);
    CFArrayRef v20 = v37;
    CFArrayRef v37 = (const __CFArray *)buf;
    *(void *)&long long buf = v20;
    sub_100044D00(v19);
  }
  else
  {
    CFArrayRef theArray = 0;
  }
  sub_100057D78((const void **)&__dst);
  sub_1000558F4((const void **)&v33);
  sub_1000558F4((const void **)&key);
  if (v18)
  {
LABEL_65:
    CFArrayRef theArray = v37;
    CFArrayRef v37 = 0;
  }
  sub_100044D00((const void **)&v37);
  sub_100057D78((const void **)&theDict);
  if (SHIBYTE(v40) < 0) {
    operator delete(v39[0]);
  }
  if (v42 < 0) {
LABEL_69:
  }
    operator delete(v41[0]);
LABEL_70:
  *a3 = 0u;
  a3[1] = 0u;
  CFArrayRef v21 = theArray;
  if (theArray) {
    uint64_t v22 = sub_100083F10;
  }
  else {
    uint64_t v22 = 0;
  }
  if (v22)
  {
    CFIndex v23 = 0;
    long long __dst = 0uLL;
    unint64_t v45 = 0;
    while (CFArrayGetCount(v21) > v23)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v23);
      if (ValueAtIndex)
      {
        CFTypeID v25 = CFGetTypeID(ValueAtIndex);
        if (v25 == CFStringGetTypeID())
        {
          v41[0] = 0;
          v41[1] = 0;
          uint64_t v42 = 0;
          long long buf = 0uLL;
          unint64_t v49 = 0;
          ctu::cf::assign();
          *(_OWORD *)long long v41 = buf;
          uint64_t v42 = v49;
          char v26 = (_OWORD *)*((void *)&__dst + 1);
          if (*((void *)&__dst + 1) >= v45)
          {
            uint64_t v28 = sub_100048008((uint64_t *)&__dst, (long long *)v41);
          }
          else
          {
            if (SHIBYTE(v42) < 0)
            {
              sub_10004FC84(*((unsigned char **)&__dst + 1), v41[0], (unint64_t)v41[1]);
            }
            else
            {
              long long v27 = *(_OWORD *)v41;
              *(void *)(*((void *)&__dst + 1) + 16) = v42;
              *char v26 = v27;
            }
            uint64_t v28 = (uint64_t)v26 + 24;
          }
          *((void *)&__dst + 1) = v28;
          if (SHIBYTE(v42) < 0) {
            operator delete(v41[0]);
          }
        }
      }
      ++v23;
      CFArrayRef v21 = theArray;
    }
    sub_100F3ADB4((uint64_t)a3, (long long **)&__dst);
    *(void *)&long long buf = &__dst;
    sub_100047F64((void ***)&buf);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100F39790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F3993C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFArrayRef theArray = 0;
  v45[0] = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  sub_100F3A8E8(v45, v5);
  if (v46 >= 0) {
    size_t v6 = HIBYTE(v46);
  }
  else {
    size_t v6 = (size_t)v45[1];
  }
  if (!v6)
  {
    CFArrayRef theArray = 0;
    if ((v46 & 0x8000000000000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_78;
  }
  v43[0] = 0;
  v43[1] = 0;
  uint64_t v44 = 0;
  size_t v7 = v43;
  sub_1000C140C((uint64_t)v43, v6 + 18);
  if (v44 < 0) {
    size_t v7 = (void **)v43[0];
  }
  if (v46 >= 0) {
    CFIndex v8 = v45;
  }
  else {
    CFIndex v8 = (void **)v45[0];
  }
  memmove(v7, v8, v6);
  strcpy((char *)v7 + v6, "/MCCMNC2ISO3.plist");
  CFDictionaryRef theDict = 0;
  unsigned int v9 = (os_log_t *)(v5 + 40);
  sub_1007B946C((os_log_t *)(v5 + 40), (Registry **)(v5 + 464), (const UInt8 *)v43, (const void **)&theDict);
  CFArrayRef v41 = 0;
  if (theDict) {
    CFStringRef v10 = sub_100080778;
  }
  else {
    CFStringRef v10 = 0;
  }
  if (!v10)
  {
    CFTypeID v11 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v43;
      if (v44 < 0) {
        uint64_t v12 = (void **)v43[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Could not load %s as dictionary", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_74;
  }
  key = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    unint64_t v39 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v39) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    unint64_t v49 = v39;
  }
  long long v50 = 0;
  if (SHIBYTE(v49) < 0)
  {
    sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long buf = __dst;
    unint64_t v53 = v49;
  }
  long long v51 = 0;
  if (ctu::cf::convert_copy())
  {
    __int16 v13 = v50;
    long long v50 = v51;
    v35[0] = v13;
    sub_1000558F4((const void **)v35);
  }
  if (SHIBYTE(v53) < 0) {
    operator delete((void *)buf);
  }
  key = v50;
  long long v50 = 0;
  sub_1000558F4((const void **)&v50);
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  CFArrayRef v37 = 0;
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v35, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)unint64_t v35 = *(_OWORD *)(a2 + 24);
    unint64_t v36 = *(void *)(a2 + 40);
  }
  if (SHIBYTE(v36) < 0)
  {
    sub_10004FC84(&__dst, v35[0], (unint64_t)v35[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v35;
    unint64_t v49 = v36;
  }
  long long v47 = 0;
  if (SHIBYTE(v49) < 0)
  {
    sub_10004FC84(&buf, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long buf = __dst;
    unint64_t v53 = v49;
  }
  long long v50 = 0;
  if (ctu::cf::convert_copy())
  {
    char v14 = v47;
    long long v47 = v50;
    long long v51 = v14;
    sub_1000558F4((const void **)&v51);
  }
  if (SHIBYTE(v53) < 0) {
    operator delete((void *)buf);
  }
  CFArrayRef v37 = v47;
  long long v47 = 0;
  sub_1000558F4((const void **)&v47);
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)__dst);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[0]);
  }
  CFDictionaryRef Value = CFDictionaryGetValue(theDict, key);
  uint64_t v16 = Value;
  if (Value && (CFTypeID v17 = CFGetTypeID(Value), v17 == CFDictionaryGetTypeID()))
  {
    *(void *)&long long __dst = v16;
    CFRetain(v16);
  }
  else
  {
    uint64_t v16 = 0;
    *(void *)&long long __dst = 0;
  }
  if (v16) {
    uint64_t v18 = sub_100080778;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18)
  {
    if (v37) {
      uint64_t v19 = sub_1000810B8;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v19)
    {
      long long v51 = (void *)CFDictionaryGetValue((CFDictionaryRef)v16, v37);
      *(void *)&long long buf = 0;
      CFArrayRef v20 = (const void **)sub_100044D6C(&buf, (CFTypeRef *)&v51);
      CFArrayRef v21 = v41;
      CFArrayRef v41 = (const __CFArray *)buf;
      *(void *)&long long buf = v21;
      sub_100044D00(v20);
    }
    if (v41) {
      uint64_t v22 = sub_100083F10;
    }
    else {
      uint64_t v22 = 0;
    }
    if (!v22)
    {
      long long v51 = (void *)CFDictionaryGetValue((CFDictionaryRef)__dst, @"FallbackToMCC");
      *(void *)&long long buf = 0;
      CFIndex v23 = (const void **)sub_100044D6C(&buf, (CFTypeRef *)&v51);
      CFArrayRef v24 = v41;
      CFArrayRef v41 = (const __CFArray *)buf;
      *(void *)&long long buf = v24;
      sub_100044D00(v23);
    }
  }
  else
  {
    CFArrayRef theArray = 0;
  }
  sub_100057D78((const void **)&__dst);
  sub_1000558F4((const void **)&v37);
  sub_1000558F4((const void **)&key);
  if (v18)
  {
LABEL_74:
    CFArrayRef theArray = v41;
    CFArrayRef v41 = 0;
  }
  sub_100044D00((const void **)&v41);
  sub_100057D78((const void **)&theDict);
  if (SHIBYTE(v44) < 0) {
    operator delete(v43[0]);
  }
  if (v46 < 0) {
LABEL_78:
  }
    operator delete(v45[0]);
LABEL_79:
  *a3 = 0u;
  a3[1] = 0u;
  CFArrayRef v25 = theArray;
  if (theArray) {
    char v26 = sub_100083F10;
  }
  else {
    char v26 = 0;
  }
  if (v26)
  {
    CFIndex v27 = 0;
    long long __dst = 0uLL;
    unint64_t v49 = 0;
    while (CFArrayGetCount(v25) > v27)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v27);
      if (ValueAtIndex)
      {
        CFTypeID v29 = CFGetTypeID(ValueAtIndex);
        if (v29 == CFStringGetTypeID())
        {
          v45[0] = 0;
          v45[1] = 0;
          uint64_t v46 = 0;
          long long buf = 0uLL;
          unint64_t v53 = 0;
          ctu::cf::assign();
          *(_OWORD *)unint64_t v45 = buf;
          uint64_t v46 = v53;
          uint64_t v30 = (_OWORD *)*((void *)&__dst + 1);
          if (*((void *)&__dst + 1) >= v49)
          {
            uint64_t v32 = sub_100048008((uint64_t *)&__dst, (long long *)v45);
          }
          else
          {
            if (SHIBYTE(v46) < 0)
            {
              sub_10004FC84(*((unsigned char **)&__dst + 1), v45[0], (unint64_t)v45[1]);
            }
            else
            {
              long long v31 = *(_OWORD *)v45;
              *(void *)(*((void *)&__dst + 1) + 16) = v46;
              *uint64_t v30 = v31;
            }
            uint64_t v32 = (uint64_t)v30 + 24;
          }
          *((void *)&__dst + 1) = v32;
          if (SHIBYTE(v46) < 0) {
            operator delete(v45[0]);
          }
        }
      }
      ++v27;
      CFArrayRef v25 = theArray;
    }
    sub_100F3ADB4((uint64_t)a3, (long long **)&__dst);
    *(void *)&long long buf = &__dst;
    sub_100047F64((void ***)&buf);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100F39F84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F3A134@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 32);
  CFArrayRef theArray = 0;
  v32[0] = 0;
  v32[1] = 0;
  uint64_t v33 = 0;
  sub_100F3A8E8(v32, v5);
  if (SHIBYTE(v33) >= 0) {
    size_t v6 = HIBYTE(v33);
  }
  else {
    size_t v6 = (size_t)v32[1];
  }
  if (!v6)
  {
    CFArrayRef theArray = 0;
    if ((HIBYTE(v33) & 0x80) == 0) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  size_t v7 = v30;
  sub_1000C140C((uint64_t)v30, v6 + 19);
  if (v31 < 0) {
    size_t v7 = (void **)v30[0];
  }
  if (SHIBYTE(v33) >= 0) {
    CFIndex v8 = v32;
  }
  else {
    CFIndex v8 = (void **)v32[0];
  }
  memmove(v7, v8, v6);
  strcpy((char *)v7 + v6, "/ISO3ToMCCMNC.plist");
  CFDictionaryRef theDict = 0;
  unsigned int v9 = (os_log_t *)(v5 + 40);
  sub_1007B946C((os_log_t *)(v5 + 40), (Registry **)(v5 + 464), (const UInt8 *)v30, (const void **)&theDict);
  CFArrayRef theArray = 0;
  if (theDict) {
    CFStringRef v10 = sub_100080778;
  }
  else {
    CFStringRef v10 = 0;
  }
  if (v10)
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a2;
      CFIndex v27 = *(void **)(a2 + 16);
    }
    if (SHIBYTE(v27) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      unint64_t v36 = v27;
    }
    __int16 v34 = 0;
    if (SHIBYTE(v36) < 0)
    {
      sub_10004FC84(&buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long buf = *(_OWORD *)__p;
      uint64_t v40 = v36;
    }
    CFArrayRef v37 = 0;
    if (ctu::cf::convert_copy())
    {
      __int16 v13 = v34;
      __int16 v34 = v37;
      uint64_t v38 = v13;
      sub_1000558F4(&v38);
    }
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)buf);
    }
    char v14 = v34;
    uint64_t v28 = v34;
    __int16 v34 = 0;
    sub_1000558F4(&v34);
    if (SHIBYTE(v36) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(__dst[0]);
    }
    __p[0] = (void *)CFDictionaryGetValue(theDict, v14);
    *(void *)&long long buf = 0;
    uint64_t v15 = (const void **)sub_100044D6C(&buf, (CFTypeRef *)__p);
    CFArrayRef theArray = (CFArrayRef)buf;
    *(void *)&long long buf = 0;
    sub_100044D00(v15);
    sub_1000558F4(&v28);
  }
  else
  {
    CFTypeID v11 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v30;
      if (v31 < 0) {
        uint64_t v12 = (void **)v30[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Could not load %s as dictionary", (uint8_t *)&buf, 0xCu);
    }
  }
  sub_100057D78((const void **)&theDict);
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[0]);
  }
  if ((HIBYTE(v33) & 0x80) != 0) {
LABEL_41:
  }
    operator delete(v32[0]);
LABEL_42:
  *a3 = 0u;
  a3[1] = 0u;
  CFArrayRef v16 = theArray;
  if (theArray) {
    CFTypeID v17 = sub_100083F10;
  }
  else {
    CFTypeID v17 = 0;
  }
  if (v17)
  {
    CFIndex v18 = 0;
    __p[0] = 0;
    __p[1] = 0;
    unint64_t v36 = 0;
    while (CFArrayGetCount(v16) > v18)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
      if (ValueAtIndex)
      {
        CFTypeID v20 = CFGetTypeID(ValueAtIndex);
        if (v20 == CFStringGetTypeID())
        {
          v32[0] = 0;
          v32[1] = 0;
          uint64_t v33 = 0;
          long long buf = 0uLL;
          uint64_t v40 = 0;
          ctu::cf::assign();
          *(_OWORD *)uint64_t v32 = buf;
          uint64_t v33 = v40;
          CFArrayRef v21 = __p[1];
          if (__p[1] >= v36)
          {
            CFIndex v23 = (void *)sub_100048008((uint64_t *)__p, (long long *)v32);
          }
          else
          {
            if (SHIBYTE(v33) < 0)
            {
              sub_10004FC84((unsigned char *)__p[1], v32[0], (unint64_t)v32[1]);
            }
            else
            {
              long long v22 = *(_OWORD *)v32;
              *((void *)__p[1] + 2) = v33;
              *CFArrayRef v21 = v22;
            }
            CFIndex v23 = (char *)v21 + 24;
          }
          __p[1] = v23;
          if (SHIBYTE(v33) < 0) {
            operator delete(v32[0]);
          }
        }
      }
      ++v18;
      CFArrayRef v16 = theArray;
    }
    sub_100F3ADB4((uint64_t)a3, (long long **)__p);
    *(void *)&long long buf = __p;
    sub_100047F64((void ***)&buf);
  }
  return sub_100044D00((const void **)&theArray);
}

void sub_100F3A57C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,const void *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100044D00(&a10);
  sub_100057D78(&a19);
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F3A6A8(uint64_t a1)
{
  sub_100F3BB0C((uint64_t *)(a1 + 40));
  unint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }
  int v4 = (void **)(a1 + 8);
  sub_100047F64(&v4);
  return a1;
}

uint64_t sub_100F3A6FC(uint64_t a1)
{
  sub_100F3BBCC((uint64_t *)(a1 + 40));
  unint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }
  int v4 = (void **)(a1 + 8);
  sub_100047F64(&v4);
  return a1;
}

void *sub_100F3A750(void *a1)
{
  sub_100F3BC98(a1 + 5);
  unint64_t v2 = (const void *)a1[4];
  if (v2) {
    _Block_release(v2);
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_100F3A79C(uint64_t a1)
{
  sub_100F3BD0C((uint64_t *)(a1 + 40));
  unint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    _Block_release(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100F3A7E8(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F3A8E8(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 488);
  if (v3)
  {
    int v4 = *(void (**)(void))(*(void *)v3 + 152);
    v4();
  }
  else
  {
    size_t v6 = *(NSObject **)(a2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No CarrierBundleInterface, file a radar with the generated stackshot!", buf, 2u);
      size_t v6 = *(NSObject **)(a2 + 40);
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)size_t v7 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "IsoMccCache missing CarrierBundleInterface", v7, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_100F3A9F4(void *a1, uint64_t a2, uint64_t a3)
{
  CFIndex v23 = 0;
  size_t v24 = 0;
  uint64_t v25 = 0;
  sub_100F3A8E8(&v23, a2);
  char v6 = HIBYTE(v25);
  if (v25 >= 0) {
    size_t v7 = HIBYTE(v25);
  }
  else {
    size_t v7 = v24;
  }
  if (!v7)
  {
    *a1 = 0;
    if ((v6 & 0x80) == 0) {
      return;
    }
    goto LABEL_41;
  }
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  CFIndex v8 = v21;
  sub_1000C140C((uint64_t)v21, v7 + 14);
  if (v22 < 0) {
    CFIndex v8 = (void **)v21[0];
  }
  if (v25 >= 0) {
    unsigned int v9 = &v23;
  }
  else {
    unsigned int v9 = v23;
  }
  memmove(v8, v9, v7);
  strcpy((char *)v8 + v7, "/ISO2MCC.plist");
  CFDictionaryRef theDict = 0;
  CFStringRef v10 = (os_log_t *)(a2 + 40);
  sub_1007B946C((os_log_t *)(a2 + 40), (Registry **)(a2 + 464), (const UInt8 *)v21, (const void **)&theDict);
  *a1 = 0;
  if (theDict) {
    CFTypeID v11 = sub_100080778;
  }
  else {
    CFTypeID v11 = 0;
  }
  if (v11)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(v17, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)CFTypeID v17 = *(_OWORD *)a3;
      uint64_t v18 = *(void *)(a3 + 16);
    }
    if (SHIBYTE(v18) < 0)
    {
      sub_10004FC84(__p, v17[0], (unint64_t)v17[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)v17;
      uint64_t v28 = v18;
    }
    char v26 = 0;
    if (SHIBYTE(v28) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)__p;
      uint64_t v32 = v28;
    }
    CFTypeID v29 = 0;
    if (ctu::cf::convert_copy())
    {
      char v14 = v26;
      char v26 = v29;
      uint64_t v30 = v14;
      sub_1000558F4(&v30);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v15 = v26;
    uint64_t v19 = v26;
    char v26 = 0;
    sub_1000558F4(&v26);
    if (SHIBYTE(v28) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(v17[0]);
    }
    __p[0] = (void *)CFDictionaryGetValue(theDict, v15);
    *(void *)long long buf = 0;
    CFArrayRef v16 = (const void **)sub_100044D6C(buf, (CFTypeRef *)__p);
    *a1 = *(void *)buf;
    *(void *)long long buf = 0;
    sub_100044D00(v16);
    sub_1000558F4(&v19);
  }
  else
  {
    uint64_t v12 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v13 = v21;
      if (v22 < 0) {
        __int16 v13 = (void **)v21[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Could not load %s as dictionary", buf, 0xCu);
    }
  }
  sub_100057D78((const void **)&theDict);
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  if (v25 < 0) {
LABEL_41:
  }
    operator delete(v23);
}

void sub_100F3AD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,const void *a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  sub_1000558F4(&a30);
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_100044D00(v36);
  sub_100057D78(&a17);
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F3ADB4(uint64_t a1, long long **a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (void **)a1;
    sub_100047F64(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1000302C0((char *)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  *(unsigned char *)(a1 + 24) = 1;
  return a1;
}

void sub_100F3AE2C(uint64_t a1)
{
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v3 = 0;
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 64))(a1, __p);
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F3AEB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3AEE8(uint64_t a1)
{
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v3 = 0;
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 72))(a1, __p);
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F3AF74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3AFA4(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100F3CAEC;
  void v6[3] = &unk_101A71490;
  void v6[4] = a1 + 8;
  void v6[5] = v5;
  size_t v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    CFStringRef v10 = sub_100F3CF74;
    CFTypeID v11 = &unk_101A714D0;
    uint64_t v12 = a3;
    __int16 v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    CFStringRef v10 = sub_100F3CF04;
    CFTypeID v11 = &unk_101A714B0;
    uint64_t v12 = a3;
    __int16 v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_100F3B0CC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100F3CFE4;
  void v6[3] = &unk_101A714F0;
  void v6[4] = a1 + 8;
  void v6[5] = v5;
  size_t v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    CFStringRef v10 = sub_100F3D42C;
    CFTypeID v11 = &unk_101A71530;
    uint64_t v12 = a3;
    __int16 v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    CFStringRef v10 = sub_100F3D3C0;
    CFTypeID v11 = &unk_101A71510;
    uint64_t v12 = a3;
    __int16 v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_100F3B1F4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v6[0] = a1;
  v6[1] = a2;
  _DWORD v6[2] = a3;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100F3D498;
  void v7[3] = &unk_101A71550;
  void v7[4] = a1 + 8;
  void v7[5] = v6;
  CFIndex v8 = v7;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    CFTypeID v11 = sub_100F3CF74;
    uint64_t v12 = &unk_101A714D0;
    __int16 v13 = a4;
    char v14 = &v8;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    CFTypeID v11 = sub_100F3CF04;
    uint64_t v12 = &unk_101A714B0;
    __int16 v13 = a4;
    char v14 = &v8;
    dispatch_sync(v4, &block);
  }
}

void sub_100F3B31C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    long long v6 = 0uLL;
    uint64_t v7 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0uLL;
    uint64_t v5 = 0;
    (*(void (**)(uint64_t, void **))(*(void *)a1 + 24))(a1, __p);
    if (SHIBYTE(v5) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

void sub_100F3B3B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3B3E8(uint64_t a1, int a2)
{
  *(_DWORD *)std::string __str = 0;
  snprintf(__str, 4uLL, "%u", a2);
  sub_100058DB0(__p, __str);
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 24))(a1, __p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100F3B47C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F3B498(uint64_t a1, uint64_t a2)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100F3DAA4;
  void v6[3] = &unk_101A715D0;
  void v6[4] = a1 + 8;
  void v6[5] = v5;
  uint64_t v7 = v6;
  uint64_t v3 = a1 + 24;
  unint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10005B3EC;
    CFTypeID v11 = &unk_101A71610;
    uint64_t v12 = &v14;
    __int16 v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_10005A688;
    CFTypeID v11 = &unk_101A715F0;
    uint64_t v12 = &v14;
    __int16 v13 = &v7;
    dispatch_sync(v2, &block);
  }
  return v14 != 0;
}

void sub_100F3B5CC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v6[0] = a1;
  v6[1] = a2;
  _DWORD v6[2] = a3;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100F3E0A8;
  void v7[3] = &unk_101A71630;
  void v7[4] = a1 + 8;
  void v7[5] = v6;
  CFIndex v8 = v7;
  uint64_t v5 = a1 + 24;
  char v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    CFTypeID v11 = sub_100F3CF74;
    uint64_t v12 = &unk_101A714D0;
    __int16 v13 = a4;
    char v14 = &v8;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    CFTypeID v11 = sub_100F3CF04;
    uint64_t v12 = &unk_101A714B0;
    __int16 v13 = a4;
    char v14 = &v8;
    dispatch_sync(v4, &block);
  }
}

void sub_100F3B6F4(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v5[0] = a1;
  v5[1] = a2;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100F3E144;
  void v6[3] = &unk_101A71650;
  void v6[4] = a1 + 8;
  void v6[5] = v5;
  uint64_t v7 = v6;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_100F3CF74;
    CFTypeID v11 = &unk_101A714D0;
    uint64_t v12 = a3;
    __int16 v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 0x40000000;
    uint64_t v10 = sub_100F3CF04;
    CFTypeID v11 = &unk_101A714B0;
    uint64_t v12 = a3;
    __int16 v13 = &v7;
    dispatch_sync(v3, &block);
  }
}

void sub_100F3B81C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 480))
  {
    sub_100F3BD0C((uint64_t *)(a1 + 88));
    sub_100F3BB0C((uint64_t *)(a1 + 152));
    sub_100F3BC98((uint64_t *)(a1 + 216));
    sub_100F3BBCC((uint64_t *)(a1 + 280));
    sub_100F3BBCC((uint64_t *)(a1 + 344));
    sub_100F3BB0C((uint64_t *)(a1 + 408));
    unint64_t v2 = *(std::__shared_weak_count **)(a1 + 440);
    *(void *)(a1 + 432) = 0;
    *(void *)(a1 + 440) = 0;
    if (v2)
    {
      sub_10004D2C8(v2);
    }
  }
}

void sub_100F3B89C(uint64_t a1)
{
  unint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 104);
    int v7 = 136315394;
    CFIndex v8 = "ISO for MCC";
    __int16 v9 = 2048;
    uint64_t v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s cache has %zu entries", (uint8_t *)&v7, 0x16u);
    unint64_t v2 = *(NSObject **)(a1 + 40);
  }
  sub_100F3BA18(a1 + 112, (uint64_t)"String MCCs for ISO", v2);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 232);
    int v7 = 136315394;
    CFIndex v8 = "Integer MCCs for ISO";
    __int16 v9 = 2048;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s cache has %zu entries", (uint8_t *)&v7, 0x16u);
    uint64_t v4 = *(NSObject **)(a1 + 40);
  }
  sub_100F3BA18(a1 + 240, (uint64_t)"Subregion ISO for MCC + MNC", v4);
  sub_100F3BA18(a1 + 304, (uint64_t)"ISO3s for MCC + MNC", *(os_log_t *)(a1 + 40));
  long long v6 = *(NSObject **)(a1 + 40);

  sub_100F3BA18(a1 + 368, (uint64_t)"String MCCMNCs for ISO3", v6);
}

void sub_100F3BA18(uint64_t a1, uint64_t a2, os_log_t oslog)
{
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 56);
    int v7 = 136315394;
    uint64_t v8 = a2;
    __int16 v9 = 2048;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "#I %s cache has %zu entries", (uint8_t *)&v7, 0x16u);
  }
}

void sub_100F3BAD4(uint64_t a1)
{
  sub_100F3BD80(a1);

  operator delete();
}

void sub_100F3BB0C(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_100720C64((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

uint64_t sub_100F3BB80(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 24);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100F3BBCC(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_100F3BC40((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_100F3BC40(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 48);
  sub_100047F64(&v2);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void sub_100F3BC98(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_1003424C4((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_100F3BD0C(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_1000FECD4((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_100F3BD80(uint64_t a1)
{
  *(void *)a1 = off_101A71068;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 496);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 472);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 456);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 440);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100F3BB0C((uint64_t *)(a1 + 408));
  uint64_t v6 = *(const void **)(a1 + 400);
  if (v6) {
    _Block_release(v6);
  }
  __int16 v13 = (void **)(a1 + 376);
  sub_100047F64(&v13);
  sub_100F3BBCC((uint64_t *)(a1 + 344));
  int v7 = *(const void **)(a1 + 336);
  if (v7) {
    _Block_release(v7);
  }
  __int16 v13 = (void **)(a1 + 312);
  sub_100047F64(&v13);
  sub_100F3BBCC((uint64_t *)(a1 + 280));
  uint64_t v8 = *(const void **)(a1 + 272);
  if (v8) {
    _Block_release(v8);
  }
  __int16 v13 = (void **)(a1 + 248);
  sub_100047F64(&v13);
  sub_100F3BC98((uint64_t *)(a1 + 216));
  __int16 v9 = *(const void **)(a1 + 208);
  if (v9) {
    _Block_release(v9);
  }
  uint64_t v10 = *(void **)(a1 + 184);
  if (v10)
  {
    *(void *)(a1 + 192) = v10;
    operator delete(v10);
  }
  sub_100F3BB0C((uint64_t *)(a1 + 152));
  CFTypeID v11 = *(const void **)(a1 + 144);
  if (v11) {
    _Block_release(v11);
  }
  __int16 v13 = (void **)(a1 + 120);
  sub_100047F64(&v13);
  sub_100F3BD0C((uint64_t *)(a1 + 88));
  uint64_t v12 = *(const void **)(a1 + 80);
  if (v12) {
    _Block_release(v12);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  IsoMccCacheInterface::~IsoMccCacheInterface((IsoMccCacheInterface *)a1);
}

void sub_100F3BF04(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F3BF3C(uint64_t a1)
{
}

uint64_t sub_100F3BF58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F3BF9C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F3BFC8(ServiceManager::Service *this)
{
  *(void *)this = off_101A712A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F3C024(ServiceManager::Service *this)
{
  *(void *)this = off_101A712A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F3C094@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "IsoMccCache");
}

unsigned char *sub_100F3C0A4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F3C0E4(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F3A7E8(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F3A7E8(v4, 0);
}

uint64_t sub_100F3C168()
{
  return 0;
}

uint64_t sub_100F3C170()
{
  return 1;
}

uint64_t sub_100F3C178()
{
  return 0;
}

void sub_100F3C188(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F3C29C(uint64_t a1, const void *a2, long long **a3)
{
  *(void *)a1 = 5;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_1000302C0((char *)(a1 + 8), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  if (a2) {
    uint64_t v5 = _Block_copy(a2);
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = a1 + 40;
  *(void *)(a1 + 48) = a1 + 40;
  *(void *)(a1 + 56) = 0;
  return a1;
}

uint64_t sub_100F3C314(uint64_t a1, const void *a2, long long **a3)
{
  *(void *)a1 = 5;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_1000302C0((char *)(a1 + 8), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  if (a2) {
    uint64_t v5 = _Block_copy(a2);
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = a1 + 40;
  *(void *)(a1 + 48) = a1 + 40;
  *(void *)(a1 + 56) = 0;
  return a1;
}

uint64_t *sub_100F3C38C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 448));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F3C410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F3C42C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  sub_100058DB0(__p, "/cc/props/default_bundle");
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A71328;
  v4[1] = v2 + 480;
  void v4[2] = v2;
  v4[3] = sub_100F3B81C;
  void v4[4] = 0;
  size_t v24 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_101A713A8;
  v5[1] = v2;
  void v5[2] = sub_100F3B89C;
  double v5[3] = 0;
  size_t v24 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(&buf);
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  Registry::createRestModuleOneTimeUseConnection(&buf, *(Registry **)(v2 + 464));
  ctu::RestModule::connect();
  if (v23) {
    sub_10004D2C8(v23);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v2 + 464));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  __int16 v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
LABEL_17:
  CFArrayRef v16 = *(std::__shared_weak_count **)(v2 + 496);
  *(void *)(v2 + 488) = v15;
  *(void *)(v2 + 496) = v14;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_100088C88(&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100F3C69C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3C710()
{
}

__n128 sub_100F3C724(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A71328;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F3C778(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A71328;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F3C7B0(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (char *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (signed __int8 *)a2, v6);
    *uint64_t v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100F3C8A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F3C8E0()
{
}

void sub_100F3C8F0()
{
}

__n128 sub_100F3C904(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A713A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F3C958(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A713A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F3C990(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F3C9D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F3CA18()
{
}

void sub_100F3CA28(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F3CA60(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_1004DD39C(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100F3CAA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100F3CAEC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void sub_100F3CB00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1000302C0((char *)a1, *(long long **)(a2 + 8), *(long long **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  if (!*(void *)a2) {
    return;
  }
  uint64_t v6 = a2 + 40;
  uint64_t v7 = *(void *)(a2 + 48);
  if (v7 != a2 + 40)
  {
    char v8 = 0;
    while (1)
    {
      memset(v26, 0, sizeof(v26));
      *(_OWORD *)long long __s1 = 0u;
      if (*(char *)(v7 + 39) < 0)
      {
        sub_10004FC84(__s1, *(void **)(v7 + 16), *(void *)(v7 + 24));
      }
      else
      {
        *(_OWORD *)long long __s1 = *(_OWORD *)(v7 + 16);
        *(void *)&v26[0] = *(void *)(v7 + 32);
      }
      memset((char *)v26 + 8, 0, 24);
      sub_1000302C0((char *)v26 + 8, *(long long **)(v7 + 40), *(long long **)(v7 + 48), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v7 + 48) - *(void *)(v7 + 40)) >> 3));
      uint64_t v9 = BYTE7(v26[0]);
      if ((SBYTE7(v26[0]) & 0x80u) == 0) {
        uint64_t v10 = (void *)BYTE7(v26[0]);
      }
      else {
        uint64_t v10 = __s1[1];
      }
      uint64_t v11 = (void *)*(unsigned __int8 *)(a3 + 23);
      int v12 = (char)v11;
      if ((char)v11 < 0) {
        uint64_t v11 = *(void **)(a3 + 8);
      }
      if (v10 != v11) {
        goto LABEL_23;
      }
      char v13 = v12 >= 0 ? (unsigned __int8 *)a3 : *(unsigned __int8 **)a3;
      if ((BYTE7(v26[0]) & 0x80) == 0) {
        break;
      }
      int v16 = memcmp(__s1[0], v13, (size_t)__s1[1]);
      BOOL v15 = v16 == 0;
      v8 |= v16 == 0;
      if (!v16 && (_OWORD *)((char *)v26 + 8) != (_OWORD *)a1) {
        goto LABEL_26;
      }
LABEL_28:
      *(void *)&long long v23 = (char *)v26 + 8;
      sub_100047F64((void ***)&v23);
      if (SBYTE7(v26[0]) < 0) {
        operator delete(__s1[0]);
      }
      if (v15)
      {
        if ((v8 & 1) == 0)
        {
          __s1[0] = (void *)a1;
          goto LABEL_48;
        }
        return;
      }
      uint64_t v7 = *(void *)(v7 + 8);
      if (v7 == v6) {
        goto LABEL_32;
      }
    }
    if (BYTE7(v26[0]))
    {
      char v14 = __s1;
      while (*(unsigned __int8 *)v14 == *v13)
      {
        char v14 = (void **)((char *)v14 + 1);
        ++v13;
        if (!--v9) {
          goto LABEL_21;
        }
      }
LABEL_23:
      BOOL v15 = 0;
      goto LABEL_28;
    }
LABEL_21:
    if ((_OWORD *)((char *)v26 + 8) != (_OWORD *)a1) {
LABEL_26:
    }
      sub_10005CA3C(a1, *((std::string **)&v26[0] + 1), *(long long **)&v26[1], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v26[1] - *((void *)&v26[0] + 1)) >> 3));
    BOOL v15 = 1;
    char v8 = 1;
    goto LABEL_28;
  }
LABEL_32:
  long long v23 = 0u;
  long long v24 = 0u;
  (*(void (**)(long long *__return_ptr))(*(void *)(a2 + 32) + 16))(&v23);
  if (&v23 != (long long *)a1 && BYTE8(v24)) {
    sub_10005CA3C(a1, (std::string *)v23, *((long long **)&v23 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v23 + 1) - v23) >> 3));
  }
  unint64_t v17 = *(void *)(a2 + 56);
  if (v17 >= *(void *)a2)
  {
    if (!v17)
    {
      __TUAssertTrigger();
      unint64_t v17 = *(void *)(a2 + 56);
    }
    uint64_t v18 = *(uint64_t **)(a2 + 40);
    uint64_t v19 = *v18;
    *(void *)(v19 + 8) = v18[1];
    *(void *)v18[1] = v19;
    *(void *)(a2 + 56) = v17 - 1;
    sub_100720C64((uint64_t)(v18 + 2));
    operator delete(v18);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__s1, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __s1 = *(_OWORD *)a3;
    *(void *)&v26[0] = *(void *)(a3 + 16);
  }
  memset((char *)v26 + 8, 0, 24);
  sub_1000302C0((char *)v26 + 8, *(long long **)a1, *(long long **)(a1 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3));
  CFTypeID v20 = operator new(0x40uLL);
  v20[1] = *(_OWORD *)__s1;
  *((void *)v20 + 4) = *(void *)&v26[0];
  __s1[1] = 0;
  *(void *)&v26[0] = 0;
  __s1[0] = 0;
  *(_OWORD *)((char *)v20 + 40) = *(_OWORD *)((char *)v26 + 8);
  *((void *)v20 + 7) = *((void *)&v26[1] + 1);
  memset((char *)v26 + 8, 0, 24);
  char v21 = *(void **)(a2 + 48);
  *(void *)CFTypeID v20 = v6;
  *((void *)v20 + 1) = v21;
  *char v21 = v20;
  uint64_t v22 = *(void *)(a2 + 56) + 1;
  *(void *)(a2 + 48) = v20;
  *(void *)(a2 + 56) = v22;
  CFIndex v27 = (void **)v26 + 1;
  sub_100047F64(&v27);
  if (SBYTE7(v26[0]) < 0) {
    operator delete(__s1[0]);
  }
  if (BYTE8(v24))
  {
    __s1[0] = &v23;
LABEL_48:
    sub_100047F64((void ***)__s1);
  }
}

void sub_100F3CE70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a12)
  {
    std::string __p = &a9;
    sub_100047F64((void ***)&__p);
  }
  sub_100047F64((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_100F3CF04(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  sub_10005CBB4(v2);
  *(_OWORD *)uint64_t v2 = v3;
  void v2[2] = v4;
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

void sub_100F3CF74(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v3);
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  sub_10005CBB4(v2);
  *(_OWORD *)uint64_t v2 = v3;
  void v2[2] = v4;
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  uint64_t v5 = (void **)&v3;
  sub_100047F64(&v5);
}

void sub_100F3CFE4(uint64_t a1@<X0>, void **a2@<X8>)
{
  long long v3 = *(uint64_t **)(a1 + 40);
  uint64_t v5 = *v3;
  uint64_t v4 = (long long *)v3[1];
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  sub_1003A10E0(a2, *(const void **)(v5 + 184), *(void *)(v5 + 192), (uint64_t)(*(void *)(v5 + 192) - *(void *)(v5 + 184)) >> 1);
  if (!*(void *)(v5 + 176)) {
    return;
  }
  uint64_t v6 = v5 + 216;
  uint64_t v7 = *(void *)(v5 + 224);
  if (v7 != v5 + 216)
  {
    char v8 = 0;
    while (1)
    {
      memset(__p, 0, sizeof(__p));
      *(_OWORD *)long long __s1 = 0u;
      if (*(char *)(v7 + 39) < 0)
      {
        sub_10004FC84(__s1, *(void **)(v7 + 16), *(void *)(v7 + 24));
      }
      else
      {
        *(_OWORD *)long long __s1 = *(_OWORD *)(v7 + 16);
        __p[0] = *(void **)(v7 + 32);
      }
      memset(&__p[1], 0, 24);
      sub_1003A10E0(&__p[1], *(const void **)(v7 + 40), *(void *)(v7 + 48), (uint64_t)(*(void *)(v7 + 48) - *(void *)(v7 + 40)) >> 1);
      uint64_t v9 = HIBYTE(__p[0]);
      if (SHIBYTE(__p[0]) >= 0) {
        uint64_t v10 = (void *)HIBYTE(__p[0]);
      }
      else {
        uint64_t v10 = __s1[1];
      }
      uint64_t v11 = (void *)*((unsigned __int8 *)v4 + 23);
      int v12 = (char)v11;
      if ((char)v11 < 0) {
        uint64_t v11 = (void *)*((void *)v4 + 1);
      }
      if (v10 != v11) {
        goto LABEL_23;
      }
      char v13 = v12 >= 0 ? (unsigned __int8 *)v4 : *(unsigned __int8 **)v4;
      if ((HIBYTE(__p[0]) & 0x80) == 0) {
        break;
      }
      int v16 = memcmp(__s1[0], v13, (size_t)__s1[1]);
      BOOL v15 = v16 == 0;
      v8 |= v16 == 0;
      if (!v16 && &__p[1] != a2) {
        goto LABEL_26;
      }
LABEL_28:
      if (__p[1])
      {
        __p[2] = __p[1];
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(__s1[0]);
      }
      if (v15)
      {
        if ((v8 & 1) == 0)
        {
          char v21 = *a2;
          if (*a2)
          {
            a2[1] = v21;
            goto LABEL_52;
          }
        }
        return;
      }
      uint64_t v7 = *(void *)(v7 + 8);
      if (v7 == v6) {
        goto LABEL_34;
      }
    }
    if (HIBYTE(__p[0]))
    {
      char v14 = __s1;
      while (*(unsigned __int8 *)v14 == *v13)
      {
        char v14 = (void **)((char *)v14 + 1);
        ++v13;
        if (!--v9) {
          goto LABEL_21;
        }
      }
LABEL_23:
      BOOL v15 = 0;
      goto LABEL_28;
    }
LABEL_21:
    if (&__p[1] != a2) {
LABEL_26:
    }
      sub_1003BA328((char *)a2, (char *)__p[1], (uint64_t)__p[2], ((char *)__p[2] - (char *)__p[1]) >> 1);
    BOOL v15 = 1;
    char v8 = 1;
    goto LABEL_28;
  }
LABEL_34:
  *(_OWORD *)uint64_t v25 = 0u;
  long long v26 = 0u;
  (*(void (**)(void **__return_ptr))(*(void *)(v5 + 208) + 16))(v25);
  if (v25 != a2 && BYTE8(v26)) {
    sub_1003BA328((char *)a2, (char *)v25[0], (uint64_t)v25[1], ((char *)v25[1] - (char *)v25[0]) >> 1);
  }
  unint64_t v17 = *(void *)(v5 + 232);
  if (v17 >= *(void *)(v5 + 176))
  {
    if (!v17)
    {
      __TUAssertTrigger();
      unint64_t v17 = *(void *)(v5 + 232);
    }
    uint64_t v18 = *(uint64_t **)(v5 + 216);
    uint64_t v19 = *v18;
    *(void *)(v19 + 8) = v18[1];
    *(void *)v18[1] = v19;
    *(void *)(v5 + 232) = v17 - 1;
    sub_1003424C4((uint64_t)(v18 + 2));
    operator delete(v18);
  }
  if (*((char *)v4 + 23) < 0)
  {
    sub_10004FC84(__s1, *(void **)v4, *((void *)v4 + 1));
  }
  else
  {
    long long v20 = *v4;
    __p[0] = *((void **)v4 + 2);
    *(_OWORD *)long long __s1 = v20;
  }
  memset(&__p[1], 0, 24);
  sub_1003A10E0(&__p[1], *a2, (uint64_t)a2[1], ((unsigned char *)a2[1] - (unsigned char *)*a2) >> 1);
  uint64_t v22 = operator new(0x40uLL);
  v22[1] = *(_OWORD *)__s1;
  *((void **)v22 + 4) = __p[0];
  __s1[1] = 0;
  __p[0] = 0;
  __s1[0] = 0;
  *(_OWORD *)((char *)v22 + 40) = *(_OWORD *)&__p[1];
  *((void **)v22 + 7) = __p[3];
  memset(&__p[1], 0, 24);
  *(void *)uint64_t v22 = v6;
  long long v23 = *(void **)(v5 + 224);
  *((void *)v22 + 1) = v23;
  void *v23 = v22;
  uint64_t v24 = *(void *)(v5 + 232) + 1;
  *(void *)(v5 + 224) = v22;
  *(void *)(v5 + 232) = v24;
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(__s1[0]);
  }
  if (BYTE8(v26))
  {
    char v21 = v25[0];
    if (v25[0])
    {
      v25[1] = v25[0];
LABEL_52:
      operator delete(v21);
    }
  }
}

void sub_100F3D31C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20)
{
  if (a12 && __p) {
    operator delete(__p);
  }
  uint64_t v22 = *(void **)v20;
  if (*(void *)v20)
  {
    *(void *)(v20 + 8) = v22;
    operator delete(v22);
  }
  _Unwind_Resume(exception_object);
}

double sub_100F3D3C0(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

double sub_100F3D42C(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

void sub_100F3D498(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3 + 240;
  sub_10081AC1C((char *)v5, *(long long **)(v3 + 8), *(long long **)(v3 + 16));
  sub_100F3D534(a2, v4, (unsigned __int8 *)v5);
  if (v8 < 0) {
    operator delete(__p);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_100F3D508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3D534(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1000302C0((char *)a1, *(long long **)(a2 + 8), *(long long **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  if (!*(void *)a2) {
    return;
  }
  uint64_t v6 = a2 + 40;
  uint64_t v7 = *(void *)(a2 + 48);
  if (v7 != a2 + 40)
  {
    char v8 = 0;
    do
    {
      uint64_t v34 = 0;
      long long v33 = 0u;
      *(_OWORD *)long long __s1 = 0u;
      memset(__p, 0, sizeof(__p));
      sub_100F3D9A8((char *)__s1, (long long *)(v7 + 16));
      uint64_t v34 = 0;
      long long v33 = 0uLL;
      sub_1000302C0((char *)&v33, *(long long **)(v7 + 64), *(long long **)(v7 + 72), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v7 + 72) - *(void *)(v7 + 64)) >> 3));
      uint64_t v9 = HIBYTE(__p[0]);
      if (SHIBYTE(__p[0]) >= 0) {
        uint64_t v10 = (void *)HIBYTE(__p[0]);
      }
      else {
        uint64_t v10 = __s1[1];
      }
      uint64_t v11 = (void *)a3[23];
      int v12 = (char)v11;
      if ((char)v11 < 0) {
        uint64_t v11 = (void *)*((void *)a3 + 1);
      }
      if (v10 != v11) {
        goto LABEL_34;
      }
      if (v12 >= 0) {
        char v13 = a3;
      }
      else {
        char v13 = *(unsigned __int8 **)a3;
      }
      if ((HIBYTE(__p[0]) & 0x80) != 0)
      {
        if (memcmp(__s1[0], v13, (size_t)__s1[1])) {
          goto LABEL_34;
        }
      }
      else if (HIBYTE(__p[0]))
      {
        char v14 = __s1;
        while (*(unsigned __int8 *)v14 == *v13)
        {
          char v14 = (void **)((char *)v14 + 1);
          ++v13;
          if (!--v9) {
            goto LABEL_20;
          }
        }
        goto LABEL_34;
      }
LABEL_20:
      uint64_t v15 = HIBYTE(__p[3]);
      if (SHIBYTE(__p[3]) >= 0) {
        int v16 = (void *)HIBYTE(__p[3]);
      }
      else {
        int v16 = __p[2];
      }
      unint64_t v17 = (void *)a3[47];
      int v18 = (char)v17;
      if ((char)v17 < 0) {
        unint64_t v17 = (void *)*((void *)a3 + 4);
      }
      if (v16 != v17) {
        goto LABEL_34;
      }
      if (v18 >= 0) {
        uint64_t v19 = a3 + 24;
      }
      else {
        uint64_t v19 = (unsigned __int8 *)*((void *)a3 + 3);
      }
      if ((HIBYTE(__p[3]) & 0x80) != 0)
      {
        BOOL v21 = memcmp(__p[1], v19, (size_t)__p[2]) == 0;
      }
      else
      {
        uint64_t v20 = &__p[1];
        if (HIBYTE(__p[3]))
        {
          while (*(unsigned __int8 *)v20 == *v19)
          {
            uint64_t v20 = (void **)((char *)v20 + 1);
            ++v19;
            if (!--v15) {
              goto LABEL_33;
            }
          }
LABEL_34:
          LOBYTE(v21) = 0;
          goto LABEL_35;
        }
LABEL_33:
        BOOL v21 = 1;
      }
      v8 |= v21;
      if (v21 && &v33 != (long long *)a1)
      {
        sub_10005CA3C(a1, (std::string *)v33, *((long long **)&v33 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v33 + 1) - v33) >> 3));
        LOBYTE(v21) = 1;
        char v8 = 1;
      }
LABEL_35:
      *(void *)&long long v29 = &v33;
      sub_100047F64((void ***)&v29);
      if (SHIBYTE(__p[3]) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(__s1[0]);
      }
      if (v21)
      {
        if ((v8 & 1) == 0)
        {
          __s1[0] = (void *)a1;
LABEL_61:
          sub_100047F64((void ***)__s1);
        }
        return;
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != v6);
  }
  long long v29 = 0u;
  long long v30 = 0u;
  (*(void (**)(long long *__return_ptr))(*(void *)(a2 + 32) + 16))(&v29);
  if (&v29 != (long long *)a1 && BYTE8(v30)) {
    sub_10005CA3C(a1, (std::string *)v29, *((long long **)&v29 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v29 + 1) - v29) >> 3));
  }
  unint64_t v22 = *(void *)(a2 + 56);
  if (v22 >= *(void *)a2)
  {
    if (!v22)
    {
      __TUAssertTrigger();
      unint64_t v22 = *(void *)(a2 + 56);
    }
    long long v23 = *(uint64_t **)(a2 + 40);
    uint64_t v24 = *v23;
    *(void *)(v24 + 8) = v23[1];
    *(void *)v23[1] = v24;
    *(void *)(a2 + 56) = v22 - 1;
    sub_100F3BC40((uint64_t)(v23 + 2));
    operator delete(v23);
  }
  sub_100F3D9A8((char *)__s1, (long long *)a3);
  long long v33 = 0uLL;
  uint64_t v34 = 0;
  sub_1000302C0((char *)&v33, *(long long **)a1, *(long long **)(a1 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3));
  uint64_t v25 = operator new(0x58uLL);
  v25[1] = *(_OWORD *)__s1;
  *((void **)v25 + 4) = __p[0];
  __s1[0] = 0;
  __s1[1] = 0;
  long long v26 = *(_OWORD *)&__p[1];
  __p[0] = 0;
  __p[1] = 0;
  *(_OWORD *)((char *)v25 + 40) = v26;
  *((void **)v25 + 7) = __p[3];
  __p[2] = 0;
  __p[3] = 0;
  void v25[4] = v33;
  *((void *)v25 + 10) = v34;
  uint64_t v34 = 0;
  long long v33 = 0uLL;
  CFIndex v27 = *(void **)(a2 + 48);
  *(void *)uint64_t v25 = v6;
  *((void *)v25 + 1) = v27;
  *CFIndex v27 = v25;
  uint64_t v28 = *(void *)(a2 + 56) + 1;
  *(void *)(a2 + 48) = v25;
  *(void *)(a2 + 56) = v28;
  unint64_t v35 = (void **)&v33;
  sub_100047F64(&v35);
  if (SHIBYTE(__p[3]) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(__s1[0]);
  }
  if (BYTE8(v30))
  {
    __s1[0] = &v29;
    goto LABEL_61;
  }
}

void sub_100F3D924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, void **a15)
{
  if (a14)
  {
    a15 = (void **)&a11;
    sub_100047F64(&a15);
  }
  sub_100047F64(&a15);
  _Unwind_Resume(a1);
}

char *sub_100F3D9A8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  long long v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)long long v5 = v6;
  }
  return __dst;
}

void sub_100F3DA24(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100F3DA40(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

BOOL sub_100F3DAA4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 ***)(a1 + 40);
  uint64_t v2 = (void *)*((void *)*v1 + 54);
  if (!v2) {
    operator new();
  }
  return sub_1003DDE88(v2, v1[1]) != 0;
}

void sub_100F3DFE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,const void *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

void sub_100F3E0A8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)v3 + 304;
  sub_10081AC1C((char *)v5, *(long long **)(v3 + 8), *(long long **)(v3 + 16));
  sub_100F3D534(a2, v4, (unsigned __int8 *)v5);
  if (v8 < 0) {
    operator delete(__p);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_100F3E118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3E144(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

void sub_100F3E2C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100F3E410(uint64_t a1)
{
  *(void *)a1 = off_101A71680;
  uint64_t v2 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = 0;

  uint64_t v3 = *(void **)(a1 + 184);
  *(void *)(a1 + 184) = 0;

  sub_1000346F8(a1 + 208, *(void **)(a1 + 216));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 200);
  if (v4) {
    sub_10004D2C8(v4);
  }

  NetworkUsageStrategy::~NetworkUsageStrategy((char **)a1);
}

void sub_100F3E4A4(uint64_t a1)
{
  sub_100F3E410(a1);

  operator delete();
}

void sub_100F3E4DC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (!v2 || (v3 = (const void *)a1[1], uint64_t v4 = std::__shared_weak_count::lock(v2), (v21 = v4) == 0)) {
    sub_100088B9C();
  }
  if (v3 {
    && (uint64_t v5 = v4,
  }
  {
    unint64_t v22 = v6;
    long long v23 = v5;
    uint64_t v7 = (void **)&v20;
  }
  else
  {
    uint64_t v7 = &v22;
  }
  *uint64_t v7 = 0;
  v7[1] = 0;
  uint64_t v9 = v22;
  char v8 = v23;
  uint64_t v10 = operator new(0x28uLL);
  uint64_t v11 = v10;
  v10[1] = 0;
  void v10[2] = 0;
  void *v10 = off_101A71708;
  int v12 = v10 + 3;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v10[3] = v9;
    v10[4] = v8;
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v8);
  }
  else
  {
    v10[3] = v9;
    v10[4] = 0;
  }
  char v13 = (std::__shared_weak_count *)a1[25];
  a1[24] = v12;
  a1[25] = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  char v14 = [NetworkUsageUpdater alloc];
  uint64_t v15 = (std::__shared_weak_count *)a1[25];
  uint64_t v18 = a1[24];
  uint64_t v19 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v16 = [(NetworkUsageUpdater *)v14 initWithHandler:&v18];
  unint64_t v17 = (void *)a1[23];
  a1[23] = v16;

  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_100F3E65C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F3E690(uint64_t a1)
{
  if (!*(void *)(a1 + 176))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I start collect", buf, 2u);
    }
    id v3 = [objc_alloc((Class)NWStatsManager) initWithQueue:*(void *)(a1 + 24)];
    uint64_t v4 = *(void **)(a1 + 176);
    *(void *)(a1 + 176) = v3;

    uint64_t v5 = *(void **)(a1 + 176);
    if (v5)
    {
      [v5 setDelegate:*(void *)(a1 + 184)];
      v12[0] = kNWStatsSelectInterfaceCellular;
      v12[1] = kNWStatsParameterMappingAppStateMonitoring;
      *(void *)uint64_t buf = &__kCFBooleanTrue;
      char v14 = &__kCFBooleanFalse;
      v12[2] = kNWStatsParameterMappingUseNEHelper;
      v12[3] = kNWStatsParameterMappingAvoidCoalitions;
      uint64_t v15 = &__kCFBooleanTrue;
      int v16 = &__kCFBooleanTrue;
      char v6 = +[NSDictionary dictionaryWithObjects:buf forKeys:v12 count:4];
      int v7 = [*(id *)(a1 + 176) configure:v6];
      if (v7)
      {
        char v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          int v10 = 136446210;
          uint64_t v11 = strerror(v7);
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "unable to configure monitoring, reason %{public}s", (uint8_t *)&v10, 0xCu);
        }
      }
    }
    else
    {
      uint64_t v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Not starting collect. Unable to allocate resource.", buf, 2u);
      }
    }
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    NetworkUsageStrategy::setupThresholdMonitor_sync((Registry **)a1);
  }
}

void sub_100F3E8F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100F3E90C(uint64_t a1)
{
  [*(id *)(a1 + 176) setDelegate:0];
  (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
  uint64_t v2 = *(void **)(a1 + 128);
  if (v2 != (void *)(a1 + 136))
  {
    do
    {
      (*(void (**)(uint64_t, void *))(*(void *)a1 + 64))(a1, v2 + 4);
      id v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          id v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != (void *)(a1 + 136));
  }
  char v6 = *(void **)(a1 + 208);
  if (v6 != (void *)(a1 + 216))
  {
    do
    {
      sub_100F3EA34(a1, *((unsigned int *)v6 + 7), 0);
      int v7 = (void *)v6[1];
      if (v7)
      {
        do
        {
          char v8 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          char v8 = (void *)v6[2];
          BOOL v5 = *v8 == (void)v6;
          char v6 = v8;
        }
        while (!v5);
      }
      char v6 = v8;
    }
    while (v8 != (void *)(a1 + 216));
  }
}

void sub_100F3EA34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = a2;
  char v6 = *(void **)(a1 + 176);
  uint64_t v21 = kNWStatsParameterThresholds;
  int v7 = +[NSNumber numberWithUnsignedInt:a2];
  uint64_t v19 = v7;
  char v8 = +[NSNumber numberWithUnsignedLongLong:a3];
  char v20 = v8;
  uint64_t v9 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
  unint64_t v22 = v9;
  int v10 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
  int v11 = [v6 configure:v10];

  int v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134218498;
    uint64_t v14 = a3;
    __int16 v15 = 1024;
    int v16 = v4;
    __int16 v17 = 2082;
    uint64_t v18 = strerror(v11);
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Threshold monitor was set to %llu for interface %d: %{public}s", (uint8_t *)&v13, 0x1Cu);
  }
}

void sub_100F3EBB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100F3EBF4(uint64_t a1)
{
}

void sub_100F3EC00(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 128);
  uint64_t v2 = (void *)(a1 + 136);
  if (v1 != (void *)(a1 + 136))
  {
    do
    {
      uint64_t v4 = *((unsigned int *)v1 + 10);
      if ((v4 & 0x80000000) == 0 && v4 != *(_DWORD *)(a1 + 120))
      {
        BOOL v5 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 67109120;
          int v10 = v4;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I creating tethering source on %d since it differs from internet source", buf, 8u);
          uint64_t v4 = *((unsigned int *)v1 + 10);
        }
        sub_100F3EA34(a1, v4, 0x100000);
      }
      char v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          char v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      uint64_t v1 = v7;
    }
    while (v7 != v2);
  }
}

void sub_100F3ED38(uint64_t a1)
{
}

void sub_100F3ED44(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 8);
  if (v2 != *(_DWORD *)(a1 + 120))
  {
    BOOL v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 67109120;
      v6[1] = v2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I stopping tethering source %d since it differs from internet source", (uint8_t *)v6, 8u);
      uint64_t v2 = *(unsigned int *)(a2 + 8);
    }
    sub_100F3EA34(a1, v2, 0);
  }
}

BOOL sub_100F3EE10(uint64_t a1)
{
  return *(void *)(a1 + 176) != 0;
}

void sub_100F3EE20(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 euuid];
  BOOL v5 = [v4 UUIDString];
  id v6 = [objc_alloc((Class)NSString) initWithUTF8String:"67A03811-DB0A-594E-C2AE-8B0517EDF26F"];
  id v7 = [v5 isEqualToString:v6];

  if (v7)
  {
    id v8 = v3;
    if ([v8 snapshotReason] == 2)
    {
      signed int v9 = [v8 interfaceIndex];
      int v10 = *(uint64_t **)(a1 + 216);
      if (v10)
      {
        uint64_t v11 = a1 + 216;
        uint64_t v12 = *(void *)(a1 + 216);
        do
        {
          signed int v13 = *(_DWORD *)(v12 + 28);
          BOOL v14 = v13 < v9;
          if (v13 >= v9) {
            __int16 v15 = (uint64_t *)v12;
          }
          else {
            __int16 v15 = (uint64_t *)(v12 + 8);
          }
          if (!v14) {
            uint64_t v11 = v12;
          }
          uint64_t v12 = *v15;
        }
        while (*v15);
        if (v11 != a1 + 216 && *(_DWORD *)(v11 + 28) <= v9)
        {
          int v16 = *(void **)(v11 + 8);
          if (v16)
          {
            do
            {
              __int16 v17 = v16;
              int v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            uint64_t v21 = (void *)v11;
            do
            {
              __int16 v17 = (void *)v21[2];
              BOOL v80 = *v17 == (void)v21;
              uint64_t v21 = v17;
            }
            while (!v80);
          }
          if (*(void *)(a1 + 208) == v11) {
            *(void *)(a1 + 208) = v17;
          }
          --*(void *)(a1 + 224);
          sub_10005EE6C(v10, (uint64_t *)v11);
          operator delete((void *)v11);
          sub_100F3EA34(a1, (uint64_t)[v8 interfaceIndex], 0);
        }
      }
    }
    else
    {
      *(_DWORD *)uint64_t buf = [v8 interfaceIndex];
      sub_10078C71C((uint64_t **)(a1 + 208), (int *)buf, buf);
      if (v18)
      {
        uint64_t v19 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v20 = [v8 interfaceIndex];
          *(_DWORD *)uint64_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Monitoring ims interface index %d", buf, 8u);
        }
        sub_100F3EA34(a1, (uint64_t)[v8 interfaceIndex], 0x100000);
      }
    }
  }
  id v96 = v3;
  if ([v96 failedConsistencyChecks])
  {
    unint64_t v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      long long v23 = [v96 uuid];
      uint64_t v24 = [v23 UUIDString];
      if (v24)
      {
        id v6 = [v96 uuid];
        id v7 = [v6 UUIDString];
        uint64_t v25 = (const char *)[v7 UTF8String];
      }
      else
      {
        uint64_t v25 = "unknown uuid";
      }
      unsigned int v44 = [v96 interfaceIndex];
      *(_DWORD *)uint64_t buf = 136446466;
      *(void *)&uint8_t buf[4] = v25;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v44;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#N Snapshot (%{public}s) for interface %d failed consistency checks", buf, 0x12u);
      if (v24)
      {
      }
    }
    goto LABEL_155;
  }
  if (![v96 deltaAccountingRxCellularBytes] && !objc_msgSend(v96, "deltaAccountingTxCellularBytes")) {
    goto LABEL_155;
  }
  if ([v96 interfaceIndex] != *(_DWORD *)(a1 + 120))
  {
    unsigned int v26 = [v96 interfaceIndex];
    CFIndex v27 = *(void **)(a1 + 128);
    uint64_t v28 = (void *)(a1 + 136);
    if (v27 != (void *)(a1 + 136))
    {
      while (*((_DWORD *)v27 + 10) != v26)
      {
        long long v29 = (void *)v27[1];
        if (v29)
        {
          do
          {
            long long v30 = v29;
            long long v29 = (void *)*v29;
          }
          while (v29);
        }
        else
        {
          do
          {
            long long v30 = (void *)v27[2];
            BOOL v80 = *v30 == (void)v27;
            CFIndex v27 = v30;
          }
          while (!v80);
        }
        CFIndex v27 = v30;
        if (v30 == v28) {
          goto LABEL_45;
        }
      }
    }
    if (v27 != v28)
    {
      NetworkUsageStrategy::updateTetheringDataUsage_sync((void *)a1, v27 + 4);
      goto LABEL_155;
    }
  }
LABEL_45:
  uint64_t v105 = 0;
  long long v111 = 0u;
  memset(buf, 0, sizeof(buf));
  memset(v104, 0, sizeof(v104));
  long long v103 = 0xFFFFFFFFFFFFFFFFLL;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  *(_OWORD *)BOOL v109 = 0u;
  memset(v110, 0, sizeof(v110));
  *(void *)uint64_t buf = [v96 deltaAccountingRxCellularBytes];
  *(void *)&uint8_t buf[8] = [v96 deltaAccountingTxCellularBytes];
  LODWORD(v103) = [v96 epid];
  DWORD1(v103) = [v96 processID];
  objc_opt_class();
  BYTE8(v103) = objc_opt_isKindOfClass() & 1;
  objc_opt_class();
  BYTE9(v103) = objc_opt_isKindOfClass() & 1;
  BYTE10(v103) = [v96 interfaceCellularViaAnyFallback];
  uint64_t v31 = [v96 euuid];
  if (v31)
  {
    uint64_t v32 = [v96 euuid];
    id v33 = [v32 UUIDString];
    sub_100058DB0(__p, (char *)[v33 UTF8String]);
    uint64_t v34 = *(void **)(a1 + 152);
    v101.__r_.__value_.__s.__data_[0] = 0;
    unint64_t v35 = sub_1000D85D4(v34, (void *)(a1 + 160), (unsigned __int8 **)__p);
    if (SBYTE7(v99) < 0) {
      operator delete(__p[0]);
    }

    if ((void *)(a1 + 160) != v35) {
      LOBYTE(v110[4]) = 1;
    }
  }
  unint64_t v36 = [v96 attributedEntity];
  BOOL v37 = v36 == 0;

  if (v37)
  {
    uint64_t v40 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#N attributed entity is not valid", (uint8_t *)__p, 2u);
    }
    CFArrayRef v41 = [v96 processName];
    BOOL v42 = v41 == 0;

    if (v42)
    {
      unint64_t v45 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#N process name is not valid", (uint8_t *)__p, 2u);
      }
    }
    else
    {
      id v43 = [v96 processName];
      sub_10003ED78(v104, (char *)[v43 UTF8String]);
    }
  }
  else
  {
    id v38 = [v96 attributedEntity];
    sub_10003ED78(&v104[1], (char *)[v38 UTF8String]);

    id v39 = [v96 processName];
    sub_10003ED78(v104, (char *)[v39 UTF8String]);
  }
  LOBYTE(v105) = [v96 attributionReason] == 0;
  uint64_t v46 = [v96 uuid];
  if (v46)
  {
  }
  else
  {
    long long v47 = [v96 euuid];
    BOOL v48 = v47 == 0;

    if (v48)
    {
      unint64_t v49 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#N snapshot uuid & euuid are not valid", (uint8_t *)__p, 2u);
      }
    }
  }
  long long v50 = [v96 uuid];
  BOOL v51 = v50 == 0;

  if (!v51)
  {
    long long v52 = [v96 uuid];
    id v53 = [v52 UUIDString];
    sub_10003ED78((std::string *)&v106, (char *)[v53 UTF8String]);
  }
  long long v54 = [v96 euuid];
  BOOL v55 = v54 == 0;

  if (!v55)
  {
    long long v56 = [v96 euuid];
    id v57 = [v56 UUIDString];
    sub_10003ED78((std::string *)((char *)&v107 + 8), (char *)[v57 UTF8String]);
  }
  long long v58 = [v96 localAddress];
  BOOL v59 = v58 == 0;

  if (!v59)
  {
    v101.__r_.__value_.__r.__words[0] = 0;
    BOOL v60 = [v96 localAddress];
    CFUUIDRef v61 = v60;
    v101.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
    if (v60) {
      CFRetain(v60);
    }

    sockaddrToString((uint64_t *)&v101, __p);
    if (SHIBYTE(v110[0]) < 0) {
      operator delete(v109[0]);
    }
    *(_OWORD *)BOOL v109 = *(_OWORD *)__p;
    v110[0] = v99;
    sub_100030068((const void **)&v101.__r_.__value_.__l.__data_);
  }
  BOOL v62 = [v96 remoteAddress];
  BOOL v63 = v62 == 0;

  if (!v63)
  {
    v101.__r_.__value_.__r.__words[0] = 0;
    BOOL v64 = [v96 remoteAddress];
    BOOL v65 = v64;
    v101.__r_.__value_.__r.__words[0] = (std::string::size_type)v64;
    if (v64) {
      CFRetain(v64);
    }

    sockaddrToString((uint64_t *)&v101, __p);
    if (SHIBYTE(v110[3]) < 0) {
      operator delete((void *)v110[1]);
    }
    *(_OWORD *)&v110[1] = *(_OWORD *)__p;
    v110[3] = v99;
    sub_1003C5CD0((const void **)&v111, (const void **)&v101.__r_.__value_.__l.__data_);
    sub_100030068((const void **)&v101.__r_.__value_.__l.__data_);
  }
  *((void *)&v111 + 1) = [v96 sourceIdentifier];
  unsigned int v66 = [v96 snapshotReason];
  memset(&__dst, 0, sizeof(__dst));
  if (SHIBYTE(v104[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, v104[1].__r_.__value_.__l.__data_, v104[1].__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = v104[1];
  }
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  if (!size) {
    std::string::operator=(&__dst, v104);
  }
  *(_OWORD *)std::string __p = 0u;
  long long v99 = 0u;
  sub_100A280FC((void **)&__dst.__r_.__value_.__l.__data_, (uint64_t)__p);
  if (BYTE8(v99))
  {
    std::string::operator=(&v104[1], (const std::string *)__p);
  }
  else
  {
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    BOOL v69 = (char *)sub_100A27E48((char *)p_dst);
    if (*v69) {
      sub_10003ED78(&v104[1], v69);
    }
  }
  if (BYTE8(v99) && SBYTE7(v99) < 0) {
    operator delete(__p[0]);
  }
  sub_100F3FF98((uint64_t)__p, (long long *)buf);
  BOOL v70 = *(std::__shared_weak_count **)(a1 + 56);
  if (v70)
  {
    BOOL v71 = std::__shared_weak_count::lock(v70);
    if (v71)
    {
      BOOL v72 = v71;
      uint64_t v73 = *(void *)(a1 + 48);
      if (v73) {
        (*(void (**)(uint64_t, void **, BOOL))(*(void *)v73 + 16))(v73, __p, v66 == 2);
      }
      sub_10004D2C8(v72);
    }
  }
  sub_10015E720((uint64_t)__p);
  std::string::size_type v74 = HIBYTE(v104[1].__r_.__value_.__r.__words[2]);
  if ((v104[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v74 = v104[1].__r_.__value_.__l.__size_;
  }
  if (v74 != 26) {
    goto LABEL_121;
  }
  uint64_t v75 = (v104[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? &v104[1]
      : (std::string *)v104[1].__r_.__value_.__r.__words[0];
  std::string::size_type v76 = v75->__r_.__value_.__r.__words[0];
  std::string::size_type v77 = v75->__r_.__value_.__l.__size_;
  std::string::size_type v78 = v75->__r_.__value_.__r.__words[2];
  int data_low = LOWORD(v75[1].__r_.__value_.__l.__data_);
  BOOL v80 = v76 == 0x6C7070612E6D6F63 && v77 == 0x7375617461642E65;
  BOOL v81 = v80 && v78 == 0x646469682E656761;
  if (v81 && data_low == 28261)
  {
    if ((*((unsigned char *)&v104[0].__r_.__value_.__s + 23) & 0x80) == 0)
    {
LABEL_138:
      std::string v97 = v104[0];
      goto LABEL_141;
    }
  }
  else
  {
LABEL_121:
    std::string::size_type v83 = HIBYTE(v104[0].__r_.__value_.__r.__words[2]);
    if ((v104[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v83 = v104[0].__r_.__value_.__l.__size_;
    }
    if (v83 != 26) {
      goto LABEL_152;
    }
    uint64_t v84 = (std::string *)v104[0].__r_.__value_.__r.__words[0];
    if ((v104[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v84 = v104;
    }
    std::string::size_type v85 = v84->__r_.__value_.__r.__words[0];
    std::string::size_type v86 = v84->__r_.__value_.__l.__size_;
    std::string::size_type v87 = v84->__r_.__value_.__r.__words[2];
    int v88 = LOWORD(v84[1].__r_.__value_.__l.__data_);
    BOOL v89 = v85 == 0x6C7070612E6D6F63 && v86 == 0x7375617461642E65;
    BOOL v90 = v89 && v87 == 0x646469682E656761;
    if (!v90 || v88 != 28261) {
      goto LABEL_152;
    }
    if ((*((unsigned char *)&v104[0].__r_.__value_.__s + 23) & 0x80) == 0) {
      goto LABEL_138;
    }
  }
  sub_10004FC84(&v97, v104[0].__r_.__value_.__l.__data_, v104[0].__r_.__value_.__l.__size_);
LABEL_141:
  uint64_t v92 = *(std::__shared_weak_count **)(a1 + 56);
  if (v92)
  {
    BOOL v93 = std::__shared_weak_count::lock(v92);
    if (v93)
    {
      BOOL v94 = v93;
      uint64_t v95 = *(void *)(a1 + 48);
      if (v95)
      {
        if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v101, v97.__r_.__value_.__l.__data_, v97.__r_.__value_.__l.__size_);
        }
        else {
          std::string v101 = v97;
        }
        (*(void (**)(uint64_t, std::string *))(*(void *)v95 + 32))(v95, &v101);
        if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v101.__r_.__value_.__l.__data_);
        }
      }
      sub_10004D2C8(v94);
    }
  }
  if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v97.__r_.__value_.__l.__data_);
  }
LABEL_152:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  sub_10015E720((uint64_t)buf);
LABEL_155:
}

void sub_100F3F9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,char a63)
{
  sub_10004D2C8(v64);
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  sub_10015E720((uint64_t)&a63);

  _Unwind_Resume(a1);
}

void sub_100F3FC08(uint64_t a1, int a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 80))(a1, 1);
  uint64_t v4 = *(int *)(a1 + 120);
  if ((v4 & 0x80000000) == 0 && a2 == v4)
  {
    BOOL v5 = *(void **)(a1 + 128);
    if (v5 != (void *)(a1 + 136))
    {
      do
      {
        if (*((_DWORD *)v5 + 10) == *(_DWORD *)(a1 + 120)) {
          NetworkUsageStrategy::updateTetheringDataUsage_sync((void *)a1, v5 + 4);
        }
        id v6 = (void *)v5[1];
        if (v6)
        {
          do
          {
            id v7 = v6;
            id v6 = (void *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            id v7 = (void *)v5[2];
            BOOL v8 = *v7 == (void)v5;
            BOOL v5 = v7;
          }
          while (!v8);
        }
        BOOL v5 = v7;
      }
      while (v7 != (void *)(a1 + 136));
    }
  }
}

void sub_100F3FCD4(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 176) refresh:0];
  if (v2)
  {
    unsigned int v3 = v2;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5[0] = 67109120;
      v5[1] = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Refreshing flows failed %d", (uint8_t *)v5, 8u);
    }
  }
}

id sub_100F3FD88(uint64_t a1)
{
  return [*(id *)(a1 + 176) dumpState];
}

void sub_100F3FD90(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = *(void (**)(void *, void))(*a1 + 16);
  uint64_t v3 = *(void *)(*a1 + 24);
  uint64_t v4 = (void *)(*(void *)*a1 + (v3 >> 1));
  if (v3) {
    unsigned int v2 = *(void (**)(void *, void))(*v4 + v2);
  }
  v2(v4, *(void *)(v1 + 32));
  sub_100F3FE40(v1);
}

void sub_100F3FE24()
{
  sub_100F3FE40(v0);
}

void sub_100F3FE40(uint64_t a1)
{
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void sub_100F3FE98(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = *(void (**)(void *, void))(*a1 + 16);
  uint64_t v3 = *(void *)(*a1 + 24);
  uint64_t v4 = (void *)(*(void *)*a1 + (v3 >> 1));
  if (v3) {
    unsigned int v2 = *(void (**)(void *, void))(*v4 + v2);
  }
  v2(v4, *(unsigned int *)(v1 + 32));
  sub_100F3FF48(v1);
}

void sub_100F3FF2C()
{
  sub_100F3FF48(v0);
}

void sub_100F3FF48(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_100F3FF98(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_OWORD *)(a1 + 27) = *(long long *)((char *)a2 + 27);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)(a1 + 48) = v6;
  }
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 72), *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 72);
    *(void *)(a1 + 88) = *((void *)a2 + 11);
    *(_OWORD *)(a1 + 72) = v7;
  }
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a2 + 96);
  if (*((char *)a2 + 127) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 104), *((void **)a2 + 13), *((void *)a2 + 14));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 104);
    *(void *)(a1 + 120) = *((void *)a2 + 15);
    *(_OWORD *)(a1 + 104) = v8;
  }
  if (*((char *)a2 + 151) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 128), *((void **)a2 + 16), *((void *)a2 + 17));
  }
  else
  {
    long long v9 = a2[8];
    *(void *)(a1 + 144) = *((void *)a2 + 18);
    *(_OWORD *)(a1 + 128) = v9;
  }
  if (*((char *)a2 + 175) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 152), *((void **)a2 + 19), *((void *)a2 + 20));
  }
  else
  {
    long long v10 = *(long long *)((char *)a2 + 152);
    *(void *)(a1 + 168) = *((void *)a2 + 21);
    *(_OWORD *)(a1 + 152) = v10;
  }
  uint64_t v11 = (unsigned char *)(a1 + 176);
  if (*((char *)a2 + 199) < 0)
  {
    sub_10004FC84(v11, *((void **)a2 + 22), *((void *)a2 + 23));
  }
  else
  {
    long long v12 = a2[11];
    *(void *)(a1 + 192) = *((void *)a2 + 24);
    *(_OWORD *)uint64_t v11 = v12;
  }
  *(unsigned char *)(a1 + 200) = *((unsigned char *)a2 + 200);
  sub_10002FD9C((const void **)(a1 + 208), (const void **)a2 + 26);
  *(void *)(a1 + 216) = *((void *)a2 + 27);
  return a1;
}

void sub_100F40128(_Unwind_Exception *exception_object)
{
  if (v1[175] < 0) {
    operator delete(*v6);
  }
  if (v1[151] < 0) {
    operator delete(*v5);
  }
  if (v1[127] < 0) {
    operator delete(*v4);
  }
  if (v1[95] < 0) {
    operator delete(*v3);
  }
  if (v1[71] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F401A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A71708;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F401C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A71708;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F40218(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100F4022C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F4058C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, uint64_t a11, dispatch_object_t a12, dispatch_object_t a13, void *__p, std::__shared_weak_count *a15, int a16, __int16 a17, char a18, char a19)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_100F40700(void *a1)
{
  *a1 = off_101A71758;
  unsigned int v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  long long v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  AudioRoutingInterface::~AudioRoutingInterface((AudioRoutingInterface *)a1);
}

void sub_100F4078C(void *a1)
{
  sub_100F40700(a1);

  operator delete();
}

void sub_100F407C4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  long long v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F408C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F409B8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F40AA8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F40BA8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F40C98(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F40D88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F40E88(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F40F7C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 97)) {
      uint64_t v3 = "true";
    }
    else {
      uint64_t v3 = "false";
    }
    int v5 = 136315138;
    long long v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Voice mute: %s", (uint8_t *)&v5, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 96)) {
      long long v4 = "true";
    }
    else {
      long long v4 = "false";
    }
    int v5 = 136315138;
    long long v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I TTY enabled: %s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100F410CC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F41104(uint64_t a1)
{
}

uint64_t sub_100F41120(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F41164(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F41190(ServiceManager::Service *this)
{
  *(void *)this = off_101A71920;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F411EC(ServiceManager::Service *this)
{
  *(void *)this = off_101A71920;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F4125C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "AudioRoutingController");
}

unsigned char *sub_100F4126C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 3;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F412AC(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F407C4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F407C4(v4, 0);
}

uint64_t sub_100F41330()
{
  return 0;
}

uint64_t sub_100F41338()
{
  return 1;
}

uint64_t sub_100F41340()
{
  return 0;
}

void sub_100F4134C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4142C(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100F41540(void **a1)
{
  uint64_t v1 = *a1;
  long long v7 = a1;
  long long v8 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 80);
  int v5 = v1[1];
  *(void *)uint64_t buf = v5;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 24))(v4, buf);
  if (*(void *)buf)
  {
    dispatch_group_leave(*(dispatch_group_t *)buf);
    if (*(void *)buf) {
      dispatch_release(*(dispatch_object_t *)buf);
    }
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 64));
  sub_100088C88((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100F41630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
}

uint64_t *sub_100F4166C(void **a1)
{
  uint64_t v1 = *a1;
  signed int v13 = a1;
  BOOL v14 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v4 || (v5 = *(void *)(v2 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  long long v7 = v6;
  long long v8 = (std::__shared_weak_count *)operator new(0x30uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_101A719A0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A71A48;
  v8[1].__shared_owners_ = v5;
  v8[1].__shared_weak_owners_ = (uint64_t)v7;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)off_101A719F0;
  uint64_t v9 = *(void *)(v2 + 80);
  long long v10 = v1[1];
  dispatch_group_t group = v10;
  if (v10)
  {
    dispatch_retain(v10);
    dispatch_group_enter(v10);
  }
  xpc_object_t v19 = xpc_null_create();
  xpc_object_t object = xpc_null_create();
  __int16 v17 = v8 + 1;
  char v18 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  (*(void (**)(uint64_t, dispatch_group_t *, xpc_object_t *, std::__shared_weak_count **))(*(void *)v9 + 32))(v9, &group, &v19, &v17);
  if (v18) {
    sub_10004D2C8(v18);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  Registry::createRestModuleOneTimeUseConnection(&v15, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_100058DB0(&__p, "/cc/events/dump_state");
  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = off_101A71A70;
  v11[1] = v2;
  dispatch_object_t v11[2] = sub_100F40F7C;
  void v11[3] = 0;
  uint64_t v25 = v11;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v23 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v8);
  sub_100088C88((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100F41918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, xpc_object_t object, dispatch_group_t group, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24)
{
  sub_10003F600(&a24);
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v24);
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100F419F4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A719A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F41A14(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A719A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100F41A68(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100F41A90(AudioRoutingCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A71A48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  AudioRoutingCommandDriverDelegateInterface::~AudioRoutingCommandDriverDelegateInterface(this);
}

void sub_100F41AEC(AudioRoutingCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A71A48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  AudioRoutingCommandDriverDelegateInterface::~AudioRoutingCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_100F41B5C(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      long long v6 = v5;
      uint64_t v7 = *(void *)(a1 + 8);
      if (v7)
      {
        long long v8 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = "is not";
          if (a2) {
            uint64_t v9 = "is";
          }
          int v10 = 136315138;
          uint64_t v11 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Driver %s ready", (uint8_t *)&v10, 0xCu);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100F41C78(AudioRoutingCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A71A48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  AudioRoutingCommandDriverDelegateInterface::~AudioRoutingCommandDriverDelegateInterface(this);
}

void sub_100F41CD4(AudioRoutingCommandDriverDelegateInterface *this)
{
  *(void *)this = off_101A71A48;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  AudioRoutingCommandDriverDelegateInterface::~AudioRoutingCommandDriverDelegateInterface(this);

  operator delete();
}

void sub_100F41D48()
{
}

__n128 sub_100F41D5C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A71A70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F41DB0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A71A70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F41DE8(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F41E30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F41E70()
{
}

void sub_100F41E7C(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 80) + 16))(*(void *)(v1 + 80));
  operator delete();
}

void sub_100F41F38()
{
}

void sub_100F41F64(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 80) + 40))(*(void *)(**(void **)a1 + 80), *(unsigned int *)(*(void *)a1 + 8), *(unsigned int *)(*(void *)a1 + 12));
  operator delete();
}

void sub_100F41FE0()
{
}

void sub_100F4200C(BOOL **a1)
{
  long long v8 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = *((void *)*a1 + 1);
  *(unsigned char *)(v2 + 96) = **a1;
  (*(void (**)(void))(**(void **)(v2 + 80) + 48))(*(void *)(v2 + 80));
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v13 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v13 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v13 = v5;
LABEL_9:
  xpc_release(v4);
  xpc_object_t object = xpc_BOOL_create(*v1);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v14 = 0uLL;
  uint64_t v15 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v10 = 0;
  v11[0] = &v13;
  v11[1] = __p;
  sub_100035E70((uint64_t)v11, &object, (xpc_object_t *)&v14);
  xpc_release((xpc_object_t)v14);
  *(void *)&long long v14 = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_object_t v6 = v13;
  __p[0] = v13;
  if (v13)
  {
    xpc_retain(v13);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    __p[0] = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  v11[0] = v7;
  sub_1000452AC(81, __p, v11);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(v13);
  operator delete();
}

void sub_100F42210(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object)
{
  xpc_release(v17);
  xpc_release(v18);
  xpc_release(object);
  operator delete();
}

void sub_100F422B4(uint64_t *a1)
{
  xpc_object_t v3 = a1;
  uint64_t v1 = *a1;
  xpc_object_t object = xpc_BOOL_create(*(unsigned char *)(*(void *)*a1 + 96));
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  v4[0] = *(void *)(v1 + 8);
  v4[1] = "kAudioBoolean";
  sub_100035E70((uint64_t)v4, &object, &v6);
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(object);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

void sub_100F4236C(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void))(**(void **)(**(void **)a1 + 80) + 56))(*(void *)(**(void **)a1 + 80), *(unsigned __int8 *)(*(void *)a1 + 8));
  operator delete();
}

void sub_100F423E8()
{
}

void sub_100F42414(BOOL **a1)
{
  long long v8 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = *((void *)*a1 + 1);
  *(unsigned char *)(v2 + 97) = **a1;
  (*(void (**)(void))(**(void **)(v2 + 80) + 64))(*(void *)(v2 + 80));
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v4 = v3;
  if (v3)
  {
    xpc_object_t v13 = v3;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v13 = v4;
    if (!v4)
    {
      xpc_object_t v5 = xpc_null_create();
      xpc_object_t v4 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v4);
    goto LABEL_9;
  }
  xpc_object_t v5 = xpc_null_create();
LABEL_8:
  xpc_object_t v13 = v5;
LABEL_9:
  xpc_release(v4);
  xpc_object_t object = xpc_BOOL_create(*v1);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  long long v14 = 0uLL;
  uint64_t v15 = 0;
  ctu::cf::assign();
  *(_OWORD *)std::string __p = 0uLL;
  uint64_t v10 = 0;
  v11[0] = &v13;
  v11[1] = __p;
  sub_100035E70((uint64_t)v11, &object, (xpc_object_t *)&v14);
  xpc_release((xpc_object_t)v14);
  *(void *)&long long v14 = 0;
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_object_t v6 = v13;
  __p[0] = v13;
  if (v13)
  {
    xpc_retain(v13);
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    __p[0] = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  v11[0] = v7;
  sub_1000452AC(80, __p, v11);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(v13);
  operator delete();
}

void sub_100F42618(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object)
{
  xpc_release(v17);
  xpc_release(v18);
  xpc_release(object);
  operator delete();
}

void sub_100F426BC(uint64_t *a1)
{
  xpc_object_t v3 = a1;
  uint64_t v1 = *a1;
  xpc_object_t object = xpc_BOOL_create(*(unsigned char *)(*(void *)*a1 + 97));
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  v4[0] = *(void *)(v1 + 8);
  v4[1] = "kAudioMuteState";
  sub_100035E70((uint64_t)v4, &object, &v6);
  xpc_release(v6);
  xpc_object_t v6 = 0;
  xpc_release(object);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

void sub_100F42774(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void))(**(void **)(**(void **)a1 + 80) + 72))(*(void *)(**(void **)a1 + 80), *(unsigned int *)(*(void *)a1 + 8), *(unsigned int *)(*(void *)a1 + 12));
  operator delete();
}

void sub_100F427F0()
{
}

void MaxDataRateManager::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100F43840(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,dispatch_object_t object,dispatch_object_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  sub_10008863C((void *)(v32 - 128));
  operator delete();
}

const char *sub_100F43CF0(int a1)
{
  uint64_t v1 = "max.?";
  if (a1 == 2) {
    uint64_t v1 = "max.2";
  }
  if (a1 == 1) {
    return "max.1";
  }
  else {
    return v1;
  }
}

void sub_100F43D1C(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F43E1C(uint64_t a1, xpc_object_t object, dispatch_object_t *a3)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  xpc_object_t v5 = *a3;
  if (*a3)
  {
    dispatch_retain(*a3);
    dispatch_group_enter(v5);
  }
  xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F43F5C(uint64_t a1)
{
  *(void *)a1 = off_101A71AF0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 520);
  if (v2) {
    sub_10004D2C8(v2);
  }
  xpc_object_t v3 = *(std::__shared_weak_count **)(a1 + 504);
  if (v3) {
    sub_10004D2C8(v3);
  }
  xpc_object_t v4 = *(std::__shared_weak_count **)(a1 + 488);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 472);
  *(void *)(a1 + 472) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  xpc_object_t v6 = *(std::__shared_weak_count **)(a1 + 464);
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100119D90(*(void **)(a1 + 440));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 264));
  sub_1000346F8(a1 + 240, *(void **)(a1 + 248));
  sub_1000346F8(a1 + 216, *(void **)(a1 + 224));
  sub_1000346F8(a1 + 192, *(void **)(a1 + 200));
  sub_10019D5B8(a1 + 160, *(void **)(a1 + 168));
  sub_100087F94(a1 + 128, *(void **)(a1 + 136));
  sub_1000346F8(a1 + 104, *(void **)(a1 + 112));
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 96);
  if (v7) {
    sub_10004D2C8(v7);
  }
  long long v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 64);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  MaxDataRateInterface::~MaxDataRateInterface((MaxDataRateInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100F440C8(uint64_t a1)
{
  sub_100F43F5C(a1);

  operator delete();
}

BOOL sub_100F44100(uint64_t a1, uint64_t a2, const __CFString **a3, BOOL *a4)
{
  xpc_object_t v7 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long v8 = (os_log_t *)v7;
  if (a3)
  {
    if (capabilities::ct::supportsGemini(v7))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 56));
      uint64_t v11 = ServiceMap;
      if (v12 < 0)
      {
        xpc_object_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v12;
      int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)__p);
      if (v16)
      {
        uint64_t v18 = v16[3];
        __int16 v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          if (!v18)
          {
LABEL_9:
            unsigned int v20 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_FAULT))
            {
              LOWORD(__p[0]) = 0;
              _os_log_fault_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "PersonalWallet interface not available", (uint8_t *)__p, 2u);
            }
            BOOL v21 = 0;
LABEL_37:
            if ((v19 & 1) == 0) {
              sub_10004D2C8(v17);
            }
            return v21;
          }
LABEL_19:
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v36 = 0;
          PersonalityIdFromSlotId();
          if (isReal())
          {
            BOOL v37 = 0;
            id v38 = 0;
            if (ctu::cf::convert_copy((ctu::cf *)&v38, a3, (const char *)0x8000100, kCFAllocatorDefault, v24))
            {
              uint64_t v25 = v37;
              BOOL v37 = v38;
              cf[0] = v25;
              sub_1000558F4(cf);
            }
            unsigned int v26 = v37;
            uint64_t v34 = v37;
            BOOL v37 = 0;
            sub_1000558F4(&v37);
            cf[0] = 0;
            (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **, const void *, const __CFString *, void, uint64_t))(*(void *)v18 + 64))(cf, v18, __p, v26, @"MaxDataRate", 0, 1);
            CFIndex v27 = (BOOL *)cf[0];
            if (cf[0]) {
              uint64_t v28 = sub_100080934;
            }
            else {
              uint64_t v28 = 0;
            }
            BOOL v21 = v28 != 0;
            if (v28)
            {
              LOBYTE(v38) = 0;
              if (cf[0] && (CFTypeID v29 = CFGetTypeID(cf[0]), v29 == CFBooleanGetTypeID()))
              {
                ctu::cf::assign((ctu::cf *)&v38, v27, v30);
                char v31 = (char)v38;
              }
              else
              {
                char v31 = 0;
              }
              *a4 = v31;
            }
            sub_1000577C4(cf);
            sub_1000558F4(&v34);
          }
          else
          {
            uint64_t v32 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
            {
              LOWORD(cf[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Personality unknown", (uint8_t *)cf, 2u);
            }
            BOOL v21 = 0;
          }
          if (SHIBYTE(v36) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_37;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      __int16 v17 = 0;
      char v19 = 1;
      if (!v18) {
        goto LABEL_9;
      }
      goto LABEL_19;
    }
    uint64_t v23 = sub_100365D74();
    sub_100058DB0(__p, (char *)a3);
    BOOL v21 = sub_1002260B0(v23, __p, a4);
    if (SHIBYTE(v36) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    unint64_t v22 = *(NSObject **)v7;
    if (os_log_type_enabled(*(os_log_t *)v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid key", (uint8_t *)__p, 2u);
    }
    return 0;
  }
  return v21;
}

void sub_100F4448C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, const void *a20)
{
  sub_1000577C4(&a20);
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_100F44504(uint64_t a1, uint64_t a2, const __CFString **a3)
{
  uint64_t v5 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  xpc_object_t v6 = (os_log_t *)v5;
  if (a3)
  {
    if (capabilities::ct::supportsGemini(v5))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 56));
      uint64_t v9 = ServiceMap;
      if (v10 < 0)
      {
        uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__p);
      if (v14)
      {
        uint64_t v16 = v14[3];
        unsigned int v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
          if (!v16)
          {
LABEL_9:
            uint64_t v18 = *v6;
            if (os_log_type_enabled(*v6, OS_LOG_TYPE_FAULT))
            {
              LOWORD(__p[0]) = 0;
              _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "PersonalWallet interface not available", (uint8_t *)__p, 2u);
            }
            char v19 = 0;
LABEL_37:
            if ((v17 & 1) == 0) {
              sub_10004D2C8(v15);
            }
            return v19;
          }
LABEL_20:
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v32 = 0;
          PersonalityIdFromSlotId();
          if ((isReal() & 1) == 0)
          {
            uint64_t v28 = *v6;
            if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
            {
              LOWORD(cf[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Personality unknown", (uint8_t *)cf, 2u);
            }
            char v19 = 0;
            goto LABEL_35;
          }
          id v33 = 0;
          uint64_t v34 = 0;
          if (ctu::cf::convert_copy((ctu::cf *)&v34, a3, (const char *)0x8000100, kCFAllocatorDefault, v22))
          {
            uint64_t v23 = v33;
            id v33 = v34;
            cf[0] = v23;
            sub_1000558F4(cf);
          }
          CFAllocatorRef v24 = v33;
          CFBooleanRef v30 = v33;
          id v33 = 0;
          sub_1000558F4(&v33);
          cf[0] = 0;
          (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **, const void *, const __CFString *, void, uint64_t))(*(void *)v16 + 64))(cf, v16, __p, v24, @"MaxDataRate", 0, 1);
          char v19 = (unsigned __int8 *)cf[0];
          if (cf[0]) {
            uint64_t v25 = sub_100080934;
          }
          else {
            uint64_t v25 = 0;
          }
          if (v25)
          {
            LOBYTE(v34) = 0;
            if (!cf[0])
            {
LABEL_34:
              sub_1000577C4(cf);
              sub_1000558F4(&v30);
LABEL_35:
              if (SHIBYTE(v32) < 0) {
                operator delete(__p[0]);
              }
              goto LABEL_37;
            }
            CFTypeID v26 = CFGetTypeID(cf[0]);
            if (v26 == CFNumberGetTypeID())
            {
              ctu::cf::assign((ctu::cf *)&v34, v19, v27);
              char v19 = (unsigned __int8 *)v34;
              goto LABEL_34;
            }
          }
          char v19 = 0;
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      unsigned int v15 = 0;
      char v17 = 1;
      if (!v16) {
        goto LABEL_9;
      }
      goto LABEL_20;
    }
    LOBYTE(cf[0]) = 0;
    uint64_t v21 = sub_100365D74();
    sub_100058DB0(__p, (char *)a3);
    sub_100F448FC(v21, __p, cf);
    if (SHIBYTE(v32) < 0) {
      operator delete(__p[0]);
    }
    return (unsigned __int8 *)LOBYTE(cf[0]);
  }
  else
  {
    unsigned int v20 = *(NSObject **)v5;
    if (os_log_type_enabled(*(os_log_t *)v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Invalid key", (uint8_t *)__p, 2u);
    }
    return 0;
  }
}

void sub_100F44884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, const void *a20)
{
  sub_1000577C4(&a20);
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100F448FC(uint64_t a1, void **a2, unsigned char *a3)
{
  std::mutex::lock(&stru_101B09FA8);
  memset(&v11, 0, sizeof(v11));
  xpc_object_t v6 = sub_100046F68(a1, a2);
  xpc_object_t v7 = v6;
  long long v8 = (void **)(a1 + 8);
  if (v8 != v6)
  {
    std::string::operator=(&v11, (const std::string *)(v6 + 7));
    if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v9 = &v11;
    }
    else {
      uint64_t v9 = (std::string *)v11.__r_.__value_.__r.__words[0];
    }
    *a3 = strtoll((const char *)v9, 0, 16);
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  std::mutex::unlock(&stru_101B09FA8);
  return v8 != v7;
}

void sub_100F449BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(&stru_101B09FA8);
  _Unwind_Resume(a1);
}

void sub_100F449E4(uint64_t a1, uint64_t a2, const __CFString **a3, unsigned int a4)
{
  xpc_object_t v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long v8 = v7;
  if (a3)
  {
    uint64_t v9 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 512) + 160))(*(void *)(a1 + 512));
    if (capabilities::ct::supportsGemini(v9))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 56));
      uint64_t v12 = ServiceMap;
      if ((v13 & 0x8000000000000000) != 0)
      {
        uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          std::string::size_type v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      buf.__r_.__value_.__r.__words[0] = v13;
      char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&buf);
      if (v17)
      {
        uint64_t v19 = v17[3];
        uint64_t v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
          if (!v19) {
            goto LABEL_9;
          }
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      uint64_t v18 = 0;
      char v20 = 1;
      if (!v19)
      {
LABEL_9:
        char v21 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_FAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "PersonalWallet interface not available", (uint8_t *)&buf, 2u);
        }
LABEL_29:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        return;
      }
LABEL_17:
      std::string __p = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      PersonalityIdFromSlotId();
      if (isReal())
      {
        CFNumberRef v42 = 0;
        CFNumberRef v43 = 0;
        if (ctu::cf::convert_copy((ctu::cf *)&v43, a3, (const char *)0x8000100, kCFAllocatorDefault, v24))
        {
          std::string::size_type v25 = (std::string::size_type)v42;
          CFNumberRef v42 = v43;
          buf.__r_.__value_.__r.__words[0] = v25;
          sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
        }
        CFNumberRef v38 = v42;
        CFNumberRef v42 = 0;
        sub_1000558F4((const void **)&v42);
        CFNumberRef v43 = 0;
        buf.__r_.__value_.__r.__words[0] = a4;
        CFNumberRef v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &buf);
        if (v26)
        {
          std::string::size_type v27 = (std::string::size_type)v43;
          CFNumberRef v43 = v26;
          buf.__r_.__value_.__r.__words[0] = v27;
          sub_1000570E8((const void **)&buf.__r_.__value_.__l.__data_);
        }
        CFNumberRef v28 = v43;
        CFNumberRef v42 = v43;
        CFNumberRef v43 = 0;
        sub_1000570E8((const void **)&v43);
        if ((*(unsigned int (**)(uint64_t, void **, CFNumberRef, CFNumberRef, const __CFString *, void, uint64_t, void))(*(void *)v19 + 48))(v19, &__p, v38, v28, @"MaxDataRate", 0, 1, 0))
        {
          CFTypeID v29 = *v8;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            uint64_t v31 = HIBYTE(v41);
            uint64_t v32 = (void **)__p;
            uint64_t v33 = v40;
            uint64_t v34 = asString();
            if ((v31 & 0x80u) == 0) {
              uint64_t v35 = v31;
            }
            else {
              uint64_t v35 = v33;
            }
            uint64_t p_p = &__p;
            if ((v31 & 0x80u) != 0) {
              uint64_t p_p = v32;
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            if (v35) {
              BOOL v37 = (const char *)p_p;
            }
            else {
              BOOL v37 = "<invalid>";
            }
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v37;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a3;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
            uint64_t v45 = v34;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%s : failed to store %s : %s", (uint8_t *)&buf, 0x20u);
          }
        }
        sub_1000570E8((const void **)&v42);
        sub_1000558F4((const void **)&v38);
      }
      else
      {
        CFBooleanRef v30 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Personality unknown", (uint8_t *)&buf, 2u);
        }
      }
      if (SHIBYTE(v41) < 0) {
        operator delete(__p);
      }
      goto LABEL_29;
    }
    uint64_t v23 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&buf, (char *)a3);
    LOBYTE(__p) = a4;
    sub_100571BC4(v23, &buf, (unsigned __int8 *)&__p);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    CFAllocatorRef v22 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid key", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_100F44E20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_1000570E8(&a16);
  sub_1000558F4((const void **)&a9);
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(a1);
}

void sub_100F44EB8(uint64_t a1, uint64_t a2, const __CFString **a3, int a4)
{
  unsigned __int8 v38 = a4;
  xpc_object_t v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  long long v8 = v7;
  if (a3)
  {
    uint64_t v9 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 512) + 160))(*(void *)(a1 + 512));
    if (capabilities::ct::supportsGemini(v9))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 56));
      uint64_t v12 = ServiceMap;
      if ((v13 & 0x8000000000000000) != 0)
      {
        uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          std::string::size_type v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      buf.__r_.__value_.__r.__words[0] = v13;
      char v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)&buf);
      if (v17)
      {
        uint64_t v19 = v17[3];
        uint64_t v18 = (std::__shared_weak_count *)v17[4];
        if (v18)
        {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v18);
          char v20 = 0;
          if (!v19) {
            goto LABEL_9;
          }
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v12);
      uint64_t v18 = 0;
      char v20 = 1;
      if (!v19)
      {
LABEL_9:
        char v21 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_FAULT))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "PersonalWallet interface not available", (uint8_t *)&buf, 2u);
        }
LABEL_29:
        if ((v20 & 1) == 0) {
          sub_10004D2C8(v18);
        }
        return;
      }
LABEL_17:
      std::string __p = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      PersonalityIdFromSlotId();
      if (isReal())
      {
        CFBooleanRef v39 = 0;
        CFBooleanRef v40 = 0;
        if (ctu::cf::convert_copy((ctu::cf *)&v40, a3, (const char *)0x8000100, kCFAllocatorDefault, v24))
        {
          std::string::size_type v25 = (std::string::size_type)v39;
          CFBooleanRef v39 = v40;
          buf.__r_.__value_.__r.__words[0] = v25;
          sub_1000558F4((const void **)&buf.__r_.__value_.__l.__data_);
        }
        CFBooleanRef v26 = v39;
        CFBooleanRef v34 = v39;
        CFBooleanRef v39 = 0;
        sub_1000558F4((const void **)&v39);
        std::string::size_type v27 = &kCFBooleanTrue;
        if (!a4) {
          std::string::size_type v27 = &kCFBooleanFalse;
        }
        CFBooleanRef v28 = *v27;
        buf.__r_.__value_.__r.__words[0] = 0;
        sub_100062778((const void **)&buf.__r_.__value_.__l.__data_);
        CFBooleanRef v40 = v28;
        buf.__r_.__value_.__r.__words[0] = 0;
        sub_100062778((const void **)&buf.__r_.__value_.__l.__data_);
        if ((*(unsigned int (**)(uint64_t, void **, CFBooleanRef, CFBooleanRef, const __CFString *, void, uint64_t, void))(*(void *)v19 + 48))(v19, &__p, v26, v28, @"MaxDataRate", 0, 1, 0))
        {
          CFTypeID v29 = *v8;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            uint64_t p_p = (const char *)__p;
            uint64_t v32 = v36;
            if (v37 >= 0)
            {
              uint64_t v32 = HIBYTE(v37);
              uint64_t p_p = (const char *)&__p;
            }
            if (!v32) {
              uint64_t p_p = "<invalid>";
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            if (v38) {
              uint64_t v33 = "true";
            }
            else {
              uint64_t v33 = "false";
            }
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a3;
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
            CFNumberRef v42 = v33;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%s : failed to store %s : %s", (uint8_t *)&buf, 0x20u);
          }
        }
        sub_100062778((const void **)&v40);
        sub_1000558F4((const void **)&v34);
      }
      else
      {
        CFBooleanRef v30 = *v8;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Personality unknown", (uint8_t *)&buf, 2u);
        }
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(__p);
      }
      goto LABEL_29;
    }
    uint64_t v23 = (uint64_t **)sub_100365D74();
    sub_100058DB0(&buf, (char *)a3);
    sub_1002264FC(v23, &buf, &v38);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    CFAllocatorRef v22 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid key", (uint8_t *)&buf, 2u);
    }
  }
}

void sub_100F452FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  sub_100062778(&a20);
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(a1);
}

void sub_100F45384(uint64_t a1, uint64_t a2, const __CFString **a3)
{
  uint64_t v5 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  xpc_object_t v6 = (os_log_t *)v5;
  if (a3)
  {
    if (capabilities::ct::supportsGemini(v5))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 56));
      uint64_t v9 = ServiceMap;
      if (v10 < 0)
      {
        std::string v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v12 = 5381;
        do
        {
          uint64_t v10 = v12;
          unsigned int v13 = *v11++;
          uint64_t v12 = (33 * v12) ^ v13;
        }
        while (v13);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v10;
      uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
      if (v14)
      {
        uint64_t v16 = v14[3];
        uint64_t v15 = (std::__shared_weak_count *)v14[4];
        if (v15)
        {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v9);
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v15);
          char v17 = 0;
          if (!v16) {
            goto LABEL_9;
          }
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v16 = 0;
      }
      std::mutex::unlock(v9);
      uint64_t v15 = 0;
      char v17 = 1;
      if (!v16)
      {
LABEL_9:
        uint64_t v18 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "PersonalWallet interface not available", buf, 2u);
        }
LABEL_36:
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        return;
      }
LABEL_17:
      *(void *)std::string buf = 0;
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      PersonalityIdFromSlotId();
      if (isReal())
      {
        uint64_t v37 = 0;
        unsigned __int8 v38 = 0;
        if (ctu::cf::convert_copy((ctu::cf *)&v38, a3, (const char *)0x8000100, kCFAllocatorDefault, v21))
        {
          CFAllocatorRef v22 = v37;
          uint64_t v37 = v38;
          *(void *)CFBooleanRef v39 = v22;
          sub_1000558F4((const void **)v39);
        }
        uint64_t v23 = v37;
        uint64_t v33 = v37;
        uint64_t v37 = 0;
        sub_1000558F4(&v37);
        CFAllocatorRef v24 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = HIBYTE(v36);
          if (v36 < 0) {
            uint64_t v25 = v35;
          }
          CFBooleanRef v26 = buf;
          if (v36 < 0) {
            CFBooleanRef v26 = *(uint8_t **)buf;
          }
          if (v25) {
            char v27 = (const char *)v26;
          }
          else {
            char v27 = "<invalid>";
          }
          *(_DWORD *)CFBooleanRef v39 = 136315394;
          *(void *)&v39[4] = v27;
          __int16 v40 = 2080;
          uint64_t v41 = a3;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s : remove key : %s", v39, 0x16u);
        }
        if ((*(unsigned int (**)(uint64_t, uint8_t *, const void *, const __CFString *, void, uint64_t))(*(void *)v16 + 72))(v16, buf, v23, @"MaxDataRate", 0, 1))
        {
          CFBooleanRef v28 = *v6;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            uint64_t v30 = HIBYTE(v36);
            if (v36 < 0) {
              uint64_t v30 = v35;
            }
            uint64_t v31 = buf;
            if (v36 < 0) {
              uint64_t v31 = *(uint8_t **)buf;
            }
            if (v30) {
              uint64_t v32 = (const char *)v31;
            }
            else {
              uint64_t v32 = "<invalid>";
            }
            *(_DWORD *)CFBooleanRef v39 = 136315394;
            *(void *)&v39[4] = v32;
            __int16 v40 = 2080;
            uint64_t v41 = a3;
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%s : failed to remove key : %s", v39, 0x16u);
          }
        }
        sub_1000558F4(&v33);
      }
      else
      {
        CFTypeID v29 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CFBooleanRef v39 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Personality unknown", v39, 2u);
        }
      }
      if (SHIBYTE(v36) < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_36;
    }
    char v20 = (uint64_t **)sub_100365D74();
    sub_100058DB0(buf, (char *)a3);
    sub_1003660FC(v20, (void **)buf);
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    uint64_t v19 = *(NSObject **)v5;
    if (os_log_type_enabled(*(os_log_t *)v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid key", buf, 2u);
    }
  }
}

void sub_100F457AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  sub_1000558F4(&a10);
  if (a16 < 0) {
    operator delete(__p);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

const void **sub_100F4582C(uint64_t a1, const char *a2)
{
  CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  (*(void (**)(void, CFStringRef, void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 72) + 16))(*(void *)(a1 + 72), v4, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 72)
                                                                                           + 48))(*(void *)(a1 + 72), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  return sub_1000558F4((const void **)&v4);
}

void sub_100F45910(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100F45924(uint64_t a1, int a2, char *a3)
{
  if ((a2 - 1) >= 2)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    return;
  }
  uint64_t v19 = 0;
  char v20 = 0;
  sub_10119BFD8(a2, 0, &v19);
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v5 = v19;
  uint64_t v16 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 40))(v19);
  sub_100F4DC88(__p, "Enable5G", &v16);
  uint64_t v15 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
  sub_100F4DC88(v23, "EnableLTE", &v15);
  uint64_t v14 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 56))(v5);
  sub_100F4DC88(v24, "Enable3G", &v14);
  unsigned int v13 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  sub_100F4DC88(v25, "Enable5GSwitchSupport", &v13);
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5);
  sub_100F4DC88(v26, "EnableLTESwitchSupport", &v12);
  std::string v11 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
  sub_100F4DC88(v27, "Enable3GSwitchSupport", &v11);
  sub_100343A10((uint64_t)v17, (unsigned __int8 *)__p, 6);
  uint64_t v6 = 36;
  do
  {
    xpc_object_t v7 = &__p[v6];
    if (SHIBYTE(__p[v6 - 1]) < 0) {
      operator delete(*(v7 - 3));
    }
    if (*((char *)v7 - 25) < 0) {
      operator delete(*(v7 - 6));
    }
    v6 -= 6;
  }
  while (v6 * 8);
  sub_100058DB0(__p, a3);
  long long v8 = sub_1003DF000(v17, (unsigned __int8 *)__p);
  uint64_t v9 = v8;
  if (v22 < 0)
  {
    operator delete(__p[0]);
    if (v9)
    {
LABEL_10:
      if ((char)v9[63] < 0)
      {
        sub_10004FC84((unsigned char *)a1, *((void **)v9 + 5), *((void *)v9 + 6));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 40);
        *(void *)(a1 + 16) = *((void *)v9 + 7);
        *(_OWORD *)a1 = v10;
      }
      goto LABEL_16;
    }
  }
  else if (v8)
  {
    goto LABEL_10;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
LABEL_16:
  sub_100343DF4((uint64_t)v17);
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_100F45C34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(a1);
}

void sub_100F45CEC(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  xpc_object_t v3 = v19;
  uint64_t v2 = v20;
  if (v19 != v20)
  {
    CFStringRef v4 = v21;
    while ((v21(*v3) & 1) == 0)
    {
      if (++v3 == v20)
      {
        xpc_object_t v3 = v20;
        break;
      }
    }
    uint64_t v5 = v20;
    while (v3 != v5)
    {
      uint64_t v6 = *v3;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      MaxDataRateManager::getModel_sync(a1, v6, &v17);
      uint64_t v7 = v17;
      if (v17)
      {
        uint64_t v8 = *(void *)(v17 + 168);
        if (v8) {
          LOBYTE(v8) = sub_100F56180(v8, *(void *)(v17 + 128));
        }
        *(unsigned char *)(v7 + 136) = v8;
        uint64_t v9 = *(void *)(v7 + 48);
        if (v9) {
          LOBYTE(v9) = sub_100F56180(v9, *(void *)(v7 + 8));
        }
        *(unsigned char *)(v7 + 16) = v9;
        uint64_t v10 = *(void *)(v7 + 288);
        if (v10) {
          LOBYTE(v10) = sub_100F56180(v10, *(void *)(v7 + 248));
        }
        *(unsigned char *)(v7 + 256) = v10;
        std::string v11 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
        uint64_t v12 = *v11;
        if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v23 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I 3G Switch support retrieved: %s", buf, 0xCu);
          uint64_t v12 = *v11;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v23 = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I LTE Switch support retrieved: %s", buf, 0xCu);
          uint64_t v12 = *v11;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = asString();
          *(_DWORD *)std::string buf = 136315138;
          uint64_t v23 = v15;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I 5G Switch support retrieved: %s", buf, 0xCu);
        }
      }
      if (v18) {
        sub_10004D2C8(v18);
      }
      uint64_t v16 = v3 + 1;
      xpc_object_t v3 = v2;
      if (v16 != v2)
      {
        xpc_object_t v3 = v16;
        while ((v4(*v3) & 1) == 0)
        {
          if (++v3 == v2)
          {
            xpc_object_t v3 = v2;
            break;
          }
        }
      }
    }
  }
}

void sub_100F45F68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MaxDataRateManager::getModel_sync@<X0>(uint64_t result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 440);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = result + 440;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != result + 440 && *(_DWORD *)(v4 + 32) <= a2)
  {
    uint64_t v9 = *(void *)(v4 + 40);
    uint64_t v8 = *(void *)(v4 + 48);
    *a3 = v9;
    a3[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

BOOL sub_100F45FFC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (sub_100F494CC(a1, a2) == 2 && sub_100F48FE4(a1, a2) == 2)
  {
    uint64_t v10 = *v8;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I 3G and LTE switches are supported", buf, 2u);
    }
    std::string v11 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    uint64_t v63 = 0;
    BOOL v64 = 0;
    MaxDataRateManager::getModel_sync(a1, a2, &v63);
    uint64_t v12 = v63;
    BOOL v13 = v63 != 0;
    if (v63)
    {
      v62[1] = 0;
      RatSelectionType::RatSelectionType();
      uint64_t v14 = off_101A730B8;
      v73[0] = off_101A730B8;
      v73[1] = a1;
      v73[2] = a2 | (unint64_t)(a4 << 32);
      std::string::size_type v74 = (uint64_t (***)())v73;
      switch(a3)
      {
        case 1:
          if (a4 != 1) {
            goto LABEL_62;
          }
          uint64_t v15 = *v11;
          BOOL v16 = os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT);
          char v17 = 0;
          if (v16)
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Saving user preference to 2G", buf, 2u);
            char v17 = 0;
          }
          goto LABEL_47;
        case 2:
          if (a4 != 1) {
            goto LABEL_62;
          }
          uint64_t v45 = *v11;
          if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Saving user preference to 3G", buf, 2u);
          }
          char v17 = 1;
LABEL_47:
          sub_100F481BC(v12 + 600, v17);
          sub_100F481BC(v12 + 480, 0);
          char v46 = 0;
          break;
        case 3:
          memset(v72, 0, sizeof(v72));
          sub_1000F0058((uint64_t)v72, (uint64_t)v73);
          sub_1003355AC(v73);
          *(void *)std::string buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 1174405120;
          *(void *)&uint8_t buf[16] = sub_100F4C3A8;
          unsigned int v66 = &unk_101A71BC0;
          char v71 = a4;
          BOOL v67 = v11;
          uint64_t v68 = v12;
          BOOL v69 = v64;
          if (v64) {
            atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_1000F0058((uint64_t)v70, (uint64_t)v72);
          long long v47 = _Block_copy(buf);
          v62[0] = v47;
          sub_100F4B904(a1, a2, a4, 1, (uint64_t)v62);
          if (v47) {
            _Block_release(v47);
          }
          sub_10003B34C(v70);
          if (v69) {
            sub_10004D2C8(v69);
          }
          sub_10003B34C(v72);
          goto LABEL_60;
        case 4:
          if (a4 != 1) {
            goto LABEL_62;
          }
          BOOL v48 = *v11;
          if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Saving user preference to 5G", buf, 2u);
          }
          char v46 = 1;
          sub_100F481BC(v12 + 480, 1);
          break;
        default:
          goto LABEL_62;
      }
      sub_100F481BC(v12 + 360, v46);
LABEL_60:
      if (v74)
      {
        uint64_t v14 = *v74;
LABEL_62:
        v14[6]();
      }
      sub_10003B34C(v73);
    }
    else
    {
      CFAllocatorRef v24 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Unable to find model when sending 3G and LTE user preference", buf, 2u);
      }
    }
    if (v64) {
      sub_10004D2C8(v64);
    }
    return v13;
  }
  switch(a3)
  {
    case 0:
    case 5:
    case 6:
    case 7:
    case 8:
      uint64_t v18 = *v8;
      BOOL v13 = 0;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        uint64_t v19 = "#I Not handling setting maximum data rate to %s";
        char v20 = v18;
        goto LABEL_13;
      }
      goto LABEL_15;
    case 1:
      uint64_t v25 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Setting max data rate to 2G", buf, 2u);
      }
      sub_100F4AEDC(a1, a2, 0, a4);
      BOOL v13 = 1;
      goto LABEL_15;
    case 2:
      unsigned __int16 v26 = sub_100F4B174(a1, a2);
      if (v26 < 0x100u) {
        goto LABEL_14;
      }
      int v27 = v26;
      CFBooleanRef v28 = *v8;
      BOOL v29 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
      if (v27)
      {
        if (v29)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I LTE capable device, disabling LTE", buf, 2u);
        }
        BOOL v13 = sub_100F4B498(a1, a2, 0, a4);
      }
      else
      {
        if (v29)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I LTE non-capable device, Setting max data rate to 3G", buf, 2u);
        }
        sub_100F4AEDC(a1, a2, 1, a4);
        BOOL v13 = 1;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v30, *(Registry **)(a1 + 56));
      long long v54 = ServiceMap;
      if (v55 < 0)
      {
        long long v56 = (unsigned __int8 *)(v55 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v57 = 5381;
        do
        {
          uint64_t v55 = v57;
          unsigned int v58 = *v56++;
          uint64_t v57 = (33 * v57) ^ v58;
        }
        while (v58);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v55;
      BOOL v59 = sub_10004D37C(&v54[1].__m_.__sig, (unint64_t *)buf);
      if (v59)
      {
        uint64_t v60 = v59[3];
        CFNumberRef v42 = (std::__shared_weak_count *)v59[4];
        if (v42)
        {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v54);
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v42);
          char v61 = 0;
          goto LABEL_90;
        }
      }
      else
      {
        uint64_t v60 = 0;
      }
      std::mutex::unlock(v54);
      CFNumberRef v42 = 0;
      char v61 = 1;
LABEL_90:
      if (v60 && (*(unsigned int (**)(uint64_t))(*(void *)v60 + 16))(v60)) {
        sub_100F4B66C(a1, a2, 0, a4);
      }
      if ((v61 & 1) == 0) {
        goto LABEL_94;
      }
      goto LABEL_15;
    case 3:
      unsigned __int16 v31 = sub_100F4B174(a1, a2);
      if (v31 < 0x100u) {
        goto LABEL_14;
      }
      int v32 = v31;
      uint64_t v33 = *v8;
      BOOL v34 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
      if (!v32)
      {
        if (v34)
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = asString();
          uint64_t v19 = "#I Not handling setting maximum data rate to %s on non-LTE capable devices";
          char v20 = v33;
LABEL_13:
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
        }
        goto LABEL_14;
      }
      if (v34)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I LTE capable device, enabling LTE", buf, 2u);
      }
      if (capabilities::ct::supports5G((capabilities::ct *)v34)) {
        sub_100F4B66C(a1, a2, 0, a4);
      }
      BOOL v13 = sub_100F4B498(a1, a2, 1, a4);
      goto LABEL_15;
    case 4:
      uint64_t v35 = (std::mutex *)Registry::getServiceMap(v9, *(Registry **)(a1 + 56));
      uint64_t v36 = v35;
      if (v37 < 0)
      {
        unsigned __int8 v38 = (unsigned __int8 *)(v37 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v39 = 5381;
        do
        {
          uint64_t v37 = v39;
          unsigned int v40 = *v38++;
          uint64_t v39 = (33 * v39) ^ v40;
        }
        while (v40);
      }
      std::mutex::lock(v35);
      *(void *)std::string buf = v37;
      uint64_t v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)buf);
      if (!v41)
      {
        uint64_t v43 = 0;
LABEL_68:
        std::mutex::unlock(v36);
        CFNumberRef v42 = 0;
        char v44 = 1;
        if (!v43) {
          goto LABEL_73;
        }
        goto LABEL_69;
      }
      uint64_t v43 = v41[3];
      CFNumberRef v42 = (std::__shared_weak_count *)v41[4];
      if (!v42) {
        goto LABEL_68;
      }
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v36);
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v42);
      char v44 = 0;
      if (!v43)
      {
LABEL_73:
        BOOL v51 = *v8;
        BOOL v13 = 0;
        if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v52 = asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v52;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Not handling setting maximum data rate to %s on non-5G capable devices", buf, 0xCu);
          BOOL v13 = 0;
        }
        goto LABEL_75;
      }
LABEL_69:
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v43 + 16))(v43)) {
        goto LABEL_73;
      }
      long long v50 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I 5G capable device, enabling 5G", buf, 2u);
      }
      sub_100F4B498(a1, a2, 1, 2);
      BOOL v13 = 1;
      sub_100F4B66C(a1, a2, 1, a4);
LABEL_75:
      if ((v44 & 1) == 0) {
LABEL_94:
      }
        sub_10004D2C8(v42);
LABEL_15:
      CFAllocatorRef v21 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = asString();
        uint64_t v23 = "false";
        if (v13) {
          uint64_t v23 = "true";
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v23;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Setting max data rate to %s resulted in %s", buf, 0x16u);
      }
      return v13;
    default:
LABEL_14:
      BOOL v13 = 0;
      goto LABEL_15;
  }
}

void sub_100F469C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F46AA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v121 = 0;
  BOOL v122 = 0;
  Model_sync = (capabilities::ct *)MaxDataRateManager::getModel_sync(a1, a2, &v121);
  if (v121)
  {
    uint64_t v119 = 0;
    BOOL v120 = 0;
    char v6 = capabilities::ct::supportsGemini(Model_sync);
    sub_10119BFD8(a2, v6, &v119);
    uint64_t v141 = 0;
    memset(v140, 0, sizeof(v140));
    *(_OWORD *)std::string buf = 0u;
    uint64_t v8 = v119;
    uint64_t v7 = v120;
    if (v120) {
      atomic_fetch_add_explicit(&v120->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v9 = sub_100F48CEC(a1);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    *(_DWORD *)std::string buf = 4;
    *(void *)&uint8_t buf[8] = v10;
    LOBYTE(v140[0]) = v9;
    *(void *)&v140[2] = 0;
    *(void *)&v140[4] = 0;
    uint64_t v141 = 0;
    if (v7)
    {
      sub_10004D2C8(v7);
      uint64_t v138 = 0;
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      long long v132 = 0u;
      long long v133 = 0u;
      long long v131 = 0u;
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      uint64_t v138 = 0;
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      long long v132 = 0u;
      long long v133 = 0u;
      long long v131 = 0u;
    }
    char v12 = sub_100F48FE4(a1, a2);
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
    LODWORD(v131) = 3;
    *((void *)&v131 + 1) = v13;
    LOBYTE(v132) = v12;
    *(void *)&long long v134 = 0;
    *(void *)&long long v136 = 0;
    uint64_t v138 = 0;
    if (v7)
    {
      sub_10004D2C8(v7);
      uint64_t v130 = 0;
      long long v128 = 0u;
      long long v129 = 0u;
      long long v126 = 0u;
      long long v127 = 0u;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v123 = 0u;
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      uint64_t v130 = 0;
      long long v128 = 0u;
      long long v129 = 0u;
      long long v126 = 0u;
      long long v127 = 0u;
      long long v124 = 0u;
      long long v125 = 0u;
      long long v123 = 0u;
    }
    char v14 = sub_100F494CC(a1, a2);
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32))(v8);
    LODWORD(v123) = 2;
    *((void *)&v123 + 1) = v15;
    LOBYTE(v124) = v14;
    *(void *)&long long v126 = 0;
    *(void *)&long long v128 = 0;
    uint64_t v130 = 0;
    if (v7) {
      sub_10004D2C8(v7);
    }
    BOOL v16 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Current 3G switch support: %s", v142, 0xCu);
      BOOL v16 = *v4;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Current LTE switch support: %s", v142, 0xCu);
      BOOL v16 = *v4;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v19;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Current 5G switch support: %s", v142, 0xCu);
      BOOL v16 = *v4;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v20;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Last known 3G switch support: %s", v142, 0xCu);
      BOOL v16 = *v4;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Last known LTE switch support: %s", v142, 0xCu);
      BOOL v16 = *v4;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Last known 5G switch support: %s", v142, 0xCu);
    }
    if (!(_BYTE)v132 || (int v23 = v124, !(_BYTE)v124) || !LOBYTE(v140[0]))
    {
      int v32 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)BOOL v142 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Unable to find model when evaluating switch states", v142, 2u);
      }
      goto LABEL_170;
    }
    CFAllocatorRef v24 = v121;
    if (v121[16] || v121[256] || v121[136])
    {
      int v25 = 0;
    }
    else
    {
      long long v108 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)BOOL v142 = 0;
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I Do not know the support for 3G, LTE, and 5G switches, figuring out for the first time", v142, 2u);
        int v25 = 1;
        int v23 = v124;
      }
      else
      {
        int v25 = 1;
      }
    }
    int v26 = v24[256];
    int v109 = v25;
    if (v26 == v23)
    {
      int v117 = 0;
    }
    else
    {
      int v27 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = asString();
        uint64_t v29 = asString();
        *(_DWORD *)BOOL v142 = 136315650;
        *(void *)&v142[4] = "3G";
        __int16 v143 = 2080;
        uint64_t v144 = v28;
        __int16 v145 = 2080;
        uint64_t v146 = v29;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s Support statuses are not matching: old - %s, new - %s", v142, 0x20u);
        int v30 = v24[256];
        int v31 = v124;
      }
      else
      {
        int v31 = v23;
        int v30 = v26;
      }
      int v117 = 0;
      if (v30 != 3 && v31 == 3)
      {
        uint64_t v33 = *v4;
        BOOL v34 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
        int v35 = v123;
        if (v34)
        {
          if ((v123 - 1) > 3) {
            uint64_t v36 = "Cannot convert datarate to indicator string";
          }
          else {
            uint64_t v36 = off_101A731B8[(int)v123 - 1];
          }
          *(_DWORD *)BOOL v142 = 136315138;
          *(void *)&v142[4] = v36;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Support for %s switch has been lost", v142, 0xCu);
          int v35 = v123;
        }
        if (v35 < 1)
        {
          int v117 = 0;
        }
        else
        {
          int v117 = v35;
          uint64_t v37 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v38 = asString();
            *(_DWORD *)BOOL v142 = 136315138;
            *(void *)&v142[4] = v38;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Data rate needs to be set to at least %s", v142, 0xCu);
          }
        }
      }
      v24[256] = v124;
    }
    int v39 = v24[16];
    int v115 = v132;
    if (v39 != v132)
    {
      unsigned int v40 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = asString();
        uint64_t v42 = asString();
        *(_DWORD *)BOOL v142 = 136315650;
        *(void *)&v142[4] = "LTE";
        __int16 v143 = 2080;
        uint64_t v144 = v41;
        __int16 v145 = 2080;
        uint64_t v146 = v42;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s Support statuses are not matching: old - %s, new - %s", v142, 0x20u);
        int v43 = v24[16];
        int v44 = v132;
      }
      else
      {
        int v44 = v115;
        int v43 = v39;
      }
      if (v43 != 3 && v44 == 3)
      {
        uint64_t v45 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          if ((v131 - 1) > 3) {
            char v46 = "Cannot convert datarate to indicator string";
          }
          else {
            char v46 = off_101A731B8[(int)v131 - 1];
          }
          *(_DWORD *)BOOL v142 = 136315138;
          *(void *)&v142[4] = v46;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Support for %s switch has been lost", v142, 0xCu);
        }
        int v47 = v131;
        if (v117 < (int)v131)
        {
          BOOL v48 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v49 = asString();
            *(_DWORD *)BOOL v142 = 136315138;
            *(void *)&v142[4] = v49;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Data rate needs to be set to at least %s", v142, 0xCu);
          }
          int v117 = v47;
        }
      }
      v24[16] = v132;
    }
    int v116 = v24[136];
    int v114 = LOBYTE(v140[0]);
    if (v116 != LOBYTE(v140[0]))
    {
      long long v50 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v51 = asString();
        uint64_t v52 = asString();
        *(_DWORD *)BOOL v142 = 136315650;
        *(void *)&v142[4] = "5G";
        __int16 v143 = 2080;
        uint64_t v144 = v51;
        __int16 v145 = 2080;
        uint64_t v146 = v52;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I %s Support statuses are not matching: old - %s, new - %s", v142, 0x20u);
        int v53 = v24[136];
        int v54 = LOBYTE(v140[0]);
      }
      else
      {
        int v54 = v114;
        int v53 = v116;
      }
      if (v53 != 3 && v54 == 3)
      {
        uint64_t v55 = *v4;
        if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
        {
          if ((*(_DWORD *)buf - 1) > 3) {
            long long v56 = "Cannot convert datarate to indicator string";
          }
          else {
            long long v56 = off_101A731B8[*(_DWORD *)buf - 1];
          }
          *(_DWORD *)BOOL v142 = 136315138;
          *(void *)&v142[4] = v56;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Support for %s switch has been lost", v142, 0xCu);
        }
        int v57 = *(_DWORD *)buf;
        if (v117 < *(int *)buf)
        {
          unsigned int v58 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v59 = asString();
            *(_DWORD *)BOOL v142 = 136315138;
            *(void *)&v142[4] = v59;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Data rate needs to be set to at least %s", v142, 0xCu);
          }
          int v117 = v57;
        }
      }
      v24[136] = v140[0];
    }
    int v113 = v39;
    int v118 = *((_DWORD *)v24 + 154);
    uint64_t v60 = *((void *)v24 + 81);
    if (v60) {
      int v61 = (*(uint64_t (**)(uint64_t))(*(void *)v60 + 48))(v60);
    }
    else {
      int v61 = 0;
    }
    *((_DWORD *)v24 + 154) = v61;
    BOOL v62 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v63 = asString();
      *(_DWORD *)BOOL v142 = 136315394;
      *(void *)&v142[4] = "3G";
      __int16 v143 = 2080;
      uint64_t v144 = v63;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s User preference evaluated: %s", v142, 0x16u);
    }
    if (v61 != v118)
    {
      BOOL v64 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v65 = asString();
        uint64_t v66 = asString();
        *(_DWORD *)BOOL v142 = 136315650;
        *(void *)&v142[4] = "3G";
        __int16 v143 = 2080;
        uint64_t v144 = v65;
        __int16 v145 = 2080;
        uint64_t v146 = v66;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I User preferences for %s are not matching : old - %s, new - %s", v142, 0x20u);
      }
    }
    int v110 = v26;
    int v111 = v23;
    uint64_t v112 = a1;
    int v67 = *((_DWORD *)v24 + 124);
    uint64_t v68 = *((void *)v24 + 66);
    if (v68) {
      int v69 = (*(uint64_t (**)(uint64_t))(*(void *)v68 + 48))(v68);
    }
    else {
      int v69 = 0;
    }
    *((_DWORD *)v24 + 124) = v69;
    BOOL v70 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v71 = asString();
      *(_DWORD *)BOOL v142 = 136315394;
      *(void *)&v142[4] = "LTE";
      __int16 v143 = 2080;
      uint64_t v144 = v71;
      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I %s User preference evaluated: %s", v142, 0x16u);
    }
    if (v69 != v67)
    {
      BOOL v72 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v73 = asString();
        uint64_t v74 = asString();
        *(_DWORD *)BOOL v142 = 136315650;
        *(void *)&v142[4] = "LTE";
        __int16 v143 = 2080;
        uint64_t v144 = v73;
        __int16 v145 = 2080;
        uint64_t v146 = v74;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I User preferences for %s are not matching : old - %s, new - %s", v142, 0x20u);
      }
    }
    int v75 = *((_DWORD *)v24 + 94);
    uint64_t v76 = *((void *)v24 + 51);
    if (v76) {
      int v77 = (*(uint64_t (**)(uint64_t))(*(void *)v76 + 48))(v76);
    }
    else {
      int v77 = 0;
    }
    *((_DWORD *)v24 + 94) = v77;
    std::string::size_type v78 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v79 = asString();
      *(_DWORD *)BOOL v142 = 136315394;
      *(void *)&v142[4] = "5G";
      __int16 v143 = 2080;
      uint64_t v144 = v79;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I %s User preference evaluated: %s", v142, 0x16u);
    }
    if (v77 != v75)
    {
      BOOL v80 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v81 = asString();
        uint64_t v82 = asString();
        *(_DWORD *)BOOL v142 = 136315650;
        *(void *)&v142[4] = "5G";
        __int16 v143 = 2080;
        uint64_t v144 = v81;
        __int16 v145 = 2080;
        uint64_t v146 = v82;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I User preferences for %s are not matching : old - %s, new - %s", v142, 0x20u);
      }
    }
    BOOL v85 = v69 != v67 || v77 != v75 || v61 != v118;
    int v86 = sub_100F49D10(v112, a2);
    if (v86 < v117)
    {
      sub_100F45FFC(v112, a2, v117, 3);
LABEL_139:
      if (v110 != v111)
      {
        if (v24[256] != 2)
        {
          BOOL v93 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v94 = asString();
            *(_DWORD *)BOOL v142 = 136315394;
            *(void *)&v142[4] = "3G";
            __int16 v143 = 2080;
            uint64_t v144 = v94;
            _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#N Resetting %s preference due to %s", v142, 0x16u);
          }
          uint64_t v95 = *((void *)v24 + 85);
          if (v95)
          {
            *(void *)BOOL v142 = *((void *)v24 + 76);
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v95 + 48))(v95, v142);
            uint64_t v96 = *((void *)v24 + 81);
            if (v96) {
              LODWORD(v96) = (*(uint64_t (**)(uint64_t))(*(void *)v96 + 48))(v96);
            }
            *((_DWORD *)v24 + 154) = v96;
          }
        }
        uint64_t v97 = *((void *)v24 + 44);
        if (v97) {
          sub_100F56128(v97, *((void *)v24 + 31), v24[256]);
        }
      }
      if (v113 != v115)
      {
        if (v24[16] != 2)
        {
          BOOL v98 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v99 = asString();
            *(_DWORD *)BOOL v142 = 136315394;
            *(void *)&v142[4] = "LTE";
            __int16 v143 = 2080;
            uint64_t v144 = v99;
            _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "#N Resetting %s preference due to %s", v142, 0x16u);
          }
          uint64_t v100 = *((void *)v24 + 70);
          if (v100)
          {
            *(void *)BOOL v142 = *((void *)v24 + 61);
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v100 + 48))(v100, v142);
            uint64_t v101 = *((void *)v24 + 66);
            if (v101) {
              LODWORD(v101) = (*(uint64_t (**)(uint64_t))(*(void *)v101 + 48))(v101);
            }
            *((_DWORD *)v24 + 124) = v101;
          }
        }
        uint64_t v102 = *((void *)v24 + 14);
        if (v102) {
          sub_100F56128(v102, *((void *)v24 + 1), v24[16]);
        }
      }
      if (v116 != v114)
      {
        if (v24[136] != 2)
        {
          long long v103 = *v4;
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v104 = asString();
            *(_DWORD *)BOOL v142 = 136315394;
            *(void *)&v142[4] = "5G";
            __int16 v143 = 2080;
            uint64_t v144 = v104;
            _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#N Resetting %s preference due to %s", v142, 0x16u);
          }
          uint64_t v105 = *((void *)v24 + 55);
          if (v105)
          {
            *(void *)BOOL v142 = *((void *)v24 + 46);
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v105 + 48))(v105, v142);
            uint64_t v106 = *((void *)v24 + 51);
            if (v106) {
              LODWORD(v106) = (*(uint64_t (**)(uint64_t))(*(void *)v106 + 48))(v106);
            }
            *((_DWORD *)v24 + 94) = v106;
          }
        }
        uint64_t v107 = *((void *)v24 + 29);
        if (v107) {
          sub_100F56128(v107, *((void *)v24 + 16), v24[136]);
        }
      }
      sub_100F4A020(v112);
LABEL_170:
      sub_100F4E628((void *)&v128 + 1);
      sub_100F4E5A4((void *)&v126 + 1);
      sub_100F4E520((void *)&v124 + 1);
      sub_100F4E628((void *)&v136 + 1);
      sub_100F4E5A4((void *)&v134 + 1);
      sub_100F4E520((void *)&v132 + 1);
      sub_100F4E628((void *)&v140[4] + 1);
      sub_100F4E5A4((void *)&v140[2] + 1);
      sub_100F4E520((void *)v140 + 1);
      if (v120) {
        sub_10004D2C8(v120);
      }
      goto LABEL_172;
    }
    BOOL v87 = (v24[136] & 0xFE) == 2 || (v24[16] & 0xFE) == 2 || (v24[256] & 0xFE) == 2;
    if (v109)
    {
      if (!v87) {
        goto LABEL_139;
      }
      int v88 = *v4;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
LABEL_138:
        sub_100F45FFC(v112, a2, v86, 3);
        goto LABEL_139;
      }
      uint64_t v89 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v89;
      BOOL v90 = "#I Force sending the max data rate %s to baseband";
    }
    else
    {
      int v91 = v113 != v115 || v85;
      if (v110 != v111) {
        int v91 = 1;
      }
      if (v116 != v114) {
        int v91 = 1;
      }
      if ((v91 & v87) != 1) {
        goto LABEL_139;
      }
      int v88 = *v4;
      if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_138;
      }
      uint64_t v92 = asString();
      *(_DWORD *)BOOL v142 = 136315138;
      *(void *)&v142[4] = v92;
      BOOL v90 = "#I Switch support or user preference has changed, setting the max data rate %s";
    }
    _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, v90, v142, 0xCu);
    goto LABEL_138;
  }
  std::string v11 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Unable to find model when evaluating switch states", buf, 2u);
  }
LABEL_172:
  if (v122) {
    sub_10004D2C8(v122);
  }
}

void sub_100F47D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  _Unwind_Resume(a1);
}

void sub_100F47E20(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 416);
  uint64_t v3 = *(void **)v2;
  uint64_t v4 = *(void **)(v2 + 8);
  if (*(void **)v2 != v4)
  {
    while (!sub_10001D294((unsigned __int8 *)(*v3 + 24), a2))
    {
      v3 += 2;
      if (v3 == v4)
      {
        uint64_t v3 = v4;
        break;
      }
    }
    if (v3 != *(void **)(v2 + 8))
    {
      uint64_t v7 = *v3;
      uint64_t v8 = (std::__shared_weak_count *)v3[1];
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v7 && !*(unsigned char *)(v7 + 49)) {
        sub_100F47F00(a1);
      }
      if (v8)
      {
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_100F47EE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F47F00(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 416);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (v3 == v4)
  {
    unsigned int v5 = 0;
  }
  else
  {
    unsigned int v5 = 0;
    do
    {
      if (!*(unsigned char *)(*(void *)v3 + 49)) {
        v5 += *(unsigned __int8 *)(*(void *)v3 + 48);
      }
      v3 += 16;
    }
    while (v3 != v4);
  }
  char v6 = *(void **)(a1 + 432);
  uint64_t v7 = (void *)(a1 + 440);
  if (v6 == (void *)(a1 + 440))
  {
    unsigned int v8 = 0;
  }
  else
  {
    unsigned int v8 = 0;
    do
    {
      int v9 = sub_10024FACC(v6[5] + 720);
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          std::string v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          std::string v11 = (void *)v6[2];
          BOOL v12 = *v11 == (void)v6;
          char v6 = v11;
        }
        while (!v12);
      }
      v8 += v9;
      char v6 = v11;
    }
    while (v11 != v7);
    char v6 = *(void **)(a1 + 432);
  }
  if (v6 != v7)
  {
    while (1)
    {
      uint64_t v13 = *((unsigned int *)v6 + 8);
      if (v5 < 2)
      {
        int v15 = 0;
      }
      else
      {
        BOOL v14 = *(_DWORD *)(a1 + 156) != v13 && v8 > 1;
        int v15 = v14;
      }
      uint64_t v30 = 0;
      int v31 = 0;
      MaxDataRateManager::getModel_sync(a1, v13, &v30);
      uint64_t v16 = v30;
      if (v30)
      {
        sub_10024FCFC(v30 + 720, v15);
        if (*(unsigned char *)(v16 + 748)) {
          break;
        }
      }
LABEL_41:
      if (v31) {
        sub_10004D2C8(v31);
      }
      uint64_t v28 = (void *)v6[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)v6[2];
          BOOL v12 = *v29 == (void)v6;
          char v6 = v29;
        }
        while (!v12);
      }
      char v6 = v29;
      if (v29 == v7) {
        return;
      }
    }
    sub_100F481BC(v16 + 480, 1);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 56));
    uint64_t v19 = ServiceMap;
    if ((v20 & 0x8000000000000000) != 0)
    {
      uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        unint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v32 = v20;
    CFAllocatorRef v24 = sub_10004D37C(&v19[1].__m_.__sig, &v32);
    if (v24)
    {
      uint64_t v26 = v24[3];
      int v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        if (!v26)
        {
LABEL_39:
          if ((v27 & 1) == 0) {
            sub_10004D2C8(v25);
          }
          goto LABEL_41;
        }
LABEL_38:
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26 + 352))(v26, v13, 2);
        goto LABEL_39;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    int v25 = 0;
    char v27 = 1;
    if (!v26) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
}

void sub_100F48188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F481BC(uint64_t a1, char a2)
{
  uint64_t result = *(void *)(a1 + 112);
  if (result)
  {
    sub_100F560D0(result, *(void *)(a1 + 8), a2);
    uint64_t result = *(void *)(a1 + 48);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
    }
    *(_DWORD *)(a1 + 16) = result;
  }
  return result;
}

void sub_100F48220(uint64_t a1, uint64_t a2)
{
  if ((rest::operator==() & 1) == 0)
  {
    uint64_t v4 = *(void **)(a1 + 432);
    if (v4 != (void *)(a1 + 440))
    {
      unsigned int v5 = (uint64_t *)(a1 + 136);
      char v6 = (void *)(a2 + 8);
      do
      {
        uint64_t v7 = *v5;
        if (*v5)
        {
          int v8 = *((_DWORD *)v4 + 8);
          uint64_t v9 = a1 + 136;
          do
          {
            int v10 = *(_DWORD *)(v7 + 32);
            BOOL v11 = v10 < v8;
            if (v10 >= v8) {
              BOOL v12 = (uint64_t *)v7;
            }
            else {
              BOOL v12 = (uint64_t *)(v7 + 8);
            }
            if (!v11) {
              uint64_t v9 = v7;
            }
            uint64_t v7 = *v12;
          }
          while (*v12);
          if ((uint64_t *)v9 != v5 && v8 >= *(_DWORD *)(v9 + 32))
          {
            uint64_t v13 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
            uint64_t v14 = *v6;
            if (!*v6) {
              goto LABEL_66;
            }
            int v15 = *((_DWORD *)v4 + 8);
            uint64_t v16 = v6;
            do
            {
              int v17 = *(_DWORD *)(v14 + 32);
              BOOL v18 = v17 < v15;
              if (v17 >= v15) {
                uint64_t v19 = (uint64_t *)v14;
              }
              else {
                uint64_t v19 = (uint64_t *)(v14 + 8);
              }
              if (!v18) {
                uint64_t v16 = (void *)v14;
              }
              uint64_t v14 = *v19;
            }
            while (*v19);
            if (v16 == v6 || v15 < *((_DWORD *)v16 + 8) || (rest::operator==() & 1) == 0)
            {
LABEL_66:
              if (*(unsigned char *)(v9 + 40))
              {
                unint64_t v20 = *v13;
                if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v21 = asString();
                  uint64_t v22 = asString();
                  *(_DWORD *)std::string buf = 136315394;
                  *(void *)&uint8_t buf[4] = v21;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v22;
                  _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle setup event received (%s, %s), evaluating state of switches and user preferences", buf, 0x16u);
                }
                uint64_t v23 = *((unsigned int *)v4 + 8);
                CFAllocatorRef v24 = (capabilities::ct *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v23);
                *(void *)std::string buf = 0;
                *(void *)&uint8_t buf[8] = 0;
                char v25 = capabilities::ct::supportsGemini(v24);
                sub_10119BFD8(v23, v25, buf);
                uint64_t v45 = 0;
                uint64_t v26 = (const __CFString **)(*(uint64_t (**)(void))(**(void **)buf + 64))(*(void *)buf);
                char v46 = 0;
                *(void *)BOOL v48 = 0;
                if (ctu::cf::convert_copy((ctu::cf *)v48, v26, (const char *)0x8000100, kCFAllocatorDefault, v27))
                {
                  uint64_t v28 = v46;
                  char v46 = *(BOOL **)v48;
                  *(void *)uint64_t v42 = v28;
                  sub_1000558F4((const void **)v42);
                }
                uint64_t v45 = v46;
                char v46 = 0;
                sub_1000558F4((const void **)&v46);
                char v46 = 0;
                (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(v42);
                sub_1000057AC(&v46, (CFTypeRef *)v42);
                sub_1000577C4((const void **)v42);
                v42[0] = 0;
                ctu::cf::assign((ctu::cf *)v42, v46, v29);
                if (v42[0])
                {
                  CFBooleanRef v44 = 0;
                  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 72) + 40))(v42);
                  sub_1000057AC(&v44, (CFTypeRef *)v42);
                  sub_1000577C4((const void **)v42);
                  if (v44) {
                    uint64_t v30 = sub_100084B4C;
                  }
                  else {
                    uint64_t v30 = 0;
                  }
                  if (v30 && v44 == kCFBooleanTrue)
                  {
                    int v31 = *(NSObject **)v24;
                    if (os_log_type_enabled(*(os_log_t *)v24, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)uint64_t v42 = 0;
                      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I LTE switch user preference, 'EnableLTEAfterUpgrade was already used once - bail out'", v42, 2u);
                    }
                  }
                  else
                  {
                    *(void *)uint64_t v42 = 0;
                    int v43 = 0;
                    MaxDataRateManager::getModel_sync(a1, v23, v42);
                    uint64_t v33 = *(void *)v42;
                    BOOL v34 = *(NSObject **)v24;
                    if (*(void *)v42)
                    {
                      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)BOOL v48 = 0;
                        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Processing EnableLTEAfterUpgrade for LTE switch user preference", v48, 2u);
                      }
                      (*(void (**)(void, BOOL *, const CFBooleanRef, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 72) + 16))(*(void *)(a1 + 72), v45, kCFBooleanTrue, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                      (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                      int v35 = *(_DWORD *)(v33 + 496);
                      uint64_t v36 = *(NSObject **)v24;
                      BOOL v37 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
                      if (v35 == 3)
                      {
                        if (v37)
                        {
                          *(_WORD *)BOOL v48 = 0;
                          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Enabling LTE user preference due to migration", v48, 2u);
                        }
                        sub_100F45FFC(a1, v23, 3, 2);
                      }
                      else if (v37)
                      {
                        uint64_t v38 = asString();
                        *(_DWORD *)BOOL v48 = 136315138;
                        *(void *)&void v48[4] = v38;
                        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Leaving LTE switch migration alone, LTE user preference is: %s", v48, 0xCu);
                      }
                    }
                    else if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)BOOL v48 = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Unable to find model when evaluating LTE switch during migration", v48, 2u);
                    }
                    if (v43) {
                      sub_10004D2C8(v43);
                    }
                  }
                  sub_100062778((const void **)&v44);
                }
                else
                {
                  unint64_t v32 = *(NSObject **)v24;
                  if (os_log_type_enabled(*(os_log_t *)v24, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)uint64_t v42 = 0;
                    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I LTE switch user preference, 'EnableLTEAfterUpgrade is not present - drop set flag if present'", v42, 2u);
                  }
                  (*(void (**)(void, BOOL *, void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 72) + 16))(*(void *)(a1 + 72), v45, 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                  (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
                }
                sub_100062778((const void **)&v46);
                sub_1000558F4((const void **)&v45);
                if (*(void *)&buf[8]) {
                  sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                }
                sub_100F489C4(a1);
              }
            }
          }
        }
        int v39 = (void *)v4[1];
        if (v39)
        {
          do
          {
            unsigned int v40 = v39;
            int v39 = (void *)*v39;
          }
          while (v39);
        }
        else
        {
          do
          {
            unsigned int v40 = (void *)v4[2];
            BOOL v41 = *v40 == (void)v4;
            uint64_t v4 = v40;
          }
          while (!v41);
        }
        uint64_t v4 = v40;
      }
      while (v40 != (void *)(a1 + 440));
    }
  }
}

void sub_100F48930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,const void *a24,const void *a25,const void *a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  sub_100062778(&a24);
  sub_100062778(&a26);
  sub_1000558F4(&a25);
  if (a28) {
    sub_10004D2C8(a28);
  }
  _Unwind_Resume(a1);
}

void sub_100F489C4(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  uint64_t v2 = v4;
  if (v4 != v5)
  {
    while ((v6(*v2) & 1) == 0)
    {
      if (++v2 == v5)
      {
        uint64_t v2 = v5;
        break;
      }
    }
LABEL_5:
    while (v2 != v5)
    {
      uint64_t v3 = v2 + 1;
      sub_100F46AA4(a1, *v2);
      uint64_t v2 = v5;
      if (v3 != v5)
      {
        uint64_t v2 = v3;
        while ((v6(*v2) & 1) == 0)
        {
          if (++v2 == v5)
          {
            uint64_t v2 = v5;
            goto LABEL_5;
          }
        }
      }
    }
  }
}

void sub_100F48A80(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 120))
  {
    uint64_t v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v4 = *(void **)(a1 + 104);
    unsigned int v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      int v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          int v8 = v3;
        }
        while (!v6);
      }
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          unsigned int v5 = v10;
        }
        while (!v6);
      }
      unsigned int v5 = v10;
      if (v3 == a2 + 1) {
        return;
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 104);
  }
  BOOL v11 = (void *)(a1 + 112);
  if (v4 != (void *)(a1 + 112))
  {
    BOOL v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      int v14 = *((_DWORD *)v4 + 7);
      if (!*v12) {
        goto LABEL_35;
      }
      int v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < v14;
        if (v16 >= v14) {
          BOOL v18 = (uint64_t *)v13;
        }
        else {
          BOOL v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          int v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12 || v14 < *((_DWORD *)v15 + 7) || *((_DWORD *)v15 + 8) != *((_DWORD *)v4 + 8))
      {
LABEL_35:
        uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v4 + 7));
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = *((int *)v4 + 8);
          uint64_t v21 = "Device Type unknown";
          if (v20 <= 3) {
            uint64_t v21 = off_101A731D8[v20];
          }
          *(_DWORD *)std::string buf = 136315138;
          char v25 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Device type changed to %s, evaluating state of switches", buf, 0xCu);
        }
        sub_100F489C4(a1);
      }
      uint64_t v22 = (void *)v4[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v4[2];
          BOOL v6 = *v23 == (void)v4;
          uint64_t v4 = v23;
        }
        while (!v6);
      }
      uint64_t v4 = v23;
    }
    while (v23 != v11);
  }
}

uint64_t sub_100F48CEC(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 56));
  unsigned int v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  cf[0] = (CFTypeRef)v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)cf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    BOOL v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  BOOL v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    int v14 = *v2;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(cf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Unable to get the CapabilitiesHandler when enabling 5G switch", (uint8_t *)cf, 2u);
    }
    uint64_t v15 = 0;
    if ((v13 & 1) == 0) {
      goto LABEL_10;
    }
    return v15;
  }
LABEL_14:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v12 + 16))(v12))
  {
    uint64_t v15 = 1;
    if (v13) {
      return v15;
    }
    goto LABEL_10;
  }
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 480) + 96))(cf);
  BOOL v17 = (BOOL *)cf[0];
  unsigned __int8 v23 = 0;
  if (cf[0] && (CFTypeID v18 = CFGetTypeID(cf[0]), v18 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v23, v17, v19);
    int v20 = v23;
    sub_1000577C4(cf);
    if (v20)
    {
      uint64_t v21 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(cf[0]) = 0;
        uint64_t v15 = 2;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Show5GSwitch is set to true, 5G switch is therefore supported", (uint8_t *)cf, 2u);
        if (v13) {
          return v15;
        }
      }
      else
      {
        uint64_t v15 = 2;
        if (v13) {
          return v15;
        }
      }
      goto LABEL_10;
    }
  }
  else
  {
    sub_1000577C4(cf);
  }
  uint64_t v22 = *v2;
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(cf[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I 5G switch is not supported", (uint8_t *)cf, 2u);
  }
  uint64_t v15 = 3;
  if ((v13 & 1) == 0) {
LABEL_10:
  }
    sub_10004D2C8(v11);
  return v15;
}

void sub_100F48FB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F48FE4(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  unsigned __int16 v5 = sub_100F4B174(a1, a2);
  if (v5 < 0x100u) {
    return 0;
  }
  if (!(_BYTE)v5) {
    return 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)v5, *(Registry **)(a1 + 56));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  cf[0] = (CFTypeRef)v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)cf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_10;
      }
LABEL_17:
      if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 16))(v15))
      {
        (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 480) + 96))(cf);
        CFTypeID v18 = (BOOL *)cf[0];
        unsigned __int8 v35 = 0;
        if (cf[0])
        {
          CFTypeID v19 = CFGetTypeID(cf[0]);
          if (v19 == CFBooleanGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v35, v18, v20);
          }
          int v21 = v35;
          sub_1000577C4(cf);
          if (v21)
          {
            uint64_t v22 = *v4;
            if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(cf[0]) = 0;
              unsigned __int8 v23 = "#I Show3GSwitchWith5G is set to true, 4G switch is therefore supported";
              goto LABEL_39;
            }
LABEL_48:
            uint64_t v6 = 2;
            if (v16) {
              return v6;
            }
            goto LABEL_46;
          }
        }
        else
        {
          sub_1000577C4(cf);
        }
        (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 480) + 96))(cf);
        CFAllocatorRef v24 = (BOOL *)cf[0];
        unsigned __int8 v35 = 0;
        if (cf[0] && (CFTypeID v25 = CFGetTypeID(cf[0]), v25 == CFBooleanGetTypeID()))
        {
          ctu::cf::assign((ctu::cf *)&v35, v24, v26);
          int v27 = v35;
          sub_1000577C4(cf);
          if (v27)
          {
            uint64_t v22 = *v4;
            if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_48;
            }
            LOWORD(cf[0]) = 0;
            unsigned __int8 v23 = "#I Show4GSwitchWith5G is set to true, 4G switch is therefore supported";
            goto LABEL_39;
          }
        }
        else
        {
          sub_1000577C4(cf);
        }
      }
      if (sub_100F48CEC(a1) == 2)
      {
        uint64_t v28 = *v4;
        if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_45;
        }
        LOWORD(cf[0]) = 0;
        CFBooleanRef v29 = "#I 5G switch is set to true, 4G switch is therefore not supported";
      }
      else
      {
        (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 480) + 96))(cf);
        uint64_t v30 = (BOOL *)cf[0];
        unsigned __int8 v35 = 0;
        if (cf[0] && (CFTypeID v31 = CFGetTypeID(cf[0]), v31 == CFBooleanGetTypeID()))
        {
          ctu::cf::assign((ctu::cf *)&v35, v30, v32);
          int v33 = v35;
          sub_1000577C4(cf);
          if (v33)
          {
            uint64_t v22 = *v4;
            if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_48;
            }
            LOWORD(cf[0]) = 0;
            unsigned __int8 v23 = "#I Show4GSwitch is set to true, 4G switch is therefore supported";
LABEL_39:
            uint64_t v6 = 2;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)cf, 2u);
            if (v16) {
              return v6;
            }
            goto LABEL_46;
          }
        }
        else
        {
          sub_1000577C4(cf);
        }
        uint64_t v28 = *v4;
        if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
LABEL_45:
          uint64_t v6 = 3;
          if (v16) {
            return v6;
          }
LABEL_46:
          sub_10004D2C8(v14);
          return v6;
        }
        LOWORD(cf[0]) = 0;
        CFBooleanRef v29 = "#I 4G switch is not supported";
      }
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v29, (uint8_t *)cf, 2u);
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  int v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_17;
  }
LABEL_10:
  BOOL v17 = *v4;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(cf[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Unable to get the CapabilitiesHandler, support for 3G switch is therefore unknown", (uint8_t *)cf, 2u);
  }
  uint64_t v6 = 0;
  if ((v16 & 1) == 0) {
    goto LABEL_46;
  }
  return v6;
}

void sub_100F4948C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F494CC(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  unsigned __int16 v5 = v4;
  uint64_t v6 = *(void *)(a1 + 112);
  if (!v6) {
    goto LABEL_23;
  }
  uint64_t v7 = a1 + 112;
  do
  {
    int v8 = *(_DWORD *)(v6 + 28);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      int v10 = (uint64_t *)v6;
    }
    else {
      int v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 == a1 + 112 || *(_DWORD *)(v7 + 28) > a2) {
    goto LABEL_23;
  }
  int v11 = *(_DWORD *)(v7 + 32);
  if (v11 == 3)
  {
    char v12 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Device is CDMA core, not allowing 3G switch", buf, 2u);
    }
    return 1;
  }
  if ((v11 - 1) >= 2)
  {
LABEL_23:
    CFTypeID v25 = *v4;
    uint64_t v13 = 0;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Device type is still unknown, not allowing 3G switch", buf, 2u);
      return 0;
    }
  }
  else
  {
    if (capabilities::ct::supportsVoiceCall((capabilities::ct *)v4))
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(a1 + 56));
      char v16 = ServiceMap;
      if (v17 < 0)
      {
        CFTypeID v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          uint64_t v17 = v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v17;
      int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
      if (v21)
      {
        uint64_t v23 = v21[3];
        uint64_t v22 = (std::__shared_weak_count *)v21[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v24 = 0;
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      std::mutex::unlock(v16);
      uint64_t v22 = 0;
      char v24 = 1;
LABEL_31:
      if (v23)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v23 + 16))(v23))
        {
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(buf);
          uint64_t v28 = *(BOOL **)buf;
          unsigned __int8 v57 = 0;
          if (*(void *)buf)
          {
            CFTypeID v29 = CFGetTypeID(*(CFTypeRef *)buf);
            if (v29 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v57, v28, v30);
            }
            int v31 = v57;
            sub_1000577C4((const void **)buf);
            if (v31)
            {
              CFBooleanRef v32 = *v5;
              if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                int v33 = "#I Show3GSwitchWith5G is set to true, 3G switch is therefore supported";
LABEL_68:
                uint64_t v13 = 2;
                _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v33, buf, 2u);
                goto LABEL_85;
              }
              goto LABEL_84;
            }
          }
          else
          {
            sub_1000577C4((const void **)buf);
          }
          (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(buf);
          unsigned __int8 v35 = *(BOOL **)buf;
          unsigned __int8 v57 = 0;
          if (*(void *)buf)
          {
            CFTypeID v36 = CFGetTypeID(*(CFTypeRef *)buf);
            if (v36 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)&v57, v35, v37);
            }
            int v38 = v57;
            sub_1000577C4((const void **)buf);
            if (v38)
            {
              int v39 = *v5;
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string buf = 0;
                unsigned int v40 = "#I Show4GSwitchWith5G is set to true, 3G switch is therefore not supported";
LABEL_53:
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v40, buf, 2u);
                goto LABEL_54;
              }
              goto LABEL_54;
            }
          }
          else
          {
            sub_1000577C4((const void **)buf);
          }
        }
        if (sub_100F48CEC(a1) == 2)
        {
          int v39 = *v5;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            unsigned int v40 = "#I 5G switch is set to true, 3G switch is therefore not supported";
            goto LABEL_53;
          }
LABEL_54:
          uint64_t v13 = 3;
          goto LABEL_85;
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(buf);
        BOOL v41 = *(BOOL **)buf;
        unsigned __int8 v57 = 0;
        if (*(void *)buf)
        {
          CFTypeID v42 = CFGetTypeID(*(CFTypeRef *)buf);
          if (v42 == CFBooleanGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v57, v41, v43);
          }
          int v44 = v57;
          sub_1000577C4((const void **)buf);
          if (v44)
          {
            CFBooleanRef v32 = *v5;
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              int v33 = "#I Show3GSwitchWithVolte is set to true, 3G switch is therefore supported";
              goto LABEL_68;
            }
LABEL_84:
            uint64_t v13 = 2;
LABEL_85:
            if ((v24 & 1) == 0) {
              sub_10004D2C8(v22);
            }
            return v13;
          }
        }
        else
        {
          sub_1000577C4((const void **)buf);
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(buf);
        uint64_t v45 = *(BOOL **)buf;
        unsigned __int8 v57 = 0;
        if (*(void *)buf)
        {
          CFTypeID v46 = CFGetTypeID(*(CFTypeRef *)buf);
          if (v46 == CFBooleanGetTypeID()) {
            ctu::cf::assign((ctu::cf *)&v57, v45, v47);
          }
          int v48 = v57;
          sub_1000577C4((const void **)buf);
          if (v48)
          {
            CFBooleanRef v32 = *v5;
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              int v33 = "#I Show3GSwitchWith4G is set to true, 3G switch is therefore supported";
              goto LABEL_68;
            }
            goto LABEL_84;
          }
        }
        else
        {
          sub_1000577C4((const void **)buf);
        }
        if (sub_100F48FE4(a1, a2) == 2)
        {
          int v39 = *v5;
          if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_54;
          }
          *(_WORD *)std::string buf = 0;
          unsigned int v40 = "#I LTE switch is supported, 3G switch is therefore not supported";
          goto LABEL_53;
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(buf);
        uint64_t v49 = *(BOOL **)buf;
        unsigned __int8 v57 = 0;
        if (*(void *)buf && (CFTypeID v50 = CFGetTypeID(*(CFTypeRef *)buf), v50 == CFBooleanGetTypeID()))
        {
          ctu::cf::assign((ctu::cf *)&v57, v49, v51);
          int v52 = v57;
          sub_1000577C4((const void **)buf);
          if (v52)
          {
            int v39 = *v5;
            if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_54;
            }
            *(_WORD *)std::string buf = 0;
            unsigned int v40 = "#I LTE switch is not supported but LTE is enabled by default, 3G switch is therefore not supported";
            goto LABEL_53;
          }
        }
        else
        {
          sub_1000577C4((const void **)buf);
        }
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 480) + 96))(buf);
        int v53 = *(BOOL **)buf;
        unsigned __int8 v57 = 0;
        if (*(void *)buf && (CFTypeID v54 = CFGetTypeID(*(CFTypeRef *)buf), v54 == CFBooleanGetTypeID()))
        {
          ctu::cf::assign((ctu::cf *)&v57, v53, v55);
          int v56 = v57;
          sub_1000577C4((const void **)buf);
          if (v56)
          {
            CFBooleanRef v32 = *v5;
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              int v33 = "#I Show3GSwitch is set to true, 3G switch is therefore supported";
              goto LABEL_68;
            }
            goto LABEL_84;
          }
        }
        else
        {
          sub_1000577C4((const void **)buf);
        }
      }
      else
      {
        BOOL v34 = *v5;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Unable to get the CapabilitiesHandler, support for 3G switch is therefore unknown", buf, 2u);
        }
      }
      uint64_t v13 = 0;
      goto LABEL_85;
    }
    int v27 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I iPad device, not supporting 3G switch", buf, 2u);
    }
    return 3;
  }
  return v13;
}

void sub_100F49CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F49D10(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = 0;
  int v21 = 0;
  Model_sync = (capabilities::ct *)MaxDataRateManager::getModel_sync(a1, a2, &v20);
  if (!v20)
  {
    uint64_t v12 = 0;
    goto LABEL_35;
  }
  if ((*(unsigned char *)(v20 + 136) & 0xFE) != 2 || *(_DWORD *)(v20 + 376) != 2)
  {
    if ((*(unsigned char *)(v20 + 16) & 0xFE) == 2)
    {
      if (*(_DWORD *)(v20 + 496) == 2)
      {
LABEL_19:
        uint64_t v12 = 3;
        goto LABEL_33;
      }
      if (*(unsigned char *)(v20 + 256) != 2 || *(_DWORD *)(v20 + 616) == 2) {
        goto LABEL_27;
      }
    }
    else
    {
      if ((*(unsigned char *)(v20 + 256) & 0xFE) != 2)
      {
        uint64_t v12 = 0;
        goto LABEL_33;
      }
      if (*(_DWORD *)(v20 + 616) == 2)
      {
LABEL_27:
        uint64_t v12 = 2;
        goto LABEL_33;
      }
    }
    uint64_t v12 = !capabilities::ct::supportsBB2GMitigation(Model_sync)
       || (uint64_t v13 = *(void *)(a1 + 456), *(unsigned char *)(v13 + 16) != 2)
       || *(_DWORD *)(v13 + 136) == 2;
    goto LABEL_33;
  }
  uint64_t v5 = *(void *)(a1 + 200);
  if (v5)
  {
    uint64_t v6 = a1 + 200;
    do
    {
      int v7 = *(_DWORD *)(v5 + 28);
      BOOL v8 = v7 < (int)a2;
      if (v7 >= (int)a2) {
        BOOL v9 = (uint64_t *)v5;
      }
      else {
        BOOL v9 = (uint64_t *)(v5 + 8);
      }
      if (!v8) {
        uint64_t v6 = v5;
      }
      uint64_t v5 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 200 && *(_DWORD *)(v6 + 28) <= (int)a2 && NRDisableStatus::isNSADisabledWithReason())
    {
      int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v23 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Squashing 5G user preference to LTE due to NR disable status %s", buf, 0xCu);
      }
      goto LABEL_19;
    }
  }
  uint64_t v12 = 4;
LABEL_33:
  int v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asString();
    uint64_t v16 = asString();
    uint64_t v17 = asString();
    uint64_t v18 = asString();
    *(_DWORD *)std::string buf = 136315906;
    uint64_t v23 = v15;
    __int16 v24 = 2080;
    uint64_t v25 = v16;
    __int16 v26 = 2080;
    uint64_t v27 = v17;
    __int16 v28 = 2080;
    uint64_t v29 = v18;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Query to get the current max data rate, 5G(%s), LTE(%s), 3G(%s), result: %s", buf, 0x2Au);
  }
LABEL_35:
  if (v21) {
    sub_10004D2C8(v21);
  }
  return v12;
}

void sub_100F49FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F4A020(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v37 = asString();
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I 2G Switch support: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asString();
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v37 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I 2G User preference: %s", buf, 0xCu);
  }
  if (*(void *)(a1 + 472))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I 2G temporary enablement timer is running", buf, 2u);
    }
  }
  uint64_t v5 = *(void **)(a1 + 432);
  if (v5 != (void *)(a1 + 440))
  {
    uint64_t v6 = (uint64_t *)(a1 + 136);
    int v7 = (uint64_t *)(a1 + 112);
    do
    {
      BOOL v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v5 + 8));
      BOOL v9 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I 3G Switch support: %s", buf, 0xCu);
        BOOL v9 = *v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I LTE Switch support: %s", buf, 0xCu);
        BOOL v9 = *v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I 5G Switch support: %s", buf, 0xCu);
        BOOL v9 = *v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = v13;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I 3G User preference: %s", buf, 0xCu);
        BOOL v9 = *v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = v14;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I LTE User preference: %s", buf, 0xCu);
        BOOL v9 = *v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = asString();
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = v15;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I 5G User preference: %s", buf, 0xCu);
      }
      uint64_t v16 = *v6;
      if (*v6)
      {
        int v17 = *((_DWORD *)v5 + 8);
        uint64_t v18 = a1 + 136;
        do
        {
          int v19 = *(_DWORD *)(v16 + 32);
          BOOL v20 = v19 < v17;
          if (v19 >= v17) {
            int v21 = (uint64_t *)v16;
          }
          else {
            int v21 = (uint64_t *)(v16 + 8);
          }
          if (!v20) {
            uint64_t v18 = v16;
          }
          uint64_t v16 = *v21;
        }
        while (*v21);
        if ((uint64_t *)v18 != v6 && v17 >= *(_DWORD *)(v18 + 32))
        {
          uint64_t v22 = *v8;
          if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = asString();
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v37 = v23;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Bundle technology type: %s", buf, 0xCu);
          }
        }
      }
      uint64_t v24 = *v7;
      if (!*v7) {
        goto LABEL_44;
      }
      int v25 = *((_DWORD *)v5 + 8);
      uint64_t v26 = a1 + 112;
      do
      {
        int v27 = *(_DWORD *)(v24 + 28);
        BOOL v28 = v27 < v25;
        if (v27 >= v25) {
          uint64_t v29 = (uint64_t *)v24;
        }
        else {
          uint64_t v29 = (uint64_t *)(v24 + 8);
        }
        if (!v28) {
          uint64_t v26 = v24;
        }
        uint64_t v24 = *v29;
      }
      while (*v29);
      if ((uint64_t *)v26 != v7 && v25 >= *(_DWORD *)(v26 + 28)) {
        unsigned int v30 = *(_DWORD *)(v26 + 32);
      }
      else {
LABEL_44:
      }
        unsigned int v30 = 0;
      int v31 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        CFBooleanRef v32 = "Device Type unknown";
        if (v30 <= 3) {
          CFBooleanRef v32 = off_101A731D8[v30];
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v37 = (uint64_t)v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Device type: %s", buf, 0xCu);
      }
      int v33 = (void *)v5[1];
      if (v33)
      {
        do
        {
          BOOL v34 = v33;
          int v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          BOOL v34 = (void *)v5[2];
          BOOL v35 = *v34 == (void)v5;
          uint64_t v5 = v34;
        }
        while (!v35);
      }
      uint64_t v5 = v34;
    }
    while (v34 != (void *)(a1 + 440));
  }
}

void *sub_100F4A50C(void *a1)
{
  return a1;
}

void sub_100F4A548(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F4A648(uint64_t result, int a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    uint64_t v3 = result;
    uint64_t v5 = result;
    int v6 = a2;
    sub_100F564E8((uint64_t)&v7, a3);
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100F4A798(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4A7A8(int **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = 0;
  int v38 = 0;
  MaxDataRateManager::getModel_sync(a2, a3, &v37);
  int v6 = v37;
  if (!v37)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    goto LABEL_41;
  }
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v36 = 1065353216;
  if (v37[256] == 2)
  {
    sub_100F56C04((float *)&v34, 2, 2);
    if (!capabilities::ct::supportsBB2GMitigation(v7)
      || (uint64_t v8 = *(void *)(a2 + 456), *(unsigned char *)(v8 + 16) != 2)
      || *(_DWORD *)(v8 + 136) == 2)
    {
      sub_100F56C04((float *)&v34, 1, 1);
    }
  }
  BOOL v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a2 + 56));
  uint64_t v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  int v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      if (!v19) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
  if (!v19) {
    goto LABEL_18;
  }
LABEL_17:
  if (((*(uint64_t (**)(uint64_t))(*(void *)v19 + 16))(v19) & 1) == 0)
  {
    *(void *)std::string buf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a2 + 480) + 96))(v33);
    sub_1000057AC(buf, v33);
    sub_1000577C4(v33);
    if (*(_DWORD *)(a2 + 152) == a3 || !CFBooleanGetValue(*(CFBooleanRef *)buf))
    {
      char v21 = 0;
    }
    else
    {
      CFBooleanRef v32 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v33[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Hiding LTE switch for non-internal builds as HideLTEForNonPreferredSim is set to true", (uint8_t *)v33, 2u);
      }
      char v21 = 1;
    }
    sub_100062778((const void **)buf);
    if (v20) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
LABEL_18:
  char v21 = 0;
  if ((v20 & 1) == 0) {
LABEL_19:
  }
    sub_10004D2C8(v18);
LABEL_20:
  if (v6[748])
  {
    uint64_t v22 = *v9;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Hiding LTE switch for Multi SIM VoLTE-only mode", buf, 2u);
    }
  }
  else
  {
    if (v6[16] == 2) {
      char v23 = v21;
    }
    else {
      char v23 = 1;
    }
    if ((v23 & 1) == 0)
    {
      sub_100F56C04((float *)&v34, 3, 3);
      sub_100F56C04((float *)&v34, 2, 2);
    }
  }
  if (v6[136] == 2)
  {
    sub_100F56C04((float *)&v34, 4, 4);
    sub_100F56C04((float *)&v34, 3, 3);
  }
  uint64_t v24 = (uint64_t *)v35;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  int v25 = 0;
  if (v24)
  {
    uint64_t v26 = v24;
    do
    {
      int v25 = (int *)((char *)v25 + 1);
      uint64_t v26 = (void *)*v26;
    }
    while (v26);
    sub_100F4DCDC(a1, (unint64_t)v25);
    uint64_t v27 = 0;
    BOOL v28 = a1[1];
    do
    {
      v28[v27] = *((_DWORD *)v24 + 4);
      uint64_t v24 = (uint64_t *)*v24;
      ++v27;
    }
    while (v24);
    int v25 = &v28[v27];
    a1[1] = &v28[v27];
    uint64_t v29 = *a1;
  }
  else
  {
    uint64_t v29 = 0;
  }
  unint64_t v30 = 126 - 2 * __clz(v25 - v29);
  if (v25 == v29) {
    uint64_t v31 = 0;
  }
  else {
    uint64_t v31 = v30;
  }
  sub_100F4DD20(v29, v25, v31, 1);
  sub_100F56BB8((uint64_t)&v34);
LABEL_41:
  if (v38) {
    sub_10004D2C8(v38);
  }
}

void sub_100F4AB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, std::__shared_weak_count *);
  sub_100062778((const void **)va1);
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  sub_100F56BB8((uint64_t)va);
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F4AC30(uint64_t result, int a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    uint64_t v3 = result;
    uint64_t v5 = result;
    int v6 = a2;
    sub_100F56FEC((uint64_t)&v7, a3);
    char v4 = *(std::__shared_weak_count **)(v3 + 16);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100F4AD80(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4AD90(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v6 = a1;
  int v7 = a2;
  int v8 = a3;
  sub_100F5712C((uint64_t)&v9, a4);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4AECC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4AEDC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v24 = 0;
  int v25 = 0;
  MaxDataRateManager::getModel_sync(a1, a2, &v24);
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v9 = v8;
  if (v24)
  {
    if (a4 == 1) {
      sub_100F481BC(v24 + 600, a3);
    }
    uint64_t v10 = *v9;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = "false";
      if (a3) {
        uint64_t v12 = "true";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Device supports enable 3G option in system selection, sending it down with 3G set to %s", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 56));
    uint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      unsigned int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      char v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    char v20 = 0;
    char v22 = 1;
LABEL_18:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 360))(v21, a2, a4);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    goto LABEL_20;
  }
  char v23 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Unable to find model when setting 3G user prefrence", buf, 2u);
  }
LABEL_20:
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100F4B134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F4B174(uint64_t a1, int a2)
{
  char v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v5 = *(void *)(a1 + 136);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 136;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == a1 + 136 || *(_DWORD *)(v6 + 32) > a2)
  {
LABEL_11:
    char v10 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Bundle not found when checking for carrier and device LTE support", buf, 2u);
    }
LABEL_13:
    BOOL v11 = 0;
    int v12 = 0;
    return v11 | (v12 << 8);
  }
  if (!*(unsigned char *)(v6 + 41))
  {
    unsigned int v16 = *v4;
    BOOL v17 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
    BOOL v11 = 0;
    int v12 = 0;
    if (!v17) {
      return v11 | (v12 << 8);
    }
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle is not set up yet, cannot decide whether carrier supports LTE", buf, 2u);
    goto LABEL_13;
  }
  *(void *)std::string buf = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 480) + 96))(&v21);
  sub_1000057AC(buf, &v21);
  sub_1000577C4(&v21);
  uint64_t v21 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 480) + 96))(&v20);
  sub_1000057AC(&v21, &v20);
  sub_1000577C4(&v20);
  char v20 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 480) + 96))(&v19);
  sub_1000057AC(&v20, &v19);
  sub_1000577C4(&v19);
  if (*(void *)buf) {
    uint64_t v14 = sub_100084B4C;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v14 || (v21 ? (uint64_t v15 = sub_100084B4C) : (uint64_t v15 = 0), v15))
  {
    BOOL v11 = 1;
  }
  else
  {
    if (v20) {
      unsigned int v18 = sub_100084B4C;
    }
    else {
      unsigned int v18 = 0;
    }
    BOOL v11 = v18 != 0;
  }
  sub_100062778(&v20);
  sub_100062778(&v21);
  sub_100062778((const void **)buf);
  int v12 = 1;
  return v11 | (v12 << 8);
}

void sub_100F4B444(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  sub_1000577C4((const void **)va);
  sub_100062778((const void **)va1);
  sub_100062778((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL sub_100F4B498(uint64_t a1, uint64_t a2, char a3, int a4)
{
  BOOL v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  MaxDataRateManager::getModel_sync(a1, a2, &v20);
  uint64_t v9 = v20;
  if (v20)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 1174405120;
    dispatch_object_t v13[2] = sub_100F4BB24;
    void v13[3] = &unk_101A71B60;
    char v16 = a4;
    void v13[4] = a1;
    void v13[5] = v8;
    char v17 = a3;
    void v13[6] = v20;
    uint64_t v14 = v21;
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v15 = a2;
    char v10 = _Block_copy(v13);
    unsigned int v18 = v10;
    sub_100F4B904(a1, a2, a4, a3, (uint64_t)&v18);
    if (v10) {
      _Block_release(v10);
    }
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  else
  {
    BOOL v11 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Unable to find model when setting LTE user preference", buf, 2u);
    }
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  return v9 != 0;
}

void sub_100F4B634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v17) {
    _Block_release(v17);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F4B66C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v24 = 0;
  int v25 = 0;
  MaxDataRateManager::getModel_sync(a1, a2, &v24);
  BOOL v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v9 = v8;
  if (v24)
  {
    if (a4 == 1) {
      sub_100F481BC(v24 + 360, a3);
    }
    char v10 = *v9;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = "false";
      if (a3) {
        int v12 = "true";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Device supports enable 5G option in system selection, sending it down with 5G set to %s", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v11, *(Registry **)(a1 + 56));
    uint64_t v14 = ServiceMap;
    if (v15 < 0)
    {
      char v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)buf);
    if (v19)
    {
      uint64_t v21 = v19[3];
      uint64_t v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    uint64_t v20 = 0;
    char v22 = 1;
LABEL_18:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 344))(v21, a2, a4);
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    goto LABEL_20;
  }
  char v23 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Unable to find model when setting 5G user prefrence", buf, 2u);
  }
LABEL_20:
  if (v25) {
    sub_10004D2C8(v25);
  }
}

void sub_100F4B8C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100F4B904(uint64_t a1, uint64_t a2, int a3, char a4, uint64_t a5)
{
  if (a3 == 1 && (a4 & 1) != 0)
  {
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 480) + 96))(&cf);
    int v7 = (BOOL *)cf;
    char v23 = 0;
    if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFBooleanGetTypeID()) && (ctu::cf::assign((ctu::cf *)&v23, v7, v9), v23))
    {
      char v10 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v10 || (uint64_t v11 = *(void *)(a1 + 8), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v13 = v12;
      p_shared_weak_owners = &v12->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      global_queue = dispatch_get_global_queue(0, 0);
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 1174405120;
      void v19[2] = sub_100F4BF34;
      unint64_t v19[3] = &unk_101A71B90;
      void v19[4] = a1;
      v19[5] = v11;
      uint64_t v20 = v13;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      char v16 = *(void **)a5;
      if (*(void *)a5) {
        char v16 = _Block_copy(v16);
      }
      aBlock = v16;
      dispatch_async(global_queue, v19);
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (v20) {
        std::__shared_weak_count::__release_weak(v20);
      }
      std::__shared_weak_count::__release_weak(v13);
    }
    else
    {
      (*(void (**)(void))(*(void *)a5 + 16))();
    }
    return sub_1000577C4(&cf);
  }
  else
  {
    uint64_t v17 = *(uint64_t (**)(void))(*(void *)a5 + 16);
    return (const void **)v17();
  }
}

void sub_100F4BB08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100F4BB24(uint64_t a1, char a2)
{
  uint64_t v3 = (uint64_t *)__stack_chk_guard;
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(unsigned __int8 *)(a1 + 68);
  if (v5 == 1 && (a2 & 1) == 0)
  {
    uint64_t v6 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Not saving LTE enabled setting due to user canceling request", buf, 2u);
    }
    xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
    if (v7 || (xpc_object_t v7 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v7);
        xpc_object_t v8 = v7;
      }
      else
      {
        xpc_object_t v8 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v8 = xpc_null_create();
      xpc_object_t v7 = 0;
    }
    xpc_release(v7);
    *(void *)std::string buf = v8;
    if (v8) {
      xpc_retain(v8);
    }
    else {
      *(void *)std::string buf = xpc_null_create();
    }
    xpc_object_t v21 = xpc_null_create();
    xpc_object_t v22 = v21;
    sub_1000452AC(137, (xpc_object_t *)buf, &v22);
    xpc_release(v21);
    xpc_release(*(xpc_object_t *)buf);
    *(void *)std::string buf = 0;
    xpc_release(v8);
    (*(void (**)(void))(**(void **)(v4 + 512) + 160))(*(void *)(v4 + 512));
    return;
  }
  if (v5 != 3)
  {
    CFBooleanRef v9 = **(NSObject ***)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 69)) {
        char v10 = "true";
      }
      else {
        char v10 = "false";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      __int16 v24 = 2080;
      uint64_t v25 = asString();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Saving LTE user preference to %s due to %s", buf, 0x16u);
    }
    sub_100F481BC(*(void *)(a1 + 48) + 480, *(unsigned char *)(a1 + 69));
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v4 + 56));
  int v12 = ServiceMap;
  if (v13 < 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v17)
  {
    uint64_t v19 = 0;
    goto LABEL_23;
  }
  uint64_t v19 = v17[3];
  unsigned int v18 = (std::__shared_weak_count *)v17[4];
  if (!v18)
  {
LABEL_23:
    std::mutex::unlock(v12);
    unsigned int v18 = 0;
    char v20 = 1;
    goto LABEL_24;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
LABEL_24:
  if ((*(unsigned char *)(*(void *)(a1 + 48) + 256) & 0xFE) == 2) {
    (*(void (**)(uint64_t, void, void))(*(void *)v19 + 360))(v19, *(unsigned int *)(a1 + 64), *(unsigned __int8 *)(a1 + 68));
  }
  (*(void (**)(uint64_t, void, void))(*(void *)v19 + 352))(v19, *(unsigned int *)(a1 + 64), *(unsigned __int8 *)(a1 + 68));
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_100F4BE84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F4BF08(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100F4BF24(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

const void **sub_100F4BF34(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Showing pop-up for LTE enable warning", buf, 2u);
  }
  CFStringRef v15 = 0;
  (*(void (**)(const __CFString **__return_ptr))(**(void **)(v2 + 496) + 16))(&v15);
  CFStringRef v14 = 0;
  (*(void (**)(const __CFString **__return_ptr))(**(void **)(v2 + 496) + 16))(&v14);
  CFStringRef v13 = 0;
  (*(void (**)(const __CFString **__return_ptr))(**(void **)(v2 + 496) + 16))(&v13);
  CFStringRef v12 = 0;
  (*(void (**)(const __CFString **__return_ptr))(**(void **)(v2 + 496) + 16))(&v12);
  CFOptionFlags responseFlags = 0;
  CFUserNotificationDisplayAlert(0.0, 2uLL, 0, 0, 0, v15, v14, v13, v12, 0, &responseFlags);
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = responseFlags;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I response flags: %ld", buf, 0xCu);
  }
  int v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = a1[5];
      if (v7)
      {
        xpc_object_t v8 = (const void *)a1[7];
        if (v8) {
          _Block_copy(v8);
        }
        CFBooleanRef v9 = *(std::__shared_weak_count **)(v7 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v6);
    }
  }
  sub_1000558F4((const void **)&v12);
  sub_1000558F4((const void **)&v13);
  sub_1000558F4((const void **)&v14);
  return sub_1000558F4((const void **)&v15);
}

void sub_100F4C29C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F4C308(void *a1, void *a2)
{
  uint64_t v3 = a2[6];
  a1[5] = a2[5];
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[7];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[7] = result;
  return result;
}

void sub_100F4C354(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 56);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100F4C3A8(uint64_t a1, char a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 88);
  if (v3 != 1 || (a2 & 1) != 0)
  {
    if (v3 != 3)
    {
      int v5 = **(NSObject ***)(a1 + 32);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Saving user preference to LTE", v7, 2u);
      }
      sub_100F481BC(*(void *)(a1 + 40) + 600, 1);
      sub_100F481BC(*(void *)(a1 + 40) + 480, 1);
      sub_100F481BC(*(void *)(a1 + 40) + 360, 0);
    }
    uint64_t v6 = *(void *)(a1 + 80);
    if (!v6) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
  }
  else
  {
    uint64_t v4 = **(NSObject ***)(a1 + 32);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Not saving LTE enabled setting due to user canceling request", buf, 2u);
    }
  }
}

uint64_t sub_100F4C4CC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return sub_1000F0058(a1 + 56, a2 + 56);
}

void sub_100F4C510(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F4C528(uint64_t a1)
{
  sub_10003B34C((void *)(a1 + 56));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100F4C574(uint64_t a1, int a2, uint64_t a3)
{
  if (capabilities::ct::supportsBB2GMitigation((capabilities::ct *)a1))
  {
    if (a3 == 1)
    {
      uint64_t v6 = *(void *)(a1 + 456);
      uint64_t v7 = *(void *)(v6 + 232);
      if (v7)
      {
        *(void *)std::string buf = *(void *)(v6 + 128);
        char v25 = a2;
        (*(void (**)(uint64_t, unsigned char *, char *))(*(void *)v7 + 48))(v7, buf, &v25);
        uint64_t v8 = *(void *)(v6 + 168);
        if (v8) {
          LODWORD(v8) = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
        }
        *(_DWORD *)(v6 + 136) = v8;
      }
      uint64_t v9 = *(void *)(a1 + 472);
      if (v9)
      {
        char v10 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = "disables";
          if (a2) {
            uint64_t v11 = "enables";
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I User %s 2G while temporary timer is running. Reset timer", buf, 0xCu);
          uint64_t v9 = *(void *)(a1 + 472);
          *(void *)(a1 + 472) = 0;
          if (!v9) {
            goto LABEL_15;
          }
        }
        else
        {
          *(void *)(a1 + 472) = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
    }
LABEL_15:
    CFStringRef v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v14 = "false";
      if (a2) {
        CFStringRef v14 = "true";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Device supports enable 2G option in system selection, sending it down with 2G set to %s", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *(Registry **)(a1 + 56));
    unsigned int v16 = ServiceMap;
    if (v17 < 0)
    {
      unsigned int v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v17;
    xpc_object_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
    if (v21)
    {
      uint64_t v23 = v21[3];
      xpc_object_t v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v16);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v16);
    xpc_object_t v22 = 0;
    char v24 = 1;
LABEL_27:
    (*(void (**)(uint64_t, uint64_t))(*(void *)v23 + 368))(v23, a3);
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
  }
}

void sub_100F4C840(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100F4C870(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_100F57778;
  double v5[3] = &unk_101A73128;
  void v5[4] = a1 + 8;
  void v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  char v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005B428;
    char v10 = &unk_101A73168;
    uint64_t v11 = &v13;
    CFStringRef v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005A6C4;
    char v10 = &unk_101A73148;
    uint64_t v11 = &v13;
    CFStringRef v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100F4C9A0(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100F577B4((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4CAE8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4CAF8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100F577B4((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4CC40(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4CC50(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_100F577B4((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4CD98(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F4CDA8(uint64_t result, uint64_t a2)
{
  if (*(void *)(a2 + 24))
  {
    uint64_t v2 = result;
    uint64_t v4 = result;
    sub_100F577B4((uint64_t)&v5, a2);
    int v3 = *(std::__shared_weak_count **)(v2 + 16);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_100F4CEE4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4CEF4(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5 = a1;
  char v6 = a2;
  sub_100F5712C((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4D03C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F4D04C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a2 & 0x8000000000000000) == 0 || !*(void *)(a3 + 24))
  {
    *(void *)std::string buf = a1;
    *(void *)&uint8_t buf[8] = a2;
    sub_100023950((uint64_t)&v9, a3);
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  char v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Unable to enable 2G with a negative duration", buf, 2u);
  }
  return sub_1000607A8(a3, 0);
}

void sub_100F4D1E4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4D1F4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  sub_1003357B4((uint64_t)&v7, a3);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4D33C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100F4D34C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 184) != a2)
  {
    int v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I 5G activation support is now (%s)", (uint8_t *)&v4, 0xCu);
    }
    sub_100F489C4(a1);
  }
}

uint64_t sub_100F4D410(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (a2[2] == *(void *)(result + 208))
  {
    int v3 = a2 + 1;
    int v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return result;
    }
    uint64_t v5 = *(void **)(result + 192);
    while (*((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7))
    {
      uint64_t result = NRDisableStatus::operator==();
      if (!result) {
        break;
      }
      int v6 = (void *)v4[1];
      uint64_t v7 = v4;
      if (v6)
      {
        do
        {
          int v4 = v6;
          int v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v4 = (void *)v7[2];
          BOOL v8 = *v4 == (void)v7;
          uint64_t v7 = v4;
        }
        while (!v8);
      }
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          char v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          char v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v8);
      }
      uint64_t v5 = v10;
      if (v4 == v3) {
        return result;
      }
    }
  }
  uint64_t v11 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I NR disable status changed, notifying clients", buf, 2u);
  }
  xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
  if (v12 || (xpc_object_t v12 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v12);
      xpc_object_t v13 = v12;
    }
    else
    {
      xpc_object_t v13 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v13 = xpc_null_create();
    xpc_object_t v12 = 0;
  }
  xpc_release(v12);
  *(void *)std::string buf = v13;
  if (v13) {
    xpc_retain(v13);
  }
  else {
    *(void *)std::string buf = xpc_null_create();
  }
  xpc_object_t v14 = xpc_null_create();
  xpc_object_t v15 = v14;
  sub_1000452AC(137, (xpc_object_t *)buf, &v15);
  xpc_release(v14);
  xpc_release(*(xpc_object_t *)buf);
  *(void *)std::string buf = 0;
  xpc_release(v13);
  return (*(uint64_t (**)(void))(**(void **)(v2 + 512) + 160))(*(void *)(v2 + 512));
}

void sub_100F4D624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(v12);
  xpc_release(object);
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_100F4D66C(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 256) == a2[2])
  {
    int v4 = *(void **)(a1 + 240);
    if (v4 == (void *)(a1 + 248)) {
      return;
    }
    uint64_t v5 = (void *)*a2;
    while (*((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7))
    {
      int v6 = *((unsigned __int8 *)v5 + 33);
      if (*((unsigned char *)v4 + 33)) {
        BOOL v7 = v6 == 0;
      }
      else {
        BOOL v7 = 1;
      }
      if (v7)
      {
        if ((*((unsigned char *)v4 + 33) != 0) != (v6 != 0)) {
          break;
        }
      }
      else if (*((unsigned __int8 *)v4 + 32) != *((unsigned __int8 *)v5 + 32))
      {
        break;
      }
      BOOL v8 = (void *)v4[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          BOOL v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v4[2];
          BOOL v7 = *v9 == (void)v4;
          int v4 = v9;
        }
        while (!v7);
      }
      char v10 = (void *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          char v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v5[2];
          BOOL v7 = *v11 == (void)v5;
          uint64_t v5 = v11;
        }
        while (!v7);
      }
      uint64_t v5 = v11;
      int v4 = v9;
      if (v9 == (void *)(a1 + 248)) {
        return;
      }
    }
  }
  subscriber::makeSimSlotRange();
  xpc_object_t v13 = v46;
  xpc_object_t v12 = v47;
  if (v46 != v47)
  {
    xpc_object_t v14 = v48;
    while ((v48(*v13) & 1) == 0)
    {
      if (++v13 == v47)
      {
        xpc_object_t v13 = v47;
        break;
      }
    }
    xpc_object_t v15 = v47;
    if (v13 != v47)
    {
      int v44 = a2 + 1;
      unsigned int v16 = (uint64_t *)(a1 + 248);
      while (1)
      {
        uint64_t v17 = *v13;
        unsigned int v18 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v17);
        if (sub_100F49D10(a1, v17) - 1 > 1) {
          break;
        }
        uint64_t v19 = *v18;
        if (os_log_type_enabled(*v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = asString();
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I User selected %s. CS voice support ignored", (uint8_t *)&buf, 0xCu);
        }
LABEL_78:
        int v39 = v13 + 1;
        xpc_object_t v13 = v12;
        if (v39 != v12)
        {
          xpc_object_t v13 = v39;
          while ((v14(*v13) & 1) == 0)
          {
            if (++v13 == v12)
            {
              xpc_object_t v13 = v12;
              break;
            }
          }
        }
        if (v13 == v15) {
          return;
        }
      }
      long long buf = 0uLL;
      uint64_t v50 = 0;
      sub_100F4A7A8((int **)&buf, a1, v17);
      xpc_object_t v21 = (void *)buf;
      xpc_object_t v22 = (_DWORD *)buf;
      if ((void)buf != *((void *)&buf + 1))
      {
        xpc_object_t v22 = (_DWORD *)buf;
        while ((*v22 - 1) >= 2)
        {
          if (++v22 == *((_DWORD **)&buf + 1)) {
            goto LABEL_51;
          }
        }
      }
      if (v22 == *((_DWORD **)&buf + 1))
      {
LABEL_51:
        uint64_t v29 = *v18;
        if (os_log_type_enabled(*v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v45 = 0;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I 2G/3G not supported. CS voice support ignored", v45, 2u);
        }
        int v30 = 3;
        if (v21) {
          goto LABEL_75;
        }
        goto LABEL_76;
      }
      uint64_t v23 = v44;
      uint64_t v24 = *v44;
      if (*v44)
      {
        do
        {
          int v25 = *(_DWORD *)(v24 + 28);
          BOOL v26 = v25 < (int)v17;
          if (v25 >= (int)v17) {
            uint64_t v27 = (uint64_t *)v24;
          }
          else {
            uint64_t v27 = (uint64_t *)(v24 + 8);
          }
          if (!v26) {
            uint64_t v23 = (void *)v24;
          }
          uint64_t v24 = *v27;
        }
        while (*v27);
        if (v23 == v44 || *((_DWORD *)v23 + 7) > (int)v17)
        {
          int v28 = 0;
          LODWORD(v24) = 0;
        }
        else
        {
          unsigned int v31 = *((unsigned __int16 *)v23 + 16);
          int v28 = *((_WORD *)v23 + 16);
          LODWORD(v24) = v31 >> 8;
        }
      }
      else
      {
        int v28 = 0;
      }
      if (v24) {
        BOOL v32 = v28 == 0;
      }
      else {
        BOOL v32 = 0;
      }
      int v33 = !v32;
      uint64_t v34 = *v16;
      if (!*v16) {
        goto LABEL_73;
      }
      uint64_t v35 = a1 + 248;
      do
      {
        int v36 = *(_DWORD *)(v34 + 28);
        BOOL v37 = v36 < (int)v17;
        if (v36 >= (int)v17) {
          int v38 = (uint64_t *)v34;
        }
        else {
          int v38 = (uint64_t *)(v34 + 8);
        }
        if (!v37) {
          uint64_t v35 = v34;
        }
        uint64_t v34 = *v38;
      }
      while (*v38);
      if ((uint64_t *)v35 != v16 && *(_DWORD *)(v35 + 28) <= (int)v17)
      {
        unsigned int v40 = *(unsigned __int16 *)(v35 + 32);
        if ((_BYTE)v40) {
          BOOL v41 = 0;
        }
        else {
          BOOL v41 = v40 >= 0x100;
        }
        int v42 = !v41;
        if (v33 == v42)
        {
LABEL_74:
          int v30 = 0;
          if ((void)buf) {
LABEL_75:
          }
            operator delete(v21);
LABEL_76:
          if (v30 != 3 && v30) {
            return;
          }
          goto LABEL_78;
        }
      }
      else
      {
LABEL_73:
        if (v33) {
          goto LABEL_74;
        }
      }
      CFBooleanRef v43 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v45 = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I CS voice support changed, notifying clients", v45, 2u);
      }
      (*(void (**)(void))(**(void **)(a1 + 512) + 160))(*(void *)(a1 + 512));
      int v30 = 1;
      if (v21) {
        goto LABEL_75;
      }
      goto LABEL_76;
    }
  }
}

void sub_100F4DAF0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100F4DB10(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A71CC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F4DB30(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A71CC8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100F4DB84(void *a1)
{
  sub_10024FA8C((ctu::OsLogLogger *)(a1 + 93));
  sub_100F4E730(a1 + 89);
  sub_100F4E5A4(a1 + 85);
  sub_100F4E6AC(a1 + 81);
  sub_100F4E730(a1 + 74);
  sub_100F4E5A4(a1 + 70);
  sub_100F4E6AC(a1 + 66);
  sub_100F4E730(a1 + 59);
  sub_100F4E5A4(a1 + 55);
  sub_100F4E6AC(a1 + 51);
  sub_100F4E628(a1 + 44);
  sub_100F4E5A4(a1 + 40);
  sub_100F4E520(a1 + 36);
  sub_100F4E628(a1 + 29);
  sub_100F4E5A4(a1 + 25);
  sub_100F4E520(a1 + 21);
  sub_100F4E628(a1 + 14);
  sub_100F4E5A4(a1 + 10);

  return sub_100F4E520(a1 + 6);
}

void *sub_100F4DC4C(void *a1)
{
  return a1;
}

void *sub_100F4DC88(void *a1, char *a2, char **a3)
{
  uint64_t v5 = sub_100058DB0(a1, a2);
  sub_100058DB0(v5 + 3, *a3);
  return a1;
}

void sub_100F4DCC0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100F4DCDC(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_10006A748();
  }
  uint64_t result = (char *)operator new(4 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * a2];
  return result;
}

int *sub_100F4DD20(int *result, int *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    char v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                int v39 = *(a2 - 1);
                int v40 = *v10;
                if (v39 < *v10)
                {
                  int *v10 = v39;
                  *(a2 - 1) = v40;
                }
                break;
              case 3uLL:
                uint64_t result = sub_100050AC0(v10, v10 + 1, a2 - 1);
                break;
              case 4uLL:
                uint64_t result = sub_100054A64(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5uLL:
                uint64_t result = sub_1008568F4(v10, v10 + 1, v10 + 2, v10 + 3, a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 95)
          {
            BOOL v41 = v10 + 1;
            BOOL v43 = v10 == a2 || v41 == a2;
            if (a4)
            {
              if (!v43)
              {
                uint64_t v44 = 4;
                uint64_t v45 = v10;
                do
                {
                  int v47 = *v45;
                  int v46 = v45[1];
                  uint64_t v45 = v41;
                  if (v46 < v47)
                  {
                    uint64_t v48 = v44;
                    do
                    {
                      *(int *)((char *)v10 + v48) = v47;
                      uint64_t v49 = v48 - 4;
                      if (v48 == 4)
                      {
                        uint64_t v50 = v10;
                        goto LABEL_82;
                      }
                      int v47 = *(int *)((char *)v10 + v48 - 8);
                      v48 -= 4;
                    }
                    while (v46 < v47);
                    uint64_t v50 = (int *)((char *)v10 + v49);
LABEL_82:
                    int *v50 = v46;
                  }
                  BOOL v41 = v45 + 1;
                  v44 += 4;
                }
                while (v45 + 1 != a2);
              }
            }
            else if (!v43)
            {
              do
              {
                int v79 = *v9;
                int v78 = v9[1];
                uint64_t v9 = v41;
                if (v78 < v79)
                {
                  do
                  {
                    *BOOL v41 = v79;
                    int v79 = *(v41 - 2);
                    --v41;
                  }
                  while (v78 < v79);
                  *BOOL v41 = v78;
                }
                BOOL v41 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v51 = (v12 - 2) >> 1;
              int64_t v52 = v51;
              do
              {
                int64_t v53 = v52;
                if (v51 >= v52)
                {
                  uint64_t v54 = (2 * v52) | 1;
                  CFBooleanRef v55 = &v10[v54];
                  if (2 * v53 + 2 < (uint64_t)v12)
                  {
                    int v57 = *v55;
                    int v56 = v55[1];
                    if (*v55 <= v56) {
                      int v57 = v55[1];
                    }
                    if (*v55 < v56)
                    {
                      ++v55;
                      uint64_t v54 = 2 * v53 + 2;
                    }
                  }
                  else
                  {
                    int v57 = *v55;
                  }
                  unsigned int v58 = &v10[v53];
                  int v59 = *v58;
                  if (v57 >= *v58)
                  {
                    do
                    {
                      uint64_t v60 = v55;
                      int *v58 = v57;
                      if (v51 < v54) {
                        break;
                      }
                      uint64_t v61 = (2 * v54) | 1;
                      CFBooleanRef v55 = &v10[v61];
                      uint64_t v54 = 2 * v54 + 2;
                      if (v54 < (uint64_t)v12)
                      {
                        int v57 = *v55;
                        uint64_t result = v55 + 1;
                        int v62 = v55[1];
                        if (*v55 <= v62) {
                          int v57 = v55[1];
                        }
                        if (*v55 >= v62) {
                          uint64_t v54 = v61;
                        }
                        else {
                          ++v55;
                        }
                      }
                      else
                      {
                        int v57 = *v55;
                        uint64_t v54 = v61;
                      }
                      unsigned int v58 = v60;
                    }
                    while (v57 >= v59);
                    int *v60 = v59;
                  }
                }
                int64_t v52 = v53 - 1;
              }
              while (v53);
              uint64_t v63 = (unint64_t)v11 >> 2;
              do
              {
                uint64_t v64 = 0;
                int v65 = *v10;
                uint64_t v66 = v10;
                do
                {
                  int v67 = &v66[v64 + 1];
                  uint64_t v68 = (2 * v64) | 1;
                  uint64_t v64 = 2 * v64 + 2;
                  if (v64 < v63)
                  {
                    int v70 = *v67;
                    int v69 = v67[1];
                    if (*v67 <= v69) {
                      int v70 = v67[1];
                    }
                    if (*v67 >= v69) {
                      uint64_t v64 = v68;
                    }
                    else {
                      ++v67;
                    }
                  }
                  else
                  {
                    int v70 = *v67;
                    uint64_t v64 = v68;
                  }
                  *uint64_t v66 = v70;
                  uint64_t v66 = v67;
                }
                while (v64 <= (uint64_t)((unint64_t)(v63 - 2) >> 1));
                if (v67 == --a2)
                {
                  int *v67 = v65;
                }
                else
                {
                  int *v67 = *a2;
                  *a2 = v65;
                  uint64_t v71 = (char *)v67 - (char *)v10 + 4;
                  if (v71 >= 5)
                  {
                    unint64_t v72 = (((unint64_t)v71 >> 2) - 2) >> 1;
                    uint64_t v73 = &v10[v72];
                    int v74 = *v73;
                    int v75 = *v67;
                    if (*v73 < *v67)
                    {
                      do
                      {
                        uint64_t v76 = v73;
                        int *v67 = v74;
                        if (!v72) {
                          break;
                        }
                        unint64_t v72 = (v72 - 1) >> 1;
                        uint64_t v73 = &v10[v72];
                        int v74 = *v73;
                        int v67 = v76;
                      }
                      while (*v73 < v75);
                      *uint64_t v76 = v75;
                    }
                  }
                }
              }
              while (v63-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          xpc_object_t v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x201)
          {
            sub_100050AC0(v9, &v9[v12 >> 1], a2 - 1);
            sub_100050AC0(v9 + 1, v14 - 1, a2 - 2);
            sub_100050AC0(v9 + 2, &v9[v13 + 1], a2 - 3);
            uint64_t result = sub_100050AC0(v14 - 1, v14, &v9[v13 + 1]);
            int v15 = *v9;
            int *v9 = *v14;
            *xpc_object_t v14 = v15;
          }
          else
          {
            uint64_t result = sub_100050AC0(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          int v16 = *v9;
          if ((a4 & 1) != 0 || *(v9 - 1) < v16) {
            break;
          }
          if (v16 >= *(a2 - 1))
          {
            unsigned int v31 = v9 + 1;
            do
            {
              char v10 = v31;
              if (v31 >= a2) {
                break;
              }
              ++v31;
            }
            while (v16 >= *v10);
          }
          else
          {
            char v10 = v9;
            do
            {
              int v30 = v10[1];
              ++v10;
            }
            while (v16 >= v30);
          }
          BOOL v32 = a2;
          if (v10 < a2)
          {
            BOOL v32 = a2;
            do
              int v33 = *--v32;
            while (v16 < v33);
          }
          if (v10 < v32)
          {
            int v34 = *v10;
            int v35 = *v32;
            do
            {
              int *v10 = v35;
              *BOOL v32 = v34;
              do
              {
                int v36 = v10[1];
                ++v10;
                int v34 = v36;
              }
              while (v16 >= v36);
              do
              {
                int v37 = *--v32;
                int v35 = v37;
              }
              while (v16 < v37);
            }
            while (v10 < v32);
          }
          int v38 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            int *v9 = *v38;
          }
          a4 = 0;
          *int v38 = v16;
        }
        uint64_t v17 = 0;
        do
          int v18 = v9[++v17];
        while (v18 < v16);
        uint64_t v19 = &v9[v17];
        uint64_t v20 = a2;
        if (v17 == 1)
        {
          uint64_t v20 = a2;
          do
          {
            if (v19 >= v20) {
              break;
            }
            int v22 = *--v20;
          }
          while (v22 >= v16);
        }
        else
        {
          do
            int v21 = *--v20;
          while (v21 >= v16);
        }
        if (v19 >= v20)
        {
          int v28 = v19 - 1;
        }
        else
        {
          int v23 = *v20;
          uint64_t v24 = v20;
          int v25 = &v9[v17];
          do
          {
            int *v25 = v23;
            *uint64_t v24 = v18;
            do
            {
              int v26 = v25[1];
              ++v25;
              int v18 = v26;
            }
            while (v26 < v16);
            do
            {
              int v27 = *--v24;
              int v23 = v27;
            }
            while (v27 >= v16);
          }
          while (v25 < v24);
          int v28 = v25 - 1;
        }
        if (v28 != v9) {
          int *v9 = *v28;
        }
        int *v28 = v16;
        if (v19 >= v20) {
          break;
        }
LABEL_33:
        uint64_t result = (int *)sub_100F4DD20(v9, v28, a3, a4 & 1);
        a4 = 0;
        char v10 = v28 + 1;
      }
      BOOL v29 = sub_100F4E3A0(v9, v28);
      char v10 = v28 + 1;
      uint64_t result = (int *)sub_100F4E3A0(v28 + 1, a2);
      if (result) {
        break;
      }
      if (!v29) {
        goto LABEL_33;
      }
    }
    a2 = v28;
    if (!v29) {
      continue;
    }
    return result;
  }
}

BOOL sub_100F4E3A0(int *a1, int *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 1);
      int v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_100050AC0(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_100054A64(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1008568F4(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      BOOL v8 = a1 + 2;
      sub_100050AC0(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 12;
      break;
  }
  while (1)
  {
    int v12 = *v9;
    int v13 = *v8;
    if (*v9 < *v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(int *)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 4;
        if (v14 == 4) {
          break;
        }
        int v13 = *(int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= v13)
        {
          int v16 = (int *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      int v16 = a1;
LABEL_12:
      *int v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    BOOL v8 = v9;
    v11 += 4;
    if (++v9 == a2) {
      return 1;
    }
  }
}

void *sub_100F4E520(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F4E5A4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F4E628(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F4E6AC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100F4E730(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100F4E7B8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100F4E7F0(uint64_t a1)
{
}

uint64_t sub_100F4E80C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100F4E850(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100F4E87C(ServiceManager::Service *this)
{
  *(void *)this = off_101A71E10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F4E8D8(ServiceManager::Service *this)
{
  *(void *)this = off_101A71E10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100F4E948@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "MaxDataRateManager");
}

unsigned char *sub_100F4E958@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  BOOL result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100F4E998(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100F43D1C(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100F43D1C(v4, 0);
}

uint64_t sub_100F4EA1C()
{
  return 1;
}

uint64_t sub_100F4EA24()
{
  return 1;
}

uint64_t sub_100F4EA2C()
{
  return 2;
}

void sub_100F4EA34(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  int v6 = *a3;
  dispatch_object_t v7 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_100F43E1C(v4, v5, &v7);
  }
  sub_100F43E1C(v4, v5, &v7);
}

void sub_100F4EAE4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4EBC4(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100F4ECD8(ServiceManager::Service *this)
{
  *(void *)this = off_101A71E10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100F4ED34(ServiceManager::Service *this)
{
  *(void *)this = off_101A71E10;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100F4EDA4()
{
  return 0;
}

uint64_t sub_100F4EDAC()
{
  return 0;
}

void sub_100F4EDBC()
{
}

uint64_t sub_100F4EDD0(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100F4EDDC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A71EB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100F4EDFC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A71EB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100F4EE50(void *a1)
{
  sub_100F4E730(a1 + 29);
  sub_100F4E5A4(a1 + 25);
  sub_100F4E6AC(a1 + 21);
  sub_100F4E628(a1 + 14);
  sub_100F4E5A4(a1 + 10);

  return sub_100F4E520(a1 + 6);
}

void *sub_100F4EEB0(void *a1, uint64_t a2)
{
  sub_100F4F14C((uint64_t)v6, a2);
  if (v6 != a1)
  {
    uint64_t v3 = v7;
    uint64_t v4 = (void *)a1[3];
    if (v7 == v6)
    {
      if (v4 == a1)
      {
        memset(v8, 0, sizeof(v8));
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, v8);
        (*(void (**)(void *))(*v7 + 32))(v7);
        dispatch_object_t v7 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v6);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        dispatch_object_t v7 = v6;
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, a1);
        (*(void (**)(void *))(v8[0] + 32))(v8);
      }
      else
      {
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a1);
        (*(void (**)(void *))(*v7 + 32))(v7);
        dispatch_object_t v7 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v4 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v6);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v7;
      dispatch_object_t v7 = v6;
    }
    else
    {
      dispatch_object_t v7 = (void *)a1[3];
      a1[3] = v3;
    }
  }
  sub_100F4E6AC(v6);
  return a1;
}

void sub_100F4F140(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F4F14C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_100F4F1E8()
{
}

__n128 sub_100F4F1FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A71F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F4F248(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A71F08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F4F278(uint64_t a1)
{
  void (*v10)(CFTypeRef *__return_ptr);
  BOOL v11;
  BOOL *v12;
  CFTypeID v13;
  CFBooleanRef v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  CFTypeRef cf;
  BOOL v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  char v23;
  unsigned char buf[12];
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  const char *v28;

  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  int v21 = 0;
  int v22 = 0;
  MaxDataRateManager::getModel_sync(v1, v2, &v21);
  if (v21)
  {
    int v4 = *(unsigned __int8 *)(v21 + 136);
    if ((v4 - 2) >= 2)
    {
      uint64_t v7 = v4 == 1;
      xpc_object_t v5 = "default value";
    }
    else
    {
      uint64_t v20 = 0;
      if (sub_100F44100(v1, v2, *(const __CFString ***)(v21 + 368), &v20))
      {
        xpc_object_t v5 = "user preference";
      }
      else
      {
        *(void *)long long buf = 0;
        (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v1 + 480) + 96))(&cf);
        sub_1000057AC(buf, &cf);
        sub_1000577C4(&cf);
        if (*(void *)buf) {
          uint64_t v9 = sub_100084B4C;
        }
        else {
          uint64_t v9 = 0;
        }
        if (v9)
        {
          LOBYTE(cf) = 0;
          ctu::cf::assign((ctu::cf *)&cf, *(BOOL **)buf, v8);
          uint64_t v20 = (char)cf;
          xpc_object_t v5 = "carrier bundle";
        }
        else
        {
          int v10 = *(void (**)(CFTypeRef *__return_ptr))(**(void **)(v1 + 480) + 96);
          uint64_t v11 = 1;
          v10(&cf);
          int v12 = (BOOL *)cf;
          int v23 = 1;
          if (cf)
          {
            int v13 = CFGetTypeID(cf);
            if (v13 == CFBooleanGetTypeID())
            {
              ctu::cf::assign((ctu::cf *)&v23, v12, v14);
              uint64_t v11 = v23;
            }
            else
            {
              uint64_t v11 = 1;
            }
          }
          uint64_t v20 = v11;
          sub_1000577C4(&cf);
          xpc_object_t v5 = "smart data mode";
        }
        sub_100062778((const void **)buf);
      }
      if (v20) {
        uint64_t v7 = 2;
      }
      else {
        uint64_t v7 = 3;
      }
    }
    uint64_t v15 = *v3;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = asString();
      uint64_t v17 = asString();
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v16;
      int v25 = 2080;
      int v26 = v17;
      int v27 = 2080;
      int v28 = v5;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I User preference: Enable 5G: %s with %s; based on %s",
        buf,
        0x20u);
    }
  }
  else
  {
    int v6 = *v3;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Unable to find model when getting 5G user preference", buf, 2u);
    }
    uint64_t v7 = 0;
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
  return v7;
}

void sub_100F4F59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, std::__shared_weak_count *a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100062778((const void **)va);
  if (a6) {
    sub_10004D2C8(a6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F4F5F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F4F630()
{
}

void *sub_100F4F63C(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      CFBooleanRef v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      CFBooleanRef v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    CFBooleanRef v8 = 0;
  }
  if (v7 != a1)
  {
    int v4 = v8;
    xpc_object_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        CFBooleanRef v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      CFBooleanRef v8 = v7;
    }
    else
    {
      CFBooleanRef v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100F4E730(v7);
  return a1;
}

void sub_100F4F940(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F4F950()
{
}

__n128 sub_100F4F964(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A71F98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F4F9B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A71F98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F4F9E0(uint64_t a1, const __CFString ***a2, unsigned __int8 *a3)
{
}

uint64_t sub_100F4F9FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F4FA3C()
{
}

void *sub_100F4FA48(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      CFBooleanRef v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      CFBooleanRef v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    CFBooleanRef v8 = 0;
  }
  if (v7 != a1)
  {
    int v4 = v8;
    xpc_object_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        CFBooleanRef v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      CFBooleanRef v8 = v7;
    }
    else
    {
      CFBooleanRef v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100F4E5A4(v7);
  return a1;
}

void sub_100F4FD4C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F4FD5C()
{
}

__n128 sub_100F4FD70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F4FDBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F4FDEC(uint64_t a1, const __CFString ***a2)
{
}

uint64_t sub_100F4FE00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F4FE40()
{
}

void *sub_100F4FE4C(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      CFBooleanRef v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      CFBooleanRef v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    CFBooleanRef v8 = 0;
  }
  if (v7 != a1)
  {
    int v4 = v8;
    xpc_object_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        CFBooleanRef v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      CFBooleanRef v8 = v7;
    }
    else
    {
      CFBooleanRef v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100F4E520(v7);
  return a1;
}

void sub_100F50150(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F50160()
{
}

__n128 sub_100F50174(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A720B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F501C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A720B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unsigned __int8 *sub_100F501F0(uint64_t a1, const __CFString ***a2)
{
  return sub_100F44504(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16), *a2);
}

uint64_t sub_100F50204(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50244()
{
}

void *sub_100F50250(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      CFBooleanRef v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      CFBooleanRef v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    CFBooleanRef v8 = 0;
  }
  if (v7 != a1)
  {
    int v4 = v8;
    xpc_object_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        CFBooleanRef v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        CFBooleanRef v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      CFBooleanRef v8 = v7;
    }
    else
    {
      CFBooleanRef v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100F4E628(v7);
  return a1;
}

void sub_100F50554(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100F50564()
{
}

__n128 sub_100F50578(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72148;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F505C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72148;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F505F4(uint64_t a1, const __CFString ***a2, unsigned __int8 *a3)
{
}

uint64_t sub_100F50610(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50650()
{
}

void sub_100F50660()
{
}

__n128 sub_100F50674(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A721D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F506C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A721D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F506F0(uint64_t a1, const __CFString ***a2)
{
}

uint64_t sub_100F50704(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50744()
{
}

void sub_100F50754()
{
}

__n128 sub_100F50768(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F507B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72258;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F507E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  MaxDataRateManager::getModel_sync(v1, v2, &v16);
  if (v16)
  {
    int v4 = *(unsigned __int8 *)(v16 + 16);
    if ((v4 - 2) >= 2)
    {
      uint64_t v7 = v4 == 1;
      xpc_object_t v5 = "default value";
    }
    else
    {
      char v15 = 1;
      if (sub_100F44100(v1, v2, *(const __CFString ***)(v16 + 488), (BOOL *)&v15))
      {
        xpc_object_t v5 = "user preference";
      }
      else
      {
        *(void *)long long buf = 0;
        (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v1 + 480) + 96))(&v14);
        sub_1000057AC(buf, &v14);
        sub_1000577C4(&v14);
        if (*(void *)buf) {
          uint64_t v9 = sub_100084B4C;
        }
        else {
          uint64_t v9 = 0;
        }
        if (v9)
        {
          LOBYTE(v14) = 1;
          ctu::cf::assign((ctu::cf *)&v14, *(BOOL **)buf, v8);
          char v15 = (char)v14;
          xpc_object_t v5 = "carrier bundle";
        }
        else
        {
          xpc_object_t v5 = "default value";
        }
        sub_100062778((const void **)buf);
      }
      if (v15) {
        uint64_t v7 = 2;
      }
      else {
        uint64_t v7 = 3;
      }
    }
    int v10 = *v3;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = asString();
      uint64_t v12 = asString();
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v11;
      __int16 v19 = 2080;
      uint64_t v20 = v12;
      __int16 v21 = 2080;
      int v22 = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I User preference: Enable LTE: %s with %s; based on %s",
        buf,
        0x20u);
    }
  }
  else
  {
    int v6 = *v3;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Unable to find model when getting LTE user preference", buf, 2u);
    }
    uint64_t v7 = 0;
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  return v7;
}

void sub_100F50A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, ...)
{
  va_start(va, a5);
  sub_100062778((const void **)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100F50AC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50B08()
{
}

void sub_100F50B18()
{
}

__n128 sub_100F50B2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A722D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F50B78(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A722D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F50BA8(uint64_t a1, const __CFString ***a2, unsigned __int8 *a3)
{
}

uint64_t sub_100F50BC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50C04()
{
}

void sub_100F50C14()
{
}

__n128 sub_100F50C28(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F50C74(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72358;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F50CA4(uint64_t a1, const __CFString ***a2)
{
}

uint64_t sub_100F50CB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50CF8()
{
}

void sub_100F50D08()
{
}

__n128 sub_100F50D1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A723D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F50D68(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A723D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unsigned __int8 *sub_100F50D98(uint64_t a1, const __CFString ***a2)
{
  return sub_100F44504(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16), *a2);
}

uint64_t sub_100F50DAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50DEC()
{
}

void sub_100F50DFC()
{
}

__n128 sub_100F50E10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F50E5C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72458;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F50E8C(uint64_t a1, const __CFString ***a2, unsigned __int8 *a3)
{
}

uint64_t sub_100F50EA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50EE8()
{
}

void sub_100F50EF8()
{
}

__n128 sub_100F50F0C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A724D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F50F58(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A724D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F50F88(uint64_t a1, const __CFString ***a2)
{
}

uint64_t sub_100F50F9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F50FDC()
{
}

void sub_100F50FEC()
{
}

__n128 sub_100F51000(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F5104C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72558;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F5107C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  uint64_t v12 = 0;
  int v13 = 0;
  MaxDataRateManager::getModel_sync(v1, v2, &v12);
  if (v12)
  {
    int v4 = *(unsigned __int8 *)(v12 + 256);
    xpc_object_t v5 = "default value";
    if ((v4 - 2) >= 2)
    {
      uint64_t v6 = v4 == 1;
      if (v4 == 1) {
        xpc_object_t v5 = "default value";
      }
    }
    else
    {
      buf[0] = 1;
      if (sub_100F44100(v1, v2, *(const __CFString ***)(v12 + 608), (BOOL *)buf)) {
        xpc_object_t v5 = "user preference";
      }
      if (buf[0]) {
        uint64_t v6 = 2;
      }
      else {
        uint64_t v6 = 3;
      }
    }
    CFBooleanRef v8 = *v3;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = asString();
      uint64_t v10 = asString();
      *(_DWORD *)long long buf = 136315650;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      uint64_t v17 = v10;
      __int16 v18 = 2080;
      __int16 v19 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I User preference: Enable 3G: %s with %s; based on %s",
        buf,
        0x20u);
    }
  }
  else
  {
    uint64_t v7 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unable to find model when getting 3G user preference", buf, 2u);
    }
    uint64_t v6 = 0;
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  return v6;
}

void sub_100F51268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100F51284(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F512C4()
{
}

void sub_100F512D4()
{
}

__n128 sub_100F512E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A725D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F51334(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A725D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F51364(uint64_t a1, const __CFString ***a2, unsigned __int8 *a3)
{
}

uint64_t sub_100F51380(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F513C0()
{
}

void sub_100F513D0()
{
}

__n128 sub_100F513E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F51430(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F51460(uint64_t a1, const __CFString ***a2)
{
}

uint64_t sub_100F51474(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F514B4()
{
}

void sub_100F514C4()
{
}

__n128 sub_100F514D8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A726D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F51524(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A726D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unsigned __int8 *sub_100F51554(uint64_t a1, const __CFString ***a2)
{
  return sub_100F44504(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16), *a2);
}

uint64_t sub_100F51568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F515A8()
{
}

void sub_100F515B8()
{
}

__n128 sub_100F515CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A72758;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F51618(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72758;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F51648(uint64_t a1, const __CFString ***a2, unsigned __int8 *a3)
{
}

uint64_t sub_100F51664(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F516A4()
{
}

void sub_100F516B4()
{
}

__n128 sub_100F516C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A727D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100F51714(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A727D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F51744(uint64_t a1, const __CFString ***a2)
{
}

uint64_t sub_100F51758(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F51798()
{
}

void sub_100F517A8()
{
}

void *sub_100F517BC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A72858;
  result[1] = v3;
  return result;
}

uint64_t sub_100F51804(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A72858;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F51830(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(v1 + 456);
  unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
  if (v3 < 2) {
    goto LABEL_4;
  }
  int v4 = "default value";
  if (v3 == 2)
  {
    *(void *)long long buf = CFStringCreateWithCString(kCFAllocatorDefault, *(const char **)(v2 + 128), 0x8000100u);
    CFBooleanRef v13 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(v1 + 72) + 40))(&v12);
    sub_1000057AC(&v13, &v12);
    sub_1000577C4(&v12);
    if (v13) {
      uint64_t v6 = sub_100084B4C;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6) {
      int v4 = "user preference";
    }
    BOOL v7 = v13 != kCFBooleanTrue || v6 == 0;
    sub_100062778((const void **)&v13);
    sub_1000558F4((const void **)buf);
    if (v7) {
      uint64_t v5 = 3;
    }
    else {
      uint64_t v5 = 2;
    }
  }
  else
  {
    if (v3 == 3)
    {
LABEL_4:
      int v4 = "default value";
      uint64_t v5 = 2;
      goto LABEL_17;
    }
    uint64_t v5 = 0;
  }
LABEL_17:
  CFBooleanRef v8 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = asString();
    uint64_t v10 = asString();
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v9;
    __int16 v15 = 2080;
    uint64_t v16 = v10;
    __int16 v17 = 2080;
    __int16 v18 = v4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I User preference: Enable 2G: %s with %s; based on %s",
      buf,
      0x20u);
  }
  return v5;
}

void sub_100F51A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, const void *a11)
{
}

uint64_t sub_100F51A54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F51A94()
{
}

void sub_100F51AA4()
{
}

void *sub_100F51AB8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A728D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F51B00(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A728D8;
  a2[1] = v2;
  return result;
}

const void **sub_100F51B2C(uint64_t a1, const char **a2, unsigned __int8 *a3)
{
  int v3 = *a3;
  uint64_t v4 = *(void *)(a1 + 8);
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, *a2, 0x8000100u);
  CFStringRef v8 = v5;
  uint64_t v6 = &kCFBooleanTrue;
  if (!v3) {
    uint64_t v6 = &kCFBooleanFalse;
  }
  (*(void (**)(void, CFStringRef, const CFBooleanRef, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v4 + 72) + 16))(*(void *)(v4 + 72), v5, *v6, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v4 + 72)
                                                                                           + 48))(*(void *)(v4 + 72), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void))(**(void **)(v4 + 512) + 160))(*(void *)(v4 + 512));
  return sub_1000558F4((const void **)&v8);
}

void sub_100F51C58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F51C6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F51CAC()
{
}

void sub_100F51CBC()
{
}

void *sub_100F51CD0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A72958;
  result[1] = v3;
  return result;
}

uint64_t sub_100F51D18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A72958;
  a2[1] = v2;
  return result;
}

const void **sub_100F51D44(uint64_t a1, const char **a2)
{
  return sub_100F4582C(*(void *)(a1 + 8), *a2);
}

uint64_t sub_100F51D50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F51D90()
{
}

void sub_100F51DA0()
{
}

void *sub_100F51DB4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A729D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F51DFC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A729D8;
  a2[1] = v2;
  return result;
}

uint64_t sub_100F51E28(uint64_t a1, const char **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  CFStringRef v9 = CFStringCreateWithCString(kCFAllocatorDefault, *a2, 0x8000100u);
  CFStringRef v8 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(v2 + 72) + 40))(&v7);
  sub_1000842D0(&v8, &v7);
  sub_1000577C4(&v7);
  if (v8) {
    uint64_t v4 = sub_100081E58;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    LOBYTE(v7) = 0;
    ctu::cf::assign((ctu::cf *)&v7, v8, v3);
    uint64_t v5 = v7;
  }
  else
  {
    uint64_t v5 = 0;
  }
  sub_1000570E8((const void **)&v8);
  sub_1000558F4((const void **)&v9);
  return v5;
}

void sub_100F51F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_1000570E8((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100F51F58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F51F98()
{
}

void sub_100F51FA8()
{
}

void *sub_100F51FBC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A72A58;
  result[1] = v3;
  return result;
}

uint64_t sub_100F52004(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A72A58;
  a2[1] = v2;
  return result;
}

const void **sub_100F52030(uint64_t a1, const char **a2, unsigned __int8 *a3)
{
  CFNumberRef v3 = (const __CFNumber *)*a3;
  uint64_t v4 = *(void *)(a1 + 8);
  CFStringRef v10 = CFStringCreateWithCString(kCFAllocatorDefault, *a2, 0x8000100u);
  CFNumberRef v11 = 0;
  CFNumberRef valuePtr = v3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v5)
  {
    CFNumberRef v6 = v11;
    CFNumberRef v11 = v5;
    CFNumberRef valuePtr = v6;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v7 = v11;
  CFNumberRef v9 = v11;
  CFNumberRef v11 = 0;
  sub_1000570E8((const void **)&v11);
  (*(void (**)(void, CFStringRef, CFNumberRef, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v4 + 72) + 16))(*(void *)(v4 + 72), v10, v7, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void, const __CFString *, const CFStringRef, const CFStringRef))(**(void **)(v4 + 72)
                                                                                           + 48))(*(void *)(v4 + 72), @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  (*(void (**)(void))(**(void **)(v4 + 512) + 160))(*(void *)(v4 + 512));
  sub_1000570E8((const void **)&v9);
  return sub_1000558F4((const void **)&v10);
}

void sub_100F5218C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  CFNumberRef v3 = va_arg(va1, const void *);
  sub_1000570E8((const void **)va1);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100F521B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F521F4()
{
}

void sub_100F52204()
{
}

void *sub_100F52218(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A72AD8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F52260(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A72AD8;
  a2[1] = v2;
  return result;
}

const void **sub_100F5228C(uint64_t a1, const char **a2)
{
  return sub_100F4582C(*(void *)(a1 + 8), *a2);
}

uint64_t sub_100F52298(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F522D8()
{
}

uint64_t *sub_100F522E4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFNumberRef v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 88));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100F52368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100F52384(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v59 = a1;
  uint64_t v60 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", (uint8_t *)&buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 56));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    CFStringRef v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long buf = v7;
  CFNumberRef v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
LABEL_11:
  __int16 v15 = *(std::__shared_weak_count **)(v2 + 504);
  *(void *)(v2 + 496) = v13;
  *(void *)(v2 + 504) = v12;
  if (v15) {
    sub_10004D2C8(v15);
  }
  uint64_t v16 = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)(v2 + 56));
  __int16 v17 = v16;
  if (v18 < 0)
  {
    __int16 v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  *(void *)&long long buf = v18;
  int v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&buf);
  if (v22)
  {
    uint64_t v24 = v22[3];
    int v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  int v23 = 0;
LABEL_21:
  int v25 = *(std::__shared_weak_count **)(v2 + 488);
  *(void *)(v2 + 480) = v24;
  *(void *)(v2 + 488) = v23;
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_100058DB0(__p, "/cc/props/device_types");
  int v26 = operator new(0x28uLL);
  *int v26 = off_101A72B78;
  v26[1] = v2 + 104;
  _OWORD v26[2] = v2;
  v26[3] = sub_100F48A80;
  v26[4] = 0;
  v63[0] = v26;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v69) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  int v27 = operator new(0x28uLL);
  *int v27 = off_101A72BF8;
  v27[1] = v2 + 128;
  v27[2] = v2;
  v27[3] = sub_100F48220;
  v27[4] = 0;
  v63[0] = v27;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v69) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  int v28 = operator new(0x20uLL);
  void *v28 = off_101A72C78;
  v28[1] = v2;
  int v28[2] = sub_100F4A020;
  v28[3] = 0;
  v63[0] = v28;
  ctu::RestModule::observeEvent();
  sub_10003F600(&buf);
  if (SHIBYTE(v69) < 0) {
    operator delete(__p[0]);
  }
  sub_10041BCB4(v2 + 152);
  sub_100058DB0(__p, "/cc/props/user_preferred_data_slot");
  BOOL v29 = operator new(0x28uLL);
  void *v29 = off_101A72CF8;
  v29[1] = v2 + 156;
  void v29[2] = v2;
  v29[3] = sub_100F47F00;
  v29[4] = 0;
  v63[0] = v29;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  if (SHIBYTE(v69) < 0) {
    operator delete(__p[0]);
  }
  int v30 = operator new(0x20uLL);
  unsigned int v31 = (dispatch_object_t *)(v2 + 24);
  *int v30 = off_101A72D78;
  v30[1] = v2;
  v30[2] = sub_100F47E20;
  v30[3] = 0;
  v63[0] = v30;
  int v70 = 0;
  v72[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(v72);
  sub_10010040C(__p);
  sub_100100388(&buf);
  sub_10071A3EC(v2 + 160);
  if (capabilities::ct::supports5G(v32))
  {
    sub_100058DB0(__p, "/cc/prefs-nb/activation_5g_support");
    int v33 = operator new(0x28uLL);
    void *v33 = off_101A72DF8;
    v33[1] = v2 + 184;
    CFTypeRef v33[2] = v2;
    v33[3] = sub_100F4D34C;
    v33[4] = 0;
    v63[0] = v33;
    ctu::RestModule::observeProperty();
    sub_10003F600(&buf);
    if (SHIBYTE(v69) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/nr_disable_status");
    int v34 = operator new(0x28uLL);
    *int v34 = off_101A72E78;
    v34[1] = v2 + 192;
    v34[2] = v2;
    v34[3] = sub_100F4D410;
    v34[4] = 0;
    v63[0] = v34;
    ctu::RestModule::observeProperty();
    sub_10003F600(&buf);
    if (SHIBYTE(v69) < 0) {
      operator delete(__p[0]);
    }
    sub_100058DB0(__p, "/cc/props/save_data_mode_user_preference");
    *(void *)&long long buf = off_101A72EF8;
    *((void *)&buf + 1) = v2 + 216;
    v63[0] = &buf;
    ctu::RestModule::observeProperty();
    sub_10003F600(&buf);
    if (SHIBYTE(v69) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100058DB0(__p, "/cc/props/cs_voice_support");
  int v35 = operator new(0x28uLL);
  *int v35 = off_101A72F78;
  v35[1] = v2 + 240;
  v35[2] = v2;
  v35[3] = sub_100F4D66C;
  void v35[4] = 0;
  v63[0] = v35;
  ctu::RestModule::observeProperty();
  sub_10003F600(&buf);
  int v36 = (uint64_t *)SHIBYTE(v69);
  if ((v36 & 0x80000000) != 0) {
    operator delete(__p[0]);
  }
  int v37 = (std::mutex *)Registry::getServiceMap(v36, *(Registry **)(v2 + 56));
  int v38 = v37;
  if (v39 < 0)
  {
    int v40 = (unsigned __int8 *)(v39 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v41 = 5381;
    do
    {
      uint64_t v39 = v41;
      unsigned int v42 = *v40++;
      uint64_t v41 = (33 * v41) ^ v42;
    }
    while (v42);
  }
  std::mutex::lock(v37);
  *(void *)&long long buf = v39;
  BOOL v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)&buf);
  if (v43)
  {
    uint64_t v44 = v43[3];
    uint64_t v45 = (std::__shared_weak_count *)v43[4];
    if (v45)
    {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v38);
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v45);
      char v46 = 0;
      if (!v44) {
        goto LABEL_66;
      }
      goto LABEL_49;
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  std::mutex::unlock(v38);
  uint64_t v45 = 0;
  char v46 = 1;
  if (!v44) {
    goto LABEL_66;
  }
LABEL_49:
  int v47 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v47 || (v48 = *(void *)(v2 + 8), (uint64_t v49 = std::__shared_weak_count::lock(v47)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v50 = v49;
  atomic_fetch_add_explicit(&v49->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v49);
  int64_t v51 = *v31;
  if (*v31) {
    dispatch_retain(*v31);
  }
  __p[0] = _NSConcreteStackBlock;
  __p[1] = (void *)0x40000000;
  int v69 = sub_100F52DE4;
  int v70 = &unk_101A72B48;
  uint64_t v71 = v2;
  if (v51)
  {
    int64_t v52 = _Block_copy(__p);
    int64_t v53 = v52;
    v72[0] = v51;
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 1174405120;
    int v62 = sub_100F5461C;
    v63[0] = &unk_101A72FE8;
    v63[1] = v48;
    uint64_t v64 = v50;
    atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (v52) {
      uint64_t v54 = _Block_copy(v52);
    }
    else {
      uint64_t v54 = 0;
    }
    aBlock = v54;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, long long *))(*(void *)v44 + 40))(v44, "commCenterSwitchState", 1, v72, &buf);
    if (v72[0]) {
      dispatch_release(v72[0]);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (v64) {
      std::__shared_weak_count::__release_weak(v64);
    }
    if (v53) {
      _Block_release(v53);
    }
  }
  std::__shared_weak_count::__release_weak(v50);
LABEL_66:
  if ((v46 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  if (sub_100529568()) {
    char v55 = 2;
  }
  else {
    char v55 = 3;
  }
  LODWORD(buf) = 1;
  *((void *)&buf + 1) = "Enable2GSwitchSupport";
  LOBYTE(v62) = v55;
  aBlock = 0;
  v66[3] = 0;
  v67[3] = 0;
  *(unsigned char *)(*(void *)(v2 + 456) + 16) = v55;
  sub_100F4E628(v67);
  sub_100F4E5A4(v66);
  sub_100F4E520(v63);
  int v56 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v57 = asString();
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v57;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I 2G Switch support initialized: %s", (uint8_t *)&buf, 0xCu);
  }
  sub_100088C88(&v60);
  return sub_100046B58((uint64_t *)&v59);
}

void sub_100F52CC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, void *aBlock,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100F52DE4(capabilities::ct *a1)
{
  uint64_t v1 = (MaxDataRateManager *)*((void *)a1 + 4);
  if (capabilities::ct::supports5G(a1))
  {
    MaxDataRateManager::submit5GSwitchStateToCA_sync(v1);
    MaxDataRateManager::submit5GSDMStatusToCA_sync((Registry **)v1, v2);
  }
  MaxDataRateManager::submit4GSwitchStateToCA_sync(v1);
  MaxDataRateManager::submit3GSwitchStateToCA_sync(v1);
  uint64_t v3 = *((void *)v1 + 57);
  int v9 = 1;
  uint64_t v10 = *(void *)(v3 + 8);
  char v11 = *(unsigned char *)(v3 + 16);
  v12[3] = 0;
  void v13[3] = 0;
  v14[3] = 0;
  sub_100F4F14C((uint64_t)v6, v3 + 144);
  void v7[3] = 0;
  void v8[3] = 0;
  MaxDataRateManager::submit2GSwitchStateToCA_sync((uint64_t)v1, v4);
  sub_100F4E730(v8);
  sub_100F4E5A4(v7);
  sub_100F4E6AC(v6);
  sub_100F4E628(v14);
  sub_100F4E5A4(v13);
  return sub_100F4E520(v12);
}

void sub_100F52F10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  sub_100F4DC4C((uint64_t *)va);
  sub_100F4A50C((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void sub_100F52F38()
{
}

__n128 sub_100F52F4C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A72B78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F52FA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72B78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F52FD8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100F53098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F530B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F530F0()
{
}

void sub_100F53100()
{
}

__n128 sub_100F53114(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A72BF8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F53168(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72BF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F531A0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100F53260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F53278(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F532B8()
{
}

void sub_100F532C8()
{
}

__n128 sub_100F532DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A72C78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F53330(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72C78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F53368(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100F533B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F533F0()
{
}

void sub_100F53400()
{
}

__n128 sub_100F53414(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A72CF8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F53468(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72CF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F534A0(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    *uint64_t v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100F53590(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F535D0()
{
}

void sub_100F535E0()
{
}

__n128 sub_100F535F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A72D78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100F53648(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72D78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F53680(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    return (*(uint64_t (**)(void))(*v6 + v4))();
  }
  else {
    return v4(v6, a3);
  }
}

uint64_t sub_100F536CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F5370C()
{
}

void sub_100F5371C()
{
}

__n128 sub_100F53730(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A72DF8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F53784(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72DF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100F537BC(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    *uint64_t v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *uint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_100F538B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F538F4()
{
}

void sub_100F53904()
{
}

__n128 sub_100F53918(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A72E78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F5396C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72E78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F539A4(void *a1, xpc_object_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = (uint64_t **)(v3 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  int v23 = *(uint64_t **)v3;
  uint64_t v24 = v4;
  if (*(void *)(v3 + 16))
  {
    void v4[2] = &v24;
    *(void *)uint64_t v3 = v5;
    void *v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    int v23 = (uint64_t *)&v24;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_1000346F8(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v29, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    int v22 = v2;
    sub_100048BF4(v28, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v30; ; uint64_t i = ++v30)
    {
      if (i == v28[1] && v29 == v28[0])
      {
        xpc_release(v29);
        xpc_release(v29);
        uint64_t v2 = v22;
        goto LABEL_48;
      }
      xpc_object_t v27 = 0;
      object[0] = &v29;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v27);
      if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_46:
      xpc_release(v27);
    }
    memset(object, 0, 20);
    NRDisableStatus::NRDisableStatus((NRDisableStatus *)((char *)object + 4), 1, 1);
    xpc_object_t v9 = v27;
    if (v27)
    {
      xpc_retain(v27);
      xpc_object_t v34 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v34 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
      goto LABEL_30;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v34 = v10;
LABEL_30:
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
    {
      unsigned int v31 = &v34;
      BOOL v32 = "first";
      sub_100048BAC((uint64_t)&v31, v33);
      xpc_type_t type = xpc_get_type(*(xpc_object_t *)v33);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v35 = (int)object[0];
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v35, v33, v12);
        LODWORD(object[0]) = v35;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        LODWORD(object[0]) = xpc::dyn_cast_or_default((xpc *)v33, 0, (uint64_t)v12);
      }
      xpc_release(*(xpc_object_t *)v33);
      unsigned int v31 = &v34;
      BOOL v32 = "second";
      sub_100048BAC((uint64_t)&v31, v33);
      read_rest_value((NRDisableStatus *)((char *)object + 4), (const xpc::object *)v33);
      xpc_release(*(xpc_object_t *)v33);
      xpc_object_t v10 = v34;
    }
    xpc_release(v10);
    xpc_release(v9);
    int v13 = (int)object[0];
    unsigned int v14 = *v5;
    uint64_t v15 = (uint64_t **)(v3 + 8);
    uint64_t v16 = (uint64_t **)(v3 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v16 = (uint64_t **)v14;
          int v17 = *((_DWORD *)v14 + 7);
          if (v17 <= SLODWORD(object[0])) {
            break;
          }
          unsigned int v14 = *v16;
          uint64_t v15 = v16;
          if (!*v16) {
            goto LABEL_45;
          }
        }
        if (v17 >= SLODWORD(object[0])) {
          break;
        }
        unsigned int v14 = v16[1];
        if (!v14)
        {
          uint64_t v15 = v16 + 1;
          goto LABEL_45;
        }
      }
    }
    else
    {
LABEL_45:
      uint64_t v18 = operator new(0x30uLL);
      v18[7] = v13;
      *((_OWORD *)v18 + 2) = *(_OWORD *)((char *)object + 4);
      sub_100046C38((uint64_t **)v3, (uint64_t)v16, v15, (uint64_t *)v18);
    }
    goto LABEL_46;
  }
LABEL_48:
  xpc_release(v6);
  __int16 v19 = (void (*)(void *, uint64_t **))v2[3];
  uint64_t v20 = v2[4];
  unsigned int v21 = (void *)(v2[2] + (v20 >> 1));
  if (v20) {
    __int16 v19 = *(void (**)(void *, uint64_t **))(*v21 + v19);
  }
  v19(v21, &v23);
  sub_1000346F8((uint64_t)&v23, v24);
}

void sub_100F53DD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, xpc_object_t object, uint64_t a15, uint64_t a16, xpc_object_t a17, xpc_object_t a18, uint64_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a20);
  xpc_release(v20);
  sub_1000346F8((uint64_t)&a11, a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100F53EC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F53F08()
{
}

void sub_100F53F18()
{
}

void *sub_100F53F2C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A72EF8;
  result[1] = v3;
  return result;
}

uint64_t sub_100F53F74(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A72EF8;
  a2[1] = v2;
  return result;
}

void sub_100F53FA0(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_100F53FA8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F53FE8()
{
}

void sub_100F53FF8()
{
}

__n128 sub_100F5400C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A72F78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100F54060(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A72F78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100F54098(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    _DWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    void v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_100F541BC((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100F54158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100F54170(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100F541B0()
{
}

void sub_100F541BC(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v10, object, 0);
    xpc_release(object[0]);
    v7[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      v7[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(object, v7, count);
    xpc_release(v7[0]);
    for (uint64_t i = v11; i != object[1] || v10 != object[0]; uint64_t i = ++v11)
    {
      v7[1] = i;
      xpc_object_t v8 = 0;
      v7[0] = &v10;
      sub_10003FBDC((uint64_t)v7, &v8);
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v6 = v8;
        v7[0] = 0;
        if (v8) {
          xpc_retain(v8);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_100F54438((int *)v7, &v6);
        xpc_release(v6);
        sub_100315328((uint64_t **)a1, (int *)v7, (uint64_t)v7);
      }
      xpc_release(v8);
    }
    xpc_release(v10);
    xpc_release(v10);
  }
  xpc_release(v3);
}

void sub_100F543A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, xpc_object_t a12, xpc_object_t a13, uint64_t a14, xpc_object_t a15)
{
  xpc_release(object);
  xpc_release(a15);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100F54438(int *a1, void **a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t object = &object;
    xpc_object_t v9 = "first";
    sub_100048BAC((uint64_t)&p_object, &v10);
    xpc_type_t type = xpc_get_type(v10);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v12 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v12, (int *)&v10, v6);
      *a1 = v12;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&v10, 0, (uint64_t)v6);
    }
    xpc_release(v10);
    p_xpc_object_t object = &object;
    xpc_object_t v9 = "second";
    sub_100048BAC((uint64_t)&p_object, &v10);
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_null)
    {
      if (*((unsigned char *)a1 + 5)) {
        *((unsigned char *)a1 + 5) = 0;
      }
    }
    else
    {
      if (!*((unsigned char *)a1 + 5)) {
        *((_WORD *)a1 + 2) = 256;
      }
      *((unsigned char *)a1 + 4) = xpc::dyn_cast_or_default((xpc *)&v10, 0, v7);
    }
    xpc_release(v10);
  }
  xpc_release(object);
}

void sub_100F545C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
}

void sub_100F5461C(void *a1, uint64_t a2)
{
  xpc_object_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      xpc_object_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100F54694(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100F546A8(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100F546F4(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_100F54748(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v20 = a1;
  uint64_t v21 = v1;
  uint64_t v3 = *(void *)v1;
  xpc_object_t v2 = *(xpc_object_t *)(v1 + 8);
  if (v2) {
    xpc_retain(*(xpc_object_t *)(v1 + 8));
  }
  else {
    xpc_object_t v2 = xpc_null_create();
  }
  uint64_t v5 = *(NSObject **)(v1 + 16);
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v3 + 56));
  BOOL v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    xpc_object_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v22[0] = v8;
  int v12 = sub_10004D37C(&v7[1].__m_.__sig, v22);
  if (v12)
  {
    uint64_t v13 = v12[3];
    unsigned int v14 = (std::__shared_weak_count *)v12[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v15 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v14 = 0;
  char v15 = 1;
LABEL_14:
  xpc_object_t v16 = xpc_null_create();
  int v23 = 0;
  int v17 = operator new(0x28uLL);
  *int v17 = off_101A73028;
  v17[1] = v3;
  _OWORD v17[2] = v3;
  v17[3] = v2;
  xpc_object_t v18 = xpc_null_create();
  v17[4] = v5;
  int v23 = v17;
  (*(void (**)(uint64_t, uint64_t, unint64_t *))(*(void *)v13 + 96))(v13, 1, v22);
  sub_100ED7DE4(v22);
  xpc_release(v18);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  xpc_release(v16);
  sub_100F549DC(&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_100F54930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t *sub_100F549DC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    xpc_object_t v2 = *(NSObject **)(v1 + 16);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 16);
      if (v3) {
        dispatch_release(v3);
      }
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t sub_100F54A4C(uint64_t a1)
{
  *(void *)a1 = off_101A73028;
  xpc_object_t v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 32);
    if (v3) {
      dispatch_release(v3);
    }
  }
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  return a1;
}

void sub_100F54AB4(uint64_t a1)
{
  *(void *)a1 = off_101A73028;
  xpc_object_t v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 32);
    if (v3) {
      dispatch_release(v3);
    }
  }
  xpc_release(*(xpc_object_t *)(a1 + 24));
  *(void *)(a1 + 24) = 0;

  operator delete();
}

void *sub_100F54B3C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  xpc_object_t v2 = operator new(0x28uLL);
  void *v2 = off_101A73028;
  sub_100F54D78((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100F54B90(uint64_t a1, void *a2)
{
  *a2 = off_101A73028;
  return sub_100F54D78((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100F54BBC(uint64_t a1)
{
}

void sub_100F54BC4(void *a1)
{
  sub_100F54DE4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100F54C00(void *a1)
{
  uint64_t v2 = a1[1];
  a1[3] = xpc_null_create();
  a1[4] = 0;
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100F54D2C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A73098)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100F54D6C()
{
  return &off_101A73098;
}

uint64_t sub_100F54D78(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  xpc_object_t v4 = *(void **)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    xpc_retain(v4);
  }
  else {
    *(void *)(a1 + 16) = xpc_null_create();
  }
  uint64_t v5 = *(NSObject **)(a2 + 24);
  *(void *)(a1 + 24) = v5;
  if (v5)
  {
    dispatch_retain(v5);
    xpc_object_t v6 = *(NSObject **)(a1 + 24);
    if (v6) {
      dispatch_group_enter(v6);
    }
  }
  return a1;
}

void sub_100F54DE4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 24);
    if (v3) {
      dispatch_release(v3);
    }
  }
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
}

uint64_t *sub_100F54E2C(unsigned __int8 **a1)
{
  uint64_t v1 = *a1;
  BOOL v32 = a1;
  int v33 = v1;
  int v2 = *v1;
  uint64_t v4 = *((void *)v1 + 1);
  uint64_t v3 = (void *)*((void *)v1 + 2);
  xpc_object_t v34 = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v34 = xpc_null_create();
  }
  *(void *)long long buf = &v34;
  *(void *)&uint8_t buf[8] = "kIsDifferentDevice";
  sub_100048BAC((uint64_t)buf, &object);
  int v6 = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
  xpc_release(object);
  BOOL v7 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Migrator has called to re-evaluate the saved switch states in Max Data Manager", buf, 2u);
    BOOL v7 = *(NSObject **)(v4 + 40);
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v8 = "false";
    if (v6) {
      unint64_t v8 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Is from a different device: %s", buf, 0xCu);
  }
  sub_100F45CEC(v4);
  char v37 = 1;
  xpc_object_t object = 0;
  int v36 = 0;
  MaxDataRateManager::getModel_sync(v4, 1, &object);
  uint64_t v9 = sub_100365D74();
  sub_100058DB0(buf, *((char **)object + 76));
  BOOL v10 = sub_1002260B0(v9, (void **)buf, (BOOL *)&v37);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  unsigned int v11 = *(uint64_t (**)(void))(**(void **)(v4 + 48) + 16);
  if (v10)
  {
    int v12 = *(NSObject **)v11();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v37;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Not saving the check RAT Selection for 3G Switch, there is already a user preference with value: %d", buf, 8u);
    }
  }
  else
  {
    uint64_t v13 = (os_log_t *)v11();
    unsigned int v14 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v2;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I There is no 3G user preference stored, but checking for RAT Selection: %d", buf, 8u);
    }
    if (v2 == 1)
    {
      char v15 = *v13;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I RAT Selection has been set to GSM, looks like user had set to 2G before, setting the user selection to 2G", buf, 2u);
      }
      sub_100F45FFC(v4, 1, 1, 1);
    }
  }
  xpc_object_t v16 = *(void **)(v4 + 432);
  if (v16 != (void *)(v4 + 440))
  {
    do
    {
      uint64_t v17 = *((unsigned int *)v16 + 8);
      xpc_object_t v18 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v17);
      *(_OWORD *)long long buf = 0uLL;
      Model_sync = (capabilities::ct *)MaxDataRateManager::getModel_sync(v4, v17, buf);
      if (!*(void *)buf)
      {
        int v23 = *v18;
        if (os_log_type_enabled(*v18, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v39 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Unable to find model when evaluating LTE switch during migration for latest devices", v39, 2u);
        }
        goto LABEL_36;
      }
      int v20 = *(_DWORD *)(*(void *)buf + 496);
      if (capabilities::ct::latestAndGreatestDevice(Model_sync))
      {
        uint64_t v21 = *v18;
        BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
        if (v20 == 3)
        {
          if (v6)
          {
            if (v22)
            {
              *(_WORD *)uint64_t v39 = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Enabling LTE user preference for new device due to migration", v39, 2u);
            }
            sub_100F45FFC(v4, v17, 3, 2);
            goto LABEL_36;
          }
          if (v22)
          {
            uint64_t v27 = asString();
            *(_DWORD *)uint64_t v39 = 136315138;
            uint64_t v40 = v27;
            int v25 = v21;
            int v26 = "#I Restoring from the same device, leaving LTE switch at: %s";
            goto LABEL_35;
          }
        }
        else if (v22)
        {
          uint64_t v24 = asString();
          *(_DWORD *)uint64_t v39 = 136315138;
          uint64_t v40 = v24;
          int v25 = v21;
          int v26 = "#I Leaving LTE switch migration alone, LTE user preference is: %s";
LABEL_35:
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v26, v39, 0xCu);
        }
      }
LABEL_36:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      sub_100F46AA4(v4, *((unsigned int *)v16 + 8));
      int v28 = (void *)v16[1];
      if (v28)
      {
        do
        {
          xpc_object_t v29 = v28;
          int v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          xpc_object_t v29 = (void *)v16[2];
          BOOL v30 = *v29 == (void)v16;
          xpc_object_t v16 = v29;
        }
        while (!v30);
      }
      xpc_object_t v16 = v29;
    }
    while (v29 != (void *)(v4 + 440));
  }
  if (v36) {
    sub_10004D2C8(v36);
  }
  xpc_release(v34);
  sub_100F553D8((uint64_t *)&v33);
  return sub_100046B58((uint64_t *)&v32);
}

void sub_100F55328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, xpc_object_t a14, std::__shared_weak_count *a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  xpc_release(object);
  sub_100F553D8(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_100F553D8(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    int v2 = *(NSObject **)(v1 + 24);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 24);
      if (v3) {
        dispatch_release(v3);
      }
    }
    xpc_release(*(xpc_object_t *)(v1 + 16));
    *(void *)(v1 + 16) = 0;
    operator delete();
  }
  return result;
}

void sub_100F55448(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v66, *(Registry **)(v1 + 56));
  ctu::RestModule::connect();
  uint64_t v3 = (capabilities::ct *)v67;
  if (v67) {
    sub_10004D2C8(v67);
  }
  uint64_t v61 = v1;
  if (!capabilities::ct::supportsGemini(v3)) {
    goto LABEL_102;
  }
  subscriber::makeSimSlotRange();
  uint64_t v4 = v63;
  if (v63 == v64) {
    goto LABEL_102;
  }
  do
  {
    if (v65(*v4)) {
      goto LABEL_10;
    }
    ++v4;
  }
  while (v4 != v64);
  uint64_t v4 = v64;
LABEL_10:
  if (v4 == v64) {
    goto LABEL_102;
  }
LABEL_11:
  uint64_t v5 = *v4;
  int v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v5);
  int v75 = 0;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  PersonalityIdFromSlotId();
  int v62 = isReal();
  long long v82 = 0uLL;
  uint64_t v83 = 0;
  sub_100058DB0(buf, "Enable5G");
  sub_100058DB0(v79, "EnableLTE");
  sub_100058DB0(v80, "Enable3G");
  long long v82 = 0uLL;
  uint64_t v83 = 0;
  std::string __p = &v82;
  uint64_t v73 = 0;
  *(void *)&long long v82 = operator new(0x48uLL);
  *((void *)&v82 + 1) = v82;
  uint64_t v83 = v82 + 72;
  uint64_t v7 = 0;
  *((void *)&v82 + 1) = sub_1000D8A18((uint64_t)&v83, (long long *)buf, (long long *)&v81, (char *)v82);
  do
  {
    if (SHIBYTE(v80[v7 + 2]) < 0) {
      operator delete((void *)v80[v7]);
    }
    v7 -= 3;
  }
  while (v7 != -9);
  uint64_t v9 = (char *)*((void *)&v82 + 1);
  for (uint64_t i = (char *)v82; i != v9; i += 24)
  {
    LOBYTE(v68) = 0;
    std::string __p = 0;
    uint64_t v73 = 0;
    int v74 = 0;
    BOOL v10 = i;
    if (i[23] < 0) {
      BOOL v10 = *(char **)i;
    }
    sub_100F45924((uint64_t)&__p, v5, v10);
    uint64_t v11 = sub_100365D74();
    if (sub_1002260B0(v11, &__p, (BOOL *)&v68))
    {
      if (v62)
      {
        int v12 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          if (v77 >= 0) {
            uint64_t v13 = (std::__shared_weak_count *)HIBYTE(v77);
          }
          else {
            uint64_t v13 = v76;
          }
          if (v77 >= 0) {
            unsigned int v14 = (const char *)&v75;
          }
          else {
            unsigned int v14 = v75;
          }
          char v15 = i;
          if (i[23] < 0) {
            char v15 = *(char **)i;
          }
          if (!v13) {
            unsigned int v14 = "<invalid>";
          }
          *(_DWORD *)long long buf = 136315650;
          xpc_object_t v16 = "true";
          if (!(_BYTE)v68) {
            xpc_object_t v16 = "false";
          }
          *(void *)&uint8_t buf[4] = v14;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v15;
          *(_WORD *)&unsigned char buf[22] = 2080;
          v79[0] = v16;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Migration -- %s : key: %s, value: %s", buf, 0x20u);
        }
        uint64_t v17 = (const __CFString **)i;
        if (i[23] < 0) {
          uint64_t v17 = *(const __CFString ***)i;
        }
        sub_100F44EB8(v1, v5, v17, v68);
      }
      xpc_object_t v18 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        if (SHIBYTE(v74) >= 0) {
          uint64_t p_p = &__p;
        }
        else {
          uint64_t p_p = __p;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = p_p;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Erase : key : %s", buf, 0xCu);
      }
      int v20 = (uint64_t **)sub_100365D74();
      if (SHIBYTE(v74) >= 0) {
        uint64_t v21 = (char *)&__p;
      }
      else {
        uint64_t v21 = (char *)__p;
      }
      sub_100058DB0(buf, v21);
      sub_1003660FC(v20, (void **)buf);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    if (SHIBYTE(v74) < 0) {
      operator delete(__p);
    }
  }
  std::string __p = 0;
  uint64_t v73 = 0;
  int v74 = 0;
  sub_100058DB0(buf, "Enable5GSwitchSupport");
  sub_100058DB0(v79, "EnableLTESwitchSupport");
  sub_100058DB0(v80, "Enable3GSwitchSupport");
  std::string __p = 0;
  uint64_t v73 = 0;
  int v74 = 0;
  uint64_t v68 = &__p;
  uint64_t v69 = 0;
  std::string __p = operator new(0x48uLL);
  uint64_t v73 = (char *)__p;
  int v74 = (char *)__p + 72;
  uint64_t v22 = 0;
  uint64_t v73 = sub_1000D8A18((uint64_t)&v74, (long long *)buf, (long long *)&v81, (char *)__p);
  do
  {
    if (SHIBYTE(v80[v22 + 2]) < 0) {
      operator delete((void *)v80[v22]);
    }
    v22 -= 3;
  }
  while (v22 != -9);
  int v23 = (char *)__p;
  uint64_t v24 = v73;
  while (1)
  {
    if (v23 == v24)
    {
      *(void *)long long buf = &__p;
      sub_100047F64((void ***)buf);
      *(void *)long long buf = &v82;
      sub_100047F64((void ***)buf);
      if (SHIBYTE(v77) < 0) {
        operator delete(v75);
      }
      uint64_t v41 = v4 + 1;
      uint64_t v4 = v64;
      if (v41 != v64)
      {
        uint64_t v4 = v41;
        do
        {
          if (v65(*v4)) {
            goto LABEL_101;
          }
          ++v4;
        }
        while (v4 != v64);
        uint64_t v4 = v64;
      }
LABEL_101:
      if (v4 == v64)
      {
LABEL_102:
        sub_100F45CEC(v1);
        uint64_t v42 = *(void *)(v1 + 456);
        uint64_t v43 = *(void *)(v42 + 168);
        if (v43) {
          LODWORD(v43) = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 48))(v43);
        }
        *(_DWORD *)(v42 + 136) = v43;
        uint64_t v44 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v45 = asString();
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v45;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I 2G User Preference evaluated: %s", buf, 0xCu);
        }
        subscriber::makeSimSlotRange();
        int v47 = *(unsigned int **)buf;
        char v46 = *(unsigned int **)&buf[8];
        if (*(void *)buf != *(void *)&buf[8])
        {
          uint64_t v48 = *(uint64_t (**)(void))&buf[16];
          do
          {
            if (v48(*v47)) {
              goto LABEL_111;
            }
            ++v47;
          }
          while (v47 != v46);
          int v47 = v46;
LABEL_111:
          uint64_t v49 = *(unsigned int **)&buf[8];
          while (v47 != v49)
          {
            uint64_t v50 = *v47;
            int v75 = 0;
            uint64_t v76 = 0;
            MaxDataRateManager::getModel_sync(v61, v50, &v75);
            int64_t v51 = v75;
            if (v75)
            {
              uint64_t v52 = *((void *)v75 + 81);
              if (v52) {
                LODWORD(v52) = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 48))(v52);
              }
              *((_DWORD *)v51 + 154) = v52;
              uint64_t v53 = *((void *)v51 + 66);
              if (v53) {
                LODWORD(v53) = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 48))(v53);
              }
              *((_DWORD *)v51 + 124) = v53;
              uint64_t v54 = *((void *)v51 + 51);
              if (v54) {
                LODWORD(v54) = (*(uint64_t (**)(uint64_t))(*(void *)v54 + 48))(v54);
              }
              *((_DWORD *)v51 + 94) = v54;
              char v55 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v61 + 48) + 16))(*(void *)(v61 + 48), v50);
              int v56 = *v55;
              if (os_log_type_enabled(*v55, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v57 = asString();
                LODWORD(v82) = 136315138;
                *(void *)((char *)&v82 + 4) = v57;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I 3G User Preference evaluated: %s", (uint8_t *)&v82, 0xCu);
                int v56 = *v55;
              }
              if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v58 = asString();
                LODWORD(v82) = 136315138;
                *(void *)((char *)&v82 + 4) = v58;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I LTE User Preference evaluated: %s", (uint8_t *)&v82, 0xCu);
                int v56 = *v55;
              }
              if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v59 = asString();
                LODWORD(v82) = 136315138;
                *(void *)((char *)&v82 + 4) = v59;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I 5G User Preference evaluated: %s", (uint8_t *)&v82, 0xCu);
              }
            }
            if (v76) {
              sub_10004D2C8(v76);
            }
            uint64_t v60 = v47 + 1;
            int v47 = v46;
            if (v60 != v46)
            {
              int v47 = v60;
              do
              {
                if (v48(*v47)) {
                  goto LABEL_132;
                }
                ++v47;
              }
              while (v47 != v46);
              int v47 = v46;
            }
LABEL_132:
            ;
          }
        }
        operator delete();
      }
      goto LABEL_11;
    }
    unsigned __int8 v71 = 0;
    uint64_t v68 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    int v25 = v23;
    if (v23[23] < 0) {
      int v25 = *(char **)v23;
    }
    sub_100F45924((uint64_t)&v68, v5, v25);
    uint64_t v26 = sub_100365D74();
    if (v70 >= 0) {
      uint64_t v27 = (char *)&v68;
    }
    else {
      uint64_t v27 = (char *)v68;
    }
    sub_100058DB0(buf, v27);
    BOOL v28 = sub_100F448FC(v26, (void **)buf, &v71);
    BOOL v29 = v28;
    if ((buf[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (!v29) {
        goto LABEL_91;
      }
    }
    else if (!v28)
    {
      goto LABEL_91;
    }
    if (v62)
    {
      BOOL v30 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        if (v77 >= 0) {
          unsigned int v31 = (std::__shared_weak_count *)HIBYTE(v77);
        }
        else {
          unsigned int v31 = v76;
        }
        if (v77 >= 0) {
          BOOL v32 = (void **)&v75;
        }
        else {
          BOOL v32 = (void **)v75;
        }
        int v33 = v23;
        if (v23[23] < 0) {
          int v33 = *(char **)v23;
        }
        uint64_t v34 = asString();
        *(_DWORD *)long long buf = 136315650;
        int v35 = "<invalid>";
        if (v31) {
          int v35 = (const char *)v32;
        }
        *(void *)&uint8_t buf[4] = v35;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v33;
        *(_WORD *)&unsigned char buf[22] = 2080;
        v79[0] = v34;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Migration -- %s : key: %s, value: %s", buf, 0x20u);
        uint64_t v1 = v61;
      }
      int v36 = (const __CFString **)v23;
      if (v23[23] < 0) {
        int v36 = *(const __CFString ***)v23;
      }
      sub_100F449E4(v1, v5, v36, v71);
    }
    char v37 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      int v38 = &v68;
      if (v70 < 0) {
        int v38 = v68;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Erase : key : %s", buf, 0xCu);
    }
    uint64_t v39 = (uint64_t **)sub_100365D74();
    if (v70 >= 0) {
      uint64_t v40 = (char *)&v68;
    }
    else {
      uint64_t v40 = (char *)v68;
    }
    sub_100058DB0(buf, v40);
    sub_1003660FC(v39, (void **)buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
LABEL_91:
    if (SHIBYTE(v70) < 0) {
      operator delete(v68);
    }
    v23 += 24;
  }
}