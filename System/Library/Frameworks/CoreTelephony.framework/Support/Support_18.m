void sub_1009E67B0(uint64_t a1, int a2)
{
  NSObject *v4;
  void v5[5];
  int v6;
  void block[6];
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;

  if (subscriber::isValidSimSlot())
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_1009E68D0;
    v5[3] = &unk_101A24EC0;
    v5[4] = a1;
    v6 = a2;
    v9 = 0;
    v10 = 0;
    sub_10003E168(&v9, (void *)(a1 + 8));
    v4 = *(NSObject **)(a1 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 1174405120;
    block[2] = sub_1009EE930;
    block[3] = &unk_101A25358;
    block[5] = v9;
    v8 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    block[4] = v5;
    dispatch_async(v4, block);
    if (v8) {
      sub_10004D2C8(v8);
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
}

uint64_t **sub_1009E68D0(uint64_t a1)
{
  v1 = (int *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 32);
  v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *(unsigned int *)(a1 + 40));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I CellBroadcast service ready received", v5, 2u);
  }
  sms::Controller::setupBasebandForCellBroadcast_sync(v2, *v1);
  v6 = v1;
  result = sub_1001B0B78((uint64_t **)(v2 + 2544), v1, (uint64_t)&unk_10144E20E, &v6);
  *((unsigned char *)result[5] + 271) = 1;
  return result;
}

void sub_1009E69A4(uint64_t a1, void *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v36 = v6;
  v10 = sub_10004D37C(&v5[1].__m_.__sig, &v36);
  if (v10)
  {
    uint64_t v12 = v10[3];
    v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  v11 = 0;
  char v13 = 1;
LABEL_9:
  uint64_t v14 = *(unsigned int *)(*a2 + 152);
  CSIPhoneNumber::CSIPhoneNumber();
  CSIPhoneNumber::CSIPhoneNumber();
  uint64_t v16 = *a2;
  uint64_t v15 = a2[1];
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  v38 = 0;
  v17 = operator new(0x20uLL);
  void *v17 = off_101A289F0;
  v17[1] = a1;
  v17[2] = v16;
  v17[3] = v15;
  v38 = v17;
  (*(void (**)(uint64_t, uint64_t, unsigned char *, uint64_t *, void *))(*(void *)v12 + 168))(v12, v14, v27, &v18, v37);
  sub_1005A5234(v37);
  if (v26 < 0) {
    operator delete(__p);
  }
  if (v24 < 0) {
    operator delete(v23);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (v20 < 0) {
    operator delete(v19);
  }
  if (v35 < 0) {
    operator delete(v34);
  }
  if (v33 < 0) {
    operator delete(v32);
  }
  if (v31 < 0) {
    operator delete(v30);
  }
  if (v29 < 0)
  {
    operator delete(v28);
    if (v13) {
      return;
    }
  }
  else if (v13)
  {
    return;
  }
  sub_10004D2C8(v11);
}

void sub_1009E6BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  sub_1005A5234((void *)(v28 - 104));
  sub_100087E24((uint64_t)&a9);
  sub_100087E24((uint64_t)&a26);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009E6C54(uint64_t a1, uint64_t a2, int a3, CSIPhoneNumber *a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7)
{
  int v30 = a2;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    memset(&__str, 0, sizeof(__str));
    uint64_t v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    CSIPhoneNumber::getFullNumber((uint64_t *)&__p, a4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
      operator delete(__p.__r_.__value_.__l.__data_);
      if (size) {
        goto LABEL_4;
      }
    }
    else if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
    {
LABEL_4:
      CSIPhoneNumber::getFullNumber((uint64_t *)&__p, a4);
      goto LABEL_13;
    }
    uint64_t v16 = *v14;
    if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
    {
      v27[0] = &v30;
      v17 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v30, (uint64_t)&unk_10144E20E, (_DWORD **)v27);
      CSIPhoneNumber::getFullNumber((uint64_t *)&__p, (CSIPhoneNumber *)(v17[5] + 10));
      uint64_t v18 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I sendProactiveSms: Address not provided by SIM. Setting to Service Center Number (SMSC) - %s", (uint8_t *)&buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    *(void *)&long long buf = &v30;
    v19 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v30, (uint64_t)&unk_10144E20E, (_DWORD **)&buf);
    CSIPhoneNumber::getFullNumber((uint64_t *)&__p, (CSIPhoneNumber *)(v19[5] + 10));
LABEL_13:
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    std::string __str = __p;
    int v20 = *(char *)(a5 + 23);
    if (v20 >= 0) {
      v21 = (char *)a5;
    }
    else {
      v21 = *(char **)a5;
    }
    if (v20 >= 0) {
      size_t v22 = *(unsigned __int8 *)(a5 + 23);
    }
    else {
      size_t v22 = *(void *)(a5 + 8);
    }
    uint64_t v36 = 0;
    long long buf = 0uLL;
    sub_10012C7D0((char *)&buf, v21, &v21[v22], v22);
    v27[0] = 0;
    v27[1] = 0;
    uint64_t v28 = 0;
    sub_1009D7F94((uint64_t *)v27, (uint64_t)&buf);
    v23 = *v14;
    if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
    {
      char v24 = v27;
      if (v28 < 0) {
        char v24 = (void **)v27[0];
      }
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      int v26 = *a7;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_str;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
      int v32 = a3;
      __int16 v33 = 1024;
      int v34 = v26;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Sending Proactive SMS %s to Address - %s session %d isPackingRequired %d", (uint8_t *)&__p, 0x22u);
    }
    operator new();
  }
  return result;
}

void sub_1009E76BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::__shared_weak_count *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v35);
  if (a20) {
    sub_10004D2C8(a20);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  v38 = *(void **)(v36 - 128);
  if (v38)
  {
    *(void *)(v36 - 120) = v38;
    operator delete(v38);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void sub_1009E784C(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (subscriber::isValidSimSlot())
  {
    uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a3);
    unsigned int v9 = (std::__shared_weak_count *)operator new(0x2B0uLL);
    v9->__shared_owners_ = 0;
    v9->__shared_weak_owners_ = 0;
    v9->__vftable = (std::__shared_weak_count_vtbl *)off_101A28B48;
    SmsPduDecoder::SmsPduDecoder((SmsPduDecoder *)&v9[1]);
    if (*(char *)(a2 + 23) >= 0) {
      v10 = (const char *)a2;
    }
    else {
      v10 = *(const char **)a2;
    }
    if (SmsPduDecoder::decode((SmsPduDecoder *)&v9[1], v10, 1))
    {
      if ((a4 & 1) == 0) {
        operator new();
      }
    }
    else
    {
      v11 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(block) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Failed to decode the SMS pdu for simulation", (uint8_t *)&block, 2u);
      }
    }
    sub_10004D2C8(v9);
  }
}

void sub_1009E7B30(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  sub_10004D2C8(v1);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1009E7BCC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v3 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 40);
  v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 24))(v2, &v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  v4 = **(NSObject ***)(a1 + 56);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Simulated SMS received", v5, 2u);
  }
}

void sub_1009E7C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009E7C9C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009E7CB8(uint64_t a1)
{
  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1009E7CC8(uint64_t a1, char a2)
{
  uint64_t v2 = *(os_log_t **)(a1 + 40);
  v3 = *v2;
  if (a2)
  {
    if (!os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    __int16 v23 = 0;
    v4 = "#I Successfully stored MWI info from SMS over IMS";
    v5 = (uint8_t *)&v23;
    uint64_t v6 = v3;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v4, v5, 2u);
    return;
  }
  uint64_t v8 = *(void *)(a1 + 32);
  BOOL v9 = os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR);
  if (v9)
  {
    *(_WORD *)v25 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to store MWI info from SMS over IMS. Set VM state anyway", v25, 2u);
  }
  if (!capabilities::ct::supportsVoiceCall((capabilities::ct *)v9))
  {
    v21 = **(NSObject ***)(a1 + 40);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    v4 = "#I Device does not support Voicecalls, ignoring Voicemail Indication";
    v5 = buf;
    uint64_t v6 = v21;
    goto LABEL_16;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(v8 + 80));
  uint64_t v12 = ServiceMap;
  if ((v13 & 0x8000000000000000) != 0)
  {
    uint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      unint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v13;
  v17 = sub_10004D37C(&v12[1].__m_.__sig, &v26);
  if (!v17)
  {
    uint64_t v19 = 0;
LABEL_18:
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
    if (!v19) {
      goto LABEL_23;
    }
LABEL_19:
    if (*(unsigned char *)(a1 + 57)) {
      uint64_t v22 = *(unsigned int *)(a1 + 52);
    }
    else {
      uint64_t v22 = 0xFFFFFFFFLL;
    }
    (*(void (**)(uint64_t, void, BOOL, BOOL, uint64_t, void))(*(void *)v19 + 16))(v19, *(unsigned int *)(a1 + 48), *(unsigned char *)(a1 + 56) != 0, *(unsigned char *)(a1 + 57) != 0, v22, 0);
    goto LABEL_23;
  }
  uint64_t v19 = v17[3];
  uint64_t v18 = (std::__shared_weak_count *)v17[4];
  if (!v18) {
    goto LABEL_18;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v18);
  char v20 = 0;
  if (v19) {
    goto LABEL_19;
  }
LABEL_23:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_1009E7ECC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009E7EE8(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6)
{
  unsigned int v8 = a2;
  int v88 = a2;
  unsigned __int8 v87 = 5;
  if (*((char *)a3 + 23) >= 0) {
    unint64_t v10 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    unint64_t v10 = a3[1];
  }
  v11 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v12 = *v11;
  if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&buf[4] = a4;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Destination port is: %d", buf, 8u);
    unsigned int v8 = v88;
  }
  unint64_t v13 = operator new(0x10uLL);
  *(void *)long long buf = v13;
  *(void *)&buf[16] = v13 + 2;
  *unint64_t v13 = @"SMSSettings";
  v13[1] = @"UseAlternateVVMPort";
  *(void *)&buf[8] = v13 + 2;
  v78 = (Registry **)(a1 + 80);
  ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(a1 + 80), *(Registry **)(a1 + 80));
  uint64_t v15 = ServiceMap;
  if (v16 < 0)
  {
    v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      uint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(ServiceMap);
  cf[0] = (CFTypeRef)v16;
  char v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)cf);
  if (!v20)
  {
    std::mutex::unlock(v15);
    LODWORD(v21) = 0;
    goto LABEL_21;
  }
  v21 = (BOOL *)v20[3];
  uint64_t v22 = (std::__shared_weak_count *)v20[4];
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v15);
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    __int16 v23 = v22;
    sub_10004D2C8(v22);
    if (!v21)
    {
LABEL_20:
      sub_10004D2C8(v23);
      goto LABEL_21;
    }
  }
  else
  {
    __int16 v23 = 0;
    std::mutex::unlock(v15);
    if (!v21) {
      goto LABEL_21;
    }
  }
  (*(void (**)(CFTypeRef *__return_ptr, BOOL *, void, uint64_t, uint8_t *, const CFBooleanRef, void))(*(void *)v21 + 104))(cf, v21, v8, 1, buf, kCFBooleanFalse, 0);
  v21 = (BOOL *)cf[0];
  LOBYTE(v84) = 0;
  if (cf[0])
  {
    CFTypeID v24 = CFGetTypeID(cf[0]);
    if (v24 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v84, v21, v25);
      LODWORD(v21) = (_BYTE)v84 != 0;
    }
    else
    {
      LODWORD(v21) = 0;
    }
  }
  sub_1000577C4(cf);
  if (v23) {
    goto LABEL_20;
  }
LABEL_21:
  if (*(void *)buf)
  {
    *(void *)&buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v21) {
    int v26 = 5496;
  }
  else {
    int v26 = 5499;
  }
  if ((a4 - 5497) < 2 || v26 == a4)
  {
    if (v10 < 0x400)
    {
      v84 = 0;
      sub_1009EA058((CFStringRef *)&v84, (const char *)a3, 0);
      if (v84) {
        int v30 = sub_1000810B8;
      }
      else {
        int v30 = 0;
      }
      if (v30)
      {
        uint64_t v94 = 0;
        memset(buf, 0, sizeof(buf));
        NetworkNotification::NetworkNotification((NetworkNotification *)buf, v84);
        int v32 = NetworkNotification::type(v31);
        __int16 v33 = *v11;
        if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
        {
          int v34 = (const void *)asString();
          LODWORD(cf[0]) = 136315138;
          *(CFTypeRef *)((char *)cf + 4) = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Handling SMS as %s", (uint8_t *)cf, 0xCu);
        }
        switch(v32)
        {
          case 0:
            int v28 = 2;
            break;
          case 1:
            (*(void (**)(void, void, uint8_t *, uint64_t))(**(void **)(a1 + 2528) + 16))(*(void *)(a1 + 2528), v88, buf, a5);
            int v28 = 0;
            unsigned __int8 v87 = 0;
            break;
          case 2:
            (*(void (**)(void, void, uint8_t *))(**(void **)(a1 + 2528) + 88))(*(void *)(a1 + 2528), v88, buf);
            int v28 = 0;
            unsigned __int8 v61 = 3;
            goto LABEL_110;
          case 3:
            cf[0] = &v88;
            if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v88, (uint64_t)&unk_10144E20E, (_DWORD **)cf)[5] + 600))
            {
              cf[0] = &v88;
              v62 = sub_1001B0B78((uint64_t **)(a1 + 2544), &v88, (uint64_t)&unk_10144E20E, (_DWORD **)cf)[5];
              *((unsigned char *)v62 + 592) = 0;
              *((unsigned char *)v62 + 600) = 0;
            }
            (*(void (**)(void, uint8_t *, void))(**(void **)(a1 + 2528) + 24))(*(void *)(a1 + 2528), buf, v88);
            int v28 = 0;
            unsigned __int8 v61 = 2;
LABEL_110:
            unsigned __int8 v87 = v61;
            break;
          default:
            int v28 = 0;
            break;
        }
        NetworkNotification::~NetworkNotification((NetworkNotification *)buf);
      }
      else
      {
        v56 = *v11;
        if (os_log_type_enabled(*v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Failed to convert SMS body to UTF8 string which is expected", buf, 2u);
        }
        int v28 = 1;
      }
      sub_1000558F4((const void **)&v84);
    }
    else
    {
      char v29 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218240;
        *(void *)&buf[4] = v10;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 1024;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Got a network notification of length: %lu, max: %lu", buf, 0x16u);
      }
      int v28 = 3;
    }
    goto LABEL_169;
  }
  if (a4 == 7275)
  {
    char v27 = *v11;
    if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Handled SUPL INIT MT SMS notification", buf, 2u);
    }
    (*(void (**)(void, void, uint64_t *))(**(void **)(a1 + 2528) + 96))(*(void *)(a1 + 2528), v88, a3);
    int v28 = 0;
    unsigned __int8 v87 = 4;
    goto LABEL_169;
  }
  int isMessagesInstalled = MessageCenterModel::isMessagesInstalled(v78);
  int v36 = isMessagesInstalled;
  if (a4 == 2948)
  {
    int v37 = *((char *)a3 + 23);
    if (v37 >= 0) {
      v38 = (char *)a3;
    }
    else {
      v38 = (char *)*a3;
    }
    if (v37 >= 0) {
      size_t v39 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      size_t v39 = a3[1];
    }
    v85 = 0;
    uint64_t v86 = 0;
    v84 = 0;
    sub_10012C7D0((char *)&v84, v38, &v38[v39], v39);
    std::string __p = 0;
    uint64_t v82 = 0;
    uint64_t v83 = 0;
    sub_1009D7F94((uint64_t *)&__p, (uint64_t)&v84);
    v40 = *v11;
    if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
    {
      p_p = &__p;
      if (v83 < 0) {
        p_p = __p;
      }
      *(_DWORD *)long long buf = 136642819;
      *(void *)&buf[4] = p_p;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I WAP push (as hex str): %{sensitive}s", buf, 0xCu);
    }
    if (v36
      && (*(unsigned int (**)(void, void, uint64_t *, uint64_t))(**(void **)(a1 + 2528) + 104))(*(void *)(a1 + 2528), v88, a3, a5))
    {
      v42 = v11;
      v43 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Handled WAP push as MMS notification", buf, 2u);
      }
      int v28 = 0;
      unsigned __int8 v44 = 1;
LABEL_96:
      unsigned __int8 v87 = v44;
      int v58 = 2;
      goto LABEL_160;
    }
    if ((*(unsigned int (**)(void, void, uint64_t *))(**(void **)(a1 + 2528) + 112))(*(void *)(a1 + 2528), v88, a3))
    {
      v42 = v11;
      v57 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I Handled WAP push as SUPL INIT notification", buf, 2u);
      }
      int v28 = 0;
      unsigned __int8 v44 = 4;
      goto LABEL_96;
    }
    if ((v36 & 1) == 0)
    {
      v42 = v11;
      v65 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I Messages is not installed. Dropping incoming message.", buf, 2u);
      }
      unsigned __int8 v87 = 5;
      int v58 = 2;
      int v28 = 2;
LABEL_160:
      if (SHIBYTE(v83) < 0) {
        operator delete(__p);
      }
      if (v84)
      {
        v85 = v84;
        operator delete(v84);
      }
      if (v58) {
        goto LABEL_169;
      }
      v11 = v42;
      if (v36) {
        goto LABEL_169;
      }
      goto LABEL_166;
    }
    *(void *)v89 = 0;
    sub_1009EA058((CFStringRef *)v89, (const char *)a3, 0);
    if (*(void *)v89) {
      v59 = sub_1000810B8;
    }
    else {
      v59 = 0;
    }
    if (!v59)
    {
      v42 = v11;
      v66 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v58 = 2;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "#I Failed to convert SMS body to UTF8 string which is expected", buf, 2u);
      }
      else
      {
        int v58 = 2;
      }
      int v28 = 2;
      goto LABEL_159;
    }
    uint64_t v94 = 0;
    memset(buf, 0, sizeof(buf));
    NetworkNotification::NetworkNotification((NetworkNotification *)buf, *(const __CFString **)v89);
    if (sub_1009EA0C8(a1, v88, (NetworkNotification *)buf, a5, (char *)&v87))
    {
      v42 = v11;
      v60 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(cf[0]) = 0;
        int v58 = 2;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "#I Wap push handled as either voicemail or PNR", (uint8_t *)cf, 2u);
        int v28 = 0;
      }
      else
      {
        int v28 = 0;
        int v58 = 2;
      }
      goto LABEL_158;
    }
    if (v10 > 4)
    {
      sub_1009EA058((CFStringRef *)v80, (const char *)a3, 4uLL);
      cf[0] = *(CFTypeRef *)v89;
      *(void *)v89 = *(void *)v80;
      *(void *)v80 = 0;
      sub_1000558F4(cf);
      sub_1000558F4((const void **)v80);
      if (*(void *)v89) {
        v69 = sub_1000810B8;
      }
      else {
        v69 = 0;
      }
      if (v69)
      {
        uint64_t v92 = 0;
        *(_OWORD *)cf = 0u;
        long long v91 = 0u;
        NetworkNotification::NetworkNotification((NetworkNotification *)cf, *(const __CFString **)v89);
        if (sub_1009EA0C8(a1, v88, (NetworkNotification *)cf, a5, (char *)&v87))
        {
          v42 = v11;
          v70 = *v11;
          if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v80 = 0;
            int v58 = 2;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I Wap push handled as either voicemail or PNR", v80, 2u);
            int v28 = 0;
          }
          else
          {
            int v28 = 0;
            int v58 = 2;
          }
        }
        else
        {
          v42 = v11;
          int v58 = 0;
          int v28 = 2;
        }
        NetworkNotification::~NetworkNotification((NetworkNotification *)cf);
        goto LABEL_158;
      }
      v42 = v11;
      v67 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(cf[0]) = 0;
        v68 = "#I Failed to convert SMS body to UTF8 string which is expected";
        goto LABEL_139;
      }
    }
    else
    {
      v42 = v11;
      v67 = *v11;
      if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(cf[0]) = 0;
        v68 = "#I WAP push too small to handle carrier specific case";
LABEL_139:
        int v58 = 2;
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v68, (uint8_t *)cf, 2u);
LABEL_141:
        int v28 = 2;
LABEL_158:
        NetworkNotification::~NetworkNotification((NetworkNotification *)buf);
LABEL_159:
        sub_1000558F4((const void **)v89);
        goto LABEL_160;
      }
    }
    int v58 = 2;
    goto LABEL_141;
  }
  if ((isMessagesInstalled & 1) == 0)
  {
LABEL_166:
    v75 = *v11;
    if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I Messages is not installed. Dropping incoming message.", buf, 2u);
    }
    unsigned __int8 v87 = 5;
    int v28 = 2;
    goto LABEL_169;
  }
  if (a4 != 37273)
  {
LABEL_155:
    int v28 = 0;
LABEL_169:
    unsigned __int8 v64 = v87;
    sms::Controller::submitNetworkNotificationMetric(a1, v88, a4, v87, v28);
    return v64;
  }
  uint64_t v45 = *(void *)(a1 + 2512);
  if (v45)
  {
    uint64_t v46 = a1 + 2512;
    do
    {
      int v47 = *(_DWORD *)(v45 + 28);
      BOOL v48 = v47 < v88;
      if (v47 >= v88) {
        v49 = (uint64_t *)v45;
      }
      else {
        v49 = (uint64_t *)(v45 + 8);
      }
      if (!v48) {
        uint64_t v46 = v45;
      }
      uint64_t v45 = *v49;
    }
    while (*v49);
    if (v46 != a1 + 2512 && v88 >= *(_DWORD *)(v46 + 28) && *(unsigned char *)sub_10012EF5C(a1 + 2504, &v88))
    {
      cf[0] = 0;
      cf[1] = 0;
      sub_1009E9F8C(*v78, cf, (uint64_t *)v78);
      v84 = 0;
      v85 = 0;
      if (cf[0]
        && ((*(void (**)(__CFString **__return_ptr))(*(void *)cf[0] + 16))(&v84), (v50 = v84) != 0))
      {
        if (a6 == 4)
        {
          std::string __p = 0;
          uint64_t v82 = 0;
          ctu::TextConverter::TextConverter((ctu::TextConverter *)&__p);
          int v51 = *((char *)a3 + 23);
          if (v51 >= 0) {
            v52 = (const char *)a3;
          }
          else {
            v52 = (const char *)*a3;
          }
          if (v51 >= 0) {
            unint64_t v53 = *((unsigned __int8 *)a3 + 23);
          }
          else {
            unint64_t v53 = a3[1];
          }
          ctu::TextConverter::setSource((ctu::TextConverter *)&__p, v52, v53);
          ctu::TextConverter::pushConversion();
          memset(buf, 0, 24);
          ctu::TextConverter::readChars((uint64_t *)buf, (ctu::TextConverter *)&__p, 0x7FFFFFFFuLL);
          v54 = *v11;
          if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
          {
            v55 = buf;
            if ((buf[23] & 0x80u) != 0) {
              v55 = *(uint8_t **)buf;
            }
            *(_DWORD *)v89 = 136315138;
            *(void *)&v89[4] = v55;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Handling lazuli binary SMS: [%{senstive}s]", v89, 0xCu);
          }
          (*((void (**)(__CFString *, void, uint8_t *))v84->isa + 9))(v84, v88, buf);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          ctu::TextConverter::~TextConverter((ctu::TextConverter *)&__p);
        }
        else
        {
          v72 = *v11;
          if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v73 = *((unsigned __int8 *)a3 + 23);
            if ((v73 & 0x80u) == 0) {
              v74 = a3;
            }
            else {
              v74 = (uint64_t *)*a3;
            }
            if ((v73 & 0x80u) != 0) {
              uint64_t v73 = a3[1];
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&buf[4] = v74;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v73;
            _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I Handling lazuli SMS: [%{senstive}s] [%lu]", buf, 0x16u);
            v50 = v84;
          }
          (*((void (**)(__CFString *, void, uint64_t *))v50->isa + 9))(v50, v88, a3);
        }
      }
      else
      {
        v71 = *v11;
        if (os_log_type_enabled(*v11, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Failed to find lazuli manager...", buf, 2u);
        }
      }
      if (v85) {
        sub_10004D2C8((std::__shared_weak_count *)v85);
      }
      if (cf[1]) {
        sub_10004D2C8((std::__shared_weak_count *)cf[1]);
      }
      goto LABEL_155;
    }
  }
  v63 = *v11;
  if (os_log_type_enabled(*v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I Unhandled lazuli SMS: Feature not enabled", buf, 2u);
  }
  return 5;
}

void sub_1009E8D94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,std::__shared_weak_count *a27)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  if (a27) {
    sub_10004D2C8(a27);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1009E8EE4(uint64_t a1, int a2)
{
  int v11 = a2;
  v3 = (uint64_t **)(a1 + 2544);
  __p[0] = &v11;
  if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v11, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5] + 600)) {
    return 0;
  }
  Registry::getTimerService((uint64_t *)__p, *(Registry **)(a1 + 80));
  uint64_t v4 = (**(uint64_t (***)(void *))__p[0])(__p[0]);
  v10.__locale_ = (std::locale::__imp *)&v11;
  uint64_t v5 = v4 - sub_1001B0B78(v3, &v11, (uint64_t)&unk_10144E20E, &v10)[5][74];
  if (__p[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__p[1]);
  }
  BOOL v6 = v5 < 180000000000;
  BOOL v7 = v5 < 180000000000;
  if (v6) {
    sub_10056D028(&v10, "^REG-RESP\\?v=[23];r=\\d+;n=\\+\\d+;s=[0-9A-Za-z]+$", 0);
  }
  __p[0] = &v11;
  unsigned int v8 = sub_1001B0B78(v3, &v11, (uint64_t)&unk_10144E20E, (_DWORD **)__p)[5];
  *((unsigned char *)v8 + 592) = 0;
  *((unsigned char *)v8 + 600) = 0;
  return v7;
}

void sub_1009E909C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100155138(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1009E90D4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, int a5)
{
  unsigned int v84 = a2;
  v77 = (uint64_t *)(a1 + 80);
  if (!subscriber::isValidSimSlot()) {
    return 0;
  }
  v76 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 80));
  uint64_t v12 = ServiceMap;
  uint64_t v14 = v13;
  if (v13 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v14;
  uint64_t v18 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
  if (!v18)
  {
    uint64_t v20 = 0;
    goto LABEL_10;
  }
  uint64_t v20 = v18[3];
  unsigned int v19 = (std::__shared_weak_count *)v18[4];
  if (!v19)
  {
LABEL_10:
    std::mutex::unlock(v12);
    v21 = 0;
    char v22 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v12);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  v21 = v19;
  sub_10004D2C8(v19);
  char v22 = 0;
LABEL_11:
  CFTypeID v24 = (uint64_t **)(a1 + 2544);
  *(void *)long long buf = &v84;
  if (!*((_DWORD *)sub_1001B0B78(v24, (int *)&v84, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 78)
    || (*(void *)long long buf = &v84,
        *((unsigned char *)sub_1001B0B78(v24, (int *)&v84, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 270)))
  {
    int valuePtr = -1;
    CFNumberRef v82 = 0;
    if (v20)
    {
      (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v20 + 96))(&v81, v20, v84, 1, @"VMSMFilterProtocolID", 0, 0);
      sub_1000842D0(__p, (CFTypeRef *)&v81);
      *(void *)long long buf = v82;
      CFNumberRef v82 = (const __CFNumber *)__p[0];
      __p[0] = 0;
      sub_1000570E8((const void **)buf);
      sub_1000570E8((const void **)__p);
      sub_1000577C4((const void **)&v81);
      CFNumberRef v25 = v82;
    }
    else
    {
      CFNumberRef v25 = 0;
    }
    if (v25) {
      int v26 = sub_100081E58;
    }
    else {
      int v26 = 0;
    }
    if (v26 && CFNumberGetValue(v25, kCFNumberIntType, &valuePtr) && valuePtr == a5)
    {
      char v27 = *v76;
      if (os_log_type_enabled(*v76, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Protocol identifier filter matched", buf, 2u);
      }
      goto LABEL_67;
    }
    v81 = 0;
    if (!v20)
    {
      v38 = 0;
      goto LABEL_37;
    }
    char v75 = v22;
    int v28 = (std::mutex *)Registry::getServiceMap(v77, (Registry *)*v77);
    char v29 = v28;
    uint64_t v30 = v13;
    if (v13 < 0)
    {
      char v31 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(v28);
    *(void *)long long buf = v30;
    int v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
    if (v34)
    {
      uint64_t v36 = v34[3];
      char v35 = (std::__shared_weak_count *)v34[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v29);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v37 = 0;
LABEL_34:
        (*(void (**)(const void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v36 + 96))(&v80, v36, v84, 1, @"VMSMFilterNumber", 0, 0);
        char v22 = v75;
        sub_100056248(__p, &v80);
        *(void *)long long buf = v81;
        v81 = __p[0];
        __p[0] = 0;
        sub_1000558F4((const void **)buf);
        sub_1000558F4((const void **)__p);
        sub_1000577C4(&v80);
        if ((v37 & 1) == 0) {
          sub_10004D2C8(v35);
        }
        v38 = v81;
LABEL_37:
        if (v38) {
          size_t v39 = sub_1000810B8;
        }
        else {
          size_t v39 = 0;
        }
        if (!v39)
        {
LABEL_58:
          sub_1000558F4((const void **)&v81);
          sub_1000570E8((const void **)&v82);
          goto LABEL_59;
        }
        memset(buf, 0, sizeof(buf));
        uint64_t v86 = 0;
        ctu::cf::assign();
        uint64_t v79 = v86;
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        uint64_t v40 = a4[23];
        if ((v40 & 0x80u) == 0) {
          v41 = (void *)a4[23];
        }
        else {
          v41 = (void *)*((void *)a4 + 1);
        }
        v42 = (void *)HIBYTE(v79);
        int v43 = SHIBYTE(v79);
        if (v79 < 0) {
          v42 = __p[1];
        }
        if (v41 == v42)
        {
          unsigned __int8 v44 = __p[0];
          if (v79 >= 0) {
            uint64_t v45 = __p;
          }
          else {
            uint64_t v45 = (void **)__p[0];
          }
          if ((v40 & 0x80) == 0)
          {
            if (a4[23])
            {
              while (*a4 == *(unsigned __int8 *)v45)
              {
                ++a4;
                uint64_t v45 = (void **)((char *)v45 + 1);
                if (!--v40) {
                  goto LABEL_62;
                }
              }
              goto LABEL_56;
            }
LABEL_62:
            int v47 = *v76;
            if (os_log_type_enabled(*v76, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I Address filter matched", buf, 2u);
            }
            if (v43 < 0) {
              operator delete(v44);
            }
            sub_1000558F4((const void **)&v81);
LABEL_67:
            sub_1000570E8((const void **)&v82);
            __p[0] = 0;
            if (!v20) {
              goto LABEL_78;
            }
            BOOL v48 = (std::mutex *)Registry::getServiceMap(v77, (Registry *)*v77);
            v49 = v48;
            if (v13 < 0)
            {
              v50 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v51 = 5381;
              do
              {
                uint64_t v13 = v51;
                unsigned int v52 = *v50++;
                uint64_t v51 = (33 * v51) ^ v52;
              }
              while (v52);
            }
            std::mutex::lock(v48);
            *(void *)long long buf = v13;
            unint64_t v53 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)buf);
            if (v53)
            {
              uint64_t v55 = v53[3];
              v54 = (std::__shared_weak_count *)v53[4];
              if (v54)
              {
                atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v49);
                atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v54);
                char v56 = 0;
                goto LABEL_76;
              }
            }
            else
            {
              uint64_t v55 = 0;
            }
            std::mutex::unlock(v49);
            v54 = 0;
            char v56 = 1;
LABEL_76:
            (*(void (**)(void **__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v55 + 96))(&v81, v55, v84, 1, @"VMSMFilterContents", 0, 0);
            sub_100056248(&v82, (CFTypeRef *)&v81);
            *(void **)long long buf = __p[0];
            __p[0] = v82;
            CFNumberRef v82 = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)&v82);
            sub_1000577C4((const void **)&v81);
            if ((v56 & 1) == 0) {
              sub_10004D2C8(v54);
            }
LABEL_78:
            CFNumberRef v82 = 0;
            if (*(char *)(a3 + 23) >= 0) {
              v57 = (const char *)a3;
            }
            else {
              v57 = *(const char **)a3;
            }
            CFStringRef v58 = CFStringCreateWithCString(kCFAllocatorDefault, v57, 0x8000100u);
            CFNumberRef v82 = (const __CFNumber *)v58;
            if (v58) {
              v59 = sub_1000810B8;
            }
            else {
              v59 = 0;
            }
            if (v59)
            {
              if (__p[0]) {
                v60 = sub_1000810B8;
              }
              else {
                v60 = 0;
              }
              if (!v60
                || (*(char *)(a3 + 23) >= 0
                  ? (v61.length = *(unsigned __int8 *)(a3 + 23))
                  : (v61.length = *(void *)(a3 + 8)),
                    v61.location = 0,
                    CFStringFindWithOptions(v58, (CFStringRef)__p[0], v61, 0, 0)))
              {
                v62 = (std::mutex *)Registry::getServiceMap(v77, (Registry *)*v77);
                v63 = v62;
                if (v64 < 0)
                {
                  v65 = (unsigned __int8 *)(v64 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v66 = 5381;
                  do
                  {
                    uint64_t v64 = v66;
                    unsigned int v67 = *v65++;
                    uint64_t v66 = (33 * v66) ^ v67;
                  }
                  while (v67);
                }
                std::mutex::lock(v62);
                *(void *)long long buf = v64;
                v68 = sub_10004D37C(&v63[1].__m_.__sig, (unint64_t *)buf);
                if (v68)
                {
                  uint64_t v70 = v68[3];
                  v69 = (std::__shared_weak_count *)v68[4];
                  if (v69)
                  {
                    atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v63);
                    atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v69);
                    char v71 = 0;
                    if (!v70) {
                      goto LABEL_106;
                    }
                    goto LABEL_104;
                  }
                }
                else
                {
                  uint64_t v70 = 0;
                }
                std::mutex::unlock(v63);
                v69 = 0;
                char v71 = 1;
                if (!v70) {
                  goto LABEL_106;
                }
LABEL_104:
                if ((*(uint64_t (**)(uint64_t, void))(*(void *)v70 + 80))(v70, v84))
                {
                  uint64_t v23 = 1;
LABEL_108:
                  if ((v71 & 1) == 0) {
                    sub_10004D2C8(v69);
                  }
LABEL_113:
                  sub_1000558F4((const void **)&v82);
                  sub_1000558F4((const void **)__p);
                  if (v22) {
                    return v23;
                  }
                  goto LABEL_60;
                }
LABEL_106:
                v74 = *v76;
                uint64_t v23 = 0;
                if (os_log_type_enabled(*v76, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I VVM not supported", buf, 2u);
                  uint64_t v23 = 0;
                }
                goto LABEL_108;
              }
              v72 = *v76;
              uint64_t v23 = 0;
              if (!os_log_type_enabled(*v76, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_113;
              }
              *(_WORD *)long long buf = 0;
              uint64_t v73 = "#I Content filter not matched";
            }
            else
            {
              v72 = *v76;
              uint64_t v23 = 0;
              if (!os_log_type_enabled(*v76, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_113;
              }
              *(_WORD *)long long buf = 0;
              uint64_t v73 = "#I Failed to convert SMS body to UTF8 string which is expected";
            }
            _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, v73, buf, 2u);
            uint64_t v23 = 0;
            goto LABEL_113;
          }
          if (!memcmp(*(const void **)a4, v45, *((void *)a4 + 1))) {
            goto LABEL_62;
          }
        }
LABEL_56:
        if (v43 < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    std::mutex::unlock(v29);
    char v35 = 0;
    char v37 = 1;
    goto LABEL_34;
  }
LABEL_59:
  uint64_t v23 = 0;
  if ((v22 & 1) == 0) {
LABEL_60:
  }
    sub_10004D2C8(v21);
  return v23;
}

void sub_1009E99A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,const void *a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  sub_1000558F4(&a24);
  sub_1000558F4(&a14);
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(a1);
}

void sub_1009E9A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_1000570E8((const void **)va);
  if (v10) {
    JUMPOUT(0x1009E9A58);
  }
  JUMPOUT(0x1009E9A50);
}

void sub_1009E9AAC()
{
  if (v0) {
    JUMPOUT(0x1009E9A58);
  }
  JUMPOUT(0x1009E9A50);
}

BOOL sub_1009E9AB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v46 = 0;
  int v47 = 0;
  uint64_t v48 = 0;
  sms::Controller::getDynamicMessageModes_sync(a1, a2, (uint64_t *)&v46);
  memset(&__dst, 0, sizeof(__dst));
  if (*(char *)(a3 + 23) < 0) {
    sub_10004FC84(&__dst, *(void **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __dst = *(std::string *)a3;
  }
  BOOL v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  BOOL v7 = v6;
  unsigned int v8 = (uint64_t *)v46;
  if (v46 != v47)
  {
    while (*(_DWORD *)v8 != 2)
    {
      unsigned int v8 = (uint64_t *)((char *)v8 + 4);
      if (v8 == v47)
      {
        unsigned int v8 = v47;
        break;
      }
    }
  }
  if (v8 == v47)
  {
    unsigned int v19 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Device doesn't support restricted MT SMS mode", buf, 2u);
    }
    goto LABEL_18;
  }
  if (*(double *)(a1 + 2712) != 0.0)
  {
LABEL_18:
    BOOL v20 = 1;
    goto LABEL_69;
  }
  CFArrayRef theArray = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v47, *(Registry **)(a1 + 80));
  char v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    uint64_t v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  uint64_t v16 = 0;
  char v18 = 1;
LABEL_21:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v17 + 96))(__p, v17, a2, 1, @"CarrierOverridesSmsSupportWhitelist", 0, 0);
  sub_100044D6C(&theArray, (CFTypeRef *)__p);
  sub_1000577C4((const void **)__p);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  CFArrayRef v21 = theArray;
  if (theArray) {
    char v22 = sub_100083F10;
  }
  else {
    char v22 = 0;
  }
  if (v22)
  {
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__dst.__r_.__value_.__l.__size_)
      {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
LABEL_34:
        if (p_dst->__r_.__value_.__s.__data_[0] == 43)
        {
          std::string::erase(&__dst, 0, 1uLL);
          CFArrayRef v21 = theArray;
        }
      }
    }
    else if (*((unsigned char *)&__dst.__r_.__value_.__s + 23))
    {
      p_dst = &__dst;
      goto LABEL_34;
    }
    CFIndex Count = CFArrayGetCount(v21);
    if (Count >= 1)
    {
      CFIndex v26 = 0;
      while (1)
      {
        int v43 = 0;
        *(void *)long long buf = CFArrayGetValueAtIndex(theArray, v26);
        sub_100056248(&v43, (CFTypeRef *)buf);
        memset(buf, 0, sizeof(buf));
        uint64_t v50 = 0;
        ctu::cf::assign();
        uint64_t v42 = v50;
        *(_OWORD *)std::string __p = *(_OWORD *)buf;
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __dst.__r_.__value_.__l.__size_;
        }
        int v28 = (void *)HIBYTE(v42);
        int v29 = SHIBYTE(v42);
        if (v42 < 0) {
          int v28 = __p[1];
        }
        if ((void *)size == v28)
        {
          if (v42 >= 0) {
            uint64_t v30 = __p;
          }
          else {
            uint64_t v30 = (void **)__p[0];
          }
          if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            BOOL v39 = memcmp(__dst.__r_.__value_.__l.__data_, v30, __dst.__r_.__value_.__l.__size_) == 0;
          }
          else
          {
            if (!*((unsigned char *)&__dst.__r_.__value_.__s + 23))
            {
              BOOL v39 = 1;
              if ((SHIBYTE(v42) & 0x80000000) == 0) {
                goto LABEL_61;
              }
LABEL_60:
              operator delete(__p[0]);
              goto LABEL_61;
            }
            uint64_t v31 = HIBYTE(__dst.__r_.__value_.__r.__words[2]) - 1;
            uint64_t v32 = &__dst;
            do
            {
              int v34 = v32->__r_.__value_.__s.__data_[0];
              uint64_t v32 = (std::string *)((char *)v32 + 1);
              int v33 = v34;
              int v36 = *(unsigned __int8 *)v30;
              uint64_t v30 = (void **)((char *)v30 + 1);
              int v35 = v36;
              BOOL v38 = v31-- != 0;
              BOOL v39 = v33 == v35;
            }
            while (v33 == v35 && v38);
          }
          if (v29 < 0) {
            goto LABEL_60;
          }
        }
        else
        {
          BOOL v39 = 0;
          if (SHIBYTE(v42) < 0) {
            goto LABEL_60;
          }
        }
LABEL_61:
        sub_1000558F4(&v43);
        if (v39) {
          goto LABEL_67;
        }
        if (++v26 == Count)
        {
          CFIndex v26 = Count;
          goto LABEL_67;
        }
      }
    }
    CFIndex v26 = 0;
LABEL_67:
    BOOL v20 = v26 != Count;
    goto LABEL_68;
  }
  CFTypeID v24 = *v7;
  BOOL v20 = 0;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Key CarrierOverridesSmsSupportWhitelist absent in the bundle", buf, 2u);
    BOOL v20 = 0;
  }
LABEL_68:
  sub_100044D00((const void **)&theArray);
LABEL_69:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v46)
  {
    int v47 = (uint64_t *)v46;
    operator delete(v46);
  }
  return v20;
}

void sub_1009E9EF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, int a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a22)
  {
    a23 = (uint64_t)a22;
    operator delete(a22);
  }
  _Unwind_Resume(a1);
}

void sub_1009E9F8C(Registry *this@<X1>, void *a2@<X0>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, this);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v13 = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, &v13);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  *a2 = v12;
  a2[1] = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
}

CFStringRef sub_1009EA058(CFStringRef *a1, const char *a2, unint64_t a3)
{
  if (a2[23] < 0)
  {
    if (*((void *)a2 + 1) <= a3)
    {
LABEL_7:
      CFStringRef result = 0;
      goto LABEL_8;
    }
    a2 = *(const char **)a2;
  }
  else if (*((unsigned __int8 *)a2 + 23) <= a3)
  {
    goto LABEL_7;
  }
  CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, &a2[a3], 0x8000100u);
LABEL_8:
  *a1 = result;
  return result;
}

uint64_t sub_1009EA0C8(uint64_t a1, uint64_t a2, NetworkNotification *this, uint64_t a4, char *a5)
{
  int v10 = NetworkNotification::type(this);
  if (v10 == 3)
  {
    uint64_t result = (*(uint64_t (**)(void, NetworkNotification *, uint64_t))(**(void **)(a1 + 2528) + 24))(*(void *)(a1 + 2528), this, a2);
    char v12 = 2;
    goto LABEL_5;
  }
  if (v10 == 1)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, NetworkNotification *, uint64_t))(**(void **)(a1 + 2528) + 16))(*(void *)(a1 + 2528), a2, this, a4);
    char v12 = 0;
LABEL_5:
    *a5 = v12;
    return result;
  }
  return 0;
}

void sub_1009EA19C(uint64_t a1)
{
}

void sub_1009EA1AC(uint64_t a1, int a2)
{
  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3 || (v5 = *(void *)(a1 + 8), (unint64_t v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  BOOL v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  Registry::getTimerService(&v20, *(Registry **)(a1 + 80));
  uint64_t v8 = v20;
  sub_100058DB0(__p, "SMS Hold timer");
  unsigned int v9 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 1174405120;
  v13[2] = sub_1009EA3F0;
  v13[3] = &unk_101A24F50;
  v13[4] = a1;
  v13[5] = v5;
  unsigned int v14 = v7;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v15 = a2;
  aBlock = _Block_copy(v13);
  sub_100118A44(v8, (uint64_t)__p, 0, 30000000, &object, &aBlock);
  uint64_t v10 = v22;
  uint64_t v22 = 0;
  uint64_t v11 = *(void *)(a1 + 2632);
  *(void *)(a1 + 2632) = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v22;
    uint64_t v22 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  std::__shared_weak_count::__release_weak(v7);
}

void sub_1009EA384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  char v27 = *(std::__shared_weak_count **)(v25 - 64);
  if (v27) {
    sub_10004D2C8(v27);
  }
  std::__shared_weak_count::__release_weak(v24);
  _Unwind_Resume(a1);
}

void sub_1009EA3F0(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        unsigned int v7 = *(_DWORD *)(a1 + 56);
        unint64_t v6 = (int *)(a1 + 56);
        uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v7);
        uint64_t v9 = *(void *)(v3 + 2440);
        if (v9)
        {
          int v10 = *v6;
          uint64_t v11 = v3 + 2440;
          do
          {
            int v12 = *(_DWORD *)(v9 + 28);
            BOOL v13 = v12 < v10;
            if (v12 >= v10) {
              unsigned int v14 = (uint64_t *)v9;
            }
            else {
              unsigned int v14 = (uint64_t *)(v9 + 8);
            }
            if (!v13) {
              uint64_t v11 = v9;
            }
            uint64_t v9 = *v14;
          }
          while (*v14);
          if (v11 != v3 + 2440 && v10 >= *(_DWORD *)(v11 + 28))
          {
            int v15 = *(_DWORD *)(v11 + 32);
            *(void *)long long buf = v6;
            int v16 = *((_DWORD *)sub_1001B0B78((uint64_t **)(v3 + 2544), v6, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
                  + 146);
            uint64_t v17 = *v8;
            if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v32 = v6;
              sub_1001B0B78((uint64_t **)(v3 + 2544), v6, (uint64_t)&unk_10144E20E, &v32);
              uint64_t v18 = asString();
              uint64_t v19 = asString();
              *(_DWORD *)long long buf = 136315394;
              *(void *)&buf[4] = v18;
              __int16 v34 = 2080;
              uint64_t v35 = v19;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I SMS international roaming conditions changed %s ==> %s", buf, 0x16u);
            }
            if (v15 != v16) {
              goto LABEL_35;
            }
          }
        }
        uint64_t v20 = *(void *)(v3 + 2464);
        if (v20)
        {
          int v21 = *v6;
          uint64_t v22 = v3 + 2464;
          do
          {
            int v23 = *(_DWORD *)(v20 + 28);
            BOOL v24 = v23 < v21;
            if (v23 >= v21) {
              uint64_t v25 = (uint64_t *)v20;
            }
            else {
              uint64_t v25 = (uint64_t *)(v20 + 8);
            }
            if (!v24) {
              uint64_t v22 = v20;
            }
            uint64_t v20 = *v25;
          }
          while (*v25);
          if (v22 != v3 + 2464 && v21 >= *(_DWORD *)(v22 + 28))
          {
            int v26 = *(unsigned __int8 *)(v22 + 32);
            *(void *)long long buf = v6;
            int v27 = *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(v3 + 2544), v6, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]+ 588);
            int v28 = *v8;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v32 = v6;
              int v29 = sub_1001B0B78((uint64_t **)(v3 + 2544), v6, (uint64_t)&unk_10144E20E, &v32);
              uint64_t v30 = "true";
              if (*((unsigned char *)v29[5] + 588)) {
                uint64_t v31 = "true";
              }
              else {
                uint64_t v31 = "false";
              }
              if (!*(unsigned char *)(v22 + 32)) {
                uint64_t v30 = "false";
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&buf[4] = v31;
              __int16 v34 = 2080;
              uint64_t v35 = (uint64_t)v30;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I SMS domestic roaming conditions changed %s ==> %s", buf, 0x16u);
            }
            if (v26 != v27) {
LABEL_35:
            }
              (*(void (**)(void, void, uint64_t))(**(void **)(v3 + 2528) + 56))(*(void *)(v3 + 2528), *v6, 1);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1009EA710(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t **sub_1009EA734(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v30 = a2;
  uint64_t v5 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  *(void *)long long buf = &v30;
  uint64_t result = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  if (*((unsigned __int8 *)result[5] + 269) != a3)
  {
    unsigned int v7 = *v5;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)long long buf = &v30;
      uint64_t v8 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      uint64_t v9 = "[ready]";
      if (*((unsigned char *)v8[5] + 269)) {
        int v10 = "[ready]";
      }
      else {
        int v10 = "[not-ready]";
      }
      if (!a3) {
        uint64_t v9 = "[not-ready]";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I SMS changing from %s -> %s", buf, 0x16u);
    }
    *(void *)long long buf = &v30;
    *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 269) = a3;
    v29[0] = 1;
    v29[1] = a1 + 2160;
    *(void *)long long buf = &v30;
    char v11 = *((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
          + 269);
    *(void *)long long buf = &v30;
    *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 2192), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v11;
    uint64_t v12 = *(void *)(a1 + 2528);
    uint64_t v13 = v30;
    *(void *)long long buf = &v30;
    unsigned int v14 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v12 + 48))(v12, v13, *((unsigned __int8 *)v14[5] + 269));
    *(void *)long long buf = &v30;
    if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v30, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
          + 269))
      return (uint64_t **)sub_100A033A0((uint64_t)v29);
    uint64_t v15 = v30;
    int v16 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v30);
    std::string __p = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    sub_1009DCB40((uint64_t)&__p, a1, v15);
    uint64_t v17 = (uint64_t *)HIBYTE(v33);
    if (v33 < 0) {
      uint64_t v17 = v32;
    }
    if (!v17)
    {
LABEL_26:
      if (SHIBYTE(v33) < 0) {
        operator delete(__p);
      }
      sub_1009EA1AC(a1, v30);
      return (uint64_t **)sub_100A033A0((uint64_t)v29);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 80));
    uint64_t v19 = ServiceMap;
    if (v20 < 0)
    {
      int v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v20;
    BOOL v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
    if (v24)
    {
      uint64_t v26 = v24[3];
      uint64_t v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        if (!v26) {
          goto LABEL_19;
        }
        goto LABEL_23;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    uint64_t v25 = 0;
    char v27 = 1;
    if (!v26)
    {
LABEL_19:
      int v28 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to get Subscriber Interface. Not updating TPMR in sim while refreshing TPMR", buf, 2u);
      }
      goto LABEL_24;
    }
LABEL_23:
    *(void *)long long buf = off_101A27178;
    *(void *)&buf[8] = a1;
    *(void *)&uint8_t buf[16] = v15;
    uint64_t v35 = buf;
    (*(void (**)(uint64_t, uint64_t, uint64_t, unsigned char *))(*(void *)v26 + 184))(v26, v15, 36, buf);
    sub_10090EC3C(buf);
LABEL_24:
    if ((v27 & 1) == 0) {
      sub_10004D2C8(v25);
    }
    goto LABEL_26;
  }
  return result;
}

void sub_1009EAB94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18)
{
  sub_10090EC3C(&a18);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_100A033A0((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1009EABF4(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_1009EACE0(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(a1 + 40))
      {
        uint64_t v5 = *(void *)(v3 + 2640);
        *(void *)(v3 + 2640) = 0;
        if (v5) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
        unint64_t v6 = **(NSObject ***)(a1 + 56);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unsigned int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I 2G location hint timer expiry", v7, 2u);
        }
        sub_1009EABF4(v3);
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_1009EADB8(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (!*(void *)(a1 + 32))
  {
    BOOL v5 = 1;
LABEL_7:
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_100A03FDC;
    v9[3] = &unk_101A28D20;
    v9[4] = a1 + 8;
    v9[5] = v7;
    int v10 = v9;
    unint64_t v6 = *(NSObject **)(a1 + 24);
    unsigned __int8 v16 = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = (_DWORD *)0x40000000;
    if (v5)
    {
      uint64_t v12 = sub_10005A304;
      uint64_t v13 = &unk_101A253A8;
      unsigned int v14 = &v16;
      uint64_t v15 = &v10;
      dispatch_sync(v6, block);
    }
    else
    {
      uint64_t v12 = sub_10005B068;
      uint64_t v13 = &unk_101A253C8;
      unsigned int v14 = &v16;
      uint64_t v15 = &v10;
      dispatch_async_and_wait(v6, block);
    }
    int v4 = v16;
    return v4 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v5 = *(void *)(a1 + 32) == 0;
    goto LABEL_7;
  }
  uint64_t result = subscriber::isValidSimSlot();
  if (!result) {
    return result;
  }
  block[0] = &v8;
  int v4 = *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v8, (uint64_t)&unk_10144E20E, block)[5] + 269);
  return v4 != 0;
}

uint64_t sub_1009EAF68(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (!*(void *)(a1 + 32))
  {
    BOOL v5 = 1;
LABEL_7:
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_100A04048;
    v9[3] = &unk_101A28D40;
    v9[4] = a1 + 8;
    v9[5] = v7;
    int v10 = v9;
    unint64_t v6 = *(NSObject **)(a1 + 24);
    unsigned __int8 v16 = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = (_DWORD *)0x40000000;
    if (v5)
    {
      uint64_t v12 = sub_10005A304;
      uint64_t v13 = &unk_101A253A8;
      unsigned int v14 = &v16;
      uint64_t v15 = &v10;
      dispatch_sync(v6, block);
    }
    else
    {
      uint64_t v12 = sub_10005B068;
      uint64_t v13 = &unk_101A253C8;
      unsigned int v14 = &v16;
      uint64_t v15 = &v10;
      dispatch_async_and_wait(v6, block);
    }
    int v4 = v16;
    return v4 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v5 = *(void *)(a1 + 32) == 0;
    goto LABEL_7;
  }
  uint64_t result = subscriber::isValidSimSlot();
  if (!result) {
    return result;
  }
  block[0] = &v8;
  int v4 = *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v8, (uint64_t)&unk_10144E20E, block)[5] + 271);
  return v4 != 0;
}

void sub_1009EB118(uint64_t a1@<X0>, NSObject **a2@<X8>)
{
  char v2 = *(NSObject **)(a1 + 24);
  *a2 = v2;
  if (v2) {
    dispatch_retain(v2);
  }
}

void sub_1009EB130(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v22 = a2;
  BOOL v5 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  unint64_t v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v7 = "false";
    if (a3) {
      unsigned int v7 = "true";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Emergency session intent: %s", buf, 0xCu);
  }
  if (a3)
  {
    *(void *)long long buf = &v22;
    if (!*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]
          + 270))
    {
      int v8 = *v5;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v9 = "#I Ims not over Wifi, no further actions required";
      goto LABEL_15;
    }
    if (sub_1009C8E34(a1, v22))
    {
      int v8 = *v5;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v9 = "#I Carrier preference to use Wifi for Emergency Text.";
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, buf, 2u);
      return;
    }
    if (sub_1009E62D8(a1))
    {
      int v8 = *v5;
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v9 = "#I Active Call. Not handling Emergency Text intent.";
      goto LABEL_15;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v10, *(Registry **)(a1 + 80));
    uint64_t v12 = ServiceMap;
    if (v13 < 0)
    {
      unsigned int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v13;
    uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)buf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      uint64_t v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        if (!v19) {
          goto LABEL_23;
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v12);
    uint64_t v18 = 0;
    char v20 = 1;
    if (!v19)
    {
LABEL_23:
      int v21 = *v5;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to get Emergency manager interface", buf, 2u);
      }
      goto LABEL_28;
    }
LABEL_27:
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v19 + 56))(v19, v22, 1);
LABEL_28:
    if ((v20 & 1) == 0) {
      sub_10004D2C8(v18);
    }
  }
}

void sub_1009EB428(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1009EB458(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      BOOL result = 1;
      if (*(_DWORD *)(a1 + 2604) == 1)
      {
        block[0] = &v7;
        if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, block)[5] + 270))
        {
          block[0] = &v7;
          if (*((unsigned char *)sub_1001B0B78((uint64_t **)(a1 + 2544), &v7, (uint64_t)&unk_10144E20E, block)[5] + 42))
          {
            if (*(unsigned char *)(a1 + 200)) {
              return 0;
            }
          }
        }
      }
      return result;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100A040B4;
  v8[3] = &unk_101A28D60;
  v8[4] = a1 + 8;
  v8[5] = v6;
  uint64_t v9 = v8;
  BOOL v5 = *(NSObject **)(a1 + 24);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = (_DWORD *)0x40000000;
  if (v4)
  {
    char v11 = sub_10005A304;
    uint64_t v12 = &unk_101A253A8;
    uint64_t v13 = &v15;
    unsigned int v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    char v11 = sub_10005B068;
    uint64_t v12 = &unk_101A253C8;
    uint64_t v13 = &v15;
    unsigned int v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15 != 0;
}

void sub_1009EB650(uint64_t a1, unsigned int a2, unsigned __int8 a3)
{
  unsigned int v8 = a2;
  unsigned __int8 v7 = a3;
  v6[0] = a1;
  v6[1] = &v8;
  void v6[2] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      sub_1009EB130(a1, v8, v7);
      return;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100A04164;
  block[3] = &unk_101A28D80;
  block[4] = a1 + 8;
  block[5] = v6;
  BOOL v5 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_sync(v5, block);
  }
  else {
    dispatch_async_and_wait(v5, block);
  }
}

unint64_t sub_1009EB734(int *a1, uint64_t a2, const __CFNumber *a3)
{
  if (a1) {
    unint64_t v3 = (unint64_t)sub_100081E58;
  }
  else {
    unint64_t v3 = 0;
  }
  if (v3)
  {
    int v6 = 0;
    ctu::cf::assign((ctu::cf *)&v6, a1, a3);
    if ((v6 - 1) >= 2) {
      unint64_t v3 = 0;
    }
    else {
      unint64_t v3 = v6;
    }
    BOOL v4 = &_mh_execute_header;
  }
  else
  {
    BOOL v4 = 0;
  }
  return (unint64_t)v4 | v3;
}

void sub_1009EB7A8(uint64_t a1)
{
  sub_1009ED35C(a1);

  operator delete();
}

void sub_1009EB7E0()
{
  if (byte_101B0F838 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F858, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F858))
  {
    sub_1009F0720();
    __cxa_atexit((void (*)(void *))sub_1009F06F4, qword_101B0FAD0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F858);
  }
}

void sub_1009EB894(_Unwind_Exception *a1)
{
}

void sub_1009EB8AC()
{
  if (byte_101B0F839 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F860, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F860))
  {
    sub_1009F130C();
    __cxa_atexit((void (*)(void *))sub_1009F12E0, qword_101B0FAF0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F860);
  }
}

void sub_1009EB960(_Unwind_Exception *a1)
{
}

void sub_1009EB978()
{
  if (byte_101B0F83A == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F868, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F868))
  {
    sub_1009F1798();
    __cxa_atexit((void (*)(void *))sub_1009F176C, qword_101B0F950, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F868);
  }
}

void sub_1009EBA2C(_Unwind_Exception *a1)
{
}

void sub_1009EBA44()
{
  if (byte_101B0F83B == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F870, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F870))
  {
    sub_1009F18EC();
    __cxa_atexit((void (*)(void *))sub_1009F18C0, qword_101B0FB10, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F870);
  }
}

void sub_1009EBAF8(_Unwind_Exception *a1)
{
}

void sub_1009EBB10()
{
  if (byte_101B0F83C == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F878, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F878))
  {
    sub_1009F1C00();
    __cxa_atexit((void (*)(void *))sub_1009F1BD4, qword_101B0F968, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F878);
  }
}

void sub_1009EBBC4(_Unwind_Exception *a1)
{
}

void sub_1009EBBDC()
{
  if (byte_101B0F83D == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F880, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F880))
  {
    sub_1009F1D6C();
    __cxa_atexit((void (*)(void *))sub_1009F1D40, qword_101B0FB30, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F880);
  }
}

void sub_1009EBC90(_Unwind_Exception *a1)
{
}

void sub_1009EBCA8()
{
  if (byte_101B0F83E == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F888, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F888))
  {
    sub_1009F2354();
    __cxa_atexit((void (*)(void *))sub_1009F2328, qword_101B0FB50, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F888);
  }
}

void sub_1009EBD5C(_Unwind_Exception *a1)
{
}

void sub_1009EBD74()
{
  if (byte_101B0F83F == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F890, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F890))
  {
    sub_1009F26CC();
    __cxa_atexit((void (*)(void *))sub_1009F26A0, qword_101B0F980, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F890);
  }
}

void sub_1009EBE28(_Unwind_Exception *a1)
{
}

void sub_1009EBE40()
{
  if (byte_101B0F840 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F898, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F898))
  {
    sub_1009F283C();
    __cxa_atexit((void (*)(void *))sub_1009F2810, qword_101B0F998, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F898);
  }
}

void sub_1009EBEF4(_Unwind_Exception *a1)
{
}

void sub_1009EBF0C()
{
  if (byte_101B0F841 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8A0))
  {
    sub_1009F29B8();
    __cxa_atexit((void (*)(void *))sub_1009F298C, qword_101B0FB70, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8A0);
  }
}

void sub_1009EBFC0(_Unwind_Exception *a1)
{
}

void sub_1009EBFD8()
{
  if (byte_101B0F842 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8A8))
  {
    sub_1009F2DD0();
    __cxa_atexit((void (*)(void *))sub_1009F2DA4, qword_101B0F9B0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8A8);
  }
}

void sub_1009EC08C(_Unwind_Exception *a1)
{
}

void sub_1009EC0A4()
{
  if (byte_101B0F843 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8B0))
  {
    sub_1009F2F4C();
    __cxa_atexit((void (*)(void *))sub_1009F2F20, qword_101B0F9C8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8B0);
  }
}

void sub_1009EC158(_Unwind_Exception *a1)
{
}

void sub_1009EC170()
{
  if (byte_101B0F844 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8B8))
  {
    sub_1009F3164();
    __cxa_atexit((void (*)(void *))sub_1009F3138, qword_101B0FB90, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8B8);
  }
}

void sub_1009EC224(_Unwind_Exception *a1)
{
}

void sub_1009EC23C()
{
  if (byte_101B0F845 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8C0))
  {
    sub_1009F408C();
    __cxa_atexit((void (*)(void *))sub_1009F4060, qword_101B0FBB0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8C0);
  }
}

void sub_1009EC2F0(_Unwind_Exception *a1)
{
}

void sub_1009EC308()
{
  if (byte_101B0F846 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8C8))
  {
    sub_1009F44D8();
    __cxa_atexit((void (*)(void *))sub_1009F44AC, qword_101B0F9E0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8C8);
  }
}

void sub_1009EC3BC(_Unwind_Exception *a1)
{
}

void sub_1009EC3D4()
{
  if (byte_101B0F847 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8D0))
  {
    sub_1009F462C();
    __cxa_atexit((void (*)(void *))sub_1009F4600, qword_101B0FBD0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8D0);
  }
}

void sub_1009EC488(_Unwind_Exception *a1)
{
}

void sub_1009EC4A0()
{
  if (byte_101B0F848 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8D8))
  {
    sub_1009F4C44();
    __cxa_atexit((void (*)(void *))sub_1009F4C18, qword_101B0FBF0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8D8);
  }
}

void sub_1009EC554(_Unwind_Exception *a1)
{
}

void sub_1009EC56C()
{
  if (byte_101B0F849 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8E0))
  {
    sub_1009F4F58();
    __cxa_atexit((void (*)(void *))sub_1009F4F2C, qword_101B0F9F8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8E0);
  }
}

void sub_1009EC620(_Unwind_Exception *a1)
{
}

void sub_1009EC638()
{
  if (byte_101B0F84A == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8E8))
  {
    sub_1009F50C4();
    __cxa_atexit((void (*)(void *))sub_1009F5098, qword_101B0FA10, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8E8);
  }
}

void sub_1009EC6EC(_Unwind_Exception *a1)
{
}

void sub_1009EC704()
{
  if (byte_101B0F84B == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8F0))
  {
    sub_1009F5218();
    __cxa_atexit((void (*)(void *))sub_1009F51EC, qword_101B0FC10, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8F0);
  }
}

void sub_1009EC7B8(_Unwind_Exception *a1)
{
}

void sub_1009EC7D0()
{
  if (byte_101B0F84C == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F8F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F8F8))
  {
    sub_1009F5618();
    __cxa_atexit((void (*)(void *))sub_1009F55EC, qword_101B0FA28, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F8F8);
  }
}

void sub_1009EC884(_Unwind_Exception *a1)
{
}

void sub_1009EC89C()
{
  if (byte_101B0F84D == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F900, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F900))
  {
    sub_1009F577C();
    __cxa_atexit((void (*)(void *))sub_1009F5750, qword_101B0FC30, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F900);
  }
}

void sub_1009EC950(_Unwind_Exception *a1)
{
}

void sub_1009EC968()
{
  if (byte_101B0F84E == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F908, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F908))
  {
    sub_1009F5E18();
    __cxa_atexit((void (*)(void *))sub_1009F5DEC, qword_101B0FA40, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F908);
  }
}

void sub_1009ECA1C(_Unwind_Exception *a1)
{
}

void sub_1009ECA34()
{
  if (byte_101B0F84F == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F910, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F910))
  {
    sub_1009F5F94();
    __cxa_atexit((void (*)(void *))sub_1009F5F68, qword_101B0FC50, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F910);
  }
}

void sub_1009ECAE8(_Unwind_Exception *a1)
{
}

void sub_1009ECB00()
{
  if (byte_101B0F850 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F918, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F918))
  {
    sub_1009F63FC();
    __cxa_atexit((void (*)(void *))sub_1009F63D0, qword_101B0FC70, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F918);
  }
}

void sub_1009ECBB4(_Unwind_Exception *a1)
{
}

void sub_1009ECBCC()
{
  if (byte_101B0F851 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F920, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F920))
  {
    sub_1009F6758();
    __cxa_atexit((void (*)(void *))sub_1009F672C, qword_101B0FA58, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F920);
  }
}

void sub_1009ECC80(_Unwind_Exception *a1)
{
}

void sub_1009ECC98()
{
  if (byte_101B0F852 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F928, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F928))
  {
    sub_1009F68AC();
    __cxa_atexit((void (*)(void *))sub_1009F6880, qword_101B0FA70, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F928);
  }
}

void sub_1009ECD4C(_Unwind_Exception *a1)
{
}

void sub_1009ECD64()
{
  if (byte_101B0F853 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F930, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F930))
  {
    sub_1009F6A28();
    __cxa_atexit((void (*)(void *))sub_1009F69FC, qword_101B0FA88, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F930);
  }
}

void sub_1009ECE18(_Unwind_Exception *a1)
{
}

void sub_1009ECE30()
{
  if (byte_101B0F854 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F938, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F938))
  {
    sub_1009F6DAC();
    __cxa_atexit((void (*)(void *))sub_1009F6D80, qword_101B0FC90, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F938);
  }
}

void sub_1009ECEE4(_Unwind_Exception *a1)
{
}

void sub_1009ECEFC()
{
  if (byte_101B0F855 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F940, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F940))
  {
    sub_1009F74BC();
    __cxa_atexit((void (*)(void *))sub_1009F7490, qword_101B0FAA0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F940);
  }
}

void sub_1009ECFB0(_Unwind_Exception *a1)
{
}

void sub_1009ECFC8()
{
  if (byte_101B0F856 == 1) {
    __assert_rtn("get_instance", "singleton.hpp", 167, "! is_destroyed()");
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0F948, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0F948))
  {
    sub_1009F7608();
    __cxa_atexit((void (*)(void *))sub_1009F75DC, qword_101B0FAB8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101B0F948);
  }
}

void sub_1009ED07C(_Unwind_Exception *a1)
{
}

void *sub_1009ED094(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1009ED118(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 60) {
      sub_10006A748();
    }
    int v6 = result;
    BOOL result = sub_1009C886C(a4);
    void *v6 = result;
    v6[1] = result;
    void v6[2] = &result[2 * v7];
    if (a2 != a3)
    {
      unsigned int v8 = result;
      do
      {
        *unsigned int v8 = *a2;
        uint64_t v9 = a2[1];
        v8[1] = v9;
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        result += 2;
        a2 += 2;
        v8 += 2;
      }
      while (a2 != a3);
    }
    v6[1] = result;
  }
  return result;
}

void sub_1009ED1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *sub_1009ED1D8(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_10006A748();
  }
  BOOL result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t sub_1009ED218(long long *a1, long long *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    BOOL v5 = a1;
    do
    {
      long long v6 = *v5;
      *(void *)BOOL v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v7 = *(std::__shared_weak_count **)(a3 + 8);
      *(_OWORD *)a3 = v6;
      if (v7) {
        sub_10004D2C8(v7);
      }
      ++v5;
      a3 += 16;
    }
    while (v5 != a2);
  }
  return a3;
}

BOOL sub_1009ED27C(uint64_t a1)
{
  int v1 = *(_DWORD *)(*(void *)a1 + 184);
  if (v1)
  {
    os_log_t v3 = os_log_create(kCtLoggingSystemName, "cbs");
    os_log_t v6 = v3;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(*(void *)a1 + 184);
      *(_DWORD *)long long buf = 67109120;
      int v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Partial Message with timestamp: %u is being erased", buf, 8u);
    }
    sub_10003F684((void **)&v6);
  }
  return v1 != 0;
}

uint64_t sub_1009ED35C(uint64_t a1)
{
  *(void *)a1 = off_101A24AD8;
  char v2 = *(std::__shared_weak_count **)(a1 + 2736);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1009ED6E0((void *)(a1 + 2672));
  os_log_t v3 = *(std::__shared_weak_count **)(a1 + 2664);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 2648);
  *(void *)(a1 + 2648) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 2640);
  *(void *)(a1 + 2640) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 2632);
  *(void *)(a1 + 2632) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 2624);
  *(void *)(a1 + 2624) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 2616);
  *(void *)(a1 + 2616) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 2592);
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v10 = *(std::__shared_weak_count **)(a1 + 2576);
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100119D90(*(void **)(a1 + 2552));
  char v11 = *(std::__shared_weak_count **)(a1 + 2536);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_1000346F8(a1 + 2504, *(void **)(a1 + 2512));
  sub_1000346F8(a1 + 2480, *(void **)(a1 + 2488));
  sub_1000346F8(a1 + 2456, *(void **)(a1 + 2464));
  sub_1000346F8(a1 + 2432, *(void **)(a1 + 2440));
  sub_10026CF54(a1 + 2408, *(void **)(a1 + 2416));
  sub_1009ED094((void *)(a1 + 2376));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 2352));
  sub_100703778(a1 + 2328, *(char **)(a1 + 2336));
  sub_1000346F8(a1 + 2304, *(void **)(a1 + 2312));
  sub_1000886C0(a1 + 2272, *(char **)(a1 + 2280));
  sub_1000346F8(a1 + 2248, *(void **)(a1 + 2256));
  sub_10041A760((void *)(a1 + 2216));
  sub_1000346F8(a1 + 2192, *(void **)(a1 + 2200));
  sub_10041A760((void *)(a1 + 2160));
  sub_1000346F8(a1 + 2136, *(void **)(a1 + 2144));
  sub_10041A760((void *)(a1 + 2104));
  sub_1000346F8(a1 + 2080, *(void **)(a1 + 2088));
  sub_100136194(a1 + 1280);
  sub_100136194(a1 + 480);
  sub_10003FB28(a1 + 456, *(void **)(a1 + 464));
  sub_100087ED0(a1 + 432, *(void **)(a1 + 440));
  sub_1000886C0(a1 + 408, *(char **)(a1 + 416));
  uint64_t v19 = (void **)(a1 + 384);
  sub_10008A88C(&v19);
  sub_100087F94(a1 + 360, *(void **)(a1 + 368));
  sub_100087F94(a1 + 336, *(void **)(a1 + 344));
  sub_1000346F8(a1 + 312, *(void **)(a1 + 320));
  sub_1000346F8(a1 + 288, *(void **)(a1 + 296));
  sub_1000346F8(a1 + 264, *(void **)(a1 + 272));
  sub_1000346F8(a1 + 232, *(void **)(a1 + 240));
  sub_10005CD2C(a1 + 208, *(char **)(a1 + 216));
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 152);
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (v13) {
    sub_10004D2C8(v13);
  }
  unsigned int v14 = *(std::__shared_weak_count **)(a1 + 120);
  if (v14) {
    sub_10004D2C8(v14);
  }
  char v15 = *(std::__shared_weak_count **)(a1 + 104);
  if (v15) {
    sub_10004D2C8(v15);
  }
  unsigned int v16 = *(std::__shared_weak_count **)(a1 + 88);
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_100160A84((atomic_uint **)(a1 + 56));
  uint64_t v17 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  SmsControllerInterface::~SmsControllerInterface((SmsControllerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void *sub_1009ED6E0(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1009ED768()
{
}

uint64_t sub_1009ED77C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_1009ED78C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1009ED7C4(uint64_t a1)
{
}

uint64_t sub_1009ED7E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009ED824(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009ED850(uint64_t *a1)
{
  char v2 = operator new(0x278uLL);
  v2[1] = 0;
  v2[2] = 0;
  *char v2 = off_101A25140;
  uint64_t result = sub_10082FC38((uint64_t)(v2 + 3));
  *a1 = result;
  a1[1] = (uint64_t)v2;
  return result;
}

void sub_1009ED8A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1009ED8BC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A25140;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009ED8DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A25140;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1009ED930(uint64_t a1)
{
  char v2 = *(void **)(a1 + 584);
  if (v2)
  {
    *(void *)(a1 + 592) = v2;
    operator delete(v2);
  }
  sub_10005CD2C(a1 + 560, *(char **)(a1 + 568));
  sub_10005CD2C(a1 + 536, *(char **)(a1 + 544));
  uint64_t v7 = (void **)(a1 + 512);
  sub_10005CBF0(&v7);
  if (*(char *)(a1 + 479) < 0) {
    operator delete(*(void **)(a1 + 456));
  }
  if (*(char *)(a1 + 447) < 0) {
    operator delete(*(void **)(a1 + 424));
  }
  if (*(char *)(a1 + 415) < 0) {
    operator delete(*(void **)(a1 + 392));
  }
  os_log_t v3 = *(void **)(a1 + 368);
  if (v3)
  {
    *(void *)(a1 + 376) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 367) < 0) {
    operator delete(*(void **)(a1 + 344));
  }
  uint64_t v4 = *(void *)(a1 + 328);
  *(void *)(a1 + 328) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v7 = (void **)(a1 + 296);
  sub_10005CBF0(&v7);
  sub_1000346F8(a1 + 256, *(void **)(a1 + 264));
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (void **)(a1 + 24);
  sub_10005CBF0(&v7);
}

void sub_1009EDACC(ServiceManager::Service *this)
{
  *(void *)this = off_101A25190;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1009EDB28(ServiceManager::Service *this)
{
  *(void *)this = off_101A25190;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1009EDB98@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SmsController");
}

unsigned char *sub_1009EDBA8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  char v2 = operator new(1uLL);
  *a1 = v2;
  *char v2 = 3;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1009EDBE8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  os_log_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1009CA034(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1009CA034(v4, 0);
}

uint64_t sub_1009EDC6C()
{
  return 0;
}

uint64_t sub_1009EDC74()
{
  return 1;
}

uint64_t sub_1009EDC7C()
{
  return 0;
}

void sub_1009EDC88(uint64_t a1)
{
  int v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_1009EDD64(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

uint64_t *sub_1009EDE78(void **a1)
{
  int v1 = *a1;
  int v10 = a1;
  char v11 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 144));
  uint64_t v4 = *(void *)(v2 + 112);
  if (v4)
  {
    uint64_t v5 = v1[1];
    *(void *)long long buf = v5;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v4 + 8))(v4, buf);
    if (*(void *)buf)
    {
      dispatch_group_leave(*(dispatch_group_t *)buf);
      if (*(void *)buf) {
        dispatch_release(*(dispatch_object_t *)buf);
      }
    }
  }
  uint64_t v6 = *(void *)(v2 + 128);
  if (v6)
  {
    uint64_t v7 = v1[1];
    dispatch_group_t group = v7;
    if (v7)
    {
      dispatch_retain(v7);
      dispatch_group_enter(v7);
    }
    (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v6 + 8))(v6, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  for (uint64_t i = *(void *)(v2 + 64); i != v2 + 56; uint64_t i = *(void *)(i + 8))
    sub_10016111C((uint64_t *)(i + 16));
  sub_100160A84((atomic_uint **)(v2 + 56));
  sub_100088C88((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_1009EDFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group, dispatch_group_t a13)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_1009EE058(uint64_t **a1)
{
  int v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(v2 + 80));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
LABEL_11:
  *(void *)(v2 + 2568) = v13;
  unsigned int v14 = *(std::__shared_weak_count **)(v2 + 2576);
  *(void *)(v2 + 2576) = v12;
  if (v14) {
    sub_10004D2C8(v14);
  }
  char v15 = *(void (****)(void, uint8_t *))(v2 + 112);
  if (v15)
  {
    unsigned int v16 = v1[1];
    *(void *)long long buf = v16;
    if (v16)
    {
      dispatch_retain(v16);
      dispatch_group_enter(v16);
    }
    (**v15)(v15, buf);
    if (*(void *)buf)
    {
      dispatch_group_leave(*(dispatch_group_t *)buf);
      if (*(void *)buf) {
        dispatch_release(*(dispatch_object_t *)buf);
      }
    }
  }
  uint64_t v17 = *(void (****)(void, dispatch_group_t *))(v2 + 128);
  if (v17)
  {
    uint64_t v18 = v1[1];
    dispatch_group_t group = v18;
    if (v18)
    {
      dispatch_retain(v18);
      dispatch_group_enter(v18);
    }
    (**v17)(v17, &group);
    if (group)
    {
      dispatch_group_leave(group);
      if (group) {
        dispatch_release(group);
      }
    }
  }
  sub_1009DF4B0(v2);
}

void sub_1009EE268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group, dispatch_group_t a13)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_1009EE2C4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v18, *(Registry **)(v1 + 80));
  ctu::RestModule::connect();
  if (v19) {
    sub_10004D2C8(v19);
  }
  subscriber::makeSimSlotRange();
  uint64_t v4 = *(unsigned int **)buf;
  uint64_t v3 = v16;
  if (*(unsigned int **)buf != v16)
  {
    uint64_t v5 = v17;
    do
    {
      if (v5(*v4)) {
        goto LABEL_10;
      }
      ++v4;
    }
    while (v4 != v3);
    uint64_t v4 = v3;
LABEL_10:
    uint64_t v6 = v16;
LABEL_11:
    while (v4 != v6)
    {
      sub_1009CB71C(v1, *v4);
      uint64_t v7 = v4 + 1;
      uint64_t v4 = v3;
      if (v7 != v3)
      {
        uint64_t v4 = v7;
        do
        {
          if (v5(*v4)) {
            goto LABEL_11;
          }
          ++v4;
        }
        while (v4 != v3);
        uint64_t v4 = v3;
      }
    }
  }
  subscriber::makeSimSlotRange();
  uint64_t v9 = *(int **)buf;
  uint64_t v8 = (int *)v16;
  if (*(unsigned int **)buf != v16)
  {
    unsigned int v10 = v17;
    do
    {
      if (v10(*v9)) {
        goto LABEL_22;
      }
      ++v9;
    }
    while (v9 != v8);
    uint64_t v9 = v8;
LABEL_22:
    char v11 = (int *)v16;
LABEL_23:
    while (v9 != v11)
    {
      sub_1009DDA70(v1, *v9);
      uint64_t v12 = v9 + 1;
      uint64_t v9 = v8;
      if (v12 != v8)
      {
        uint64_t v9 = v12;
        do
        {
          if (v10(*v9)) {
            goto LABEL_23;
          }
          ++v9;
        }
        while (v9 != v8);
        uint64_t v9 = v8;
      }
    }
  }
  uint64_t v13 = *(void *)(v1 + 112);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
  }
  uint64_t v14 = *(void *)(v1 + 128);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
  }
  operator delete();
}

void sub_1009EE4F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  operator delete();
}

void sub_1009EE550(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(uint64_t **)(a1 + 40);
  uint64_t v5 = *v3;
  uint64_t v4 = (_DWORD *)v3[1];
  uint64_t v6 = *v4;
  uint64_t v7 = (uint64_t **)(*v3 + 2544);
  uint64_t v9 = v4;
  uint64_t v8 = sub_1001B0B78(v7, v4, (uint64_t)&unk_10144E20E, &v9);
  sub_1009CAE18(a2, v5, v6, *((_DWORD *)v8[5] + 55));
}

void sub_1009EE5C0(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_1009EE628(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v5;
  long long v5 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  *(_OWORD *)uint64_t v2 = v3;
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
}

void sub_1009EE690(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009EE6F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009EE734(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009EE76C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009EE79C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1009EE7E0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009EE848(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009EE884(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009EE8BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009EE8EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009EE930(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1009EE940(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1009EE95C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1009EE96C(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 160);
}

uint64_t sub_1009EE97C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v4 = *(void *)(v1 + 16);
    uint64_t v5 = **(unsigned int **)(v1 + 8);
    uint64_t v6 = **(unsigned int **)(v1 + 24);
    return sub_1009CD4A8(v2, v5, v4, v6);
  }
  return result;
}

uint64_t sub_1009EE9E0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_1009EEA78(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  sub_1009EE9E0((uint64_t)v7, v1 + 16);
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v2 + 480))(v2, v3, v7);
  sub_100218320(v7);
  sub_1009EEB60(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1009EEB34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_100218320((uint64_t *)va2);
  sub_1009EEB60((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009EEB60(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100218320((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

BOOL sub_1009EEBB0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  int v3 = **(_DWORD **)(v1 + 8);
  uint64_t v4 = *(long long **)(v1 + 16);
  if (*((char *)v4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)v4, *((void *)v4 + 1));
  }
  else
  {
    long long v5 = *v4;
    uint64_t v9 = *((void *)v4 + 2);
    *(_OWORD *)std::string __p = v5;
  }
  BOOL isEmergencyTextNumberForSlot_sync = sms::Controller::isEmergencyTextNumberForSlot_sync(v2, v3, (uint64_t)__p);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  return isEmergencyTextNumberForSlot_sync;
}

void sub_1009EEC34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009EEC50(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *sub_1009EECE8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  sub_1009EEC50((uint64_t)v16, v1 + 16);
  int v15 = v3;
  if (v17)
  {
    if (subscriber::isValidSimSlot())
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        __p[0] = &v15;
        long long v5 = sub_1001B0B78((uint64_t **)(v2 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
        CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(v5[5] + 10));
        uint64_t v6 = v14 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136315138;
        uint64_t v19 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Smsc Address %s ", buf, 0xCu);
        if (v14 < 0) {
          operator delete(__p[0]);
        }
      }
      __p[0] = &v15;
      uint64_t v7 = sub_1001B0B78((uint64_t **)(v2 + 2544), &v15, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
      CSIPhoneNumber::getFullNumber((uint64_t *)__p, (CSIPhoneNumber *)(v7[5] + 10));
      sub_1009CCFAC(v17, (uint64_t)__p, 0);
    }
    else
    {
      uint64_t v9 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid slot while reading Smsc Address...", (uint8_t *)__p, 2u);
      }
      sub_100058DB0(__p, "");
      sub_1009CCFAC(v17, (uint64_t)__p, 0x1600000001);
    }
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid callback while reading Smsc Address...", (uint8_t *)__p, 2u);
    }
  }
  sub_100217EB0(v16);
  sub_1009EEFA4(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_1009EEF58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18)
{
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100217EB0(&a18);
  sub_1009EEFA4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009EEFA4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100217EB0((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_1009EEFF4(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
}

double sub_1009EF004(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

double sub_1009EF070(uint64_t a1)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v3;
    operator delete(v3);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
  }
  double result = *(double *)&v5;
  *(_OWORD *)uint64_t v2 = v5;
  *(void *)(v2 + 16) = v6;
  return result;
}

void sub_1009EF0DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  if (subscriber::isValidSimSlot())
  {
    uint64_t v3 = *(void *)(v1 + 16);
    uint64_t v4 = **(unsigned int **)(v1 + 8);
    uint64_t v5 = **(void **)(v1 + 24);
    uint64_t v6 = **(void **)(v1 + 32);
    sub_1009CD630(v2, v4, v3, v5, v6);
  }
}

uint64_t *sub_1009EF144(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v6 = 0;
  sub_1009ED118(&v6, *(void **)(v1 + 8), *(void **)(v1 + 16), (uint64_t)(*(void *)(v1 + 16) - *(void *)(v1 + 8)) >> 4);
  sub_1009CDB04(v2, v6, v7);
  uint64_t v9 = (void **)&v6;
  sub_10005CBF0(&v9);
  sub_1009EF1F0(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1009EF1BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  *(void *)(v11 - 24) = &a11;
  sub_10005CBF0((void ***)(v11 - 24));
  sub_1009EF1F0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009EF1F0(uint64_t *result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 8);
    sub_10005CBF0(&v2);
    operator delete();
  }
  return result;
}

uint64_t *sub_1009EF250(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v50 = a1;
  uint64_t v51 = v1;
  uint64_t v2 = *v1;
  int v52 = *(_DWORD *)(v1[1] + 24);
  if (subscriber::isValidSimSlot())
  {
    uint64_t v3 = v1[1];
    if (*(_DWORD *)(v3 + 236) == 9)
    {
      *(void *)long long buf = &v52;
      *(_DWORD *)(v3 + 236) = *((_DWORD *)sub_1001B0B78((uint64_t **)(v2 + 2544), &v52, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]+ 11);
      uint64_t v3 = v1[1];
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[2];
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = *(unsigned int *)(v3 + 24);
    int v61 = *(_DWORD *)(v3 + 24);
    int v6 = *(_DWORD *)(v3 + 224);
    uint64_t v7 = (std::__shared_weak_count *)operator new(0x38uLL);
    v7->__shared_weak_owners_ = 0;
    v7->__shared_owners_ = 0;
    v7->__vftable = (std::__shared_weak_count_vtbl *)off_101A254B8;
    LOBYTE(v7[2].__vftable) = 1;
    v7[1].__vftable = (std::__shared_weak_count_vtbl *)off_101AAF7D0;
    v7[1].__shared_owners_ = (uint64_t)&v7[1];
    HIDWORD(v7[2].__vftable) = v6;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v49 = (char *)&v7[1];
    v7[1].__shared_weak_owners_ = (uint64_t)v7;
    sub_10004D2C8(v7);
    if (*(_DWORD *)(v3 + 24))
    {
      uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v5);
      memset(&__str, 0, sizeof(__str));
      if (*(char *)(v3 + 159) < 0)
      {
        sub_10004FC84(&__str, *(void **)(v3 + 136), *(void *)(v3 + 144));
      }
      else
      {
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = *(_OWORD *)(v3 + 136);
        uint64_t v9 = *(uint64_t **)(v3 + 152);
        __str.__r_.__value_.__r.__words[2] = (std::string::size_type)v9;
      }
      v57 = 0;
      CFStringRef v58 = 0;
      unint64_t v59 = 0;
      uint64_t v46 = v2 + 80;
      if (sub_100794960((Registry **)(v2 + 80), *(unsigned int *)(v3 + 24), v9)
        && (uint64_t v13 = *(unsigned int *)(v3 + 24),
            *(void *)long long buf = &v61,
            char v14 = sub_1001B0B78((uint64_t **)(v2 + 2544), &v61, (uint64_t)&unk_10144E20E, (_DWORD **)buf),
            sub_100797864((Registry **)(v2 + 80), v13, *((_DWORD *)v14[5] + 66), v14[5])))
      {
        int v15 = v58;
        if ((unint64_t)v58 >= v59)
        {
          unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v58 - v57) >> 3);
          unint64_t v39 = v38 + 1;
          if (v38 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_1000D8578();
          }
          if (0x5555555555555556 * ((uint64_t)(v59 - (void)v57) >> 3) > v39) {
            unint64_t v39 = 0x5555555555555556 * ((uint64_t)(v59 - (void)v57) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - (void)v57) >> 3) >= 0x555555555555555) {
            unint64_t v40 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v40 = v39;
          }
          uint64_t v64 = &v59;
          if (v40) {
            v41 = (char *)sub_10004812C((uint64_t)&v59, v40);
          }
          else {
            v41 = 0;
          }
          uint64_t v42 = &v41[24 * v38];
          *(void *)long long buf = v41;
          *(void *)v63 = v42;
          *(void *)&v63[16] = &v41[24 * v40];
          long long v43 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
          *((void *)v42 + 2) = *((void *)&__str.__r_.__value_.__l + 2);
          *(_OWORD *)uint64_t v42 = v43;
          memset(&__str, 0, sizeof(__str));
          *(void *)&v63[8] = v42 + 24;
          sub_100048204((uint64_t *)&v57, buf);
          uint64_t v17 = v58;
          sub_100048174((uint64_t)buf);
        }
        else
        {
          long long v16 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
          *((void *)v58 + 2) = *((void *)&__str.__r_.__value_.__l + 2);
          *int v15 = v16;
          memset(&__str, 0, sizeof(__str));
          uint64_t v17 = (char *)v15 + 24;
        }
        CFStringRef v58 = v17;
      }
      else
      {
        uint64_t v56 = 0;
        sub_1009CD630(v2, *(unsigned int *)(v3 + 24), (uint64_t)&__str, (uint64_t)&v56 + 4, (uint64_t)&v56);
        int v18 = v56;
        int v19 = HIDWORD(v56);
        char v20 = *v8;
        BOOL v21 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
        if (v19 && v18)
        {
          if (v21)
          {
            *(_DWORD *)long long buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v19;
            *(_WORD *)v63 = 1024;
            *(_DWORD *)&v63[2] = v18;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I EMS is unsupported, bodysize is %d with a threshold of %d", buf, 0xEu);
            int v18 = v56;
          }
          int v22 = vcvtpd_s64_f64(140.0 / (double)v18);
          long long v54 = 0uLL;
          uint64_t v55 = 0;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_str = &__str;
          }
          else {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          sub_100796324(v8, (const char *)p_str, v18 * v22, v22, 0, 32, 2, (char **)&v54);
          BOOL v24 = (std::string::size_type *)*((void *)&v54 + 1);
          uint64_t v25 = (std::string::size_type *)v54;
          if ((void)v54 != *((void *)&v54 + 1))
          {
            int v47 = v8;
            uint64_t v48 = v4;
            int v26 = 0;
            do
            {
              std::string::size_type v27 = *v25;
              int v28 = v26;
              std::string::basic_string(&v53, &__str, v26, *v25, (std::allocator<char> *)buf);
              int v29 = v58;
              if ((unint64_t)v58 >= v59)
              {
                unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((v58 - v57) >> 3);
                unint64_t v32 = v31 + 1;
                if (v31 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  sub_1000D8578();
                }
                if (0x5555555555555556 * ((uint64_t)(v59 - (void)v57) >> 3) > v32) {
                  unint64_t v32 = 0x5555555555555556 * ((uint64_t)(v59 - (void)v57) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v59 - (void)v57) >> 3) >= 0x555555555555555) {
                  unint64_t v33 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v33 = v32;
                }
                uint64_t v64 = &v59;
                if (v33) {
                  __int16 v34 = (char *)sub_10004812C((uint64_t)&v59, v33);
                }
                else {
                  __int16 v34 = 0;
                }
                uint64_t v35 = &v34[24 * v31];
                *(void *)long long buf = v34;
                *(void *)v63 = v35;
                *(void *)&v63[16] = &v34[24 * v33];
                long long v36 = *(_OWORD *)&v53.__r_.__value_.__l.__data_;
                *((void *)v35 + 2) = *((void *)&v53.__r_.__value_.__l + 2);
                *(_OWORD *)uint64_t v35 = v36;
                memset(&v53, 0, sizeof(v53));
                *(void *)&v63[8] = v35 + 24;
                sub_100048204((uint64_t *)&v57, buf);
                char v37 = v58;
                sub_100048174((uint64_t)buf);
                CFStringRef v58 = v37;
                if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v53.__r_.__value_.__l.__data_);
                }
              }
              else
              {
                long long v30 = *(_OWORD *)&v53.__r_.__value_.__l.__data_;
                *((void *)v58 + 2) = *((void *)&v53.__r_.__value_.__l + 2);
                *int v29 = v30;
                CFStringRef v58 = (char *)v29 + 24;
              }
              int v26 = v27 + v28;
              ++v25;
            }
            while (v25 != v24);
            uint64_t v25 = (std::string::size_type *)v54;
            uint64_t v8 = v47;
            uint64_t v4 = v48;
          }
          if (v25)
          {
            *((void *)&v54 + 1) = v25;
            operator delete(v25);
          }
        }
        else if (v21)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I EMS is unsupported, but unable to determine bodysize / threshold, passing through as normal", buf, 2u);
        }
        uint64_t v17 = v58;
      }
      long long v54 = 0uLL;
      uint64_t v55 = 0;
      if (v57 != v17)
      {
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = 0uLL;
        operator new();
      }
      unsigned __int8 v44 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I Outgoing message queue is empty", buf, 2u);
      }
      *(_DWORD *)&uint8_t buf[4] = *(_DWORD *)(v3 + 12);
      *(_DWORD *)v63 = v61;
      *(_DWORD *)long long buf = 1;
      *(_OWORD *)&v63[4] = 0uLL;
      (*(void (**)(char *, uint64_t, uint8_t *))(*(void *)v49 + 16))(v49, v46, buf);
      v53.__r_.__value_.__r.__words[0] = (std::string::size_type)&v54;
      sub_10005CBF0((void ***)&v53);
      *(void *)&long long v54 = &v57;
      sub_100047F64((void ***)&v54);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      unsigned int v10 = *(NSObject **)(v2 + 40);
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      int v12 = 0;
      if (v11)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I SMS not enqueued, slot invalid", buf, 2u);
        int v12 = *(_DWORD *)(v3 + 24);
      }
      *(_DWORD *)&uint8_t buf[4] = *(_DWORD *)(v3 + 12);
      *(_DWORD *)v63 = v12;
      *(_DWORD *)long long buf = 1;
      *(void *)&v63[12] = 0;
      *(void *)&v63[4] = 0;
      (*(void (**)(char *, uint64_t, uint8_t *))(*(void *)v49 + 16))(v49, v2 + 80, buf);
    }
    sub_10004D2C8(v7);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  sub_1000E1A60((uint64_t *)&v51);
  return sub_100046B58((uint64_t *)&v50);
}

void sub_1009EFCA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  sub_100048174(v41 - 160);
  a26 = &a31;
  sub_100047F64((void ***)&a26);
  if (a39 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v39);
  if (v40) {
    sub_10004D2C8(v40);
  }
  sub_1000E1A60(&a17);
  sub_100046B58(&a16);
  _Unwind_Resume(a1);
}

void sub_1009EFDE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A254B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009EFE08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A254B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009EFE5C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1009EFE84(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1009EFEEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1009EFF8C(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009EFF08(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t *sub_1009EFF40(uint64_t a1)
{
  return sub_1009EFF8C(*(uint64_t **)(a1 + 24));
}

uint64_t sub_1009EFF48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_1009EFF8C(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (std::__shared_weak_count *)result[18];
    if (v2) {
      sub_10004D2C8(v2);
    }
    if (*((char *)v1 + 87) < 0) {
      operator delete((void *)v1[8]);
    }
    if (*((char *)v1 + 63) < 0) {
      operator delete((void *)v1[5]);
    }
    if (*((char *)v1 + 39) < 0) {
      operator delete((void *)v1[2]);
    }
    uint64_t v3 = *v1;
    uint64_t *v1 = 0;
    if (v3) {
      operator delete();
    }
    operator delete();
  }
  return result;
}

uint64_t **sub_1009F0034(uint64_t **a1, unsigned __int8 a2, unsigned char *a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((unsigned __int8 *)v5 + 32);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x40uLL);
    v9[32] = *a3;
    *((void *)v9 + 6) = 0;
    *((void *)v9 + 7) = 0;
    *((void *)v9 + 5) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t sub_1009F00E8(uint64_t a1)
{
  return *((unsigned __int8 *)sub_1001B0B78((uint64_t **)(**(void **)(a1 + 40) + 2544), *(int **)(*(void *)(a1 + 40) + 8), (uint64_t)&unk_10144E20E, &v2)[5]+ 42);
}

void sub_1009F0134(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009F016C(uint64_t a1)
{
  return sub_1009F01B8(*(void *)(a1 + 24));
}

uint64_t sub_1009F0174(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1009F01B8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 160);
    if (v2)
    {
      uint64_t v3 = *(void *)(result + 168);
      uint64_t v4 = *(void **)(result + 160);
      if (v3 != v2)
      {
        do
        {
          if (*(char *)(v3 - 9) < 0) {
            operator delete(*(void **)(v3 - 32));
          }
          v3 -= 32;
        }
        while (v3 != v2);
        uint64_t v4 = *(void **)(v1 + 160);
      }
      *(void *)(v1 + 168) = v2;
      operator delete(v4);
    }
    if (*(char *)(v1 + 135) < 0) {
      operator delete(*(void **)(v1 + 112));
    }
    if (*(char *)(v1 + 111) < 0) {
      operator delete(*(void **)(v1 + 88));
    }
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    operator delete();
  }
  return result;
}

void sub_1009F0290(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009F02C8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 24);
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_1009F031C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_1009F0360(uint64_t *result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 24);
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

BOOL sub_1009F03B8(uint64_t a1)
{
  return sub_1009D58D4(**(void **)(a1 + 40), **(_DWORD **)(*(void *)(a1 + 40) + 8));
}

void sub_1009F03C8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  uint64_t v4 = *(atomic_ullong **)(v3 + 8);
  v5[0] = *(sms::Model **)v3;
  v5[1] = (sms::Model *)v4;
  if (v4) {
    atomic_fetch_add_explicit(v4 + 1, 1uLL, memory_order_relaxed);
  }
  sub_1009D57E0(v2, v5);
  if (v4)
  {
    sub_10004D2C8((std::__shared_weak_count *)v4);
  }
}

void sub_1009F043C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009F0454(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_1009F04EC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

boost::archive::detail::basic_iarchive *sub_1009F0570(boost::archive::detail::basic_iarchive *a1)
{
  boost::archive::detail::basic_iarchive::~basic_iarchive(a1);
  boost::archive::basic_text_iprimitive<std::istream>::~basic_text_iprimitive(v2 + 40);
  return a1;
}

void sub_1009F05A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A256D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009F05C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A256D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009F0614(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

boost::archive::detail::basic_iarchive *sub_1009F063C(boost::archive::detail::basic_iarchive *a1, uint64_t *a2)
{
  uint64_t v3 = boost::archive::text_iarchive_impl<boost::archive::text_iarchive>::text_iarchive_impl(a1, a2, 0);
  *(void *)uint64_t v3 = off_101A25720;
  boost::archive::text_iarchive_impl<boost::archive::text_iarchive>::init((uint64_t)v3);
  return a1;
}

void sub_1009F0688(_Unwind_Exception *a1)
{
  boost::archive::detail::basic_iarchive::~basic_iarchive(v1);
  boost::archive::basic_text_iprimitive<std::istream>::~basic_text_iprimitive((uint64_t)v1 + 40);
  _Unwind_Resume(a1);
}

void sub_1009F06A4(boost::archive::detail::basic_iarchive *a1)
{
  boost::archive::detail::basic_iarchive::~basic_iarchive(a1);
  boost::archive::basic_text_iprimitive<std::istream>::~basic_text_iprimitive(v1 + 40);

  operator delete();
}

void sub_1009F06F4(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25788;
  byte_101B0F838 = 1;
  sub_1009F0804(a1);
}

uint64_t *sub_1009F0720()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FAD0, 0);
  *(void *)char v0 = off_101A25830;
  double result = boost::serialization::extended_type_info::key_register(qword_101B0FAD0);
  qword_101B0FAD0[0] = (uint64_t)off_101A25788;
  if (byte_101B0F838 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F07D8(_Unwind_Exception *a1)
{
}

void sub_1009F0804(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25830;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F0864(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25788;
  byte_101B0F838 = 1;
  sub_1009F0804(a1);

  operator delete();
}

void sub_1009F08C4(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F095C(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F0990(boost::serialization::extended_type_info *a1)
{
  sub_1009F0804(a1);

  operator delete();
}

void sub_1009F09C8(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = (boost::archive::detail::basic_iarchive *)sub_1009F1284(a2);
  uint64_t v6 = *(void *)(a3 + 8);
  uint64_t v5 = *(std::__shared_weak_count **)(a3 + 16);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v37 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 32) = 0;
  int v38 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 36) = 0;
  sub_1009F0FF0();
  sub_1009F0FF0();
  sub_1009F0FF0();
  sub_1009F0FF0();
  sub_1009F0FF0();
  sub_1009F1024(v4, v6 + 48);
  sub_1009F1024(v4, v6 + 72);
  int v39 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 96) = 0;
  sub_1009F0FF0();
  sub_1009F10F0();
  sub_1009F1128((uint64_t)v4, (_DWORD *)(v6 + 108));
  sub_1009F0FF0();
  sub_1009F1128((uint64_t)v4, (_DWORD *)(v6 + 116));
  sub_1009F0FF0();
  sub_1009F10F0();
  sub_1009F10F0();
  sub_1009F10F0();
  sub_1009F0FF0();
  __int16 v40 = 0;
  sub_10006B3C8();
  *(unsigned char *)(v6 + 137) = 0;
  sub_1009EBB10();
  boost::archive::detail::basic_iarchive::load_object(v4, v6 + 138, (const boost::archive::detail::basic_iserializer *)qword_101B0F968);
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  long long v36 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v34);
  sub_1009F1178(v4, (uint64_t)&v34);
  uint64_t v8 = v35;
  uint64_t v7 = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 144) = *(void *)v8;
  std::string::operator=((std::string *)(v6 + 152), (const std::string *)(v8 + 8));
  std::string::operator=((std::string *)(v6 + 176), (const std::string *)(v8 + 32));
  int v9 = *(_DWORD *)(v8 + 56);
  *(unsigned char *)(v6 + 204) = *(unsigned char *)(v8 + 60);
  *(_DWORD *)(v6 + 200) = v9;
  std::string::operator=((std::string *)(v6 + 208), (const std::string *)(v8 + 64));
  std::string::operator=((std::string *)(v6 + 232), (const std::string *)(v8 + 88));
  long long v10 = *(_OWORD *)(v8 + 112);
  *(unsigned char *)(v6 + 272) = *(unsigned char *)(v8 + 128);
  *(_OWORD *)(v6 + 256) = v10;
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  unint64_t v33 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v31);
  sub_1009F1178(v4, (uint64_t)&v31);
  uint64_t v12 = v32;
  BOOL v11 = v33;
  if (v33) {
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 280) = *(void *)v12;
  std::string::operator=((std::string *)(v6 + 288), (const std::string *)(v12 + 8));
  std::string::operator=((std::string *)(v6 + 312), (const std::string *)(v12 + 32));
  int v13 = *(_DWORD *)(v12 + 56);
  *(unsigned char *)(v6 + 340) = *(unsigned char *)(v12 + 60);
  *(_DWORD *)(v6 + 336) = v13;
  std::string::operator=((std::string *)(v6 + 344), (const std::string *)(v12 + 64));
  std::string::operator=((std::string *)(v6 + 368), (const std::string *)(v12 + 88));
  long long v14 = *(_OWORD *)(v12 + 112);
  *(unsigned char *)(v6 + 408) = *(unsigned char *)(v12 + 128);
  *(_OWORD *)(v6 + 392) = v14;
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_1009F0FF0();
  uint64_t v28 = 0;
  int v29 = 0;
  long long v30 = 0;
  CSIDateSerialized::CSIDateSerialized((CSIDateSerialized *)&v28);
  sub_1009EBFD8();
  boost::archive::detail::basic_iarchive::load_object(v4, (uint64_t)&v28, (const boost::archive::detail::basic_iserializer *)qword_101B0F9B0);
  long long v16 = v29;
  int v15 = v30;
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v17 = *v16;
    long long v18 = v16[2];
    *(_OWORD *)(v6 + 440) = v16[1];
    *(_OWORD *)(v6 + 456) = v18;
    *(_OWORD *)(v6 + 424) = v17;
    sub_10004D2C8(v15);
  }
  else
  {
    long long v19 = *v29;
    long long v20 = v29[2];
    *(_OWORD *)(v6 + 440) = v29[1];
    *(_OWORD *)(v6 + 456) = v20;
    *(_OWORD *)(v6 + 424) = v19;
  }
  sub_1009F0FF0();
  sub_1009F10F0();
  sub_1009F0FF0();
  sub_1009F10F0();
  sub_1009F0FF0();
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  std::string::size_type v27 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v25);
  sub_1009F1178(v4, (uint64_t)&v25);
  uint64_t v22 = v26;
  BOOL v21 = v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 496) = *(void *)v22;
  std::string::operator=((std::string *)(v6 + 504), (const std::string *)(v22 + 8));
  std::string::operator=((std::string *)(v6 + 528), (const std::string *)(v22 + 32));
  int v23 = *(_DWORD *)(v22 + 56);
  *(unsigned char *)(v6 + 556) = *(unsigned char *)(v22 + 60);
  *(_DWORD *)(v6 + 552) = v23;
  std::string::operator=((std::string *)(v6 + 560), (const std::string *)(v22 + 64));
  std::string::operator=((std::string *)(v6 + 584), (const std::string *)(v22 + 88));
  long long v24 = *(_OWORD *)(v22 + 112);
  *(unsigned char *)(v6 + 624) = *(unsigned char *)(v22 + 128);
  *(_OWORD *)(v6 + 608) = v24;
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_1009F10F0();
  sub_1009F10F0();
  sub_1009F0FF0();
  sub_1009F10F0();
  sub_1009F10F0();
  sub_1009F10F0();
  sub_1009F0FF0();
  sub_1009F0FF0();
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v25);
  CSIDateSerialized::~CSIDateSerialized((CSIDateSerialized *)&v28);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v31);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v34);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1009F0E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  CSIDateSerialized::~CSIDateSerialized((CSIDateSerialized *)va);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)va1);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)va2);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void *sub_1009F0FF0()
{
  return sub_1009F11D4();
}

void sub_1009F1008(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void sub_1009F1024(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_1009EB978();
  boost::archive::detail::basic_iarchive::load_object(a1, (uint64_t)&v7, (const boost::archive::detail::basic_iserializer *)qword_101B0F950);
  sub_10012CD04(&v5, v7, v8, v8 - v7);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v5;
  uint64_t v4 = v7;
  *(void *)(a2 + 16) = v6;
  if (v4)
  {
    uint64_t v8 = v4;
    operator delete(v4);
  }
}

void sub_1009F10AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a2 == 2 || a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1009F109CLL);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009F10F0()
{
  return sub_10006B47C();
}

void sub_1009F110C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void *sub_1009F1128(uint64_t a1, _DWORD *a2)
{
  uint64_t result = sub_10006B47C();
  *a2 = 0;
  return result;
}

void sub_1009F1168(void *a1)
{
}

uint64_t sub_1009F1178(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  return boost::archive::detail::basic_iarchive::load_object(a1, a2, (const boost::archive::detail::basic_iserializer *)qword_101B0F998);
}

void sub_1009F11B4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void *sub_1009F11D4()
{
  uint64_t result = (void *)std::istream::operator>>();
  if ((*((unsigned char *)result + *(void *)(*result - 24) + 32) & 5) != 0)
  {
    boost::archive::archive_exception::archive_exception((uint64_t)v1, 8, 0, 0);
    sub_10006A800((uint64_t)v1);
  }
  return result;
}

void sub_1009F1270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

void *sub_1009F1284(const void *a1)
{
  if (!result) {
    __cxa_bad_cast();
  }
  return result;
}

void sub_1009F12E0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25878;
  byte_101B0F839 = 1;
  sub_1009F13F0(a1);
}

uint64_t *sub_1009F130C()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FAF0, 0);
  *(void *)char v0 = off_101A25920;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FAF0);
  qword_101B0FAF0[0] = (uint64_t)off_101A25878;
  if (byte_101B0F839 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F13C4(_Unwind_Exception *a1)
{
}

void sub_1009F13F0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25920;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F1450(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25878;
  byte_101B0F839 = 1;
  sub_1009F13F0(a1);

  operator delete();
}

void sub_1009F14B0(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void **sub_1009F1548(uint64_t a1, void **a2)
{
  return sub_1009F158C(a2);
}

void sub_1009F1554(boost::serialization::extended_type_info *a1)
{
  sub_1009F13F0(a1);

  operator delete();
}

void **sub_1009F158C(void **result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (v2)
    {
      v1[1] = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

void sub_1009F15E8(uint64_t a1, const void *a2, unint64_t *a3)
{
  uint64_t v4 = sub_1009F1284(a2);
  unsigned __int16 v5 = 0;
  boost::archive::detail::basic_iarchive::get_library_version((uint64_t)v4, &v5);
  sub_1009F16BC();
  if (v5 >= 4u)
  {
    int v6 = 0;
    sub_10006D048();
  }
  sub_100240658(a3, 0);
  if (a3[1] != *a3) {
    a3[1] = *a3;
  }
}

void *sub_1009F16BC()
{
  uint64_t result = (void *)std::istream::operator>>();
  if ((*((unsigned char *)result + *(void *)(*result - 24) + 32) & 5) != 0)
  {
    boost::archive::archive_exception::archive_exception((uint64_t)v1, 8, 0, 0);
    sub_10006A800((uint64_t)v1);
  }
  return result;
}

void sub_1009F1758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

void sub_1009F176C(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25978;
  byte_101B0F83A = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F1798()
{
  sub_1009EB8AC();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F950, (uint64_t)qword_101B0FAF0);
  *uint64_t result = off_101A25978;
  if (byte_101B0F83A == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F1818(_Unwind_Exception *a1)
{
}

void sub_1009F1830(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25978;
  byte_101B0F83A = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F1890()
{
  return 0;
}

BOOL sub_1009F1898(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F18A8(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F18B0()
{
  return 0;
}

void **sub_1009F18B8(uint64_t a1, void **a2)
{
  return sub_1009F158C(a2);
}

void sub_1009F18C0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A259F8;
  byte_101B0F83B = 1;
  sub_1009F19D0(a1);
}

uint64_t *sub_1009F18EC()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FB10, 0);
  *(void *)char v0 = off_101A25AA0;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FB10);
  qword_101B0FB10[0] = (uint64_t)off_101A259F8;
  if (byte_101B0F83B == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F19A4(_Unwind_Exception *a1)
{
}

void sub_1009F19D0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25AA0;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F1A30(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A259F8;
  byte_101B0F83B = 1;
  sub_1009F19D0(a1);

  operator delete();
}

void sub_1009F1A90(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void sub_1009F1B28(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F1B4C(boost::serialization::extended_type_info *a1)
{
  sub_1009F19D0(a1);

  operator delete();
}

void *sub_1009F1B84(uint64_t a1, const void *a2)
{
  sub_1009F1284(a2);
  sub_10006B3C8();

  return sub_10006B3C8();
}

void sub_1009F1BD4(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25AF8;
  byte_101B0F83C = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F1C00()
{
  sub_1009EBA44();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F968, (uint64_t)qword_101B0FB10);
  *uint64_t result = off_101A25AF8;
  if (byte_101B0F83C == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F1C80(_Unwind_Exception *a1)
{
}

void sub_1009F1C98(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25AF8;
  byte_101B0F83C = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F1CF8()
{
  return 1;
}

BOOL sub_1009F1D00(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F1D10(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F1D18()
{
  return 0;
}

void sub_1009F1D20(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F1D40(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25B78;
  byte_101B0F83D = 1;
  sub_1009F1E50(a1);
}

uint64_t *sub_1009F1D6C()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FB30, 0);
  *(void *)char v0 = off_101A25C20;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FB30);
  qword_101B0FB30[0] = (uint64_t)off_101A25B78;
  if (byte_101B0F83D == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F1E24(_Unwind_Exception *a1)
{
}

void sub_1009F1E50(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25C20;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F1EB0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25B78;
  byte_101B0F83D = 1;
  sub_1009F1E50(a1);

  operator delete();
}

void sub_1009F1F10(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F1FA8(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F1FDC(boost::serialization::extended_type_info *a1)
{
  sub_1009F1E50(a1);

  operator delete();
}

void sub_1009F2014(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = (boost::archive::detail::basic_iarchive *)sub_1009F1284(a2);
  uint64_t v6 = *(void *)(a3 + 8);
  unsigned __int16 v5 = *(std::__shared_weak_count **)(a3 + 16);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v8 = 0;
  sub_10006B47C();
  *(_DWORD *)uint64_t v6 = 0;
  sub_10006B47C();
  sub_1009F2228(v4, v6 + 8);
  sub_1009F2228(v4, v6 + 32);
  uint64_t v7 = 0;
  sub_1009EBD74();
  boost::archive::detail::basic_iarchive::load_object(v4, (uint64_t)&v7, (const boost::archive::detail::basic_iserializer *)qword_101B0F980);
  if ((_BYTE)v7)
  {
    *(_DWORD *)(v6 + 56) = HIDWORD(v7);
    *(unsigned char *)(v6 + 60) = 1;
  }
  sub_1009F2228(v4, v6 + 64);
  sub_1009F2228(v4, v6 + 88);
  sub_1009F22F4();
  sub_1009F22F4();
  sub_1009F22F4();
  int v9 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 116) = v9;
  int v10 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 120) = v10;
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1009F2228(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  uint64_t v7 = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  sub_1009EB978();
  boost::archive::detail::basic_iarchive::load_object(a1, (uint64_t)&v7, (const boost::archive::detail::basic_iserializer *)qword_101B0F950);
  sub_10012CD04(&v5, v7, v8, v8 - v7);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v5;
  uint64_t v4 = v7;
  *(void *)(a2 + 16) = v6;
  if (v4)
  {
    int v8 = v4;
    operator delete(v4);
  }
}

void sub_1009F22B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a2 == 2 || a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1009F22A0);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009F22F4()
{
  return sub_1009F11D4();
}

void sub_1009F230C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void sub_1009F2328(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25C68;
  byte_101B0F83E = 1;
  sub_1009F2438(a1);
}

uint64_t *sub_1009F2354()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FB50, 0);
  *(void *)char v0 = off_101A25D10;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FB50);
  qword_101B0FB50[0] = (uint64_t)off_101A25C68;
  if (byte_101B0F83E == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F240C(_Unwind_Exception *a1)
{
}

void sub_1009F2438(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25D10;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F2498(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25C68;
  byte_101B0F83E = 1;
  sub_1009F2438(a1);

  operator delete();
}

void sub_1009F24F8(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void sub_1009F2590(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F25B4(boost::serialization::extended_type_info *a1)
{
  sub_1009F2438(a1);

  operator delete();
}

void *sub_1009F25EC(uint64_t a1, const void *a2, unsigned char *a3)
{
  sub_1009F1284(a2);
  uint64_t result = sub_1009F11D4();
  *a3 = 0;
  return result;
}

void sub_1009F26A0(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25D98;
  byte_101B0F83F = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F26CC()
{
  sub_1009EBCA8();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F980, (uint64_t)qword_101B0FB50);
  *uint64_t result = off_101A25D98;
  if (byte_101B0F83F == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F274C(_Unwind_Exception *a1)
{
}

void sub_1009F2764(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25D98;
  byte_101B0F83F = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F27C4()
{
  return 1;
}

BOOL sub_1009F27CC(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F27DC(_DWORD *a1@<X8>)
{
  *a1 = 1;
}

uint64_t sub_1009F27E8()
{
  return 0;
}

void sub_1009F27F0(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F2810(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25E18;
  byte_101B0F840 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F283C()
{
  sub_1009EBBDC();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F998, (uint64_t)qword_101B0FB30);
  qword_101B0F998[0] = (uint64_t)off_101A25E18;
  if (byte_101B0F840 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F28BC(_Unwind_Exception *a1)
{
}

void sub_1009F28D4(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25E18;
  byte_101B0F840 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F2934()
{
  return 1;
}

BOOL sub_1009F293C(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F294C(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F2954()
{
  return 1;
}

uint64_t sub_1009F295C(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F298C(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25E98;
  byte_101B0F841 = 1;
  sub_1009F2A9C(a1);
}

uint64_t *sub_1009F29B8()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FB70, 0);
  *(void *)char v0 = off_101A25F40;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FB70);
  qword_101B0FB70[0] = (uint64_t)off_101A25E98;
  if (byte_101B0F841 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F2A70(_Unwind_Exception *a1)
{
}

void sub_1009F2A9C(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25F40;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F2AFC(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A25E98;
  byte_101B0F841 = 1;
  sub_1009F2A9C(a1);

  operator delete();
}

void sub_1009F2B5C(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F2BF4(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F2C28(boost::serialization::extended_type_info *a1)
{
  sub_1009F2A9C(a1);

  operator delete();
}

void sub_1009F2C60(uint64_t a1, const void *a2, uint64_t a3)
{
  sub_1009F1284(a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a3 + 16);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1009F2D6C();
  sub_1009F2D6C();
  sub_1009F2D6C();
  sub_1009F2D6C();
  sub_1009F2D6C();
  sub_1009F2D6C();
  sub_1009F2D6C();
  sub_1009F11D4();
  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void *sub_1009F2D6C()
{
  return sub_10006B47C();
}

void sub_1009F2D88(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void sub_1009F2DA4(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25F88;
  byte_101B0F842 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F2DD0()
{
  sub_1009EBF0C();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F9B0, (uint64_t)qword_101B0FB70);
  *uint64_t result = off_101A25F88;
  if (byte_101B0F842 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F2E50(_Unwind_Exception *a1)
{
}

void sub_1009F2E68(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A25F88;
  byte_101B0F842 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F2EC8()
{
  return 1;
}

BOOL sub_1009F2ED0(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F2EE0(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F2EE8()
{
  return 1;
}

uint64_t sub_1009F2EF0(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F2F20(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26008;
  byte_101B0F843 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F2F4C()
{
  sub_1009EB7E0();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F9C8, (uint64_t)qword_101B0FAD0);
  *uint64_t result = off_101A26008;
  if (byte_101B0F843 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F2FCC(_Unwind_Exception *a1)
{
}

void sub_1009F2FE4(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26008;
  byte_101B0F843 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F3044()
{
  return 1;
}

BOOL sub_1009F304C(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F305C(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F3064()
{
  return 1;
}

uint64_t sub_1009F306C(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F309C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A26088;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009F30BC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A26088;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009F3110(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1009F3138(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A260D8;
  byte_101B0F844 = 1;
  sub_1009F3248(a1);
}

uint64_t *sub_1009F3164()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FB90, 0);
  *(void *)char v0 = off_101A26180;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FB90);
  qword_101B0FB90[0] = (uint64_t)off_101A260D8;
  if (byte_101B0F844 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F321C(_Unwind_Exception *a1)
{
}

void sub_1009F3248(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26180;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F32A8(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A260D8;
  byte_101B0F844 = 1;
  sub_1009F3248(a1);

  operator delete();
}

void sub_1009F3308(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F33A0(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F33D4(boost::serialization::extended_type_info *a1)
{
  sub_1009F3248(a1);

  operator delete();
}

void sub_1009F340C(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = (boost::archive::detail::basic_iarchive *)sub_1009F1284(a2);
  uint64_t v6 = *(void *)(a3 + 8);
  long long v5 = *(std::__shared_weak_count **)(a3 + 16);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1009F3EEC();
  sub_1009EC308();
  boost::archive::detail::basic_iarchive::load_object(v4, v6 + 48, (const boost::archive::detail::basic_iserializer *)qword_101B0F9E0);
  sub_1009EC638();
  boost::archive::detail::basic_iarchive::load_object(v4, v6 + 72, (const boost::archive::detail::basic_iserializer *)qword_101B0FA10);
  int v51 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 96) = 0;
  int v52 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 100) = 0;
  sub_1009F3EEC();
  sub_1009F3F20();
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v48);
  sub_1009F3F58(v4, (uint64_t)&v48);
  uint64_t v8 = v49;
  uint64_t v7 = v50;
  if (v50) {
    atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 112) = *(void *)v8;
  std::string::operator=((std::string *)(v6 + 120), (const std::string *)(v8 + 8));
  std::string::operator=((std::string *)(v6 + 144), (const std::string *)(v8 + 32));
  int v9 = *(_DWORD *)(v8 + 56);
  *(unsigned char *)(v6 + 172) = *(unsigned char *)(v8 + 60);
  *(_DWORD *)(v6 + 168) = v9;
  std::string::operator=((std::string *)(v6 + 176), (const std::string *)(v8 + 64));
  std::string::operator=((std::string *)(v6 + 200), (const std::string *)(v8 + 88));
  long long v10 = *(_OWORD *)(v8 + 112);
  *(unsigned char *)(v6 + 240) = *(unsigned char *)(v8 + 128);
  *(_OWORD *)(v6 + 224) = v10;
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_1009F3F20();
  sub_1009F3FB4((uint64_t)v4, (_DWORD *)(v6 + 252));
  int v53 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 256) = v53;
  int v54 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 260) = v54;
  sub_1009F3F20();
  sub_1009F3EEC();
  int v55 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 272) = v55;
  sub_1009F3F20();
  CFStringRef v58 = 0;
  unint64_t v59 = 0;
  v60 = 0;
  sub_1009EB978();
  boost::archive::detail::basic_iarchive::load_object(v4, (uint64_t)&v58, (const boost::archive::detail::basic_iserializer *)qword_101B0F950);
  sub_10012CD04(&v56, v58, v59, v59 - v58);
  BOOL v11 = (void **)(v6 + 280);
  if (*(char *)(v6 + 303) < 0) {
    operator delete(*v11);
  }
  *(_OWORD *)BOOL v11 = v56;
  *(void *)(v6 + 296) = v57;
  if (v58)
  {
    unint64_t v59 = v58;
    operator delete(v58);
  }
  sub_1009F3F20();
  CFStringRef v58 = 0;
  unint64_t v59 = 0;
  v60 = 0;
  CSIDateSerialized::CSIDateSerialized((CSIDateSerialized *)&v58);
  sub_1009F4004(v4, (uint64_t)&v58);
  uint64_t v13 = v59;
  uint64_t v12 = v60;
  if (v60)
  {
    atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v14 = (_OWORD *)(v6 + 312);
    long long v15 = *(_OWORD *)v13;
    long long v16 = *((_OWORD *)v13 + 2);
    *(_OWORD *)(v6 + 328) = *((_OWORD *)v13 + 1);
    *(_OWORD *)(v6 + 344) = v16;
    *(_OWORD *)(v6 + 312) = v15;
    sub_10004D2C8(v12);
  }
  else
  {
    long long v14 = (_OWORD *)(v6 + 312);
    long long v17 = *(_OWORD *)v59;
    long long v18 = *((_OWORD *)v59 + 2);
    *(_OWORD *)(v6 + 328) = *((_OWORD *)v59 + 1);
    *(_OWORD *)(v6 + 344) = v18;
    *(_OWORD *)(v6 + 312) = v17;
  }
  long long v56 = 0uLL;
  v57 = 0;
  CSIDateSerialized::CSIDateSerialized((CSIDateSerialized *)&v56);
  sub_1009F4004(v4, (uint64_t)&v56);
  long long v20 = (long long *)*((void *)&v56 + 1);
  long long v19 = v57;
  if (v57)
  {
    atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v21 = *v20;
    long long v22 = v20[2];
    v14[1] = v20[1];
    v14[2] = v22;
    *long long v14 = v21;
    sub_10004D2C8(v19);
  }
  else
  {
    long long v23 = **((_OWORD **)&v56 + 1);
    long long v24 = *(_OWORD *)(*((void *)&v56 + 1) + 32);
    v14[1] = *(_OWORD *)(*((void *)&v56 + 1) + 16);
    v14[2] = v24;
    *long long v14 = v23;
  }
  int v61 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 408) = v61;
  int v62 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 412) = v62;
  int v63 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 416) = v63;
  sub_1009EC7D0();
  boost::archive::detail::basic_iarchive::load_object(v4, v6 + 424, (const boost::archive::detail::basic_iserializer *)qword_101B0FA28);
  int v64 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 432) = v64;
  int v65 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 436) = v65;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v45);
  sub_1009F3F58(v4, (uint64_t)&v45);
  uint64_t v26 = v46;
  uint64_t v25 = v47;
  if (v47) {
    atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 440) = *(void *)v26;
  std::string::operator=((std::string *)(v6 + 448), (const std::string *)(v26 + 8));
  std::string::operator=((std::string *)(v6 + 472), (const std::string *)(v26 + 32));
  int v27 = *(_DWORD *)(v26 + 56);
  *(unsigned char *)(v6 + 500) = *(unsigned char *)(v26 + 60);
  *(_DWORD *)(v6 + 496) = v27;
  std::string::operator=((std::string *)(v6 + 504), (const std::string *)(v26 + 64));
  std::string::operator=((std::string *)(v6 + 528), (const std::string *)(v26 + 88));
  long long v28 = *(_OWORD *)(v26 + 112);
  *(unsigned char *)(v6 + 568) = *(unsigned char *)(v26 + 128);
  *(_OWORD *)(v6 + 552) = v28;
  if (v25) {
    sub_10004D2C8(v25);
  }
  int v66 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 576) = v66;
  sub_1009F3F20();
  sub_1009F3FB4((uint64_t)v4, (_DWORD *)(v6 + 584));
  int v67 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 588) = v67;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  unsigned __int8 v44 = 0;
  C2KVmnInfoSerialized::C2KVmnInfoSerialized((C2KVmnInfoSerialized *)&v42);
  sub_1009EC968();
  boost::archive::detail::basic_iarchive::load_object(v4, (uint64_t)&v42, (const boost::archive::detail::basic_iserializer *)qword_101B0FA40);
  uint64_t v30 = v43;
  int v29 = v44;
  if (v44) {
    atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v31 = *(_OWORD *)(v30 + 8);
  long long v32 = *(_OWORD *)(v30 + 24);
  *(void *)(v6 + 632) = *(void *)(v30 + 40);
  *(_OWORD *)(v6 + 616) = v32;
  *(_OWORD *)(v6 + 600) = v31;
  *(void *)(v6 + 640) = *(void *)(v30 + 48);
  std::string::operator=((std::string *)(v6 + 648), (const std::string *)(v30 + 56));
  std::string::operator=((std::string *)(v6 + 672), (const std::string *)(v30 + 80));
  int v33 = *(_DWORD *)(v30 + 104);
  *(unsigned char *)(v6 + 700) = *(unsigned char *)(v30 + 108);
  *(_DWORD *)(v6 + 696) = v33;
  std::string::operator=((std::string *)(v6 + 704), (const std::string *)(v30 + 112));
  std::string::operator=((std::string *)(v6 + 728), (const std::string *)(v30 + 136));
  long long v34 = *(_OWORD *)(v30 + 160);
  *(unsigned char *)(v6 + 768) = *(unsigned char *)(v30 + 176);
  *(_OWORD *)(v6 + 752) = v34;
  *(void *)(v6 + 776) = *(void *)(v30 + 184);
  std::string::operator=((std::string *)(v6 + 784), (const std::string *)(v30 + 192));
  std::string::operator=((std::string *)(v6 + 808), (const std::string *)(v30 + 216));
  int v35 = *(_DWORD *)(v30 + 240);
  *(unsigned char *)(v6 + 836) = *(unsigned char *)(v30 + 244);
  *(_DWORD *)(v6 + 832) = v35;
  std::string::operator=((std::string *)(v6 + 840), (const std::string *)(v30 + 248));
  std::string::operator=((std::string *)(v6 + 864), (const std::string *)(v30 + 272));
  long long v36 = *(_OWORD *)(v30 + 296);
  *(unsigned char *)(v6 + 904) = *(unsigned char *)(v30 + 312);
  *(_OWORD *)(v6 + 888) = v36;
  *(unsigned char *)(v6 + 912) = *(unsigned char *)(v30 + 320);
  ctu::OsLogLogger::operator=();
  if (v29) {
    sub_10004D2C8(v29);
  }
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  C2KVmnAckInfoSerialized::C2KVmnAckInfoSerialized((C2KVmnAckInfoSerialized *)&v39);
  sub_1009ECC98();
  boost::archive::detail::basic_iarchive::load_object(v4, (uint64_t)&v39, (const boost::archive::detail::basic_iserializer *)qword_101B0FA70);
  uint64_t v38 = v40;
  int v37 = v41;
  if (v41) {
    atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(v6 + 936) = *(_OWORD *)(v38 + 8);
  if (v6 + 928 != v38)
  {
    sub_10008A534((char *)(v6 + 952), *(char **)(v38 + 24), *(void *)(v38 + 32), (uint64_t)(*(void *)(v38 + 32) - *(void *)(v38 + 24)) >> 2);
    sub_10008A534((char *)(v6 + 976), *(char **)(v38 + 48), *(void *)(v38 + 56), (uint64_t)(*(void *)(v38 + 56) - *(void *)(v38 + 48)) >> 2);
  }
  *(unsigned char *)(v6 + 1000) = *(unsigned char *)(v38 + 72);
  ctu::OsLogLogger::operator=();
  if (v37) {
    sub_10004D2C8(v37);
  }
  sub_1009F3EEC();
  sub_1009F3F20();
  sub_1009F3F20();
  sub_1009F3F20();
  sub_1009F3EEC();
  sub_1009F3EEC();
  sub_1009F3F20();
  sub_1009F3F20();
  sub_1009F3F20();
  sub_1009F3EEC();
  sub_1009EBB10();
  boost::archive::detail::basic_iarchive::load_object(v4, v6 + 1050, (const boost::archive::detail::basic_iserializer *)qword_101B0F968);
  C2KVmnAckInfoSerialized::~C2KVmnAckInfoSerialized((C2KVmnAckInfoSerialized *)&v39);
  C2KVmnInfoSerialized::~C2KVmnInfoSerialized((C2KVmnInfoSerialized *)&v42);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v45);
  CSIDateSerialized::~CSIDateSerialized((CSIDateSerialized *)&v56);
  CSIDateSerialized::~CSIDateSerialized((CSIDateSerialized *)&v58);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v48);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1009F3B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v16 = va_arg(va3, void);
  uint64_t v18 = va_arg(va3, void);
  uint64_t v19 = va_arg(va3, void);
  uint64_t v20 = va_arg(va3, void);
  uint64_t v21 = va_arg(va3, void);
  uint64_t v22 = va_arg(va3, void);
  C2KVmnInfoSerialized::~C2KVmnInfoSerialized((C2KVmnInfoSerialized *)va);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)va1);
  CSIDateSerialized::~CSIDateSerialized((CSIDateSerialized *)va3);
  CSIDateSerialized::~CSIDateSerialized((CSIDateSerialized *)(v6 - 120));
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)va2);
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void *sub_1009F3EEC()
{
  return sub_1009F11D4();
}

void sub_1009F3F04(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void *sub_1009F3F20()
{
  return sub_10006B47C();
}

void sub_1009F3F3C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

uint64_t sub_1009F3F58(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  return boost::archive::detail::basic_iarchive::load_object(a1, a2, (const boost::archive::detail::basic_iserializer *)qword_101B0F998);
}

void sub_1009F3F94(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void *sub_1009F3FB4(uint64_t a1, _DWORD *a2)
{
  uint64_t result = sub_10006B47C();
  *a2 = 0;
  return result;
}

void sub_1009F3FF4(void *a1)
{
}

uint64_t sub_1009F4004(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  return boost::archive::detail::basic_iarchive::load_object(a1, a2, (const boost::archive::detail::basic_iserializer *)qword_101B0F9B0);
}

void sub_1009F4040(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void sub_1009F4060(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A261C8;
  byte_101B0F845 = 1;
  sub_1009F4170(a1);
}

uint64_t *sub_1009F408C()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FBB0, 0);
  *(void *)char v0 = off_101A26270;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FBB0);
  qword_101B0FBB0[0] = (uint64_t)off_101A261C8;
  if (byte_101B0F845 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F4144(_Unwind_Exception *a1)
{
}

void sub_1009F4170(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26270;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F41D0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A261C8;
  byte_101B0F845 = 1;
  sub_1009F4170(a1);

  operator delete();
}

void sub_1009F4230(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void **sub_1009F42C8(uint64_t a1, void **a2)
{
  return sub_1009F158C(a2);
}

void sub_1009F42D4(boost::serialization::extended_type_info *a1)
{
  sub_1009F4170(a1);

  operator delete();
}

void sub_1009F430C(uint64_t a1, const void *a2, unint64_t *a3)
{
  uint64_t v4 = sub_1009F1284(a2);
  unsigned __int16 v5 = 0;
  boost::archive::detail::basic_iarchive::get_library_version((uint64_t)v4, &v5);
  sub_1009F16BC();
  if (v5 >= 4u)
  {
    int v6 = 0;
    sub_10006D048();
  }
  sub_1003BF988(a3, 0);
  if (a3[1] != *a3) {
    a3[1] = *a3;
  }
}

void sub_1009F44AC(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A262C8;
  byte_101B0F846 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F44D8()
{
  sub_1009EC23C();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F9E0, (uint64_t)qword_101B0FBB0);
  *uint64_t result = off_101A262C8;
  if (byte_101B0F846 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F4558(_Unwind_Exception *a1)
{
}

void sub_1009F4570(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A262C8;
  byte_101B0F846 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F45D0()
{
  return 0;
}

BOOL sub_1009F45D8(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F45E8(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F45F0()
{
  return 0;
}

void **sub_1009F45F8(uint64_t a1, void **a2)
{
  return sub_1009F158C(a2);
}

void sub_1009F4600(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26348;
  byte_101B0F847 = 1;
  sub_1009F4710(a1);
}

uint64_t *sub_1009F462C()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FBD0, 0);
  *(void *)char v0 = off_101A263F0;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FBD0);
  qword_101B0FBD0[0] = (uint64_t)off_101A26348;
  if (byte_101B0F847 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F46E4(_Unwind_Exception *a1)
{
}

void sub_1009F4710(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A263F0;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F4770(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26348;
  byte_101B0F847 = 1;
  sub_1009F4710(a1);

  operator delete();
}

void sub_1009F47D0(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F4868(uint64_t a1, uint64_t a2)
{
  return sub_1009F48AC(a2);
}

void sub_1009F4874(boost::serialization::extended_type_info *a1)
{
  sub_1009F4710(a1);

  operator delete();
}

uint64_t sub_1009F48AC(uint64_t result)
{
  if (result)
  {
    sub_10005D144(*(void **)(result + 8));
    operator delete();
  }
  return result;
}

void *sub_1009F4900(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = sub_1009F1284(a2);
  sub_10005D144(*(void **)(a3 + 8));
  *(void *)a3 = a3 + 8;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 8) = 0;
  unsigned __int16 v6 = 0;
  boost::archive::detail::basic_iarchive::get_library_version((uint64_t)v4, &v6);
  uint64_t result = sub_1009F16BC();
  if (v6 >= 4u)
  {
    LODWORD(v7) = 0;
    return sub_10006D048();
  }
  return result;
}

void sub_1009F4C18(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26448;
  byte_101B0F848 = 1;
  sub_1009F4D28(a1);
}

uint64_t *sub_1009F4C44()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FBF0, 0);
  *(void *)char v0 = off_101A264F0;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FBF0);
  qword_101B0FBF0[0] = (uint64_t)off_101A26448;
  if (byte_101B0F848 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F4CFC(_Unwind_Exception *a1)
{
}

void sub_1009F4D28(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A264F0;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F4D88(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26448;
  byte_101B0F848 = 1;
  sub_1009F4D28(a1);

  operator delete();
}

void sub_1009F4DE8(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void sub_1009F4E80(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F4EA4(boost::serialization::extended_type_info *a1)
{
  sub_1009F4D28(a1);

  operator delete();
}

void *sub_1009F4EDC(uint64_t a1, const void *a2)
{
  sub_1009F1284(a2);
  sub_10006D048();

  return sub_1009F11D4();
}

void sub_1009F4F2C(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26548;
  byte_101B0F849 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F4F58()
{
  sub_1009EC4A0();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0F9F8, (uint64_t)qword_101B0FBF0);
  *uint64_t result = off_101A26548;
  if (byte_101B0F849 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F4FD8(_Unwind_Exception *a1)
{
}

void sub_1009F4FF0(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26548;
  byte_101B0F849 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F5050()
{
  return 1;
}

BOOL sub_1009F5058(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F5068(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F5070()
{
  return 0;
}

void sub_1009F5078(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F5098(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A265C8;
  byte_101B0F84A = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F50C4()
{
  sub_1009EC3D4();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0FA10, (uint64_t)qword_101B0FBD0);
  *uint64_t result = off_101A265C8;
  if (byte_101B0F84A == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F5144(_Unwind_Exception *a1)
{
}

void sub_1009F515C(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A265C8;
  byte_101B0F84A = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F51BC()
{
  return 1;
}

BOOL sub_1009F51C4(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F51D4(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F51DC()
{
  return 0;
}

uint64_t sub_1009F51E4(uint64_t a1, uint64_t a2)
{
  return sub_1009F48AC(a2);
}

void sub_1009F51EC(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26648;
  byte_101B0F84B = 1;
  sub_1009F52FC(a1);
}

uint64_t *sub_1009F5218()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FC10, 0);
  *(void *)char v0 = off_101A266F0;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FC10);
  qword_101B0FC10[0] = (uint64_t)off_101A26648;
  if (byte_101B0F84B == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F52D0(_Unwind_Exception *a1)
{
}

void sub_1009F52FC(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A266F0;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F535C(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26648;
  byte_101B0F84B = 1;
  sub_1009F52FC(a1);

  operator delete();
}

void sub_1009F53BC(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void sub_1009F5454(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F5478(boost::serialization::extended_type_info *a1)
{
  sub_1009F52FC(a1);

  operator delete();
}

void sub_1009F54B0(uint64_t a1, const void *a2, uint64_t *a3)
{
  uint64_t v4 = sub_1009F1284(a2);
  memset(&__p, 0, sizeof(__p));
  boost::archive::text_iarchive_impl<boost::archive::text_iarchive>::load((uint64_t)v4, &__p);
  uint64_t v17 = 0;
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  char v6 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }
  else
  {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (size)
  {
    uint64_t v8 = p_p;
    std::string::size_type v9 = size;
    do
    {
      std::string::value_type v10 = v8->__r_.__value_.__s.__data_[0];
      uint64_t v8 = (std::string *)((char *)v8 + 1);
      if ((v10 & 0xFE) != 0x30) {
        sub_1003B7950("bitset string ctor has invalid argument");
      }
      --v9;
    }
    while (v9);
  }
  uint64_t v11 = 4;
  if (size < 4) {
    uint64_t v11 = size;
  }
  if (!v11) {
    goto LABEL_16;
  }
  uint64_t v12 = 0;
  char v13 = 0;
  uint64_t v14 = (char *)&p_p[-1].__r_.__value_.__r.__words[2] + 7;
  uint64_t v15 = v11;
  do
  {
    uint64_t v16 = v12 & ~(1 << v13);
    v12 |= 1 << v13;
    if (v14[v15] != 49) {
      uint64_t v12 = v16;
    }
    uint64_t v17 = v12;
    ++v13;
    --v15;
  }
  while (v15);
  if (size <= 3)
  {
LABEL_16:
    uint64_t v19 = &v17;
    int v20 = v11;
    sub_10019E478((uint64_t)&v19, 4 - v11);
    uint64_t v12 = v17;
    char v6 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  *a3 = v12;
  if (v6 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1009F55CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009F55EC(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26770;
  byte_101B0F84C = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F5618()
{
  sub_1009EC704();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0FA28, (uint64_t)qword_101B0FC10);
  *uint64_t result = off_101A26770;
  if (byte_101B0F84C == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F5698(_Unwind_Exception *a1)
{
}

void sub_1009F56B0(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26770;
  byte_101B0F84C = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F5710()
{
  return 1;
}

uint64_t sub_1009F5718()
{
  return 0;
}

void sub_1009F5720(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F5728()
{
  return 0;
}

void sub_1009F5730(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator delete();
  }
}

void sub_1009F5750(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A267F0;
  byte_101B0F84D = 1;
  sub_1009F5860(a1);
}

uint64_t *sub_1009F577C()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FC30, 0);
  *(void *)char v0 = off_101A26898;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FC30);
  qword_101B0FC30[0] = (uint64_t)off_101A267F0;
  if (byte_101B0F84D == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F5834(_Unwind_Exception *a1)
{
}

void sub_1009F5860(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26898;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F58C0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A267F0;
  byte_101B0F84D = 1;
  sub_1009F5860(a1);

  operator delete();
}

void sub_1009F5920(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F59B8(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F59EC(boost::serialization::extended_type_info *a1)
{
  sub_1009F5860(a1);

  operator delete();
}

void sub_1009F5A24(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = (boost::archive::detail::basic_iarchive *)sub_1009F1284(a2);
  uint64_t v6 = *(void *)(a3 + 8);
  unsigned __int16 v5 = *(std::__shared_weak_count **)(a3 + 16);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v21 = 0;
  sub_10006B47C();
  *(_DWORD *)(v6 + 8) = 0;
  sub_1009F5D24();
  sub_1009F5D24();
  sub_1009F5D24();
  sub_1009F5D58();
  sub_1009F5D58();
  sub_1009F5D58();
  sub_1009F5D24();
  sub_1009F5D24();
  sub_1009F5D24();
  sub_1009F5D24();
  sub_1009F5D58();
  sub_1009F5D58();
  sub_1009F5D58();
  sub_1009F5D58();
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  int v20 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v18);
  sub_1009F5D90(v4, (uint64_t)&v18);
  uint64_t v8 = v19;
  uint64_t v7 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 48) = *(void *)v8;
  std::string::operator=((std::string *)(v6 + 56), (const std::string *)(v8 + 8));
  std::string::operator=((std::string *)(v6 + 80), (const std::string *)(v8 + 32));
  int v9 = *(_DWORD *)(v8 + 56);
  *(unsigned char *)(v6 + 108) = *(unsigned char *)(v8 + 60);
  *(_DWORD *)(v6 + 104) = v9;
  std::string::operator=((std::string *)(v6 + 112), (const std::string *)(v8 + 64));
  std::string::operator=((std::string *)(v6 + 136), (const std::string *)(v8 + 88));
  long long v10 = *(_OWORD *)(v8 + 112);
  *(unsigned char *)(v6 + 176) = *(unsigned char *)(v8 + 128);
  *(_OWORD *)(v6 + 160) = v10;
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  CSIPhoneNumberSerialized::CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v15);
  sub_1009F5D90(v4, (uint64_t)&v15);
  uint64_t v12 = v16;
  uint64_t v11 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v6 + 184) = *(void *)v12;
  std::string::operator=((std::string *)(v6 + 192), (const std::string *)(v12 + 8));
  std::string::operator=((std::string *)(v6 + 216), (const std::string *)(v12 + 32));
  int v13 = *(_DWORD *)(v12 + 56);
  *(unsigned char *)(v6 + 244) = *(unsigned char *)(v12 + 60);
  *(_DWORD *)(v6 + 240) = v13;
  std::string::operator=((std::string *)(v6 + 248), (const std::string *)(v12 + 64));
  std::string::operator=((std::string *)(v6 + 272), (const std::string *)(v12 + 88));
  long long v14 = *(_OWORD *)(v12 + 112);
  *(unsigned char *)(v6 + 312) = *(unsigned char *)(v12 + 128);
  *(_OWORD *)(v6 + 296) = v14;
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_1009F5D24();
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v15);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)&v18);
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1009F5C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  CSIPhoneNumberSerialized::~CSIPhoneNumberSerialized((CSIPhoneNumberSerialized *)va);
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void *sub_1009F5D24()
{
  return sub_1009F11D4();
}

void sub_1009F5D3C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void *sub_1009F5D58()
{
  return sub_10006B47C();
}

void sub_1009F5D74(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

uint64_t sub_1009F5D90(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  return boost::archive::detail::basic_iarchive::load_object(a1, a2, (const boost::archive::detail::basic_iserializer *)qword_101B0F998);
}

void sub_1009F5DCC(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void sub_1009F5DEC(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A268E0;
  byte_101B0F84E = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F5E18()
{
  sub_1009EC89C();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0FA40, (uint64_t)qword_101B0FC30);
  *uint64_t result = off_101A268E0;
  if (byte_101B0F84E == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F5E98(_Unwind_Exception *a1)
{
}

void sub_1009F5EB0(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A268E0;
  byte_101B0F84E = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F5F10()
{
  return 1;
}

BOOL sub_1009F5F18(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F5F28(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F5F30()
{
  return 1;
}

uint64_t sub_1009F5F38(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F5F68(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26960;
  byte_101B0F84F = 1;
  sub_1009F6078(a1);
}

uint64_t *sub_1009F5F94()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FC50, 0);
  *(void *)char v0 = off_101A26A08;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FC50);
  qword_101B0FC50[0] = (uint64_t)off_101A26960;
  if (byte_101B0F84F == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F604C(_Unwind_Exception *a1)
{
}

void sub_1009F6078(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26A08;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F60D8(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26960;
  byte_101B0F84F = 1;
  sub_1009F6078(a1);

  operator delete();
}

void sub_1009F6138(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F61D0(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F6204(boost::serialization::extended_type_info *a1)
{
  sub_1009F6078(a1);

  operator delete();
}

void sub_1009F623C(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = (boost::archive::detail::basic_iarchive *)sub_1009F1284(a2);
  uint64_t v6 = *(void *)(a3 + 8);
  unsigned __int16 v5 = *(std::__shared_weak_count **)(a3 + 16);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1009F633C();
  sub_1009F633C();
  sub_1009F633C();
  sub_1009F633C();
  sub_1009F6374(v4, v6 + 24);
  sub_1009F6374(v4, v6 + 48);
  sub_1009F11D4();
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void *sub_1009F633C()
{
  return sub_10006B47C();
}

void sub_1009F6358(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

uint64_t sub_1009F6374(boost::archive::detail::basic_iarchive *a1, uint64_t a2)
{
  return boost::archive::detail::basic_iarchive::load_object(a1, a2, (const boost::archive::detail::basic_iserializer *)qword_101B0FA58);
}

void sub_1009F63B0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void sub_1009F63D0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26A50;
  byte_101B0F850 = 1;
  sub_1009F64E0(a1);
}

uint64_t *sub_1009F63FC()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FC70, 0);
  *(void *)char v0 = off_101A26AF8;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FC70);
  qword_101B0FC70[0] = (uint64_t)off_101A26A50;
  if (byte_101B0F850 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F64B4(_Unwind_Exception *a1)
{
}

void sub_1009F64E0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26AF8;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F6540(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26A50;
  byte_101B0F850 = 1;
  sub_1009F64E0(a1);

  operator delete();
}

void sub_1009F65A0(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

void **sub_1009F6638(uint64_t a1, void **a2)
{
  return sub_1009F158C(a2);
}

void sub_1009F6644(boost::serialization::extended_type_info *a1)
{
  sub_1009F64E0(a1);

  operator delete();
}

void sub_1009F667C(uint64_t a1, const void *a2, void **a3)
{
  uint64_t v4 = sub_1009F1284(a2);
  unsigned __int16 v5 = 0;
  boost::archive::detail::basic_iarchive::get_library_version((uint64_t)v4, &v5);
  sub_1009F16BC();
  if (v5 >= 4u)
  {
    int v6 = 0;
    sub_10006D048();
  }
  sub_100215304(a3, 0);
  sub_10006EE1C((uint64_t)a3, 0);
}

void sub_1009F672C(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26B50;
  byte_101B0F851 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F6758()
{
  sub_1009ECB00();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0FA58, (uint64_t)qword_101B0FC70);
  *uint64_t result = off_101A26B50;
  if (byte_101B0F851 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F67D8(_Unwind_Exception *a1)
{
}

void sub_1009F67F0(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26B50;
  byte_101B0F851 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F6850()
{
  return 0;
}

BOOL sub_1009F6858(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F6868(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F6870()
{
  return 0;
}

void **sub_1009F6878(uint64_t a1, void **a2)
{
  return sub_1009F158C(a2);
}

void sub_1009F6880(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26BD0;
  byte_101B0F852 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F68AC()
{
  sub_1009ECA34();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0FA70, (uint64_t)qword_101B0FC50);
  *uint64_t result = off_101A26BD0;
  if (byte_101B0F852 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F692C(_Unwind_Exception *a1)
{
}

void sub_1009F6944(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26BD0;
  byte_101B0F852 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F69A4()
{
  return 1;
}

BOOL sub_1009F69AC(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F69BC(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F69C4()
{
  return 1;
}

uint64_t sub_1009F69CC(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F69FC(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26C50;
  byte_101B0F853 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);
}

void *sub_1009F6A28()
{
  sub_1009EC170();
  uint64_t result = boost::archive::detail::basic_iserializer::basic_iserializer(qword_101B0FA88, (uint64_t)qword_101B0FB90);
  *uint64_t result = off_101A26C50;
  if (byte_101B0F853 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F6AA8(_Unwind_Exception *a1)
{
}

void sub_1009F6AC0(boost::archive::detail::basic_iserializer *a1)
{
  *(void *)a1 = off_101A26C50;
  byte_101B0F853 = 1;
  boost::archive::detail::basic_iserializer::~basic_iserializer(a1);

  operator delete();
}

uint64_t sub_1009F6B20()
{
  return 1;
}

BOOL sub_1009F6B28(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F6B38(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F6B40()
{
  return 1;
}

uint64_t sub_1009F6B48(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F6B78(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A26CD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009F6B98(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A26CD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1009F6BEC(uint64_t a1)
{
}

void sub_1009F6BF8(void *a1)
{
  uint64_t v2 = operator new(0x28uLL);
  v2[1] = 0;
  void v2[2] = 0;
  *uint64_t v2 = off_101A26D20;
  CTParserXPCRequest::CTParserXPCRequest((CTParserXPCRequest *)(v2 + 3));
  *a1 = v3;
  a1[1] = v2;
}

void sub_1009F6C4C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1009F6C64(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A26D20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1009F6C84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A26D20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1009F6CD8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 8))();
}

boost::archive::detail::basic_oarchive *sub_1009F6D00(boost::archive::detail::basic_oarchive *a1)
{
  boost::archive::detail::basic_oarchive::~basic_oarchive(a1);
  boost::archive::basic_text_oprimitive<std::ostream>::~basic_text_oprimitive(v2 + 48);
  return a1;
}

void sub_1009F6D30(boost::archive::detail::basic_oarchive *a1)
{
  boost::archive::detail::basic_oarchive::~basic_oarchive(a1);
  boost::archive::basic_text_oprimitive<std::ostream>::~basic_text_oprimitive(v1 + 48);

  operator delete();
}

void sub_1009F6D80(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26DE8;
  byte_101B0F854 = 1;
  sub_1009F6E90(a1);
}

uint64_t *sub_1009F6DAC()
{
  char v0 = (boost::serialization::typeid_system::extended_type_info_typeid_0 *)boost::serialization::typeid_system::extended_type_info_typeid_0::extended_type_info_typeid_0((boost::serialization::typeid_system::extended_type_info_typeid_0 *)qword_101B0FC90, 0);
  *(void *)char v0 = off_101A26E90;
  uint64_t result = boost::serialization::extended_type_info::key_register(qword_101B0FC90);
  qword_101B0FC90[0] = (uint64_t)off_101A26DE8;
  if (byte_101B0F854 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F6E64(_Unwind_Exception *a1)
{
}

void sub_1009F6E90(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26E90;
  boost::serialization::extended_type_info::key_unregister(a1);
  boost::serialization::typeid_system::extended_type_info_typeid_0::type_unregister((uint64_t *)a1);

  boost::serialization::typeid_system::extended_type_info_typeid_0::~extended_type_info_typeid_0(a1);
}

void sub_1009F6EF0(boost::serialization::extended_type_info *a1)
{
  *(void *)a1 = off_101A26DE8;
  byte_101B0F854 = 1;
  sub_1009F6E90(a1);

  operator delete();
}

void sub_1009F6F50(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      __assert_rtn("factory", "factory.hpp", 38, "false");
    default:
      __assert_rtn("construct", "extended_type_info_typeid.hpp", 129, "false");
  }
}

uint64_t sub_1009F6FE8(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void sub_1009F701C(boost::serialization::extended_type_info *a1)
{
  sub_1009F6E90(a1);

  operator delete();
}

void sub_1009F7054(uint64_t a1, const void *a2, uint64_t a3)
{
  unsigned __int16 v5 = (boost::archive::detail::basic_oarchive *)sub_1009F729C(a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 40))(&v8, a1);
  uint64_t v7 = *(_DWORD **)(a3 + 8);
  int v6 = *(std::__shared_weak_count **)(a3 + 16);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HIDWORD(v8) = *v7;
  sub_1009F7250(v5);
  int v9 = v7[1];
  sub_1009F7250(v5);
  int v10 = v7[2];
  sub_1009F7250(v5);
  sub_1009ECEFC();
  boost::archive::detail::basic_oarchive::save_object((unsigned int **)v5, (unint64_t)(v7 + 4), (const boost::archive::detail::basic_oserializer *)qword_101B0FAA0);
  sub_1009F71F4(v5);
  sub_1009F71F4(v5);
  if (v6) {
    sub_10004D2C8(v6);
  }
}

uint64_t sub_1009F71F4(boost::archive::detail::basic_oarchive *a1)
{
  return boost::archive::basic_text_oprimitive<std::ostream>::save((void *)a1 + 6);
}

void sub_1009F7230(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

uint64_t sub_1009F7250(boost::archive::detail::basic_oarchive *a1)
{
  return sub_10006BEE4((void *)a1 + 6);
}

void *sub_1009F729C(const void *a1)
{
  if (!result) {
    __cxa_bad_cast();
  }
  return result;
}

uint64_t sub_1009F72F8(uint64_t a1, const void *a2, unsigned __int8 **a3)
{
  unsigned __int16 v5 = (boost::archive::detail::basic_oarchive *)sub_1009F729C(a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 40))(&v12, a1);
  uint64_t v7 = *a3;
  int v6 = a3[1];
  boost::archive::detail::basic_oarchive::end_preamble(v5);
  boost::archive::basic_text_oarchive<boost::archive::text_oarchive>::newtoken((uint64_t)v5);
  if ((*(unsigned char *)(*((void *)v5 + 6) + *(void *)(**((void **)v5 + 6) - 24) + 32) & 5) != 0)
  {
    boost::archive::archive_exception::archive_exception((uint64_t)v13, 13, 0, 0);
    sub_10006A800((uint64_t)v13);
  }
  std::ostream::operator<<();
  boost::archive::detail::basic_oarchive::end_preamble(v5);
  v13[0] = 0;
  boost::archive::basic_text_oarchive<boost::archive::text_oarchive>::newtoken((uint64_t)v5);
  HIBYTE(v12) = 0;
  uint64_t result = sub_10006D9D0((void *)v5 + 6);
  if (v6 != v7)
  {
    int v9 = *a3;
    int v10 = (unsigned __int8 *)(v7 - v6);
    do
    {
      boost::archive::detail::basic_oarchive::end_preamble(v5);
      boost::archive::basic_text_oarchive<boost::archive::text_oarchive>::newtoken((uint64_t)v5);
      LOWORD(v13[0]) = *v9;
      HIBYTE(v12) = 0;
      uint64_t result = sub_10006BE20((void *)v5 + 6);
      ++v9;
    }
    while (!__CFADD__(v10++, 1));
  }
  return result;
}

void sub_1009F7474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

void sub_1009F7490(boost::archive::detail::basic_oserializer *a1)
{
  *(void *)a1 = off_101A26ED8;
  byte_101B0F855 = 1;
  boost::archive::detail::basic_oserializer::~basic_oserializer(a1);
}

void *sub_1009F74BC()
{
  sub_1009EB8AC();
  uint64_t result = boost::archive::detail::basic_oserializer::basic_oserializer(qword_101B0FAA0, (uint64_t)qword_101B0FAF0);
  *uint64_t result = off_101A26ED8;
  if (byte_101B0F855 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F753C(_Unwind_Exception *a1)
{
}

void sub_1009F7554(boost::archive::detail::basic_oserializer *a1)
{
  *(void *)a1 = off_101A26ED8;
  byte_101B0F855 = 1;
  boost::archive::detail::basic_oserializer::~basic_oserializer(a1);

  operator delete();
}

uint64_t sub_1009F75B4()
{
  return 0;
}

BOOL sub_1009F75BC(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F75CC(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F75D4()
{
  return 0;
}

void sub_1009F75DC(boost::archive::detail::basic_oserializer *a1)
{
  *(void *)a1 = off_101A26F50;
  byte_101B0F856 = 1;
  boost::archive::detail::basic_oserializer::~basic_oserializer(a1);
}

void *sub_1009F7608()
{
  sub_1009ECE30();
  uint64_t result = boost::archive::detail::basic_oserializer::basic_oserializer(qword_101B0FAB8, (uint64_t)qword_101B0FC90);
  *uint64_t result = off_101A26F50;
  if (byte_101B0F856 == 1) {
    __assert_rtn("singleton_wrapper", "singleton.hpp", 148, "! is_destroyed()");
  }
  return result;
}

void sub_1009F7688(_Unwind_Exception *a1)
{
}

void sub_1009F76A0(boost::archive::detail::basic_oserializer *a1)
{
  *(void *)a1 = off_101A26F50;
  byte_101B0F856 = 1;
  boost::archive::detail::basic_oserializer::~basic_oserializer(a1);

  operator delete();
}

uint64_t sub_1009F7700()
{
  return 1;
}

BOOL sub_1009F7708(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0;
}

void sub_1009F7718(_DWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1009F7720()
{
  return 1;
}

void *sub_1009F7728(void *a1)
{
  *a1 = off_101A26FC8;
  sub_1009F04EC(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1009F7784(void *a1)
{
  *a1 = off_101A26FC8;
  sub_1009F04EC(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1009F7800(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A26FC8;
  sub_1009F7B58(v2 + 1, v1);
  return v2;
}

void sub_1009F7854(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1009F7868(uint64_t a1, void *a2)
{
  *a2 = off_101A26FC8;
  return sub_1009F7B58(a2 + 1, (void *)(a1 + 8));
}

void sub_1009F7894(uint64_t a1)
{
}

void sub_1009F789C(void *a1)
{
  sub_1009F7BDC(a1 + 1);

  operator delete(a1);
}

void sub_1009F78D8(void *a1, uint64_t a2)
{
  uint64_t v4 = *(CTParserXPCResponse **)a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  unsigned __int16 v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = a1[1];
      if (v8)
      {
        if (CTParserXPCResponse::hasError(v4))
        {
          int v9 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid XPC response", buf, 2u);
          }
        }
        else
        {
          v12[0] = v4;
          v12[1] = v3;
          if (v3) {
            atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v10 = (std::__shared_weak_count *)a1[4];
          v11[0] = a1[3];
          v11[1] = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_1009F0454((uint64_t)buf, (uint64_t)(a1 + 5));
          sub_1009D6058(v8, v12, v11, (uint64_t)buf);
          sub_1009F04EC(buf);
          if (v10) {
            sub_10004D2C8(v10);
          }
          if (v3) {
            sub_10004D2C8(v3);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_1009F7A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1009F04EC((uint64_t *)va);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v5)
  {
    sub_10004D2C8(v5);
    sub_10004D2C8(v6);
  }
  else
  {
    unsigned __int16 v5 = v6;
  }
  sub_10004D2C8(v5);
  _Unwind_Resume(a1);
}

uint64_t sub_1009F7A8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009F7ACC()
{
}

uint64_t sub_1009F7AD8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_1009F7B58(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1009F0454((uint64_t)(a1 + 4), (uint64_t)(a2 + 4));
  return a1;
}

void sub_1009F7BB8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009F7BDC(void *a1)
{
  sub_1009F04EC(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_1009F7C34(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1009F7CB8(void *a1)
{
  *a1 = off_101A27058;
  sub_1009F04EC(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1009F7D14(void *a1)
{
  *a1 = off_101A27058;
  sub_1009F04EC(a1 + 5);
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_1009F7D90(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = off_101A27058;
  sub_1009F8068(v2 + 1, v1);
  return v2;
}

void sub_1009F7DE4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1009F7DF8(uint64_t a1, void *a2)
{
  *a2 = off_101A27058;
  return sub_1009F8068(a2 + 1, (void *)(a1 + 8));
}

void sub_1009F7E24(uint64_t a1)
{
}

void sub_1009F7E2C(void *a1)
{
  sub_1009F7BDC(a1 + 1);

  operator delete(a1);
}

void sub_1009F7E68(void *a1, uint64_t a2)
{
  uint64_t v4 = *(CTParserXPCResponse **)a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  unsigned __int16 v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = a1[1];
      if (v8)
      {
        if (CTParserXPCResponse::hasError(v4))
        {
          int v9 = *(NSObject **)(v8 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid XPC response", buf, 2u);
          }
        }
        else
        {
          v12[0] = v4;
          v12[1] = v3;
          if (v3) {
            atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v10 = (std::__shared_weak_count *)a1[4];
          v11[0] = a1[3];
          v11[1] = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_1009F0454((uint64_t)buf, (uint64_t)(a1 + 5));
          sub_1009D6058(v8, v12, v11, (uint64_t)buf);
          sub_1009F04EC(buf);
          if (v10) {
            sub_10004D2C8(v10);
          }
          if (v3) {
            sub_10004D2C8(v3);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_1009F7FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1009F04EC((uint64_t *)va);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v5)
  {
    sub_10004D2C8(v5);
    sub_10004D2C8(v6);
  }
  else
  {
    unsigned __int16 v5 = v6;
  }
  sub_10004D2C8(v5);
  _Unwind_Resume(a1);
}

uint64_t sub_1009F801C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009F805C()
{
}

void *sub_1009F8068(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1009F0454((uint64_t)(a1 + 4), (uint64_t)(a2 + 4));
  return a1;
}

void sub_1009F80C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1009F80EC(uint64_t a1)
{
  return *(double *)(**(void **)(a1 + 40) + 2712) != 0.0;
}

uint64_t *sub_1009F8104(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1009F815C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1009F8144(_Unwind_Exception *a1)
{
  sub_100087ED0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1009F815C(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    unsigned __int16 v5 = (uint64_t **)result;
    int v6 = result + 1;
    do
    {
      uint64_t result = sub_1009F81E8(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1009F81E8(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v6 = sub_1000262C0(a1, a2, &v12, &v11, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1009F828C((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_10008B8F0((uint64_t)v10, 0);
  }
  return v7;
}

char *sub_1009F828C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = operator new(0x80uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *(_DWORD *)a2;
  uint64_t result = sub_100897414((char *)v6 + 40, (long long *)(a2 + 8));
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1009F82F0(_Unwind_Exception *a1)
{
  sub_10008B8F0(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_1009F8308(void *a1)
{
  *a1 = off_101A270F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1009F8354(void *a1)
{
  *a1 = off_101A270F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1009F83C0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A270F8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)result + 8) = *(_DWORD *)(a1 + 32);
  return result;
}

uint64_t sub_1009F842C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A270F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(result + 32);
  return result;
}

void sub_1009F8474(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1009F8484(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1009F84C4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = *(void *)(a1 + 8);
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      sub_10004D2C8(v6);
      if (v7)
      {
        uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), *(unsigned int *)(a1 + 32));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v9 = "true";
          if (!v4) {
            BOOL v9 = "false";
          }
          int v10 = 136315138;
          uint64_t v11 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I TPMR write status: %s", (uint8_t *)&v10, 0xCu);
        }
      }
    }
  }
}

uint64_t sub_1009F85D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009F8610()
{
}

void sub_1009F8620()
{
}

__n128 sub_1009F8634(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A27178;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1009F8680(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27178;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009F86B0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a3[1];
  *a3 = 0;
  a3[1] = 0;
  int v4 = (void *)(*(void *)(a1 + 8) + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v4);
  operator new();
}

uint64_t sub_1009F87C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1009F8804()
{
}

uint64_t *sub_1009F8810(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(unsigned __int8 ***)(v1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    if (*v2 == v2[1])
    {
      int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v1 + 24));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Empty TPMR value from sim", buf, 2u);
      }
    }
    else
    {
      unsigned int v4 = **v2;
      uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v1 + 24));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        unsigned int v11 = v4;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I TPMR read from sim: %u", buf, 8u);
      }
      sub_1009DCDFC(v3, *(unsigned int *)(v1 + 24), v4, 0);
    }
  }
  sub_1000BD218(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1009F8994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1009F89B0(uint64_t a1, unsigned int a2, void ***a3)
{
  unsigned int v13 = a2;
  if (subscriber::isValidSimSlot())
  {
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v13;
    uint64_t v5 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v13, (uint64_t)&unk_10144E20E, &__p)[5];
    sub_10005CD2C((uint64_t)(v5 + 64), (char *)v5[65]);
    v5[64] = (uint64_t)(v5 + 65);
    v5[66] = 0;
    v5[65] = 0;
    int v6 = *a3;
    uint64_t v7 = a3[1];
    if (*a3 != v7)
    {
      do
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v13;
        uint64_t v8 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v13, (uint64_t)&unk_10144E20E, &__p);
        sub_100046BAC((uint64_t **)v8[5] + 64, v6, (uint64_t)v6);
        v6 += 3;
      }
      while (v6 != v7);
    }
    uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v13);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v13;
      int v10 = sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v13, (uint64_t)&unk_10144E20E, &__p);
      sub_10082FF60(v10[5], &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v15 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Emergency Text Numbers %s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v13;
    if (sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v13, (uint64_t)&unk_10144E20E, &__p)[5][66]) {
      sub_1009DDA70(a1, v13);
    }
  }
}

void sub_1009F8BCC(void *a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    int v6 = (const void *)a1[1];
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = _Block_copy(v6);
    dispatch_retain(*(dispatch_object_t *)a2);
    if (a3 != 1) {
      return;
    }
    uint64_t v7 = (uint64_t)a1;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return;
    }
    uint64_t v7 = a2;
LABEL_10:
    sub_1009F93AC(v7);
    return;
  }
  uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
  if (v8 == (const char *)(0x8000000101520067 & 0x7FFFFFFFFFFFFFFFLL)
    || !strcmp(v8, (const char *)(0x8000000101520067 & 0x7FFFFFFFFFFFFFFFLL)))
  {
    *(void *)a2 = a1;
  }
  else
  {
    *(void *)a2 = 0;
  }
}

void sub_1009F8CB8(uint64_t a1)
{
  uint64_t v1 = _Block_copy(*(const void **)(a1 + 8));
  uint64_t v2 = _Block_copy(v1);
  uint64_t v3 = _Block_copy(v2);
  unsigned int v4 = _Block_copy(v3);
  uint64_t v5 = _Block_copy(v4);
  int v6 = _Block_copy(v5);
  uint64_t v8 = _Block_copy(v6);
  _Block_release(v6);
  _Block_release(v5);
  _Block_release(v4);
  uint64_t v7 = off_101A27228;
  _Block_release(v3);
  _Block_release(v2);
  operator new();
}

void sub_1009F8E50()
{
}

uint64_t sub_1009F8F14(uint64_t a1)
{
  sub_1003595BC(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_100980A44(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

void sub_1009F8F98(const void **a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  if (a3 > 1)
  {
    if (a3 != 3)
    {
      if (a3 == 2)
      {
        _Block_release(*(const void **)a2);
        return;
      }
      goto LABEL_2;
    }
    int v6 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v6 == (const char *)(0x80000001015200A7 & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v6, (const char *)(0x80000001015200A7 & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
  }
  else
  {
    *(void *)a2 = _Block_copy(*a1);
    if (a3 == 1) {
      _Block_release(*a1);
    }
  }
}

uint64_t sub_1009F906C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void *sub_1009F907C(void *a1)
{
  *a1 = off_101A27258;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1009F90C8(void *a1)
{
  *a1 = off_101A27258;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1009F9134(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_1009F91E4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1009F91FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_1009F921C()
{
}

void *sub_1009F9288(void *a1)
{
  *a1 = off_101A272A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1009F92D4(void *a1)
{
  *a1 = off_101A272A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1009F9340()
{
}

uint64_t sub_1009F93AC(uint64_t a1)
{
  return a1;
}

uint64_t sub_1009F93E4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1009F9430(uint64_t a1)
{
  sub_1009FB7C0((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_1009F9470(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1009F94B4(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_1009F95AC(a1, v3);
}

void sub_1009F957C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009F95AC(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_1009F96A4(a1, a2);
}

void sub_1009F968C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1009F96A4(uint64_t *a1, void *a2)
{
}

void sub_1009F9718()
{
}

uint64_t sub_1009F973C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_1009F9780(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_1009F97C4(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1009F9AE0(a1, a2, 1, 2);
}

void sub_1009F98C0()
{
}

void sub_1009F98E4(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_1009F9B94(&v2, a2);
}

uint64_t sub_1009F9960(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_1009F99A4(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  uint64_t v22 = *a4;
  int v10 = (uint64_t *)sub_1009F973C(a1);
  uint64_t result = (uint64_t *)sub_1009FAAA0(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_1009F9780(result + 2);
        sub_1009FA1C8(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_1009F9780(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_1009F973C(a1);
        uint64_t v17 = sub_1009FAAA0(v16);
        uint64_t v18 = sub_1009F9780(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      uint64_t v22 = (uint64_t *)v15;
      uint64_t v19 = (uint64_t *)sub_1009F973C(a1);
      int v20 = (uint64_t *)sub_1009FAAA0(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_1009F9AE0(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_1009F973C(a1);
  uint64_t v10 = sub_1009FAAA0(v9);
  unsigned int v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_1009F973C(a1);
    unsigned int v11 = *(uint64_t **)(sub_1009FAAA0(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_1009F99A4(a1, a2, a3, &v14, a4);
}

void sub_1009F9B94(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1009F9C00(&v2);
}

void sub_1009F9BEC(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1009F9C00(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1009F9C70(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_1009F9C84(_Unwind_Exception *a1)
{
}

void sub_1009F9C9C()
{
}

uint64_t sub_1009F9CB0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1009F9D14()
{
  return 0;
}

uint64_t sub_1009F9D1C()
{
  return 0;
}

uint64_t sub_1009F9D24()
{
  return 0;
}

void sub_1009F9D2C()
{
}

void sub_1009F9DA8()
{
}

uint64_t sub_1009F9DCC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1009F9F58((uint64_t *)a1, a2);
  sub_1009F9FC4((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  int v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      unsigned int v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          unsigned int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          uint64_t v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_1009F9F30(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1009F9F58(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_1009F9FB0(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1009F9FC4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1009FA014(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1009FA02C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1009FA098(&v2);
}

void sub_1009FA084(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1009FA098(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1009FA108(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_1009FA11C(_Unwind_Exception *a1)
{
}

void sub_1009FA134()
{
}

uint64_t sub_1009FA148(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_1009FA1B0()
{
  return 0;
}

uint64_t sub_1009FA1B8()
{
  return 0;
}

uint64_t sub_1009FA1C0()
{
  return 0;
}

uint64_t *sub_1009FA1C8(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    int v6 = (uint64_t *)sub_1009FA230(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_1009FA230(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1009FA274(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A273C8;
  operator new();
}

void sub_1009FA388(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_1009FA3F0(uint64_t a1)
{
  sub_1009FA7A4(a1);

  operator delete();
}

BOOL sub_1009FA428(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_1009FA814((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_1009FA4D8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1009FA508(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_1009FA534(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_1009FA560@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_1009FA5BC(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1009FA628(&v2);
}

void sub_1009FA614(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1009FA628(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1009FA698(void *a1)
{
  __cxa_begin_catch(a1);
  sub_1009FA6C0(v1);
  __cxa_rethrow();
}

void sub_1009FA6AC(_Unwind_Exception *a1)
{
}

uint64_t sub_1009FA6C0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_1009FB7C0((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_1009FA720()
{
}

uint64_t sub_1009FA734(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1009FB7C0((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_1009FA78C()
{
  return 0;
}

uint64_t sub_1009FA794()
{
  return 0;
}

uint64_t sub_1009FA79C()
{
  return 0;
}

uint64_t sub_1009FA7A4(uint64_t a1)
{
  *(void *)a1 = off_101A273C8;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_1009FA814(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1009FA230((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1009FA230(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_1009FA8F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1009FA918(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1009FA984(&v2);
}

void sub_1009FA970(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1009FA984(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1009FA9F4(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_1009FAA2C(_Unwind_Exception *a1)
{
}

void sub_1009FAA44()
{
}

uint64_t sub_1009FAA58(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1009FAA88()
{
  return 0;
}

uint64_t sub_1009FAA90()
{
  return 0;
}

uint64_t sub_1009FAA98()
{
  return 0;
}

uint64_t sub_1009FAAA0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

dispatch_object_t *sub_1009FAAE4(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v4 = _Block_copy(v4);
    dispatch_object_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_1009FAB2C(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_1009FAB84((uint64_t)a1, a2);
  return a1;
}

void sub_1009FAB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_1009FB7C0((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1009FAB84(uint64_t a1, NSObject **a2)
{
  sub_1009FAC60(v4, a2);
  sub_1009FABDC((uint64_t *)(a1 + 24), v4);
  return sub_1009FB814((uint64_t)v4);
}

void sub_1009FABC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_1009FABDC(uint64_t *a1, NSObject **a2)
{
  sub_1009FAC60(v4, a2);
  sub_1009FAD28(v5, v4);
  sub_1009FACAC(v5, a1);
  sub_1009FB7C0(v5);
  sub_1009FB814((uint64_t)v4);
  return a1;
}

void sub_1009FAC3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_1009FAC60(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    uint64_t v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

uint64_t *sub_1009FACAC(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_1009FB700((uint64_t)v4, result);
    sub_1009FB700(v3, a2);
    sub_1009FB700((uint64_t)a2, (uint64_t *)v4);
    return sub_1009FB7C0((uint64_t *)v4);
  }
  return result;
}

void sub_1009FAD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1009FAD28(void *a1, NSObject **a2)
{
  sub_1009FAC60(v4, a2);
  sub_1009FAD88(a1, v4);
  sub_1009FB814((uint64_t)v4);
  return a1;
}

void sub_1009FAD74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1009FAD88(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_1009FAC60(v4, a2);
  sub_1009FADE8((uint64_t)a1, v4);
  sub_1009FB814((uint64_t)v4);
  return a1;
}

void sub_1009FADD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1009FADE8(uint64_t a1, NSObject **a2)
{
  sub_1009FAC60(v6, a2);
  int v3 = sub_1009FAF40((uint64_t)off_101A274D0, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_1009FB814((uint64_t)v6);
  if (v3) {
    long long v5 = off_101A274D0;
  }
  else {
    long long v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_1009FAE50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1009FAE64(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_1009FAC60((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_1009FB814(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN24ActivationModelInterface6StatusES4_bEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFvN24ActivationModelInterface6StatusES4_bEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t sub_1009FAF40(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_1009FAC60(v7, a2);
  uint64_t v5 = sub_1009FB6B8(a1, v7, a3);
  sub_1009FB814((uint64_t)v7);
  return v5;
}

void sub_1009FAF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1009FAFA8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1) {
    uint64_t v1 = _Block_copy(v1);
  }
  aBlock = v1;
  sub_1009FB340(v3, &aBlock);
  sub_1009FB060();
}

void sub_1009FB034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, uint64_t a11)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(a1);
}

void sub_1009FB060()
{
}

void sub_1009FB1BC()
{
}

uint64_t sub_1009FB1E0(uint64_t a1)
{
  sub_1009FB2A8(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_1009FB7C0(v2);
    operator delete();
  }
  if (*(void *)(a1 + 40)) {
    operator delete();
  }
  if (*(void *)(a1 + 48)) {
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 56);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1009FB2A8(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_1009FB32C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void *sub_1009FB340(void *a1, void **a2)
{
  int v3 = *a2;
  if (*a2) {
    int v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_1009FB3BC(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1009FB3A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1009FB3BC(void *a1, void **a2)
{
  *a1 = 0;
  int v3 = *a2;
  if (*a2) {
    int v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_1009FB438((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1009FB41C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009FB438(uint64_t a1, void **a2)
{
  int v3 = *a2;
  if (*a2) {
    int v3 = _Block_copy(v3);
  }
  aBlock = v3;
  int v4 = sub_1009FB500((uint64_t)off_101A27510, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    uint64_t v5 = off_101A27510;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_1009FB4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009FB4D0(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_1009FB584(a1, a2, a3);
  }
}

uint64_t sub_1009FB4F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_1009FB500(uint64_t a1, void **a2, void **a3)
{
  uint64_t v5 = *a2;
  if (*a2) {
    uint64_t v5 = _Block_copy(v5);
  }
  aBlock = v5;
  uint64_t v6 = sub_1009FB658(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_1009FB568(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1009FB584(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN24ActivationModelInterface6StatusES2_bEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFvN24ActivationModelInterface6StatusES2_bEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

uint64_t sub_1009FB658(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (int v4 = _Block_copy(*a2), (v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_1009FB6B8(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_1009FAC60(v5, a2);
  sub_1009FAC60(a3, v5);
  sub_1009FB814((uint64_t)v5);
  return 1;
}

uint64_t sub_1009FB700(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    int v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_1009FB79C(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_1009FB7AC(_Unwind_Exception *a1)
{
}

uint64_t *sub_1009FB7C0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      int v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_1009FB814(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1009FB854()
{
}

__n128 sub_1009FB868(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27540;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FB8BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27540;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FB8F4(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  unsigned int v11 = (void **)*v3;
  unsigned int v12 = v5;
  unsigned int v13 = (void *)v3[2];
  if (v13)
  {
    void v5[2] = &v12;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    unsigned int v11 = &v12;
  }
  sub_10008B2E4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  uint64_t v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    void v12[2] = v10;
    unsigned int v11 = &v12;
    unsigned int v12 = 0;
    unsigned int v13 = 0;
  }
  else
  {
    uint64_t v9 = v10;
  }
  v6(v8, &v9);
  sub_100087ED0((uint64_t)&v9, v10[0]);
  sub_100087ED0((uint64_t)&v11, v12);
}

void sub_1009FB9F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_1009FBA1C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FBA5C()
{
}

void sub_1009FBA6C()
{
}

__n128 sub_1009FBA80(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A275C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FBAD4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A275C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FBB0C(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_1009FBBCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FBBE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FBC24()
{
}

void sub_1009FBC34()
{
}

__n128 sub_1009FBC48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27640;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FBC9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FBCD4(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_1009FBD94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FBDAC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FBDEC()
{
}

void sub_1009FBDFC()
{
}

__n128 sub_1009FBE10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A276C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FBE64(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A276C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FBE9C(uint64_t a1, xpc_object_t *a2)
{
  sub_100089CF0(*(uint64_t **)(a1 + 8), a2);
  int v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    int v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_1009FBF18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FBF58()
{
}

void sub_1009FBF68()
{
}

__n128 sub_1009FBF7C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27740;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FBFD0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27740;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FC008(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FC0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FC0E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FC120()
{
}

void sub_1009FC130()
{
}

__n128 sub_1009FC144(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A277C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FC198(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A277C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FC1D0(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031571C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_1009FC290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1009FC2A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FC2E8()
{
}

void sub_1009FC2F8()
{
}

__n128 sub_1009FC30C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27840;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FC360(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27840;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FC398(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_1009FC434(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FC474()
{
}

void sub_1009FC484()
{
}

__n128 sub_1009FC498(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A278C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FC4EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A278C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FC524(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FC5E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FC5FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FC63C()
{
}

void sub_1009FC64C()
{
}

__n128 sub_1009FC660(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27940;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FC6B4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27940;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FC6EC(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  int v5 = (void *)v3[1];
  unsigned int v11 = (void **)*v3;
  unsigned int v12 = v5;
  unsigned int v13 = (void *)v3[2];
  if (v13)
  {
    void v5[2] = &v12;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    unsigned int v11 = &v12;
  }
  sub_10025697C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  uint64_t v9 = v11;
  v10[0] = v12;
  v10[1] = v13;
  if (v13)
  {
    void v12[2] = v10;
    unsigned int v11 = &v12;
    unsigned int v12 = 0;
    unsigned int v13 = 0;
  }
  else
  {
    uint64_t v9 = v10;
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10[0]);
  sub_1000346F8((uint64_t)&v11, v12);
}

void sub_1009FC7E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_1009FC814(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FC854()
{
}

void sub_1009FC864()
{
}

__n128 sub_1009FC878(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A279C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FC8CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A279C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FC904(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 8);
  read_rest_value();
  int v3 = *(uint64_t (**)(void *, uint64_t))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    int v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }

  return v3(v5, v2);
}

uint64_t sub_1009FC988(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FC9C8()
{
}

void sub_1009FC9D8()
{
}

__n128 sub_1009FC9EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27A40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FCA40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27A40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FCA78(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unsigned int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1009FCB70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FCBB0()
{
}

void sub_1009FCBC0()
{
}

__n128 sub_1009FCBD4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27AC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FCC28(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27AC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FCC60(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10031B0B4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FCD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FCD38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FCD78()
{
}

void sub_1009FCD88()
{
}

__n128 sub_1009FCD9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27B40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FCDF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27B40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FCE28(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1005BEA0C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FCEE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FCF00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FCF40()
{
}

void sub_1009FCF50()
{
}

__n128 sub_1009FCF64(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27BC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FCFB8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27BC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FCFF0(void *a1, xpc_object_t *a2)
{
  int v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1000FF5C4((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000886C0((uint64_t)&v9, v10);
}

void sub_1009FD0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1009FD0C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FD108()
{
}

void sub_1009FD118()
{
}

__n128 sub_1009FD12C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A27C40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009FD180(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27C40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FD1B8(void *a1)
{
  *(_OWORD *)uint64_t v25 = 0u;
  long long v26 = 0u;
  memset(v24, 0, sizeof(v24));
  *(_OWORD *)long long v23 = 0u;
  *(_OWORD *)int v21 = 0u;
  memset(v22, 0, sizeof(v22));
  long long v20 = 0u;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)((char *)&v20 + 8));
  v25[0] = 0;
  v25[1] = 0;
  WORD4(v26) = 0;
  *(void *)&long long v26 = 0;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, long long *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, long long *))(*v4 + v2);
  }
  uint64_t v7 = v22[0];
  uint64_t v9 = v22[3];
  uint64_t v10 = v22[4];
  long long v5 = v20;
  *(_OWORD *)uint64_t v6 = *(_OWORD *)v21;
  v21[0] = 0;
  v21[1] = 0;
  *(_OWORD *)uint64_t v8 = *(_OWORD *)&v22[1];
  memset(v22, 0, 32);
  unsigned int v12 = v22[7];
  *(_OWORD *)uint64_t v11 = *(_OWORD *)&v22[5];
  memset(&v22[5], 0, 24);
  uint64_t v14 = *(void *)&v24[0];
  *(_OWORD *)unsigned int v13 = *(_OWORD *)v23;
  v23[0] = 0;
  v23[1] = 0;
  *(void *)&v24[0] = 0;
  char v16 = BYTE8(v24[1]);
  long long v15 = *(_OWORD *)((char *)v24 + 8);
  *(_OWORD *)std::string __p = *(_OWORD *)v25;
  uint64_t v18 = v26;
  v25[0] = 0;
  v25[1] = 0;
  *(void *)&long long v26 = 0;
  __int16 v19 = WORD4(v26);
  v2(v4, &v5);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(v8[0]);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  if (v25[0])
  {
    v25[1] = v25[0];
    operator delete(v25[0]);
  }
  if (SBYTE7(v24[0]) < 0) {
    operator delete(v23[0]);
  }
  if (SHIBYTE(v22[7]) < 0) {
    operator delete(v22[5]);
  }
  if (SHIBYTE(v22[3]) < 0) {
    operator delete(v22[1]);
  }
  if (SHIBYTE(v22[0]) < 0) {
    operator delete(v21[0]);
  }
}

void sub_1009FD3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (__p) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a72) {
    operator delete(a72);
  }
  if (a69 < 0) {
    operator delete(a64);
  }
  if (a63 < 0) {
    operator delete(a58);
  }
  if (a56 < 0) {
    operator delete(a51);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1009FD458(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FD498()
{
}

void sub_1009FD4A8()
{
}

__n128 sub_1009FD4BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A27CC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009FD510(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27CC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FD548(void *a1)
{
  rest::read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void, void))(*v4 + v2);
  }
  return v2(v4, 0, 0);
}

uint64_t sub_1009FD5D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FD610()
{
}

void sub_1009FD620()
{
}

__n128 sub_1009FD634(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27D40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FD688(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27D40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FD6C0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = &v43;
  sub_1007044CC((uint64_t)&v42, a2);
  uint64_t v4 = (void *)(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 8);
  uint64_t v39 = *(uint64_t **)v3;
  uint64_t v40 = (char *)v5;
  uint64_t v41 = *(void *)(v3 + 16);
  if (v41)
  {
    *(void *)(v5 + 16) = &v40;
    *(void *)uint64_t v3 = v4;
    void *v4 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    uint64_t v39 = (uint64_t *)&v40;
  }
  uint64_t v7 = v42;
  uint64_t v6 = v43;
  int v37 = v42;
  v38[0] = v43;
  v38[1] = v44;
  if (v44)
  {
    *((void *)v43 + 2) = v38;
    uint64_t v42 = &v43;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    if (v7 != v38)
    {
      do
      {
        int v54 = 0;
        int v55 = 0;
        uint64_t v56 = 0;
        v57[0] = v7 + 4;
        uint64_t v8 = (std::string **)(sub_10008CC40((uint64_t **)v3, (int *)v7 + 8, (uint64_t)&unk_10144E20E, v57) + 5);
        if (v8 != &v54) {
          sub_10005CA3C((uint64_t)v8, v54, v55, 0xAAAAAAAAAAAAAAABLL * (((char *)v55 - (char *)v54) >> 3));
        }
        uint64_t v10 = (uint64_t)v7[5];
        uint64_t v9 = v7[6];
        while ((char *)v10 != v9)
        {
          uint64_t v53 = 0;
          long long v51 = 0u;
          long long v52 = 0u;
          *(_OWORD *)uint64_t v49 = 0u;
          *(_OWORD *)uint64_t v50 = 0u;
          long long v48 = 0u;
          memset(&v47, 0, sizeof(v47));
          sub_10009DB3C((uint64_t)&v47, v10);
          if (CSIPhoneNumber::getIsEmSMSTextSupported(&v47))
          {
            v57[0] = v7 + 4;
            uint64_t v11 = sub_10008CC40((uint64_t **)v3, (int *)v7 + 8, (uint64_t)&unk_10144E20E, v57);
            CSIPhoneNumber::getFullNumber((uint64_t *)__p, &v47);
            unsigned int v12 = v11[7];
            unsigned int v13 = v11[6];
            if (v13 >= v12)
            {
              long long v15 = v11[5];
              unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (v13 - v15);
              unint64_t v17 = v16 + 1;
              if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
                sub_1000D8578();
              }
              unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (v12 - v15);
              if (2 * v18 > v17) {
                unint64_t v17 = 2 * v18;
              }
              if (v18 >= 0x555555555555555) {
                unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v19 = v17;
              }
              v57[4] = v11 + 7;
              if (v19) {
                long long v20 = sub_10004812C((uint64_t)(v11 + 7), v19);
              }
              else {
                long long v20 = 0;
              }
              int v21 = &v20[6 * v16];
              v57[0] = v20;
              v57[1] = v21;
              v57[3] = &v20[6 * v19];
              long long v22 = *(_OWORD *)__p;
              *((void *)v21 + 2) = v46;
              *(_OWORD *)int v21 = v22;
              __p[1] = 0;
              uint64_t v46 = 0;
              __p[0] = 0;
              v57[2] = v21 + 6;
              sub_100048204((uint64_t *)v11 + 5, v57);
              long long v23 = v11[6];
              sub_100048174((uint64_t)v57);
              int v24 = SHIBYTE(v46);
              v11[6] = v23;
              if (v24 < 0) {
                operator delete(__p[0]);
              }
            }
            else
            {
              long long v14 = *(_OWORD *)__p;
              v13[2] = v46;
              *(_OWORD *)unsigned int v13 = v14;
              v11[6] = v13 + 3;
            }
          }
          if (SHIBYTE(v51) < 0) {
            operator delete(v50[1]);
          }
          if (SHIBYTE(v50[0]) < 0) {
            operator delete(v49[0]);
          }
          if (SBYTE7(v48) < 0) {
            operator delete(*(void **)&v47.var2.__r_.var0);
          }
          if (*((char *)&v47.var2.__r_.__value_.var0.var1 + 23) < 0) {
            operator delete(v47.var2.__r_.__value_.var0.var1.__data_);
          }
          v10 += 136;
        }
        *(void *)&v47.var0 = &v54;
        sub_100047F64((void ***)&v47);
        uint64_t v25 = v7[1];
        if (v25)
        {
          do
          {
            long long v26 = (char **)v25;
            uint64_t v25 = *(char **)v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            long long v26 = (char **)v7[2];
            BOOL v27 = *v26 == (char *)v7;
            uint64_t v7 = v26;
          }
          while (!v27);
        }
        uint64_t v7 = v26;
      }
      while (v26 != v38);
      uint64_t v6 = (char *)v38[0];
    }
  }
  else
  {
    int v37 = (char **)v38;
  }
  sub_1007036B8((uint64_t)&v37, v6);
  if (v41 == *(void *)(v3 + 16))
  {
    long long v28 = v39;
    if (v39 == (uint64_t *)&v40) {
      goto LABEL_60;
    }
    int v29 = *(uint64_t **)v3;
    while ((sub_100704DA4((uint64_t)&v47, (uint64_t)(v28 + 4), (uint64_t)(v29 + 4)) & 1) != 0)
    {
      uint64_t v30 = (uint64_t *)v28[1];
      long long v31 = v28;
      if (v30)
      {
        do
        {
          long long v28 = v30;
          uint64_t v30 = (uint64_t *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          long long v28 = (uint64_t *)v31[2];
          BOOL v27 = *v28 == (void)v31;
          long long v31 = v28;
        }
        while (!v27);
      }
      long long v32 = (uint64_t *)v29[1];
      if (v32)
      {
        do
        {
          int v33 = v32;
          long long v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          int v33 = (uint64_t *)v29[2];
          BOOL v27 = *v33 == (void)v29;
          int v29 = v33;
        }
        while (!v27);
      }
      int v29 = v33;
      if (v28 == (uint64_t *)&v40) {
        goto LABEL_60;
      }
    }
  }
  long long v34 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v35 = a1[4];
  long long v36 = (void *)(a1[2] + (v35 >> 1));
  if (v35) {
    long long v34 = *(void (**)(void *, uint64_t **))(*v36 + v34);
  }
  v34(v36, &v39);
LABEL_60:
  sub_100703778((uint64_t)&v39, v40);
  sub_1007036B8((uint64_t)&v42, v43);
}

void sub_1009FDB00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, char *a17, uint64_t a18, char a19, char *a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
}

uint64_t sub_1009FDBD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FDC10()
{
}

void sub_1009FDC20()
{
}

__n128 sub_1009FDC34(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27DC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FDC88(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27DC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FDCC0(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  rest::read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_1009FDD44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FDD84()
{
}

void sub_1009FDD94()
{
}

__n128 sub_1009FDDA8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27E40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FDDFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27E40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FDE34(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FDEF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FDF0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FDF4C()
{
}

void sub_1009FDF5C()
{
}

void *sub_1009FDF70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A27EC0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FDFB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A27EC0;
  a2[1] = v2;
  return result;
}

void sub_1009FDFE4(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1009FDFEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE02C()
{
}

void sub_1009FE038(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  read_rest_value();
  xpc_release(object);
}

void sub_1009FE094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
}

void sub_1009FE0B4()
{
}

__n128 sub_1009FE0C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A27F40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009FE11C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27F40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FE154(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1009FE19C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE1DC()
{
}

void sub_1009FE1EC()
{
}

__n128 sub_1009FE200(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A27FC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FE254(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A27FC0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FE28C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1005BF770((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10003FB28((uint64_t)&v9, v10);
}

void sub_1009FE34C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FE364(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE3A4()
{
}

void sub_1009FE3B4()
{
}

__n128 sub_1009FE3C8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A28040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1009FE41C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A28040;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1009FE454(void *a1)
{
  uint64_t v6 = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, uint64_t *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_1009FE4D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE514()
{
}

void sub_1009FE524()
{
}

void *sub_1009FE538(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A280C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FE580(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A280C0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1009FE5AC(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  unsigned char *v3 = result;
  return result;
}

uint64_t sub_1009FE5DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE61C()
{
}

void sub_1009FE62C()
{
}

__n128 sub_1009FE640(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A28140;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FE694(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A28140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FE6CC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100026EC0((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FE78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FE7A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE7E4()
{
}

void sub_1009FE7F4()
{
}

__n128 sub_1009FE808(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A281C0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1009FE85C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A281C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1009FE894(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1009FE954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1009FE96C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FE9AC()
{
}

void sub_1009FE9BC()
{
}

void *sub_1009FE9D0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A28240;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FEA18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A28240;
  a2[1] = v2;
  return result;
}

void sub_1009FEA44(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1009FEA4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FEA8C()
{
}

void sub_1009FEA9C()
{
}

void *sub_1009FEAB0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A282C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FEAF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A282C0;
  a2[1] = v2;
  return result;
}

void sub_1009FEB24(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/smsc_address_available");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1009FEBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1009FEC0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FEC4C()
{
}

void sub_1009FEC5C()
{
}

void *sub_1009FEC70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A28340;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FECB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A28340;
  a2[1] = v2;
  return result;
}

void sub_1009FECE4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/service_center_address_fetch_error");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1009FED88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1009FEDCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FEE0C()
{
}

void sub_1009FEE1C()
{
}

void *sub_1009FEE30(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A283C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FEE78(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A283C0;
  a2[1] = v2;
  return result;
}

void sub_1009FEEA4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/sms_online");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1009FEF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1009FEF8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FEFCC()
{
}

void sub_1009FEFDC()
{
}

void *sub_1009FEFF0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A28440;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FF038(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A28440;
  a2[1] = v2;
  return result;
}

void sub_1009FF064(uint64_t a1, double *a2)
{
}

uint64_t sub_1009FF06C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FF0AC()
{
}

void sub_1009FF0B8(uint64_t a1, double *a2)
{
  xpc_object_t v2 = xpc_double_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/prevent_detach_expiry_time");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_1009FF168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void *sub_1009FF1B0(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    char v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1009FF418(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1009FF428()
{
}

void *sub_1009FF43C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A284D0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FF484(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A284D0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1009FF4B0(uint64_t a1, xpc *this)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, (const object *)this, 0.0);
  *uint64_t v2 = v4;
  return result;
}

uint64_t sub_1009FF4E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FF520()
{
}

void sub_1009FF530()
{
}

void *sub_1009FF544(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A28550;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FF58C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A28550;
  a2[1] = v2;
  return result;
}

void sub_1009FF5B8(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1009FF5C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FF600()
{
}

void sub_1009FF610()
{
}

void *sub_1009FF624(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A285D0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FF66C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A285D0;
  a2[1] = v2;
  return result;
}

void sub_1009FF698(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  uint64_t v7 = (void *)*a2;
  char v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v9);
        goto LABEL_16;
      }
      xpc_object_t v10 = xpc_null_create();
LABEL_15:
      xpc_object_t v26 = v10;
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      std::string __p = &v26;
      int v29 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_object_t v14 = xpc_array_create(0, 0);
      if (v14 || (xpc_object_t v14 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v14);
          xpc_object_t v15 = v14;
        }
        else
        {
          xpc_object_t v15 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v15 = xpc_null_create();
        xpc_object_t v14 = 0;
      }
      xpc_release(v14);
      uint64_t v16 = v6[5];
      uint64_t v17 = v6[6];
      while (v16 != v17)
      {
        capabilities::ct::asString();
        ctu::rest::detail::write_enum_string_value();
        if (v30 < 0) {
          operator delete(__p);
        }
        xpc_array_append_value(v15, value);
        xpc_release(value);
        v16 += 4;
      }
      xpc_object_t v23 = v15;
      if (v15) {
        xpc_retain(v15);
      }
      else {
        xpc_object_t v23 = xpc_null_create();
      }
      xpc_release(v15);
      std::string __p = &v26;
      int v29 = "second";
      sub_100035E70((uint64_t)&__p, &v23, &value);
      xpc_release(value);
      xpc_object_t value = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_object_t v18 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v18 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v18);
      xpc_release(v18);
      unint64_t v19 = (void *)v6[1];
      if (v19)
      {
        do
        {
          long long v20 = v19;
          unint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          long long v20 = (void *)v6[2];
          BOOL v21 = *v20 == (void)v6;
          uint64_t v6 = v20;
        }
        while (!v21);
      }
      uint64_t v6 = v20;
    }
    while (v20 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v22 = v4;
  }
  else
  {
    xpc_object_t v22 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/supported_message_modes");
  xpc_object_t value = v22;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    xpc_object_t value = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(value);
  xpc_object_t value = 0;
  if (v30 < 0) {
    operator delete(__p);
  }
  xpc_release(v22);
}

void sub_1009FFA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t a14, xpc_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  xpc_release(object);
  if (a21 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_1009FFB50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FFB90()
{
}

void sub_1009FFBA0()
{
}

void *sub_1009FFBB4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A28660;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FFBFC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A28660;
  a2[1] = v2;
  return result;
}

uint64_t sub_1009FFC28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FFC68()
{
}

uint64_t sub_1009FFC74(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_1009FFCDC()
{
}

void *sub_1009FFCF0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A286E0;
  result[1] = v3;
  return result;
}

uint64_t sub_1009FFD38(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A286E0;
  a2[1] = v2;
  return result;
}

void sub_1009FFD64(uint64_t a1, int *a2)
{
}

uint64_t sub_1009FFD70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1009FFDB0()
{
}

void sub_1009FFDBC()
{
  if (subscriber::isValidSimSlot()) {
    operator new();
  }
  operator delete();
}

void sub_100A005A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v35);
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_10004D2C8(v34);
  operator delete();
}

void sub_100A0074C()
{
}

void sub_100A00758()
{
}

void *sub_100A0076C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A28770;
  result[1] = v3;
  return result;
}

uint64_t sub_100A007B4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A28770;
  a2[1] = v2;
  return result;
}

void sub_100A007E0(uint64_t a1, int *a2)
{
}

uint64_t sub_100A007EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A0082C()
{
}

void sub_100A00838(uint64_t a1, unsigned int a2)
{
  unsigned int v17 = a2;
  uint64_t v3 = (uint64_t **)(a1 + 2544);
  v13[0] = &v17;
  sub_1001B0B78((uint64_t **)(a1 + 2544), (int *)&v17, (uint64_t)&unk_10144E20E, v13);
  MCC::operator=();
  MCC::operator=();
  xpc_object_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v17);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = &v17;
    char v5 = sub_1001B0B78(v3, (int *)&v17, (uint64_t)&unk_10144E20E, v9);
    MCCAndMNC::getMcc((uint64_t *)v13, (MCCAndMNC *)(v5[5] + 49));
    uint64_t v6 = v15;
    MCC::getStringValue((uint64_t *)v15, (MCC *)v13);
    if (v16 < 0) {
      uint64_t v6 = (void **)v15[0];
    }
    xpc_object_t v18 = &v17;
    uint64_t v7 = sub_1001B0B78(v3, (int *)&v17, (uint64_t)&unk_10144E20E, &v18);
    MCCAndMNC::getMnc((uint64_t *)v9, (MCCAndMNC *)(v7[5] + 49));
    MCC::getStringValue((uint64_t *)__p, (MCC *)v9);
    if (v12 >= 0) {
      xpc_object_t v8 = __p;
    }
    else {
      xpc_object_t v8 = (void **)__p[0];
    }
    *(_DWORD *)long long buf = 136643075;
    long long v20 = v6;
    __int16 v21 = 2085;
    xpc_object_t v22 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Device location info :- MCC:%{sensitive}s MNC:%{sensitive}s", buf, 0x16u);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    if (v10 < 0) {
      operator delete(v9[1]);
    }
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    if (v14 < 0) {
      operator delete(v13[1]);
    }
  }
}

void sub_100A00A4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A00AA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A00ADC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A00B0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A00B54(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A00B8C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A00BBC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A00C00(uint64_t a1, uint64_t a2)
{
  if (subscriber::isValidSimSlot())
  {
    xpc_object_t v4 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315394;
      uint64_t v6 = asString();
      __int16 v7 = 2080;
      uint64_t v8 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Operator Bundle changed [%s, %s]", (uint8_t *)&v5, 0x16u);
    }
    (*(void (**)(void))(**(void **)(a1 + 2568) + 8))(*(void *)(a1 + 2568));
    sms::Controller::setupBasebandForCellBroadcast_sync(a1, a2);
  }
}

void sub_100A00D44()
{
}

void *sub_100A00D58(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A288D0;
  result[1] = v3;
  return result;
}

uint64_t sub_100A00DA0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A288D0;
  a2[1] = v2;
  return result;
}

void sub_100A00DCC(uint64_t a1@<X0>, int *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *a2;
  int v22 = *a2;
  xpc_object_t v4 = *(void ***)(a1 + 8);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, (Registry *)v4[10]);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  cf[0] = (CFTypeRef)v7;
  int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)cf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    char v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  char v12 = 0;
  char v14 = 1;
LABEL_9:
  xpc_object_t v15 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(*v4[6] + 16))(v4[6], v3);
  if (v13)
  {
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v13 + 96))(cf, v13, v3, 1, @"CheckSMSonSIM", kCFBooleanFalse, 0);
    char v16 = (BOOL *)cf[0];
    char v23 = 0;
    if (cf[0])
    {
      CFTypeID v17 = CFGetTypeID(cf[0]);
      if (v17 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v23, v16, v18);
        char v16 = (BOOL *)(v23 != 0);
      }
      else
      {
        char v16 = 0;
      }
    }
    sub_1000577C4(cf);
    ((void (*)(void **, BOOL *, uint64_t))(*v4)[33])(v4, v16, v3);
  }
  else
  {
    unint64_t v19 = *v15;
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
    {
      LOWORD(cf[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to get carrierSettings for check SMS on Sim", (uint8_t *)cf, 2u);
    }
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_1009CA87C((uint64_t)v4, v3);
  sub_1009CC01C((uint64_t)v4, v3);
  sub_1009CB71C((uint64_t)v4, v3);
  sub_1009DAF14(v4, v3);
  sub_1009DC120((uint64_t)v4, v3);
  long long v20 = (NSObject **)(*(uint64_t (**)(void *, uint64_t))(*v4[6] + 16))(v4[6], v3);
  cf[0] = &v22;
  if (!*((unsigned char *)sub_1001B0B78(v4 + 318, &v22, (uint64_t)&unk_10144E20E, (_DWORD **)cf)[5] + 269))
  {
    __int16 v21 = *v20;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(cf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Recalculating SMS Ready upon carrier bundle setup", (uint8_t *)cf, 2u);
    }
    sub_1009E1038((uint64_t)v4, v22);
  }
}

void sub_100A010DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A01114(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A01154()
{
}

void *sub_100A01160(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v13 = 136315394;
    *(void *)&v13[4] = asString();
    *(_WORD *)&v13[12] = 2080;
    *(void *)&v13[14] = asString();
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Handling Carrier bundle change : change:%s technology:%s", v13, 0x16u);
  }
  unsigned int v7 = *a3;
  BOOL v8 = v7 > 5;
  int v9 = (1 << v7) & 0x2C;
  if (!v8 && v9 != 0)
  {
    int v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Purging MO messages due to bundle change", v13, 2u);
    }
    sub_1009CFF20(a1, 1);
  }
  *(void *)uint64_t v13 = off_101A288D0;
  *(void *)&v13[8] = a1;
  char v14 = v13;
  sub_1009E3B40(a1, a2, (uint64_t)v13);
  return sub_1008FDE68(v13);
}

void sub_100A01300(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100A0131C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    xpc_object_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **(unsigned int **)(v1 + 8));
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received a call to check if Service Center Address is Available", v5, 2u);
    }
    return sub_1009E4324(v2, **(_DWORD **)(v1 + 8));
  }
  return result;
}

uint64_t sub_100A013DC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100A01420(uint64_t *a1, uint64_t a2)
{
  long long v24 = 0uLL;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  xpc_object_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v27, v4);
  uint64_t v5 = a1[1];
  if (v5)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) == 1) {
      sub_100A01694(a1, &v27, 0, 1);
    }
    uint64_t v6 = *a1;
    uint64_t v7 = a1[1];
    if (v7) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = *a1;
  }
  long long v8 = v24;
  *(void *)&long long v24 = v6;
  *((void *)&v24 + 1) = v7;
  v26[0] = v8;
  sub_10000A740((atomic_uint **)v26 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v38 + 1));
  sub_10000A5F8(&v27);
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  uint64_t v42 = 0;
  uint64_t v43 = 10;
  uint64_t v44 = (char *)&v27 + 8;
  uint64_t v45 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = a2;
  int v9 = (uint64_t *)sub_1008E3394((uint64_t *)&v24);
  v23[0] = &v27;
  v23[1] = a1;
  v23[2] = sub_1008E396C(v9);
  uint64_t v10 = sub_1008E3394((uint64_t *)&v24);
  uint64_t v11 = sub_100060EA8((uint64_t *)(v10 + 16));
  char v12 = (uint64_t *)sub_1008E3394((uint64_t *)&v24);
  uint64_t v13 = *(void *)(sub_1008E396C(v12) + 8);
  char v14 = (uint64_t *)sub_1008E3394((uint64_t *)&v24);
  *(void *)&long long v21 = v13;
  *((void *)&v21 + 1) = sub_1008E396C(v14);
  *(void *)&long long v22 = &v27;
  *((void *)&v22 + 1) = *((void *)&v21 + 1);
  sub_100A01B90((uint64_t *)&v21);
  xpc_object_t v15 = (uint64_t *)sub_1008E3394((uint64_t *)&v24);
  uint64_t v16 = sub_1008E396C(v15);
  CFTypeID v17 = (uint64_t *)sub_1008E3394((uint64_t *)&v24);
  *(void *)&long long v19 = v16;
  *((void *)&v19 + 1) = sub_1008E396C(v17);
  *(void *)&long long v20 = &v27;
  *((void *)&v20 + 1) = *((void *)&v19 + 1);
  sub_100A01B90((uint64_t *)&v19);
  v26[0] = v21;
  v26[1] = v22;
  v25[0] = v19;
  v25[1] = v20;
  sub_100A01974(v11, (uint64_t *)v26, v25);
  sub_100A01F50((uint64_t)v23);
  sub_100A02294((uint64_t)&v27);
  return sub_10000A740((atomic_uint **)&v24 + 1);
}

void sub_100A01640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t *sub_100A01694(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  int v9 = (uint64_t *)sub_1008E3394(a1);
  uint64_t v10 = sub_1008E396C(v9);
  uint64_t v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    char v12 = (uint64_t *)sub_1008E3394(a1);
    uint64_t v11 = *(uint64_t **)(sub_1008E396C(v12) + 8);
  }
  char v14 = v11;
  return sub_100A01748(a1, a2, a3, &v14, a4);
}

uint64_t *sub_100A01748(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_1008E3394(a1);
  uint64_t result = (uint64_t *)sub_1008E396C(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100A01884(result + 2);
        sub_100A018C8(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100A01884(result + 2) + 24))
      {
        xpc_object_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_1008E3394(a1);
        uint64_t v17 = sub_1008E396C(v16);
        uint64_t v18 = sub_100A01884(v22 + 2);
        xpc_object_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      long long v19 = (uint64_t *)sub_1008E3394(a1);
      long long v20 = (uint64_t *)sub_1008E396C(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t sub_100A01884(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100A018C8(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_100A01930(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100A01930(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100A01974(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_100A019F4(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_100A01B90(a2);
    uint64_t v5 = (unsigned char *)a2[2];
    if (*v5) {
      unsigned char *v5 = 0;
    }
  }
}

unsigned char *sub_100A019F4(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_100A01AB0((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      *uint64_t v2 = 1;
    }
  }
  uint64_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_100A01AB0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_100A01884(a2);
  uint64_t v3 = (void *)(sub_100A01930((uint64_t *)(v2 + 32)) + 24);

  return sub_100A01AF8(v3);
}

uint64_t sub_100A01AF8(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100A01B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100A01B90(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      uint64_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_100A01DEC(v3);
      sub_10000A4EC(&v15, v4);
      uint64_t v5 = (atomic_uint **)sub_100A01884((uint64_t *)(*a1 + 16));
      sub_100A01E30(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_100A01884((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 280);
      }
      else {
        ++*(_DWORD *)(v7 + 284);
      }
      uint64_t v8 = sub_100A01884((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1001AB328(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_100A01DEC((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1001AB328(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_100A01DB0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A01DEC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100A01E30(atomic_uint **result, void *a2, void *a3)
{
  uint64_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_100A01930((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100A01930(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_100A01F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A01F50(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 284) > *(_DWORD *)(*(void *)a1 + 280)) {
    sub_100A01F94(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_100A01F94(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  uint64_t v5 = (uint64_t *)sub_1008E3394(a1);
  if (sub_1008E396C(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_1008E3394(a1);
    uint64_t v8 = *(uint64_t **)(sub_1008E396C(v7) + 8);
    sub_100A01748(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_100A020E0()
{
}

void sub_100A02134(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_1008E37D4(&v2, a2);
}

uint64_t sub_100A021B0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100A021F4()
{
}

void sub_100A02270()
{
}

uint64_t sub_100A02294(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 288);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 288), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100A02368(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A02388(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A023EC(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A02450(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t result = subscriber::isValidSimSlot();
  if (result)
  {
    uint64_t v4 = *(void *)(v1 + 16);
    unsigned int v5 = **(_DWORD **)(v1 + 8);
    return sub_1009E4EF4(v2, v4, v5);
  }
  return result;
}

uint64_t sub_100A024AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  if (!subscriber::isValidSimSlot()) {
    return 300;
  }
  uint64_t v3 = **(unsigned int **)(v1 + 8);

  return sub_1009E5214(v2, v3);
}

uint64_t sub_100A0250C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100A02548(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

void *sub_100A02584(void *a1)
{
  *a1 = off_101A289F0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100A025D0(void *a1)
{
  *a1 = off_101A289F0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

char *sub_100A0263C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A289F0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A026A0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A289F0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A026E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100A026F0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_100A02730(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  int v4 = *a2;
  uint64_t v5 = *a3;
  long long v34 = *(_OWORD *)(a3 + 1);
  uint64_t v6 = a3[3];
  uint64_t v33 = v5;
  uint64_t v35 = v6;
  a3[1] = 0;
  a3[2] = 0;
  long long v36 = *((_OWORD *)a3 + 2);
  a3[3] = 0;
  a3[4] = 0;
  uint64_t v7 = a3[6];
  uint64_t v8 = a3[7];
  a3[5] = 0;
  a3[6] = 0;
  uint64_t v37 = v7;
  uint64_t v38 = v8;
  uint64_t v9 = a3[10];
  long long v39 = *((_OWORD *)a3 + 4);
  a3[8] = 0;
  a3[9] = 0;
  long long v10 = *(_OWORD *)(a3 + 11);
  uint64_t v11 = a3[13];
  uint64_t v40 = v9;
  uint64_t v42 = v11;
  long long v41 = v10;
  a3[10] = 0;
  a3[11] = 0;
  a3[12] = 0;
  a3[13] = 0;
  long long v12 = *((_OWORD *)a3 + 7);
  char v44 = *((unsigned char *)a3 + 128);
  long long v43 = v12;
  uint64_t v21 = *a4;
  long long v13 = *(_OWORD *)(a4 + 1);
  uint64_t v23 = a4[3];
  *(_OWORD *)long long v22 = v13;
  a4[1] = 0;
  a4[2] = 0;
  *(_OWORD *)long long v24 = *((_OWORD *)a4 + 2);
  a4[3] = 0;
  a4[4] = 0;
  uint64_t v14 = a4[6];
  uint64_t v15 = a4[7];
  a4[5] = 0;
  a4[6] = 0;
  uint64_t v25 = v14;
  uint64_t v26 = v15;
  long long v16 = *((_OWORD *)a4 + 4);
  uint64_t v28 = a4[10];
  *(_OWORD *)long long v27 = v16;
  a4[8] = 0;
  a4[9] = 0;
  long long v17 = *(_OWORD *)(a4 + 11);
  uint64_t v30 = a4[13];
  *(_OWORD *)std::string __p = v17;
  a4[10] = 0;
  a4[11] = 0;
  a4[12] = 0;
  a4[13] = 0;
  long long v18 = *((_OWORD *)a4 + 7);
  char v32 = *((unsigned char *)a4 + 128);
  long long v31 = v18;
  long long v20 = *(_OWORD *)(a1 + 8);
  long long v45 = v20;
  uint64_t v19 = *(void *)(a1 + 24);
  uint64_t v46 = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  int v47 = v4;
  sub_10009DB3C((uint64_t)&v48, (uint64_t)&v33);
  sub_10009DB3C((uint64_t)&v49, (uint64_t)&v21);
  v50[0] = 0;
  v50[1] = 0;
  sub_10003E168(v50, (void *)(v20 + 8));
  operator new();
}

void sub_100A02AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,void *a60,uint64_t a61,int a62,__int16 a63)
{
  if (a79 < 0) {
    operator delete(__p);
  }
  if (a77 < 0) {
    operator delete(a76);
  }
  if (a75 < 0) {
    operator delete(a74);
  }
  if (a73 < 0) {
    operator delete(a72);
  }
  if (a71) {
    sub_10004D2C8(a71);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a65 < 0) {
    operator delete(a60);
  }
  if (a59 < 0) {
    operator delete(a54);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A02BC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A02C04()
{
}

uint64_t sub_100A02C10(uint64_t a1)
{
  if (*(char *)(a1 + 279) < 0) {
    operator delete(*(void **)(a1 + 256));
  }
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t *sub_100A02CC0(int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v26 = a1;
  long long v27 = v1;
  uint64_t v2 = v1[6];
  uint64_t v3 = *(void *)v1;
  int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(*((void *)v1 + 1) + 152));
  uint64_t v5 = v4;
  if (v2 > 2) {
    uint64_t v6 = "Unknown";
  }
  else {
    uint64_t v6 = off_101A28DF0[v2];
  }
  uint64_t v7 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I UICC Call Control Result for SMS - %s", (uint8_t *)&buf, 0xCu);
  }
  if (v2 == 2)
  {
    memset(&buf, 0, sizeof(buf));
    CSIPhoneNumber::getBaseNumber((uint64_t *)&buf, (CSIPhoneNumber *)(v1 + 8));
    std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
    int v13 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = buf.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      uint64_t v14 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *((void *)v1 + 1);
        long long v16 = (void *)(v15 + 40);
        if (*(char *)(v15 + 63) < 0) {
          long long v16 = (void *)*v16;
        }
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        if (v13 >= 0) {
          p_std::string buf = &buf;
        }
        LODWORD(v32.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
        WORD2(v32.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v32.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I UICC Call Control modified destination number from %s to %s", (uint8_t *)&v32, 0x16u);
      }
      std::string::operator=((std::string *)(*((void *)v1 + 1) + 40), &buf);
    }
    memset(&v32, 0, sizeof(v32));
    CSIPhoneNumber::getBaseNumber((uint64_t *)&v32, (CSIPhoneNumber *)(v1 + 42));
    std::string::size_type v18 = HIBYTE(v32.__r_.__value_.__r.__words[2]);
    int v19 = SHIBYTE(v32.__r_.__value_.__r.__words[2]);
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v18 = v32.__r_.__value_.__l.__size_;
    }
    if (v18)
    {
      long long v20 = *v5;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *((void *)v1 + 1);
        long long v22 = (void *)(v21 + 64);
        if (*(char *)(v21 + 87) < 0) {
          long long v22 = (void *)*v22;
        }
        uint64_t v23 = (std::string *)v32.__r_.__value_.__r.__words[0];
        if (v19 >= 0) {
          uint64_t v23 = &v32;
        }
        *(_DWORD *)uint64_t v28 = 136315394;
        long long v29 = v22;
        __int16 v30 = 2080;
        long long v31 = v23;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I UICC Call Control modified service center number from %s to %s", v28, 0x16u);
      }
      std::string::operator=((std::string *)(*((void *)v1 + 1) + 64), &v32);
      LOBYTE(v19) = *((unsigned char *)&v32.__r_.__value_.__s + 23);
    }
    if ((v19 & 0x80) != 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
  else if (v2 == 1)
  {
    uint64_t v8 = *v5;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "UICC Call Control rejected SMS, bailing", (uint8_t *)&buf, 2u);
    }
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 0;
    *(_WORD *)((char *)&buf.__r_.__value_.__r.__words[2] + 5) = 0;
    uint64_t v9 = *((void *)v1 + 1);
    uint64_t v10 = *(void *)(v9 + 136);
    int v11 = *(_DWORD *)(v9 + 152);
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = *(_DWORD *)(v9 + 96);
    LODWORD(buf.__r_.__value_.__r.__words[1]) = v11;
    LODWORD(buf.__r_.__value_.__l.__data_) = 1;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 4) = 54;
    buf.__r_.__value_.__s.__data_[20] = 1;
    int v34 = 5;
    (*(void (**)(uint64_t, uint64_t, std::string *))(*(void *)v10 + 16))(v10, v3 + 80, &buf);
    goto LABEL_40;
  }
  long long v24 = (std::__shared_weak_count *)*((void *)v1 + 2);
  buf.__r_.__value_.__r.__words[0] = *((void *)v1 + 1);
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v24;
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1009CE3AC(v3, (long long *)&buf);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_1009CE628(v3, *(_DWORD *)(*((void *)v1 + 1) + 152));
LABEL_40:
  sub_100A030C0((uint64_t *)&v27);
  return sub_100046B58((uint64_t *)&v26);
}

void sub_100A0305C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  sub_100A030C0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A030C0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_100A02C10(v2);
    operator delete();
  }
  return a1;
}

void sub_100A03108(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A28A80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A03128(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A28A80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A0317C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100A031A8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A031E0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A03210(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A03254(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A28B48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A03274(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A28B48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A032C8(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100A032F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A0332C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A0335C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A033A0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_100A03404(void ****a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (int *)(*a1 + 1);
  uint64_t v3 = **a1;
  int v4 = (os_log_t *)(*(uint64_t (**)(void *, void))(*v3[6] + 16))(v3[6], *v2);
  uint64_t v5 = v3 + 318;
  *(void *)std::string buf = v2;
  if (*((unsigned char *)sub_1001B0B78(v3 + 318, v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 269))
  {
    os_log_t v6 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_19;
    }
    *(void *)std::string buf = v2;
    uint64_t v7 = sub_1001B0B78(v5, v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
    uint64_t v8 = "[ready]";
    if (!*((unsigned char *)v7[5] + 269)) {
      uint64_t v8 = "[not-ready]";
    }
    if (*((unsigned char *)v1 + 12)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v9;
    uint64_t v10 = "#I SMS %s - potential 2G location: %s";
    int v11 = v6;
    uint32_t v12 = 22;
    goto LABEL_9;
  }
  int v13 = *((unsigned __int8 *)v1 + 12);
  uint64_t v14 = *v4;
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v15)
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = "[ready]";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I SMS pseudo-%s -(in potential 2G location)", buf, 0xCu);
    }
    *(void *)std::string buf = 1;
    *(void *)&uint8_t buf[8] = v3 + 270;
    long long v17 = v2;
    *((unsigned char *)sub_10005CE78(v3 + 274, v2, (uint64_t)&unk_10144E20E, &v17) + 32) = 1;
    (*(void (**)(void *, void, uint64_t))(*v3[316] + 48))(v3[316], *v2, 1);
    sub_1009EA1AC((uint64_t)v3, *v2);
    sub_100A033A0((uint64_t)buf);
  }
  else if (v15)
  {
    *(void *)std::string buf = v2;
    if (*((unsigned char *)sub_1001B0B78(v3 + 318, v2, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 269)) {
      long long v16 = "[ready]";
    }
    else {
      long long v16 = "[not-ready]";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    uint64_t v10 = "#I SMS %s - in lockdown (no update required)";
    int v11 = v14;
    uint32_t v12 = 12;
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
  }
LABEL_19:
  operator delete();
}

void sub_100A036F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100A033A0((uint64_t)va);
  operator delete();
}

void *sub_100A0372C(void *a1)
{
  *a1 = off_101A28C00;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A03778(void *a1)
{
  *a1 = off_101A28C00;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100A037E4(uint64_t a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A28C00;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = *(void *)(a1 + 24);
  *((_DWORD *)result + 8) = *(_DWORD *)(a1 + 32);
  return result;
}

uint64_t sub_100A03850(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A28C00;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(result + 32);
  *(void *)(a2 + 24) = v4;
  return result;
}

void sub_100A03898(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A038A8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A038E8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[3];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[1])
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100A03A04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A03A44()
{
}

void sub_100A03A50(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 2640);
  *(void *)(v1 + 2640) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1009EABF4(v1);
}

void *sub_100A03AE0(void *a1)
{
  *a1 = off_101A28C80;
  sub_1008FDE68(a1 + 3);
  return a1;
}

void sub_100A03B24(void *a1)
{
  *a1 = off_101A28C80;
  sub_1008FDE68(a1 + 3);

  operator delete();
}

char *sub_100A03B88(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = off_101A28C80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  sub_10090994C((uint64_t)(v2 + 24), a1 + 24);
  return v2;
}

void sub_100A03BE8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A03BFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A28C80;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return sub_10090994C(a2 + 24, a1 + 24);
}

void *sub_100A03C30(uint64_t a1)
{
  return sub_1008FDE68((void *)(a1 + 24));
}

void sub_100A03C38(void *a1)
{
  sub_1008FDE68(a1 + 3);

  operator delete(a1);
}

void *sub_100A03C74(uint64_t a1, char *a2)
{
  char v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 16);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  v10[2] = sub_100A03E28;
  v10[3] = &unk_101A28CE0;
  v10[4] = v3;
  int v12 = *(_DWORD *)(a1 + 8);
  char v13 = v2;
  sub_10090994C((uint64_t)v11, a1 + 24);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  sub_10003E168(&v8, (void *)(v3 + 8));
  uint64_t v4 = *(NSObject **)(v3 + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 1174405120;
  void v6[2] = sub_1009EE930;
  void v6[3] = &unk_101A25358;
  v6[5] = v8;
  uint64_t v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v6[4] = v10;
  dispatch_async(v4, v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return sub_1008FDE68(v11);
}

void sub_100A03DD0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A03DDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A03E1C()
{
}

uint64_t sub_100A03E28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (uint64_t **)(v2 + 2544);
  uint64_t v4 = (int *)(a1 + 72);
  *(void *)std::string buf = a1 + 72;
  if (*((unsigned __int8 *)sub_1001B0B78((uint64_t **)(v2 + 2544), (int *)(a1 + 72), (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5]+ 40) != *(unsigned __int8 *)(a1 + 76))
  {
    uint64_t v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)std::string buf = v4;
      os_log_t v6 = sub_1001B0B78(v3, v4, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      uint64_t v7 = "true";
      if (*((unsigned char *)v6[5] + 40)) {
        uint64_t v8 = "true";
      }
      else {
        uint64_t v8 = "false";
      }
      if (!*(unsigned char *)(a1 + 76)) {
        uint64_t v7 = "false";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v8;
      __int16 v12 = 2080;
      char v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Device Customer Ready changing from :- %s to %s", buf, 0x16u);
    }
  }
  char v9 = *(unsigned char *)(a1 + 76);
  *(void *)std::string buf = v4;
  *((unsigned char *)sub_1001B0B78(v3, v4, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5] + 40) = v9;
  return sub_1008FBA74(a1 + 40, *(_DWORD *)(a1 + 72));
}

uint64_t sub_100A03FC8(uint64_t a1, uint64_t a2)
{
  return sub_10090994C(a1 + 40, a2 + 40);
}

void *sub_100A03FD4(uint64_t a1)
{
  return sub_1008FDE68((void *)(a1 + 40));
}

uint64_t sub_100A03FDC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t result = subscriber::isValidSimSlot();
  if (result) {
    return *((unsigned char *)sub_1001B0B78((uint64_t **)(v2 + 2544), (int *)v1[1], (uint64_t)&unk_10144E20E, &v4)[5] + 269) != 0;
  }
  return result;
}

uint64_t sub_100A04048(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t result = subscriber::isValidSimSlot();
  if (result) {
    return *((unsigned char *)sub_1001B0B78((uint64_t **)(v2 + 2544), (int *)v1[1], (uint64_t)&unk_10144E20E, &v4)[5] + 271) != 0;
  }
  return result;
}

BOOL sub_100A040B4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  uint64_t v2 = *v1;
  BOOL result = 1;
  if (*(_DWORD *)(*v1 + 2604) == 1)
  {
    uint64_t v4 = (int *)v1[1];
    if (*((unsigned char *)sub_1001B0B78((uint64_t **)(v2 + 2544), v4, (uint64_t)&unk_10144E20E, &v4)[5] + 270))
    {
      uint64_t v4 = (int *)v1[1];
      if (*((unsigned char *)sub_1001B0B78((uint64_t **)(v2 + 2544), v4, (uint64_t)&unk_10144E20E, &v4)[5] + 42))
      {
        if (*(unsigned char *)(v2 + 200)) {
          return 0;
        }
      }
    }
  }
  return result;
}

void sub_100A04164(uint64_t a1)
{
}

void sub_100A0417C()
{
  if ((byte_101B0F740 & 1) == 0)
  {
    byte_101B0F740 = 1;
    sub_1009EB7E0();
  }
}

void sub_100A04198()
{
  if ((byte_101B0F748 & 1) == 0)
  {
    byte_101B0F748 = 1;
    sub_1009EB8AC();
  }
}

void sub_100A041B4()
{
  if ((byte_101B0F750 & 1) == 0)
  {
    byte_101B0F750 = 1;
    sub_1009EB978();
  }
}

void sub_100A041D0()
{
  if ((byte_101B0F758 & 1) == 0)
  {
    byte_101B0F758 = 1;
    sub_1009EBA44();
  }
}

void sub_100A041EC()
{
  if ((byte_101B0F760 & 1) == 0)
  {
    byte_101B0F760 = 1;
    sub_1009EBB10();
  }
}

void sub_100A04208()
{
  if ((byte_101B0F768 & 1) == 0)
  {
    byte_101B0F768 = 1;
    sub_1009EBBDC();
  }
}

void sub_100A04224()
{
  if ((byte_101B0F770 & 1) == 0)
  {
    byte_101B0F770 = 1;
    sub_1009EBCA8();
  }
}

void sub_100A04240()
{
  if ((byte_101B0F778 & 1) == 0)
  {
    byte_101B0F778 = 1;
    sub_1009EBD74();
  }
}

void sub_100A0425C()
{
  if ((byte_101B0F780 & 1) == 0)
  {
    byte_101B0F780 = 1;
    sub_1009EBE40();
  }
}

void sub_100A04278()
{
  if ((byte_101B0F788 & 1) == 0)
  {
    byte_101B0F788 = 1;
    sub_1009EBF0C();
  }
}

void sub_100A04294()
{
  if ((byte_101B0F790 & 1) == 0)
  {
    byte_101B0F790 = 1;
    sub_1009EBFD8();
  }
}

void sub_100A042B0()
{
  if ((byte_101B0F798 & 1) == 0)
  {
    byte_101B0F798 = 1;
    sub_1009EC0A4();
  }
}

void sub_100A042CC()
{
  if ((byte_101B0F7A0 & 1) == 0)
  {
    byte_101B0F7A0 = 1;
    sub_1009EC170();
  }
}

void sub_100A042E8()
{
  if ((byte_101B0F7A8 & 1) == 0)
  {
    byte_101B0F7A8 = 1;
    sub_1009EC23C();
  }
}

void sub_100A04304()
{
  if ((byte_101B0F7B0 & 1) == 0)
  {
    byte_101B0F7B0 = 1;
    sub_1009EC308();
  }
}

void sub_100A04320()
{
  if ((byte_101B0F7B8 & 1) == 0)
  {
    byte_101B0F7B8 = 1;
    sub_1009EC3D4();
  }
}

void sub_100A0433C()
{
  if ((byte_101B0F7C0 & 1) == 0)
  {
    byte_101B0F7C0 = 1;
    sub_1009EC4A0();
  }
}

void sub_100A04358()
{
  if ((byte_101B0F7C8 & 1) == 0)
  {
    byte_101B0F7C8 = 1;
    sub_1009EC56C();
  }
}

void sub_100A04374()
{
  if ((byte_101B0F7D0 & 1) == 0)
  {
    byte_101B0F7D0 = 1;
    sub_1009EC638();
  }
}

void sub_100A04390()
{
  if ((byte_101B0F7D8 & 1) == 0)
  {
    byte_101B0F7D8 = 1;
    sub_1009EC704();
  }
}

void sub_100A043AC()
{
  if ((byte_101B0F7E0 & 1) == 0)
  {
    byte_101B0F7E0 = 1;
    sub_1009EC7D0();
  }
}

void sub_100A043C8()
{
  if ((byte_101B0F7E8 & 1) == 0)
  {
    byte_101B0F7E8 = 1;
    sub_1009EC89C();
  }
}

void sub_100A043E4()
{
  if ((byte_101B0F7F0 & 1) == 0)
  {
    byte_101B0F7F0 = 1;
    sub_1009EC968();
  }
}

void sub_100A04400()
{
  if ((byte_101B0F7F8 & 1) == 0)
  {
    byte_101B0F7F8 = 1;
    sub_1009ECA34();
  }
}

void sub_100A0441C()
{
  if ((byte_101B0F800 & 1) == 0)
  {
    byte_101B0F800 = 1;
    sub_1009ECB00();
  }
}

void sub_100A04438()
{
  if ((byte_101B0F808 & 1) == 0)
  {
    byte_101B0F808 = 1;
    sub_1009ECBCC();
  }
}

void sub_100A04454()
{
  if ((byte_101B0F810 & 1) == 0)
  {
    byte_101B0F810 = 1;
    sub_1009ECC98();
  }
}

void sub_100A04470()
{
  if ((byte_101B0F818 & 1) == 0)
  {
    byte_101B0F818 = 1;
    sub_1009ECD64();
  }
}

void sub_100A0448C()
{
  if ((byte_101B0F820 & 1) == 0)
  {
    byte_101B0F820 = 1;
    sub_1009ECE30();
  }
}

void sub_100A044A8()
{
  if ((byte_101B0F828 & 1) == 0)
  {
    byte_101B0F828 = 1;
    sub_1009ECEFC();
  }
}

void sub_100A044C4()
{
  if ((byte_101B0F830 & 1) == 0)
  {
    byte_101B0F830 = 1;
    sub_1009ECFC8();
  }
}

void sub_100A044E0(void *a1)
{
  sub_10003E168(&v2, a1);
  uint64_t v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A045BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A045E0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 0x40000000;
        void v7[2] = sub_100A0471C;
        v7[3] = &unk_101A28E08;
        void v7[4] = v3;
        uint64_t v10 = 0;
        int v11 = 0;
        sub_10003E168(&v10, v3);
        os_log_t v6 = v3[2];
        block[0] = _NSConcreteStackBlock;
        block[1] = 1174405120;
        block[2] = sub_100A04B38;
        block[3] = &unk_101A28E80;
        block[5] = v10;
        char v9 = v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        block[4] = v7;
        dispatch_async(v6, block);
        if (v9) {
          sub_10004D2C8(v9);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_100A0471C()
{
  return sub_100A04794((wis::MetricFactory *)0x80105);
}

uint64_t sub_100A04794(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    os_log_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100A048F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100A04974(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(v3 + 168);
  if ((v4 - 1) >= 3) {
    int v4 = 0;
  }
  a2[12] |= 2u;
  a2[10] = v4;
  (*(void (**)(_DWORD **__return_ptr))(**(void **)(v3 + 72) + 40))(&v16);
  uint64_t v5 = v16;
  os_log_t v6 = v17;
  if (v16 != v17)
  {
    do
    {
      int v8 = *v5;
      int v7 = v5[1];
      int v9 = a2[7];
      uint64_t v10 = a2[6];
      if ((int)v10 >= v9)
      {
        if (v9 == a2[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4), v9 + 1);
          int v9 = a2[7];
        }
        a2[7] = v9 + 1;
        operator new();
      }
      uint64_t v11 = *((void *)a2 + 2);
      a2[6] = v10 + 1;
      __int16 v12 = *(_DWORD **)(v11 + 8 * v10);
      if ((v8 - 1) >= 3) {
        int v13 = 0;
      }
      else {
        int v13 = v8;
      }
      int v14 = v12[11];
      v12[11] = v14 | 2;
      v12[3] = v13;
      if ((v7 - 1) > 2) {
        int v15 = 1;
      }
      else {
        int v15 = dword_1015252E4[v7 - 1];
      }
      v12[11] = v14 | 3;
      void v12[2] = v15;
      v5 += 2;
    }
    while (v5 != v6);
    uint64_t v5 = v16;
  }
  if (v5)
  {
    long long v17 = v5;
    operator delete(v5);
  }
}

void sub_100A04AFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

uint64_t sub_100A04B38(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100A04B48(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A04B64(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100A04B74(void (****a1)(Registry **__return_ptr)@<X2>, void *a2@<X8>)
{
  long long v20 = 0;
  uint64_t v21 = 0;
  (***a1)(&v20);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20);
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    os_log_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_10:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_7;
    }
    goto LABEL_11;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11)
  {
LABEL_7:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "cp.bs.prov");
    int v13 = __p[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    LOWORD(__p[0]) = 0;
    int v14 = "no gestalt service found";
    goto LABEL_25;
  }
LABEL_11:
  int v15 = (capabilities::ct *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 72))(v11);
  if (v15)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "cp.bs.prov");
    int v13 = __p[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    LOWORD(__p[0]) = 0;
    int v14 = "Bootstrap provisioning not supported for this device";
    goto LABEL_25;
  }
  long long v16 = (capabilities::ct *)capabilities::ct::dataOnlySingleSIMDevice(v15);
  if (v16)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "cp.bs.prov");
    int v13 = __p[1];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_26;
    }
    LOWORD(__p[0]) = 0;
    int v14 = "Bootstrap provisioning not supported for eonly device";
    goto LABEL_25;
  }
  long long v17 = v21;
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v18 = capabilities::ct::bootstrapProvisioningSupportedOnSlotID(v16);
  int v19 = VinylSlotIdFromInt(v18);
  if (v17) {
    sub_10004D2C8(v17);
  }
  if ((v19 - 1) <= 1) {
    operator new();
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)__p, kCtLoggingSystemName, "cp.bs.prov");
  int v13 = __p[1];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)__p);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    int v14 = "Bootstrap provisioning not supported";
LABEL_25:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)__p, 2u);
  }
LABEL_26:
  *a2 = 0;
  a2[1] = 0;
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
}

void sub_100A05100(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100A0673C);
  __cxa_rethrow();
}

void sub_100A05128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, std::__shared_weak_count *a12, dispatch_object_t object, dispatch_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  __cxa_end_catch();
  if (v23)
  {
    sub_10004D2C8(v23);
    if (!v22)
    {
LABEL_3:
      if (!v21) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
  }
  else if (!v22)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_weak(v22);
  if (!v21)
  {
LABEL_8:
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    if (a12) {
      sub_10004D2C8(a12);
    }
    _Unwind_Resume(a1);
  }
LABEL_7:
  dispatch_release(v21);
  goto LABEL_8;
}

void sub_100A05264(capabilities::ct *a1)
{
  if (*((void *)a1 + 14) != *((void *)a1 + 15))
  {
    uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 11);
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v3 = capabilities::ct::bootstrapProvisioningSupportedOnSlotID(a1);
    int v4 = VinylSlotIdFromInt(v3);
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v5 = *((void *)a1 + 14);
    uint64_t v6 = *((void *)a1 + 15);
    if (v5 != v6)
    {
      while (*(_DWORD *)(v5 + 4) != v4)
      {
        v5 += 88;
        if (v5 == v6) {
          goto LABEL_14;
        }
      }
    }
    if (v5 == v6)
    {
LABEL_14:
      uint64_t v7 = *((void *)a1 + 5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v8 = 136315138;
        uint64_t v9 = subscriber::asString();
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Slot (%s) not found in vinyl info", (uint8_t *)&v8, 0xCu);
      }
    }
    else
    {
      sub_100A05DC8((uint64_t)a1, v5);
    }
  }
}

void sub_100A053BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A053D4(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 136) & 0xFFFFFFFE) == 2 && !*(unsigned char *)(a1 + 151))
  {
    *(unsigned char *)(a1 + 151) = 1;
    sub_100A05E2C(a1);
  }
}

void sub_100A053FC(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 != *(unsigned __int8 *)(a1 + 140)) {
    sub_100A05E2C(a1);
  }
}

void sub_100A05414(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = *(_DWORD *)(a1 + 144) - 1;
    if (v3 > 5) {
      int v4 = "kBootstrapProvisioningNotSupported";
    }
    else {
      int v4 = off_101A29218[v3];
    }
    int v11 = 136315138;
    *(void *)char v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I fState: %s", (uint8_t *)&v11, 0xCu);
  }
  if (*(_DWORD *)(a1 + 144) != 5)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(unsigned __int8 *)(a1 + 148);
      uint64_t v7 = asString();
      uint64_t v8 = *(void *)(a1 + 152);
      int v9 = *(_DWORD *)(a1 + 160);
      int v10 = *(unsigned __int8 *)(a1 + 151);
      int v11 = 67110146;
      *(_DWORD *)char v12 = v6;
      *(_WORD *)&v12[4] = 2080;
      *(void *)&v12[6] = v7;
      __int16 v13 = 2048;
      uint64_t v14 = v8;
      __int16 v15 = 1024;
      int v16 = v9;
      __int16 v17 = 1024;
      int v18 = v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fIsVinylAvailable:%d, \t\t\t\tfInternetStatusSink:%s, \t\t\t\tfNextFetchTime:%lu, \t\t\t\tfBackoffRetries:%d, \t\t\t\tfSetupCompleted:%d", (uint8_t *)&v11, 0x28u);
    }
  }
}

const void **sub_100A05578(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v22, *(Registry **)(a1 + 80));
  ctu::RestModule::connect();
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_100058DB0(__p, "/cc/props/vinyl_info");
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A29028;
  v2[1] = a1 + 112;
  void v2[2] = a1;
  v2[3] = sub_100A05264;
  v2[4] = 0;
  uint64_t v28 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(&object);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/buddy_state");
  unsigned int v3 = operator new(0x28uLL);
  void *v3 = off_101A290A8;
  v3[1] = a1 + 136;
  v3[2] = a1;
  v3[3] = sub_100A053D4;
  void v3[4] = 0;
  uint64_t v28 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(&object);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/internet_status");
  int v4 = operator new(0x28uLL);
  void *v4 = off_101A29128;
  v4[1] = a1 + 140;
  _OWORD v4[2] = a1;
  v4[3] = sub_100A053FC;
  v4[4] = 0;
  uint64_t v28 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&object);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_101A291A8;
  v5[1] = a1;
  void v5[2] = sub_100A05414;
  v5[3] = 0;
  uint64_t v28 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(&object);
  if (v25 < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 64) + 896))(__p);
  if (__p[0]) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    xpc_object_t v22 = 0;
    ctu::cf_to_xpc((uint64_t *)&object, (ctu *)__p[0], v6);
    xpc_object_t v8 = object;
    xpc_object_t v22 = object;
    if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_retain(v8);
    }
    else {
      xpc_object_t v22 = xpc_null_create();
    }
    xpc_release(object);
    xpc_object_t object = &v22;
    long long v27 = "State";
    sub_100048BAC((uint64_t)&object, &v21);
    *(_DWORD *)(a1 + 144) = xpc::dyn_cast_or_default((xpc *)&v21, (const object *)*(int *)(a1 + 144), v9);
    xpc_release(v21);
    if ((*(_DWORD *)(a1 + 144) - 5) > 1)
    {
      xpc_object_t object = &v22;
      long long v27 = "BackoffRetries";
      sub_100048BAC((uint64_t)&object, &v21);
      *(_DWORD *)(a1 + 160) = xpc::dyn_cast_or_default((xpc *)&v21, (const object *)*(unsigned int *)(a1 + 160), v15);
      xpc_release(v21);
      xpc_object_t object = &v22;
      long long v27 = "NextFetchAttemptTime";
      sub_100048BAC((uint64_t)&object, &v21);
      *(void *)(a1 + 152) = xpc::dyn_cast_or_default((xpc *)&v21, *(const object **)(a1 + 152), v16);
      xpc_release(v21);
      time_t v17 = *(void *)(a1 + 152);
      xpc_object_t object = (xpc_object_t)std::chrono::system_clock::now().__d_.__rep_;
      time_t v18 = std::chrono::system_clock::to_time_t((const std::chrono::system_clock::time_point *)&object);
      double v19 = difftime(v17, v18);
      if (v19 <= 0.0) {
        *(void *)(a1 + 152) = 0;
      }
      else {
        sub_100A05B34(a1, (int)(v19 / 60.0));
      }
    }
    else
    {
      int v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(object) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Bootstrap Provisioning completed already", (uint8_t *)&object, 2u);
      }
      int v11 = *(std::__shared_weak_count **)(a1 + 56);
      if (v11)
      {
        char v12 = std::__shared_weak_count::lock(v11);
        if (v12)
        {
          __int16 v13 = v12;
          uint64_t v14 = *(void *)(a1 + 48);
          if (v14) {
            (*(void (**)(uint64_t, void, void, void))(*(void *)v14 + 24))(v14, 0, 0, 0);
          }
          sub_10004D2C8(v13);
        }
      }
    }
    xpc_release(v22);
  }
  return sub_100057D78((const void **)__p);
}

void sub_100A05A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, xpc_object_t object, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  sub_10004D2C8(v18);
  xpc_release(object);
  sub_100057D78((const void **)&__p);
  _Unwind_Resume(a1);
}

void sub_100A05B34(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 208))
  {
    unsigned int v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E Setting backoff timer when one is already set.", buf, 2u);
    }
  }
  else
  {
    uint64_t v4 = 60000000 * a2;
    *(void *)std::string buf = std::chrono::system_clock::now().__d_.__rep_ + 60000000 * a2;
    *(void *)(a1 + 152) = std::chrono::system_clock::to_time_t((const std::chrono::system_clock::time_point *)buf);
    (***(void (****)(Registry **__return_ptr))(a1 + 64))(&v15);
    Registry::getTimerService((uint64_t *)buf, v15);
    uint64_t v5 = *(void *)buf;
    sub_100058DB0(__p, "Bootstrap Provisioning");
    int v6 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v6;
    if (v6) {
      dispatch_retain(v6);
    }
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = sub_100A064EC;
    v10[3] = &unk_101A28EF0;
    v10[4] = a1;
    aBlock = _Block_copy(v10);
    sub_100118A44(v5, (uint64_t)__p, 1, v4, &object, &aBlock);
    uint64_t v7 = v19;
    uint64_t v19 = 0;
    uint64_t v8 = *(void *)(a1 + 208);
    *(void *)(a1 + 208) = v7;
    if (v8)
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      uint64_t v9 = v19;
      uint64_t v19 = 0;
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
}

void sub_100A05D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  char v25 = *(std::__shared_weak_count **)(v23 - 56);
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A05DC8(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 148);
  int v3 = *(_DWORD *)(a2 + 12) == 3;
  if (v2 != v3) {
    *(unsigned char *)(a1 + 148) = v3;
  }
  if (*(unsigned char *)(a2 + 80))
  {
    for (uint64_t i = *(void *)(a2 + 56); i != *(void *)(a2 + 64); i += 216)
    {
      if (*(unsigned char *)(i + 88))
      {
        *(unsigned char *)(a1 + 150) = 1;
        goto LABEL_10;
      }
    }
  }
  if (v2 != v3 || *(unsigned char *)(a1 + 149)) {
LABEL_10:
  }
    sub_100A05E2C(a1);
}

void sub_100A05E2C(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 144);
  if (*(unsigned char *)(a1 + 150))
  {
    uint64_t v3 = *(void *)(a1 + 208);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
      *(void *)(a1 + 152) = 0;
      uint64_t v4 = *(void *)(a1 + 208);
      *(void *)(a1 + 208) = 0;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
    }
    int v5 = 5;
LABEL_6:
    *(_DWORD *)(a1 + 144) = v5;
LABEL_7:
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = "kBootstrapProvisioningNotSupported";
      if (v5 == 5) {
        uint64_t v7 = "kBootstrapProvisioningCompleted";
      }
      int v8 = *(_DWORD *)(a1 + 160);
      if (v5 == 6) {
        uint64_t v7 = "kBootstrapProvisioningFailure";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v7;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Provisioning completed: %s, fetch attempts: %d", buf, 0x12u);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 56);
    if (!v9) {
      goto LABEL_18;
    }
    int v10 = std::__shared_weak_count::lock(v9);
    if (!v10) {
      goto LABEL_18;
    }
    int v11 = v10;
    uint64_t v12 = *(void *)(a1 + 48);
    if (v12) {
      (*(void (**)(uint64_t, uint64_t, BOOL, void))(*(void *)v12 + 24))(v12, 1, *(_DWORD *)(a1 + 144) == 5, *(unsigned int *)(a1 + 160));
    }
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 144);
    switch(v2)
    {
      case 0:
        if (!*(unsigned char *)(a1 + 148)) {
          goto LABEL_18;
        }
        goto LABEL_25;
      case 1:
LABEL_25:
        if (*(unsigned char *)(a1 + 151)) {
          goto LABEL_26;
        }
        int v13 = 1;
        goto LABEL_68;
      case 2:
LABEL_26:
        if (!*(void *)(a1 + 208)) {
          goto LABEL_39;
        }
        int v13 = 2;
        goto LABEL_68;
      case 3:
        if (!*(unsigned char *)(a1 + 149)) {
          goto LABEL_18;
        }
        *(unsigned char *)(a1 + 149) = 0;
        uint64_t v28 = *(int *)(a1 + 160);
        if ((int)v28 <= 4)
        {
          *(_DWORD *)(a1 + 160) = v28 + 1;
          sub_100A05B34(a1, *(void *)(a1 + 8 * v28 + 168));
          int v13 = 2;
          *(_DWORD *)(a1 + 144) = 2;
          goto LABEL_20;
        }
        int v5 = 6;
        goto LABEL_6;
      case 4:
LABEL_39:
        if (*(unsigned char *)(a1 + 140) != 1)
        {
          int v13 = 4;
LABEL_68:
          *(_DWORD *)(a1 + 144) = v13;
          goto LABEL_19;
        }
        long long v20 = *(std::__shared_weak_count **)(a1 + 56);
        if (!v20) {
          goto LABEL_18;
        }
        xpc_object_t v21 = std::__shared_weak_count::lock(v20);
        if (!v21) {
          goto LABEL_18;
        }
        int v11 = v21;
        uint64_t v22 = *(void *)(a1 + 48);
        if (v22)
        {
          uint64_t v23 = *(NSObject **)(a1 + 40);
          BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
          if (v24)
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Attempt bootstrap provisioning", buf, 2u);
          }
          *(_DWORD *)(a1 + 144) = 3;
          *(unsigned char *)(a1 + 149) = 0;
          char v25 = *(std::__shared_weak_count **)(a1 + 88);
          if (v25) {
            atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v26 = capabilities::ct::bootstrapProvisioningSupportedOnSlotID((capabilities::ct *)v24);
          uint64_t v27 = VinylSlotIdFromInt(v26);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 16))(v22, v27);
          if (v25) {
            sub_10004D2C8(v25);
          }
        }
        break;
      case 5:
      case 6:
        goto LABEL_7;
      default:
        goto LABEL_18;
    }
  }
  sub_10004D2C8(v11);
LABEL_18:
  int v13 = *(_DWORD *)(a1 + 144);
LABEL_19:
  if (v2 != v13)
  {
LABEL_20:
    char v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if ((v2 - 1) > 5) {
        int v15 = "kBootstrapProvisioningNotSupported";
      }
      else {
        int v15 = off_101A29218[v2 - 1];
      }
      if ((v13 - 1) > 5) {
        uint64_t v16 = "kBootstrapProvisioningNotSupported";
      }
      else {
        uint64_t v16 = off_101A29218[v13 - 1];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s -> %s", buf, 0x16u);
      int v13 = *(_DWORD *)(a1 + 144);
    }
    if (v13 != 3)
    {
      xpc_object_t v39 = 0;
      xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v18 = v17;
      if (v17)
      {
        xpc_object_t v39 = v17;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
        xpc_object_t v39 = v18;
        if (!v18)
        {
          xpc_object_t v19 = xpc_null_create();
          xpc_object_t v18 = 0;
          goto LABEL_55;
        }
      }
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v18);
LABEL_56:
        xpc_release(v18);
        xpc_object_t v37 = xpc_int64_create(*(int *)(a1 + 144));
        if (!v37) {
          xpc_object_t v37 = xpc_null_create();
        }
        *(void *)std::string buf = &v39;
        *(void *)&uint8_t buf[8] = "State";
        sub_100035E70((uint64_t)buf, &v37, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_object_t v35 = xpc_int64_create(*(int *)(a1 + 160));
        if (!v35) {
          xpc_object_t v35 = xpc_null_create();
        }
        *(void *)std::string buf = &v39;
        *(void *)&uint8_t buf[8] = "BackoffRetries";
        sub_100035E70((uint64_t)buf, &v35, &v36);
        xpc_release(v36);
        xpc_object_t v36 = 0;
        xpc_release(v35);
        xpc_object_t v35 = 0;
        xpc_object_t v33 = xpc_int64_create(*(void *)(a1 + 152));
        if (!v33) {
          xpc_object_t v33 = xpc_null_create();
        }
        *(void *)std::string buf = &v39;
        *(void *)&uint8_t buf[8] = "NextFetchAttemptTime";
        sub_100035E70((uint64_t)buf, &v33, &v34);
        xpc_release(v34);
        xpc_object_t v34 = 0;
        xpc_release(v33);
        xpc_object_t v33 = 0;
        uint64_t v29 = *(void *)(a1 + 64);
        xpc_object_t v31 = v39;
        if (v39) {
          xpc_retain(v39);
        }
        else {
          xpc_object_t v31 = xpc_null_create();
        }
        xpc::bridge((uint64_t *)&v32, (xpc *)&v31, v30);
        sub_10004EFE4(buf, &v32);
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v29 + 904))(v29, buf);
        sub_100057D78((const void **)buf);
        sub_1000577C4(&v32);
        xpc_release(v31);
        xpc_release(v39);
        return;
      }
      xpc_object_t v19 = xpc_null_create();
LABEL_55:
      xpc_object_t v39 = v19;
      goto LABEL_56;
    }
  }
}

void sub_100A063F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18, char a19)
{
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

void sub_100A064D4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 149) = 1;
  if (*(unsigned char *)(a2 + 88)) {
    sub_100A05DC8(a1, a2);
  }
  else {
    sub_100A05E2C(a1);
  }
}

uint64_t sub_100A064EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 208);
  *(void *)(v1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)(v1 + 152) = 0;
  if (*(_DWORD *)(v1 + 144) != 2)
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#E Timer fired while not in waiting state.", v5, 2u);
    }
  }
  return sub_100A05E2C(v1);
}

void sub_100A0659C(uint64_t a1)
{
  sub_100A065D4(a1);

  operator delete();
}

uint64_t sub_100A065D4(uint64_t a1)
{
  *(void *)a1 = off_101A28ED0;
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v8 = (void **)(a1 + 112);
  sub_1000C56F4(&v8);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A066A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A066DC(uint64_t a1)
{
}

uint64_t sub_100A066F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A0673C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100A0676C()
{
}

__n128 sub_100A06780(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A29028;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A067D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A29028;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A0680C(uint64_t a1, xpc_object_t *a2)
{
  sub_10010C4E0(*(uint64_t **)(a1 + 8), a2);
  uint64_t v3 = *(uint64_t (**)(void *))(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = (void *)(*(void *)(a1 + 16) + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100A06888(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A068C8()
{
}

void sub_100A068D8()
{
}

__n128 sub_100A068EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A290A8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A06940(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A290A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A06978(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v6);
    int *v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  int v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100A06A68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A06AA8()
{
}

void sub_100A06AB8()
{
}

__n128 sub_100A06ACC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A29128;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A06B20(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A29128;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A06B58(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (char *)a1[1];
  char v13 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (unsigned __int8 *)a2, v6);
    char *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    char *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *, char *))a1[3];
  uint64_t v10 = a1[4];
  int v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, char *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

uint64_t sub_100A06C54(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A06C94()
{
}

void sub_100A06CA4()
{
}

__n128 sub_100A06CB8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A291A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A06D0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A291A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A06D44(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100A06D8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A06DCC()
{
}

void sub_100A06DD8(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 360) + 136);
  if (v3)
  {
    uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56));
    sub_10047ECE8(v3, v4, a2);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

uint64_t sub_100A06E60()
{
  return 1;
}

void sub_100A06E68(uint64_t a1)
{
  LazuliProvisioningServerWrapper::stopTimers((LazuliProvisioningServerWrapper *)a1);
  unint64_t v2 = sub_1008AFC10(*(void *)(a1 + 360));
  if (v3)
  {
    unint64_t v4 = v2;
    sub_10003E168(&v16, (void *)(a1 + 8));
    long long v5 = v16;
    if (*((void *)&v16 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v16 + 1) + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
    }
    unint64_t v15 = v4;
    sub_100210914((void *)(a1 + 72), (NSObject **)(a1 + 24), &off_101A29290, &v15, &v16);
    long long v6 = v16;
    long long v16 = 0uLL;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 408);
    *(_OWORD *)(a1 + 400) = v6;
    if (v7)
    {
      sub_10004D2C8(v7);
      if (*((void *)&v16 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v16 + 1));
      }
    }
    uint64_t v8 = *(void *)(a1 + 400);
    if (*((void *)&v5 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v5 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    xpc_object_t v17 = 0;
    uint64_t v9 = (char *)operator new(0x20uLL);
    *(void *)uint64_t v9 = off_101A292C0;
    *(_OWORD *)(v9 + 8) = v5;
    *((void *)v9 + 3) = a1;
    xpc_object_t v17 = v9;
    sub_10040F734(v8, (uint64_t)&v16, 0);
    sub_10003B34C(&v16);
    sub_10040F9CC(*(void *)(a1 + 400), 0);
    if (*((void *)&v5 + 1)) {
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v5 + 1));
    }
  }
  else
  {
    unint64_t v10 = sub_1008AE4F8(*(void *)(a1 + 360));
    if (v11)
    {
      LazuliProvisioningServerWrapper::startUnauthorizedXmlTimer((LazuliProvisioningServerWrapper *)a1, v10);
    }
    else
    {
      unint64_t v12 = sub_1008AD5A0(*(void *)(a1 + 360));
      if (v13 || (unint64_t v12 = sub_1008ADD90(*(void *)(a1 + 360)), v14))
      {
        LazuliProvisioningServerWrapper::startFullXmlTimer((LazuliProvisioningServerWrapper *)a1, v12);
      }
    }
  }
}

void sub_100A07080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100A070C8(uint64_t a1)
{
  __n128 result = *(void **)(a1 + 400);
  if (result) {
    return (void *)sub_10040FE68(result);
  }
  return result;
}

void sub_100A070F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 400);
  if (v2)
  {
    sub_10040F9CC(v2, 1);
  }
  else
  {
    char v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v4 = (void *)(a1 + 128);
      if (*(char *)(a1 + 151) < 0) {
        unint64_t v4 = (void *)*v4;
      }
      int v5 = 136446210;
      long long v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [%{public}s] Access Control XML timer --> not active", (uint8_t *)&v5, 0xCu);
    }
  }
  LazuliProvisioningServerWrapper::dump((LazuliProvisioningServerWrapper *)a1);
}

void sub_100A071E8(LazuliProvisioningServerWrapper *this)
{
  *(void *)this = off_101A29258;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 51);
  if (v2) {
    sub_10004D2C8(v2);
  }

  LazuliProvisioningServerWrapper::~LazuliProvisioningServerWrapper(this);
}

void sub_100A07244(LazuliProvisioningServerWrapper *this)
{
  *(void *)this = off_101A29258;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 51);
  if (v2) {
    sub_10004D2C8(v2);
  }
  LazuliProvisioningServerWrapper::~LazuliProvisioningServerWrapper(this);

  operator delete();
}

void *sub_100A072B4(void *a1)
{
  *a1 = off_101A292C0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A07300(void *a1)
{
  *a1 = off_101A292C0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100A0736C(void *a1)
{
  __n128 result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *__n128 result = off_101A292C0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100A073D0(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A292C0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100A07410(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A07420(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A07460(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[3];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[1])
      {
        long long v6 = *(std::__shared_weak_count **)(v3 + 104);
        if (v6)
        {
          uint64_t v7 = std::__shared_weak_count::lock(v6);
          if (v7)
          {
            uint64_t v8 = *(void *)(v3 + 96);
            if (v8)
            {
              if (*(char *)(v3 + 151) < 0)
              {
                sub_10004FC84(__p, *(void **)(v3 + 128), *(void *)(v3 + 136));
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)(v3 + 128);
                uint64_t v12 = *(void *)(v3 + 144);
              }
              LazuliProvisioningModel::handleAccessControlXmlTimerExpiry(v8);
            }
          }
        }
        else
        {
          uint64_t v7 = 0;
        }
        uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 56));
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v10 = (void *)(v3 + 128);
          if (*(char *)(v3 + 151) < 0) {
            unint64_t v10 = (void *)*v10;
          }
          LODWORD(__p[0]) = 136446210;
          *(void **)((char *)__p + 4) = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [%{public}s] Client disappeared while handling unauthorized XML timer expiry", (uint8_t *)__p, 0xCu);
        }
        if (v7) {
          sub_10004D2C8(v7);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100A075E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_10004D2C8(v15);
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_100A07620(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A07660()
{
}

BOOL sub_100A0766C(uint64_t a1)
{
  if ((!*(unsigned char *)(a1 + 57) || !*(unsigned char *)(a1 + 97) || !*(unsigned char *)(a1 + 96)) && !*(unsigned char *)(a1 + 98)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 58))
  {
    if (*(unsigned char *)(a1 + 88)) {
      return *(void *)(a1 + 80) != 0;
    }
    return 0;
  }
  return 1;
}

void sub_100A076BC(CFDictionaryRef theDict@<X1>, id *a2@<X0>, uint64_t ***a3@<X8>)
{
  if (!theDict
    || (CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"roadside_providers")) == 0
    || (CFArrayRef v6 = Value, v7 = CFGetTypeID(Value), v7 != CFArrayGetTypeID()))
  {
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  CFIndex Count = CFArrayGetCount(v6);
  uint64_t v9 = (std::__shared_weak_count *)operator new(0x30uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9[1].__shared_owners_ = 0;
  p_shared_owners = (uint64_t **)&v9[1].__shared_owners_;
  v9->__vftable = (std::__shared_weak_count_vtbl *)off_101A29340;
  v9[1].__vftable = (std::__shared_weak_count_vtbl *)&v9[1].__shared_owners_;
  __int16 v30 = (uint64_t **)&v9[1];
  v9[1].__shared_weak_owners_ = 0;
  if (Count < 1) {
    goto LABEL_58;
  }
  CFIndex v11 = 0;
  uint64_t v29 = v9;
  do
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(v6, v11);
    char v13 = ValueAtIndex;
    if (!ValueAtIndex || (CFTypeID v14 = CFGetTypeID(ValueAtIndex), v14 != CFDictionaryGetTypeID()))
    {
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v32 = 0u;
      memset(v31, 0, sizeof(v31));
      goto LABEL_44;
    }
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v32 = 0u;
    memset(v31, 0, sizeof(v31));
    uint64_t v44 = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    memset(v39, 0, sizeof(v39));
    if (!sub_100215408(v13, @"id", v39)
      || !sub_1002155D4(v13, @"name", (std::string *)((char *)v39 + 8))
      || !sub_1002155D4(v13, @"bizId", (std::string *)&v40)
      || !sub_100215578(v13, @"supportsPayPerUse", (unsigned char *)&v41 + 8)
      || !sub_100215578(v13, @"enabled", (unsigned char *)&v41 + 9))
    {
      LOBYTE(v31[0]) = 0;
      BYTE8(v36) = 0;
      goto LABEL_23;
    }
    sub_100215578(v13, @"carrierProvider", (unsigned char *)&v41 + 10);
    if (BYTE9(v41))
    {
      unint64_t v15 = (void *)CFDictionaryGetValue((CFDictionaryRef)v13, @"requiredIosVersion");
      long long v16 = v15;
      if (v15)
      {
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 == CFDictionaryGetTypeID())
        {
          long long v37 = 0uLL;
          uint64_t v38 = 0;
          if (!sub_100897640(&v37, a2, v16))
          {
            xpc_object_t v18 = sub_100200FB4(a2);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::string buf = 67109120;
              int v46 = v39[0];
              _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "ProviderId: %u has incorrect required OS configuration, will mark the provider as unsupported", buf, 8u);
            }
            goto LABEL_48;
          }
          if ((sub_100897850(&v37) & 1) == 0)
          {
            xpc_object_t v18 = sub_100200FB4(a2);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 67109120;
              int v46 = v39[0];
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I ProviderId: %u is not supported on this OS, will mark the provider as unsupported", buf, 8u);
            }
LABEL_48:

            BYTE9(v41) = 0;
          }
        }
      }
    }
    LODWORD(v31[0]) = v39[0];
    *(_OWORD *)((char *)v31 + 8) = *(_OWORD *)((char *)v39 + 8);
    *((void *)&v31[1] + 1) = *((void *)&v39[1] + 1);
    memset((char *)v39 + 8, 0, 24);
    long long v32 = v40;
    *(void *)&long long v33 = v41;
    long long v40 = 0uLL;
    *(void *)&long long v41 = 0;
    BYTE10(v33) = BYTE10(v41);
    WORD4(v33) = WORD4(v41);
    LOBYTE(v34) = 0;
    BYTE8(v35) = 0;
    if (BYTE8(v43))
    {
      long long v34 = v42;
      *(void *)&long long v35 = v43;
      if ((void)v43)
      {
        *(void *)(*((void *)&v42 + 1) + 16) = (char *)&v34 + 8;
        *(void *)&long long v42 = (char *)&v42 + 8;
        *((void *)&v42 + 1) = 0;
        *(void *)&long long v43 = 0;
      }
      else
      {
        *(void *)&long long v34 = (char *)&v34 + 8;
      }
      BYTE8(v35) = 1;
    }
    LOWORD(v36) = v44;
    BYTE2(v36) = BYTE2(v44);
    BYTE8(v36) = 1;
LABEL_23:
    if (BYTE8(v43)) {
      sub_10005CD2C((uint64_t)&v42, *((char **)&v42 + 1));
    }
    if (SBYTE7(v41) < 0) {
      operator delete((void *)v40);
    }
    if (SHIBYTE(v39[1]) < 0) {
      operator delete(*((void **)&v39[0] + 1));
    }
    if (BYTE8(v36))
    {
      unint64_t v19 = LODWORD(v31[0]);
      *(void *)&v39[1] = 0;
      long long v20 = (char *)operator new(0x90uLL);
      *(void *)&v39[0] = v20;
      *((void *)&v39[0] + 1) = p_shared_owners;
      *((void *)v20 + 4) = v19;
      *((_DWORD *)v20 + 10) = v19;
      *((_OWORD *)v20 + 3) = *(_OWORD *)((char *)v31 + 8);
      *((void *)v20 + 8) = *((void *)&v31[1] + 1);
      memset((char *)v31 + 8, 0, 24);
      *(_OWORD *)(v20 + 72) = v32;
      *((void *)v20 + 11) = v33;
      *(void *)&long long v33 = 0;
      long long v32 = 0uLL;
      __int16 v21 = WORD4(v33);
      v20[98] = BYTE10(v33);
      *((_WORD *)v20 + 48) = v21;
      v20[104] = 0;
      v20[128] = 0;
      if (BYTE8(v35))
      {
        long long v22 = v34;
        *((void *)v20 + 14) = *((void *)&v34 + 1);
        uint64_t v23 = v20 + 112;
        *((void *)v20 + 13) = v22;
        uint64_t v24 = v35;
        *((void *)v20 + 15) = v35;
        if (v24)
        {
          *(void *)(*((void *)&v22 + 1) + 16) = v23;
          *(void *)&long long v34 = (char *)&v34 + 8;
          *((void *)&v34 + 1) = 0;
          *(void *)&long long v35 = 0;
        }
        else
        {
          *((void *)v20 + 13) = v23;
        }
        v20[128] = 1;
      }
      *((_WORD *)v20 + 68) = v36;
      v20[138] = BYTE2(v36);
      LOBYTE(v39[1]) = 1;
      char v25 = *p_shared_owners;
      int v26 = p_shared_owners;
      uint64_t v27 = p_shared_owners;
      if (*p_shared_owners)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v27 = (uint64_t **)v25;
            unint64_t v28 = v25[4];
            if (v28 <= v19) {
              break;
            }
            char v25 = *v27;
            int v26 = v27;
            if (!*v27) {
              goto LABEL_42;
            }
          }
          if (v28 >= v19) {
            break;
          }
          char v25 = v27[1];
          if (!v25)
          {
            int v26 = v27 + 1;
            goto LABEL_42;
          }
        }
      }
      else
      {
LABEL_42:
        sub_100046C38(v30, (uint64_t)v27, v26, (uint64_t *)v20);
        *(void *)&v39[0] = 0;
      }
      sub_100A08220((uint64_t)v39, 0);
    }
LABEL_44:
    sub_100A08070((uint64_t)v31);
    ++v11;
  }
  while (v11 != Count);
  uint64_t v9 = v29;
  if (v29[1].__shared_weak_owners_)
  {
    *a3 = v30;
    a3[1] = (uint64_t **)v29;
    return;
  }
LABEL_58:
  *a3 = 0;
  a3[1] = 0;
  sub_10004D2C8(v9);
}

void sub_100A07C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  sub_100A08018(v17 - 224);
  sub_10004D2C8(a17);
  _Unwind_Resume(a1);
}

void sub_100A07CE0(CFDictionaryRef theDict@<X1>, id *a2@<X0>, uint64_t ***a3@<X8>)
{
  if (theDict
    && (CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"roadside_provider_ids")) != 0
    && (v7 = Value, CFTypeID v8 = CFGetTypeID(Value), v8 == CFArrayGetTypeID()))
  {
    CFIndex Count = CFArrayGetCount(v7);
    unint64_t v10 = (std::__shared_weak_count *)operator new(0x30uLL);
    v10->__shared_owners_ = 0;
    v10->__shared_weak_owners_ = 0;
    v10[1].__shared_owners_ = 0;
    v10->__vftable = (std::__shared_weak_count_vtbl *)off_101A29390;
    v10[1].__vftable = (std::__shared_weak_count_vtbl *)&v10[1].__shared_owners_;
    CFIndex v11 = (uint64_t **)&v10[1];
    v10[1].__shared_weak_owners_ = 0;
    if (Count < 1) {
      goto LABEL_17;
    }
    for (CFIndex i = 0; i != Count; ++i)
    {
      ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex(v7, i);
      CFTypeID v14 = ValueAtIndex;
      if (ValueAtIndex && (CFTypeID v15 = CFGetTypeID(ValueAtIndex), v15 == CFNumberGetTypeID()))
      {
        *(_DWORD *)std::string buf = 0;
        ctu::cf::assign((ctu::cf *)buf, v14, v16);
        unsigned int v18 = *(_DWORD *)buf;
        sub_100A08300(v11, &v18, &v18);
      }
      else
      {
        uint64_t v17 = sub_100200FB4(a2);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218242;
          CFIndex v20 = i;
          __int16 v21 = 2112;
          CFDictionaryRef v22 = theDict;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "ProviderId at index: %ld incorrectly configured in configuration: %@", buf, 0x16u);
        }
      }
    }
    if (v10[1].__shared_weak_owners_)
    {
      *a3 = v11;
      a3[1] = (uint64_t **)v10;
    }
    else
    {
LABEL_17:
      *a3 = 0;
      a3[1] = 0;
      sub_10004D2C8(v10);
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_100A07EDC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A07F00(void *a1, uint64_t a2)
{
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    uint64_t v4 = (void *)(a2 + 8);
    do
    {
      if (*((unsigned char *)v3 + 98))
      {
        uint64_t v5 = *v4;
        if (!*v4) {
          goto LABEL_26;
        }
        unsigned int v6 = *((_DWORD *)v3 + 10);
        CFArrayRef v7 = v4;
        do
        {
          unsigned int v8 = *(_DWORD *)(v5 + 32);
          BOOL v9 = v8 >= v6;
          if (v8 >= v6) {
            unint64_t v10 = (uint64_t *)v5;
          }
          else {
            unint64_t v10 = (uint64_t *)(v5 + 8);
          }
          if (v9) {
            CFArrayRef v7 = (void *)v5;
          }
          uint64_t v5 = *v10;
        }
        while (*v10);
        if (v7 != v4 && v6 >= *((_DWORD *)v7 + 8))
        {
          sub_1000C6BDC(v14, (uint64_t)(v7 + 5));
          sub_100634768((uint64_t)(v3 + 13), v14);
          sub_10005CD2C((uint64_t)v14, (char *)v14[1]);
        }
        else
        {
LABEL_26:
          if (*((unsigned char *)v3 + 128))
          {
            sub_10005CD2C((uint64_t)(v3 + 13), (char *)v3[14]);
            *((unsigned char *)v3 + 128) = 0;
          }
        }
      }
      CFIndex v11 = (void *)v3[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          CFIndex v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v3[2];
          BOOL v13 = *v12 == (void)v3;
          uint64_t v3 = v12;
        }
        while (!v13);
      }
      uint64_t v3 = v12;
    }
    while (v12 != v2);
  }
}

void sub_100A08000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100A08018(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88)) {
    sub_10005CD2C(a1 + 64, *(char **)(a1 + 72));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100A08070(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 104))
  {
    if (*(unsigned char *)(a1 + 88)) {
      sub_10005CD2C(a1 + 64, *(char **)(a1 + 72));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

void sub_100A080D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A29340;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A080F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A29340;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A08144(uint64_t a1)
{
}

void sub_100A08158(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100A08158(a1, *a2);
    sub_100A08158(a1, a2[1]);
    sub_100A081B4((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100A081B4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96)) {
    sub_10005CD2C(a1 + 72, *(char **)(a1 + 80));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 16);
    operator delete(v2);
  }
}

void sub_100A08220(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100A081B4((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_100A08278(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A29390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A08298(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A29390;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A082EC(uint64_t a1)
{
}

uint64_t **sub_100A08300(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  unsigned int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unsigned int v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        unsigned int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        unsigned int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unsigned int v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    sub_100046C38(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_100A083BC()
{
}

void sub_100A08428()
{
}

uint64_t sub_100A0844C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "lasd.ids.st");
  sub_100A0858C(v4, &v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *(void *)a1 = off_101A293E0;
  *(void *)(a1 + 40) = *(void *)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a1 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 56), *(Registry **)a2);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = a1 + 128;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 1065353216;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_DWORD *)(a1 + 216) = 1065353216;
  return a1;
}

void sub_100A0854C(_Unwind_Exception *a1)
{
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v1 + 6);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_1006C7390(v2);
  LASDDatabaseIDSStateManagerInterface::~LASDDatabaseIDSStateManagerInterface(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A0858C(uint64_t a1, const OsLogContext *a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, a2);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 24), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  return a1;
}

void sub_100A085DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100A08604(os_unfair_lock_s *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a3[1];
  uint64_t v12 = *a3;
  BOOL v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100A0B284((uint64_t)v14, a4);
  unsigned int v6 = a1 + 6;
  os_unfair_lock_lock(v6);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  OsLogContext v7 = *(std::__shared_weak_count **)&a1[20]._os_unfair_lock_opaque;
  *(void *)&a1[18]._os_unfair_lock_opaque = v12;
  *(void *)&a1[20]._os_unfair_lock_opaque = v13;
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100A0B284((uint64_t)v15, (uint64_t)v14);
  unsigned int v8 = a1 + 22;
  if (v15 != (void *)&a1[22])
  {
    unsigned int v9 = v16;
    unint64_t v10 = *(os_unfair_lock_s **)&a1[28]._os_unfair_lock_opaque;
    if (v16 == v15)
    {
      if (v10 == v8)
      {
        memset(v17, 0, sizeof(v17));
        (*(void (**)(void *, void *))(v15[0] + 24))(v15, v17);
        (*(void (**)(void *))(*v16 + 32))(v16);
        CFNumberRef v16 = 0;
        (*(void (**)(void, void *))(**(void **)&a1[28]._os_unfair_lock_opaque + 24))(*(void *)&a1[28]._os_unfair_lock_opaque, v15);
        (*(void (**)(void))(**(void **)&a1[28]._os_unfair_lock_opaque + 32))(*(void *)&a1[28]._os_unfair_lock_opaque);
        *(void *)&a1[28]._os_unfair_lock_opaque = 0;
        CFNumberRef v16 = v15;
        (*(void (**)(void *, uint32_t *))(v17[0] + 24))(v17, &a1[22]._os_unfair_lock_opaque);
        (*(void (**)(void *))(v17[0] + 32))(v17);
      }
      else
      {
        (*(void (**)(void *, uint32_t *))(v15[0] + 24))(v15, &a1[22]._os_unfair_lock_opaque);
        (*(void (**)(void *))(*v16 + 32))(v16);
        CFNumberRef v16 = *(void **)&a1[28]._os_unfair_lock_opaque;
      }
      *(void *)&a1[28]._os_unfair_lock_opaque = v8;
    }
    else if (v10 == v8)
    {
      (*(void (**)(uint32_t *, void *))(*(void *)&v8->_os_unfair_lock_opaque + 24))(&a1[22]._os_unfair_lock_opaque, v15);
      (*(void (**)(void))(**(void **)&a1[28]._os_unfair_lock_opaque + 32))(*(void *)&a1[28]._os_unfair_lock_opaque);
      *(void *)&a1[28]._os_unfair_lock_opaque = v16;
      CFNumberRef v16 = v15;
    }
    else
    {
      CFNumberRef v16 = *(void **)&a1[28]._os_unfair_lock_opaque;
      *(void *)&a1[28]._os_unfair_lock_opaque = v9;
    }
  }
  sub_100A0AEFC(v15);
  os_unfair_lock_unlock(v6);
  sub_100A0AEFC(v14);
  if (v13) {
    sub_10004D2C8(v13);
  }
}

void sub_100A08928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A08954(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  int v4 = sub_100BE0C90(v3);
  LODWORD(__p[0]) = begin();
  int v5 = end();
  while (LODWORD(__p[0]) != v5)
  {
    LODWORD(v29[0]) = 0;
    LODWORD(v29[0]) = operator*();
    if (((uint64_t)v29[0] & v4) != 0)
    {
      memset(__str, 0, sizeof(__str));
      sub_100A0B5C4(a1 + 120, (int *)v29, v29, (long long *)__str);
      if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[1].__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str[0].__r_.__value_.__l.__data_);
      }
    }
    operator++();
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 72) + 96))(__str);
  unsigned int v6 = (std::string::size_type *)(a1 + 184);
  if (*(void *)(a1 + 208))
  {
    sub_100A0B238(a1 + 184, *(void ***)(a1 + 200));
    *(void *)(a1 + 200) = 0;
    uint64_t v7 = *(void *)(a1 + 192);
    if (v7)
    {
      for (uint64_t i = 0; i != v7; ++i)
        *(void *)(*v6 + 8 * i) = 0;
    }
    *(void *)(a1 + 208) = 0;
  }
  std::string::size_type v9 = __str[0].__r_.__value_.__r.__words[0];
  __str[0].__r_.__value_.__r.__words[0] = 0;
  unint64_t v10 = (void *)*v6;
  std::string::size_type *v6 = v9;
  if (v10) {
    operator delete(v10);
  }
  long long v11 = *(_OWORD *)&__str[0].__r_.__value_.__r.__words[1];
  *(_OWORD *)(a1 + 192) = *(_OWORD *)&__str[0].__r_.__value_.__r.__words[1];
  __str[0].__r_.__value_.__l.__size_ = 0;
  std::string::pointer data = __str[1].__r_.__value_.__l.__data_;
  *(void *)(a1 + 208) = __str[1].__r_.__value_.__l.__data_;
  *(_DWORD *)(a1 + 216) = __str[1].__r_.__value_.__r.__words[1];
  if (data)
  {
    unint64_t v13 = *(void *)(*((void *)&v11 + 1) + 8);
    if (((unint64_t)v11 & ((void)v11 - 1)) != 0)
    {
      if (*((void *)&v11 + 1) >= (unint64_t)v11) {
        unint64_t v13 = *((void *)&v11 + 1) % (unint64_t)v11;
      }
    }
    else
    {
      unint64_t v13 = *((void *)&v11 + 1) & (v11 - 1);
    }
    *(void *)(*v6 + 8 * v13) = a1 + 200;
    __str[0].__r_.__value_.__r.__words[2] = 0;
    __str[1].__r_.__value_.__r.__words[0] = 0;
  }
  sub_100A0B1FC((uint64_t)__str);
  CFTypeRef v32 = 0;
  Registry::getMobileHelper((uint64_t *)__str, *(Registry **)(a1 + 40));
  std::string::size_type v14 = __str[0].__r_.__value_.__r.__words[0];
  sub_100058DB0(v29, "/var/mobile/Library/Preferences/com.apple.lasd.plist");
  (*(void (**)(CFTypeRef *__return_ptr, std::string::size_type, void **))(*(void *)v14 + 40))(&cf, v14, v29);
  uint64_t v27 = (char **)cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v33 = 0;
  __p[0] = 0;
  sub_10004EFE4(__p, (CFTypeRef *)&v27);
  if (__p[0]) {
    CFTypeID v15 = sub_100080778;
  }
  else {
    CFTypeID v15 = 0;
  }
  if (v15) {
    sub_100058140(&v33, (const void **)__p);
  }
  sub_100057D78((const void **)__p);
  CFTypeRef v32 = v33;
  CFTypeRef v33 = 0;
  sub_100057D78(&v33);
  sub_1000577C4((const void **)&v27);
  sub_1000577C4(&cf);
  if (v30 < 0) {
    operator delete(v29[0]);
  }
  if (__str[0].__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__str[0].__r_.__value_.__l.__size_);
  }
  if (v32) {
    CFNumberRef v16 = sub_100080778;
  }
  else {
    CFNumberRef v16 = 0;
  }
  if (v16)
  {
    uint64_t v27 = 0;
    v28[0] = 0;
    v28[1] = 0;
    CFTypeRef v33 = v32;
    if (v32) {
      CFRetain(v32);
    }
    sub_100BE0904(&v33, (uint64_t)&v27);
    sub_100057D78(&v33);
    uint64_t v17 = (char *)v27;
    if (v27 != v28)
    {
      unsigned int v18 = (uint64_t **)(a1 + 120);
      do
      {
        memset(__p, 0, 32);
        LODWORD(__p[0]) = *((_DWORD *)v17 + 8);
        if (v17[63] < 0)
        {
          sub_10004FC84(&__p[1], *((void **)v17 + 5), *((void *)v17 + 6));
        }
        else
        {
          *(_OWORD *)&__p[1] = *(_OWORD *)(v17 + 40);
          __p[3] = *((void **)v17 + 7);
        }
        memset(__str, 0, sizeof(__str));
        if (SHIBYTE(__p[3]) < 0) {
          sub_10004FC84(__str, __p[1], (unint64_t)__p[2]);
        }
        else {
          __str[0] = *(std::string *)&__p[1];
        }
        unint64_t v19 = sub_100A0B31C((uint64_t)v6, (int)__p[0], __p);
        if (*((char *)v19 + 47) < 0)
        {
          sub_10004FC84(&__str[1], (void *)v19[3], v19[4]);
        }
        else
        {
          long long v20 = *(_OWORD *)(v19 + 3);
          __str[1].__r_.__value_.__r.__words[2] = v19[5];
          *(_OWORD *)&__str[1].__r_.__value_.__l.__data_ = v20;
        }
        __int16 v21 = sub_100299430(v18, (int)__p[0], __p);
        std::string::operator=((std::string *)(v21 + 5), __str);
        std::string::operator=((std::string *)(v21 + 8), &__str[1]);
        if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str[1].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str[0].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
        CFDictionaryRef v22 = (char *)*((void *)v17 + 1);
        if (v22)
        {
          do
          {
            uint64_t v23 = (char **)v22;
            CFDictionaryRef v22 = *(char **)v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            uint64_t v23 = (char **)*((void *)v17 + 2);
            BOOL v24 = *v23 == v17;
            uint64_t v17 = (char *)v23;
          }
          while (!v24);
        }
        uint64_t v17 = (char *)v23;
      }
      while (v23 != v28);
    }
    sub_1000886C0((uint64_t)&v27, v28[0]);
  }
  else
  {
    char v25 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__str[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__str[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"/var/mobile/Library/Preferences/com.apple.lasd.plist";
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I %s not available to read, maybe still using bootstrap db", (uint8_t *)__str, 0xCu);
    }
  }
  sub_100057D78(&v32);

  os_unfair_lock_unlock(v2);
}

void sub_100A08E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100A08F80(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v28 = *((void *)a2 + 2);
  }
  uint64_t v3 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock(v3);
  if ((sub_100A0ADC0(*(Registry **)(a1 + 40), v4) & 1) == 0)
  {
    long long v11 = *(NSObject **)(a1 + 32);
    uint64_t v12 = 0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      unint64_t v13 = "#I We are not supposed to initiate any messaging";
      std::string::size_type v14 = v11;
      uint32_t v15 = 2;
      goto LABEL_11;
    }
    goto LABEL_34;
  }
  if (!*(void *)(a1 + 136))
  {
    CFNumberRef v16 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "We don't have any state info, this should not happen", buf, 2u);
    }
    goto LABEL_14;
  }
  unint64_t v5 = sub_100206390(a1 + 168, (uint64_t)&__p);
  int8x8_t v6 = *(int8x8_t *)(a1 + 152);
  if (!*(void *)&v6) {
    goto LABEL_28;
  }
  unint64_t v7 = v5;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v5;
    if (v5 >= *(void *)&v6) {
      unint64_t v10 = v5 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v10 = (*(void *)&v6 - 1) & v5;
  }
  uint64_t v17 = *(unsigned __int8 ***)(*(void *)(a1 + 144) + 8 * v10);
  if (!v17 || (unsigned int v18 = *v17) == 0)
  {
LABEL_28:
    long long v20 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      if (v28 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = (long long *)__p;
      }
      *(_DWORD *)std::string buf = 136315138;
      char v30 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Device %s may need some resources that we can support", buf, 0xCu);
    }
    uint64_t v12 = 1;
    goto LABEL_34;
  }
  while (1)
  {
    unint64_t v19 = *((void *)v18 + 1);
    if (v7 == v19) {
      break;
    }
    if (v9 > 1)
    {
      if (v19 >= *(void *)&v6) {
        v19 %= *(void *)&v6;
      }
    }
    else
    {
      v19 &= *(void *)&v6 - 1;
    }
    if (v19 != v10) {
      goto LABEL_28;
    }
LABEL_27:
    unsigned int v18 = *(unsigned __int8 **)v18;
    if (!v18) {
      goto LABEL_28;
    }
  }
  if ((sub_1000609C0(a1 + 176, v18 + 16, (unsigned __int8 *)&__p) & 1) == 0) {
    goto LABEL_27;
  }
  uint64_t v23 = *(NSObject **)(a1 + 32);
  BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  uint64_t v12 = 0;
  if (v24)
  {
    if (v28 >= 0) {
      char v25 = &__p;
    }
    else {
      char v25 = (long long *)__p;
    }
    *(_DWORD *)std::string buf = 136315138;
    char v30 = v25;
    unint64_t v13 = "#I Devices %s has all the resources we can support, no sync needed";
    std::string::size_type v14 = v23;
    uint32_t v15 = 12;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
LABEL_14:
    uint64_t v12 = 0;
  }
LABEL_34:
  os_unfair_lock_unlock(v3);
  if (SHIBYTE(v28) < 0) {
    operator delete((void *)__p);
  }
  return v12;
}

void sub_100A09274(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100A09280(uint64_t a1, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v74, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v74 = *a2;
    uint64_t v75 = *((void *)a2 + 2);
  }
  sub_100A0BA68((uint64_t *)&v76, a3);
  unint64_t v5 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock(v5);
  uint64_t v6 = a1 + 144;
  if (sub_1003DDE88((void *)(a1 + 144), (unsigned __int8 *)&v74))
  {
    unint64_t v7 = *(NSObject **)(a1 + 32);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (v75 >= 0) {
        uint8x8_t v8 = &v74;
      }
      else {
        uint8x8_t v8 = (long long *)v74;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Device %s already has all the resources we can support, no further action needed", buf, 0xCu);
    }
    goto LABEL_145;
  }
  v81 = 0;
  CFNumberRef v82 = 0;
  v80 = &v81;
  unint64_t v9 = v76;
  if (v76 == v77) {
    goto LABEL_138;
  }
  char v71 = v5;
  unint64_t v10 = (uint64_t **)(a1 + 120);
  long long v11 = (uint64_t *)(a1 + 128);
  v72 = (uint64_t **)(a1 + 120);
  do
  {
    uint64_t v12 = (int *)(v9 + 4);
    uint64_t v13 = *v11;
    if (!*v11) {
      goto LABEL_22;
    }
    std::string::size_type v14 = v9 + 5;
    int v15 = *v12;
    uint64_t v16 = a1 + 128;
    do
    {
      int v17 = *(_DWORD *)(v13 + 32);
      BOOL v18 = v17 < v15;
      if (v17 >= v15) {
        unint64_t v19 = (uint64_t *)v13;
      }
      else {
        unint64_t v19 = (uint64_t *)(v13 + 8);
      }
      if (!v18) {
        uint64_t v16 = v13;
      }
      uint64_t v13 = *v19;
    }
    while (*v19);
    if ((uint64_t *)v16 == v11 || v15 < *(_DWORD *)(v16 + 32))
    {
LABEL_22:
      long long v20 = *(NSObject **)(a1 + 32);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_47;
      }
      if (v75 >= 0) {
        __int16 v21 = &v74;
      }
      else {
        __int16 v21 = (long long *)v74;
      }
      CFDictionaryRef v22 = "gsm";
      switch(*v12)
      {
        case 1:
          CFDictionaryRef v22 = "umts";
          break;
        case 2:
          CFDictionaryRef v22 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_41;
        case 4:
          CFDictionaryRef v22 = "lte";
          break;
        case 8:
          break;
        default:
          if ("gsm" == 16)
          {
            CFDictionaryRef v22 = "scdma";
          }
          else if ("gsm" == 32)
          {
            CFDictionaryRef v22 = "nr";
          }
          else
          {
LABEL_41:
            CFDictionaryRef v22 = "unknown";
          }
          break;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v22;
      uint64_t v29 = v20;
      char v30 = "#I Device %s has database type %s which we don't support";
      uint32_t v31 = 22;
LABEL_46:
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v30, buf, v31);
      goto LABEL_47;
    }
    uint64_t v23 = sub_100299430(v10, v15, (_DWORD *)v9 + 8);
    if (*((char *)v23 + 63) < 0)
    {
      if (!v23[6])
      {
LABEL_38:
        uint64_t v27 = *(NSObject **)(a1 + 32);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_47;
        }
        uint64_t v28 = "gsm";
        switch(*v12)
        {
          case 1:
            uint64_t v28 = "umts";
            break;
          case 2:
            uint64_t v28 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_124;
          case 4:
            uint64_t v28 = "lte";
            break;
          case 8:
            break;
          default:
            if ("gsm" == 16)
            {
              uint64_t v28 = "scdma";
            }
            else if ("gsm" == 32)
            {
              uint64_t v28 = "nr";
            }
            else
            {
LABEL_124:
              uint64_t v28 = "unknown";
            }
            break;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v28;
        uint64_t v29 = v27;
        char v30 = "#I We don't have version info for the supported db %s, (possibly using bootstrap database)";
        uint32_t v31 = 12;
        goto LABEL_46;
      }
    }
    else if (!*((unsigned char *)v23 + 63))
    {
      goto LABEL_38;
    }
    if (*((char *)v9 + 63) < 0)
    {
      if (!v9[6])
      {
LABEL_55:
        long long v35 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          if (v75 >= 0) {
            long long v36 = &v74;
          }
          else {
            long long v36 = (long long *)v74;
          }
          sub_100A0BC94(__p, *v12);
          int v37 = v79;
          uint64_t v38 = (void **)__p[0];
          xpc_object_t v39 = sub_100299430(v72, *v12, (_DWORD *)v9 + 8);
          if (v37 >= 0) {
            long long v40 = __p;
          }
          else {
            long long v40 = v38;
          }
          long long v41 = v39 + 5;
          if (*((char *)v39 + 63) < 0) {
            long long v41 = (void *)*v41;
          }
          unint64_t v10 = (uint64_t **)(a1 + 120);
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = v36;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v40;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = v41;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Device %s has %s db with no associated version info (possibly using bootstrap database), our version is %s, so it needs the resources for this db", buf, 0x20u);
          if (v79 < 0) {
            operator delete(__p[0]);
          }
        }
        memset(buf, 0, 48);
        long long v42 = sub_100299430(v10, *v12, (_DWORD *)v9 + 8);
        if (*((char *)v42 + 63) < 0)
        {
          sub_10004FC84(buf, v42[5], (unint64_t)v42[6]);
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)(v42 + 5);
          *(void *)&uint8_t buf[16] = v42[7];
        }
        int v63 = sub_100299430(v10, *v12, (_DWORD *)v9 + 8);
        if ((*((char *)v63 + 87) & 0x80000000) == 0)
        {
          *(_OWORD *)&unsigned char buf[24] = *((_OWORD *)v63 + 4);
          *(void *)&uint8_t buf[40] = v63[10];
LABEL_117:
          sub_100A0B5C4((uint64_t)&v80, (int *)v9 + 8, (_DWORD *)v9 + 8, (long long *)buf);
          if ((char)buf[47] < 0) {
            operator delete(*(void **)&buf[24]);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_47;
        }
LABEL_116:
        sub_10004FC84(&buf[24], v63[8], (unint64_t)v63[9]);
        goto LABEL_117;
      }
    }
    else if (!*((unsigned char *)v9 + 63))
    {
      goto LABEL_55;
    }
    BOOL v24 = sub_100299430(v10, *v12, (_DWORD *)v9 + 8);
    if (*((char *)v9 + 63) < 0)
    {
      int v26 = v9[5];
      size_t v25 = (size_t)v9[6];
    }
    else
    {
      size_t v25 = *((unsigned __int8 *)v9 + 63);
      int v26 = (char *)(v9 + 5);
    }
    long long v45 = v24[5];
    long long v43 = v24 + 5;
    uint64_t v44 = v45;
    int v46 = *((char *)v43 + 23);
    if (v46 >= 0) {
      size_t v47 = *((unsigned __int8 *)v43 + 23);
    }
    else {
      size_t v47 = (size_t)v43[1];
    }
    if (v46 >= 0) {
      uint64_t v48 = v43;
    }
    else {
      uint64_t v48 = (uint64_t **)v44;
    }
    if (v47 >= v25) {
      size_t v49 = v25;
    }
    else {
      size_t v49 = v47;
    }
    int v50 = memcmp(v26, v48, v49);
    if (v50) {
      BOOL v51 = v50 < 0;
    }
    else {
      BOOL v51 = v25 < v47;
    }
    long long v52 = *(NSObject **)(a1 + 32);
    BOOL v53 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
    if (v51)
    {
      unint64_t v10 = (uint64_t **)(a1 + 120);
      if (v53)
      {
        if (v75 >= 0) {
          int v54 = &v74;
        }
        else {
          int v54 = (long long *)v74;
        }
        sub_100A0BC94(__p, *v12);
        int v55 = __p;
        if (v79 < 0) {
          int v55 = (void **)__p[0];
        }
        v69 = v55;
        if (*((char *)v9 + 63) < 0) {
          std::string::size_type v14 = (void *)*v14;
        }
        uint64_t v56 = sub_100299430(v72, *v12, (_DWORD *)v9 + 8);
        v57 = v56 + 5;
        if (*((char *)v56 + 63) < 0) {
          v57 = (void *)*v57;
        }
        *(_DWORD *)std::string buf = 136315906;
        *(void *)&uint8_t buf[4] = v54;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v69;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v14;
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = v57;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Device %s has %s version %s < our version %s, so it needs the resources for this db", buf, 0x2Au);
        if (v79 < 0) {
          operator delete(__p[0]);
        }
      }
      memset(buf, 0, 48);
      CFStringRef v58 = sub_100299430(v72, *v12, (_DWORD *)v9 + 8);
      if (*((char *)v58 + 63) < 0)
      {
        sub_10004FC84(buf, v58[5], (unint64_t)v58[6]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)(v58 + 5);
        *(void *)&uint8_t buf[16] = v58[7];
      }
      int v63 = sub_100299430(v72, *v12, (_DWORD *)v9 + 8);
      if ((*((char *)v63 + 87) & 0x80000000) == 0)
      {
        *(_OWORD *)&unsigned char buf[24] = *((_OWORD *)v63 + 4);
        *(void *)&uint8_t buf[40] = v63[10];
        goto LABEL_117;
      }
      goto LABEL_116;
    }
    unint64_t v10 = (uint64_t **)(a1 + 120);
    if (v53)
    {
      if (v75 >= 0) {
        unint64_t v59 = &v74;
      }
      else {
        unint64_t v59 = (long long *)v74;
      }
      sub_100A0BC94(__p, *v12);
      v60 = __p;
      if (v79 < 0) {
        v60 = (void **)__p[0];
      }
      uint64_t v70 = v60;
      if (*((char *)v9 + 63) < 0) {
        std::string::size_type v14 = (void *)*v14;
      }
      int v61 = sub_100299430(v72, *v12, (_DWORD *)v9 + 8);
      int v62 = v61 + 5;
      if (*((char *)v61 + 63) < 0) {
        int v62 = (void *)*v62;
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v59;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v70;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v14;
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = v62;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Device %s has %s version %s >= our version %s, so it doesn't need the resources for this db", buf, 0x2Au);
      if (v79 < 0) {
        operator delete(__p[0]);
      }
    }
LABEL_47:
    CFTypeRef v32 = v9[1];
    if (v32)
    {
      do
      {
        CFTypeRef v33 = (char **)v32;
        CFTypeRef v32 = *(char **)v32;
      }
      while (v32);
    }
    else
    {
      do
      {
        CFTypeRef v33 = (char **)v9[2];
        BOOL v34 = *v33 == (char *)v9;
        unint64_t v9 = v33;
      }
      while (!v34);
    }
    unint64_t v9 = v33;
  }
  while (v33 != v77);
  unint64_t v5 = v71;
  uint64_t v6 = a1 + 144;
  if (v82)
  {
    if (sub_100A0ADC0(*(Registry **)(a1 + 40), v82))
    {
      int v64 = *(NSObject **)(a1 + 32);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        if (v75 >= 0) {
          int v65 = &v74;
        }
        else {
          int v65 = (long long *)v74;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v65;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I Sharing database file(s) with device %s", buf, 0xCu);
      }
      sub_100A0B7BC((uint64_t *)buf, (uint64_t)&v80);
      uint64_t v66 = *(void *)(a1 + 112);
      if (!v66) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v66 + 48))(v66, buf);
      sub_10019D5B8((uint64_t)buf, *(void **)&buf[8]);
    }
    goto LABEL_144;
  }
LABEL_138:
  int v67 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
  {
    if (v75 >= 0) {
      v68 = &v74;
    }
    else {
      v68 = (long long *)v74;
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v68;
    _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I Don't need to share any database file with device %s at the current state", buf, 0xCu);
  }
  sub_1009A3B74(v6, (unsigned __int8 *)&v74, (uint64_t)&v74);
LABEL_144:
  sub_10019D5B8((uint64_t)&v80, v81);
LABEL_145:
  os_unfair_lock_unlock(v5);
  sub_1000886C0((uint64_t)&v76, v77[0]);
  if (SHIBYTE(v75) < 0) {
    operator delete((void *)v74);
  }
}

void sub_100A09C70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a2)
  {
    if (a41 < 0) {
      operator delete(__p);
    }
    sub_10019D5B8(v41 - 184, *(void **)(v41 - 176));
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A09D7C(uint64_t a1, uint64_t a2)
{
  sub_100A0B7BC((uint64_t *)&v53, a2);
  uint64_t v3 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  int v55 = &v56;
  int v4 = v53;
  if (v53 == v54) {
    goto LABEL_122;
  }
  size_t v49 = v3;
  BOOL v51 = (uint64_t **)(a1 + 128);
  do
  {
    if (*((char *)v4 + 87) < 0) {
      unint64_t v5 = v4[9];
    }
    else {
      unint64_t v5 = (void *)*((unsigned __int8 *)v4 + 87);
    }
    uint64_t v6 = (int *)(v4 + 4);
    if (!v5)
    {
      uint64_t v16 = *(NSObject **)(a1 + 32);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        goto LABEL_62;
      }
      int v17 = "gsm";
      switch(*v6)
      {
        case 1:
          int v17 = "umts";
          break;
        case 2:
          int v17 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_81;
        case 4:
          int v17 = "lte";
          break;
        case 8:
          break;
        default:
          if ("gsm" == 16)
          {
            int v17 = "scdma";
          }
          else if ("gsm" == 32)
          {
            int v17 = "nr";
          }
          else
          {
LABEL_81:
            int v17 = "unknown";
          }
          break;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      long long v40 = v16;
      uint64_t v41 = "Incoming %s database has no file associated with it";
      goto LABEL_119;
    }
    if (*((char *)v4 + 63) < 0)
    {
      if (v4[6]) {
        goto LABEL_9;
      }
LABEL_26:
      BOOL v18 = *(NSObject **)(a1 + 32);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_62;
      }
      unint64_t v19 = "gsm";
      switch(*v6)
      {
        case 1:
          unint64_t v19 = "umts";
          break;
        case 2:
          unint64_t v19 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_92;
        case 4:
          unint64_t v19 = "lte";
          break;
        case 8:
          break;
        default:
          if ("gsm" == 16)
          {
            unint64_t v19 = "scdma";
          }
          else if ("gsm" == 32)
          {
            unint64_t v19 = "nr";
          }
          else
          {
LABEL_92:
            unint64_t v19 = "unknown";
          }
          break;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v19;
      long long v40 = v18;
      uint64_t v41 = "Incoming %s database has no version associated with it";
LABEL_119:
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v41, buf, 0xCu);
      goto LABEL_62;
    }
    if (!*((unsigned char *)v4 + 63)) {
      goto LABEL_26;
    }
LABEL_9:
    if (!*v51) {
      goto LABEL_19;
    }
    unint64_t v7 = v4 + 8;
    int v8 = *v6;
    unint64_t v9 = (uint64_t *)(a1 + 128);
    unint64_t v10 = *v51;
    do
    {
      int v11 = *((_DWORD *)v10 + 8);
      BOOL v12 = v11 < v8;
      if (v11 >= v8) {
        uint64_t v13 = (uint64_t **)v10;
      }
      else {
        uint64_t v13 = (uint64_t **)(v10 + 1);
      }
      if (!v12) {
        unint64_t v9 = v10;
      }
      unint64_t v10 = *v13;
    }
    while (*v13);
    if (v9 == (uint64_t *)v51 || v8 < *((_DWORD *)v9 + 8))
    {
LABEL_19:
      std::string::size_type v14 = *(NSObject **)(a1 + 32);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_62;
      }
      int v15 = "gsm";
      switch(*v6)
      {
        case 1:
          int v15 = "umts";
          break;
        case 2:
          int v15 = "cdma";
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          goto LABEL_56;
        case 4:
          int v15 = "lte";
          break;
        case 8:
          break;
        default:
          if ("gsm" == 16)
          {
            int v15 = "scdma";
          }
          else if ("gsm" == 32)
          {
            int v15 = "nr";
          }
          else
          {
LABEL_56:
            int v15 = "unknown";
          }
          break;
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v15;
      BOOL v34 = v14;
      long long v35 = "#I Incoming %s database is not supported";
      uint32_t v36 = 12;
      goto LABEL_61;
    }
    long long v20 = sub_1000389F8(*v51, v8);
    int v21 = *((char *)v4 + 63);
    int v22 = *((char *)v20 + 23);
    if (v22 >= 0) {
      size_t v23 = *((unsigned __int8 *)v20 + 23);
    }
    else {
      size_t v23 = v20[1];
    }
    if (v22 < 0) {
      long long v20 = (uint64_t *)*v20;
    }
    if (v21 >= 0) {
      size_t v24 = *((unsigned __int8 *)v4 + 63);
    }
    else {
      size_t v24 = (size_t)v4[6];
    }
    if (v21 >= 0) {
      size_t v25 = v4 + 5;
    }
    else {
      size_t v25 = v4[5];
    }
    if (v24 >= v23) {
      size_t v26 = v23;
    }
    else {
      size_t v26 = v24;
    }
    int v50 = v25;
    int v27 = memcmp(v20, v25, v26);
    if (v27) {
      BOOL v28 = v27 < 0;
    }
    else {
      BOOL v28 = v23 < v24;
    }
    uint64_t v29 = *(NSObject **)(a1 + 32);
    BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
    if (v28)
    {
      if (v30)
      {
        uint32_t v31 = "gsm";
        switch(*v6)
        {
          case 1:
            uint32_t v31 = "umts";
            break;
          case 2:
            uint32_t v31 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_82;
          case 4:
            uint32_t v31 = "lte";
            break;
          case 8:
            break;
          default:
            if ("gsm" == 16)
            {
              uint32_t v31 = "scdma";
            }
            else if ("gsm" == 32)
            {
              uint32_t v31 = "nr";
            }
            else
            {
LABEL_82:
              uint32_t v31 = "unknown";
            }
            break;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v31;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v50;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Incoming %s database with version %s will be used for updating", buf, 0x16u);
        LOBYTE(v21) = *((unsigned char *)v4 + 63);
      }
      memset(buf, 0, sizeof(buf));
      if ((v21 & 0x80) != 0)
      {
        sub_10004FC84(buf, v4[5], (unint64_t)v4[6]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)(v4 + 5);
        *(void *)&uint8_t buf[16] = v4[7];
      }
      if (*((char *)v4 + 87) < 0)
      {
        sub_10004FC84(&buf[24], v4[8], (unint64_t)v4[9]);
      }
      else
      {
        *(_OWORD *)&unsigned char buf[24] = *v7;
        *(void *)&uint8_t buf[40] = v4[10];
      }
      sub_100A0B5C4((uint64_t)&v55, (int *)v4 + 8, (_DWORD *)v4 + 8, (long long *)buf);
      if ((char)buf[47] < 0) {
        operator delete(*(void **)&buf[24]);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      if (v30)
      {
        int v32 = *v6;
        CFTypeRef v33 = "gsm";
        switch(*v6)
        {
          case 1:
            CFTypeRef v33 = "umts";
            break;
          case 2:
            CFTypeRef v33 = "cdma";
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_83;
          case 4:
            CFTypeRef v33 = "lte";
            break;
          case 8:
            break;
          default:
            if (v32 == 16)
            {
              CFTypeRef v33 = "scdma";
            }
            else if (v32 == 32)
            {
              CFTypeRef v33 = "nr";
            }
            else
            {
LABEL_83:
              CFTypeRef v33 = "unknown";
            }
            break;
        }
        long long v42 = sub_1000389F8(*v51, v32);
        if (*((char *)v42 + 23) >= 0) {
          uint64_t v43 = (uint64_t)v42;
        }
        else {
          uint64_t v43 = *v42;
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v33;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v50;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v43;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Incoming %s database with version %s <= our version %s will not be used for updating", buf, 0x20u);
      }
      uint64_t v44 = (*(uint64_t (**)(void, void **))(**(void **)(a1 + 56) + 112))(*(void *)(a1 + 56), v4 + 8);
      int v45 = v44;
      if (v44)
      {
        int v46 = *(NSObject **)(a1 + 32);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v4 + 87) < 0) {
            unint64_t v7 = *(_OWORD **)v7;
          }
          size_t v47 = strerror(v45);
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v7;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v47;
          BOOL v34 = v46;
          long long v35 = "#N Could not remove %s file: %s";
          uint32_t v36 = 22;
LABEL_61:
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v35, buf, v36);
        }
      }
    }
LABEL_62:
    int v37 = v4[1];
    if (v37)
    {
      do
      {
        uint64_t v38 = (void **)v37;
        int v37 = (void *)*v37;
      }
      while (v37);
    }
    else
    {
      do
      {
        uint64_t v38 = (void **)v4[2];
        BOOL v39 = *v38 == v4;
        int v4 = v38;
      }
      while (!v39);
    }
    int v4 = v38;
  }
  while (v38 != v54);
  uint64_t v3 = v49;
  if (v57)
  {
    (*(void (**)(void, void ***))(**(void **)(a1 + 72) + 88))(*(void *)(a1 + 72), &v55);
    goto LABEL_124;
  }
LABEL_122:
  uint64_t v48 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I Incoming database resources will not be used for updating", buf, 2u);
  }
LABEL_124:
  sub_10019D5B8((uint64_t)&v55, v56);
  os_unfair_lock_unlock(v3);
  sub_10019D5B8((uint64_t)&v53, v54[0]);
}

void sub_100A0A5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,void *a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10019D5B8((uint64_t)&a24, a25);
  sub_10006A6AC(exception_object);
}

void sub_100A0A6B8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  *(void *)(a2 + 8) = 0;
  unint64_t v5 = (uint64_t **)(a2 + 8);
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = a2 + 8;
  uint64_t v6 = *(void **)(a1 + 120);
  unint64_t v7 = (void *)(a1 + 128);
  if (v6 != (void *)(a1 + 128))
  {
    do
    {
      int v8 = *((_DWORD *)v6 + 8);
      unint64_t v9 = (uint64_t **)(a2 + 8);
      unint64_t v10 = (uint64_t **)(a2 + 8);
      if (*v5)
      {
        int v11 = *v5;
        while (1)
        {
          while (1)
          {
            unint64_t v10 = (uint64_t **)v11;
            int v12 = *((_DWORD *)v11 + 8);
            if (v12 <= v8) {
              break;
            }
            int v11 = *v10;
            unint64_t v9 = v10;
            if (!*v10) {
              goto LABEL_10;
            }
          }
          if (v12 >= v8) {
            break;
          }
          int v11 = v10[1];
          if (!v11)
          {
            unint64_t v9 = v10 + 1;
            goto LABEL_10;
          }
        }
      }
      else
      {
LABEL_10:
        uint64_t v13 = (char *)operator new(0x40uLL);
        *((_DWORD *)v13 + 8) = v8;
        std::string::size_type v14 = v13 + 40;
        if (*((char *)v6 + 63) < 0)
        {
          sub_10004FC84(v14, (void *)v6[5], v6[6]);
        }
        else
        {
          long long v15 = *(_OWORD *)(v6 + 5);
          *((void *)v13 + 7) = v6[7];
          *(_OWORD *)std::string::size_type v14 = v15;
        }
        sub_100046C38((uint64_t **)a2, (uint64_t)v10, v9, (uint64_t *)v13);
      }
      uint64_t v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          int v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          int v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          uint64_t v6 = v17;
        }
        while (!v18);
      }
      uint64_t v6 = v17;
    }
    while (v17 != v7);
  }

  os_unfair_lock_unlock(v4);
}

void sub_100A0A828(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_10008CD08(a9, v11);
  sub_1000886C0(v10, *v12);
  sub_10006A6AC(a1);
}

void sub_100A0A85C(uint64_t a1, uint64_t a2)
{
  sub_100A0BD40((uint64_t *)&v46, a2);
  uint64_t v3 = (os_unfair_lock_s *)(a1 + 24);
  os_unfair_lock_lock(v3);
  uint64_t v4 = a1;
  unint64_t v5 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Applying the update information to current state", buf, 2u);
  }
  uint64_t v6 = v46;
  if (v46 != v47)
  {
    char v44 = 0;
    uint64_t v7 = a1 + 184;
    int v8 = (std::string *)&__p[1];
    unint64_t v9 = (uint64_t **)(a1 + 120);
    uint64_t v10 = (uint64_t **)(a1 + 128);
    do
    {
      if (!*((_DWORD *)v6 + 10) && *((unsigned char *)v6 + 72))
      {
        *(_OWORD *)long long __p = 0u;
        long long v50 = 0u;
        *(_OWORD *)std::string buf = 0u;
        if (*((char *)v6 + 71) < 0)
        {
          sub_10004FC84(buf, v6[6], (unint64_t)v6[7]);
        }
        else
        {
          *(_OWORD *)std::string buf = *((_OWORD *)v6 + 3);
          __p[0] = v6[8];
        }
        std::string::size_type v14 = (int *)(v6 + 4);
        long long v15 = sub_100A0B31C(v7, *((_DWORD *)v6 + 8), (_DWORD *)v6 + 8);
        if (*((char *)v15 + 47) < 0)
        {
          sub_10004FC84(v8, (void *)v15[3], v15[4]);
        }
        else
        {
          long long v16 = *(_OWORD *)(v15 + 3);
          v8->__r_.__value_.__r.__words[2] = v15[5];
          *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v16;
        }
        if (!*v10) {
          goto LABEL_30;
        }
        int v17 = *v14;
        BOOL v18 = v10;
        unint64_t v19 = *v10;
        do
        {
          int v20 = *((_DWORD *)v19 + 8);
          BOOL v21 = v20 < v17;
          if (v20 >= v17) {
            int v22 = (uint64_t **)v19;
          }
          else {
            int v22 = (uint64_t **)(v19 + 1);
          }
          if (!v21) {
            BOOL v18 = (uint64_t **)v19;
          }
          unint64_t v19 = *v22;
        }
        while (*v22);
        if (v18 != v10 && v17 >= *((_DWORD *)v18 + 8))
        {
          size_t v24 = sub_1000389F8(*v10, v17);
          uint64_t v25 = *((unsigned __int8 *)v24 + 23);
          if ((v25 & 0x80u) != 0) {
            uint64_t v25 = v24[1];
          }
          if (!v25) {
            goto LABEL_59;
          }
          size_t v26 = sub_1000389F8(*v10, *v14);
          int v27 = *((char *)v26 + 23);
          if (v27 >= 0) {
            size_t v28 = *((unsigned __int8 *)v26 + 23);
          }
          else {
            size_t v28 = v26[1];
          }
          if (v27 < 0) {
            size_t v26 = (uint64_t *)*v26;
          }
          uint64_t v43 = v10;
          uint64_t v29 = v8;
          uint64_t v30 = v4;
          uint64_t v31 = v7;
          int v32 = v9;
          CFTypeRef v33 = v3;
          if (SHIBYTE(__p[0]) >= 0) {
            size_t v34 = HIBYTE(__p[0]);
          }
          else {
            size_t v34 = *(void *)&buf[8];
          }
          if (SHIBYTE(__p[0]) >= 0) {
            long long v35 = buf;
          }
          else {
            long long v35 = *(uint8_t **)buf;
          }
          if (v34 >= v28) {
            size_t v36 = v28;
          }
          else {
            size_t v36 = v34;
          }
          int v37 = memcmp(v26, v35, v36);
          BOOL v38 = v28 >= v34;
          uint64_t v3 = v33;
          unint64_t v9 = v32;
          uint64_t v7 = v31;
          uint64_t v4 = v30;
          int v8 = v29;
          uint64_t v10 = v43;
          BOOL v39 = !v38;
          if (v37) {
            BOOL v39 = v37 < 0;
          }
          if (v39)
          {
LABEL_59:
            long long v40 = sub_100299430(v9, *v14, (_DWORD *)v6 + 8);
            std::string::operator=((std::string *)(v40 + 5), (const std::string *)buf);
            std::string::operator=((std::string *)(v40 + 8), v8);
            char v44 = 1;
          }
        }
        else
        {
LABEL_30:
          size_t v23 = *(NSObject **)(v4 + 32);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            uint64_t v41 = "gsm";
            switch(*v14)
            {
              case 1:
                uint64_t v41 = "umts";
                break;
              case 2:
                uint64_t v41 = "cdma";
                break;
              case 3:
              case 5:
              case 6:
              case 7:
                goto LABEL_65;
              case 4:
                uint64_t v41 = "lte";
                break;
              case 8:
                break;
              default:
                if ("gsm" == 16)
                {
                  uint64_t v41 = "scdma";
                }
                else if ("gsm" == 32)
                {
                  uint64_t v41 = "nr";
                }
                else
                {
LABEL_65:
                  uint64_t v41 = "unknown";
                }
                break;
            }
            *(_DWORD *)BOOL v51 = 136315138;
            long long v52 = v41;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Database %s updated successfully, but is not being tracked", v51, 0xCu);
          }
          sub_100A0B5C4((uint64_t)v9, (int *)v6 + 8, (_DWORD *)v6 + 8, (long long *)buf);
        }
        if (SHIBYTE(v50) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(*(void **)buf);
        }
      }
      int v11 = v6[1];
      if (v11)
      {
        do
        {
          int v12 = (char **)v11;
          int v11 = *(char **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (char **)v6[2];
          BOOL v13 = *v12 == (char *)v6;
          uint64_t v6 = v12;
        }
        while (!v13);
      }
      uint64_t v6 = v12;
    }
    while (v12 != v47);
    if (v44)
    {
      long long v42 = *(NSObject **)(v4 + 32);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Clearing out the fDevicesWithRequirementsMet record", buf, 2u);
      }
      sub_100A0BFBC(v4 + 144);
    }
  }
  os_unfair_lock_unlock(v3);
  sub_100A0AF80((uint64_t)&v46, v47[0]);
}

void sub_100A0ACF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

void sub_100A0AD64(os_unfair_lock_s *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = a1 + 6;
  os_unfair_lock_lock(a1 + 6);
  uint64_t v3 = *(void **)&v1[32]._os_unfair_lock_opaque;
  v1 += 32;
  sub_10019D5B8((uint64_t)&v1[-2], v3);
  *(void *)&v1[-2]._os_unfair_lock_opaque = v1;
  *(void *)&v1->_os_unfair_lock_opaque = 0;
  *(void *)&v1[2]._os_unfair_lock_opaque = 0;
  sub_100A0BFBC((uint64_t)&v1[4]);

  os_unfair_lock_unlock(v2);
}

uint64_t sub_100A0ADC0@<X0>(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    unint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v14);
  if (v8)
  {
    uint64_t v10 = (GestaltUtilityInterface *)v8[3];
    unint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  unint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  uint64_t isIPhone = GestaltUtilityInterface::isIPhone(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return isIPhone;
}

void sub_100A0AEA4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0AEC4(uint64_t a1)
{
  sub_100A0AFEC(a1);

  operator delete();
}

void *sub_100A0AEFC(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100A0AF80(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100A0AF80(a1, *(void *)a2);
    sub_100A0AF80(a1, *((void *)a2 + 1));
    if (a2[72] && a2[71] < 0) {
      operator delete(*((void **)a2 + 6));
    }
    operator delete(a2);
  }
}

void sub_100A0AFEC(uint64_t a1)
{
  *(void *)a1 = off_101A293E0;
  sub_100A0B1FC(a1 + 184);
  sub_1004DD39C(a1 + 144);
  sub_10019D5B8(a1 + 120, *(void **)(a1 + 128));
  sub_100A0AEFC((void *)(a1 + 88));
  char v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  LASDDatabaseIDSStateManagerInterface::~LASDDatabaseIDSStateManagerInterface((LASDDatabaseIDSStateManagerInterface *)a1);
}

void sub_100A0B094(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A0B114(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0B150(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A0B188(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t sub_100A0B1B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A0B1FC(uint64_t a1)
{
  sub_100A0B238(a1, *(void ***)(a1 + 16));
  char v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100A0B238(int a1, void **__p)
{
  if (__p)
  {
    char v2 = __p;
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 47) < 0) {
        operator delete(v2[3]);
      }
      operator delete(v2);
      char v2 = v3;
    }
    while (v3);
  }
}

uint64_t sub_100A0B284(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100A0B31C(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  int v12 = (void *)(a1 + 16);
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  void v10[5] = 0;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_1001369F0(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v19 = *(void *)a1;
  int v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    void *v10 = *v20;
LABEL_38:
    *int v20 = v10;
    goto LABEL_39;
  }
  void *v10 = *v12;
  *int v12 = v10;
  *(void *)(v19 + 8 * v8) = v12;
  if (*v10)
  {
    unint64_t v21 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6) {
        v21 %= v6;
      }
    }
    else
    {
      v21 &= v6 - 1;
    }
    int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_100A0B548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_100A0B564(v11, v10);
  _Unwind_Resume(a1);
}

void sub_100A0B564(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 47) < 0) {
      operator delete(__p[3]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *sub_100A0B5C4(uint64_t a1, int *a2, _DWORD *a3, long long *a4)
{
  unint64_t v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t *)v5;
        int v9 = *(_DWORD *)(v5 + 32);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        unint64_t v6 = (uint64_t **)v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v8 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v8 = (uint64_t *)(a1 + 8);
LABEL_10:
    memset(v11, 0, sizeof(v11));
    sub_100A0B694(a1, a3, a4, v11);
    sub_100046C38((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    unint64_t v8 = v11[0];
    v11[0] = 0;
    sub_1001A7E1C((uint64_t)v11, 0);
  }
  return v8;
}

uint64_t sub_100A0B694@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, long long *a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 8;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  unint64_t v8 = operator new(0x58uLL);
  *a4 = v8;
  a4[1] = v7;
  *((unsigned char *)a4 + 16) = 0;
  uint64_t result = sub_100A0B710((uint64_t)v8 + 32, a2, a3);
  *((unsigned char *)a4 + 16) = 1;
  return result;
}

void sub_100A0B6F8(_Unwind_Exception *a1)
{
  sub_1001A7E1C(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100A0B710(uint64_t a1, _DWORD *a2, long long *a3)
{
  *(_DWORD *)a1 = *a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v5;
  }
  unint64_t v6 = (unsigned char *)(a1 + 32);
  if (*((char *)a3 + 47) < 0)
  {
    sub_10004FC84(v6, *((void **)a3 + 3), *((void *)a3 + 4));
  }
  else
  {
    long long v7 = *(long long *)((char *)a3 + 24);
    *(void *)(a1 + 48) = *((void *)a3 + 5);
    *(_OWORD *)unint64_t v6 = v7;
  }
  return a1;
}

void sub_100A0B7A0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100A0B7BC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100A0B814(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A0B7FC(_Unwind_Exception *a1)
{
  sub_10019D5B8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100A0B814(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    long long v5 = (uint64_t **)result;
    unint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100A0B8A0(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      long long v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          long long v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }
        while (!v9);
      }
      unint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100A0B8A0(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v11 = 0;
  int v12 = 0;
  unint64_t v6 = sub_1000262C0(a1, a2, &v12, &v11, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_100A0B944((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    sub_1001A7E1C((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_100A0B944@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t v6 = operator new(0x58uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_100A0B9B8((uint64_t)v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A0B9A0(_Unwind_Exception *a1)
{
  sub_1001A7E1C(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100A0B9B8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_100A0BA4C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100A0BA68(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100A0BAC0(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A0BAA8(_Unwind_Exception *a1)
{
  sub_1000886C0(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100A0BAC0(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    long long v6 = result + 1;
    do
    {
      uint64_t result = sub_100A0BB4C(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      long long v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          long long v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100A0BB4C(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  long long v6 = (uint64_t **)sub_1000262C0(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100A0BBDC((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

void *sub_100A0BBDC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  long long v6 = a3 + 1;
  long long v7 = operator new(0x40uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  v7[8] = *(_DWORD *)a2;
  uint64_t result = v7 + 10;
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)(a2 + 8);
    result[2] = *(void *)(a2 + 24);
  }
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A0BC78(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_10008CD08(v2, v3);
  _Unwind_Resume(a1);
}

void *sub_100A0BC94(void *a1, int a2)
{
  switch(a2)
  {
    case 1:
      uint64_t v2 = "umts";
      break;
    case 2:
      uint64_t v2 = "cdma";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_7;
    case 4:
      uint64_t v2 = "lte";
      break;
    case 8:
      uint64_t v2 = "gsm";
      break;
    default:
      if (a2 == 16)
      {
        uint64_t v2 = "scdma";
      }
      else if (a2 == 32)
      {
        uint64_t v2 = "nr";
      }
      else
      {
LABEL_7:
        uint64_t v2 = 0;
      }
      break;
  }
  return sub_100058DB0(a1, v2);
}

uint64_t *sub_100A0BD40(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100A0BD98(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A0BD80(_Unwind_Exception *a1)
{
  sub_100A0AF80(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100A0BD98(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    long long v6 = result + 1;
    do
    {
      uint64_t result = sub_100A0BE24(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      long long v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          long long v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100A0BE24(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  long long v6 = (uint64_t **)sub_1000262C0(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_100A0BEB4((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

uint64_t sub_100A0BEB4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  long long v6 = a3 + 1;
  long long v7 = operator new(0x50uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  v7[8] = *(_DWORD *)a2;
  *((void *)v7 + 5) = *(void *)(a2 + 8);
  uint64_t result = sub_1000593FC((uint64_t)(v7 + 12), (long long *)(a2 + 16));
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A0BF38(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_100A0BF54(v2, v3);
  _Unwind_Resume(a1);
}

void sub_100A0BF54(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((unsigned char *)__p + 72) && *((char *)__p + 71) < 0) {
      operator delete(__p[6]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_100A0BFBC(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1004DD3D8(a1, *(void ***)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void sub_100A0C014(uint64_t a1)
{
  *(void *)a1 = off_101A29570;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (void *)(a1 + 40);
  uint64_t v3 = v4;
  *uint64_t v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v5) {
    sub_100206334(a1 + 32, v5);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v6) {
    sub_100206334(a1 + 24, v6);
  }
  sub_100110A40((void ***)(a1 + 16), 0);
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v7) {
    sub_100206334(a1 + 8, v7);
  }

  PB::Base::~Base((PB::Base *)a1);
}

void sub_100A0C0C0(uint64_t a1)
{
  sub_100A0C014(a1);

  operator delete();
}

uint64_t sub_100A0C0F8(uint64_t result, uint64_t a2)
{
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)uint64_t result = off_101A29570;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 52) = 0;
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  if (*(unsigned char *)(a2 + 52))
  {
    int v2 = *(_DWORD *)(a2 + 48);
    *(unsigned char *)(result + 52) |= 1u;
    *(_DWORD *)(result + 48) = v2;
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A0C36C(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  uint64_t v5 = *(const PB::Data **)(a1 + 16);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(unsigned char *)(a1 + 52)) {
    PB::TextFormatter::format(this, "subscriptionStatus", *(_DWORD *)(a1 + 48));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100A0C444(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_47:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        *(unsigned char *)(a1 + 52) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_46;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_42:
          LODWORD(v27) = 0;
          goto LABEL_46;
        }
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        break;
      case 4u:
        operator new();
      case 5u:
        operator new();
      case 6u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v23 == v22)
      {
        LODWORD(v27) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_46;
      }
      unint64_t v32 = v22 + 1;
      char v33 = *(unsigned char *)(v24 + v22);
      *((void *)this + 1) = v32;
      v27 |= (unint64_t)(v33 & 0x7F) << v30;
      if ((v33 & 0x80) == 0) {
        break;
      }
      v30 += 7;
      unint64_t v22 = v32;
      BOOL v14 = v31++ > 8;
      if (v14) {
        goto LABEL_42;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v27) = 0;
    }
LABEL_46:
    *(_DWORD *)(a1 + 48) = v27;
    goto LABEL_47;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_100A0C880(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 16);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(void *)(v3 + 24)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(unsigned char *)(v3 + 52)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 48), 3u);
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 8))
  {
    return PB::Writer::write();
  }
  return result;
}

uint64_t sub_100A0C938()
{
  return 0;
}

uint64_t sub_100A0C940(uint64_t a1, uint64_t a2)
{
  unsigned int v12 = 0;
  if (!sub_100FECA8C(a2, (int *)&v12)) {
    return 0;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  uint64_t v4 = *(unsigned int *)(a2 + 20);
  if (v5 - v4 < v12) {
    return 0;
  }
  if (v5 <= v4)
  {
    int v7 = *(unsigned __int8 *)(a1 + 36);
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 8);
    *(_DWORD *)(a2 + 20) = v4 + 1;
    int v7 = *(unsigned __int8 *)(v6 + v4);
    *(unsigned char *)(a1 + 36) = v7;
  }
  if ((char)v7 >= -126)
  {
    char v9 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 8);
      unint64_t v11 = (void *)(v10 + 8);
      if (*(char *)(v10 + 31) < 0) {
        unint64_t v11 = (void *)*v11;
      }
      *(_DWORD *)std::string buf = 67109378;
      int v14 = v7;
      __int16 v15 = 2080;
      unsigned int v16 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "unknown date type 0x%.2x for field %s", buf, 0x12u);
    }
    return 0;
  }

  return sub_100FECB30(a2, (int *)(a1 + 32));
}

uint64_t sub_100A0CAAC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)long long __p = 0u;
  long long v9 = 0u;
  LODWORD(__p[0]) = *(_DWORD *)a2;
  uint64_t v10 = 0;
  __p[1] = 0;
  long long v9 = 0uLL;
  std::string::push_back((std::string *)&__p[1], *(unsigned char *)(a1 + 36));
  sub_10078E5C4((uint64_t)__p, *(_DWORD *)(a1 + 32));
  if (v9 >= 0) {
    unsigned int v4 = HIBYTE(v9);
  }
  else {
    unsigned int v4 = v9;
  }
  sub_10078E718(a2, v4);
  if (v9 >= 0) {
    unsigned int v5 = (const std::string::value_type *)&__p[1];
  }
  else {
    unsigned int v5 = (const std::string::value_type *)__p[1];
  }
  if (v9 >= 0) {
    std::string::size_type v6 = HIBYTE(v9);
  }
  else {
    std::string::size_type v6 = v9;
  }
  std::string::append((std::string *)(a2 + 8), v5, v6);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  return 1;
}

void sub_100A0CB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0CB88()
{
}

void sub_100A0CC0C()
{
}

void sub_100A0CC30()
{
}

void sub_100A0CCB0()
{
}

uint64_t sub_100A0CCD4(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)long long __p = 0u;
  memset(v10, 0, sizeof(v10));
  sub_10004DE24((uint64_t)v10);
  unsigned int v4 = (void *)std::ostream::operator<<();
  unsigned int v5 = sub_10004B96C(v4, (uint64_t)", ", 2);
  if (*(unsigned __int8 *)(a1 + 36) == 128) {
    std::string::size_type v6 = "Absolute";
  }
  else {
    std::string::size_type v6 = "Relative";
  }
  sub_10004B96C(v5, (uint64_t)v6, 8);
  sub_10004BC98((uint64_t)v10 + 8, &v8);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v8;
  *(void *)(a2 + 16) = v9;
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return 1;
}

void sub_100A0CE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

const char *sub_100A0CEAC()
{
  return "date";
}

uint64_t sub_100A0CEB8(uint64_t a1)
{
  return a1;
}

void sub_100A0CEE4(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 24));

  operator delete();
}

void sub_100A0CF30(void **a1)
{
  *a1 = off_101A296A0;
  unint64_t v2 = (void ***)(a1 + 1);
  uint64_t v3 = a1 + 2;
  sub_100465E6C(&v3);
  sub_100110A40(v2, 0);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100A0CFA0(void **a1)
{
  sub_100A0CF30(a1);

  operator delete();
}

uint64_t sub_100A0CFD8(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  unsigned int v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(unsigned char *)(a1 + 48)) {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 40));
  }
  std::string::size_type v6 = *(uint64_t **)(a1 + 16);
  int v7 = *(uint64_t **)(a1 + 24);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "pendingProfile");
  }
  if ((*(unsigned char *)(a1 + 48) & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 44));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100A0D0C8(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_26;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_21:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_26:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        sub_100A0D440();
      case 3u:
        *(unsigned char *)(a1 + 48) |= 2u;
        unint64_t v23 = *((void *)this + 1);
        if (v23 >= *((void *)this + 2))
        {
          BOOL v26 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v24 = v23 + 1;
          int v25 = *(unsigned __int8 *)(*(void *)this + v23);
          *((void *)this + 1) = v24;
          BOOL v26 = v25 != 0;
        }
        *(unsigned char *)(a1 + 44) = v26;
        goto LABEL_21;
      case 4u:
        *(unsigned char *)(a1 + 48) |= 1u;
        unint64_t v27 = *((void *)this + 1);
        unint64_t v28 = *((void *)this + 2);
        uint64_t v29 = *(void *)this;
        if (v27 <= 0xFFFFFFFFFFFFFFF5 && v27 + 10 <= v28)
        {
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v32 = 0;
          do
          {
            unint64_t v33 = v27 + 1;
            *((void *)this + 1) = v27 + 1;
            char v34 = *(unsigned char *)(v29 + v27);
            v32 |= (unint64_t)(v34 & 0x7F) << v30;
            if ((v34 & 0x80) == 0) {
              goto LABEL_51;
            }
            v30 += 7;
            unint64_t v27 = v33;
            BOOL v14 = v31++ > 8;
          }
          while (!v14);
LABEL_47:
          LODWORD(v32) = 0;
          goto LABEL_51;
        }
        char v35 = 0;
        unsigned int v36 = 0;
        uint64_t v32 = 0;
        if (v28 <= v27) {
          unint64_t v28 = *((void *)this + 1);
        }
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v28 == v27)
      {
        LODWORD(v32) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_51;
      }
      unint64_t v37 = v27 + 1;
      char v38 = *(unsigned char *)(v29 + v27);
      *((void *)this + 1) = v37;
      v32 |= (unint64_t)(v38 & 0x7F) << v35;
      if ((v38 & 0x80) == 0) {
        break;
      }
      v35 += 7;
      unint64_t v27 = v37;
      BOOL v14 = v36++ > 8;
      if (v14) {
        goto LABEL_47;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v32) = 0;
    }
LABEL_51:
    *(_DWORD *)(a1 + 40) = v32;
    goto LABEL_21;
  }
  int v4 = 0;
  return v4 == 0;
}

void sub_100A0D440()
{
}

void sub_100A0D560(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A0D5A4(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  unsigned int v5 = *(const PB::Base ***)(v3 + 16);
  std::string::size_type v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    int v7 = *v5++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 2u);
  }
  char v8 = *(unsigned char *)(v3 + 48);
  if ((v8 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 44), 3u);
    char v8 = *(unsigned char *)(v3 + 48);
  }
  if (v8)
  {
    unsigned int v9 = *(_DWORD *)(v3 + 40);
    return PB::Writer::writeVarInt(this, v9, 4u);
  }
  return result;
}

void sub_100A0D650(BOOL a1)
{
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = 0uLL;
  uint64_t v9 = 0;
  sub_1006941A8(&object);
  xpc_object_t v2 = xpc_BOOL_create(a1);
  xpc_object_t v3 = v2;
  if (v2)
  {
    xpc_object_t v13 = v2;
LABEL_4:
    xpc_retain(v3);
    goto LABEL_5;
  }
  xpc_object_t v3 = xpc_null_create();
  xpc_object_t v13 = v3;
  if (v3) {
    goto LABEL_4;
  }
  xpc_object_t v3 = 0;
  xpc_object_t v13 = xpc_null_create();
LABEL_5:
  *(void *)&long long v10 = &object;
  *((void *)&v10 + 1) = __p;
  sub_100035E70((uint64_t)&v10, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v4 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_object_t v4 = xpc_null_create();
  }
  xpc_release(v3);
  xpc_release(object);
  xpc_object_t v5 = xpc_null_create();
  xpc_release(v5);
  *(void *)&long long v10 = v4;
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v6 = v4;
  }
  else
  {
    xpc_object_t v6 = xpc_null_create();
    *(void *)&long long v10 = v6;
  }
  xpc_object_t v7 = xpc_null_create();
  xpc_object_t v14 = v7;
  sub_1000452AC(130, (xpc_object_t *)&v10, &v14);
  xpc_release(v7);
  xpc_release(v6);
  xpc_release(v4);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A0D7EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  unint64_t v24 = v23;
  xpc_release(v24);
  xpc_release(v22);
  xpc_release(v21);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__CFString *sub_100A0D870(int a1)
{
  switch(a1)
  {
    case 0:
      uint64_t v1 = kCTAudioVocoderTypeQCELP13;
      goto LABEL_21;
    case 1:
      uint64_t v1 = kCTAudioVocoderTypeEVRC;
      goto LABEL_21;
    case 2:
      uint64_t v1 = kCTAudioVocoderTypeEVRCB;
      goto LABEL_21;
    case 3:
      uint64_t v1 = kCTAudioVocoderType4GVNB;
      goto LABEL_21;
    case 4:
      uint64_t v1 = kCTAudioVocoderType4GVWB;
      goto LABEL_21;
    case 5:
      uint64_t v1 = kCTAudioVocoderType4GVNW;
      goto LABEL_21;
    case 6:
      uint64_t v1 = kCTAudioVocoderTypeFR;
      goto LABEL_21;
    case 7:
      uint64_t v1 = kCTAudioVocoderTypeHR;
      goto LABEL_21;
    case 8:
      uint64_t v1 = kCTAudioVocoderTypeEFR;
      goto LABEL_21;
    case 9:
      uint64_t v1 = kCTAudioVocoderTypeAMR;
      goto LABEL_21;
    case 10:
      uint64_t v1 = kCTAudioVocoderTypeWAMR;
      goto LABEL_21;
    case 11:
      uint64_t v1 = kCTAudioVocoderTypeEAMR;
      goto LABEL_21;
    case 12:
      uint64_t v1 = kCTAudioVocoderTypeFRWithBWE;
      goto LABEL_21;
    case 13:
      uint64_t v1 = kCTAudioVocoderTypeHRWithBWE;
      goto LABEL_21;
    case 14:
      uint64_t v1 = kCTAudioVocoderTypeEFRWithBWE;
      goto LABEL_21;
    case 15:
      uint64_t v1 = kCTAudioVocoderTypeAMRWithBWE;
      goto LABEL_21;
    case 16:
      uint64_t v1 = kCTAudioVocoderTypeEVRCBWithBWE;
      goto LABEL_21;
    case 17:
      uint64_t v1 = kCTAudioVocoderTypeEVS;
LABEL_21:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_100A0D9C8(const void *a1)
{
  if (!a1) {
    return 18;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeQCELP13")) {
    return 0;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEVRC")) {
    return 1;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEVRCB")) {
    return 2;
  }
  if (CFEqual(a1, @"kCTAudioVocoderType4GVNB")) {
    return 3;
  }
  if (CFEqual(a1, @"kCTAudioVocoderType4GVWB")) {
    return 4;
  }
  if (CFEqual(a1, @"kCTAudioVocoderType4GVNW")) {
    return 5;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeFR")) {
    return 6;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeHR")) {
    return 7;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEFR")) {
    return 8;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeAMR")) {
    return 9;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeWAMR")) {
    return 10;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEAMR")) {
    return 11;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeFRWithBWE")) {
    return 12;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeHRWithBWE")) {
    return 13;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEFRWithBWE")) {
    return 14;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeAMRWithBWE")) {
    return 15;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEVRCBWithBWE")) {
    return 16;
  }
  if (CFEqual(a1, @"kCTAudioVocoderTypeEVS")) {
    return 17;
  }
  return 18;
}

void sub_100A0DC3C()
{
}

void sub_100A0E080(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[4], v2, (dispatch_function_t)sub_100A10E2C);
    __cxa_rethrow();
  }
  JUMPOUT(0x100A0E1CCLL);
}

void sub_100A0E0B4()
{
}

void sub_100A0E0C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, dispatch_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, std::__shared_weak_count *a19)
{
  if (a19) {
    sub_10004D2C8(a19);
  }
  sub_100A10F08(*(void **)(v19 + 224));
  sub_100A10F08(*(void **)(v19 + 200));
  sub_100A10EB4(*(void **)(v19 + 176));
  if (*(char *)(v19 + 167) < 0) {
    operator delete(*v23);
  }
  sub_1001FEC70(*(void **)(v19 + 128));
  sub_10030AAD0(v22, *(void **)(v19 + 104));
  unint64_t v24 = *(std::__shared_weak_count **)(v19 + 80);
  if (v24) {
    sub_10004D2C8(v24);
  }
  int v25 = *(std::__shared_weak_count **)(v19 + 64);
  if (v25) {
    sub_10004D2C8(v25);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  operator delete();
}

void sub_100A0E1C4(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100A0E1DC(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 72));
}

void sub_100A0E1E4(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v17, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v18) {
    sub_10004D2C8(v18);
  }
  xpc_object_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v2 || (v3 = *(void *)(a1 + 16), (xpc_object_t v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  xpc_object_t v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  sub_100058DB0(__p, "/cc/props/current_data_slot");
  xpc_object_t v6 = operator new(0x28uLL);
  void *v6 = off_101A299A0;
  v6[1] = a1 + 88;
  void v6[2] = a1;
  void v6[3] = v3;
  v6[4] = v5;
  uint64_t v22 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(v21);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  xpc_object_t v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v7 || (uint64_t v8 = *(void *)(a1 + 16), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  long long v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  sub_100058DB0(__p, "/cc/props/carrier_entitlements_info");
  uint64_t v11 = operator new(0x28uLL);
  void *v11 = off_101A29A20;
  v11[1] = a1 + 96;
  void v11[2] = a1;
  v11[3] = v8;
  void v11[4] = v10;
  uint64_t v22 = v11;
  ctu::RestModule::observeProperty();
  sub_10003F600(v21);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v12 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v12 || (uint64_t v13 = *(void *)(a1 + 16), (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
    sub_100088B9C();
  }
  char v15 = v14;
  atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  sub_100058DB0(__p, "/cc/events/dump_state");
  unsigned int v16 = operator new(0x20uLL);
  *unsigned int v16 = off_101A29AA0;
  v16[1] = a1;
  v16[2] = v13;
  void v16[3] = v15;
  uint64_t v22 = v16;
  ctu::RestModule::observeEvent();
  sub_10003F600(v21);
  if (v20 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A0E434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100A0E4AC(uint64_t a1)
{
  char v18 = 0;
  uint64_t v19 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    xpc_object_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(const std::string **__return_ptr, uint64_t, void))(*(void *)v10 + 8))(&v18, v10, *(unsigned int *)(a1 + 88));
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v18) {
    std::string::operator=((std::string *)(a1 + 144), v18 + 1);
  }
  unint64_t v12 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    char v15 = *(const char **)(a1 + 144);
    uint64_t v14 = a1 + 144;
    uint64_t v13 = v15;
    uint64_t v16 = *(unsigned __int8 *)(v14 + 23);
    BOOL v17 = (v16 & 0x80u) != 0;
    if ((v16 & 0x80u) != 0) {
      uint64_t v16 = *(void *)(v14 + 8);
    }
    if (!v17) {
      uint64_t v13 = (const char *)v14;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    if (!v16) {
      uint64_t v13 = "<invalid>";
    }
    __int16 v21 = 2080;
    uint64_t v22 = "";
    __int16 v23 = 2080;
    unint64_t v24 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s%sstarting. Active personality %s", buf, 0x20u);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
}

void sub_100A0E698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0E6D4(uint64_t a1, uint64_t a2, uint64_t a3, void **a4)
{
  uint64_t v8 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    asString();
    uint64_t v9 = SHIBYTE(v81) >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v83 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%spersonality event: %s", buf, 0x20u);
    if (SHIBYTE(v81) < 0) {
      operator delete(__p[0]);
    }
  }
  int v10 = *(unsigned char *)(a3 + 24) & 0xFE;
  char v11 = (uint64_t **)(a1 + 120);
  unint64_t v12 = sub_100046F68(a1 + 120, (void **)a3);
  uint64_t v13 = (uint64_t *)v12;
  uint64_t v14 = (void **)(a1 + 128);
  if (v10 == 6)
  {
    if (v14 != v12)
    {
      char v15 = *(NSObject **)(a1 + 48);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(unsigned __int8 *)(a3 + 23);
        BOOL v17 = (v16 & 0x80u) != 0;
        char v18 = *(const char **)a3;
        if ((v16 & 0x80u) != 0) {
          uint64_t v16 = *(void *)(a3 + 8);
        }
        if (!v17) {
          char v18 = (const char *)a3;
        }
        if (v16) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = "<invalid>";
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v83 = (void *)v19;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sRemoving controller for %s", buf, 0x20u);
      }
      char v20 = (uint64_t *)v13[1];
      if (v20)
      {
        do
        {
          __int16 v21 = v20;
          char v20 = (uint64_t *)*v20;
        }
        while (v20);
      }
      else
      {
        unint64_t v28 = v13;
        do
        {
          __int16 v21 = (uint64_t *)v28[2];
          BOOL v29 = *v21 == (void)v28;
          unint64_t v28 = v21;
        }
        while (!v29);
      }
      if (*v11 == v13) {
        void *v11 = v21;
      }
      char v30 = *(uint64_t **)(a1 + 128);
      --*(void *)(a1 + 136);
      sub_10005EE6C(v30, v13);
      sub_1001FEC1C((uint64_t)(v13 + 4));
      operator delete(v13);
    }
    unsigned int v31 = sub_100046F68(a1 + 192, (void **)a3);
    if ((void **)(a1 + 200) != v31)
    {
      uint64_t v32 = (uint64_t *)v31;
      unint64_t v33 = (void **)v31[7];
      char v34 = v31 + 8;
      if (v33 != v31 + 8)
      {
        do
        {
          uint64_t v35 = *(void *)(a1 + 240);
          if (*((char *)v33 + 55) < 0)
          {
            sub_10004FC84(__dst, v33[4], (unint64_t)v33[5]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *((_OWORD *)v33 + 2);
            v76 = v33[6];
          }
          if (SHIBYTE(v76) < 0)
          {
            sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)__dst;
            v81 = v76;
          }
          v78 = 0;
          if (SHIBYTE(v81) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v81;
          }
          char v79 = 0;
          if (ctu::cf::convert_copy())
          {
            unsigned int v36 = v78;
            v78 = v79;
            v70[0] = v36;
            sub_1000558F4(v70);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          v77 = v78;
          v78 = 0;
          sub_1000558F4(&v78);
          if (SHIBYTE(v81) < 0) {
            operator delete(__p[0]);
          }
          (*(void (**)(uint64_t, const void *))(*(void *)v35 + 40))(v35, v77);
          sub_1000558F4(&v77);
          if (SHIBYTE(v76) < 0) {
            operator delete(__dst[0]);
          }
          unint64_t v37 = (void **)v33[1];
          if (v37)
          {
            do
            {
              char v38 = v37;
              unint64_t v37 = (void **)*v37;
            }
            while (v37);
          }
          else
          {
            do
            {
              char v38 = (void **)v33[2];
              BOOL v29 = *v38 == v33;
              unint64_t v33 = v38;
            }
            while (!v29);
          }
          unint64_t v33 = v38;
        }
        while (v38 != v34);
      }
      sub_1000F5B04((uint64_t **)(a1 + 192), v32);
      sub_100A10F5C((uint64_t)(v32 + 4));
      operator delete(v32);
    }
    BOOL v39 = sub_100046F68(a1 + 168, (void **)a3);
    if ((void **)(a1 + 176) != v39)
    {
      long long v40 = (uint64_t *)v39;
      uint64_t v41 = (void **)v39[7];
      long long v42 = v39 + 8;
      if (v41 != v39 + 8)
      {
        do
        {
          uint64_t v43 = *(void *)(a1 + 240);
          if (*((char *)v41 + 55) < 0)
          {
            sub_10004FC84(v73, v41[4], (unint64_t)v41[5]);
          }
          else
          {
            *(_OWORD *)uint64_t v73 = *((_OWORD *)v41 + 2);
            long long v74 = v41[6];
          }
          if (SHIBYTE(v74) < 0)
          {
            sub_10004FC84(__p, v73[0], (unint64_t)v73[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v73;
            v81 = v74;
          }
          v78 = 0;
          if (SHIBYTE(v81) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v81;
          }
          char v79 = 0;
          if (ctu::cf::convert_copy())
          {
            char v44 = v78;
            v78 = v79;
            v70[0] = v44;
            sub_1000558F4(v70);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          v77 = v78;
          v78 = 0;
          sub_1000558F4(&v78);
          if (SHIBYTE(v81) < 0) {
            operator delete(__p[0]);
          }
          (*(void (**)(uint64_t, const void *))(*(void *)v43 + 40))(v43, v77);
          sub_1000558F4(&v77);
          if (SHIBYTE(v74) < 0) {
            operator delete(v73[0]);
          }
          int v45 = (void **)v41[1];
          if (v45)
          {
            do
            {
              int v46 = v45;
              int v45 = (void **)*v45;
            }
            while (v45);
          }
          else
          {
            do
            {
              int v46 = (void **)v41[2];
              BOOL v29 = *v46 == v41;
              uint64_t v41 = v46;
            }
            while (!v29);
          }
          uint64_t v41 = v46;
        }
        while (v46 != v42);
      }
      sub_1000F5B04((uint64_t **)(a1 + 168), v40);
      sub_10020F878((uint64_t)(v40 + 4));
      operator delete(v40);
    }
    size_t v47 = sub_100046F68(a1 + 216, (void **)a3);
    if ((void **)(a1 + 224) != v47)
    {
      uint64_t v48 = (uint64_t *)v47;
      size_t v49 = (void **)v47[7];
      long long v50 = v47 + 8;
      if (v49 != v47 + 8)
      {
        do
        {
          uint64_t v51 = *(void *)(a1 + 240);
          if (*((char *)v49 + 55) < 0)
          {
            sub_10004FC84(v71, v49[4], (unint64_t)v49[5]);
          }
          else
          {
            *(_OWORD *)char v71 = *((_OWORD *)v49 + 2);
            v72 = v49[6];
          }
          if (SHIBYTE(v72) < 0)
          {
            sub_10004FC84(__p, v71[0], (unint64_t)v71[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v71;
            v81 = v72;
          }
          v78 = 0;
          if (SHIBYTE(v81) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v81;
          }
          char v79 = 0;
          if (ctu::cf::convert_copy())
          {
            long long v52 = v78;
            v78 = v79;
            v70[0] = v52;
            sub_1000558F4(v70);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          v77 = v78;
          v78 = 0;
          sub_1000558F4(&v78);
          if (SHIBYTE(v81) < 0) {
            operator delete(__p[0]);
          }
          (*(void (**)(uint64_t, const void *))(*(void *)v51 + 40))(v51, v77);
          sub_1000558F4(&v77);
          if (SHIBYTE(v72) < 0) {
            operator delete(v71[0]);
          }
          BOOL v53 = (void **)v49[1];
          if (v53)
          {
            do
            {
              int v54 = v53;
              BOOL v53 = (void **)*v53;
            }
            while (v53);
          }
          else
          {
            do
            {
              int v54 = (void **)v49[2];
              BOOL v29 = *v54 == v49;
              size_t v49 = v54;
            }
            while (!v29);
          }
          size_t v49 = v54;
        }
        while (v54 != v50);
      }
      sub_1000F5B04((uint64_t **)(a1 + 216), v48);
      sub_100A10F5C((uint64_t)(v48 + 4));
      operator delete(v48);
    }
    return;
  }
  if (v14 == v12)
  {
    uint64_t v22 = 0;
    goto LABEL_29;
  }
  __int16 v23 = v12[7];
  uint64_t v22 = (std::__shared_weak_count *)v12[8];
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v23)
  {
LABEL_29:
    if (isReal())
    {
      for (uint64_t i = (void *)(*a4)[59]; i != (void *)(*a4)[60]; i += 2)
      {
        unint64_t v27 = (const void *)*i;
        if ((*(unsigned char *)(*i + 80) & 0x20) != 0)
        {
          int v55 = (std::__shared_weak_count *)i[1];
          if (v55) {
            atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v70[0] = v27;
          v70[1] = v55;
          if (!*(unsigned char *)(*(void *)**a4 + 49))
          {
            CFStringRef v58 = *(NSObject **)(a1 + 48);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v59 = *(unsigned __int8 *)(a3 + 23);
              BOOL v60 = (v59 & 0x80u) != 0;
              int v61 = *(const char **)a3;
              if ((v59 & 0x80u) != 0) {
                uint64_t v59 = *(void *)(a3 + 8);
              }
              if (!v60) {
                int v61 = (const char *)a3;
              }
              if (v59) {
                int v62 = v61;
              }
              else {
                int v62 = "<invalid>";
              }
              *(_DWORD *)std::string buf = 136315650;
              *(void *)&uint8_t buf[4] = "";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = "";
              *(_WORD *)&unsigned char buf[22] = 2080;
              uint64_t v83 = (void *)v62;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I %s%sCreating controller for %s", buf, 0x20u);
            }
            int v63 = *(std::__shared_weak_count **)(a1 + 24);
            if (v63)
            {
              uint64_t v64 = *(void *)(a1 + 16);
              int v65 = std::__shared_weak_count::lock(v63);
              if (v65)
              {
                uint64_t v66 = v65;
                atomic_fetch_add_explicit(&v65->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v65);
                __p[0] = 0;
                __p[1] = 0;
                int v67 = std::__shared_weak_count::lock(v66);
                v68 = v67;
                if (v67)
                {
                  v69 = (void *)(v64 + 8);
                  if (!v64) {
                    v69 = 0;
                  }
                  atomic_fetch_add_explicit(&v67->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  __p[0] = v69;
                  __p[1] = v67;
                  std::__shared_weak_count::__release_weak(v66);
                  sub_10004D2C8(v68);
                }
                else
                {
                  __p[0] = 0;
                  __p[1] = 0;
                  std::__shared_weak_count::__release_weak(v66);
                }
                DDBControlImpl::create();
              }
            }
            sub_100088B9C();
          }
          if (v55) {
            sub_10004D2C8(v55);
          }
          if (v22) {
            goto LABEL_130;
          }
          return;
        }
      }
    }
    goto LABEL_129;
  }
  int v24 = (*(uint64_t (**)(void *))(*(void *)v23 + 80))(v23);
  uint64_t v25 = 1;
  switch(*(unsigned char *)(a3 + 24))
  {
    case 1:
      goto LABEL_27;
    case 2:
      uint64_t v25 = 0;
LABEL_27:
      (*(void (**)(void *, uint64_t, void, uint64_t))(*(void *)v23 + 40))(v23, v25, **a4, a2);
      break;
    case 3:
      uint64_t v56 = (void (**)(void *, void))(*(void *)v23 + 48);
      goto LABEL_125;
    case 4:
      uint64_t v56 = (void (**)(void *, void))(*(void *)v23 + 56);
      goto LABEL_125;
    case 5:
      uint64_t v56 = (void (**)(void *, void))(*(void *)v23 + 64);
LABEL_125:
      (*v56)(v23, **a4);
      break;
    default:
      break;
  }
  uint64_t v57 = (*(uint64_t (**)(void *, uint64_t))(*(void *)v23 + 80))(v23, v25);
  if (sub_10001D294((unsigned __int8 *)a3, (unsigned __int8 *)(a1 + 144)) && v24 != v57) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 240) + 24))(*(void *)(a1 + 240), v57);
  }
LABEL_129:
  if (v22) {
LABEL_130:
  }
    sub_10004D2C8(v22);
}

void sub_100A0F3D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  sub_1001FEBC4((uint64_t)&__p);
  sub_1002B1A40(v46 - 144);
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_100A0F588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    void v6[2] = *(void **)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    __p[2] = *(void **)(a3 + 16);
  }
  xpc_object_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A0F738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0F75C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_100A0F764(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A0F8BC(uint64_t a1, uint64_t a2)
{
}

void sub_100A0F8C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v10, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)int v10 = *(_OWORD *)a2;
    v10[2] = *(void **)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)char v11 = *(_OWORD *)a3;
    void v11[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  char v13 = a5;
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A0FAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0FB20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
}

void sub_100A0FB28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v10, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)int v10 = *(_OWORD *)a2;
    v10[2] = *(void **)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)char v11 = *(_OWORD *)a3;
    void v11[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  char v13 = a5;
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A0FD48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A0FD84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
}

void sub_100A0FD8C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100023950((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A0FEC0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A0FED0(unint64_t a1, char **a2, uint64_t a3)
{
  long long v16 = a1;
  long long v17 = 0uLL;
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v14 = (char *)&v16 + 8;
  uint64_t v7 = v6 - v5;
  if (v6 != v5)
  {
    uint64_t v15 = 0;
    if (v7 < 0) {
      sub_10006A748();
    }
    uint64_t v8 = sub_10006A794((uint64_t)&v17 + 8, v7 >> 4);
    uint64_t v9 = 0;
    *((void *)&v16 + 1) = v8;
    *(void *)&long long v17 = v8;
    *((void *)&v17 + 1) = &v8[2 * v10];
    char v11 = v8;
    do
    {
      void *v11 = *(void *)v5;
      uint64_t v12 = *((void *)v5 + 1);
      v11[1] = v12;
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      v9 += 2;
      v5 += 16;
      v11 += 2;
    }
    while (v5 != v6);
    *(void *)&long long v17 = &v8[v9];
  }
  sub_100A13C14((uint64_t)&v18, a3);
  char v13 = *(std::__shared_weak_count **)(a1 + 24);
  if (v13)
  {
    if (std::__shared_weak_count::lock(v13)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A100AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100A100D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ctu::cf::assign();
  uint64_t v6 = a1;
  long long __p = 0;
  memset(v8, 0, sizeof(v8));
  memset(&v9[32], 0, 15);
  sub_100A14174((uint64_t)v9, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A10284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100A102B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100A14174((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A103EC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A103FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ctu::cf::assign();
  uint64_t v6 = a1;
  long long __p = 0;
  memset(v8, 0, sizeof(v8));
  memset(&v9[32], 0, 15);
  sub_100A15130((uint64_t)v9, a3);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A105A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100A105DC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100A153A4((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A10710(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A10720(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100A15A48((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A10854(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A10864(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_100A14174((uint64_t)&v5, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A10998(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A109AC(uint64_t a1)
{
  sub_100A10CBC(a1);

  operator delete();
}

uint64_t sub_100A109E4(uint64_t a1)
{
  return sub_100A10CBC(a1 - 8);
}

void sub_100A109EC(uint64_t a1)
{
  sub_100A10CBC(a1 - 8);

  operator delete();
}

void *sub_100A10A28(void *a1)
{
  xpc_object_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A10AAC(void *a1)
{
  xpc_object_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A10B30(void *a1)
{
  xpc_object_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A10BB4(void *a1)
{
  xpc_object_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A10C38(void *a1)
{
  xpc_object_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100A10CBC(uint64_t a1)
{
  *(void *)a1 = off_101A29700;
  *(void *)(a1 + 8) = off_101A297A0;
  xpc_object_t v2 = *(std::__shared_weak_count **)(a1 + 248);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100A10F08(*(void **)(a1 + 224));
  sub_100A10F08(*(void **)(a1 + 200));
  sub_100A10EB4(*(void **)(a1 + 176));
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  sub_1001FEC70(*(void **)(a1 + 128));
  sub_10030AAD0(a1 + 96, *(void **)(a1 + 104));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  return a1;
}

void sub_100A10D94(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A10DCC(uint64_t a1)
{
}

uint64_t sub_100A10DE8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A10E2C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

uint64_t *sub_100A10E58(uint64_t a1)
{
  uint64_t v3 = a1;
  if (*(void *)a1)
  {
    uint64_t v1 = *(std::__shared_weak_count **)(*(void *)a1 + 8);
    if (v1) {
      sub_10004D2C8(v1);
    }
    operator delete();
  }
  return sub_100046B58(&v3);
}

void sub_100A10EB4(void *a1)
{
  if (a1)
  {
    sub_100A10EB4(*a1);
    sub_100A10EB4(a1[1]);
    sub_10020F878((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100A10F08(void *a1)
{
  if (a1)
  {
    sub_100A10F08(*a1);
    sub_100A10F08(a1[1]);
    sub_100A10F5C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100A10F5C(uint64_t a1)
{
  sub_10010C0E0(a1 + 24, *(void **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
  {
    xpc_object_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void *sub_100A10FB0(void *a1)
{
  *a1 = off_101A299A0;
  xpc_object_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A10FFC(void *a1)
{
  *a1 = off_101A299A0;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A11068(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A299A0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A110CC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A299A0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A1110C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A1111C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A1115C(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (_DWORD *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&buf, (int *)a2, v7);
    _DWORD *v4 = buf.__r_.__value_.__l.__data_;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    _DWORD *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (std::__shared_weak_count *)a1[4];
  if (v10)
  {
    uint64_t v11 = a1[2];
    uint64_t v12 = std::__shared_weak_count::lock(v10);
    if (v12)
    {
      char v13 = v12;
      if (!a1[3])
      {
LABEL_78:
        sub_10004D2C8(v13);
        return;
      }
      uint64_t v14 = *(NSObject **)(v11 + 48);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sdetected change in current_data_slot", (uint8_t *)&buf, 0x16u);
      }
      uint64_t v64 = 0;
      int v65 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(v11 + 56));
      long long v17 = ServiceMap;
      std::string::size_type v19 = v18;
      if ((v18 & 0x8000000000000000) != 0)
      {
        char v20 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v21 = 5381;
        do
        {
          std::string::size_type v19 = v21;
          unsigned int v22 = *v20++;
          uint64_t v21 = (33 * v21) ^ v22;
        }
        while (v22);
      }
      std::mutex::lock(ServiceMap);
      buf.__r_.__value_.__r.__words[0] = v19;
      __int16 v23 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&buf);
      if (v23)
      {
        uint64_t v25 = v23[3];
        int v24 = (std::__shared_weak_count *)v23[4];
        if (v24)
        {
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v17);
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v24);
          char v26 = 0;
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v25 = 0;
      }
      std::mutex::unlock(v17);
      int v24 = 0;
      char v26 = 1;
LABEL_25:
      (*(void (**)(const std::string **__return_ptr, uint64_t, void))(*(void *)v25 + 8))(&v64, v25, *(unsigned int *)(v11 + 88));
      if ((v26 & 1) == 0) {
        sub_10004D2C8(v24);
      }
      unint64_t v27 = v64;
      unint64_t v28 = *(NSObject **)(v11 + 48);
      BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
      if (v27)
      {
        if (v29)
        {
          std::string::pointer data = v27[1].__r_.__value_.__l.__data_;
          unsigned int v31 = v27 + 1;
          char v30 = data;
          std::string::size_type size = HIBYTE(v31->__r_.__value_.__r.__words[2]);
          BOOL v34 = (size & 0x80u) != 0;
          if ((size & 0x80u) != 0) {
            std::string::size_type size = v31->__r_.__value_.__l.__size_;
          }
          if (!v34) {
            char v30 = (const char *)v31;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          if (!size) {
            char v30 = "<invalid>";
          }
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          uint64_t v67 = (uint64_t)v30;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%sactive personality: %s", (uint8_t *)&buf, 0x20u);
          unint64_t v27 = v64;
        }
        std::string::operator=((std::string *)(v11 + 144), v27 + 1);
        uint64_t v35 = sub_100046F68(v11 + 120, (void **)(v11 + 144));
        if ((void **)(v11 + 128) != v35)
        {
          uint64_t v37 = (*(uint64_t (**)(void *))(*(void *)v35[7] + 80))(v35[7]);
          goto LABEL_45;
        }
        char v38 = *(NSObject **)(v11 + 48);
        uint64_t v37 = 0;
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
LABEL_45:
          uint64_t v62 = 0;
          int v63 = 0;
          BOOL v39 = (std::mutex *)Registry::getServiceMap(v36, *(Registry **)(v11 + 56));
          long long v40 = v39;
          if ((v18 & 0x8000000000000000) != 0)
          {
            uint64_t v41 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v42 = 5381;
            do
            {
              std::string::size_type v18 = v42;
              unsigned int v43 = *v41++;
              uint64_t v42 = (33 * v42) ^ v43;
            }
            while (v43);
          }
          std::mutex::lock(v39);
          buf.__r_.__value_.__r.__words[0] = v18;
          char v44 = sub_10004D37C(&v40[1].__m_.__sig, (unint64_t *)&buf);
          if (v44)
          {
            uint64_t v46 = v44[3];
            int v45 = (std::__shared_weak_count *)v44[4];
            if (v45)
            {
              atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v40);
              atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v45);
              char v47 = 0;
              goto LABEL_53;
            }
          }
          else
          {
            uint64_t v46 = 0;
          }
          std::mutex::unlock(v40);
          int v45 = 0;
          char v47 = 1;
LABEL_53:
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v46 + 8))(&v62, v46, v5);
          if ((v47 & 1) == 0) {
            sub_10004D2C8(v45);
          }
          if (!v62 || (uint64_t v48 = sub_100046F68(v11 + 120, (void **)(v62 + 24)), (void **)(v11 + 128) == v48))
          {
            if ((v37 & 1) == 0) {
              goto LABEL_64;
            }
            BOOL v50 = 0;
          }
          else
          {
            int v49 = (*(uint64_t (**)(void *))(*(void *)v48[7] + 80))(v48[7]);
            BOOL v50 = v49;
            if (v37 == v49)
            {
LABEL_64:
              int v54 = *(NSObject **)(v11 + 48);
              if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v55 = asStringBool(v37);
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
                WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
                HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
                uint64_t v67 = v55;
                _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I %s%sDedicated bearer management support IS NOT changed: %s", (uint8_t *)&buf, 0x20u);
              }
LABEL_66:
              if (v5 != *(_DWORD *)(v11 + 88))
              {
                if (!v62 || (uint64_t v56 = sub_100046F68(v11 + 120, (void **)(v62 + 24)), (void **)(v11 + 128) == v56))
                {
                  uint64_t v58 = 0;
                  uint64_t v59 = 0;
                }
                else
                {
                  uint64_t v57 = v56[7];
                  sub_100058DB0(&buf, "custom-qos");
                  (*(void (**)(uint64_t *__return_ptr, void *, std::string *))(*(void *)v57 + 88))(&v60, v57, &buf);
                  uint64_t v58 = v60;
                  uint64_t v59 = v61;
                  uint64_t v60 = 0;
                  int v61 = 0;
                  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(buf.__r_.__value_.__l.__data_);
                  }
                }
                (*(void (**)(void, uint64_t))(**(void **)(v11 + 240) + 48))(*(void *)(v11 + 240), v58);
                if (v59) {
                  sub_10004D2C8(v59);
                }
              }
              if (v63) {
                sub_10004D2C8(v63);
              }
              if (v65) {
                sub_10004D2C8(v65);
              }
              goto LABEL_78;
            }
          }
          uint64_t v51 = *(NSObject **)(v11 + 48);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v52 = asStringBool(v50);
            uint64_t v53 = asStringBool(v37);
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
            HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
            uint64_t v67 = v52;
            __int16 v68 = 2080;
            uint64_t v69 = v53;
            _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I %s%sDedicated bearer management support changed %s -> %s", (uint8_t *)&buf, 0x2Au);
          }
          (*(void (**)(void, uint64_t))(**(void **)(v11 + 240) + 24))(*(void *)(v11 + 240), v37);
          goto LABEL_66;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I %s%sno DDB controller for active personality!!", (uint8_t *)&buf, 0x16u);
      }
      else
      {
        if (v29)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I %s%sno active personality!", (uint8_t *)&buf, 0x16u);
        }
        memset(&buf, 0, sizeof(buf));
        std::string::operator=((std::string *)(v11 + 144), &buf);
        unsigned int v36 = (uint64_t *)SHIBYTE(buf.__r_.__value_.__r.__words[2]);
        if ((v36 & 0x80000000) != 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v37 = 0;
      goto LABEL_45;
    }
  }
}

void sub_100A118A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100A11978(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A119B8()
{
}

void *sub_100A119C4(void *a1)
{
  *a1 = off_101A29A20;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A11A10(void *a1)
{
  *a1 = off_101A29A20;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A11A7C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A29A20;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A11AE0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A29A20;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A11B20(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A11B30(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A11B70(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = *(NSObject **)(v4 + 48);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(__p[0]) = 136315394;
          *(void **)((char *)__p + 4) = "";
          WORD2(__p[1]) = 2080;
          *(void **)((char *)&__p[1] + 6) = "";
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%shandleEntitlementStatesChanged", (uint8_t *)__p, 0x16u);
        }
        uint64_t v8 = (void ***)(v4 + 120);
        uint64_t v9 = sub_100046F68(v4 + 120, (void **)(v4 + 144));
        uint64_t v10 = v9;
        uint64_t v11 = (void **)(v4 + 128);
        if ((void **)(v4 + 128) == v9) {
          int v12 = 0;
        }
        else {
          int v12 = (*(uint64_t (**)(void *))(*(void *)v9[7] + 80))(v9[7]);
        }
        char v13 = *v8;
        if (*v8 != v11)
        {
          do
          {
            uint64_t v21 = 0;
            memset(__p, 0, sizeof(__p));
            if (*((char *)v13 + 55) < 0)
            {
              sub_10004FC84(__p, v13[4], (unint64_t)v13[5]);
            }
            else
            {
              *(_OWORD *)long long __p = *((_OWORD *)v13 + 2);
              __p[2] = v13[6];
            }
            uint64_t v14 = v13[7];
            uint64_t v15 = (std::__shared_weak_count *)v13[8];
            __p[3] = v14;
            uint64_t v21 = v15;
            if (v15)
            {
              atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v14 = __p[3];
            }
            (*(void (**)(void *, uint64_t))(*(void *)v14 + 72))(v14, v4 + 96);
            if (v21) {
              sub_10004D2C8(v21);
            }
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
            long long v16 = (void **)v13[1];
            if (v16)
            {
              do
              {
                long long v17 = v16;
                long long v16 = (void **)*v16;
              }
              while (v16);
            }
            else
            {
              do
              {
                long long v17 = (void **)v13[2];
                BOOL v18 = *v17 == v13;
                char v13 = v17;
              }
              while (!v18);
            }
            char v13 = v17;
          }
          while (v17 != v11);
        }
        if (v11 == v10) {
          int v19 = 0;
        }
        else {
          int v19 = (*(uint64_t (**)(void *))(*(void *)v10[7] + 80))(v10[7]);
        }
        if (v12 != v19) {
          (*(void (**)(void))(**(void **)(v4 + 240) + 24))(*(void *)(v4 + 240));
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A11E48(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A11E70(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A11EB0()
{
}

void *sub_100A11EBC(void *a1)
{
  *a1 = off_101A29AA0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A11F08(void *a1)
{
  *a1 = off_101A29AA0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A11F74(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A29AA0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A11FD8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A29AA0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A12018(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A12028(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A12068(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[2])
      {
        uint64_t v6 = *(NSObject **)(v3 + 48);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315394;
          int v61 = "";
          __int16 v62 = 2080;
          int v63 = "";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s |--- Dedicated Bearer Manager:", buf, 0x16u);
          uint64_t v6 = *(NSObject **)(v3 + 48);
        }
        uint64_t v59 = v5;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = subscriber::asString();
          uint64_t v8 = (const char *)(v3 + 144);
          uint64_t v9 = *(unsigned __int8 *)(v3 + 167);
          int v10 = (char)v9;
          if ((v9 & 0x80u) != 0) {
            uint64_t v9 = *(void *)(v3 + 152);
          }
          if (v10 < 0) {
            uint64_t v8 = *(const char **)(v3 + 144);
          }
          *(_DWORD *)std::string buf = 136315906;
          int v61 = "";
          __int16 v62 = 2080;
          if (!v9) {
            uint64_t v8 = "<invalid>";
          }
          int v63 = "";
          __int16 v64 = 2080;
          int v65 = (void *)v7;
          __int16 v66 = 2080;
          uint64_t v67 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%s | Active slot:%s, personality:%s", buf, 0x2Au);
        }
        if (!*(void *)(v3 + 208))
        {
          uint64_t v11 = *(NSObject **)(v3 + 48);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315394;
            int v61 = "";
            __int16 v62 = 2080;
            int v63 = "";
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %s%s | No active sessions", buf, 0x16u);
          }
        }
        int v12 = *(void **)(v3 + 192);
        if (v12 != (void *)(v3 + 200))
        {
          do
          {
            char v13 = *(NSObject **)(v3 + 48);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v14 = (const char *)v12[4];
              uint64_t v15 = *((unsigned __int8 *)v12 + 55);
              int v16 = (char)v15;
              if ((v15 & 0x80u) != 0) {
                uint64_t v15 = v12[5];
              }
              if (v16 >= 0) {
                uint64_t v14 = (const char *)(v12 + 4);
              }
              long long v17 = (const char *)v12[9];
              if (!v15) {
                uint64_t v14 = "<invalid>";
              }
              *(_DWORD *)std::string buf = 136315906;
              int v61 = "";
              __int16 v62 = 2080;
              int v63 = "";
              __int16 v64 = 2080;
              int v65 = v14;
              __int16 v66 = 2048;
              uint64_t v67 = v17;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%s | for persona %s -> %zu session(s)", buf, 0x2Au);
            }
            BOOL v18 = (void *)v12[7];
            if (v18 != v12 + 8)
            {
              do
              {
                int v19 = *(NSObject **)(v3 + 48);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                {
                  char v20 = v18 + 4;
                  if (*((char *)v18 + 55) < 0) {
                    char v20 = (void *)*v20;
                  }
                  uint64_t v21 = (const char *)(v18 + 7);
                  if (*((char *)v18 + 79) < 0) {
                    uint64_t v21 = *(const char **)v21;
                  }
                  *(_DWORD *)std::string buf = 136315906;
                  int v61 = "";
                  __int16 v62 = 2080;
                  int v63 = "";
                  __int16 v64 = 2080;
                  int v65 = v20;
                  __int16 v66 = 2080;
                  uint64_t v67 = v21;
                  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%s |   %s : %s", buf, 0x2Au);
                }
                unsigned int v22 = (void *)v18[1];
                if (v22)
                {
                  do
                  {
                    __int16 v23 = v22;
                    unsigned int v22 = (void *)*v22;
                  }
                  while (v22);
                }
                else
                {
                  do
                  {
                    __int16 v23 = (void *)v18[2];
                    BOOL v24 = *v23 == (void)v18;
                    BOOL v18 = v23;
                  }
                  while (!v24);
                }
                BOOL v18 = v23;
              }
              while (v23 != v12 + 8);
            }
            uint64_t v25 = (void *)v12[1];
            if (v25)
            {
              do
              {
                char v26 = v25;
                uint64_t v25 = (void *)*v25;
              }
              while (v25);
            }
            else
            {
              do
              {
                char v26 = (void *)v12[2];
                BOOL v24 = *v26 == (void)v12;
                int v12 = v26;
              }
              while (!v24);
            }
            int v12 = v26;
          }
          while (v26 != (void *)(v3 + 200));
        }
        if (!*(void *)(v3 + 184))
        {
          unint64_t v27 = *(NSObject **)(v3 + 48);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315394;
            int v61 = "";
            __int16 v62 = 2080;
            int v63 = "";
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I %s%s | No current attempts to establish session", buf, 0x16u);
          }
        }
        unint64_t v28 = *(void **)(v3 + 168);
        if (v28 != (void *)(v3 + 176))
        {
          do
          {
            BOOL v29 = *(NSObject **)(v3 + 48);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              char v30 = (const char *)v28[4];
              uint64_t v31 = *((unsigned __int8 *)v28 + 55);
              int v32 = (char)v31;
              if ((v31 & 0x80u) != 0) {
                uint64_t v31 = v28[5];
              }
              if (v32 >= 0) {
                char v30 = (const char *)(v28 + 4);
              }
              unint64_t v33 = (const char *)v28[9];
              if (!v31) {
                char v30 = "<invalid>";
              }
              *(_DWORD *)std::string buf = 136315906;
              int v61 = "";
              __int16 v62 = 2080;
              int v63 = "";
              __int16 v64 = 2080;
              int v65 = v30;
              __int16 v66 = 2048;
              uint64_t v67 = v33;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I %s%s | for persona %s -> %zu attempt(s) to add", buf, 0x2Au);
            }
            BOOL v34 = (void *)v28[7];
            if (v34 != v28 + 8)
            {
              do
              {
                uint64_t v35 = *(NSObject **)(v3 + 48);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                {
                  unsigned int v36 = v34 + 4;
                  if (*((char *)v34 + 55) < 0) {
                    unsigned int v36 = (void *)*v36;
                  }
                  *(_DWORD *)std::string buf = 136315650;
                  int v61 = "";
                  __int16 v62 = 2080;
                  int v63 = "";
                  __int16 v64 = 2080;
                  int v65 = v36;
                  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I %s%s |   %s", buf, 0x20u);
                }
                uint64_t v37 = (void *)v34[1];
                if (v37)
                {
                  do
                  {
                    char v38 = v37;
                    uint64_t v37 = (void *)*v37;
                  }
                  while (v37);
                }
                else
                {
                  do
                  {
                    char v38 = (void *)v34[2];
                    BOOL v24 = *v38 == (void)v34;
                    BOOL v34 = v38;
                  }
                  while (!v24);
                }
                BOOL v34 = v38;
              }
              while (v38 != v28 + 8);
            }
            BOOL v39 = (void *)v28[1];
            if (v39)
            {
              do
              {
                long long v40 = v39;
                BOOL v39 = (void *)*v39;
              }
              while (v39);
            }
            else
            {
              do
              {
                long long v40 = (void *)v28[2];
                BOOL v24 = *v40 == (void)v28;
                unint64_t v28 = v40;
              }
              while (!v24);
            }
            unint64_t v28 = v40;
          }
          while (v40 != (void *)(v3 + 176));
        }
        if (!*(void *)(v3 + 232))
        {
          uint64_t v41 = *(NSObject **)(v3 + 48);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 136315394;
            int v61 = "";
            __int16 v62 = 2080;
            int v63 = "";
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %s%s | No current attempts to remove session", buf, 0x16u);
          }
        }
        uint64_t v42 = *(void **)(v3 + 216);
        if (v42 != (void *)(v3 + 224))
        {
          do
          {
            unsigned int v43 = *(NSObject **)(v3 + 48);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              char v44 = (const char *)v42[4];
              uint64_t v45 = *((unsigned __int8 *)v42 + 55);
              int v46 = (char)v45;
              if ((v45 & 0x80u) != 0) {
                uint64_t v45 = v42[5];
              }
              if (v46 >= 0) {
                char v44 = (const char *)(v42 + 4);
              }
              char v47 = (const char *)v42[9];
              if (!v45) {
                char v44 = "<invalid>";
              }
              *(_DWORD *)std::string buf = 136315906;
              int v61 = "";
              __int16 v62 = 2080;
              int v63 = "";
              __int16 v64 = 2080;
              int v65 = v44;
              __int16 v66 = 2048;
              uint64_t v67 = v47;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I %s%s | for persona %s -> %zu attempt(s) to remove", buf, 0x2Au);
            }
            uint64_t v48 = (void *)v42[7];
            if (v48 != v42 + 8)
            {
              do
              {
                int v49 = *(NSObject **)(v3 + 48);
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                {
                  BOOL v50 = v48 + 4;
                  if (*((char *)v48 + 55) < 0) {
                    BOOL v50 = (void *)*v50;
                  }
                  uint64_t v51 = (const char *)(v48 + 7);
                  if (*((char *)v48 + 79) < 0) {
                    uint64_t v51 = *(const char **)v51;
                  }
                  *(_DWORD *)std::string buf = 136315906;
                  int v61 = "";
                  __int16 v62 = 2080;
                  int v63 = "";
                  __int16 v64 = 2080;
                  int v65 = v50;
                  __int16 v66 = 2080;
                  uint64_t v67 = v51;
                  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I %s%s |   %s : %s", buf, 0x2Au);
                }
                uint64_t v52 = (void *)v48[1];
                if (v52)
                {
                  do
                  {
                    uint64_t v53 = v52;
                    uint64_t v52 = (void *)*v52;
                  }
                  while (v52);
                }
                else
                {
                  do
                  {
                    uint64_t v53 = (void *)v48[2];
                    BOOL v24 = *v53 == (void)v48;
                    uint64_t v48 = v53;
                  }
                  while (!v24);
                }
                uint64_t v48 = v53;
              }
              while (v53 != v42 + 8);
            }
            int v54 = (void *)v42[1];
            if (v54)
            {
              do
              {
                uint64_t v55 = v54;
                int v54 = (void *)*v54;
              }
              while (v54);
            }
            else
            {
              do
              {
                uint64_t v55 = (void *)v42[2];
                BOOL v24 = *v55 == (void)v42;
                uint64_t v42 = v55;
              }
              while (!v24);
            }
            uint64_t v42 = v55;
          }
          while (v55 != (void *)(v3 + 224));
        }
        uint64_t v56 = *(void **)(v3 + 120);
        uint64_t v5 = v59;
        if (v56 != (void *)(v3 + 128))
        {
          do
          {
            (*(void (**)(void))(*(void *)v56[7] + 32))(v56[7]);
            uint64_t v57 = (void *)v56[1];
            if (v57)
            {
              do
              {
                uint64_t v58 = v57;
                uint64_t v57 = (void *)*v57;
              }
              while (v57);
            }
            else
            {
              do
              {
                uint64_t v58 = (void *)v56[2];
                BOOL v24 = *v58 == (void)v56;
                uint64_t v56 = v58;
              }
              while (!v24);
            }
            uint64_t v56 = v58;
          }
          while (v58 != (void *)(v3 + 128));
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100A12914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
}

uint64_t sub_100A1292C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1296C()
{
}

uint64_t *sub_100A12978(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = sub_100046F68(*(void *)v1 + 120, (void **)(v1 + 8));
  if ((void **)(v2 + 128) != v3)
  {
    uint64_t v4 = *(void *)(v2 + 240);
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v3[7] + 88))(&v8);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v8);
    if (v9) {
      sub_10004D2C8(v9);
    }
  }
  sub_10032C9A0(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100A12A3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10032C9A0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A12A6C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = sub_100046F68(*(void *)v1 + 120, (void **)(v1 + 8));
  if ((void **)(v2 + 128) != v3)
  {
    uint64_t v4 = *(void *)(v2 + 240);
    uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)v3[7] + 80))(v3[7]);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 24))(v4, v5);
  }
  sub_1001102C4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100A12B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100A12B34(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v39 = a1;
  uint64_t v40 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = sub_100046F68(*(void *)v1 + 120, (void **)(v1 + 8));
  if ((void **)(v2 + 128) == v3) {
    goto LABEL_66;
  }
  uint64_t v4 = v3;
  *(void *)std::string buf = v1 + 8;
  uint64_t v5 = sub_100A1315C((uint64_t **)(v2 + 168), (void **)(v1 + 8), (long long **)buf);
  uint64_t v6 = (uint64_t *)(v1 + 32);
  uint64_t v7 = (uint64_t *)sub_100046F68((uint64_t)(v5 + 7), (void **)(v1 + 32));
  *(void *)std::string buf = v1 + 8;
  if (sub_100A1315C((uint64_t **)(v2 + 168), (void **)(v1 + 8), (long long **)buf) + 8 != v7)
  {
    *(void *)std::string buf = v1 + 8;
    uint64_t v8 = sub_100A1315C((uint64_t **)(v2 + 168), (void **)(v1 + 8), (long long **)buf);
    sub_1000E1C44((uint64_t **)v8 + 7, (uint64_t)v7);
    *(void *)std::string buf = v1 + 8;
    if (!sub_100A1315C((uint64_t **)(v2 + 168), (void **)(v1 + 8), (long long **)buf)[9]) {
      sub_100A13320((uint64_t **)(v2 + 168), (void **)(v1 + 8));
    }
    if (*(unsigned char *)(v1 + 80))
    {
      *(void *)std::string buf = v1 + 8;
      uint64_t v9 = sub_100A13388((uint64_t **)(v2 + 192), (void **)(v1 + 8), (long long **)buf);
      *(void *)std::string buf = v1 + 32;
      int v10 = sub_100366370((uint64_t **)v9 + 7, (void **)(v1 + 32), (uint64_t)&unk_10144E20E, (long long **)buf);
      uint64_t v11 = (void *)(v1 + 56);
      std::string::operator=((std::string *)(v10 + 7), (const std::string *)(v1 + 56));
      int v12 = *(NSObject **)(v2 + 48);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_48;
      }
      uint64_t v13 = *(unsigned __int8 *)(v1 + 31);
      BOOL v14 = (v13 & 0x80u) != 0;
      if ((v13 & 0x80u) != 0) {
        uint64_t v13 = *(void *)(v1 + 16);
      }
      if (v14) {
        uint64_t v15 = *(const char **)(v1 + 8);
      }
      else {
        uint64_t v15 = (const char *)(v1 + 8);
      }
      if (v13) {
        int v16 = v15;
      }
      else {
        int v16 = "<invalid>";
      }
      uint64_t v17 = v1 + 32;
      if (*(char *)(v1 + 55) < 0) {
        uint64_t v17 = *v6;
      }
      if (*(char *)(v1 + 79) < 0) {
        uint64_t v11 = (void *)*v11;
      }
      *(_DWORD *)std::string buf = 136316162;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      BOOL v50 = v16;
      __int16 v51 = 2080;
      uint64_t v52 = (const char *)v17;
      __int16 v53 = 2080;
      int v54 = v11;
      BOOL v18 = "#I %s%sadded new session for %s: internal:%s = network:%s";
      int v19 = v12;
      uint32_t v20 = 52;
    }
    else
    {
      BOOL v29 = *(NSObject **)(v2 + 48);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_48;
      }
      uint64_t v30 = *(unsigned __int8 *)(v1 + 31);
      BOOL v31 = (v30 & 0x80u) != 0;
      if ((v30 & 0x80u) != 0) {
        uint64_t v30 = *(void *)(v1 + 16);
      }
      if (v31) {
        int v32 = *(const char **)(v1 + 8);
      }
      else {
        int v32 = (const char *)(v1 + 8);
      }
      if (v30) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = "<invalid>";
      }
      uint64_t v34 = v1 + 32;
      if (*(char *)(v1 + 55) < 0) {
        uint64_t v34 = *v6;
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      BOOL v50 = v33;
      __int16 v51 = 2080;
      uint64_t v52 = (const char *)v34;
      BOOL v18 = "#I %s%sfailed attempted to add new session for %s: internal:%s";
      int v19 = v29;
      uint32_t v20 = 42;
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
LABEL_48:
    uint64_t v35 = *(void *)(v2 + 240);
    if (*(char *)(v1 + 55) < 0)
    {
      sub_10004FC84(__dst, *(void **)(v1 + 32), *(void *)(v1 + 40));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)v6;
      uint64_t v42 = *(void *)(v1 + 48);
    }
    if (SHIBYTE(v42) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)__dst;
      uint64_t v46 = v42;
    }
    char v44 = 0;
    if (SHIBYTE(v46) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)__p;
      *(void *)&uint8_t buf[16] = v46;
    }
    char v47 = 0;
    if (ctu::cf::convert_copy())
    {
      unsigned int v36 = v44;
      char v44 = v47;
      uint64_t v48 = v36;
      sub_1000558F4(&v48);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v37 = v44;
    unsigned int v43 = v44;
    char v44 = 0;
    sub_1000558F4(&v44);
    if (SHIBYTE(v46) < 0) {
      operator delete(__p[0]);
    }
    (*(void (**)(uint64_t, const void *, void))(*(void *)v35 + 32))(v35, v37, *(unsigned __int8 *)(v1 + 80));
    sub_1000558F4(&v43);
    if (SHIBYTE(v42) < 0)
    {
      unint64_t v28 = __dst[0];
      goto LABEL_65;
    }
    goto LABEL_66;
  }
  if (*(unsigned char *)(v1 + 80))
  {
    uint64_t v21 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = v1 + 32;
      if (*(char *)(v1 + 55) < 0) {
        uint64_t v22 = *v6;
      }
      uint64_t v23 = *(unsigned __int8 *)(v1 + 31);
      BOOL v24 = (v23 & 0x80u) != 0;
      if ((v23 & 0x80u) != 0) {
        uint64_t v23 = *(void *)(v1 + 16);
      }
      if (v24) {
        uint64_t v25 = *(const char **)(v1 + 8);
      }
      else {
        uint64_t v25 = (const char *)(v1 + 8);
      }
      if (v23) {
        char v26 = v25;
      }
      else {
        char v26 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      *(_WORD *)&unsigned char buf[22] = 2080;
      BOOL v50 = (const char *)v22;
      __int16 v51 = 2080;
      uint64_t v52 = v26;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%sattempt %s is not found in %s pool. Removing it", buf, 0x2Au);
    }
    unint64_t v27 = v4[7];
    sub_100058DB0(buf, "custom-qos");
    (*(void (**)(void *, unsigned char *, uint64_t, uint64_t))(*(void *)v27 + 112))(v27, buf, v1 + 32, v1 + 56);
    if ((buf[23] & 0x80000000) != 0)
    {
      unint64_t v28 = *(void **)buf;
LABEL_65:
      operator delete(v28);
    }
  }
LABEL_66:
  sub_100A130E4(&v40);
  return sub_100046B58((uint64_t *)&v39);
}

void sub_100A13054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100A130E4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A130E4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100A1315C(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      int v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    int v12 = *a3;
    uint64_t v19 = 0;
    uint64_t v13 = (uint64_t *)operator new(0x50uLL);
    v18[0] = v13;
    v18[1] = v6;
    BOOL v14 = v13 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      void v13[6] = *((void *)v12 + 2);
      *(_OWORD *)BOOL v14 = v15;
    }
    v13[9] = 0;
    v13[8] = 0;
    v13[7] = (uint64_t)(v13 + 8);
    LOBYTE(v19) = 1;
    *uint64_t v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v8;
    uint64_t *v7 = v13;
    int v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    sub_100A132C8((uint64_t)v18);
  }
  return v11;
}

void sub_100A132B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100A132C8((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A132C8(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10020F878((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_100A13320(uint64_t **a1, void **a2)
{
  uint64_t v3 = (uint64_t *)sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v3)
  {
    uint64_t v4 = v3;
    sub_1000F5B04(a1, v3);
    sub_10020F878((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

uint64_t *sub_100A13388(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      int v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    int v12 = *a3;
    uint64_t v19 = 0;
    uint64_t v13 = (uint64_t *)operator new(0x50uLL);
    v18[0] = v13;
    v18[1] = v6;
    BOOL v14 = v13 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      void v13[6] = *((void *)v12 + 2);
      *(_OWORD *)BOOL v14 = v15;
    }
    v13[9] = 0;
    v13[8] = 0;
    v13[7] = (uint64_t)(v13 + 8);
    LOBYTE(v19) = 1;
    *uint64_t v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v8;
    uint64_t *v7 = v13;
    int v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    sub_100A134F4((uint64_t)v18);
  }
  return v11;
}

void sub_100A134E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100A134F4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A134F4(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100A10F5C((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t *sub_100A1354C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v29 = a1;
  uint64_t v30 = v1;
  uint64_t v2 = *(void *)v1;
  if ((void **)(v2 + 128) != sub_100046F68(*(void *)v1 + 120, (void **)(v1 + 8)))
  {
    *(void *)std::string buf = v1 + 8;
    uint64_t v3 = sub_100A13388((uint64_t **)(v2 + 216), (void **)(v1 + 8), (long long **)buf);
    uint64_t v4 = (uint64_t *)(v1 + 32);
    uint64_t v5 = (uint64_t *)sub_100046F68((uint64_t)(v3 + 7), (void **)(v1 + 32));
    *(void *)std::string buf = v1 + 8;
    if (sub_100A13388((uint64_t **)(v2 + 216), (void **)(v1 + 8), (long long **)buf) + 8 != v5)
    {
      int v6 = *(unsigned __int8 *)(v1 + 80);
      uint64_t v7 = *(NSObject **)(v2 + 48);
      BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      if (v6)
      {
        if (v8)
        {
          uint64_t v9 = *(unsigned __int8 *)(v1 + 31);
          BOOL v10 = (v9 & 0x80u) != 0;
          if ((v9 & 0x80u) != 0) {
            uint64_t v9 = *(void *)(v1 + 16);
          }
          if (v10) {
            uint64_t v11 = *(const char **)(v1 + 8);
          }
          else {
            uint64_t v11 = (const char *)(v1 + 8);
          }
          if (v9) {
            int v12 = v11;
          }
          else {
            int v12 = "<invalid>";
          }
          uint64_t v13 = v1 + 32;
          if (*(char *)(v1 + 55) < 0) {
            uint64_t v13 = *v4;
          }
          BOOL v14 = (void *)(v1 + 56);
          if (*(char *)(v1 + 79) < 0) {
            BOOL v14 = (void *)*v14;
          }
          *(_DWORD *)std::string buf = 136316162;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v40 = v12;
          __int16 v41 = 2080;
          uint64_t v42 = v13;
          __int16 v43 = 2080;
          char v44 = v14;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%ssession removed for %s: internal:%s = network:%s", buf, 0x34u);
        }
        *(void *)std::string buf = v1 + 8;
        long long v15 = sub_100A13388((uint64_t **)(v2 + 216), (void **)(v1 + 8), (long long **)buf);
        sub_10006C514((uint64_t **)v15 + 7, v5);
        sub_1000FECD4((uint64_t)(v5 + 4));
        operator delete(v5);
        *(void *)std::string buf = v1 + 8;
        if (!sub_100A13388((uint64_t **)(v2 + 216), (void **)(v1 + 8), (long long **)buf)[9]) {
          sub_100A13A58((uint64_t **)(v2 + 216), (void **)(v1 + 8));
        }
        uint64_t v16 = *(void *)(v2 + 240);
        if (*(char *)(v1 + 55) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v1 + 32), *(void *)(v1 + 40));
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)v4;
          uint64_t v32 = *(void *)(v1 + 48);
        }
        if (SHIBYTE(v32) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v36 = v32;
        }
        uint64_t v34 = 0;
        if (SHIBYTE(v36) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v36;
        }
        uint64_t v37 = 0;
        if (ctu::cf::convert_copy())
        {
          char v26 = v34;
          uint64_t v34 = v37;
          char v38 = v26;
          sub_1000558F4(&v38);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        unint64_t v27 = v34;
        unint64_t v33 = v34;
        uint64_t v34 = 0;
        sub_1000558F4(&v34);
        if (SHIBYTE(v36) < 0) {
          operator delete(__p[0]);
        }
        (*(void (**)(uint64_t, const void *))(*(void *)v16 + 40))(v16, v27);
        sub_1000558F4(&v33);
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }
      else
      {
        if (v8)
        {
          uint64_t v17 = *(unsigned __int8 *)(v1 + 31);
          BOOL v18 = (v17 & 0x80u) != 0;
          if ((v17 & 0x80u) != 0) {
            uint64_t v17 = *(void *)(v1 + 16);
          }
          if (v18) {
            uint64_t v19 = *(const char **)(v1 + 8);
          }
          else {
            uint64_t v19 = (const char *)(v1 + 8);
          }
          if (v17) {
            uint32_t v20 = v19;
          }
          else {
            uint32_t v20 = "<invalid>";
          }
          uint64_t v21 = v1 + 32;
          if (*(char *)(v1 + 55) < 0) {
            uint64_t v21 = *v4;
          }
          uint64_t v22 = (void *)(v1 + 56);
          if (*(char *)(v1 + 79) < 0) {
            uint64_t v22 = (void *)*v22;
          }
          *(_DWORD *)std::string buf = 136316162;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v40 = v20;
          __int16 v41 = 2080;
          uint64_t v42 = v21;
          __int16 v43 = 2080;
          char v44 = v22;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sfailed to remove session for %s: internal:%s = network:%s - restoring", buf, 0x34u);
        }
        *(void *)std::string buf = v1 + 8;
        uint64_t v23 = sub_100A13388((uint64_t **)(v2 + 216), (void **)(v1 + 8), (long long **)buf);
        sub_10006C514((uint64_t **)v23 + 7, v5);
        sub_1000FECD4((uint64_t)(v5 + 4));
        operator delete(v5);
        *(void *)std::string buf = v1 + 8;
        if (!sub_100A13388((uint64_t **)(v2 + 216), (void **)(v1 + 8), (long long **)buf)[9]) {
          sub_100A13A58((uint64_t **)(v2 + 216), (void **)(v1 + 8));
        }
        *(void *)std::string buf = v1 + 8;
        BOOL v24 = sub_100A13388((uint64_t **)(v2 + 192), (void **)(v1 + 8), (long long **)buf);
        *(void *)std::string buf = v1 + 32;
        uint64_t v25 = sub_100366370((uint64_t **)v24 + 7, (void **)(v1 + 32), (uint64_t)&unk_10144E20E, (long long **)buf);
        std::string::operator=((std::string *)(v25 + 7), (const std::string *)(v1 + 56));
      }
    }
  }
  sub_100A130E4(&v30);
  return sub_100046B58((uint64_t *)&v29);
}

void sub_100A139DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_100A130E4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100A13A58(uint64_t **a1, void **a2)
{
  uint64_t v3 = (uint64_t *)sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v3)
  {
    uint64_t v4 = v3;
    sub_1000F5B04(a1, v3);
    sub_100A10F5C((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

uint64_t *sub_100A13AC0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = sub_100046F68(*(void *)v1 + 120, (void **)(*(void *)v1 + 144));
  if ((void **)(v2 + 128) == v3) {
    char v4 = 0;
  }
  else {
    char v4 = (*(uint64_t (**)(void *))(*(void *)v3[7] + 80))(v3[7]);
  }
  uint64_t v5 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315650;
    BOOL v10 = "";
    __int16 v11 = 2080;
    int v12 = "";
    __int16 v13 = 2080;
    uint64_t v14 = asStringBool(v4);
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%shasDedicatedBearerSupport is %s", buf, 0x20u);
  }
  sub_1000607A8(v1 + 8, v4);
  sub_10031EA88(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100A13BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100A13C14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100A13C94(void **a1)
{
  uint64_t v1 = *a1;
  unint64_t v28 = a1;
  BOOL v29 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (void **)(*v1 + 144);
  uint64_t v4 = sub_100046F68(*v1 + 120, v3);
  if ((void **)(v2 + 128) == v4)
  {
    uint64_t v16 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *(unsigned __int8 *)(v2 + 167);
      BOOL v18 = (v17 & 0x80u) != 0;
      if ((v17 & 0x80u) != 0) {
        uint64_t v17 = *(void *)(v2 + 152);
      }
      if (v18) {
        uint64_t v19 = *(void ***)(v2 + 144);
      }
      else {
        uint64_t v19 = v3;
      }
      if (v17) {
        uint32_t v20 = (const char *)v19;
      }
      else {
        uint32_t v20 = "<invalid>";
      }
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = "";
      WORD2(__p[1]) = 2080;
      *(void **)((char *)&__p[1] + 6) = "";
      HIWORD(__p[2]) = 2080;
      uint64_t v35 = v20;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sno controller for active personality '%s'", (uint8_t *)__p, 0x20u);
    }
    CFErrorRef v21 = CFErrorCreate(0, kCFErrorDomainPOSIX, 2, 0);
    sub_100A14120(v1[7], 0, (uint64_t)v21);
  }
  else
  {
    uint64_t v5 = v4;
    CFUUIDRef v33 = CFUUIDCreate(0);
    CFStringRef v32 = CFUUIDCreateString(0, v33);
    memset(__p, 0, sizeof(__p));
    ctu::cf::assign();
    *(_OWORD *)uint64_t v30 = 0u;
    uint64_t v31 = 0;
    int v6 = v5[7];
    sub_100058DB0(__p, "custom-qos");
    int v7 = (*(uint64_t (**)(void *, void **, void **, void *))(*(void *)v6 + 104))(v6, __p, v30, v1 + 1);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = *(NSObject **)(v2 + 48);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v9)
      {
        uint64_t v10 = *(unsigned __int8 *)(v2 + 167);
        BOOL v11 = (v10 & 0x80u) != 0;
        if ((v10 & 0x80u) != 0) {
          uint64_t v10 = *(void *)(v2 + 152);
        }
        if (v11) {
          int v12 = *(void ***)(v2 + 144);
        }
        else {
          int v12 = v3;
        }
        if (v10) {
          __int16 v13 = (const char *)v12;
        }
        else {
          __int16 v13 = "<invalid>";
        }
        uint64_t v14 = v30;
        if (v31 < 0) {
          uint64_t v14 = (void **)v30[0];
        }
        LODWORD(__p[0]) = 136315906;
        *(void **)((char *)__p + 4) = "";
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = "";
        HIWORD(__p[2]) = 2080;
        uint64_t v35 = v13;
        __int16 v36 = 2080;
        uint64_t v37 = v14;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sattempting new session for %s: internal:%s", (uint8_t *)__p, 0x2Au);
      }
      __p[0] = v3;
      long long v15 = sub_100A1315C((uint64_t **)(v2 + 168), v3, (long long **)__p);
      sub_100046BAC((uint64_t **)v15 + 7, v30, (uint64_t)v30);
      sub_100A14120(v1[7], (uint64_t)v32, 0);
    }
    else
    {
      if (v9)
      {
        uint64_t v22 = *(unsigned __int8 *)(v2 + 167);
        BOOL v23 = (v22 & 0x80u) != 0;
        if ((v22 & 0x80u) != 0) {
          uint64_t v22 = *(void *)(v2 + 152);
        }
        if (v23) {
          BOOL v24 = *(void ***)(v2 + 144);
        }
        else {
          BOOL v24 = v3;
        }
        if (v22) {
          uint64_t v25 = (const char *)v24;
        }
        else {
          uint64_t v25 = "<invalid>";
        }
        LODWORD(__p[0]) = 136315650;
        *(void **)((char *)__p + 4) = "";
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = "";
        HIWORD(__p[2]) = 2080;
        uint64_t v35 = v25;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sunable to initate <addSession> for %s", (uint8_t *)__p, 0x20u);
      }
      CFErrorRef v26 = CFErrorCreate(0, kCFErrorDomainPOSIX, 45, 0);
      sub_100A14120(v1[7], 0, (uint64_t)v26);
    }
    if (SHIBYTE(v31) < 0) {
      operator delete(v30[0]);
    }
    sub_1000558F4((const void **)&v32);
    sub_10012577C((const void **)&v33);
  }
  sub_100A140B8((uint64_t *)&v29);
  return sub_100046B58((uint64_t *)&v28);
}

void sub_100A14034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, const void *a18, const void *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1000558F4(&a18);
  sub_10012577C(&a19);
  sub_100A140B8(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A140B8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A10A28((void *)(v1 + 32));
    uint64_t v2 = (void **)(v1 + 8);
    sub_10005CBF0(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100A14120(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

uint64_t sub_100A14174(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100A141F4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v56 = a1;
  uint64_t v57 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (uint64_t **)(*(void *)v1 + 168);
  uint64_t v4 = *v3;
  uint64_t v5 = *(void *)v1 + 176;
  if (*v3 == (uint64_t *)v5)
  {
LABEL_9:
    uint64_t v10 = *(void ***)(v2 + 192);
    if (v10 == (void **)(v2 + 200))
    {
LABEL_18:
      long long v15 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = (const char *)(v1 + 8);
        if (*(char *)(v1 + 31) < 0) {
          uint64_t v16 = *(const char **)v16;
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v59 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sunknown beared id: %s", buf, 0x20u);
      }
      CFErrorRef v17 = CFErrorCreate(0, kCFErrorDomainPOSIX, 2, 0);
      sub_100A1492C(*(void *)(v1 + 56), (uint64_t)v17);
      goto LABEL_88;
    }
    BOOL v11 = (uint64_t *)(v1 + 8);
    while (1)
    {
      int v12 = sub_100046F68((uint64_t)(v10 + 7), (void **)(v1 + 8));
      if (v10 + 8 != v12) {
        break;
      }
      __int16 v13 = (void **)v10[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          __int16 v13 = (void **)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void **)v10[2];
          BOOL v9 = *v14 == v10;
          uint64_t v10 = v14;
        }
        while (!v9);
      }
      uint64_t v10 = v14;
      if (v14 == (void **)(v2 + 200)) {
        goto LABEL_18;
      }
    }
    sub_100A1492C(*(void *)(v1 + 56), 0);
    BOOL v24 = (void ***)(v12 + 7);
    uint64_t v25 = sub_100046F68(v2 + 120, v10 + 4);
    if ((void **)(v2 + 128) == v25)
    {
      uint64_t v40 = *(NSObject **)(v2 + 48);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v41 = (const char *)(v2 + 144);
        uint64_t v42 = *(unsigned __int8 *)(v2 + 167);
        int v43 = (char)v42;
        if ((v42 & 0x80u) != 0) {
          uint64_t v42 = *(void *)(v2 + 152);
        }
        if (v43 < 0) {
          __int16 v41 = *(const char **)(v2 + 144);
        }
        if (!v42) {
          __int16 v41 = "<invalid>";
        }
        uint64_t v44 = v1 + 8;
        if (*(char *)(v1 + 31) < 0) {
          uint64_t v44 = *v11;
        }
        uint64_t v45 = v12 + 7;
        if (*((char *)v12 + 79) < 0) {
          uint64_t v45 = *v24;
        }
        *(_DWORD *)std::string buf = 136316162;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v59 = v41;
        __int16 v60 = 2080;
        int v61 = (const char *)v44;
        __int16 v62 = 2080;
        int v63 = v45;
        uint64_t v46 = "#I %s%sno controller for active personality '%s' - just dropping internal:%s network:%s";
        char v47 = v40;
        goto LABEL_84;
      }
    }
    else
    {
      CFErrorRef v26 = v25[7];
      sub_100058DB0(buf, "custom-qos");
      unint64_t v27 = *(uint64_t (**)(void *, uint8_t *, uint64_t, void **))(*(void *)v26 + 112);
      unint64_t v28 = v26;
      BOOL v29 = (void ***)(v12 + 7);
      int v30 = v27(v28, buf, v1 + 8, v12 + 7);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      log = *(NSObject **)(v2 + 48);
      BOOL v31 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
      if (v30)
      {
        if (v31)
        {
          CFStringRef v32 = (void *)*((unsigned __int8 *)v10 + 55);
          BOOL v33 = (char)v32 < 0;
          if ((char)v32 < 0) {
            CFStringRef v32 = v10[5];
          }
          if (v33) {
            uint64_t v34 = (const char *)v10[4];
          }
          else {
            uint64_t v34 = (const char *)(v10 + 4);
          }
          if (v32) {
            uint64_t v35 = v34;
          }
          else {
            uint64_t v35 = "<invalid>";
          }
          uint64_t v36 = v1 + 8;
          if (*(char *)(v1 + 31) < 0) {
            uint64_t v36 = *v11;
          }
          uint64_t v37 = v12 + 7;
          if (*((char *)v12 + 79) < 0) {
            uint64_t v37 = *v29;
          }
          *(_DWORD *)std::string buf = 136316162;
          *(void *)&uint8_t buf[4] = "";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "";
          *(_WORD *)&unsigned char buf[22] = 2080;
          uint64_t v59 = v35;
          __int16 v60 = 2080;
          int v61 = (const char *)v36;
          __int16 v62 = 2080;
          int v63 = v37;
          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I %s%sremoving session for %s: internal:%s = network:%s", buf, 0x34u);
        }
        *(void *)std::string buf = v10 + 4;
        char v38 = sub_100A13388((uint64_t **)(v2 + 216), v10 + 4, (long long **)buf);
        *(void *)std::string buf = v1 + 8;
        BOOL v39 = sub_100366370((uint64_t **)v38 + 7, (void **)(v1 + 8), (uint64_t)&unk_10144E20E, (long long **)buf);
        std::string::operator=((std::string *)(v39 + 7), (const std::string *)(v12 + 7));
        goto LABEL_86;
      }
      BOOL v24 = (void ***)(v12 + 7);
      if (v31)
      {
        uint64_t v48 = (void *)*((unsigned __int8 *)v10 + 55);
        BOOL v49 = (char)v48 < 0;
        if ((char)v48 < 0) {
          uint64_t v48 = v10[5];
        }
        if (v49) {
          BOOL v50 = (const char *)v10[4];
        }
        else {
          BOOL v50 = (const char *)(v10 + 4);
        }
        if (v48) {
          __int16 v51 = v50;
        }
        else {
          __int16 v51 = "<invalid>";
        }
        uint64_t v52 = v1 + 8;
        if (*(char *)(v1 + 31) < 0) {
          uint64_t v52 = *v11;
        }
        __int16 v53 = v12 + 7;
        if (*((char *)v12 + 79) < 0) {
          __int16 v53 = *v29;
        }
        *(_DWORD *)std::string buf = 136316162;
        *(void *)&uint8_t buf[4] = "";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "";
        *(_WORD *)&unsigned char buf[22] = 2080;
        uint64_t v59 = v51;
        __int16 v60 = 2080;
        int v61 = (const char *)v52;
        __int16 v62 = 2080;
        int v63 = v53;
        uint64_t v46 = "#I %s%sunable to proceed with removing for %s: internal:%s = network:%s -  just droping";
        char v47 = log;
LABEL_84:
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, v46, buf, 0x34u);
      }
    }
    (*(void (**)(uint64_t, void **, uint64_t, void ***, uint64_t))(*(void *)v2 + 136))(v2, v10 + 4, v1 + 8, v24, 1);
LABEL_86:
    sub_10006C514((uint64_t **)v10 + 7, (uint64_t *)v12);
    sub_1000FECD4((uint64_t)(v12 + 4));
    operator delete(v12);
    if (!v10[9]) {
      sub_100A13A58((uint64_t **)(v2 + 192), v10 + 4);
    }
    goto LABEL_88;
  }
  while (1)
  {
    int v6 = sub_100046F68((uint64_t)(v4 + 7), (void **)(v1 + 8));
    if (v4 + 8 != (uint64_t *)v6) {
      break;
    }
    int v7 = (uint64_t *)v4[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        int v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        uint64_t v8 = (uint64_t *)v4[2];
        BOOL v9 = *v8 == (void)v4;
        uint64_t v4 = v8;
      }
      while (!v9);
    }
    uint64_t v4 = v8;
    if (v8 == (uint64_t *)v5) {
      goto LABEL_9;
    }
  }
  sub_1000E1C44((uint64_t **)v4 + 7, (uint64_t)v6);
  if (!v4[9]) {
    sub_100A13320(v3, (void **)v4 + 4);
  }
  BOOL v18 = *(NSObject **)(v2 + 48);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = v1 + 8;
    if (*(char *)(v1 + 31) < 0) {
      uint64_t v19 = *(void *)(v1 + 8);
    }
    uint64_t v20 = *((unsigned __int8 *)v4 + 55);
    BOOL v21 = (v20 & 0x80u) != 0;
    if ((v20 & 0x80u) != 0) {
      uint64_t v20 = v4[5];
    }
    if (v21) {
      uint64_t v22 = (const char *)v4[4];
    }
    else {
      uint64_t v22 = (const char *)(v4 + 4);
    }
    if (v20) {
      BOOL v23 = v22;
    }
    else {
      BOOL v23 = "<invalid>";
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v59 = (const char *)v19;
    __int16 v60 = 2080;
    int v61 = v23;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sincomplete attempt %s erased for %s", buf, 0x2Au);
  }
  sub_100A1492C(*(void *)(v1 + 56), 0);
  memset(buf, 0, sizeof(buf));
  (*(void (**)(uint64_t, uint64_t *, uint64_t, uint8_t *, uint64_t))(*(void *)v2 + 136))(v2, v4 + 4, v1 + 8, buf, 1);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
LABEL_88:
  sub_100A148CC(&v57);
  return sub_100046B58((uint64_t *)&v56);
}

void sub_100A1488C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100A148CC(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A148CC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A10AAC((void *)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100A1492C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v3);
}

uint64_t *sub_100A1497C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v20 = a1;
  BOOL v21 = v1;
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(NSObject **)(*v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sremoveAllDedicatedBearers", buf, 0x16u);
  }
  uint64_t v4 = (void *)v2[24];
  if (v4 != v2 + 25)
  {
    do
    {
      uint64_t v5 = (void *)v4[7];
      if (v5 != v4 + 8)
      {
        do
        {
          if (*((char *)v5 + 55) < 0)
          {
            sub_10004FC84(__dst, (void *)v5[4], v5[5]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *((_OWORD *)v5 + 2);
            uint64_t v26 = v5[6];
          }
          if (SHIBYTE(v26) < 0)
          {
            sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)__dst;
            uint64_t v29 = v26;
          }
          int v30 = 0;
          if (SHIBYTE(v29) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v29;
          }
          BOOL v31 = 0;
          if (ctu::cf::convert_copy())
          {
            int v6 = v30;
            int v30 = v31;
            v22[0] = v6;
            sub_1000558F4((const void **)v22);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          unint64_t v27 = v30;
          int v30 = 0;
          sub_1000558F4((const void **)&v30);
          if (SHIBYTE(v29) < 0) {
            operator delete(__p[0]);
          }
          *(void *)std::string buf = off_101A29B20;
          BOOL v33 = buf;
          (*(void (**)(void *, void *, unsigned char *))(*v2 + 16))(v2, v27, buf);
          sub_100A10AAC(buf);
          sub_1000558F4((const void **)&v27);
          if (SHIBYTE(v26) < 0) {
            operator delete(__dst[0]);
          }
          int v7 = (void *)v5[1];
          if (v7)
          {
            do
            {
              uint64_t v8 = v7;
              int v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              uint64_t v8 = (void *)v5[2];
              BOOL v9 = *v8 == (void)v5;
              uint64_t v5 = v8;
            }
            while (!v9);
          }
          uint64_t v5 = v8;
        }
        while (v8 != v4 + 8);
      }
      uint64_t v10 = (void *)v4[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v4[2];
          BOOL v9 = *v11 == (void)v4;
          uint64_t v4 = v11;
        }
        while (!v9);
      }
      uint64_t v4 = v11;
    }
    while (v11 != v2 + 25);
  }
  int v12 = (void *)v2[21];
  if (v12 != v2 + 22)
  {
    do
    {
      __int16 v13 = (void *)v12[7];
      if (v13 != v12 + 8)
      {
        do
        {
          if (*((char *)v13 + 55) < 0)
          {
            sub_10004FC84(v22, (void *)v13[4], v13[5]);
          }
          else
          {
            *(_OWORD *)uint64_t v22 = *((_OWORD *)v13 + 2);
            uint64_t v23 = v13[6];
          }
          if (SHIBYTE(v23) < 0)
          {
            sub_10004FC84(__p, v22[0], (unint64_t)v22[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v22;
            uint64_t v29 = v23;
          }
          unint64_t v27 = 0;
          if (SHIBYTE(v29) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v29;
          }
          int v30 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v14 = v27;
            unint64_t v27 = v30;
            BOOL v31 = v14;
            sub_1000558F4((const void **)&v31);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          BOOL v24 = v27;
          unint64_t v27 = 0;
          sub_1000558F4((const void **)&v27);
          if (SHIBYTE(v29) < 0) {
            operator delete(__p[0]);
          }
          *(void *)std::string buf = off_101A29BB0;
          BOOL v33 = buf;
          (*(void (**)(void *, const void *, unsigned char *))(*v2 + 16))(v2, v24, buf);
          sub_100A10AAC(buf);
          sub_1000558F4(&v24);
          if (SHIBYTE(v23) < 0) {
            operator delete(v22[0]);
          }
          long long v15 = (void *)v13[1];
          if (v15)
          {
            do
            {
              uint64_t v16 = v15;
              long long v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              uint64_t v16 = (void *)v13[2];
              BOOL v9 = *v16 == (void)v13;
              __int16 v13 = v16;
            }
            while (!v9);
          }
          __int16 v13 = v16;
        }
        while (v16 != v12 + 8);
      }
      CFErrorRef v17 = (void *)v12[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          CFErrorRef v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v12[2];
          BOOL v9 = *v18 == (void)v12;
          int v12 = v18;
        }
        while (!v9);
      }
      int v12 = v18;
    }
    while (v18 != v2 + 22);
  }
  sub_100A1492C(v1[4], 0);
  sub_100A14F50((uint64_t *)&v21);
  return sub_100046B58((uint64_t *)&v20);
}

void sub_100A14E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
}

uint64_t *sub_100A14F50(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A10AAC((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100A14FA4()
{
}

void *sub_100A14FB8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A29B20;
  return result;
}

void sub_100A14FF0(uint64_t a1, void *a2)
{
  *a2 = off_101A29B20;
}

uint64_t sub_100A1501C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1505C()
{
}

void sub_100A1506C()
{
}

void *sub_100A15080()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A29BB0;
  return result;
}

void sub_100A150B8(uint64_t a1, void *a2)
{
  *a2 = off_101A29BB0;
}

uint64_t sub_100A150E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A15124()
{
}

uint64_t sub_100A15130(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100A151B0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v16 = a1;
  uint64_t v17 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void **)(*(void *)v1 + 192);
  uint64_t v4 = *(void *)v1 + 200;
  if (v3 == (void *)v4)
  {
LABEL_9:
    uint64_t v8 = *(void **)(v2 + 168);
    BOOL v9 = (void *)(v2 + 176);
    if (v8 == v9)
    {
      BOOL v11 = 0;
    }
    else
    {
      do
      {
        uint64_t v10 = sub_100046F68((uint64_t)(v8 + 7), (void **)(v1 + 8));
        BOOL v11 = v8 + 8 != v10;
        if (v8 + 8 != v10) {
          break;
        }
        int v12 = (void *)v8[1];
        if (v12)
        {
          do
          {
            __int16 v13 = v12;
            int v12 = (void *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            __int16 v13 = (void *)v8[2];
            BOOL v7 = *v13 == (void)v8;
            uint64_t v8 = v13;
          }
          while (!v7);
        }
        uint64_t v8 = v13;
      }
      while (v13 != v9);
    }
  }
  else
  {
    while (v3 + 8 == sub_100046F68((uint64_t)(v3 + 7), (void **)(v1 + 8)))
    {
      uint64_t v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          int v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          int v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
      if (v6 == (void *)v4) {
        goto LABEL_9;
      }
    }
    BOOL v11 = 1;
  }
  uint64_t v14 = *(void *)(v1 + 56);
  BOOL v19 = v11;
  uint64_t v18 = 0;
  if (!v14) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, BOOL *, uint64_t *))(*(void *)v14 + 48))(v14, &v19, &v18);
  sub_100A15344(&v17);
  return sub_100046B58((uint64_t *)&v16);
}

void sub_100A15320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100A15344(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A10B30((void *)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100A153A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100A15424(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = (void *)*v1;
  CFArrayRef theArray = 0;
  CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFArrayRef v4 = theArray;
    CFArrayRef theArray = Mutable;
    *(void *)std::string buf = v4;
    sub_1000440D4((const void **)buf);
  }
  uint64_t v5 = (void *)v2[24];
  if (v5 != v2 + 25)
  {
    do
    {
      int v6 = (void *)v5[7];
      if (v6 != v5 + 8)
      {
        do
        {
          BOOL v7 = theArray;
          if (*((char *)v6 + 55) < 0)
          {
            sub_10004FC84(__dst, (void *)v6[4], v6[5]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *((_OWORD *)v6 + 2);
            uint64_t v31 = v6[6];
          }
          if (SHIBYTE(v31) < 0)
          {
            sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)__dst;
            uint64_t v35 = v31;
          }
          uint64_t v36 = 0;
          if (SHIBYTE(v35) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v35;
          }
          uint64_t v37 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v8 = v36;
            uint64_t v36 = v37;
            v27[0] = v8;
            sub_1000558F4((const void **)v27);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          xpc_object_t value = v36;
          uint64_t v36 = 0;
          sub_1000558F4((const void **)&v36);
          if (SHIBYTE(v35) < 0) {
            operator delete(__p[0]);
          }
          CFArrayAppendValue(v7, value);
          sub_1000558F4((const void **)&value);
          if (SHIBYTE(v31) < 0) {
            operator delete(__dst[0]);
          }
          BOOL v9 = (void *)v6[1];
          if (v9)
          {
            do
            {
              uint64_t v10 = v9;
              BOOL v9 = (void *)*v9;
            }
            while (v9);
          }
          else
          {
            do
            {
              uint64_t v10 = (void *)v6[2];
              BOOL v11 = *v10 == (void)v6;
              int v6 = v10;
            }
            while (!v11);
          }
          int v6 = v10;
        }
        while (v10 != v5 + 8);
      }
      int v12 = (void *)v5[1];
      if (v12)
      {
        do
        {
          __int16 v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          __int16 v13 = (void *)v5[2];
          BOOL v11 = *v13 == (void)v5;
          uint64_t v5 = v13;
        }
        while (!v11);
      }
      uint64_t v5 = v13;
    }
    while (v13 != v2 + 25);
  }
  uint64_t v14 = (void *)v2[21];
  if (v14 != v2 + 22)
  {
    do
    {
      long long v15 = (void *)v14[7];
      if (v15 != v14 + 8)
      {
        do
        {
          uint64_t v16 = theArray;
          if (*((char *)v15 + 55) < 0)
          {
            sub_10004FC84(v27, (void *)v15[4], v15[5]);
          }
          else
          {
            *(_OWORD *)unint64_t v27 = *((_OWORD *)v15 + 2);
            uint64_t v28 = v15[6];
          }
          if (SHIBYTE(v28) < 0)
          {
            sub_10004FC84(__p, v27[0], (unint64_t)v27[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v27;
            uint64_t v35 = v28;
          }
          xpc_object_t value = 0;
          if (SHIBYTE(v35) < 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v35;
          }
          uint64_t v36 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v17 = value;
            xpc_object_t value = v36;
            uint64_t v37 = v17;
            sub_1000558F4((const void **)&v37);
          }
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v29 = value;
          xpc_object_t value = 0;
          sub_1000558F4((const void **)&value);
          if (SHIBYTE(v35) < 0) {
            operator delete(__p[0]);
          }
          CFArrayAppendValue(v16, v29);
          sub_1000558F4((const void **)&v29);
          if (SHIBYTE(v28) < 0) {
            operator delete(v27[0]);
          }
          uint64_t v18 = (void *)v15[1];
          if (v18)
          {
            do
            {
              BOOL v19 = v18;
              uint64_t v18 = (void *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              BOOL v19 = (void *)v15[2];
              BOOL v11 = *v19 == (void)v15;
              long long v15 = v19;
            }
            while (!v11);
          }
          long long v15 = v19;
        }
        while (v19 != v14 + 8);
      }
      uint64_t v20 = (void *)v14[1];
      if (v20)
      {
        do
        {
          BOOL v21 = v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          BOOL v21 = (void *)v14[2];
          BOOL v11 = *v21 == (void)v14;
          uint64_t v14 = v21;
        }
        while (!v11);
      }
      uint64_t v14 = v21;
    }
    while (v21 != v2 + 22);
  }
  uint64_t v22 = v2[6];
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    int Count = CFArrayGetCount(theArray);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v39 = Count;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I %s%sgetListOfPresentDedicatedBearers reports %d elements", buf, 0x1Cu);
  }
  sub_100A159F4((uint64_t)(v1 + 1), (uint64_t)theArray);
  sub_1000440D4((const void **)&theArray);
  sub_100A159A4((uint64_t *)&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100A158B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,const void *a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,char a36)
{
}

uint64_t *sub_100A159A4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A10BB4((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100A159F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t sub_100A15A48(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100A15AC8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  __int16 v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%sgetQoSLinkCharacteristics", buf, 0x16u);
  }
  uint64_t v4 = sub_100046F68(v2 + 120, (void **)(v2 + 144));
  if ((void **)(v2 + 128) == v4)
  {
    int v6 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(unsigned __int8 *)(v2 + 167);
      BOOL v8 = (v7 & 0x80u) != 0;
      if ((v7 & 0x80u) != 0) {
        uint64_t v7 = *(void *)(v2 + 152);
      }
      if (v8) {
        BOOL v9 = *(const char **)(v2 + 144);
      }
      else {
        BOOL v9 = (const char *)(v2 + 144);
      }
      if (v7) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "";
      __int16 v18 = 2080;
      BOOL v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sno controller for active personality '%s'", buf, 0x20u);
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    CFErrorRef v11 = CFErrorCreate(0, kCFErrorDomainPOSIX, 2, 0);
    sub_100A15D9C(v1[4], (uint64_t)buf, (uint64_t)v11);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  else
  {
    uint64_t v5 = v4[7];
    sub_100058DB0(buf, "custom-qos");
    (*(void (**)(uint64_t *__return_ptr, void *, unsigned char *))(*(void *)v5 + 88))(&v15, v5, buf);
    sub_100A15D9C(v1[4], (uint64_t)&v15, 0);
    if (v16) {
      sub_10004D2C8(v16);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_100A15D4C((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100A15CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_100A15D4C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A15D4C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100A10C38((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100A15D9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, a2, &v4);
}

uint64_t *sub_100A15DEC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  __int16 v13 = a1;
  uint64_t v14 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(NSObject **)(*v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "";
    __int16 v16 = 2080;
    uint64_t v17 = "";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%srequestQoSLinkCharacteristics", buf, 0x16u);
  }
  uint64_t v4 = sub_100046F68(v2 + 120, (void **)(v2 + 144));
  if ((void **)(v2 + 128) == v4)
  {
    uint64_t v7 = *(NSObject **)(v2 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(unsigned __int8 *)(v2 + 167);
      BOOL v9 = (v8 & 0x80u) != 0;
      if ((v8 & 0x80u) != 0) {
        uint64_t v8 = *(void *)(v2 + 152);
      }
      if (v9) {
        uint64_t v10 = *(const char **)(v2 + 144);
      }
      else {
        uint64_t v10 = (const char *)(v2 + 144);
      }
      if (v8) {
        CFErrorRef v11 = v10;
      }
      else {
        CFErrorRef v11 = "<invalid>";
      }
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = "";
      __int16 v16 = 2080;
      uint64_t v17 = "";
      __int16 v18 = 2080;
      BOOL v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s%sno controller for active personality '%s'", buf, 0x20u);
    }
    CFErrorRef v6 = CFErrorCreate(0, kCFErrorDomainPOSIX, 2, 0);
  }
  else
  {
    uint64_t v5 = v4[7];
    sub_100058DB0(buf, "custom-qos");
    (*(void (**)(void *, unsigned char *))(*(void *)v5 + 96))(v5, buf);
    if (SHIBYTE(v18) < 0) {
      operator delete(*(void **)buf);
    }
    CFErrorRef v6 = 0;
  }
  sub_100A1492C(v1[4], (uint64_t)v6);
  sub_100A14F50((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_100A15FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100A14F50(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100A16018(uint64_t a1, void *a2)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = (unint64_t *)(a1 + 24);
  *(void *)(a1 + 56) = 0;
  uint64_t v4 = a1 + 56;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = a1 + 56;
  uint64_t v5 = (void *)(a1 + 48);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v6 = a1 + 72;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if (*a2)
  {
    *(_DWORD *)a1 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
    (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 64))(&v17);
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)v6);
    }
    *(_OWORD *)uint64_t v6 = v17;
    *(void *)(v6 + 16) = v18;
    *(void *)(a1 + 8) = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
    (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 56))(&v17);
    sub_10010C0E0((uint64_t)v5, *(void **)(a1 + 56));
    uint64_t v8 = (void *)*((void *)&v17 + 1);
    *(void *)(a1 + 48) = v17;
    *(void *)(a1 + 56) = v8;
    uint64_t v9 = v18;
    *(void *)(a1 + 64) = v18;
    if (v9)
    {
      v8[2] = v4;
      *(void *)&long long v17 = (char *)&v17 + 8;
      *((void *)&v17 + 1) = 0;
      uint64_t v18 = 0;
      uint64_t v8 = 0;
    }
    else
    {
      void *v5 = v4;
    }
    sub_10010C0E0((uint64_t)&v17, v8);
    __int16 v16 = 0;
    (*(void (**)(const void **__return_ptr))(*(void *)*a2 + 40))(&v16);
    if (v16) {
      uint64_t v10 = sub_10008324C;
    }
    else {
      uint64_t v10 = 0;
    }
    if (!v10) {
      sub_10006E4A8(v3, 0, 0, 0);
    }
    long long v17 = 0uLL;
    uint64_t v18 = 0;
    ctu::cf::assign();
    long long v11 = v17;
    size_t v12 = *((void *)&v17 + 1) - v17;
    uint64_t v13 = *(void *)(a1 + 24);
    unint64_t v14 = *(void *)(a1 + 32) - v13;
    if (*((void *)&v17 + 1) - (void)v17 <= v14)
    {
      if (*((void *)&v17 + 1) - (void)v17 < v14) {
        *(void *)(a1 + 32) = v13 + v12;
      }
    }
    else
    {
      sub_10011FDF0(v3, *((void *)&v17 + 1) - v17 - v14);
    }
    if (*((void *)&v11 + 1) != (void)v11) {
      memmove((void *)*v3, (const void *)v11, v12);
    }
    if ((void)v11) {
      operator delete((void *)v11);
    }
    sub_100030068(&v16);
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(void *)(a1 + 8) = -1;
  }
  return a1;
}

void sub_100A16290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  sub_100030068((const void **)&a9);
  if (*(char *)(v11 + 95) < 0) {
    operator delete(*v15);
  }
  sub_10010C0E0(v13, *v14);
  long long v17 = *v12;
  if (*v12)
  {
    *(void *)(v11 + 32) = v17;
    operator delete(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A16310(uint64_t a1)
{
  *(void *)(a1 + 32) = *(void *)(a1 + 24);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  sub_10010C0E0(a1 + 48, *(void **)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100A16368(uint64_t a1, os_log_t *a2, int a3)
{
  *(_DWORD *)(a1 + 16) = a3;
  uint64_t v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    char v12 = 8;
    strcpy(__p, "--------");
    sub_100058DB0(v7, __p);
    if (v12 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v5 = v7;
    if (v8 < 0) {
      uint64_t v5 = (void **)v7[0];
    }
    int v6 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)long long __p = 136315394;
    *(void *)&__p[4] = v5;
    __int16 v10 = 1024;
    int v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s derived response : %d", __p, 0x12u);
    if (v8 < 0) {
      operator delete(v7[0]);
    }
  }
}

void sub_100A16478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A16494(uint64_t a1, os_log_t *a2)
{
  if ((*(_DWORD *)a1 - 400) <= 0x63)
  {
    uint64_t v2 = *a2;
    BOOL v3 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v3)
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v5 = "#I MMS will not retry for BAD HTTP request (class 4XX error)...";
      int v6 = buf;
LABEL_4:
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v5, v6, 2u);
      return 0;
    }
    return result;
  }
  if ((*(_DWORD *)a1 - 500) <= 0x63)
  {
    uint64_t v7 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v18 = 0;
      char v8 = "#I MMS will retry for BAD server (class 5XX error)...";
      uint64_t v9 = (uint8_t *)&v18;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, v9, 2u);
      return 1;
    }
    return 1;
  }
  if ((unint64_t)(*(void *)(a1 + 8) + 1009) <= 8 && ((1 << (*(unsigned char *)(a1 + 8) - 15)) & 0x171) != 0)
  {
    uint64_t v7 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v17 = 0;
      char v8 = "#I MMS will retry for transient NSUrlErrors...";
      uint64_t v9 = v17;
      goto LABEL_14;
    }
    return 1;
  }
  int v11 = *(_DWORD *)(a1 + 16);
  if ((v11 + 3) >= 2)
  {
    if (v11 != -1)
    {
      uint64_t v2 = *a2;
      BOOL v13 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v13)
      {
        __int16 v14 = 0;
        uint64_t v5 = "#I No MMS retry..";
        int v6 = (uint8_t *)&v14;
        goto LABEL_4;
      }
      return result;
    }
    uint64_t v7 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v15 = 0;
      char v8 = "#I MMS will retry for INTERNAL_ERROR";
      uint64_t v9 = (uint8_t *)&v15;
      goto LABEL_14;
    }
    return 1;
  }
  uint64_t v2 = *a2;
  BOOL v12 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v12)
  {
    __int16 v16 = 0;
    uint64_t v5 = "#I MMS will not retry for BAD_CONTENT or MESSAGE_TOO_LARGE";
    int v6 = (uint8_t *)&v16;
    goto LABEL_4;
  }
  return result;
}

void sub_100A1666C(int *a1, os_log_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I MMS http response:", (uint8_t *)&buf, 2u);
    uint64_t v4 = *v2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = operator new(0x20uLL);
    memset(v5, 45, 25);
    sub_100058DB0(&buf, (char *)v5);
    operator delete(v5);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&__dst, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v4 = *v2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&__dst, "--------");
    sub_100058DB0(__p, (char *)&__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v44 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = *(unsigned char **)__p;
    }
    int v8 = *a1;
    uint64_t v9 = *((void *)a1 + 1);
    switch(v9)
    {
      case -1009:
        __int16 v10 = "Not connected to Internet";
        break;
      case -1008:
      case -1007:
      case -1006:
      case -1002:
        goto LABEL_21;
      case -1005:
        __int16 v10 = "Network connection lost";
        break;
      case -1004:
        __int16 v10 = "Cannot reach host";
        break;
      case -1003:
        __int16 v10 = "Cannot find host";
        break;
      case -1001:
        __int16 v10 = "Error timed out";
        break;
      default:
        if (v9 == -1)
        {
          __int16 v10 = "No error";
        }
        else if (v9)
        {
LABEL_21:
          __int16 v10 = "error unhandled";
        }
        else
        {
          __int16 v10 = "OK";
        }
        break;
    }
    sub_100058DB0(&__dst, v10);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v8;
    WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
    HIDWORD(buf.__r_.__value_.__r.__words[2]) = v9;
    LOWORD(v46[0]) = 2080;
    *(void *)((char *)v46 + 2) = p_dst;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s http response: %d NSUrlError: %d(%s) ", (uint8_t *)&buf, 0x22u);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (v44 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v4 = *v2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&buf, "--------");
    sub_100058DB0(&__dst, (char *)&buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    int v12 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    std::string::size_type v13 = __dst.__r_.__value_.__r.__words[0];
    sub_100A16F38(&buf, (uint64_t)(a1 + 18));
    __int16 v14 = &__dst;
    if (v12 < 0) {
      __int16 v14 = (std::string *)v13;
    }
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      __int16 v15 = &buf;
    }
    else {
      __int16 v15 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long __p = 136315394;
    *(void *)&__p[4] = v14;
    __int16 v42 = 2080;
    int v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s response status line: %s", __p, 0x16u);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    uint64_t v4 = *v2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&buf, "--------");
    sub_100058DB0(&__dst, (char *)&buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    int v16 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    std::string::size_type v17 = __dst.__r_.__value_.__r.__words[0];
    __int16 v18 = (const void *)*((void *)a1 + 3);
    unint64_t v19 = *((void *)a1 + 4) - (void)v18;
    if (v19)
    {
      if (v19 >= 0x200) {
        size_t v20 = 512;
      }
      else {
        size_t v20 = *((void *)a1 + 4) - (void)v18;
      }
      memset(&buf, 0, sizeof(buf));
      sub_10036CCEC(&buf, v18, (uint64_t)v18 + v20, v20);
      v39[0] = 0;
      v39[1] = 0;
      ctu::TextConverter::TextConverter((ctu::TextConverter *)v39);
      ctu::TextConverter::pushConversion();
      ctu::TextConverter::setSource((ctu::TextConverter *)v39, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_ - buf.__r_.__value_.__r.__words[0]);
      ctu::TextConverter::readChars((uint64_t *)__p, (ctu::TextConverter *)v39, 0x7FFFFFFFuLL);
      ctu::TextConverter::~TextConverter((ctu::TextConverter *)v39);
      if (buf.__r_.__value_.__r.__words[0])
      {
        buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      sub_100058DB0(__p, "");
    }
    BOOL v21 = &__dst;
    if (v16 < 0) {
      BOOL v21 = (std::string *)v17;
    }
    uint64_t v22 = __p;
    if (v44 < 0) {
      uint64_t v22 = *(unsigned char **)__p;
    }
    LODWORD(v40.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v40.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
    WORD2(v40.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v40.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v22;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s data: %s", (uint8_t *)&v40, 0x16u);
    if (v44 < 0) {
      operator delete(*(void **)__p);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    uint64_t v4 = *v2;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *((unsigned char *)&buf.__r_.__value_.__s + 23) = 8;
    strcpy((char *)&buf, "--------");
    sub_100058DB0(&__dst, (char *)&buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v23 = &__dst;
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v23 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s headers:", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  BOOL v24 = (int *)*((void *)a1 + 6);
  uint64_t v25 = a1 + 14;
  if (v24 != a1 + 14)
  {
    do
    {
      uint64_t v26 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 12;
        strcpy((char *)&__dst, "------------");
        sub_100058DB0(__p, (char *)&__dst);
        unint64_t v27 = v2;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (v44 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = *(unsigned char **)__p;
        }
        sub_100A16F38(&__dst, (uint64_t)(v24 + 8));
        int v29 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        std::string::size_type v30 = __dst.__r_.__value_.__r.__words[0];
        sub_100A16F38(&v40, (uint64_t)(v24 + 14));
        uint64_t v31 = &__dst;
        if (v29 < 0) {
          uint64_t v31 = (std::string *)v30;
        }
        CFStringRef v32 = &v40;
        if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          CFStringRef v32 = (std::string *)v40.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v31;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
        v46[0] = v32;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s [%s]:%s", (uint8_t *)&buf, 0x20u);
        if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v40.__r_.__value_.__l.__data_);
        }
        uint64_t v2 = v27;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (v44 < 0) {
          operator delete(*(void **)__p);
        }
      }
      BOOL v33 = (int *)*((void *)v24 + 1);
      if (v33)
      {
        do
        {
          uint64_t v34 = v33;
          BOOL v33 = *(int **)v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          uint64_t v34 = (int *)*((void *)v24 + 2);
          BOOL v35 = *(void *)v34 == (void)v24;
          BOOL v24 = v34;
        }
        while (!v35);
      }
      BOOL v24 = v34;
    }
    while (v34 != v25);
  }
  uint64_t v36 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = operator new(0x20uLL);
    memset(v37, 45, 25);
    sub_100058DB0(&buf, (char *)v37);
    operator delete(v37);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v38 = &buf;
    }
    else {
      char v38 = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I %s", (uint8_t *)&__dst, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100A16E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (__p) {
    operator delete(__p);
  }
  if (*(char *)(v29 - 105) < 0) {
    operator delete(*(void **)(v29 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_100A16F38(std::string *__dst, uint64_t a2)
{
  __dst->__r_.__value_.__r.__words[0] = 0;
  __dst->__r_.__value_.__l.__size_ = 0;
  __dst->__r_.__value_.__r.__words[2] = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    if (*(char *)(a2 + 23) < 0 && *(void *)(a2 + 8) >= 0x201uLL) {
      std::string::resize(__dst, 0x200uLL, 0);
    }
  }
  else
  {
    *(_OWORD *)&__dst->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    __dst->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
}

void sub_100A16FB0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A16FCC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  __int16 v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  size_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  int v12 = "DATA.Connection.Bootstrap.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    int v12 = "DATA.Connection.Bootstrap.2";
  }
  __int16 v14 = "Bootstrap.X";
  if (v13 == 2) {
    __int16 v14 = "Bootstrap.2";
  }
  if (v13 == 1) {
    __int16 v15 = "DATA.Connection.Bootstrap.1";
  }
  else {
    __int16 v15 = v12;
  }
  if (v13 == 1) {
    int v16 = "Bootstrap.1";
  }
  else {
    int v16 = v14;
  }
  sub_10129653C(a1, (uint64_t *)&off_101A2A6A0, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *(void *)a1 = off_101A29C68;
  *(void *)(a1 + 64) = off_101A2A1B8;
  *(void *)(a1 + 72) = off_101A2A448;
  *(void *)(a1 + 80) = off_101A2A638;
  *(void *)(a1 + 392) = 0;
  *(unsigned char *)(a1 + 400) = 0;
  return a1;
}

void sub_100A17160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100A1718C(void *a1)
{
  *a1 = off_101A29C68;
  a1[8] = off_101A2A1B8;
  a1[9] = off_101A2A448;
  a1[10] = off_101A2A638;
  uint64_t v2 = a1[49];
  a1[49] = 0;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    uint64_t v3 = a1[49];
    a1[49] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }

  sub_101296BD8((uint64_t)a1, (uint64_t *)&off_101A2A6A0);
}

void sub_100A172A4(void *a1)
{
  sub_100A1718C(a1);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A172CC(uint64_t a1)
{
  sub_100A1718C((void *)(a1 - 64));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A172F8(uint64_t a1)
{
  sub_100A1718C((void *)(a1 - 72));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A17324(uint64_t a1)
{
  sub_100A1718C((void *)(a1 - 80));

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A17350(void *a1)
{
  sub_100A1718C(a1);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100A1738C(uint64_t a1)
{
}

void sub_100A17394(uint64_t a1)
{
}

void sub_100A1739C(uint64_t a1)
{
}

uint64_t sub_100A173A4()
{
  return 0x1010100000101;
}

uint64_t sub_100A173B8()
{
  return 0x1010100000101;
}

uint64_t sub_100A173CC()
{
  return 0;
}

uint64_t sub_100A173D4()
{
  return 0;
}

uint64_t sub_100A173DC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    __int16 v10 = "activateWithNoSettingsTrigger";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: start", buf, 0xCu);
  }
  if (!qword_101B14190) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (DataPlanManagerBootstrap::sInstance
    && (*(unsigned int (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 152))())
  {
    int v5 = 0;
    *(unsigned char *)(a1 + 226) = 0;
    int v6 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      __int16 v10 = "activateWithNoSettingsTrigger";
      __int16 v11 = 1024;
      int v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: fIsActivatingAccrossSimSwap = %d", buf, 0x12u);
      int v5 = *(unsigned __int8 *)(a1 + 226);
    }
    if (!v5) {
      sub_100A17590(a1, "Bootstrap delay for lpm");
    }
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  sub_10004D2C8(v4);
  return v7;
}

void sub_100A17578(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A17590(uint64_t a1, char *a2)
{
  if (!*(void *)(a1 + 392))
  {
    uint64_t v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = "createPdpActivationTimer";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: defer bootstrap activation for - %s", buf, 0x16u);
    }
    sub_10003E168(buf, (void *)(a1 + 24));
    uint64_t v6 = *(void *)buf;
    int v5 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
      sub_10004D2C8(v5);
    }
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 88));
    uint64_t v7 = *(void *)buf;
    sub_100058DB0(__p, a2);
    int v8 = *(NSObject **)(a1 + 40);
    dispatch_object_t object = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_100A17CCC;
    aBlock[3] = &unk_101A2A708;
    aBlock[4] = a1;
    aBlock[5] = v6;
    int v13 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    __int16 v14 = _Block_copy(aBlock);
    sub_100118A44(v7, (uint64_t)__p, 0, 120000000, &object, &v14);
    uint64_t v9 = v18;
    uint64_t v18 = 0;
    uint64_t v10 = *(void *)(a1 + 392);
    *(void *)(a1 + 392) = v9;
    if (v10)
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      uint64_t v11 = v18;
      uint64_t v18 = 0;
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
      }
    }
    if (v14) {
      _Block_release(v14);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v13) {
      std::__shared_weak_count::__release_weak(v13);
    }
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_100A177F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *aBlock, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A17878(uint64_t a1, uint64_t a2)
{
  if (!qword_101B14190) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (DataPlanManagerBootstrap::sInstance
    && (*(unsigned int (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 224))())
  {
    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 8) = "";
    *(void *)(a2 + 16) = "";
    *(_DWORD *)(a2 + 24) = 0;
    *(unsigned char *)(a2 + 28) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    int v5 = *(std::__shared_weak_count **)(a2 + 48);
    *(void *)(a2 + 48) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v6 = 0;
  }
  sub_10004D2C8(v4);
  return v6;
}

void sub_100A17938(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1794C(uint64_t a1, _DWORD *a2)
{
  if (qword_101B14190)
  {
    uint64_t v3 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
    if (v3)
    {
      uint64_t v4 = v3;
      if (DataPlanManagerBootstrap::sInstance
        && (*(unsigned int (**)(void))(*(void *)(DataPlanManagerBootstrap::sInstance + 8) + 224))())
      {
        *a2 = 0;
      }
      sub_10004D2C8(v4);
    }
  }
  return 1;
}

void sub_100A179D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A179E4(uint64_t a1, _DWORD *a2)
{
  return 1;
}

void sub_100A17A00(uint64_t a1, BOOL a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = asStringBool(a2);
    uint64_t v8 = asStringBool(a3);
    uint64_t v9 = asString();
    int v10 = *(unsigned __int8 *)(a1 + 226);
    *(_DWORD *)int v13 = 136316162;
    *(void *)&v13[4] = "checkActivateConnection";
    *(_WORD *)&v13[12] = 2080;
    *(void *)&v13[14] = v7;
    __int16 v14 = 2080;
    uint64_t v15 = v8;
    __int16 v16 = 2080;
    uint64_t v17 = v9;
    __int16 v18 = 1024;
    int v19 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: change = %s activate = %s state = %s fIsActivatingAccrossSimSwap = %d", v13, 0x30u);
  }
  if (*(_DWORD *)(a1 + 168) != 2) {
    goto LABEL_7;
  }
  sub_1012A0D1C(a1, 0, 1, v13);
  uint64_t v11 = *(void *)v13;
  if (*(void *)&v13[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v13[8]);
  }
  if (!v11)
  {
    int v12 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v13 = 136315138;
      *(void *)&v13[4] = "checkActivateConnection";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %s: No Settings, cancelling activation", v13, 0xCu);
    }
    (*(void (**)(uint64_t, uint64_t, void, void))(*(void *)a1 + 1264))(a1, 1, 0, 0);
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1256))(a1, 0);
  }
  else
  {
LABEL_7:
    sub_1012A24D8(a1, a2, a3);
  }
}

void sub_100A17C18(uint64_t a1, BOOL a2, int a3)
{
}

uint64_t sub_100A17C20(uint64_t a1, uint64_t a2)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 216) + 80))(&v4);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  return 1;
}

uint64_t sub_100A17C9C(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t sub_100A17CBC(uint64_t a1, unsigned char *a2)
{
  *a2 = 1;
  return 1;
}

void sub_100A17CCC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 56);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315138;
          uint64_t v9 = "createPdpActivationTimer_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: deferred bootstrap activation timer expiry, activate to fail", (uint8_t *)&v8, 0xCu);
        }
        *(unsigned char *)(v3 + 400) = 1;
        *(unsigned char *)(v3 + 226) = 0;
        uint64_t v7 = *(void *)(v3 + 392);
        *(void *)(v3 + 392) = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        }
        (*(void (**)(uint64_t, const char *, const char *, void, void))(*(void *)v3 + 160))(v3, "deferred bootstrap activation", "CommCenter", 0, 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100A17E1C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A17E30(uint64_t a1)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_1012A0D1C(a1, 0, 1, &v10);
  if (v10)
  {
    uint64_t v2 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      int v13 = "willActivateTrigger";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: have settings", buf, 0xCu);
    }
  }
  if (*(unsigned char *)(a1 + 400)) {
    goto LABEL_5;
  }
  if (*(unsigned char *)(a1 + 226))
  {
    long long v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      int v13 = "willActivateTrigger";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s: Hold activation due to sim swap", buf, 0xCu);
    }
    goto LABEL_9;
  }
  if (!qword_101B14190) {
    goto LABEL_5;
  }
  uint64_t v6 = std::__shared_weak_count::lock((std::__shared_weak_count *)qword_101B14190);
  if (!v6) {
    goto LABEL_5;
  }
  uint64_t v7 = v6;
  uint64_t v8 = DataPlanManagerBootstrap::sInstance;
  if (!DataPlanManagerBootstrap::sInstance || !sub_100A18030(a1))
  {
    sub_10004D2C8(v7);
    goto LABEL_5;
  }
  int v9 = (*(uint64_t (**)(void))(*(void *)(v8 + 8) + 160))();
  sub_10004D2C8(v7);
  if (!v9)
  {
LABEL_5:
    uint64_t v3 = 0;
    *(unsigned char *)(a1 + 400) = 0;
    goto LABEL_10;
  }
LABEL_9:
  sub_100A17590(a1, "Bootstrap delay for failure");
  uint64_t v3 = 1;
LABEL_10:
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v3;
}

void sub_100A18000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  sub_10004D2C8(v10);
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100A18030(uint64_t a1)
{
  long long v4 = 0;
  memset(v3, 0, sizeof(v3));
  sub_101297BB4(a1, 0, (uint64_t)v3);
  int v1 = v3[0];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v1 != 0;
}

uint64_t sub_100A18088(uint64_t a1)
{
  if (!*(void *)(a1 + 392) && !*(unsigned char *)(a1 + 226) || sub_100A18030(a1)) {
    return 0;
  }
  uint64_t v3 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = "shouldActivateOnObtainingDataSettingsTrigger";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: has deferred activate on settings trigger", (uint8_t *)&v5, 0xCu);
  }
  *(unsigned char *)(a1 + 226) = 0;
  uint64_t v4 = *(void *)(a1 + 392);
  *(void *)(a1 + 392) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return 1;
}

uint64_t sub_100A18188(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 56);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315138;
    uint64_t v6 = "activateDeferredActivate";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s: activating deferred activate", (uint8_t *)&v5, 0xCu);
  }
  *(unsigned char *)(a1 + 226) = 0;
  uint64_t v3 = *(void *)(a1 + 392);
  *(void *)(a1 + 392) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return (*(uint64_t (**)(uint64_t, const char *, const char *, void, void))(*(void *)a1 + 160))(a1, "activating deferred activate as conditions have been met.", "CommCenter", 0, 0);
}

uint64_t sub_100A182A0(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 392) || *(unsigned char *)(result + 226))
  {
    uint64_t result = sub_100A18030(result);
    if ((result & 1) == 0)
    {
      return sub_100A18188(v1);
    }
  }
  return result;
}

uint64_t sub_100A182FC(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 392) || *(unsigned char *)(result + 226))
  {
    uint64_t result = sub_100A18030(result);
    if ((result & 1) == 0)
    {
      return sub_100A18188(v1);
    }
  }
  return result;
}

void sub_100A18358(PB::Base *this)
{
  *(void *)this = &off_101A2B478;
  uint64_t v4 = *((void *)this + 4);
  uint64_t v2 = (void *)((char *)this + 32);
  uint64_t v3 = v4;
  *uint64_t v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v5) {
    sub_100206334((uint64_t)this + 24, v5);
  }
  uint64_t v6 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v6) {
    sub_100206334((uint64_t)this + 16, v6);
  }
  uint64_t v7 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v7) {
    sub_100206334((uint64_t)this + 8, v7);
  }

  PB::Base::~Base(this);
}

void sub_100A183F8(PB::Base *a1)
{
  sub_100A18358(a1);

  operator delete();
}

uint64_t sub_100A18430(uint64_t result, void *a2)
{
  *(void *)uint64_t result = &off_101A2B478;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  if (a2[2]) {
    operator new();
  }
  if (a2[1]) {
    operator new();
  }
  if (a2[4]) {
    operator new();
  }
  if (a2[3]) {
    operator new();
  }
  return result;
}

uint64_t sub_100A1862C(void *a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (a1[1]) {
    PB::TextFormatter::format();
  }
  if (a1[2]) {
    PB::TextFormatter::format();
  }
  if (a1[3]) {
    PB::TextFormatter::format();
  }
  if (a1[4]) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

BOOL sub_100A186D0(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_22:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      switch((v10 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          operator new();
        case 3u:
          operator new();
        case 4u:
          operator new();
        default:
          break;
      }
LABEL_20:
      if ((PB::Reader::skip(this, v19, v18, 0) & 1) == 0) {
        return 0;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_22;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100A189D0(uint64_t result)
{
  uint64_t v1 = (void *)result;
  if (*(void *)(result + 16)) {
    uint64_t result = PB::Writer::write();
  }
  if (v1[1]) {
    uint64_t result = PB::Writer::write();
  }
  if (v1[4]) {
    uint64_t result = PB::Writer::write();
  }
  if (v1[3])
  {
    return PB::Writer::write();
  }
  return result;
}

void sub_100A18A5C(uint64_t a1)
{
  *(void *)a1 = off_101A2B4C8;
  uint64_t v4 = *(void *)(a1 + 48);
  unint64_t v2 = (void *)(a1 + 48);
  uint64_t v3 = v4;
  *unint64_t v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  sub_100110A40((void ***)(a1 + 40), 0);
  uint64_t v5 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v5) {
    sub_100206334(a1 + 32, v5);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v6) {
    sub_100206334(a1 + 24, v6);
  }
  uint64_t v7 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  sub_100110A40((void ***)(a1 + 8), 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_100A18B30(uint64_t a1)
{
  sub_100A18A5C(a1);

  operator delete();
}

uint64_t sub_100A18B68(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 68)) {
    PB::TextFormatter::format(this, "consentState", *(_DWORD *)(a1 + 56));
  }
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, this, "details");
  }
  if ((*(unsigned char *)(a1 + 68) & 2) != 0) {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 60));
  }
  if (*(void *)(a1 + 24)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if ((*(unsigned char *)(a1 + 68) & 4) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 64));
  }
  uint64_t v7 = *(const PB::Data **)(a1 + 40);
  if (v7) {
    PB::TextFormatter::format(this, "targetCsn", v7);
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100A18CB0(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_70:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        *(unsigned char *)(a1 + 68) |= 4u;
        unint64_t v22 = *((void *)this + 1);
        if (v22 >= *((void *)this + 2))
        {
          BOOL v25 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v23 = v22 + 1;
          int v24 = *(unsigned __int8 *)(*(void *)this + v22);
          *((void *)this + 1) = v23;
          BOOL v25 = v24 != 0;
        }
        *(unsigned char *)(a1 + 64) = v25;
        goto LABEL_70;
      case 3u:
        *(unsigned char *)(a1 + 68) |= 2u;
        unint64_t v26 = *((void *)this + 1);
        unint64_t v27 = *((void *)this + 2);
        uint64_t v28 = *(void *)this;
        if (v26 <= 0xFFFFFFFFFFFFFFF5 && v26 + 10 <= v27)
        {
          char v29 = 0;
          unsigned int v30 = 0;
          uint64_t v31 = 0;
          do
          {
            unint64_t v32 = v26 + 1;
            *((void *)this + 1) = v26 + 1;
            char v33 = *(unsigned char *)(v28 + v26);
            v31 |= (unint64_t)(v33 & 0x7F) << v29;
            if ((v33 & 0x80) == 0) {
              goto LABEL_66;
            }
            v29 += 7;
            unint64_t v26 = v32;
            BOOL v14 = v30++ > 8;
          }
          while (!v14);
LABEL_54:
          LODWORD(v31) = 0;
          goto LABEL_66;
        }
        char v42 = 0;
        unsigned int v43 = 0;
        uint64_t v31 = 0;
        if (v27 <= v26) {
          unint64_t v27 = *((void *)this + 1);
        }
        while (2)
        {
          if (v27 == v26)
          {
            LODWORD(v31) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v44 = v26 + 1;
            char v45 = *(unsigned char *)(v28 + v26);
            *((void *)this + 1) = v44;
            v31 |= (unint64_t)(v45 & 0x7F) << v42;
            if (v45 < 0)
            {
              v42 += 7;
              unint64_t v26 = v44;
              BOOL v14 = v43++ > 8;
              if (v14) {
                goto LABEL_54;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v31) = 0;
            }
          }
          break;
        }
LABEL_66:
        *(_DWORD *)(a1 + 60) = v31;
        goto LABEL_70;
      case 4u:
        operator new();
      case 5u:
        operator new();
      case 6u:
        *(unsigned char *)(a1 + 68) |= 1u;
        unint64_t v34 = *((void *)this + 1);
        unint64_t v35 = *((void *)this + 2);
        uint64_t v36 = *(void *)this;
        if (v34 <= 0xFFFFFFFFFFFFFFF5 && v34 + 10 <= v35)
        {
          char v37 = 0;
          unsigned int v38 = 0;
          uint64_t v39 = 0;
          do
          {
            unint64_t v40 = v34 + 1;
            *((void *)this + 1) = v34 + 1;
            char v41 = *(unsigned char *)(v36 + v34);
            v39 |= (unint64_t)(v41 & 0x7F) << v37;
            if ((v41 & 0x80) == 0) {
              goto LABEL_69;
            }
            v37 += 7;
            unint64_t v34 = v40;
            BOOL v14 = v38++ > 8;
          }
          while (!v14);
LABEL_61:
          LODWORD(v39) = 0;
          goto LABEL_69;
        }
        char v46 = 0;
        unsigned int v47 = 0;
        uint64_t v39 = 0;
        if (v35 <= v34) {
          unint64_t v35 = *((void *)this + 1);
        }
        break;
      case 7u:
        operator new();
      case 8u:
        operator new();
      case 9u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v35 == v34)
      {
        LODWORD(v39) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_69;
      }
      unint64_t v48 = v34 + 1;
      char v49 = *(unsigned char *)(v36 + v34);
      *((void *)this + 1) = v48;
      v39 |= (unint64_t)(v49 & 0x7F) << v46;
      if ((v49 & 0x80) == 0) {
        break;
      }
      v46 += 7;
      unint64_t v34 = v48;
      BOOL v14 = v47++ > 8;
      if (v14) {
        goto LABEL_61;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v39) = 0;
    }
LABEL_69:
    *(_DWORD *)(a1 + 56) = v39;
    goto LABEL_70;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_100A192F0(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  char v5 = *(unsigned char *)(v3 + 68);
  if ((v5 & 4) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 64), 2u);
    char v5 = *(unsigned char *)(v3 + 68);
  }
  if ((v5 & 2) != 0) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 60), 3u);
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  uint64_t v6 = *(const PB::Data **)(v3 + 40);
  if (v6) {
    uint64_t result = PB::Writer::write(this, v6, 5u);
  }
  if (*(unsigned char *)(v3 + 68)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 56), 6u);
  }
  uint64_t v7 = *(const PB::Base **)(v3 + 16);
  if (v7) {
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 7u);
  }
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 24))
  {
    return PB::Writer::write();
  }
  return result;
}

uint64_t sub_100A193EC(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A194B0(const char *a1)
{
  memset(v25, 0, sizeof(v25));
  int v20 = 1;
  unsigned int v2 = if_nametoindex(a1);
  int v3 = socket(17, 3, 17);
  int v4 = v3;
  if ((v3 & 0x80000000) == 0)
  {
    if (ioctl(v3, 0x8004667EuLL, &v20) < 0)
    {
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
LABEL_24:
        uint64_t v16 = 0;
LABEL_25:
        close(v4);
        return v16;
      }
      unint64_t v12 = __error();
      char v13 = strerror(*v12);
      *(_DWORD *)std::string buf = 136315138;
      *(void *)unint64_t v22 = v13;
      BOOL v14 = "getDefaultRouteMtuForIPv6V1: ioctl FIONBIO failed %s";
    }
    else
    {
      memset((char *)&v25[1] + 6, 0, 176);
      *(_OWORD *)((char *)v25 + 6) = 0u;
      memset((char *)&v25[12] + 6, 0, 26);
      WORD1(v25[0]) = 4357;
      int v5 = dword_101B0ACC8 + 1;
      dword_101B0ACC8 = v5;
      DWORD1(v25[1]) = v5;
      *((void *)&v25[0] + 1) = 0x101000000;
      WORD2(v25[0]) = v2;
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136315650;
        *(void *)unint64_t v22 = a1;
        *(_WORD *)&v22[8] = 1024;
        *(_DWORD *)unint64_t v23 = v2;
        *(_WORD *)&v23[4] = 1024;
        int v24 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "getDefaultRouteMtuForIPv6V1: index for %s: %u, rtm_seq=%u", buf, 0x18u);
      }
      WORD6(v25[5]) = 7808;
      memset((char *)&v25[5] + 14, 0, 128);
      LOWORD(v25[0]) = 220;
      if ((send(v4, v25, 0xDCuLL, 0) & 0x8000000000000000) == 0)
      {
        while (1)
        {
          ssize_t v6 = read(v4, v25, 0xE0uLL);
          if (v6 < 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "getDefaultRouteMtuForIPv6V1: read failed", buf, 2u);
          }
          if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 67109632;
            *(_DWORD *)unint64_t v22 = v6;
            *(_WORD *)&v22[4] = 1024;
            *(_DWORD *)&v22[6] = DWORD1(v25[1]);
            *(_WORD *)unint64_t v23 = 1024;
            *(_DWORD *)&v23[2] = v25[1];
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "getDefaultRouteMtuForIPv6V1: read_len=%u, rtm_seq=%u, rtm_pid=%u", buf, 0x14u);
          }
          if (v6 < 1) {
            break;
          }
          if (DWORD1(v25[1]) == dword_101B0ACC8)
          {
            int v7 = v25[1];
            if (v7 == getpid())
            {
              uint64_t v16 = DWORD2(v25[2]);
              BOOL v17 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR);
              if (v16)
              {
                if (v17)
                {
                  *(_DWORD *)std::string buf = 67109120;
                  *(_DWORD *)unint64_t v22 = v16;
                  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "getDefaultRouteMtuForIPv6V1: rt mtu %u", buf, 8u);
                }
                goto LABEL_21;
              }
              if (!v17) {
                goto LABEL_20;
              }
              *(_WORD *)std::string buf = 0;
              unsigned int v10 = "getDefaultRouteMtuForIPv6V1: rt mtu is empty";
LABEL_33:
              uint32_t v11 = 2;
              goto LABEL_34;
            }
          }
        }
        if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
          goto LABEL_20;
        }
        *(_WORD *)std::string buf = 0;
        unsigned int v10 = "getDefaultRouteMtuForIPv6V1: read len is empty";
        goto LABEL_33;
      }
      if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR)) {
        goto LABEL_24;
      }
      char v18 = __error();
      unsigned __int8 v19 = strerror(*v18);
      *(_DWORD *)std::string buf = 136315138;
      *(void *)unint64_t v22 = v19;
      BOOL v14 = "getDefaultRouteMtuForIPv6V1: send failed %s";
    }
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
    goto LABEL_24;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    uint64_t v8 = __error();
    char v9 = strerror(*v8);
    *(_DWORD *)std::string buf = 136315138;
    *(void *)unint64_t v22 = v9;
    unsigned int v10 = "getDefaultRouteMtuForIPv6V1: route socket setup failed %s";
    uint32_t v11 = 12;
LABEL_34:
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, v10, buf, v11);
  }
LABEL_20:
  uint64_t v16 = 0;
LABEL_21:
  if (v4 != -1) {
    goto LABEL_25;
  }
  return v16;
}

uint64_t sub_100A1997C()
{
  uint64_t v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  int v0 = socket(30, 2, 0);
  if (v0 < 0)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      int v5 = __error();
      ssize_t v6 = strerror(*v5);
      *(_DWORD *)std::string buf = 136315138;
      unsigned int v10 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "getDefaultRouteMtuForIPv6V2: socket failed %s", buf, 0xCu);
    }
    if (v0 == -1) {
      return 0;
    }
  }
  else
  {
    if ((unint64_t)__strlcpy_chk() < 0x10)
    {
      if ((ioctl(v0, 0xC030694CuLL, &v11) & 0x80000000) == 0
        || !os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
      {
        goto LABEL_11;
      }
      int v7 = __error();
      uint64_t v8 = strerror(*v7);
      *(_DWORD *)std::string buf = 136315138;
      unsigned int v10 = v8;
      int v3 = "getDefaultRouteMtuForIPv6V2: SIOCGIFINFO_IN6 failed %s";
      goto LABEL_13;
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      uint64_t v1 = __error();
      unsigned int v2 = strerror(*v1);
      *(_DWORD *)std::string buf = 136315138;
      unsigned int v10 = v2;
      int v3 = "getDefaultRouteMtuForIPv6V2: strlcpy failed %s";
LABEL_13:
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, v3, buf, 0xCu);
    }
  }
LABEL_11:
  close(v0);
  return v12;
}

void sub_100A19B58(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A19C20(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A19C54(uint64_t a1, void *a2, dispatch_object_t *a3)
{
  ssize_t v6 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "pp.mdl");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v16);
  ctu::OsLogLogger::OsLogLogger(v6, (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  v15[0] = off_101999E18;
  v15[1] = sub_100A1A1B8;
  void v15[3] = v15;
  *(void *)(a1 + 32) = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 32)) {
    operator new();
  }
  sub_10008863C(v15);
  *(void *)a1 = off_101A2B650;
  *(void *)(a1 + 40) = *a2;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 48) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  ChipInformation::ChipInformation((ChipInformation *)(a1 + 56));
  ActivationInfo::ActivationInfo((ActivationInfo *)(a1 + 96));
  *(void *)(a1 + 624) = 0;
  *(_DWORD *)(a1 + 632) = 0;
  *(void *)(a1 + 664) = 0;
  *(_DWORD *)(a1 + 672) = 2;
  *(void *)(a1 + 696) = 0;
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 680) = a1 + 688;
  *(unsigned char *)(a1 + 704) = 0;
  *(unsigned char *)(a1 + 705) = capabilities::ct::supportsMultiphaseBundleSetup(v9);
  *(_WORD *)(a1 + 706) = 0;
  *(unsigned char *)(a1 + 708) = 0;
  *(void *)(a1 + 800) = 0;
  *(unsigned char *)(a1 + 808) = 0;
  *(void *)(a1 + 840) = 0;
  *(void *)(a1 + 864) = 0;
  *(void *)(a1 + 856) = 0;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_DWORD *)(a1 + 768) = 0;
  *(_DWORD *)(a1 + 712) = 0;
  *(_DWORD *)(a1 + 715) = 0;
  *(void *)(a1 + 848) = a1 + 856;
  *(void *)(a1 + 896) = 0;
  *(_DWORD *)(a1 + 904) = 0;
  *(void *)(a1 + 936) = 0;
  *(_DWORD *)(a1 + 944) = 0;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(void *)(a1 + 1032) = 0;
  *(_DWORD *)(a1 + 1040) = 0;
  *(void *)(a1 + 1072) = 0;
  *(unsigned char *)(a1 + 1080) = 0;
  *(void *)(a1 + 1112) = 0;
  *(_WORD *)(a1 + 1120) = 0;
  *(unsigned char *)(a1 + 1128) = 0;
  sub_100058DB0(&__p, "ActivationModel");
  long long v11 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v11) {
    dispatch_release(v11);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_100A19FBC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
}

const char *sub_100A1A1B8(int a1)
{
  uint64_t v1 = "pp.mdl.?";
  if (a1 == 2) {
    uint64_t v1 = "pp.mdl.2";
  }
  if (a1 == 1) {
    return "pp.mdl.1";
  }
  else {
    return v1;
  }
}

void *sub_100A1A1E4(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A1E504((void *)a1);
}

void *sub_100A1A224(void *a1)
{
  sub_100A1E60C((uint64_t)(a1 + 12));
  int v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  int v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_100A1A274(uint64_t a1)
{
  uint64_t v2 = a1 + 40;
  Registry::createRestModuleOneTimeUseConnection(&v32, *(Registry **)(a1 + 40));
  uint64_t v3 = v2 + 1096;
  ctu::RestModule::connect();
  if (v33) {
    sub_10004D2C8(v33);
  }
  *(void *)&long long v37 = off_101A2B960;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_100318874(&v37, (void *)(a1 + 776));
  sub_10030AB98(&v37);
  uint64_t v4 = *(void *)(a1 + 800);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, a1 + 808);
  }
  uint64_t v5 = a1 + 816;
  *(void *)&long long v37 = off_101A2B9E0;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  if (&v37 != (long long *)(a1 + 816))
  {
    ssize_t v6 = *(long long **)(a1 + 840);
    if (v6 == (long long *)v5)
    {
      char v41 = (uint64_t **)(v2 + 1096);
      uint64_t v42 = 0;
      uint64_t v39 = 0;
      unint64_t v40 = off_101A2B9E0;
      (*(void (**)(uint64_t, long long *))(*(void *)v5 + 24))(a1 + 816, &v37);
      (*(void (**)(void))(**(void **)(a1 + 840) + 32))(*(void *)(a1 + 840));
      *(void *)(a1 + 840) = 0;
      uint64_t v39 = &v37;
      (*((void (**)(void **, uint64_t))v40 + 3))(&v40, a1 + 816);
      (*((void (**)(void **))v40 + 4))(&v40);
    }
    else
    {
      *(void *)(a1 + 816) = off_101A2B9E0;
      *(void *)(a1 + 824) = v3;
      uint64_t v39 = v6;
    }
    *(void *)(a1 + 840) = v5;
  }
  sub_100A1E504(&v37);
  uint64_t v7 = *(void *)(a1 + 840);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, a1 + 848);
  }
  uint64_t v8 = a1 + 640;
  *(void *)&long long v37 = off_101A2BA70;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  if (&v37 != (long long *)(a1 + 640))
  {
    char v9 = *(long long **)(a1 + 664);
    if (v9 == (long long *)v8)
    {
      char v41 = (uint64_t **)(v2 + 1096);
      uint64_t v42 = 0;
      uint64_t v39 = 0;
      unint64_t v40 = off_101A2BA70;
      (*(void (**)(uint64_t, long long *))(*(void *)v8 + 24))(a1 + 640, &v37);
      (*(void (**)(void))(**(void **)(a1 + 664) + 32))(*(void *)(a1 + 664));
      *(void *)(a1 + 664) = 0;
      uint64_t v39 = &v37;
      (*((void (**)(void **, uint64_t))v40 + 3))(&v40, a1 + 640);
      (*((void (**)(void **))v40 + 4))(&v40);
    }
    else
    {
      *(void *)(a1 + 640) = off_101A2BA70;
      *(void *)(a1 + 648) = v3;
      uint64_t v39 = v9;
    }
    *(void *)(a1 + 664) = v8;
  }
  sub_100A1E588(&v37);
  uint64_t v10 = *(void *)(a1 + 664);
  if (v10) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, a1 + 672);
  }
  *(void *)&long long v37 = off_101A2BB00;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_10080BCD4(&v37, (void *)(a1 + 872));
  sub_10080AC40(&v37);
  uint64_t v11 = *(void *)(a1 + 896);
  if (v11) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 48))(v11, a1 + 904);
  }
  *(void *)&long long v37 = off_101A2BB80;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_10080BCD4(&v37, (void *)(a1 + 912));
  sub_10080AC40(&v37);
  uint64_t v12 = *(void *)(a1 + 936);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, a1 + 944);
  }
  *(void *)&long long v37 = off_101A2BC00;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_1005E4DB8(&v37, (void *)(a1 + 952));
  sub_10012C330(&v37);
  uint64_t v13 = *(void *)(a1 + 976);
  if (v13) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 48))(v13, a1 + 984);
  }
  *(void *)&long long v37 = off_101A2BC80;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_100318874(&v37, (void *)(a1 + 1048));
  sub_10030AB98(&v37);
  uint64_t v14 = *(void *)(a1 + 1072);
  if (v14) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 48))(v14, a1 + 1080);
  }
  *(void *)&long long v37 = off_101A2BD00;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_10080BCD4(&v37, (void *)(a1 + 1008));
  sub_10080AC40(&v37);
  uint64_t v15 = *(void *)(a1 + 1032);
  if (v15) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, a1 + 1040);
  }
  *(void *)&long long v37 = off_101A2BD80;
  *((void *)&v37 + 1) = v2 + 1096;
  uint64_t v39 = &v37;
  sub_100A203E4(&v37, (void *)(a1 + 1088));
  sub_100A1E43C(&v37);
  uint64_t v16 = *(void *)(a1 + 1112);
  if (v16) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 48))(v16, a1 + 1120);
  }
  *(unsigned char *)(a1 + 1080) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 376))(a1);
  uint64_t v17 = *(void *)(a1 + 1072);
  if (v17) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, a1 + 1080);
  }
  CFStringRef v18 = (const __CFString *)kPostponementTicketPlist;
  DevicePersistentCopyValue((uint64_t *)&v40, kPostponementTicketPlist, 0);
  sub_10004EFE4(&v37, (CFTypeRef *)&v40);
  __int16 v19 = sub_100A1C35C((const __CFDictionary **)&v37);
  sub_100057D78((const void **)&v37);
  sub_1000577C4((const void **)&v40);
  *(_WORD *)(a1 + 1120) = v19;
  uint64_t v20 = *(void *)(a1 + 1112);
  if (v20) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, a1 + 1120);
  }
  CFDictionaryRef theDict = 0;
  DevicePersistentCopyValue((uint64_t *)&v37, v18, 0);
  sub_10004EFE4(&theDict, (CFTypeRef *)&v37);
  sub_1000577C4((const void **)&v37);
  if (theDict) {
    BOOL v21 = sub_100080778;
  }
  else {
    BOOL v21 = 0;
  }
  if (!v21) {
    goto LABEL_45;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"ActivationTicket");
  int v23 = (int)Value;
  if (!Value) {
    goto LABEL_46;
  }
  CFTypeID v24 = CFGetTypeID(Value);
  if (v24 == CFStringGetTypeID())
  {
    unint64_t v40 = 0;
    char v41 = 0;
    uint64_t v42 = 0;
    long long v37 = 0uLL;
    unsigned int v38 = 0;
    ctu::cf::assign();
    *(_OWORD *)long long __p = v37;
    unint64_t v35 = v38;
    ctu::base64::decode();
    if (SHIBYTE(v35) < 0) {
      operator delete(__p[0]);
    }
    int v23 = sub_100A1C0D8(a1, (uint64_t)&v40);
    if (v40)
    {
      char v41 = (uint64_t **)v40;
      operator delete(v40);
    }
  }
  else
  {
LABEL_45:
    int v23 = 0;
  }
LABEL_46:
  sub_100057D78((const void **)&theDict);
  *(_DWORD *)(a1 + 1040) = v23;
  uint64_t v25 = *(void *)(a1 + 1032);
  if (v25) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 48))(v25, a1 + 1040);
  }
  unint64_t v40 = (void *)1;
  char v41 = (uint64_t **)(a1 + 816);
  subscriber::makeSimSlotRange();
  unint64_t v26 = (_DWORD *)*((void *)&v37 + 1);
  unint64_t v27 = (_DWORD *)v37;
  if ((void)v37 != *((void *)&v37 + 1))
  {
    uint64_t v28 = v38;
    while ((v28(*v27) & 1) == 0)
    {
      if (++v27 == v26)
      {
        unint64_t v27 = v26;
        break;
      }
    }
    char v29 = (_DWORD *)*((void *)&v37 + 1);
    while (v27 != v29)
    {
      LODWORD(__p[0]) = 0;
      LODWORD(__p[0]) = *v27;
      *((unsigned char *)sub_100877FD0(v41 + 4, (int)__p[0], __p) + 32) = 4;
      unsigned int v30 = v27 + 1;
      unint64_t v27 = v26;
      if (v30 != v26)
      {
        unint64_t v27 = v30;
        while ((v28(*v27) & 1) == 0)
        {
          if (++v27 == v26)
          {
            unint64_t v27 = v26;
            break;
          }
        }
      }
    }
  }
  return sub_100A20658((uint64_t)&v40);
}

void sub_100A1AB80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, __int16 a18, char a19, char a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28)
{
  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100057D78(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1AC50(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 1136));
}

void sub_100A1AC58(uint64_t a1)
{
  *(void *)a1 = off_101A2B650;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1144);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100A1E43C((void *)(a1 + 1088));
  sub_10030AB98((void *)(a1 + 1048));
  sub_10080AC40((void *)(a1 + 1008));
  sub_100A1E4C0(a1 + 952);
  sub_10080AC40((void *)(a1 + 912));
  sub_10080AC40((void *)(a1 + 872));
  sub_1000346F8(a1 + 848, *(void **)(a1 + 856));
  sub_100A1E504((void *)(a1 + 816));
  sub_10030AB98((void *)(a1 + 776));
  if (*(char *)(a1 + 767) < 0) {
    operator delete(*(void **)(a1 + 744));
  }
  uint64_t v3 = *(void **)(a1 + 720);
  if (v3)
  {
    *(void *)(a1 + 728) = v3;
    operator delete(v3);
  }
  sub_10005D144(*(void **)(a1 + 688));
  sub_100A1E588((void *)(a1 + 640));
  sub_100A1E60C(a1 + 192);
  uint64_t v4 = *(void **)(a1 + 144);
  if (v4)
  {
    *(void *)(a1 + 152) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 112);
  if (v5)
  {
    *(void *)(a1 + 120) = v5;
    operator delete(v5);
  }
  ssize_t v6 = *(void **)(a1 + 64);
  if (v6)
  {
    *(void *)(a1 + 72) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 48);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  char v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  ActivationModelInterface::~ActivationModelInterface((ActivationModelInterface *)a1);
}

void sub_100A1ADC0(uint64_t a1)
{
  sub_100A1AC58(a1);

  operator delete();
}

uint64_t sub_100A1ADF8(uint64_t a1, int a2)
{
  uint64_t v4 = (os_log_t *)(a1 + 8);
  uint64_t v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Resetting all the cached data", buf, 2u);
  }
  ChipInformation::clear((ChipInformation *)(a1 + 56));
  ActivationInfo::clear((ActivationInfo *)(a1 + 96));
  sub_100BEA06C(a1 + 716, a2, v4);
  *(_WORD *)(a1 + 706) = 0;
  *(_DWORD *)(a1 + 712) = 0;
  *(_DWORD *)(a1 + 768) = 0;
  *(_DWORD *)(a1 + 624) = 1;
  if (*(char *)(a1 + 767) < 0)
  {
    **(unsigned char **)(a1 + 744) = 0;
    *(void *)(a1 + 752) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 744) = 0;
    *(unsigned char *)(a1 + 767) = 0;
  }
  if (*(_DWORD *)(a1 + 672) != 2)
  {
    *(_DWORD *)(a1 + 672) = 2;
    uint64_t v6 = *(void *)(a1 + 664);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 672);
    }
  }
  uint64_t v18 = 1;
  uint64_t v19 = a1 + 816;
  subscriber::makeSimSlotRange();
  uint64_t v8 = *(int **)buf;
  uint64_t v7 = v16;
  if (*(int **)buf != v16)
  {
    char v9 = v17;
    while ((v9(*v8) & 1) == 0)
    {
      if (++v8 == v7)
      {
        uint64_t v8 = v7;
        break;
      }
    }
    uint64_t v10 = v16;
    while (v8 != v10)
    {
      int v14 = 0;
      int v14 = *v8;
      *((unsigned char *)sub_100877FD0((uint64_t **)(v19 + 32), v14, &v14) + 32) = 4;
      uint64_t v11 = v8 + 1;
      uint64_t v8 = v7;
      if (v11 != v7)
      {
        uint64_t v8 = v11;
        while ((v9(*v8) & 1) == 0)
        {
          if (++v8 == v7)
          {
            uint64_t v8 = v7;
            break;
          }
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 808))
  {
    *(unsigned char *)(a1 + 808) = 0;
    uint64_t v12 = *(void *)(a1 + 800);
    if (v12) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, a1 + 808);
    }
  }
  return sub_100A20658((uint64_t)&v18);
}

void sub_100A1B000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_100A20658((uint64_t)va);
  _Unwind_Resume(a1);
}

const void **sub_100A1B024@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFDataRef v5 = (const __CFData *)cf;
    CFTypeRef cf = Mutable;
    CFDataRef ActivationStringFromData = v5;
    sub_10005717C((const void **)&ActivationStringFromData);
  }
  if (*(unsigned char *)(a1 + 60))
  {
    CFDataRef ActivationStringFromData = 0;
    CFDataRef ActivationStringFromData = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (const void *)(a1 + 56));
    sub_10069637C((__CFDictionary *)cf, kCTPostponementInfoBasebandChipID, (uint64_t)ActivationStringFromData);
    sub_1000570E8((const void **)&ActivationStringFromData);
  }
  if (*(unsigned char *)(a1 + 88))
  {
    CFDataRef ActivationStringFromData = 0;
    CFDataRef ActivationStringFromData = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(a1 + 64), *(void *)(a1 + 72) - *(void *)(a1 + 64));
    sub_10012C54C((__CFDictionary *)cf, kCTPostponementInfoBasebandSerialNumber, (uint64_t)ActivationStringFromData);
    sub_100030068((const void **)&ActivationStringFromData);
  }
  *(void *)uint64_t v25 = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (*(unsigned char *)(a1 + 183))
  {
    CFDataRef ActivationStringFromData = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)(a1 + 176), 7);
    CFStringRef v27 = sub_1003F2B2C(kCFAllocatorDefault, ActivationStringFromData);
    sub_10010F3F0(*(__CFDictionary **)v25, kCTPostponementInfoUniqueID, (uint64_t)v27);
    sub_10010F3F0(*(__CFDictionary **)v25, kCTPostponementInfoMEID, (uint64_t)v27);
    sub_1000558F4((const void **)&v27);
    sub_100030068((const void **)&ActivationStringFromData);
  }
  if (*(unsigned char *)(a1 + 136))
  {
    CFDataRef ActivationStringFromData = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(a1 + 112), *(void *)(a1 + 120) - *(void *)(a1 + 112));
    CFStringRef v27 = sub_1003F2B2C(kCFAllocatorDefault, ActivationStringFromData);
    sub_10010F3F0(*(__CFDictionary **)v25, kCTPostponementInfoBasebandKeyHash, (uint64_t)v27);
    sub_1000558F4((const void **)&v27);
    sub_100030068((const void **)&ActivationStringFromData);
  }
  if (*(unsigned char *)(a1 + 168))
  {
    CFDataRef ActivationStringFromData = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(a1 + 144), *(void *)(a1 + 152) - *(void *)(a1 + 144));
    CFStringRef v27 = sub_1003F2B2C(kCFAllocatorDefault, ActivationStringFromData);
    sub_10010F3F0(*(__CFDictionary **)v25, kCTPostponementInfoBasebandFactoryKeyHash, (uint64_t)v27);
    sub_1000558F4((const void **)&v27);
    sub_100030068((const void **)&ActivationStringFromData);
  }
  sub_10005717C((const void **)v25);
  CFTypeRef v24 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100A1B864((os_log_t *)(a1 + 8), a1 + 40, a1 + 680, &v24, a1 + 96);
  sub_10005717C(&v24);
  CFTypeRef v23 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100A1BCA0(&v23, a1 + 96);
  sub_10005717C(&v23);
  *(void *)unint64_t v22 = cf;
  if (cf) {
    CFRetain(cf);
  }
  if (*(unsigned char *)(a1 + 568))
  {
    CFDataRef ActivationStringFromData = (const __CFData *)createActivationStringFromData((const unsigned __int8 *)(a1 + 560), 8uLL);
    sub_10010F3F0(*(__CFDictionary **)v22, kCTPostponementInfoIMEI, (uint64_t)ActivationStringFromData);
    if (!*(unsigned char *)(a1 + 183)) {
      sub_10010F3F0(*(__CFDictionary **)v22, kCTPostponementInfoUniqueID, (uint64_t)ActivationStringFromData);
    }
    sub_1000558F4((const void **)&ActivationStringFromData);
  }
  if (*(unsigned char *)(a1 + 577))
  {
    CFDataRef ActivationStringFromData = (const __CFData *)createActivationStringFromData((const unsigned __int8 *)(a1 + 569), 8uLL);
    sub_10010F3F0(*(__CFDictionary **)v22, kCTPostponementInfoSim2IMEI, (uint64_t)ActivationStringFromData);
    sub_1000558F4((const void **)&ActivationStringFromData);
  }
  sub_10005717C((const void **)v22);
  CFDictionaryRemoveValue((CFMutableDictionaryRef)cf, @"SubscriberIdentityModules");
  uint64_t v7 = (const void **)capabilities::ct::supportsGemini(v6);
  if (v7)
  {
    *(void *)BOOL v21 = cf;
    if (cf) {
      CFRetain(cf);
    }
    if (*(unsigned char *)(a1 + 552) && *(unsigned char *)(a1 + 544))
    {
      if (*(unsigned char *)(a1 + 384))
      {
        CFDataRef ActivationStringFromData = (const __CFData *)createActivationStringFromData((const unsigned __int8 *)(a1 + 376), 8uLL);
        sub_10010F3F0(*(__CFDictionary **)v21, kCTPostponementInfoSim2IMSI, (uint64_t)ActivationStringFromData);
        sub_1000558F4((const void **)&ActivationStringFromData);
      }
      if (*(unsigned char *)(a1 + 395))
      {
        CFDataRef ActivationStringFromData = (const __CFData *)createActivationStringFromData((const unsigned __int8 *)(a1 + 385), 0xAuLL);
        sub_10010F3F0(*(__CFDictionary **)v21, kCTPostponementInfoSim2ICCID, (uint64_t)ActivationStringFromData);
        sub_1000558F4((const void **)&ActivationStringFromData);
      }
      if (*(unsigned char *)(a1 + 424))
      {
        CFDataRef ActivationStringFromData = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(a1 + 400), *(void *)(a1 + 408) - *(void *)(a1 + 400));
        sub_10012C54C(*(__CFDictionary **)v21, kCTPostponementInfoSim2GID1, (uint64_t)ActivationStringFromData);
        sub_100030068((const void **)&ActivationStringFromData);
      }
      if (*(unsigned char *)(a1 + 456))
      {
        CFDataRef ActivationStringFromData = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(a1 + 432), *(void *)(a1 + 440) - *(void *)(a1 + 432));
        sub_10012C54C(*(__CFDictionary **)v21, kCTPostponementInfoSim2GID2, (uint64_t)ActivationStringFromData);
        sub_100030068((const void **)&ActivationStringFromData);
      }
      if (*(unsigned char *)(a1 + 535))
      {
        if (*(unsigned char *)(a1 + 534)) {
          uint64_t v8 = &kCFBooleanTrue;
        }
        else {
          uint64_t v8 = &kCFBooleanFalse;
        }
        CFDataRef ActivationStringFromData = *v8;
        sub_10012C97C(*(__CFDictionary **)v21, kCTPostponementInfoSim2IsEmbedded, (uint64_t)ActivationStringFromData);
        sub_100062778((const void **)&ActivationStringFromData);
      }
      if (*(unsigned char *)(a1 + 537))
      {
        if (*(unsigned char *)(a1 + 536)) {
          char v9 = &kCFBooleanTrue;
        }
        else {
          char v9 = &kCFBooleanFalse;
        }
        CFDataRef ActivationStringFromData = *v9;
        sub_10012C97C(*(__CFDictionary **)v21, kCTPostponementInfoSim2IsBootstrap, (uint64_t)ActivationStringFromData);
        sub_100062778((const void **)&ActivationStringFromData);
      }
    }
    uint64_t v7 = sub_10005717C((const void **)v21);
  }
  if (capabilities::ct::getProvisioningProfileSupport((capabilities::ct *)v7) == 1)
  {
    *(void *)uint64_t v20 = cf;
    if (cf) {
      CFRetain(cf);
    }
    if (*(unsigned char *)(a1 + 620))
    {
      CFDataRef ActivationStringFromData = (const __CFData *)CFStringCreateWithCString(kCFAllocatorDefault, (const char *)(a1 + 616), 0x8000100u);
      sub_10010F3F0(*(__CFDictionary **)v20, kCTPostponementInfoBootstrapVersion, (uint64_t)ActivationStringFromData);
      sub_1000558F4((const void **)&ActivationStringFromData);
    }
    sub_10005717C((const void **)v20);
  }
  uint64_t v10 = (uint64_t *)&kCTPostponementStatusReady;
  switch(*(_DWORD *)(a1 + 624))
  {
    case 2:
      goto LABEL_61;
    case 3:
      uint64_t v10 = (uint64_t *)&kCTPostponementStatusRejected;
      goto LABEL_61;
    case 4:
      uint64_t v10 = (uint64_t *)&kCTPostponementStatusActivated;
      goto LABEL_61;
    case 5:
      sub_10010F3F0((__CFDictionary *)cf, kCTPostponementStatus, kCTPostponementStatusError);
      if (*(_DWORD *)(a1 + 628) == 1) {
        uint64_t v19 = (uint64_t *)&kCTPostponementStatusErrorMEIDNotProvisioned;
      }
      else {
        uint64_t v19 = (uint64_t *)&kCTPostponementStatusErrorUnknown;
      }
      sub_10010F3F0((__CFDictionary *)cf, kCTPostponementStatusErrorReason, *v19);
      goto LABEL_62;
    default:
      uint64_t v10 = (uint64_t *)&kCTPostponementStatusNotReady;
LABEL_61:
      sub_10010F3F0((__CFDictionary *)cf, kCTPostponementStatus, *v10);
LABEL_62:
      uint64_t v11 = *(void *)(a1 + 856);
      if (!v11) {
        goto LABEL_76;
      }
      uint64_t v12 = a1 + 856;
      do
      {
        int v13 = *(_DWORD *)(v11 + 28);
        BOOL v14 = v13 < 1;
        if (v13 >= 1) {
          uint64_t v15 = (uint64_t *)v11;
        }
        else {
          uint64_t v15 = (uint64_t *)(v11 + 8);
        }
        if (!v14) {
          uint64_t v12 = v11;
        }
        uint64_t v11 = *v15;
      }
      while (*v15);
      if (v12 == a1 + 856)
      {
LABEL_76:
        uint64_t v16 = (uint64_t *)&kCFBooleanFalse;
      }
      else
      {
        uint64_t v16 = (uint64_t *)&kCFBooleanFalse;
        if (*(int *)(v12 + 28) <= 1)
        {
          char v17 = *(unsigned char *)(v12 + 32);
          if (!v17) {
            goto LABEL_78;
          }
          if (v17 == 2) {
            uint64_t v16 = (uint64_t *)&kCFBooleanTrue;
          }
        }
      }
      sub_10012C97C((__CFDictionary *)cf, kCTPostponementInfoServiceProvisioningState, *v16);
LABEL_78:
      sub_10004EFE4(a2, &cf);
      return sub_10005717C(&cf);
  }
}

void sub_100A1B714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  CFDataRef v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_100062778((const void **)(v3 - 40));
  sub_10005717C((const void **)va);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

const void **sub_100A1B864(os_log_t *a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5)
{
  uint64_t v7 = (void *)(a3 + 8);
  uint64_t v6 = *(void *)(a3 + 8);
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v8 = a3 + 8;
  do
  {
    int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 < 1;
    if (v9 >= 1) {
      uint64_t v11 = (uint64_t *)v6;
    }
    else {
      uint64_t v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if ((void *)v8 == v7 || *(int *)(v8 + 28) > 1)
  {
LABEL_12:
    int v13 = &v47;
    sub_100057240((const void **)&v47, a4);
    sub_100A1E714(1, &v47, a5);
  }
  else
  {
    int v12 = *(_DWORD *)(v8 + 32);
    int v13 = &v48;
    sub_100057240((const void **)&v48, a4);
    sub_100A1E714(v12, &v48, a5);
  }
  sub_10005717C((const void **)v13);
  CFTypeRef v46 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  long long v37 = (__CFDictionary **)a4;
  if (Mutable)
  {
    uint64_t v15 = (unsigned int *)v46;
    CFTypeRef v46 = Mutable;
    unsigned int v43 = v15;
    sub_10005717C((const void **)&v43);
  }
  subscriber::makeSimSlotRange();
  char v17 = v43;
  uint64_t v16 = v44;
  if (v43 != v44)
  {
    uint64_t v18 = v45;
    while ((v18(*v17) & 1) == 0)
    {
      if (++v17 == v16)
      {
        char v17 = v16;
        break;
      }
    }
    uint64_t v19 = v44;
    while (v17 != v19)
    {
      signed int v20 = *v17;
      uint64_t v21 = *v7;
      if (!*v7) {
        goto LABEL_31;
      }
      unint64_t v22 = v7;
      do
      {
        signed int v23 = *(_DWORD *)(v21 + 28);
        BOOL v24 = v23 < v20;
        if (v23 >= v20) {
          uint64_t v25 = (uint64_t *)v21;
        }
        else {
          uint64_t v25 = (uint64_t *)(v21 + 8);
        }
        if (!v24) {
          unint64_t v22 = (void *)v21;
        }
        uint64_t v21 = *v25;
      }
      while (*v25);
      if (v22 != v7 && v20 >= *((_DWORD *)v22 + 7))
      {
        int v26 = *((_DWORD *)v22 + 8);
      }
      else
      {
LABEL_31:
        if (v20 == 1) {
          int v26 = 1;
        }
        else {
          int v26 = 2 * (v20 == 2);
        }
        CFStringRef v27 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = subscriber::asString();
          uint64_t v29 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v28;
          __int16 v52 = 2080;
          uint64_t v53 = v29;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I No SIM info for (%s), using slot [%s]", buf, 0x16u);
        }
      }
      CFTypeRef cf = 0;
      CFMutableDictionaryRef v30 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v30)
      {
        CFTypeRef v31 = cf;
        CFTypeRef cf = v30;
        *(void *)std::string buf = v31;
        sub_10005717C((const void **)buf);
      }
      char v41 = (__CFDictionary *)cf;
      if (cf) {
        CFRetain(cf);
      }
      sub_100A1E714(v26, &v41, a5);
      sub_10005717C((const void **)&v41);
      if (CFDictionaryGetCount((CFDictionaryRef)cf))
      {
        CFTypeRef v40 = 0;
        uint64_t v32 = (const __CFString **)subscriber::asString();
        char v49 = 0;
        BOOL v50 = 0;
        if (ctu::cf::convert_copy((ctu::cf *)&v50, v32, (const char *)0x8000100, kCFAllocatorDefault, v33))
        {
          unint64_t v34 = v49;
          char v49 = v50;
          *(void *)std::string buf = v34;
          sub_1000558F4((const void **)buf);
        }
        CFTypeRef v40 = v49;
        char v49 = 0;
        sub_1000558F4(&v49);
        sub_10010F4C8((__CFDictionary *)v46, (void *)v40, (uint64_t)cf);
        sub_1000558F4(&v40);
      }
      sub_10005717C(&cf);
      unint64_t v35 = v17 + 1;
      char v17 = v16;
      if (v35 != v16)
      {
        char v17 = v35;
        while ((v18(*v17) & 1) == 0)
        {
          if (++v17 == v16)
          {
            char v17 = v16;
            break;
          }
        }
      }
    }
  }
  sub_10010F4C8(*v37, @"SubscriberIdentityModules", (uint64_t)v46);
  return sub_10005717C(&v46);
}

void sub_100A1BC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100A1BCA0(const void **result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 486))
  {
    uint64_t v2 = (__CFDictionary **)result;
    CFStringRef v3 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)(a2 + 482), 0x8000100u);
    sub_10010F3F0(*v2, kCTPostponementInfoTicketVersion, (uint64_t)v3);
    return sub_1000558F4((const void **)&v3);
  }
  return result;
}

void sub_100A1BD18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1BD2C(uint64_t result)
{
  uint64_t v1 = result;
  *(void *)(result + 728) = *(void *)(result + 720);
  if (*(unsigned char *)(result + 1080))
  {
    *(unsigned char *)(result + 1080) = 0;
    uint64_t result = *(void *)(result + 1072);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, v1 + 1080);
    }
  }
  if (*(_DWORD *)(v1 + 1040))
  {
    *(_DWORD *)(v1 + 1040) = 0;
    uint64_t result = *(void *)(v1 + 1032);
    if (result)
    {
      uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 48);
      return v2();
    }
  }
  return result;
}

BOOL sub_100A1BDE4(uint64_t a1, CFDictionaryRef *a2)
{
  if (*a2) {
    CFStringRef v3 = sub_100080778;
  }
  else {
    CFStringRef v3 = 0;
  }
  if (!v3)
  {
    int v13 = *(NSObject **)(a1 + 8);
    BOOL v17 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v17) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v16 = "#N Unable to extract postponement ticket";
    goto LABEL_15;
  }
  CFArrayRef Value = CFDictionaryGetValue(*a2, @"ActivationTicket");
  if (!Value || (CFTypeID v6 = CFGetTypeID(Value), v6 != CFStringGetTypeID()))
  {
    int v13 = *(NSObject **)(a1 + 8);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v14) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v16 = "#N Did not find postponement ticket in activation record dictionary";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    return 0;
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v30 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long __p = 0u;
  uint64_t v26 = 0;
  ctu::base64::decode();
  uint64_t v7 = (uint64_t *)(a1 + 720);
  uint64_t v8 = *(void **)(a1 + 720);
  if (v8)
  {
    *(void *)(a1 + 728) = v8;
    operator delete(v8);
    uint64_t *v7 = 0;
    *(void *)(a1 + 728) = 0;
    *(void *)(a1 + 736) = 0;
  }
  uint64_t v9 = v27;
  *(void *)(a1 + 720) = v27;
  uint64_t v10 = v28;
  *(_OWORD *)(a1 + 728) = v28;
  uint64_t v11 = (uint64_t *)(a1 + 728);
  long long v28 = 0uLL;
  uint64_t v27 = 0;
  if (SHIBYTE(v26) < 0)
  {
    operator delete(__p[0]);
    uint64_t v9 = *v7;
    uint64_t v12 = *v11;
  }
  else
  {
    uint64_t v12 = v10;
  }
  int v18 = v9 != v12;
  if (*(unsigned __int8 *)(a1 + 1080) != v18)
  {
    *(unsigned char *)(a1 + 1080) = v18;
    uint64_t v19 = *(void *)(a1 + 1072);
    if (v19) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 48))(v19, a1 + 1080);
    }
  }
  int v20 = sub_100A1C0D8(a1, a1 + 720);
  if (*(_DWORD *)(a1 + 1040) != v20)
  {
    *(_DWORD *)(a1 + 1040) = v20;
    uint64_t v21 = *(void *)(a1 + 1032);
    if (v21) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 48))(v21, a1 + 1040);
    }
  }
  sub_100058198(&v24, (const void **)a2);
  unsigned __int16 v22 = sub_100A1C35C((const __CFDictionary **)&v24);
  if (v22 >= 0x100u && *(unsigned char *)(a1 + 1121))
  {
    if (*(unsigned __int8 *)(a1 + 1120) == v22) {
      goto LABEL_30;
    }
LABEL_28:
    *(_WORD *)(a1 + 1120) = v22;
    uint64_t v23 = *(void *)(a1 + 1112);
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 48))(v23);
    }
    goto LABEL_30;
  }
  if (v22 > 0xFFu != (*(unsigned char *)(a1 + 1121) != 0)) {
    goto LABEL_28;
  }
LABEL_30:
  sub_100057D78(&v24);
  return *v7 != *v11;
}

void sub_100A1C098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A1C0D8(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2 == *(void *)(a2 + 8)) {
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)a2, *(Registry **)(a1 + 40));
  CFDataRef v5 = ServiceMap;
  uint64_t v7 = v6;
  if (v6 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v7;
  uint64_t v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    int v13 = (GestaltUtilityInterface *)v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    int v13 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v12 = 0;
  char v14 = 1;
LABEL_10:
  uint64_t isIPhone = (capabilities::ct *)GestaltUtilityInterface::isIPhone(v13);
  char v16 = (char)isIPhone;
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if ((v16 & 1) == 0) {
    return 0;
  }
  if (!capabilities::ct::supportsGemini(isIPhone))
  {
    int v26 = 0;
    goto LABEL_25;
  }
  int v18 = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 40));
  uint64_t v19 = v18;
  if (v6 < 0)
  {
    int v20 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v21 = 5381;
    do
    {
      uint64_t v6 = v21;
      unsigned int v22 = *v20++;
      uint64_t v21 = (33 * v21) ^ v22;
    }
    while (v22);
  }
  std::mutex::lock(v18);
  *(void *)std::string buf = v6;
  uint64_t v23 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
  if (v23)
  {
    uint64_t v25 = v23[3];
    BOOL v24 = (std::__shared_weak_count *)v23[4];
    if (v24)
    {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v19);
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v24);
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v25 = 0;
  }
  std::mutex::unlock(v19);
  BOOL v24 = 0;
LABEL_23:
  int v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 72))(v25) ^ 1;
  if (v24) {
    sub_10004D2C8(v24);
  }
LABEL_25:
  char v30 = 0;
  if (is_activation_manifest_carrier_locked(*(void *)a2, *(_DWORD *)(a2 + 8) - *(void *)a2, v26, &v30))
  {
    uint64_t v27 = *(NSObject **)(a1 + 8);
    BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v28) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#N Failed to decode activation ticket", buf, 2u);
    return 0;
  }
  if (v30) {
    return 2;
  }
  else {
    return 1;
  }
}

void sub_100A1C330(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A1C35C(const __CFDictionary **a1)
{
  __s1 = 0;
  size_t __n = 0;
  uint64_t v25 = 0;
  sub_100058DB0(&__s1, "true");
  CFDictionaryRef v2 = *a1;
  if (*a1) {
    CFStringRef v3 = sub_100080778;
  }
  else {
    CFStringRef v3 = 0;
  }
  if (!v3) {
    goto LABEL_28;
  }
  unsigned int v22 = 0;
  *(void *)&long long v26 = CFDictionaryGetValue(v2, @"PostBuddyTicketRefresh");
  sub_100056248(&v22, (CFTypeRef *)&v26);
  if (v22) {
    uint64_t v4 = sub_1000810B8;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4)
  {
    sub_1000558F4(&v22);
LABEL_28:
    BOOL v17 = 0;
    int v18 = 0;
    goto LABEL_35;
  }
  long long v26 = 0uLL;
  uint64_t v27 = 0;
  ctu::cf::assign();
  uint64_t v21 = v27;
  *(_OWORD *)long long __p = v26;
  if (v25 >= 0) {
    size_t v5 = HIBYTE(v25);
  }
  else {
    size_t v5 = __n;
  }
  uint64_t v6 = (void *)HIBYTE(v21);
  int v7 = SHIBYTE(v21);
  if (v21 < 0) {
    uint64_t v6 = __p[1];
  }
  if ((void *)v5 == v6)
  {
    if (v21 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    if (v25 < 0)
    {
      BOOL v17 = memcmp(__s1, v8, __n) == 0;
    }
    else
    {
      if (!HIBYTE(v25))
      {
        BOOL v17 = 1;
        if ((SHIBYTE(v21) & 0x80000000) == 0) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }
      uint64_t v9 = HIBYTE(v25) - 1;
      p_s1 = &__s1;
      do
      {
        int v12 = *(unsigned __int8 *)p_s1;
        p_s1 = (void **)((char *)p_s1 + 1);
        int v11 = v12;
        int v14 = *(unsigned __int8 *)v8;
        uint64_t v8 = (void **)((char *)v8 + 1);
        int v13 = v14;
        BOOL v16 = v9-- != 0;
        BOOL v17 = v11 == v13;
      }
      while (v11 == v13 && v16);
    }
    if (v7 < 0) {
LABEL_33:
    }
      operator delete(__p[0]);
  }
  else
  {
    BOOL v17 = 0;
    if (SHIBYTE(v21) < 0) {
      goto LABEL_33;
    }
  }
LABEL_34:
  sub_1000558F4(&v22);
  int v18 = 1;
LABEL_35:
  if (SHIBYTE(v25) < 0) {
    operator delete(__s1);
  }
  return v17 | (v18 << 8);
}

void sub_100A1C4F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (*(char *)(v18 - 17) < 0) {
    operator delete(*(void **)(v18 - 40));
  }
  sub_1000558F4(&a12);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A1C534(uint64_t a1)
{
  return a1 + 720;
}

BOOL sub_100A1C53C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 632) || *(_DWORD *)(a1 + 96) == 0;
}

const void **sub_100A1C55C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFDataRef v5 = (const __CFData *)cf;
    CFTypeRef cf = Mutable;
    CFDataRef v20 = v5;
    sub_10005717C((const void **)&v20);
  }
  if (*(unsigned char *)(a1 + 183))
  {
    CFDataRef v20 = 0;
    CFDataRef v20 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)(a1 + 176), 7);
    CFStringRef valuePtr = sub_1003F2B2C(kCFAllocatorDefault, v20);
    sub_10010F3F0((__CFDictionary *)cf, kCTPostponementInfoUniqueID, (uint64_t)valuePtr);
    sub_10010F3F0((__CFDictionary *)cf, kCTPostponementInfoMEID, (uint64_t)valuePtr);
    sub_1000558F4((const void **)&valuePtr);
    sub_100030068((const void **)&v20);
  }
  uint64_t v6 = *(void *)(a1 + 856);
  if (v6)
  {
    uint64_t v7 = a1 + 856;
    do
    {
      int v8 = *(_DWORD *)(v6 + 28);
      BOOL v9 = v8 < 1;
      if (v8 >= 1) {
        unsigned int v10 = (uint64_t *)v6;
      }
      else {
        unsigned int v10 = (uint64_t *)(v6 + 8);
      }
      if (!v9) {
        uint64_t v7 = v6;
      }
      uint64_t v6 = *v10;
    }
    while (*v10);
    if (v7 == a1 + 856)
    {
      int v11 = (uint64_t *)&kCFBooleanFalse;
    }
    else
    {
      int v11 = (uint64_t *)&kCFBooleanFalse;
      if (*(int *)(v7 + 28) <= 1)
      {
        char v12 = *(unsigned char *)(v7 + 32);
        if (!v12) {
          goto LABEL_22;
        }
        if (v12 == 2) {
          int v11 = (uint64_t *)&kCFBooleanTrue;
        }
      }
    }
  }
  else
  {
    int v11 = (uint64_t *)&kCFBooleanFalse;
  }
  sub_10012C97C((__CFDictionary *)cf, @"ServiceProvisionState", *v11);
LABEL_22:
  CFBooleanRef v13 = kCFBooleanFalse;
  if (*(_DWORD *)(a1 + 96)) {
    CFBooleanRef v14 = kCFBooleanFalse;
  }
  else {
    CFBooleanRef v14 = kCFBooleanTrue;
  }
  sub_10012C97C((__CFDictionary *)cf, @"ActivationState", (uint64_t)v14);
  CFTypeRef v17 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100A1B864((os_log_t *)(a1 + 8), a1 + 40, a1 + 680, &v17, a1 + 96);
  sub_10005717C(&v17);
  CFTypeRef v16 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100A1BCA0(&v16, a1 + 96);
  sub_10005717C(&v16);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 192))(a1, 1);
  if (subscriber::isSimPresent() && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 272))(a1)) {
    CFBooleanRef v13 = kCFBooleanTrue;
  }
  sub_10012C97C((__CFDictionary *)cf, kCTPostponementInfoMultiphaseSetup, (uint64_t)v13);
  LODWORD(valuePtr) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 280))(a1);
  CFDataRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  sub_10069637C((__CFDictionary *)cf, kCTPostponementInfoSimProvisionedState, (uint64_t)v20);
  sub_1000570E8((const void **)&v20);
  sub_10004EFE4(a2, &cf);
  return sub_10005717C(&cf);
}

void sub_100A1C880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  CFDataRef v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100030068((const void **)va2);
  sub_10005717C((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL sub_100A1C8FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 856);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1 + 856;
  do
  {
    int v3 = *(_DWORD *)(v1 + 28);
    BOOL v4 = v3 < 1;
    if (v3 >= 1) {
      CFDataRef v5 = (uint64_t *)v1;
    }
    else {
      CFDataRef v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  return v2 != a1 + 856 && *(int *)(v2 + 28) <= 1 && *(unsigned char *)(v2 + 32) == 2;
}

BOOL sub_100A1C954(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 856);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = a1 + 856;
  do
  {
    int v3 = *(_DWORD *)(v1 + 28);
    BOOL v4 = v3 < 1;
    if (v3 >= 1) {
      CFDataRef v5 = (uint64_t *)v1;
    }
    else {
      CFDataRef v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  return v2 != a1 + 856 && *(int *)(v2 + 28) <= 1 && *(unsigned char *)(v2 + 32) == 1;
}

atomic_uint **sub_100A1C9AC(_DWORD *a1, int a2)
{
  int v4 = a1[156];
  char v5 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 56))(a1);
  uint64_t result = sub_100A1CA1C((uint64_t)&event::activation::postponementStatusChanged, v4, a2, v5);
  a1[156] = a2;
  return result;
}

atomic_uint **sub_100A1CA1C(uint64_t a1, int a2, int a3, char a4)
{
  sub_100A206BC((uint64_t *)(a1 + 24));
  int v8 = (uint64_t *)sub_1009F9470((uint64_t *)(a1 + 8));

  return sub_100A208C8(v8, a2, a3, a4);
}

uint64_t sub_100A1CA7C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 624);
}

uint64_t sub_100A1CA84(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_100A1CA8C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 628) = a2;
  return result;
}

uint64_t sub_100A1CA94(uint64_t result, std::string *__str)
{
  uint64_t v2 = __str;
  uint64_t v3 = result;
  int v4 = (std::string *)(result + 984);
  uint64_t v5 = *(unsigned __int8 *)(result + 1007);
  if ((v5 & 0x80u) == 0) {
    uint64_t v6 = *(unsigned __int8 *)(result + 1007);
  }
  else {
    uint64_t v6 = *(void *)(result + 992);
  }
  std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  int v8 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  if (v6 == size)
  {
    if (v8 < 0) {
      std::string __str = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    if ((v5 & 0x80) != 0)
    {
      uint64_t result = memcmp(v4->__r_.__value_.__l.__data_, __str, *(void *)(result + 992));
      if (!result) {
        return result;
      }
    }
    else
    {
      if (!*(unsigned char *)(result + 1007)) {
        return result;
      }
      for (uint64_t i = (unsigned __int8 *)(result + 984); *i == __str->__r_.__value_.__s.__data_[0]; ++i)
      {
        std::string __str = (std::string *)((char *)__str + 1);
        if (!--v5) {
          return result;
        }
      }
    }
  }
  std::string::operator=(v4, v2);
  uint64_t result = *(void *)(v3 + 976);
  if (result)
  {
    unsigned int v10 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v10();
  }
  return result;
}

void *sub_100A1CB94(void *result, unsigned char *a2)
{
  uint64_t v3 = result;
  char v4 = a2[4];
  *((_DWORD *)result + 14) = *(_DWORD *)a2;
  *((unsigned char *)result + 60) = v4;
  if (result + 7 != (void *)a2)
  {
    uint64_t v6 = result + 8;
    uint64_t v5 = (char *)result[8];
    uint64_t v7 = (char *)*((void *)a2 + 1);
    int v8 = (unsigned char *)*((void *)a2 + 2);
    unint64_t v9 = v8 - v7;
    unint64_t v10 = result[10];
    if (v10 - (unint64_t)v5 >= v8 - v7)
    {
      CFBooleanRef v13 = (unsigned char *)result[9];
      size_t v14 = v13 - v5;
      if (v13 - v5 < v9)
      {
        uint64_t v15 = &v7[v14];
        if (v13 != v5)
        {
          uint64_t result = memmove((void *)result[8], *((const void **)a2 + 1), v14);
          uint64_t v5 = (char *)v3[9];
        }
        if (v8 != v15) {
          uint64_t result = memmove(v5, v15, v8 - v15);
        }
        CFTypeRef v16 = &v5[v8 - v15];
        goto LABEL_21;
      }
    }
    else
    {
      if (v5)
      {
        result[9] = v5;
        operator delete(v5);
        unint64_t v10 = 0;
        void *v6 = 0;
        v3[9] = 0;
        v3[10] = 0;
      }
      if ((v9 & 0x8000000000000000) != 0) {
        sub_100205700();
      }
      uint64_t v11 = 2 * v10;
      if (2 * v10 <= v9) {
        uint64_t v11 = v8 - v7;
      }
      if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v12 = v11;
      }
      uint64_t result = sub_10022E748(v3 + 8, v12);
      uint64_t v5 = (char *)v3[9];
    }
    if (v8 != v7) {
      uint64_t result = memmove(v5, v7, v8 - v7);
    }
    CFTypeRef v16 = &v5[v9];
LABEL_21:
    v3[9] = v16;
  }
  *((unsigned char *)v3 + 88) = a2[32];
  return result;
}

uint64_t sub_100A1CCD4(uint64_t a1, int *a2)
{
  uint64_t v3 = a1;
  if (*((unsigned char *)a2 + 12))
  {
    int v4 = *a2;
    if (*(_DWORD *)(a1 + 96) != *a2)
    {
      uint64_t v5 = *(NSObject **)(a1 + 8);
      a1 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      if (a1)
      {
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = asString();
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = asString();
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Activation state changing from %s to %s", buf, 0x16u);
        int v4 = *a2;
      }
      if (v4 == 1) {
        a1 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 144))(v3, 2);
      }
    }
    if (*(unsigned __int8 *)(v3 + 104) != *((unsigned __int8 *)a2 + 8))
    {
      uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 32) + 16))(*(void *)(v3 + 32), 1);
      a1 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
      if (a1)
      {
        uint64_t v7 = asString();
        uint64_t v8 = asString();
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Service provisioned changing from %s to %s", buf, 0x16u);
      }
    }
    if (capabilities::ct::supportsGemini((capabilities::ct *)a1))
    {
      if (*(unsigned __int8 *)(v3 + 105) != *((unsigned __int8 *)a2 + 9))
      {
        unint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 32) + 16))(*(void *)(v3 + 32), 2);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = asString();
          uint64_t v11 = asString();
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v10;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Service provisioned changing from %s to %s", buf, 0x16u);
        }
      }
    }
    uint64_t v12 = *(void *)a2;
    *(void *)(v3 + 101) = *(void *)((char *)a2 + 5);
    *(void *)(v3 + 96) = v12;
  }
  if (*((unsigned char *)a2 + 88))
  {
    if ((int *)(v3 + 112) != a2 + 4)
    {
      sub_10006E4A8((void *)(v3 + 112), *((char **)a2 + 2), *((char **)a2 + 3), *((void *)a2 + 3) - *((void *)a2 + 2));
      *(unsigned char *)(v3 + 136) = *((unsigned char *)a2 + 40);
      sub_10006E4A8((void *)(v3 + 144), *((char **)a2 + 6), *((char **)a2 + 7), *((void *)a2 + 7) - *((void *)a2 + 6));
    }
    *(unsigned char *)(v3 + 168) = *((unsigned char *)a2 + 72);
    *(void *)(v3 + 176) = *((void *)a2 + 10);
    *(unsigned char *)(v3 + 184) = *((unsigned char *)a2 + 88);
  }
  if (*((unsigned char *)a2 + 456))
  {
    *(_WORD *)(v3 + 192) = *((_WORD *)a2 + 48);
    long long v13 = *(_OWORD *)(a2 + 26);
    *(_DWORD *)(v3 + 216) = a2[30];
    *(_OWORD *)(v3 + 200) = v13;
    if ((int *)(v3 + 96) != a2)
    {
      sub_10006E4A8((void *)(v3 + 224), *((char **)a2 + 16), *((char **)a2 + 17), *((void *)a2 + 17) - *((void *)a2 + 16));
      *(unsigned char *)(v3 + 248) = *((unsigned char *)a2 + 152);
      sub_10006E4A8((void *)(v3 + 256), *((char **)a2 + 20), *((char **)a2 + 21), *((void *)a2 + 21) - *((void *)a2 + 20));
    }
    *(unsigned char *)(v3 + 280) = *((unsigned char *)a2 + 184);
    std::string::operator=((std::string *)(v3 + 288), (const std::string *)a2 + 8);
    *(unsigned char *)(v3 + 312) = *((unsigned char *)a2 + 216);
    std::string::operator=((std::string *)(v3 + 320), (const std::string *)(a2 + 56));
    *(unsigned char *)(v3 + 344) = *((unsigned char *)a2 + 248);
    uint64_t v14 = *((void *)a2 + 32);
    *(_WORD *)(v3 + 360) = *((_WORD *)a2 + 132);
    *(void *)(v3 + 352) = v14;
    *(unsigned char *)(v3 + 368) = *((unsigned char *)a2 + 272);
    long long v15 = *(_OWORD *)(a2 + 70);
    *(_DWORD *)(v3 + 392) = a2[74];
    *(_OWORD *)(v3 + 376) = v15;
    if ((int *)(v3 + 192) != a2 + 24)
    {
      sub_10006E4A8((void *)(v3 + 400), *((char **)a2 + 38), *((char **)a2 + 39), *((void *)a2 + 39) - *((void *)a2 + 38));
      *(unsigned char *)(v3 + 424) = *((unsigned char *)a2 + 328);
      sub_10006E4A8((void *)(v3 + 432), *((char **)a2 + 42), *((char **)a2 + 43), *((void *)a2 + 43) - *((void *)a2 + 42));
    }
    *(unsigned char *)(v3 + 456) = *((unsigned char *)a2 + 360);
    std::string::operator=((std::string *)(v3 + 464), (const std::string *)(a2 + 92));
    *(unsigned char *)(v3 + 488) = *((unsigned char *)a2 + 392);
    std::string::operator=((std::string *)(v3 + 496), (const std::string *)(a2 + 100));
    *(unsigned char *)(v3 + 520) = *((unsigned char *)a2 + 424);
    uint64_t v16 = *((void *)a2 + 54);
    *(_WORD *)(v3 + 536) = *((_WORD *)a2 + 220);
    *(void *)(v3 + 528) = v16;
    *(unsigned char *)(v3 + 544) = *((unsigned char *)a2 + 448);
    *(unsigned char *)(v3 + 552) = *((unsigned char *)a2 + 456);
  }
  if (*((unsigned char *)a2 + 486))
  {
    int v17 = *(int *)((char *)a2 + 482);
    *(unsigned char *)(v3 + 582) = *((unsigned char *)a2 + 486);
    *(_DWORD *)(v3 + 578) = v17;
  }
  if (*((unsigned char *)a2 + 492)) {
    *(_DWORD *)(v3 + 632) = a2[122];
  }
  if (*((unsigned char *)a2 + 500))
  {
    int v18 = a2[124];
    if (*(_DWORD *)(v3 + 672) != v18)
    {
      *(_DWORD *)(v3 + 672) = v18;
      uint64_t v19 = *(void *)(v3 + 664);
      if (v19) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v19 + 48))(v19, v3 + 672);
      }
    }
  }
  if (*((unsigned char *)a2 + 472))
  {
    uint64_t v20 = *((void *)a2 + 58);
    *(unsigned char *)(v3 + 568) = *((unsigned char *)a2 + 472);
    *(void *)(v3 + 560) = v20;
  }
  if (*((unsigned char *)a2 + 481))
  {
    uint64_t v21 = *(void *)((char *)a2 + 473);
    *(unsigned char *)(v3 + 577) = *((unsigned char *)a2 + 481);
    *(void *)(v3 + 569) = v21;
  }
  if (*((unsigned char *)a2 + 508))
  {
    unsigned int v22 = a2 + 126;
    uint64_t v23 = (int *)(v3 + 600);
    if (*(unsigned char *)(v3 + 604))
    {
      int v24 = *v23;
      int v25 = *v22;
      *(unsigned char *)(v3 + 604) = *((unsigned char *)a2 + 508);
      int *v23 = v25;
      if (v24 == v25) {
        goto LABEL_44;
      }
    }
    else
    {
      int v26 = *v22;
      *(unsigned char *)(v3 + 604) = *((unsigned char *)a2 + 508);
      int *v23 = v26;
    }
    sub_100058DB0(buf, "/cc/events/activation_esim_flagset_changed");
    xpc_object_t object = xpc_null_create();
    ctu::RestModule::sendEvent();
    xpc_release(object);
    xpc_object_t object = 0;
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }
LABEL_44:
  if (*((unsigned char *)a2 + 513)) {
    *(_WORD *)(v3 + 608) = *((_WORD *)a2 + 256);
  }
  if (*(_DWORD *)(v3 + 632))
  {
    if (!*(unsigned char *)(v3 + 808))
    {
      *(unsigned char *)(v3 + 808) = 1;
      uint64_t v27 = *(void *)(v3 + 800);
      if (v27) {
LABEL_52:
      }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v27 + 48))(v27, v3 + 808);
    }
  }
  else
  {
    int v28 = *(_DWORD *)(v3 + 96) == 0;
    if (*(unsigned __int8 *)(v3 + 808) != v28)
    {
      *(unsigned char *)(v3 + 808) = v28;
      uint64_t v27 = *(void *)(v3 + 800);
      if (v27) {
        goto LABEL_52;
      }
    }
  }
  *(void *)std::string buf = 1;
  *(void *)&uint8_t buf[8] = v3 + 816;
  char v29 = sub_100A1D4A8(1, v3 + 680, *((unsigned char *)a2 + 8), *((unsigned char *)a2 + 9));
  LODWORD(object) = 1;
  char v30 = sub_100877FD0((uint64_t **)(v3 + 848), 1, &object);
  *((unsigned char *)v30 + 32) = v29;
  if (capabilities::ct::supportsGemini((capabilities::ct *)v30))
  {
    char v31 = sub_100A1D4A8(2, v3 + 680, *((unsigned char *)a2 + 8), *((unsigned char *)a2 + 9));
    LODWORD(object) = 2;
    *((unsigned char *)sub_100877FD0((uint64_t **)(*(void *)&buf[8] + 32), 2, &object) + 32) = v31;
  }
  uint64_t v32 = (capabilities::ct *)sub_100A20658((uint64_t)buf);
  *(void *)std::string buf = 1;
  *(void *)&uint8_t buf[8] = v3 + 872;
  if (capabilities::ct::supportsGemini(v32))
  {
    if (*((unsigned char *)a2 + 513))
    {
      if (*((unsigned char *)a2 + 512)) {
        int v33 = 2;
      }
      else {
        int v33 = 1;
      }
      *(_DWORD *)(*(void *)&buf[8] + 32) = v33;
    }
    else
    {
      *(_DWORD *)(*(void *)&buf[8] + 32) = 0;
    }
  }
  else
  {
    *(_DWORD *)(*(void *)&buf[8] + 32) = 1;
  }
  unint64_t v34 = (capabilities::ct *)sub_100A21380((uint64_t)buf);
  *(void *)std::string buf = 1;
  *(_OWORD *)&uint8_t buf[8] = (unint64_t)(v3 + 912);
  *(_DWORD *)&uint8_t buf[16] = *(_DWORD *)(v3 + 944);
  if (capabilities::ct::supports5G(v34))
  {
    int v35 = *((unsigned __int8 *)a2 + 515);
    if (*((unsigned char *)a2 + 515))
    {
      *(_WORD *)(v3 + 610) = *((_WORD *)a2 + 257);
      if (*((unsigned char *)a2 + 514)) {
        int v35 = 2;
      }
      else {
        int v35 = 1;
      }
    }
  }
  else
  {
    int v35 = 1;
  }
  *(_DWORD *)&uint8_t buf[16] = v35;
  uint64_t result = sub_100A213E4((uint64_t)buf);
  if (*((unsigned char *)a2 + 524))
  {
    int v37 = a2[130];
    *(unsigned char *)(v3 + 620) = *((unsigned char *)a2 + 524);
    *(_DWORD *)(v3 + 616) = v37;
  }
  return result;
}

void sub_100A1D428(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A1D4A8(int a1, uint64_t a2, unsigned __int8 a3, unsigned __int8 a4)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v4 = a2 + 8;
  uint64_t v5 = v6;
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v4;
  do
  {
    int v8 = *(_DWORD *)(v5 + 28);
    BOOL v9 = v8 < a1;
    if (v8 >= a1) {
      uint64_t v10 = (uint64_t *)v5;
    }
    else {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 == v4 || *(_DWORD *)(v7 + 28) > a1) {
    return 0;
  }
  int v11 = *(_DWORD *)(v7 + 32);
  if (v11 == 2) {
    return a4;
  }
  if (v11 != 1) {
    return 0;
  }
  return a3;
}

uint64_t sub_100A1D50C(uint64_t a1)
{
  return a1 + 96;
}

void sub_100A1D514(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(a1 + 8);
  ChipInformation::dumpState((ChipInformation *)(a1 + 56), (const ctu::OsLogLogger *)(a1 + 8));
  ActivationInfo::dumpState();
  sub_100BE9F88((unsigned char *)(a1 + 716), (os_log_t *)(a1 + 8));
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = asString();
    uint64_t v5 = *(int *)(a1 + 628);
    if (v5 > 3) {
      uint64_t v6 = "???";
    }
    else {
      uint64_t v6 = off_101A2BE00[v5];
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v33 = v4;
    __int16 v34 = 2080;
    uint64_t v35 = (uint64_t)v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I fPostponementStatus = %s, fPostponementError = %s", buf, 0x16u);
  }
  uint64_t v7 = *(void **)(a1 + 680);
  if (v7 != (void *)(a1 + 688))
  {
    do
    {
      int v8 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = subscriber::asString();
        uint64_t v10 = subscriber::asString();
        uint64_t v11 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315650;
        uint64_t v33 = v9;
        __int16 v34 = 2080;
        uint64_t v35 = v10;
        __int16 v36 = 2080;
        uint64_t v37 = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I fSimInfo[%s | %s] - %s", buf, 0x20u);
      }
      uint64_t v12 = (void *)v7[1];
      if (v12)
      {
        do
        {
          long long v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          long long v13 = (void *)v7[2];
          BOOL v14 = *v13 == (void)v7;
          uint64_t v7 = v13;
        }
        while (!v14);
      }
      uint64_t v7 = v13;
    }
    while (v13 != (void *)(a1 + 688));
  }
  long long v15 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 704)) {
      uint64_t v16 = "true";
    }
    else {
      uint64_t v16 = "false";
    }
    uint64_t v17 = asString();
    uint64_t v18 = asString();
    *(_DWORD *)std::string buf = 136315650;
    uint64_t v33 = (uint64_t)v16;
    __int16 v34 = 2080;
    uint64_t v35 = v17;
    __int16 v36 = 2080;
    uint64_t v37 = v18;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I fDefaultCarrierIDPresent = %s, fActivationMode = %s, fFactoryDebugState = %s", buf, 0x20u);
    long long v15 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 706)) {
      uint64_t v19 = "true";
    }
    else {
      uint64_t v19 = "false";
    }
    if (*(unsigned char *)(a1 + 707)) {
      uint64_t v20 = "true";
    }
    else {
      uint64_t v20 = "false";
    }
    uint64_t v21 = asString();
    uint64_t v22 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315906;
    uint64_t v33 = (uint64_t)v19;
    __int16 v34 = 2080;
    uint64_t v35 = (uint64_t)v20;
    __int16 v36 = 2080;
    uint64_t v37 = v21;
    __int16 v38 = 2080;
    uint64_t v39 = v22;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I fPhoneNumberAvailable = %s, fPendingMDNRequest = %s, fSimProvisionedState = %s, fCardProvisionedState = %s", buf, 0x2Au);
    long long v15 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 708)) {
      uint64_t v23 = "true";
    }
    else {
      uint64_t v23 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v33 = (uint64_t)v23;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I fAnyAssertions = %s", buf, 0xCu);
  }
  if (*(void *)(a1 + 720) == *(void *)(a1 + 728))
  {
    int v24 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#N fPostponementTicket = no cached ticket!", buf, 2u);
    }
  }
  int v31 = 0;
  int v25 = (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 384))(a1, &v31);
  int v26 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = "false";
    if (v25) {
      uint64_t v27 = "true";
    }
    int v28 = "kUnknown";
    if (v31 == 1) {
      int v28 = "kInMemory";
    }
    if (v31 == 2) {
      char v29 = "kPlist";
    }
    else {
      char v29 = v28;
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v33 = (uint64_t)v27;
    __int16 v34 = 2080;
    uint64_t v35 = (uint64_t)v29;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I isTicketAvailable = %s source = %s", buf, 0x16u);
    int v26 = *v2;
  }
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 1128)) {
      char v30 = "true";
    }
    else {
      char v30 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v33 = (uint64_t)v30;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Factory activation enabled = %s", buf, 0xCu);
  }
}

uint64_t sub_100A1DA20(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Invalidating all UMTS data received", v12, 2u);
  }
  UMTSProvisioningInfo::UMTSProvisioningInfo((UMTSProvisioningInfo *)v12);
  *(_WORD *)(a1 + 192) = *(_WORD *)v12;
  *(_OWORD *)(a1 + 200) = v13;
  *(_DWORD *)(a1 + 216) = v14;
  uint64_t v3 = *(void **)(a1 + 224);
  if (v3)
  {
    *(void *)(a1 + 232) = v3;
    operator delete(v3);
  }
  *(_OWORD *)(a1 + 224) = v15;
  *(void *)(a1 + 240) = v16;
  uint64_t v16 = 0;
  long long v15 = 0uLL;
  *(unsigned char *)(a1 + 248) = v17;
  uint64_t v4 = *(void **)(a1 + 256);
  if (v4)
  {
    *(void *)(a1 + 264) = v4;
    operator delete(v4);
  }
  *(_OWORD *)(a1 + 256) = v18;
  *(void *)(a1 + 272) = v19;
  uint64_t v19 = 0;
  long long v18 = 0uLL;
  *(unsigned char *)(a1 + 280) = v20;
  uint64_t v5 = (void **)(a1 + 288);
  if (*(char *)(a1 + 311) < 0) {
    operator delete(*v5);
  }
  *(_OWORD *)uint64_t v5 = v21;
  *(void *)(a1 + 304) = v22;
  HIBYTE(v22) = 0;
  LOBYTE(v21) = 0;
  *(unsigned char *)(a1 + 312) = v23;
  uint64_t v6 = (void **)(a1 + 320);
  if (*(char *)(a1 + 343) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)uint64_t v6 = v24;
  *(void *)(a1 + 336) = v25;
  HIBYTE(v25) = 0;
  LOBYTE(v24) = 0;
  *(unsigned char *)(a1 + 344) = v26;
  *(void *)(a1 + 352) = v27;
  *(_WORD *)(a1 + 360) = v28;
  *(unsigned char *)(a1 + 368) = v29;
  *(_DWORD *)(a1 + 392) = v31;
  *(_OWORD *)(a1 + 376) = v30;
  uint64_t v7 = *(void **)(a1 + 400);
  if (v7)
  {
    *(void *)(a1 + 408) = v7;
    operator delete(v7);
  }
  *(_OWORD *)(a1 + 400) = v32;
  *(void *)(a1 + 416) = v33;
  uint64_t v33 = 0;
  long long v32 = 0uLL;
  *(unsigned char *)(a1 + 424) = v34;
  int v8 = *(void **)(a1 + 432);
  if (v8)
  {
    *(void *)(a1 + 440) = v8;
    operator delete(v8);
  }
  *(_OWORD *)(a1 + 432) = v35;
  *(void *)(a1 + 448) = v36;
  uint64_t v36 = 0;
  long long v35 = 0uLL;
  *(unsigned char *)(a1 + 456) = v37;
  uint64_t v9 = (void **)(a1 + 464);
  if (*(char *)(a1 + 487) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)uint64_t v9 = v38;
  *(void *)(a1 + 480) = v39;
  HIBYTE(v39) = 0;
  LOBYTE(v38) = 0;
  *(unsigned char *)(a1 + 488) = v40;
  uint64_t v10 = (void **)(a1 + 496);
  if (*(char *)(a1 + 519) < 0) {
    operator delete(*v10);
  }
  *(_OWORD *)uint64_t v10 = v41;
  *(void *)(a1 + 512) = v42;
  HIBYTE(v42) = 0;
  LOBYTE(v41) = 0;
  *(unsigned char *)(a1 + 520) = v43;
  *(void *)(a1 + 528) = v44;
  *(_WORD *)(a1 + 536) = v45;
  *(unsigned char *)(a1 + 544) = v46;
  uint64_t result = sub_100A1E60C((uint64_t)v12);
  *(unsigned char *)(a1 + 552) = 0;
  return result;
}

uint64_t *sub_100A1DCE8(uint64_t *result, int a2, void *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = result[86];
  if (v6)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (void *)v6;
        int v8 = *(_DWORD *)(v6 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v6 = *v7;
        uint64_t v9 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= a2)
      {
        uint64_t v12 = v7;
        goto LABEL_13;
      }
      uint64_t v6 = v7[1];
    }
    while (v6);
    uint64_t v9 = (uint64_t **)(v7 + 1);
  }
  else
  {
    uint64_t v9 = (uint64_t **)(result + 86);
    uint64_t v7 = result + 86;
  }
LABEL_10:
  uint64_t v12 = operator new(0x28uLL);
  v12[7] = a2;
  ActivationSimInfo::ActivationSimInfo((ActivationSimInfo *)(v12 + 8));
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = v7;
  *uint64_t v9 = (uint64_t *)v12;
  uint64_t v10 = *(void *)v5[85];
  uint64_t v11 = (uint64_t *)v12;
  if (v10)
  {
    v5[85] = v10;
    uint64_t v11 = *v9;
  }
  uint64_t result = sub_100046C90((uint64_t *)v5[86], v11);
  ++v5[87];
LABEL_13:
  *((void *)v12 + 4) = *a3;
  return result;
}

void sub_100A1DDC4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1DDD8(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 688);
  if (!v2) {
    goto LABEL_11;
  }
  uint64_t v3 = a1 + 688;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 688 && *(_DWORD *)(v3 + 28) <= a2)
  {
    uint64_t v7 = (char *)(v3 + 32);
  }
  else
  {
LABEL_11:
    uint64_t v7 = &v9;
    ActivationSimInfo::ActivationSimInfo();
  }
  return *(void *)v7;
}

uint64_t sub_100A1DE5C(_DWORD *a1)
{
  uint64_t v7 = (capabilities::ct *)CFPreferencesCopyValue(@"CarrierId", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  int v2 = capabilities::ct::supportsVoiceCall(v7);
  if (a1[24] && (int v3 = v2, !(*(unsigned int (**)(_DWORD *))(*(void *)a1 + 376))(a1)))
  {
    if (a1[24] == 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 ^ 1u;
    }
  }
  else
  {
    if (v7) {
      int v4 = sub_100080934;
    }
    else {
      int v4 = 0;
    }
    uint64_t v5 = v4 == 0;
  }
  sub_1000577C4((const void **)&v7);
  return v5;
}

void sub_100A1DF3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1DF50(uint64_t a1)
{
  int v2 = 0;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 384))(a1, &v2);
}

BOOL sub_100A1DFA0(void *a1, _DWORD *a2)
{
  *a2 = 0;
  if ((*(unsigned int (**)(void *))(*a1 + 400))(a1))
  {
    *a2 = 1;
    return a1[90] != a1[91];
  }
  else if ((*(unsigned int (**)(void *))(*a1 + 264))(a1))
  {
    *a2 = 2;
    char v9 = 0;
    DevicePersistentCopyValue((uint64_t *)buf, kPostponementTicketPlist, 0);
    sub_10004EFE4(&v9, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (v9) {
      uint64_t v5 = sub_100080778;
    }
    else {
      uint64_t v5 = 0;
    }
    BOOL v4 = v5 != 0;
    if (!HIBYTE(word_101B0FCB0) || word_101B0FCB0 != v4)
    {
      word_101B0FCB0 = (v5 != 0) | 0x100;
      uint64_t v6 = a1[1];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = "false";
        if (v5) {
          uint64_t v7 = "true";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ticket present: %s", buf, 0xCu);
      }
    }
    sub_100057D78(&v9);
  }
  else
  {
    return 0;
  }
  return v4;
}

void sub_100A1E184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100A1E1A0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 672) == 1;
}

BOOL sub_100A1E1B0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 632) == 0;
}

uint64_t sub_100A1E1C0(uint64_t result)
{
  *(unsigned char *)(result + 716) = 1;
  return result;
}

uint64_t sub_100A1E1CC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 717) = a2;
  return result;
}

uint64_t sub_100A1E1D4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 717);
}

uint64_t sub_100A1E1DC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 718) = a2;
  return result;
}

uint64_t sub_100A1E1E4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 718);
}

BOOL sub_100A1E1EC(uint64_t a1)
{
  return !*(unsigned char *)(a1 + 716) && *(unsigned char *)(a1 + 717) == 0;
}

uint64_t sub_100A1E20C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 705);
}

uint64_t sub_100A1E214(uint64_t a1)
{
  return *(unsigned int *)(a1 + 712);
}

void sub_100A1E21C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 712) != a2)
  {
    BOOL v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      uint64_t v6 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting SIM provisioned state to: %s", (uint8_t *)&v5, 0xCu);
    }
  }
  *(_DWORD *)(a1 + 712) = a2;
}

uint64_t sub_100A1E2DC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 768);
}

uint64_t sub_100A1E2E4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 768) = a2;
  return result;
}

uint64_t sub_100A1E2EC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 706);
}

uint64_t sub_100A1E2F4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 706) = a2;
  if ((a2 & 1) == 0)
  {
    if (*(char *)(result + 767) < 0)
    {
      **(unsigned char **)(result + 744) = 0;
      *(void *)(result + 752) = 0;
    }
    else
    {
      *(unsigned char *)(result + 744) = 0;
      *(unsigned char *)(result + 767) = 0;
    }
  }
  return result;
}

uint64_t sub_100A1E320(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 707);
}

uint64_t sub_100A1E328(uint64_t result, char a2)
{
  *(unsigned char *)(result + 707) = a2;
  return result;
}

std::string *sub_100A1E330(std::string *a1, const std::string *a2)
{
  return std::string::operator=(a1 + 31, a2);
}

uint64_t sub_100A1E338(uint64_t a1)
{
  return a1 + 744;
}

void sub_100A1E340(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 708) = a2;
  int v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v4 = "inactive";
    if (a2) {
      BOOL v4 = "active";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Setting OTA assertions to %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_100A1E3F8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 708);
}

uint64_t sub_100A1E400(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1128);
}

uint64_t sub_100A1E408(uint64_t result, char a2)
{
  *(unsigned char *)(result + 1128) = a2;
  return result;
}

uint64_t sub_100A1E410(uint64_t a1)
{
  return *(unsigned int *)(a1 + 944);
}

uint64_t sub_100A1E418(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1040);
}

uint64_t sub_100A1E420(uint64_t a1)
{
  if (*(_WORD *)(a1 + 1120)) {
    unsigned int v1 = 2;
  }
  else {
    unsigned int v1 = 1;
  }
  if (*(unsigned __int16 *)(a1 + 1120) >= 0x100u) {
    return v1;
  }
  else {
    return 0;
  }
}

void *sub_100A1E43C(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A1E4C0(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  return sub_10012C330((void *)a1);
}

void *sub_100A1E504(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A1E588(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100A1E60C(uint64_t a1)
{
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(char *)(a1 + 295) < 0) {
    operator delete(*(void **)(a1 + 272));
  }
  int v2 = *(void **)(a1 + 240);
  if (v2)
  {
    *(void *)(a1 + 248) = v2;
    operator delete(v2);
  }
  int v3 = *(void **)(a1 + 208);
  if (v3)
  {
    *(void *)(a1 + 216) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  BOOL v4 = *(void **)(a1 + 64);
  if (v4)
  {
    *(void *)(a1 + 72) = v4;
    operator delete(v4);
  }
  int v5 = *(void **)(a1 + 32);
  if (v5)
  {
    *(void *)(a1 + 40) = v5;
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_100A1E6B0(uint64_t a1)
{
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  int v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  int v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_100A1E714(int a1, __CFDictionary **a2, uint64_t a3)
{
  memset(v22, 0, sizeof(v22));
  int v24 = 0;
  long long v23 = 0u;
  *(_OWORD *)char v20 = *(_OWORD *)(a3 + 104);
  int v21 = *(_DWORD *)(a3 + 120);
  memset((char *)v22 + 4, 0, 24);
  sub_10005C928((void **)((char *)v22 + 4), *(const void **)(a3 + 128), *(void *)(a3 + 136), *(void *)(a3 + 136) - *(void *)(a3 + 128));
  BYTE4(v22[3]) = *(unsigned char *)(a3 + 152);
  memset((char *)&v22[4] + 4, 0, 24);
  sub_10005C928((void **)((char *)&v22[4] + 4), *(const void **)(a3 + 160), *(void *)(a3 + 168), *(void *)(a3 + 168) - *(void *)(a3 + 160));
  BYTE4(v22[7]) = *(unsigned char *)(a3 + 184);
  if (*(char *)(a3 + 215) < 0)
  {
    sub_10004FC84((unsigned char *)&v22[8] + 4, *(void **)(a3 + 192), *(void *)(a3 + 200));
  }
  else
  {
    *(_OWORD *)((char *)&v22[8] + 4) = *(_OWORD *)(a3 + 192);
    *(void **)((char *)&v22[10] + 4) = *(void **)(a3 + 208);
  }
  BYTE4(v22[11]) = *(unsigned char *)(a3 + 216);
  if (*(char *)(a3 + 247) < 0)
  {
    sub_10004FC84((unsigned char *)&v22[12] + 4, *(void **)(a3 + 224), *(void *)(a3 + 232));
  }
  else
  {
    *(_OWORD *)((char *)&v22[12] + 4) = *(_OWORD *)(a3 + 224);
    *(void **)((char *)&v22[14] + 4) = *(void **)(a3 + 240);
  }
  BYTE4(v22[15]) = *(unsigned char *)(a3 + 248);
  *(void *)((char *)&v23 + 4) = *(void *)(a3 + 256);
  WORD6(v23) = *(_WORD *)(a3 + 264);
  if (a1 == 2)
  {
    int v21 = *(_DWORD *)(a3 + 296);
    *(_OWORD *)char v20 = *(_OWORD *)(a3 + 280);
    if ((unsigned __int8 *)(a3 + 280) == v20)
    {
      BYTE4(v22[3]) = *(unsigned char *)(a3 + 328);
    }
    else
    {
      sub_10006E4A8((void **)((char *)v22 + 4), *(char **)(a3 + 304), *(char **)(a3 + 312), *(void *)(a3 + 312) - *(void *)(a3 + 304));
      BYTE4(v22[3]) = *(unsigned char *)(a3 + 328);
      sub_10006E4A8((void **)((char *)&v22[4] + 4), *(char **)(a3 + 336), *(char **)(a3 + 344), *(void *)(a3 + 344) - *(void *)(a3 + 336));
    }
    BYTE4(v22[7]) = *(unsigned char *)(a3 + 360);
    std::string::operator=((std::string *)((char *)&v22[8] + 4), (const std::string *)(a3 + 368));
    BYTE4(v22[11]) = *(unsigned char *)(a3 + 392);
    std::string::operator=((std::string *)((char *)&v22[12] + 4), (const std::string *)(a3 + 400));
    BYTE4(v22[15]) = *(unsigned char *)(a3 + 424);
    uint64_t v6 = a3 + 432;
  }
  else
  {
    if (a1 != 1) {
      goto LABEL_18;
    }
    *(_OWORD *)char v20 = *(_OWORD *)(a3 + 104);
    int v21 = *(_DWORD *)(a3 + 120);
    if ((unsigned __int8 *)(a3 + 104) == v20)
    {
      BYTE4(v22[3]) = *(unsigned char *)(a3 + 152);
    }
    else
    {
      sub_10006E4A8((void **)((char *)v22 + 4), *(char **)(a3 + 128), *(char **)(a3 + 136), *(void *)(a3 + 136) - *(void *)(a3 + 128));
      BYTE4(v22[3]) = *(unsigned char *)(a3 + 152);
      sub_10006E4A8((void **)((char *)&v22[4] + 4), *(char **)(a3 + 160), *(char **)(a3 + 168), *(void *)(a3 + 168) - *(void *)(a3 + 160));
    }
    BYTE4(v22[7]) = *(unsigned char *)(a3 + 184);
    std::string::operator=((std::string *)((char *)&v22[8] + 4), (const std::string *)(a3 + 192));
    BYTE4(v22[11]) = *(unsigned char *)(a3 + 216);
    std::string::operator=((std::string *)((char *)&v22[12] + 4), (const std::string *)(a3 + 224));
    uint64_t v6 = a3 + 256;
    BYTE4(v22[15]) = *(unsigned char *)(a3 + 248);
  }
  *(void *)((char *)&v23 + 4) = *(void *)v6;
  WORD6(v23) = *(_WORD *)(v6 + 8);
LABEL_18:
  if (v20[8])
  {
    CFStringRef valuePtr = (void *)createActivationStringFromData(v20, 8uLL);
    sub_10010F3F0(*a2, kCTPostponementInfoIMSI, (uint64_t)valuePtr);
    if (*(unsigned char *)(a3 + 97))
    {
      if (*(unsigned char *)(a3 + 96)) {
        uint64_t v7 = (uint64_t *)&kCFBooleanTrue;
      }
      else {
        uint64_t v7 = (uint64_t *)&kCFBooleanFalse;
      }
      sub_10012C97C(*a2, kCTPostponementInfoIMSIOverride, *v7);
    }
    sub_1000558F4((const void **)&valuePtr);
  }
  if (HIBYTE(v21))
  {
    CFStringRef valuePtr = 0;
    CFStringRef valuePtr = (void *)createActivationStringFromData((const unsigned __int8 *)((unint64_t)v20 | 9), 0xAuLL);
    sub_10010F3F0(*a2, kCTPostponementInfoICCID, (uint64_t)valuePtr);
    sub_1000558F4((const void **)&valuePtr);
  }
  if (BYTE4(v22[11]))
  {
    CFStringRef valuePtr = 0;
    if (SBYTE3(v22[11]) >= 0) {
      int v8 = (char *)&v22[8] + 4;
    }
    else {
      int v8 = *(const char **)((char *)&v22[8] + 4);
    }
    CFStringRef valuePtr = (void *)CFStringCreateWithCString(kCFAllocatorDefault, v8, 0x8000100u);
    sub_10010F3F0(*a2, @"GID1", (uint64_t)valuePtr);
    sub_1000558F4((const void **)&valuePtr);
  }
  if (BYTE4(v22[15]))
  {
    CFStringRef valuePtr = 0;
    if (SBYTE3(v22[15]) >= 0) {
      char v9 = (char *)&v22[12] + 4;
    }
    else {
      char v9 = *(const char **)((char *)&v22[12] + 4);
    }
    CFStringRef valuePtr = (void *)CFStringCreateWithCString(kCFAllocatorDefault, v9, 0x8000100u);
    sub_10010F3F0(*a2, @"GID2", (uint64_t)valuePtr);
    sub_1000558F4((const void **)&valuePtr);
  }
  if (BYTE4(v22[3]))
  {
    CFStringRef valuePtr = 0;
    CFStringRef valuePtr = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)((char *)v22 + 4), (char *)*(void **)((char *)&v22[1] + 4) - (char *)*(void **)((char *)v22 + 4));
    sub_10012C54C(*a2, kCTPostponementInfoGID1, (uint64_t)valuePtr);
    sub_100030068((const void **)&valuePtr);
  }
  if (BYTE4(v22[7]))
  {
    CFStringRef valuePtr = 0;
    CFStringRef valuePtr = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)((char *)&v22[4] + 4), (char *)*(void **)((char *)&v22[5] + 4) - (char *)*(void **)((char *)&v22[4] + 4));
    sub_10012C54C(*a2, kCTPostponementInfoGID2, (uint64_t)valuePtr);
    sub_100030068((const void **)&valuePtr);
  }
  if (BYTE11(v23))
  {
    if (BYTE10(v23)) {
      uint64_t v10 = &kCFBooleanTrue;
    }
    else {
      uint64_t v10 = &kCFBooleanFalse;
    }
    CFStringRef valuePtr = *v10;
    sub_10012C97C(*a2, kCTPostponementInfoSim1IsEmbedded, (uint64_t)valuePtr);
    sub_100062778((const void **)&valuePtr);
  }
  if (BYTE13(v23))
  {
    if (BYTE12(v23)) {
      uint64_t v11 = &kCFBooleanTrue;
    }
    else {
      uint64_t v11 = &kCFBooleanFalse;
    }
    CFStringRef valuePtr = *v11;
    sub_10012C97C(*a2, kCTPostponementInfoSim1IsBootstrap, (uint64_t)valuePtr);
    sub_100062778((const void **)&valuePtr);
  }
  if (v20[8] && BYTE8(v23))
  {
    uint64_t v12 = *a2;
    long long v13 = (void *)WORD2(v23);
    key = @"PRIVersion_ReleaseNo";
    if (@"PRIVersion_ReleaseNo") {
      CFRetain(@"PRIVersion_ReleaseNo");
    }
    CFStringRef valuePtr = v13;
    CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
    CFNumberRef v17 = v14;
    if (key && v14) {
      CFDictionaryAddValue(v12, key, v14);
    }
    sub_10010F494((const void **)&v17);
    sub_10010F494((const void **)&key);
    sub_100A1EE94(*a2, @"PRIVersion_Minor", BYTE7(v23), kCFAllocatorDefault);
    sub_100A1EE94(*a2, @"PRIVersion_Major", BYTE6(v23), kCFAllocatorDefault);
    key = 0;
    long long v15 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%d.%d.%d", BYTE6(v23), BYTE7(v23), WORD2(v23), v17);
    uint64_t v16 = key;
    key = v15;
    CFStringRef valuePtr = v16;
    sub_1000558F4((const void **)&valuePtr);
    sub_10010F3F0(*a2, kCTPostponementInfoPRIVersion, (uint64_t)key);
    sub_1000558F4((const void **)&key);
  }
  if (SBYTE3(v22[15]) < 0) {
    operator delete(*(void **)((char *)&v22[12] + 4));
  }
  if (SBYTE3(v22[11]) < 0) {
    operator delete(*(void **)((char *)&v22[8] + 4));
  }
  if (*(void **)((char *)&v22[4] + 4))
  {
    *(void **)((char *)&v22[5] + 4) = *(void **)((char *)&v22[4] + 4);
    operator delete(*(void **)((char *)&v22[4] + 4));
  }
  if (*(void **)((char *)v22 + 4))
  {
    *(void **)((char *)&v22[1] + 4) = *(void **)((char *)v22 + 4);
    operator delete(*(void **)((char *)v22 + 4));
  }
}

void sub_100A1ED9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, const void *a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
}

const void **sub_100A1EE94(__CFDictionary *a1, void *cf, unsigned int a3, CFAllocatorRef allocator)
{
  key = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t valuePtr = a3;
  CFNumberRef v7 = CFNumberCreate(allocator, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v10 = v7;
  if (key) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    CFDictionaryAddValue(a1, key, v7);
  }
  sub_10010F494((const void **)&v10);
  return sub_10010F494((const void **)&key);
}

void sub_100A1EF24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  sub_10010F494((const void **)va);
  sub_10010F494((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100A1EF48(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A1EFC8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A1F004(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A1F03C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A1F06C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A1F0B4()
{
}

uint64_t sub_100A1F0C8(uint64_t a1)
{
  return *(void *)(a1 + 8) + 8;
}

void sub_100A1F0D8()
{
}

void *sub_100A1F0EC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2B960;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1F134(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2B960;
  a2[1] = v2;
  return result;
}

void sub_100A1F160(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/baseband_activated");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100A1F210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1F258(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1F298()
{
}

void sub_100A1F2A8()
{
}

void *sub_100A1F2BC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2B9E0;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1F304(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2B9E0;
  a2[1] = v2;
  return result;
}

void sub_100A1F330(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  CFNumberRef v7 = (void *)*a2;
  char v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v29 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v29 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v29 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v27, (ctu::rest::detail *)v11, v12, v13);
      long long __p = &v29;
      long long v23 = "first";
      sub_100035E70((uint64_t)&__p, &v27, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v27);
      xpc_object_t v27 = 0;
      CFNumberRef v14 = (ctu::rest::detail *)*((unsigned __int8 *)v6 + 32);
      unint64_t v15 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, v14, v15, v16);
      long long __p = &v29;
      long long v23 = "second";
      sub_100035E70((uint64_t)&__p, &v25, &v26);
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      xpc_object_t v17 = v29;
      if (v29) {
        xpc_retain(v29);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      xpc_release(v29);
      xpc_array_append_value(v4, v17);
      xpc_release(v17);
      long long v18 = (void *)v6[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          long long v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v6[2];
          BOOL v20 = *v19 == (void)v6;
          uint64_t v6 = v19;
        }
        while (!v20);
      }
      uint64_t v6 = v19;
    }
    while (v19 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/baseband_service_provisioned_states");
  xpc_object_t v29 = v21;
  if (v21) {
    xpc_retain(v21);
  }
  else {
    xpc_object_t v29 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (v24 < 0) {
    operator delete(__p);
  }
  xpc_release(v21);
}

void sub_100A1F608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1F6C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1F700()
{
}

void sub_100A1F710()
{
}

void *sub_100A1F724(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BA70;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1F76C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BA70;
  a2[1] = v2;
  return result;
}

void sub_100A1F798(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/props/activation_factory_debug");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100A1F84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A1F890(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1F8D0()
{
}

void sub_100A1F8E0()
{
}

void *sub_100A1F8F4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BB00;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1F93C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BB00;
  a2[1] = v2;
  return result;
}

void sub_100A1F968(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/prefs-nb/activation_gemini_support");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100A1FA1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A1FA60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1FAA0()
{
}

void sub_100A1FAB0()
{
}

void *sub_100A1FAC4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BB80;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1FB0C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BB80;
  a2[1] = v2;
  return result;
}

void sub_100A1FB38(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/prefs-nb/activation_5g_support");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100A1FBEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A1FC30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1FC70()
{
}

void sub_100A1FC80()
{
}

void *sub_100A1FC94(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BC00;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1FCDC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BC00;
  a2[1] = v2;
  return result;
}

void sub_100A1FD08(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v2 = (const char *)a2;
  }
  else {
    uint64_t v2 = *(const char **)a2;
  }
  xpc_object_t v3 = xpc_string_create(v2);
  if (!v3) {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/activation_rejected_iccid");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v6 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_100A1FDC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1FE0C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A1FE4C()
{
}

void sub_100A1FE5C()
{
}

void *sub_100A1FE70(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BC80;
  result[1] = v3;
  return result;
}

uint64_t sub_100A1FEB8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BC80;
  a2[1] = v2;
  return result;
}

void sub_100A1FEE4(uint64_t a1, BOOL *a2)
{
  xpc_object_t v2 = xpc_BOOL_create(*a2);
  if (!v2) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/is_postponement_ticket_available");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100A1FF94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100A1FFDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A2001C()
{
}

void sub_100A2002C()
{
}

void *sub_100A20040(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BD00;
  result[1] = v3;
  return result;
}

uint64_t sub_100A20088(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BD00;
  a2[1] = v2;
  return result;
}

void sub_100A200B4(uint64_t a1, int *a2)
{
  int v2 = *a2;
  xpc_object_t v9 = 0;
  uint64_t v3 = (ctu::rest::detail *)v2;
  uint64_t v4 = asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v9, v3, v4, v5);
  sub_100058DB0(&__p, "/cc/prefs-nb/is_activation_policy_locked");
  xpc_object_t object = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v8 < 0) {
    operator delete(__p);
  }
  xpc_release(v9);
}

void sub_100A20168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A201AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A201EC()
{
}

void sub_100A201FC()
{
}

void *sub_100A20210(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2BD80;
  result[1] = v3;
  return result;
}

uint64_t sub_100A20258(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2BD80;
  a2[1] = v2;
  return result;
}

void sub_100A20284(uint64_t a1, unsigned char *a2)
{
  if (!a2[1] || (xpc_object_t v2 = xpc_BOOL_create(*a2 != 0)) == 0) {
    xpc_object_t v2 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/post_buddy_ticket_refresh");
  xpc_object_t object = v2;
  if (v2) {
    xpc_retain(v2);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v5 < 0) {
    operator delete(__p);
  }
  xpc_release(v2);
}

void sub_100A20354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100A20398(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A203D8()
{
}

void *sub_100A203E4(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    char v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        _OWORD v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        _OWORD v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        _OWORD v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      _OWORD v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_100A2064C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_100A20658(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A206BC(uint64_t *a1)
{
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)long long v13 = 0u;
  memset(v12, 0, sizeof(v12));
  sub_10004DE24((uint64_t)v12);
  uint64_t v2 = (const char *)asString();
  size_t v3 = strlen(v2);
  uint64_t v4 = sub_10004B96C(v12, (uint64_t)v2, v3);
  char v5 = sub_10004B96C(v4, (uint64_t)", ", 2);
  char v6 = (const char *)asString();
  size_t v7 = strlen(v6);
  char v8 = sub_10004B96C(v5, (uint64_t)v6, v7);
  sub_10004B96C(v8, (uint64_t)", ", 2);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v12 + 8, __p);
  sub_1001AA668(a1, (uint64_t *)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100A208B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

atomic_uint **sub_100A208C8(uint64_t *a1, int a2, int a3, char a4)
{
  int v27 = a3;
  int v28 = a2;
  char v26 = a4;
  long long v25 = 0uLL;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  char v5 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(&v31, v5);
  uint64_t v6 = a1[1];
  if (v6)
  {
    if (atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) == 1) {
      sub_1009F9AE0(a1, &v31, 0, 1);
    }
    uint64_t v7 = *a1;
    uint64_t v8 = a1[1];
    if (v8) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v8 + 8), 1u, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v7 = *a1;
  }
  long long v9 = v25;
  *(void *)&long long v25 = v7;
  *((void *)&v25 + 1) = v8;
  v30[0] = v9;
  sub_10000A740((atomic_uint **)v30 + 1);
  sub_10000A6C8(*((pthread_mutex_t **)&v42 + 1));
  sub_10000A5F8(&v31);
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  uint64_t v46 = 0;
  uint64_t v47 = 10;
  unint64_t v48 = (char *)&v31 + 8;
  uint64_t v49 = 0;
  BOOL v50 = &v28;
  __int16 v51 = &v27;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  __int16 v52 = &v26;
  xpc_object_t v10 = (uint64_t *)sub_1009F973C((uint64_t *)&v25);
  v24[0] = &v31;
  v24[1] = a1;
  _OWORD v24[2] = sub_1009FAAA0(v10);
  uint64_t v11 = sub_1009F973C((uint64_t *)&v25);
  uint64_t v12 = sub_100060EA8((uint64_t *)(v11 + 16));
  long long v13 = (uint64_t *)sub_1009F973C((uint64_t *)&v25);
  uint64_t v14 = *(void *)(sub_1009FAAA0(v13) + 8);
  long long v15 = (uint64_t *)sub_1009F973C((uint64_t *)&v25);
  *(void *)&long long v22 = v14;
  *((void *)&v22 + 1) = sub_1009FAAA0(v15);
  *(void *)&long long v23 = &v31;
  *((void *)&v23 + 1) = *((void *)&v22 + 1);
  sub_100A20CE8((uint64_t *)&v22);
  long long v16 = (uint64_t *)sub_1009F973C((uint64_t *)&v25);
  uint64_t v17 = sub_1009FAAA0(v16);
  long long v18 = (uint64_t *)sub_1009F973C((uint64_t *)&v25);
  *(void *)&long long v20 = v17;
  *((void *)&v20 + 1) = sub_1009FAAA0(v18);
  *(void *)&long long v21 = &v31;
  *((void *)&v21 + 1) = *((void *)&v20 + 1);
  sub_100A20CE8((uint64_t *)&v20);
  v30[0] = v22;
  v30[1] = v23;
  v29[0] = v20;
  v29[1] = v21;
  sub_100A20B54(v12, (uint64_t *)v30, v29);
  sub_100A210A8((uint64_t)v24);
  sub_100A2128C((uint64_t)&v31);
  return sub_10000A740((atomic_uint **)&v25 + 1);
}

void sub_100A20B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,atomic_uint *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_100A20B54(uint64_t a1, uint64_t *a2, void *a3)
{
  while (*a2 != *a3)
  {
    sub_100A20BD4(a2);
    *a2 = *(void *)(*a2 + 8);
    sub_100A20CE8(a2);
    char v5 = (unsigned char *)a2[2];
    if (*v5) {
      unsigned char *v5 = 0;
    }
  }
}

unsigned char *sub_100A20BD4(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[2];
  if (!*v2)
  {
    sub_100A20C90((uint64_t)(v2 + 272), (uint64_t *)(*a1 + 16));
    if (!*v2) {
      *uint64_t v2 = 1;
    }
  }
  size_t v3 = (unsigned char *)a1[2];
  if (!*v3) {
    __assert_rtn("get", "optional.hpp", 1212, "this->is_initialized()");
  }
  return v3 + 1;
}

uint64_t sub_100A20C90(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = sub_1009F9780(a2);
  size_t v3 = (void *)(sub_1009FA230((uint64_t *)(v2 + 32)) + 24);

  return sub_1009FB2A8(v3);
}

void sub_100A20CE8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1 != a1[3])
  {
    if (v1 == a1[1]) {
      goto LABEL_15;
    }
    while (1)
    {
      sub_100062390((atomic_uint **)(a1[2] + 8), *(void *)(a1[2] + 264));
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      size_t v3 = (uint64_t *)(*a1 + 16);
      long long v15 = 0u;
      long long v16 = 0u;
      uint64_t v4 = sub_100A20F44(v3);
      sub_10000A4EC(&v15, v4);
      char v5 = (atomic_uint **)sub_1009F9780((uint64_t *)(*a1 + 16));
      sub_100A20F88(v5, &v15, (void *)(a1[2] + 8));
      uint64_t v6 = sub_1009F9780((uint64_t *)(*a1 + 16));
      uint64_t v7 = a1[2];
      if (*(unsigned char *)(v6 + 24)) {
        ++*(_DWORD *)(v7 + 296);
      }
      else {
        ++*(_DWORD *)(v7 + 300);
      }
      uint64_t v8 = sub_1009F9780((uint64_t *)(*a1 + 16));
      if (!*(unsigned char *)(v8 + 24)
        || (uint64_t v9 = *(void *)(v8 + 16)) != 0
        && atomic_load_explicit((atomic_uint *volatile)(v9 + 8), memory_order_acquire))
      {
        int v10 = 1;
      }
      else
      {
        sub_1001AD63C(a1, &v15, *a1);
        int v10 = 0;
      }
      (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
      sub_10000A5F8(&v15);
      uint64_t v1 = *a1;
      uint64_t v11 = a1[1];
      if (!v10) {
        break;
      }
      uint64_t v12 = *(void *)(v1 + 8);
      *a1 = v12;
      if (v12 == v11)
      {
        uint64_t v1 = v11;
        goto LABEL_15;
      }
    }
    if (v1 == v11)
    {
LABEL_15:
      uint64_t v13 = a1[3];
      if (v13 != v1)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        uint64_t v14 = sub_100A20F44((uint64_t *)(v13 + 16));
        sub_10000A4EC(&v15, v14);
        sub_1001AD63C(a1, &v15, a1[1]);
        (*(void (**)(void))(**((void **)&v26 + 1) + 32))(*((void *)&v26 + 1));
        sub_10000A5F8(&v15);
      }
    }
  }
}

void sub_100A20F08(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A20F44(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

atomic_uint **sub_100A20F88(atomic_uint **result, void *a2, void *a3)
{
  size_t v3 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v6 = result;
    for (uint64_t i = *(atomic_uint **)sub_1009FA230((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1009FA230(v3);
      if (i == result[1]) {
        break;
      }
      memset(v8, 0, sizeof(v8));
      sub_100060B10(i, (uint64_t)v8);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v6 + 24))
        {
          *((unsigned char *)v6 + 24) = 0;
          sub_100060D70(v6, a2);
        }
        return sub_1000624B4((uint64_t)v8);
      }
      sub_100062188(a3, (uint64_t)v8);
      sub_1000624B4((uint64_t)v8);
    }
  }
  return result;
}

void sub_100A21084(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A210A8(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)a1 + 300) > *(_DWORD *)(*(void *)a1 + 296)) {
    sub_100A210EC(*(uint64_t **)(a1 + 8), *(void *)(a1 + 16));
  }
  return a1;
}

void sub_100A210EC(uint64_t *a1, uint64_t a2)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v9, v4);
  char v5 = (uint64_t *)sub_1009F973C(a1);
  if (sub_1009FAAA0(v5) == a2)
  {
    uint64_t v6 = a1[1];
    if (!v6 || atomic_load_explicit((atomic_uint *volatile)(v6 + 8), memory_order_acquire) != 1) {
      operator new();
    }
    uint64_t v7 = (uint64_t *)sub_1009F973C(a1);
    uint64_t v8 = *(uint64_t **)(sub_1009FAAA0(v7) + 8);
    sub_1009F99A4(a1, v9, 0, &v8, 0);
  }
  sub_10000A6C8(*((pthread_mutex_t **)&v10 + 1));
  sub_10000A5F8(v9);
}

void sub_100A21238()
{
}

uint64_t sub_100A2128C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 304);
  if (v2)
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    sub_10000A4EC(v4, v2);
    sub_100060D70(*(atomic_uint ***)(a1 + 304), v4);
    (*(void (**)(void))(**((void **)&v5 + 1) + 32))(*((void *)&v5 + 1));
    sub_10000A5F8(v4);
  }
  sub_10006224C((void *)(a1 + 8));
  if (*(unsigned char *)a1) {
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_100A21360(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A21380(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t sub_100A213E4(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    int v3 = *(_DWORD *)(a1 + 16);
    if (*(_DWORD *)(v2 + 32) != v3)
    {
      *(_DWORD *)(v2 + 32) = v3;
      uint64_t v4 = *(void *)(v2 + 24);
      if (v4) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, v2 + 32);
      }
    }
  }
  return a1;
}

uint64_t sms::GSMModel::GSMModel(uint64_t a1, int a2, uint64_t *a3, long long *a4)
{
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 192), "com.apple.telephony", "msg.gsm.mdl");
  uint64_t v8 = *a3;
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  v12[0] = v8;
  v12[1] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sms::Model::Model(a1, a2, v12, 1, 0, 0);
    sub_10004D2C8(v9);
  }
  else
  {
    sms::Model::Model(a1, a2, v12, 1, 0, 0);
  }
  *(void *)a1 = off_101A2BE30;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 208), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    *(void *)(a1 + 224) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 208) = v10;
  }
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 232) = 9;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(void *)(a1 + 304) = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 376));
  *(void *)(a1 + 544) = 0;
  *(_OWORD *)(a1 + 528) = 0u;
  *(void *)(a1 + 549) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_WORD *)(a1 + 596) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  *(unsigned char *)(a1 + 200) = 1;
  *(unsigned char *)(a1 + 316) = 0;
  *(unsigned char *)(a1 + 340) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 348) = 0;
  *(_DWORD *)(a1 + 516) = 0;
  *(unsigned char *)(a1 + 520) = 0;
  *(unsigned char *)(a1 + 576) = 0;
  *(_DWORD *)(a1 + 580) = 0;
  *(void *)(a1 + 584) = 0;
  *(_DWORD *)(a1 + 312) = 4;
  return a1;
}

void sub_100A215F4(_Unwind_Exception *a1)
{
  sub_1009C456C(v1);
  ctu::OsLogLogger::~OsLogLogger(v2);
  _Unwind_Resume(a1);
}

uint64_t sms::GSMModel::GSMModel(uint64_t a1, uint64_t a2, uint64_t *a3, SmsPduDecoder **a4, int a5)
{
  long long v25 = (os_log_t *)(a1 + 192);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 192), "com.apple.telephony", "msg.gsm.mdl");
  uint64_t v10 = *a3;
  uint64_t v11 = (std::__shared_weak_count *)a3[1];
  v36[0] = v10;
  v36[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char isAlphanumericOriginator = SmsPduDecoder::isAlphanumericOriginator(*a4);
  sms::Model::Model(a1, a2, v36, 1, isAlphanumericOriginator, 0);
  if (v11) {
    sub_10004D2C8(v11);
  }
  *(void *)a1 = off_101A2BE30;
  *(unsigned char *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 232) = 8;
  SmsPduDecoder::getBody((uint64_t *)(a1 + 240), *a4);
  SmsPduDecoder::getUcs2Chars(*a4);
  SmsPduDecoder::getReplyAddress((uint64_t *)&cf.var0, *a4);
  CSIPhoneNumber::getFullNumber((uint64_t *)(a1 + 288), &cf);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v31) < 0) {
    operator delete((void *)v30);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(*(void **)&cf.var2.__r_.var0);
  }
  if (*((char *)&cf.var2.__r_.__value_.var0.var1 + 23) < 0) {
    operator delete(cf.var2.__r_.__value_.var0.var1.__data_);
  }
  *(unsigned char *)(a1 + 316) = SmsPduDecoder::isType0(*a4);
  *(_DWORD *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 340) = 0;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 326) = 0;
  *(_DWORD *)(a1 + 344) = SmsPduDecoder::getReplaceMessage(*a4);
  *(unsigned char *)(a1 + 349) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 352) = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 376));
  *(unsigned char *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 516) = 0;
  *(unsigned char *)(a1 + 520) = 0;
  SmsPduDecoder::getTimestamp(*a4);
  *(unsigned char *)(a1 + 576) = SmsPduDecoder::isConcatenated(*a4);
  *(_DWORD *)(a1 + 580) = SmsPduDecoder::concatenatedReference(*a4);
  *(_DWORD *)(a1 + 584) = SmsPduDecoder::concatenatedSequenceNumber(*a4);
  *(_DWORD *)(a1 + 588) = SmsPduDecoder::maxConcatenatedElements(*a4);
  *(_DWORD *)(a1 + 592) = SmsPduDecoder::getProtocolIdentifier(*a4);
  *(unsigned char *)(a1 + 596) = SmsPduDecoder::getDataCodingScheme(*a4);
  *(unsigned char *)(a1 + 597) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 648) = 0u;
  uint64_t SourcePort = SmsPduDecoder::getSourcePort(*a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, SourcePort);
  uint64_t DestinationPort = SmsPduDecoder::getDestinationPort(*a4);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 72))(a1, DestinationPort);
  *(_DWORD *)(a1 + 136) = SmsPduDecoder::getPartialSurrogates(*a4);
  unsigned int TextEncoding = SmsPduDecoder::getTextEncoding(*a4);
  if (TextEncoding < 4) {
    *(_DWORD *)(a1 + 232) = dword_101527B60[TextEncoding];
  }
  unsigned int Class = SmsPduDecoder::getClass(*a4);
  if (Class <= 4) {
    *(_DWORD *)(a1 + 312) = Class;
  }
  *(unsigned char *)(a1 + 512) = SmsPduDecoder::useOriginatingServiceCenter(*a4);
  SmsPduDecoder::getOriginatingServiceCenter((uint64_t *)&cf.var0, *a4);
  *(void *)(a1 + 376) = *(void *)&cf.var0;
  long long v17 = (void **)(a1 + 384);
  if (*(char *)(a1 + 407) < 0) {
    operator delete(*v17);
  }
  *(_OWORD *)long long v17 = *(_OWORD *)cf.var2.__r_.__value_.var0.var0.__data_;
  *(void *)(a1 + 400) = *((void *)&cf.var2.__r_.__value_.var0.var1 + 2);
  *((unsigned char *)&cf.var2.__r_.__value_.var0.var1 + 23) = 0;
  cf.var2.__r_.__value_.var0.var0.__data_[0] = 0;
  long long v18 = (void **)(a1 + 408);
  if (*(char *)(a1 + 431) < 0) {
    operator delete(*v18);
  }
  *(_OWORD *)long long v18 = *(_OWORD *)&cf.var2.__r_.var0;
  *(void *)(a1 + 424) = v27;
  HIBYTE(v27) = 0;
  LOBYTE(cf.var2.__r_.var0) = 0;
  *(_DWORD *)(a1 + 432) = v28;
  *(unsigned char *)(a1 + 436) = v29;
  long long v19 = (void **)(a1 + 440);
  if (*(char *)(a1 + 463) < 0) {
    operator delete(*v19);
  }
  *(_OWORD *)long long v19 = v30;
  *(void *)(a1 + 456) = v31;
  HIBYTE(v31) = 0;
  LOBYTE(v30) = 0;
  long long v20 = (_OWORD *)(a1 + 464);
  if (*(char *)(a1 + 487) < 0)
  {
    operator delete(*(void **)(a1 + 464));
    int v21 = SHIBYTE(v31);
    *long long v20 = *(_OWORD *)__p;
    *(void *)(a1 + 480) = v33;
    HIBYTE(v33) = 0;
    LOBYTE(__p[0]) = 0;
    *(_OWORD *)(a1 + 488) = v34;
    *(unsigned char *)(a1 + 504) = v35;
    if (v21 < 0) {
      operator delete((void *)v30);
    }
  }
  else
  {
    *long long v20 = *(_OWORD *)__p;
    *(void *)(a1 + 480) = v33;
    HIBYTE(v33) = 0;
    LOBYTE(__p[0]) = 0;
    *(unsigned char *)(a1 + 504) = v35;
    *(_OWORD *)(a1 + 488) = v34;
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(*(void **)&cf.var2.__r_.var0);
  }
  if ((*((char *)&cf.var2.__r_.__value_.var0.var1 + 23) & 0x80000000) == 0)
  {
    if (!a5) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  operator delete(cf.var2.__r_.__value_.var0.var1.__data_);
  if (a5) {
LABEL_31:
  }
    *(void *)(a1 + 36) = 0x200000002;
LABEL_32:
  *(unsigned char *)(a1 + 97) = SmsPduDecoder::isVoiceMailIndication(*a4);
  *(unsigned char *)(a1 + 98) = SmsPduDecoder::isVoiceMailWaiting(*a4);
  *(unsigned char *)(a1 + 99) = SmsPduDecoder::isVoiceMailCountAvailable(*a4);
  *(_DWORD *)(a1 + 100) = SmsPduDecoder::getVoiceMailCount(*a4);
  *(void *)&cf.var0 = 0;
  sms::Model::smsSettings(a2, (Registry **)(a1 + 16), &cf);
  v38[0] = *(const void **)&cf.var0;
  if (*(void *)&cf.var0) {
    CFRetain(*(CFTypeRef *)&cf.var0);
  }
  BOOL v22 = sub_1007CFFE8(v38, (unsigned __int8 *)(a1 + 288));
  sub_100057D78(v38);
  if (v22)
  {
    long long v23 = *v25;
    if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Terminal registration SMS detected", buf, 2u);
    }
    *(unsigned char *)(a1 + 32) = 1;
  }
  sub_100057D78((const void **)&cf);
  return a1;
}

void sub_100A21B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void **a11, uint64_t a12, ctu::OsLogLogger *a13, const void *a14)
{
  sub_100057D78((const void **)(v18 - 96));
  sub_100057D78(&a14);
  long long v20 = *(std::__shared_weak_count **)(v14 + 656);
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_100A26C04(v17);
  sub_100087E24(a12);
  int v21 = *(void **)(v14 + 352);
  if (v21)
  {
    *(void *)(v14 + 360) = v21;
    operator delete(v21);
  }
  if (*(char *)(v14 + 311) < 0) {
    operator delete(*v16);
  }
  if (*(char *)(v14 + 287) < 0) {
    operator delete(*a10);
  }
  if (*(char *)(v14 + 263) < 0) {
    operator delete(*a11);
  }
  if (*(char *)(v14 + 231) < 0) {
    operator delete(*v15);
  }
  sub_1009C456C(v14);
  ctu::OsLogLogger::~OsLogLogger(a13);
  _Unwind_Resume(a1);
}

uint64_t sms::GSMModel::GSMModel(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 192), "com.apple.telephony", "msg.gsm.mdl");
  uint64_t v8 = *a3;
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  v17[0] = v8;
  v17[1] = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sms::Model::Model(a1, a2, v17, 1, 0, 0);
    sub_10004D2C8(v9);
  }
  else
  {
    sms::Model::Model(a1, a2, v17, 1, 0, 0);
  }
  *(void *)a1 = off_101A2BE30;
  *(unsigned char *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 232) = 9;
  uint64_t v10 = *a4;
  if (*(char *)(*a4 + 111) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 240), *(void **)(v10 + 88), *(void *)(v10 + 96));
  }
  else
  {
    long long v11 = *(_OWORD *)(v10 + 88);
    *(void *)(a1 + 256) = *(void *)(v10 + 104);
    *(_OWORD *)(a1 + 240) = v11;
  }
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  sub_100058DB0((void *)(a1 + 288), "");
  *(unsigned char *)(a1 + 316) = 0;
  uint64_t v12 = *a4;
  *(_DWORD *)(a1 + 320) = *(_DWORD *)(*a4 + 72);
  *(void *)(a1 + 324) = *(void *)(v12 + 144);
  *(unsigned char *)(a1 + 332) = *(unsigned char *)(v12 + 140);
  *(unsigned char *)(a1 + 333) = *(unsigned char *)(v12 + 152);
  *(_DWORD *)(a1 + 336) = *(_DWORD *)(v12 + 68);
  *(unsigned char *)(a1 + 340) = 1;
  *(_DWORD *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 348) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 352) = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 376));
  *(void *)(a1 + 528) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 549) = 0;
  *(void *)(a1 + 568) = 0;
  *(void *)(a1 + 560) = 0;
  int v13 = *(_DWORD *)(*a4 + 80);
  *(unsigned char *)(a1 + 576) = (v13 & 0xE) != 0;
  *(_DWORD *)(a1 + 584) = v13 >> 4;
  *(_DWORD *)(a1 + 588) = v13 & 0xF;
  *(_WORD *)(a1 + 596) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  uint64_t v14 = a4[1];
  *(void *)(a1 + 648) = *a4;
  *(unsigned char *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 516) = 0;
  *(unsigned char *)(a1 + 520) = 0;
  *(void *)(a1 + 656) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(_DWORD *)(a1 + 232) == 1) {
    sub_10079694C(a2, (Registry **)(a1 + 16), (std::string *)(a1 + 240), 1);
  }
  unsigned int v15 = *(_DWORD *)(*a4 + 64);
  if (v15 <= 4) {
    *(_DWORD *)(a1 + 312) = v15;
  }
  CSIGetTime();
  return a1;
}

void sub_100A21EF0(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 231) < 0) {
    operator delete(*v3);
  }
  sub_1009C456C(v2);
  ctu::OsLogLogger::~OsLogLogger(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A21F98(uint64_t a1)
{
  *(void *)a1 = off_101A2BE30;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 656);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100A26C04(a1 + 600);
  if (*(char *)(a1 + 487) < 0) {
    operator delete(*(void **)(a1 + 464));
  }
  if (*(char *)(a1 + 463) < 0) {
    operator delete(*(void **)(a1 + 440));
  }
  if (*(char *)(a1 + 431) < 0) {
    operator delete(*(void **)(a1 + 408));
  }
  if (*(char *)(a1 + 407) < 0) {
    operator delete(*(void **)(a1 + 384));
  }
  int v3 = *(void **)(a1 + 352);
  if (v3)
  {
    *(void *)(a1 + 360) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 311) < 0) {
    operator delete(*(void **)(a1 + 288));
  }
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 231) < 0) {
    operator delete(*(void **)(a1 + 208));
  }
  sub_1009C456C(a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 192));
  return a1;
}

void sub_100A22090(uint64_t a1)
{
  sub_100A21F98(a1);

  operator delete();
}

void sub_100A220C8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 200)) {
      int v3 = "MO";
    }
    else {
      int v3 = "MT";
    }
    int v25 = 136315138;
    *(void *)&long long v26 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s SMS Message details:", (uint8_t *)&v25, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (*(unsigned char *)(a1 + 576))
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v25) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Message is concatenated", (uint8_t *)&v25, 2u);
      uint64_t v2 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 580);
      int v25 = 67109120;
      LODWORD(v26) = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Reference:\t\t%d", (uint8_t *)&v25, 8u);
      uint64_t v2 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 584);
      int v25 = 67109120;
      LODWORD(v26) = v5;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sequence Num:\t%d", (uint8_t *)&v25, 8u);
      uint64_t v2 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 588);
      int v25 = 67109120;
      LODWORD(v26) = v6;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Max Segments:\t%d", (uint8_t *)&v25, 8u);
      uint64_t v2 = *(NSObject **)(a1 + 192);
    }
  }
  if (*(unsigned char *)(a1 + 200)) {
    goto LABEL_52;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 448))(a1);
    int v25 = 67109120;
    LODWORD(v26) = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Message ID:    %d", (uint8_t *)&v25, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = (void *)(a1 + 288);
    if (*(char *)(a1 + 311) < 0) {
      uint64_t v8 = (void *)*v8;
    }
    int v25 = 136315138;
    *(void *)&long long v26 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sender:        %s", (uint8_t *)&v25, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(_DWORD *)(a1 + 548);
    int v10 = *(_DWORD *)(a1 + 544);
    int v11 = *(_DWORD *)(a1 + 540);
    int v12 = *(_DWORD *)(a1 + 528);
    int v13 = *(_DWORD *)(a1 + 532);
    int v14 = *(_DWORD *)(a1 + 536);
    int v15 = *(_DWORD *)(a1 + 552);
    if (*(unsigned char *)(a1 + 556)) {
      long long v16 = "yes";
    }
    else {
      long long v16 = "no";
    }
    int v25 = 67110914;
    LODWORD(v26) = v9;
    WORD2(v26) = 1024;
    *(_DWORD *)((char *)&v26 + 6) = v10;
    WORD5(v26) = 1024;
    HIDWORD(v26) = v11;
    __int16 v27 = 1024;
    int v28 = v12;
    __int16 v29 = 1024;
    int v30 = v13;
    __int16 v31 = 1024;
    int v32 = v14;
    __int16 v33 = 1024;
    int v34 = v15;
    __int16 v35 = 2080;
    long long v36 = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I MC Timestamp:  Y:%d M:%02d D:%02d @ %02d:%02d:%02d (Offset:%d, DST:%s)", (uint8_t *)&v25, 0x36u);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = CSIDateToSeconds();
    int v25 = 67109120;
    LODWORD(v26) = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I MC Timestamp:  %d", (uint8_t *)&v25, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    int v25 = 67109120;
    LODWORD(v26) = v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Source Port:   %d", (uint8_t *)&v25, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
    int v25 = 67109120;
    LODWORD(v26) = v19;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Dest Port:     %d", (uint8_t *)&v25, 8u);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (*(unsigned char *)(a1 + 200))
  {
LABEL_52:
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      long long v20 = (void *)(a1 + 160);
      if (*(char *)(a1 + 183) < 0) {
        long long v20 = (void *)*v20;
      }
      int v25 = 136315138;
      *(void *)&long long v26 = v20;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Destination:\t%s", (uint8_t *)&v25, 0xCu);
      uint64_t v2 = *(NSObject **)(a1 + 192);
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *(_DWORD *)(a1 + 516);
      int v25 = 67109120;
      LODWORD(v26) = v21;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Validity:\t\t%d", (uint8_t *)&v25, 8u);
      uint64_t v2 = *(NSObject **)(a1 + 192);
    }
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v22 = *(_DWORD *)(a1 + 232);
    if (v22 > 9) {
      long long v23 = "7bitASCII";
    }
    else {
      long long v23 = off_101A2C0E0[v22];
    }
    int v25 = 67109378;
    LODWORD(v26) = v22;
    WORD2(v26) = 2080;
    *(void *)((char *)&v26 + 6) = v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Msg Encoding:\t%d (%s)", (uint8_t *)&v25, 0x12u);
    uint64_t v2 = *(NSObject **)(a1 + 192);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 263) < 0) {
      uint64_t v24 = *(void *)(a1 + 248);
    }
    else {
      LODWORD(v24) = *(unsigned __int8 *)(a1 + 263);
    }
    int v25 = 67109120;
    LODWORD(v26) = v24;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Body Length:\t%d", (uint8_t *)&v25, 8u);
  }
}

uint64_t sub_100A226DC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 596);
}

void sub_100A226E4(uint64_t a1, const std::string *a2)
{
  int v4 = (void *)(a1 + 160);
  std::string::operator=((std::string *)(a1 + 160), a2);
  if (sms::Model::plusPrefixing(*(unsigned int *)(a1 + 8), (Registry **)(a1 + 16)))
  {
    uint64_t v7 = 0;
    sub_100B968D0(&buf);
  }
  int v5 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v6 = a2;
    }
    else {
      int v6 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if (*(char *)(a1 + 183) < 0) {
      int v4 = (void *)*v4;
    }
    int buf = 136315394;
    *(void *)buf_4 = v6;
    __int16 v10 = 2080;
    int v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Old Address %s Final address %s", (uint8_t *)&buf, 0x16u);
  }
}

void sub_100A238E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,const void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (*(char *)(v44 - 137) < 0) {
    operator delete(*(void **)(v44 - 160));
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  sub_1000558F4(&a36);
  _Unwind_Resume(a1);
}

uint64_t sub_100A239D4(uint64_t a1)
{
  return a1 + 160;
}

std::string *sub_100A239DC(uint64_t a1, const std::string *a2, int a3)
{
  uint64_t result = std::string::operator=((std::string *)(a1 + 240), a2);
  *(_DWORD *)(a1 + 232) = a3;
  return result;
}

std::string *sub_100A23A0C(std::string *a1, const std::string *a2)
{
  uint64_t result = std::string::operator=(a1 + 3, a2);
  a1[2].__r_.__value_.__s.__data_[16] = 1;
  return result;
}

uint64_t sub_100A23A3C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (a1 <= 8 && ((1 << a1) & 0x16C) != 0)
  {
    v10[0] = 0;
    v10[1] = 0;
    ctu::TextConverter::TextConverter((ctu::TextConverter *)v10);
    int v4 = *(char *)(a2 + 23);
    if (v4 >= 0) {
      int v5 = (const char *)a2;
    }
    else {
      int v5 = *(const char **)a2;
    }
    if (v4 >= 0) {
      unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      unint64_t v6 = *(void *)(a2 + 8);
    }
    ctu::TextConverter::setSource((ctu::TextConverter *)v10, v5, v6);
    ctu::TextConverter::pushConversion();
    getGsm7TableIndex();
    ctu::TextConverter::pushConversion();
    ctu::TextConverter::readChars((uint64_t *)&__p, (ctu::TextConverter *)v10, 0x7FFFFFFFuLL);
    if (v9 < 0) {
      operator delete(__p);
    }
    if (ctu::TextConverter::exceptionOccurred((ctu::TextConverter *)v10))
    {
      if (v2 == 2) {
        uint64_t v2 = 2;
      }
      else {
        uint64_t v2 = 1;
      }
    }
    else if (v2 == 8 || v2 == 2)
    {
      uint64_t v2 = 0;
    }
    ctu::TextConverter::~TextConverter((ctu::TextConverter *)v10);
  }
  return v2;
}

void sub_100A23B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A23B5C(sms::Model *a1)
{
  unsigned __int16 v1 = byte_101B0FCB2++;
  return sms::Model::setMessageID(a1, v1);
}

uint64_t sub_100A23B70(uint64_t a1)
{
  BOOL v1 = *(unsigned char *)(a1 + 597) || *(unsigned __int8 *)(a1 + 148) < 2u || *(_DWORD *)(a1 + 232) == 5;
  return sub_100A23BC0(a1) + v1;
}

uint64_t sub_100A23BC0(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 597);
  if (*(unsigned char *)(a1 + 597))
  {
    int v3 = (const char *)(a1 + 208);
    if (*(char *)(a1 + 231) < 0) {
      int v3 = *(const char **)v3;
    }
    if (*v3 == 43) {
      int v4 = v3 + 1;
    }
    else {
      int v4 = v3;
    }
    int v2 = ((strlen(v4) + 1) >> 1) + 4;
  }
  int v5 = v2 + 6;
  if (!*(unsigned char *)(a1 + 148)) {
    v2 += 4;
  }
  if (*(unsigned char *)(a1 + 148) == 1) {
    int v2 = v5;
  }
  if (*(_DWORD *)(a1 + 232) == 5) {
    int v6 = 3;
  }
  else {
    int v6 = 0;
  }
  return (v6 + v2);
}

uint64_t sub_100A23C48(uint64_t result, uint64_t a2)
{
  int v2 = (unsigned __int8 *)result;
  if (*(unsigned char *)(result + 597)) {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)a2 + 72))();
  }
  int v3 = v2[148];
  if (!v2[148])
  {
    (*(void (**)(unsigned __int8 *))(*(void *)v2 + 48))(v2);
    (*(void (**)(unsigned __int8 *))(*(void *)v2 + 64))(v2);
    uint64_t result = SmsPduEncoder::set8BitApplicationPortAddressing();
    int v3 = v2[148];
  }
  if (v3 == 1)
  {
    (*(void (**)(unsigned __int8 *))(*(void *)v2 + 48))(v2);
    (*(void (**)(unsigned __int8 *))(*(void *)v2 + 64))(v2);
    return SmsPduEncoder::set16BitApplicationPortAddressing();
  }
  return result;
}

uint64_t sub_100A23D84@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 16));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int buf = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    __int16 v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v13 = 0;
      if (!v11) {
        goto LABEL_7;
      }
LABEL_11:
      long long v16 = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(v2 + 16));
      int v17 = v16;
      if (v18 < 0)
      {
        int v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v20 = 5381;
        do
        {
          uint64_t v18 = v20;
          unsigned int v21 = *v19++;
          uint64_t v20 = (33 * v20) ^ v21;
        }
        while (v21);
      }
      std::mutex::lock(v16);
      *(void *)int buf = v18;
      unsigned int v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)buf);
      if (v22)
      {
        uint64_t v24 = v22[3];
        long long v23 = (std::__shared_weak_count *)v22[4];
        if (v23)
        {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v17);
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v23);
          char v25 = 0;
          if (!v24) {
            goto LABEL_17;
          }
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v24 = 0;
      }
      std::mutex::unlock(v17);
      long long v23 = 0;
      char v25 = 1;
      if (!v24)
      {
LABEL_17:
        uint64_t v2 = *(void *)(v2 + 192);
        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int buf = 0;
          int v15 = 2;
          _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v2, OS_LOG_TYPE_ERROR, "Failed to get Personality Shop.", buf, 2u);
        }
        else
        {
          int v15 = 2;
        }
        if (v25) {
          goto LABEL_38;
        }
        goto LABEL_37;
      }
LABEL_23:
      *(void *)int buf = 0;
      int v32 = 0;
      (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v24 + 8))(buf, v24, *(unsigned int *)(v2 + 8));
      if (*(void *)buf)
      {
        *(void *)int v30 = 0;
        (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v11 + 24))(v29, v11, *(void *)buf + 24, @"TPMR", @"SMSControllerWalletDomain", 0, 1);
        sub_1000842D0(v30, v29);
        sub_1000577C4(v29);
        if (*(void *)v30) {
          __int16 v27 = sub_100081E58;
        }
        else {
          __int16 v27 = 0;
        }
        if (v27)
        {
          LOBYTE(v29[0]) = 0;
          ctu::cf::assign((ctu::cf *)v29, *(unsigned __int8 **)v30, v26);
          LOBYTE(v2) = v29[0];
          int v15 = 1;
        }
        else
        {
          uint64_t v2 = *(void *)(v2 + 192);
          if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v29[0]) = 0;
            int v15 = 2;
            _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v2, OS_LOG_TYPE_ERROR, "Failed to read TPMR value", (uint8_t *)v29, 2u);
          }
          else
          {
            int v15 = 2;
          }
        }
        sub_1000570E8((const void **)v30);
      }
      else
      {
        uint64_t v2 = *(void *)(v2 + 192);
        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)int v30 = 0;
          int v15 = 2;
          _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)v2, OS_LOG_TYPE_ERROR, "Failed to get Personality Info.", v30, 2u);
        }
        else
        {
          int v15 = 2;
        }
      }
      if (v32) {
        sub_10004D2C8(v32);
      }
      if (v25)
      {
LABEL_38:
        if (v13) {
          goto LABEL_40;
        }
        goto LABEL_39;
      }
LABEL_37:
      sub_10004D2C8(v23);
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  __int16 v10 = 0;
  char v13 = 1;
  if (v11) {
    goto LABEL_11;
  }
LABEL_7:
  int v14 = *(NSObject **)(v2 + 192);
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    int v15 = 2;
    goto LABEL_38;
  }
  *(_WORD *)int buf = 0;
  int v15 = 2;
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get Personal Wallet.", buf, 2u);
  if (v13) {
    goto LABEL_41;
  }
LABEL_39:
  sub_10004D2C8(v10);
LABEL_40:
  if (v15 == 2) {
LABEL_41:
  }
    LOBYTE(v2) = 0;
  return v2;
}

void sub_100A24148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  sub_1000570E8(&a11);
  if (a14)
  {
    sub_10004D2C8(a14);
    if (v16)
    {
LABEL_3:
      if (v17) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (v16)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v15);
  if (v17) {
LABEL_5:
  }
    _Unwind_Resume(a1);
LABEL_4:
  sub_10004D2C8(v14);
  goto LABEL_5;
}

void sub_100A241B8()
{
  if (v0) {
    JUMPOUT(0x100A24184);
  }
  JUMPOUT(0x100A2417CLL);
}

uint64_t sub_100A241C4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(_DWORD *)(a1 + 36) != 2 || *(_DWORD *)(a1 + 40) != 2)
    {
      int v3 = (std::__shared_weak_count *)operator new(0x190uLL);
      v3->__shared_owners_ = 0;
      v3->__shared_weak_owners_ = 0;
      v3->__vftable = (std::__shared_weak_count_vtbl *)off_101A2C0A0;
      int v4 = (char *)&v3[1];
      SmsPduEncoder::SmsPduEncoder((SmsPduEncoder *)&v3[1], 0);
      (*(void (**)(char *, uint64_t))(*(void *)v4 + 16))(v4, a1 + 376);
      (*(void (**)(char *, uint64_t))(*(void *)v4 + 40))(v4, a1 + 72);
LABEL_48:
      memset(buf, 0, sizeof(buf));
      ((void (*)(void **__return_ptr, char *, uint8_t *))v3[1].__vftable[1].~__shared_weak_count_0)(v90, v4, buf);
      if ((char)buf[31] < 0) {
        operator delete(*(void **)&buf[8]);
      }
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)v90;
      *(void *)&unsigned char buf[24] = v91;
      sub_100A256BC((void *)(a1 + 600), (uint64_t)buf);
      if ((char)buf[31] < 0) {
        operator delete(*(void **)&buf[8]);
      }
      sub_10004D2C8(v3);
      return 0;
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 352))(a1);
    char v2 = *(unsigned char *)(a1 + 54);
    int v3 = (std::__shared_weak_count *)operator new(0x190uLL);
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3->__vftable = (std::__shared_weak_count_vtbl *)off_101A2C050;
    int v4 = (char *)&v3[1];
    SmsPduEncoder::SmsPduEncoder((SmsPduEncoder *)&v3[1], v2);
    v3[1].__vftable = (std::__shared_weak_count_vtbl *)&off_101A90CB0;
    LOBYTE(v3[16].__vftable) = 0;
    SmsPduEncoder::setServiceCenter((SmsPduEncoder *)&v3[1], (const CSIPhoneNumber *)(a1 + 376));
    int v5 = *(char *)(a1 + 95);
    if (v5 < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 72), *(void *)(a1 + 80));
      int v5 = *(char *)(a1 + 95);
      if (v5 < 0)
      {
        uint64_t v31 = *(void *)(a1 + 80);
        goto LABEL_45;
      }
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 72);
      uint64_t v93 = *(void *)(a1 + 88);
    }
    uint64_t v31 = v5;
LABEL_45:
    (*(void (**)(char *, void **, uint64_t))(*(void *)v4 + 152))(v4, __p, v31);
    if (SHIBYTE(v93) < 0) {
      operator delete(__p[0]);
    }
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
    goto LABEL_48;
  }
  *(unsigned char *)(a1 + 349) = 0;
  int v6 = *(void ***)(a1 + 608);
  uint64_t v7 = *(void ***)(a1 + 616);
  if (v7 == v6)
  {
    int v12 = (void *)(a1 + 640);
    uint64_t v7 = *(void ***)(a1 + 608);
  }
  else
  {
    unint64_t v8 = *(void *)(a1 + 632);
    char v9 = &v6[v8 >> 7];
    uint64_t v10 = (uint64_t)*v9;
    uint64_t v11 = (uint64_t)*v9 + 32 * (v8 & 0x7F);
    int v12 = (void *)(a1 + 640);
    uint64_t v13 = *(uint64_t *)((char *)v6 + (((*(void *)(a1 + 640) + v8) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((*(void *)(a1 + 640) + v8) & 0x7F);
    if (v11 != v13)
    {
      do
      {
        if (*(char *)(v11 + 31) < 0)
        {
          operator delete(*(void **)(v11 + 8));
          uint64_t v10 = (uint64_t)*v9;
        }
        v11 += 32;
        if (v11 - v10 == 4096)
        {
          uint64_t v14 = (uint64_t)v9[1];
          ++v9;
          uint64_t v10 = v14;
          uint64_t v11 = v14;
        }
      }
      while (v11 != v13);
      uint64_t v7 = *(void ***)(a1 + 616);
      int v6 = *(void ***)(a1 + 608);
    }
  }
  *int v12 = 0;
  unint64_t v15 = (char *)v7 - (char *)v6;
  if ((unint64_t)((char *)v7 - (char *)v6) >= 0x11)
  {
    do
    {
      operator delete(*v6);
      int v6 = (void **)(*(void *)(a1 + 608) + 8);
      *(void *)(a1 + 608) = v6;
      unint64_t v15 = *(void *)(a1 + 616) - (void)v6;
    }
    while (v15 > 0x10);
  }
  if (v15 >> 3 == 1)
  {
    uint64_t v16 = 64;
    goto LABEL_22;
  }
  if (v15 >> 3 == 2)
  {
    uint64_t v16 = 128;
LABEL_22:
    *(void *)(a1 + 632) = v16;
  }
  *(_OWORD *)v90 = 0u;
  long long v91 = 0u;
  v89 = (std::string *)(a1 + 240);
  int v17 = sub_100A23A3C(*(unsigned int *)(a1 + 232), a1 + 240);
  *(_DWORD *)(a1 + 232) = v17;
  unsigned int v18 = sub_100A23B70(a1);
  if (v18 <= 0x8C) {
    CFIndex v19 = 140 - v18;
  }
  else {
    CFIndex v19 = 0;
  }
  if (v18 > 0x8B)
  {
    uint64_t v20 = 0;
    goto LABEL_28;
  }
  unsigned int v22 = sub_100A23BC0(a1);
  if (v22 <= 0x86) {
    CFIndex v23 = 134 - v22;
  }
  else {
    CFIndex v23 = 0;
  }
  if (v17 == 5) {
    int v24 = 131;
  }
  else {
    int v24 = 134;
  }
  int v88 = v24;
  unsigned int v25 = v22;
  switch(v17)
  {
    case 0:
    case 3:
    case 5:
    case 6:
      CFNumberRef v26 = (const char *)(a1 + 240);
      if (*(char *)(a1 + 263) < 0) {
        CFNumberRef v26 = (const char *)v89->__r_.__value_.__r.__words[0];
      }
      BOOL v27 = sub_100A25BDC(a1, v26, v19);
      if (v27)
      {
        int v28 = (const char *)(a1 + 240);
        if (*(char *)(a1 + 263) < 0) {
          int v28 = (const char *)v89->__r_.__value_.__r.__words[0];
        }
        if (v25 <= 0x85)
        {
          unsigned int v39 = *(_DWORD *)(a1 + 232);
          if (v39 > 6 || ((1 << v39) & 0x69) == 0) {
            __TUAssertTrigger();
          }
          memset(buf, 0, 24);
          usedBufLen[0] = 0;
          usedBufLen[1] = 0;
          ctu::TextConverter::TextConverter((ctu::TextConverter *)usedBufLen);
          size_t v40 = strlen(v28);
          ctu::TextConverter::setSource((ctu::TextConverter *)usedBufLen, v28, v40);
          ctu::TextConverter::pushConversion();
          getGsm7TableIndex();
          int v41 = 0;
          CFIndex v42 = 0;
          while (1)
          {
            Sourceint Count = ctu::TextConverter::getSourceCount((ctu::TextConverter *)usedBufLen);
            if (ctu::TextConverter::nextCode((ctu::TextConverter *)usedBufLen) == -1) {
              break;
            }
            int Gsm7EncodedSize = ctu::TextConverter::getGsm7EncodedSize();
            int v45 = v41 + Gsm7EncodedSize + 13;
            if (v41 + Gsm7EncodedSize + 6 >= 0) {
              int v45 = v41 + Gsm7EncodedSize + 6;
            }
            if ((int)v23 < v45 >> 3)
            {
              CFIndex v23 = SourceCount;
              CFIndex v46 = SourceCount - v42;
              uint64_t v47 = *(char **)&buf[8];
              if (*(void *)&buf[8] >= *(void *)&buf[16])
              {
                uint64_t v49 = *(char **)buf;
                uint64_t v50 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
                unint64_t v51 = v50 + 1;
                if ((unint64_t)(v50 + 1) >> 61) {
                  sub_10006A748();
                }
                uint64_t v52 = *(void *)&buf[16] - *(void *)buf;
                if ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 2 > v51) {
                  unint64_t v51 = v52 >> 2;
                }
                if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v53 = v51;
                }
                if (v53)
                {
                  uint64_t v54 = (char *)sub_10004EF74((uint64_t)&buf[16], v53);
                  uint64_t v49 = *(char **)buf;
                  uint64_t v47 = *(char **)&buf[8];
                }
                else
                {
                  uint64_t v54 = 0;
                }
                uint64_t v55 = &v54[8 * v50];
                *(void *)uint64_t v55 = v46;
                unint64_t v48 = v55 + 8;
                while (v47 != v49)
                {
                  uint64_t v56 = *((void *)v47 - 1);
                  v47 -= 8;
                  *((void *)v55 - 1) = v56;
                  v55 -= 8;
                }
                *(void *)int buf = v55;
                *(void *)&uint8_t buf[8] = v48;
                *(void *)&uint8_t buf[16] = &v54[8 * v53];
                if (v49) {
                  operator delete(v49);
                }
              }
              else
              {
                **(void **)&uint8_t buf[8] = v46;
                unint64_t v48 = v47 + 8;
              }
              int v41 = 0;
              *(void *)&uint8_t buf[8] = v48;
              CFIndex v42 = v23;
              LODWORD(v23) = v88;
            }
            v41 += Gsm7EncodedSize;
          }
          if (ctu::TextConverter::getSourceCount((ctu::TextConverter *)usedBufLen))
          {
            CFIndex v57 = (int)ctu::TextConverter::getSourceCount((ctu::TextConverter *)usedBufLen) - v42;
            uint64_t v58 = *(char **)&buf[8];
            if (*(void *)&buf[8] >= *(void *)&buf[16])
            {
              __int16 v64 = *(char **)buf;
              uint64_t v65 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
              unint64_t v66 = v65 + 1;
              if ((unint64_t)(v65 + 1) >> 61) {
                sub_10006A748();
              }
              uint64_t v67 = *(void *)&buf[16] - *(void *)buf;
              if ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 2 > v66) {
                unint64_t v66 = v67 >> 2;
              }
              if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v68 = v66;
              }
              if (v68)
              {
                uint64_t v69 = (char *)sub_10004EF74((uint64_t)&buf[16], v68);
                __int16 v64 = *(char **)buf;
                uint64_t v58 = *(char **)&buf[8];
              }
              else
              {
                uint64_t v69 = 0;
              }
              v81 = &v69[8 * v65];
              CFNumberRef v82 = &v69[8 * v68];
              *(void *)v81 = v57;
              uint64_t v59 = v81 + 8;
              while (v58 != v64)
              {
                uint64_t v83 = *((void *)v58 - 1);
                v58 -= 8;
                *((void *)v81 - 1) = v83;
                v81 -= 8;
              }
              *(void *)int buf = v81;
              *(void *)&uint8_t buf[8] = v59;
              *(void *)&uint8_t buf[16] = v82;
              if (v64) {
                operator delete(v64);
              }
            }
            else
            {
              **(void **)&uint8_t buf[8] = v57;
              uint64_t v59 = v58 + 8;
            }
            *(void *)&uint8_t buf[8] = v59;
          }
          ctu::TextConverter::~TextConverter((ctu::TextConverter *)usedBufLen);
          int v30 = *(unsigned char **)buf;
          __int16 v29 = *(unsigned char **)&buf[8];
        }
        else
        {
          __int16 v29 = 0;
          int v30 = 0;
        }
      }
      else
      {
        int v30 = 0;
        __int16 v29 = 0;
      }
      unsigned int v84 = *(NSObject **)(a1 + 192);
      if (!os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_148;
      }
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v85 = *(void *)(a1 + 248);
      }
      else {
        LODWORD(v85) = *(unsigned __int8 *)(a1 + 263);
      }
      *(_DWORD *)int buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v85;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = (unint64_t)(v29 - v30) >> 3;
      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I sending Gsm7 SMS of body (length %d) in %d segments", buf, 0xEu);
      __int16 v60 = (unsigned char *)(a1 + 576);
      *(unsigned char *)(a1 + 576) = v27;
      if (!v27) {
        goto LABEL_157;
      }
      goto LABEL_149;
    case 1:
      sub_10079694C(*(unsigned int *)(a1 + 8), (Registry **)(a1 + 16), v89, 0);
      if (*(char *)(a1 + 263) < 0)
      {
        long long v38 = *(ctu::TextConverter **)(a1 + 240);
        long long v37 = *(const char **)(a1 + 248);
      }
      else
      {
        long long v37 = (const char *)*(unsigned __int8 *)(a1 + 263);
        long long v38 = (ctu::TextConverter *)(a1 + 240);
      }
      unint64_t v61 = ctu::TextConverter::countCharactersInUtf8Message(v38, v37, v36);
      unint64_t v62 = v19 >> 1;
      BOOL v27 = v61 > v62;
      if (v61 > v62)
      {
        int v63 = (const char *)(a1 + 240);
        if (*(char *)(a1 + 263) < 0) {
          int v63 = (const char *)v89->__r_.__value_.__r.__words[0];
        }
        if (v25 <= 0x85)
        {
          sub_100796070(v63, v23, v88, 2, (char **)buf);
          int v30 = *(unsigned char **)buf;
          __int16 v29 = *(unsigned char **)&buf[8];
        }
        else
        {
          __int16 v29 = 0;
          int v30 = 0;
        }
      }
      else
      {
        int v30 = 0;
        __int16 v29 = 0;
      }
      uint64_t v70 = *(NSObject **)(a1 + 192);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 263) < 0) {
          uint64_t v71 = *(void *)(a1 + 248);
        }
        else {
          LODWORD(v71) = *(unsigned __int8 *)(a1 + 263);
        }
        *(_DWORD *)int buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v71;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = (unint64_t)(v29 - v30) >> 3;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "#I sending Ucs2 SMS of body (length %d) in %d segments", buf, 0xEu);
        __int16 v60 = (unsigned char *)(a1 + 576);
        *(unsigned char *)(a1 + 576) = v61 > v62;
        if (v61 <= v62)
        {
LABEL_157:
          if (*(_DWORD *)(a1 + 36) == 2 && *(_DWORD *)(a1 + 40) == 2)
          {
            uint64_t v86 = *(NSObject **)(a1 + 192);
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I encoder: ImsSmsPduEncoder", buf, 2u);
            }
            operator new();
          }
          operator new();
        }
      }
      else
      {
LABEL_148:
        __int16 v60 = (unsigned char *)(a1 + 576);
        *(unsigned char *)(a1 + 576) = v27;
        if (!v27) {
          goto LABEL_157;
        }
      }
LABEL_149:
      if (v29 != v30)
      {
        if (*(_DWORD *)(a1 + 36) == 2 && *(_DWORD *)(a1 + 40) == 2) {
          operator new();
        }
        operator new();
      }
      uint64_t v20 = v29;
      if (!*v60 || *(void *)(a1 + 640))
      {
        uint64_t v21 = 0;
        goto LABEL_166;
      }
LABEL_28:
      uint64_t v21 = 3;
LABEL_166:
      if (SHIBYTE(v91) < 0) {
        operator delete(v90[1]);
      }
      if (v20) {
        operator delete(v20);
      }
      return v21;
    case 2:
      int v32 = (const char *)(a1 + 240);
      if (*(char *)(a1 + 263) < 0) {
        int v32 = (const char *)v89->__r_.__value_.__r.__words[0];
      }
      CFStringRef v33 = CFStringCreateWithCString(kCFAllocatorDefault, v32, 0x8000100u);
      usedBufLen[0] = 0;
      if (!v33) {
        goto LABEL_128;
      }
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v34 = *(void *)(a1 + 248);
      }
      else {
        uint64_t v34 = *(unsigned __int8 *)(a1 + 263);
      }
      v72 = (UInt8 *)CFAllocatorAllocate(kCFAllocatorDefault, v34 + 1, 0);
      CFIndex Length = CFStringGetLength(v33);
      if (v72)
      {
        v74.length = Length;
        if (*(char *)(a1 + 263) < 0) {
          CFIndex v75 = *(void *)(a1 + 248);
        }
        else {
          CFIndex v75 = *(unsigned __int8 *)(a1 + 263);
        }
        v74.location = 0;
        CFStringGetBytes(v33, v74, 0x422u, 0x3Fu, 0, v72, v75, usedBufLen);
        v72[usedBufLen[0]] = 0;
      }
      if (usedBufLen[0] <= 0)
      {
LABEL_128:
        *(unsigned char *)(a1 + 349) = 1;
        v78 = *(NSObject **)(a1 + 192);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I error sending KSC-5601 SMS (conversion failed)", buf, 2u);
        }
        if (v33) {
          CFRelease(v33);
        }
        uint64_t v20 = 0;
        uint64_t v21 = 4;
        goto LABEL_166;
      }
      sub_10003ED78(v89, (char *)v72);
      CFIndex v76 = usedBufLen[0];
      if (usedBufLen[0] <= v19)
      {
        v77 = 0;
        __int16 v29 = 0;
      }
      else
      {
        sub_100A25CF4((char **)buf, v33, v23, v88);
        v77 = *(unsigned char **)buf;
        __int16 v29 = *(unsigned char **)&buf[8];
      }
      char v79 = *(NSObject **)(a1 + 192);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 263) < 0) {
          uint64_t v80 = *(void *)(a1 + 248);
        }
        else {
          LODWORD(v80) = *(unsigned __int8 *)(a1 + 263);
        }
        *(_DWORD *)int buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v80;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = (unint64_t)(v29 - v77) >> 3;
        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I sending KSC-5601 SMS of body (length %d) in %d segments", buf, 0xEu);
      }
      CFRelease(v33);
      CFAllocatorDeallocate(kCFAllocatorDefault, v72);
      __int16 v60 = (unsigned char *)(a1 + 576);
      *(unsigned char *)(a1 + 576) = v76 > v19;
      int v30 = v77;
      if (v76 <= v19) {
        goto LABEL_157;
      }
      goto LABEL_149;
    case 4:
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v35 = *(void *)(a1 + 248);
      }
      else {
        LODWORD(v35) = *(unsigned __int8 *)(a1 + 263);
      }
      if ((int)v19 >= (int)v35) {
        goto LABEL_95;
      }
      sub_100A25EE0((char **)buf, *(void *)(a1 + 248), *(unsigned char *)(a1 + 263), v23, v88);
      int v30 = *(unsigned char **)buf;
      __int16 v29 = *(unsigned char **)&buf[8];
      __int16 v60 = (unsigned char *)(a1 + 576);
      *(unsigned char *)(a1 + 576) = 1;
      goto LABEL_149;
    default:
LABEL_95:
      *(unsigned char *)(a1 + 576) = 0;
      goto LABEL_157;
  }
}

void sub_100A254EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100A256BC(void *a1, uint64_t a2)
{
  int v4 = (char *)a1[1];
  int v5 = (char *)a1[2];
  uint64_t v6 = v5 - v4;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 16 * (v5 - v4) - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 != v9) {
    goto LABEL_37;
  }
  if (v8 < 0x80)
  {
    uint64_t v23 = v6 >> 3;
    int v24 = (char *)a1[3];
    unsigned int v25 = (char *)*a1;
    uint64_t v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 >= (unint64_t)(v26 >> 3))
    {
      uint64_t v29 = v26 >> 2;
      if (v24 == v25) {
        unint64_t v30 = 1;
      }
      else {
        unint64_t v30 = v29;
      }
      uint64_t v31 = (char *)sub_100048350(v30);
      uint64_t v33 = v32;
      uint64_t v34 = operator new(0x1000uLL);
      uint64_t v35 = &v31[8 * v23];
      unint64_t v36 = &v31[8 * v33];
      if (v23 == v33)
      {
        uint64_t v37 = 8 * v23;
        if (v6 < 1)
        {
          CFIndex v75 = v34;
          uint64_t v76 = v37 >> 2;
          if (v5 == v4) {
            unint64_t v77 = 1;
          }
          else {
            unint64_t v77 = v76;
          }
          v78 = (char *)sub_100048350(v77);
          uint64_t v35 = &v78[8 * (v77 >> 2)];
          unint64_t v36 = &v78[8 * v79];
          if (v31) {
            operator delete(v31);
          }
          uint64_t v31 = v78;
          uint64_t v34 = v75;
        }
        else
        {
          uint64_t v38 = v37 >> 3;
          if (v38 >= -1) {
            unint64_t v39 = v38 + 1;
          }
          else {
            unint64_t v39 = v38 + 2;
          }
          v35 -= 8 * (v39 >> 1);
        }
      }
      *(void *)uint64_t v35 = v34;
      uint64_t v80 = v35 + 8;
      for (uint64_t i = a1[2]; i != a1[1]; i -= 8)
      {
        if (v35 == v31)
        {
          if (v80 >= v36)
          {
            if (v36 == v31) {
              unint64_t v86 = 1;
            }
            else {
              unint64_t v86 = (v36 - v31) >> 2;
            }
            unsigned __int8 v87 = (char *)sub_100048350(v86);
            v89 = v87;
            uint64_t v35 = &v87[(2 * v86 + 6) & 0xFFFFFFFFFFFFFFF8];
            uint64_t v91 = v80 - v31;
            BOOL v90 = v80 == v31;
            uint64_t v80 = v35;
            if (!v90)
            {
              uint64_t v80 = &v35[v91 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v92 = 8 * (v91 >> 3);
              uint64_t v93 = v35;
              uint64_t v94 = (uint64_t *)v31;
              do
              {
                uint64_t v95 = *v94++;
                *(void *)uint64_t v93 = v95;
                v93 += 8;
                v92 -= 8;
              }
              while (v92);
            }
            unint64_t v36 = &v87[8 * v88];
            if (v31) {
              operator delete(v31);
            }
            uint64_t v31 = v89;
          }
          else
          {
            uint64_t v82 = (v36 - v80) >> 3;
            if (v82 >= -1) {
              uint64_t v83 = v82 + 1;
            }
            else {
              uint64_t v83 = v82 + 2;
            }
            uint64_t v84 = v83 >> 1;
            uint64_t v35 = &v31[8 * (v83 >> 1)];
            uint64_t v85 = v31;
            if (v80 != v31)
            {
              memmove(v35, v31, v80 - v31);
              uint64_t v85 = v80;
            }
            uint64_t v80 = &v85[8 * v84];
          }
        }
        uint64_t v96 = *(void *)(i - 8);
        *((void *)v35 - 1) = v96;
        v35 -= 8;
      }
      v97 = (char *)*a1;
      *a1 = v31;
      a1[1] = v35;
      a1[2] = v80;
      a1[3] = v36;
      if (v97) {
        operator delete(v97);
      }
      goto LABEL_36;
    }
    BOOL v27 = operator new(0x1000uLL);
    int v28 = v27;
    if (v24 == v5)
    {
      if (v4 == v25)
      {
        if (v5 == v4) {
          unint64_t v53 = 1;
        }
        else {
          unint64_t v53 = (v24 - v4) >> 2;
        }
        uint64_t v54 = 2 * v53;
        uint64_t v55 = (char *)sub_100048350(v53);
        int v4 = &v55[(v54 + 6) & 0xFFFFFFFFFFFFFFF8];
        CFIndex v57 = (uint64_t *)a1[1];
        uint64_t v58 = v4;
        uint64_t v59 = a1[2] - (void)v57;
        if (v59)
        {
          uint64_t v58 = &v4[v59 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v60 = 8 * (v59 >> 3);
          unint64_t v61 = &v55[(v54 + 6) & 0xFFFFFFFFFFFFFFF8];
          do
          {
            uint64_t v62 = *v57++;
            *(void *)unint64_t v61 = v62;
            v61 += 8;
            v60 -= 8;
          }
          while (v60);
        }
        int v63 = (char *)*a1;
        *a1 = v55;
        a1[1] = v4;
        a1[2] = v58;
        a1[3] = &v55[8 * v56];
        if (v63)
        {
          operator delete(v63);
          int v4 = (char *)a1[1];
        }
      }
      *((void *)v4 - 1) = v28;
      __int16 v64 = (char *)a1[1];
      uint64_t v65 = (char *)a1[2];
      a1[1] = v64 - 8;
      uint64_t v66 = *((void *)v64 - 1);
      a1[1] = v64;
      if (v65 == (char *)a1[3])
      {
        uint64_t v67 = (uint64_t)&v64[-*a1];
        if ((unint64_t)v64 <= *a1)
        {
          if (v65 == (char *)*a1) {
            unint64_t v98 = 1;
          }
          else {
            unint64_t v98 = (uint64_t)&v65[-*a1] >> 2;
          }
          v99 = (char *)sub_100048350(v98);
          v101 = &v99[8 * (v98 >> 2)];
          v102 = (uint64_t *)a1[1];
          uint64_t v65 = v101;
          uint64_t v103 = a1[2] - (void)v102;
          if (v103)
          {
            uint64_t v65 = &v101[v103 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v104 = 8 * (v103 >> 3);
            v105 = &v99[8 * (v98 >> 2)];
            do
            {
              uint64_t v106 = *v102++;
              *(void *)v105 = v106;
              v105 += 8;
              v104 -= 8;
            }
            while (v104);
          }
          v107 = (char *)*a1;
          *a1 = v99;
          a1[1] = v101;
          a1[2] = v65;
          a1[3] = &v99[8 * v100];
          if (v107)
          {
            operator delete(v107);
            uint64_t v65 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v68 = v67 >> 3;
          BOOL v15 = v67 >> 3 < -1;
          uint64_t v69 = (v67 >> 3) + 2;
          if (v15) {
            uint64_t v70 = v69;
          }
          else {
            uint64_t v70 = v68 + 1;
          }
          uint64_t v71 = -(v70 >> 1);
          uint64_t v72 = v70 >> 1;
          uint64_t v73 = &v64[-8 * v72];
          int64_t v74 = v65 - v64;
          if (v65 != v64)
          {
            memmove(&v64[-8 * v72], v64, v65 - v64);
            __int16 v64 = (char *)a1[1];
          }
          uint64_t v65 = &v73[v74];
          a1[1] = &v64[8 * v71];
          a1[2] = &v73[v74];
        }
      }
      *(void *)uint64_t v65 = v66;
    }
    else
    {
      *(void *)int v5 = v27;
    }
  }
  else
  {
    a1[4] = v8 - 128;
    uint64_t v12 = *(void *)v4;
    uint64_t v10 = v4 + 8;
    uint64_t v11 = v12;
    a1[1] = v10;
    if (v5 == (char *)a1[3])
    {
      uint64_t v13 = (uint64_t)&v10[-*a1];
      if ((unint64_t)v10 <= *a1)
      {
        if (v5 == (char *)*a1) {
          unint64_t v40 = 1;
        }
        else {
          unint64_t v40 = (uint64_t)&v5[-*a1] >> 2;
        }
        int v41 = (char *)sub_100048350(v40);
        long long v43 = &v41[8 * (v40 >> 2)];
        uint64_t v44 = (uint64_t *)a1[1];
        int v5 = v43;
        uint64_t v45 = a1[2] - (void)v44;
        if (v45)
        {
          int v5 = &v43[v45 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v46 = 8 * (v45 >> 3);
          uint64_t v47 = &v41[8 * (v40 >> 2)];
          do
          {
            uint64_t v48 = *v44++;
            *(void *)uint64_t v47 = v48;
            v47 += 8;
            v46 -= 8;
          }
          while (v46);
        }
        uint64_t v49 = (char *)*a1;
        *a1 = v41;
        a1[1] = v43;
        a1[2] = v5;
        a1[3] = &v41[8 * v42];
        if (v49)
        {
          operator delete(v49);
          int v5 = (char *)a1[2];
        }
      }
      else
      {
        uint64_t v14 = v13 >> 3;
        BOOL v15 = v13 >> 3 < -1;
        uint64_t v16 = (v13 >> 3) + 2;
        if (v15) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v14 + 1;
        }
        uint64_t v18 = -(v17 >> 1);
        uint64_t v19 = v17 >> 1;
        uint64_t v20 = &v10[-8 * v19];
        int64_t v21 = v5 - v10;
        if (v5 != v10)
        {
          memmove(&v10[-8 * v19], v10, v5 - v10);
          int v5 = (char *)a1[1];
        }
        unsigned int v22 = &v5[8 * v18];
        int v5 = &v20[v21];
        a1[1] = v22;
        a1[2] = &v20[v21];
      }
    }
    *(void *)int v5 = v11;
  }
  a1[2] += 8;
LABEL_36:
  int v4 = (char *)a1[1];
  unint64_t v9 = a1[5] + a1[4];
LABEL_37:
  uint64_t v50 = (_DWORD *)(*(void *)&v4[(v9 >> 4) & 0xFFFFFFFFFFFFFF8] + 32 * (v9 & 0x7F));
  _DWORD *v50 = *(_DWORD *)a2;
  uint64_t result = v50 + 2;
  if (*(char *)(a2 + 31) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v52 = *(_OWORD *)(a2 + 8);
    result[2] = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t result = v52;
  }
  ++a1[5];
  return result;
}

void sub_100A25BB0(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100A25BDC(uint64_t a1, const char *a2, int a3)
{
  unsigned int v5 = *(_DWORD *)(a1 + 232);
  BOOL v6 = v5 > 6;
  int v7 = (1 << v5) & 0x69;
  if (v6 || v7 == 0) {
    __TUAssertTrigger();
  }
  v14[0] = 0;
  v14[1] = 0;
  ctu::TextConverter::TextConverter((ctu::TextConverter *)v14);
  size_t v9 = strlen(a2);
  ctu::TextConverter::setSource((ctu::TextConverter *)v14, a2, v9);
  ctu::TextConverter::pushConversion();
  getGsm7TableIndex();
  int v10 = 0;
  do
  {
    int Code = ctu::TextConverter::nextCode((ctu::TextConverter *)v14);
    if (Code == -1) {
      break;
    }
    v10 += ctu::TextConverter::getGsm7EncodedSize();
    int v12 = v10 + 6;
    if (v10 < -6) {
      int v12 = v10 + 13;
    }
  }
  while (a3 >= v12 >> 3);
  ctu::TextConverter::~TextConverter((ctu::TextConverter *)v14);
  return Code != -1;
}

void sub_100A25CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100A25CF4(char **a1, const __CFString *a2, CFIndex size, unsigned int a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if ((int)size >= 1)
  {
    unsigned int v5 = size;
    unint64_t v8 = (UInt8 *)CFAllocatorAllocate(kCFAllocatorDefault, size, 0);
    if (v8)
    {
      size_t v9 = v8;
      CFIndex Length = CFStringGetLength(a2);
      CFIndex usedBufLen = 0;
      if (Length >= 1)
      {
        CFIndex v11 = Length;
        CFIndex v12 = 0;
        do
        {
          v29.length = v11 - v12;
          CFIndex v13 = v5;
          v29.location = v12;
          CFIndex Bytes = CFStringGetBytes(a2, v29, 0x422u, 0x3Fu, 0, v9, v5, &usedBufLen);
          if (usedBufLen <= v13) {
            int v15 = usedBufLen;
          }
          else {
            int v15 = v13 - 1;
          }
          uint64_t v16 = v15;
          uint64_t v18 = a1[1];
          unint64_t v17 = (unint64_t)a1[2];
          if ((unint64_t)v18 >= v17)
          {
            uint64_t v20 = *a1;
            uint64_t v21 = (v18 - *a1) >> 3;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 61) {
              sub_10006A748();
            }
            uint64_t v23 = v17 - (void)v20;
            if (v23 >> 2 > v22) {
              unint64_t v22 = v23 >> 2;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24)
            {
              unsigned int v25 = (char *)sub_10004EF74((uint64_t)(a1 + 2), v24);
              uint64_t v20 = *a1;
              uint64_t v18 = a1[1];
            }
            else
            {
              unsigned int v25 = 0;
            }
            uint64_t v26 = &v25[8 * v21];
            *(void *)uint64_t v26 = v16;
            uint64_t v19 = v26 + 8;
            while (v18 != v20)
            {
              uint64_t v27 = *((void *)v18 - 1);
              v18 -= 8;
              *((void *)v26 - 1) = v27;
              v26 -= 8;
            }
            *a1 = v26;
            a1[1] = v19;
            a1[2] = &v25[8 * v24];
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            *(void *)uint64_t v18 = v16;
            uint64_t v19 = v18 + 8;
          }
          a1[1] = v19;
          v12 += Bytes;
          unsigned int v5 = a4;
        }
        while (v12 < v11);
      }
      CFAllocatorDeallocate(kCFAllocatorDefault, v9);
    }
  }
}

void sub_100A25EB8(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A25EE0(char **a1, unint64_t a2, unsigned __int8 a3, int a4, unsigned int a5)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a4 >= 1)
  {
    if ((a3 & 0x80u) == 0) {
      a2 = a3;
    }
    if (a2)
    {
      int v7 = 0;
      unint64_t v8 = a1 + 2;
      unint64_t v9 = a4;
      unint64_t v10 = a5;
      do
      {
        if (a2 <= v9) {
          unint64_t v11 = a2;
        }
        else {
          unint64_t v11 = v9 - 1;
        }
        if ((unint64_t)v7 >= *v8)
        {
          CFIndex v13 = *a1;
          uint64_t v14 = (v7 - *a1) >> 3;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61) {
            sub_10006A748();
          }
          uint64_t v16 = *v8 - (void)v13;
          if (v16 >> 2 > v15) {
            unint64_t v15 = v16 >> 2;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17)
          {
            uint64_t v18 = (char *)sub_10004EF74((uint64_t)v8, v17);
            CFIndex v13 = *a1;
            int v7 = a1[1];
          }
          else
          {
            uint64_t v18 = 0;
          }
          uint64_t v19 = &v18[8 * v14];
          *(void *)uint64_t v19 = (int)v11;
          CFIndex v12 = v19 + 8;
          while (v7 != v13)
          {
            uint64_t v20 = *((void *)v7 - 1);
            v7 -= 8;
            *((void *)v19 - 1) = v20;
            v19 -= 8;
          }
          *a1 = v19;
          a1[1] = v12;
          a1[2] = &v18[8 * v17];
          if (v13) {
            operator delete(v13);
          }
        }
        else
        {
          *(void *)int v7 = (int)v11;
          CFIndex v12 = v7 + 8;
        }
        a1[1] = v12;
        int v7 = v12;
        unint64_t v9 = v10;
        a2 -= v11;
      }
      while (a2);
    }
  }
}

void sub_100A26024(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A26044(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1[80])
  {
    memset(&v13[2], 0, 32);
    uint64_t v3 = *(void *)(a1[76] + ((a1[79] >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (a1[79] & 0x7FLL);
    LODWORD(v13[2]) = *(_DWORD *)v3;
    int v4 = (void **)(v3 + 8);
    if (*(char *)(v3 + 31) < 0)
    {
      sub_10004FC84(&v13[3], *v4, *(void *)(v3 + 16));
    }
    else
    {
      long long v5 = *(_OWORD *)v4;
      v13[5] = *(void *)(v3 + 24);
      *(_OWORD *)&v13[3] = v5;
    }
    v13[0] = 0;
    v13[1] = 0;
    ctu::TextConverter::TextConverter((ctu::TextConverter *)v13);
    if (v13[5] >= 0) {
      BOOL v6 = (const char *)&v13[3];
    }
    else {
      BOOL v6 = (const char *)v13[3];
    }
    if (v13[5] >= 0) {
      unint64_t v7 = HIBYTE(v13[5]);
    }
    else {
      unint64_t v7 = v13[4];
    }
    ctu::TextConverter::setSource((ctu::TextConverter *)v13, v6, v7);
    ctu::TextConverter::pushConversion();
    long long __p = 0;
    unint64_t v11 = 0;
    uint64_t v12 = 0;
    ctu::TextConverter::readChars((uint64_t *)&__p, (ctu::TextConverter *)v13, 0x7FFFFFFFuLL);
    if (v12 >= 0) {
      p_p = (char *)&__p;
    }
    else {
      p_p = (char *)__p;
    }
    if (v12 >= 0) {
      unint64_t v9 = HIBYTE(v12);
    }
    else {
      unint64_t v9 = v11;
    }
    sub_10075526C(a2, p_p, &p_p[v9], v9);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p);
    }
    ctu::TextConverter::~TextConverter((ctu::TextConverter *)v13);
    if (SHIBYTE(v13[5]) < 0) {
      operator delete((void *)v13[3]);
    }
  }
}

void sub_100A2618C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  uint64_t v26 = *(void **)v24;
  if (*(void *)v24)
  {
    *(void *)(v24 + 8) = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A261EC(uint64_t a1)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1))
  {
    unint64_t v2 = *(void *)(a1 + 632);
    uint64_t v3 = *(void *)(*(void *)(a1 + 608) + ((v2 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v2 & 0x7F);
    if (*(char *)(v3 + 31) < 0)
    {
      operator delete(*(void **)(v3 + 8));
      unint64_t v2 = *(void *)(a1 + 632);
    }
    --*(void *)(a1 + 640);
    unint64_t v4 = v2 + 1;
    *(void *)(a1 + 632) = v4;
    if (v4 >= 0x100)
    {
      operator delete(**(void ***)(a1 + 608));
      *(void *)(a1 + 608) += 8;
      *(void *)(a1 + 632) -= 128;
    }
  }
}

uint64_t sub_100A262A4(uint64_t a1)
{
  return *(void *)(a1 + 640);
}

void *sub_100A262AC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_100448664(a2, *(const void **)(a1 + 352), *(void *)(a1 + 360), (uint64_t)(*(void *)(a1 + 360) - *(void *)(a1 + 352)) >> 2);
}

__n128 sub_100A262C8(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (__n128 *)(a1 + 376);
  *(void *)(a1 + 376) = *(void *)a2;
  std::string::operator=((std::string *)(a1 + 384), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 408), (const std::string *)(a2 + 32));
  char v5 = *(unsigned char *)(a2 + 60);
  *(_DWORD *)(a1 + 432) = *(_DWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 436) = v5;
  std::string::operator=((std::string *)(a1 + 440), (const std::string *)(a2 + 64));
  std::string::operator=((std::string *)(a1 + 464), (const std::string *)(a2 + 88));
  char v6 = *(unsigned char *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 112);
  v4[7] = result;
  *(unsigned char *)(a1 + 504) = v6;
  return result;
}

uint64_t sub_100A2634C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 520)) {
    return *(unsigned int *)(a1 + 516);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100A26364(uint64_t result, int a2)
{
  *(_DWORD *)(result + 516) = a2;
  *(unsigned char *)(result + 520) = 1;
  return result;
}

char *sub_100A26374@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[263] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 30), *((void *)result + 31));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 15);
  *(void *)(a2 + 16) = *((void *)result + 32);
  return result;
}

char *sub_100A263A0@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[287] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 33), *((void *)result + 34));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 264);
  *(void *)(a2 + 16) = *((void *)result + 35);
  return result;
}

uint64_t sub_100A263CC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 232);
}

void sub_100A263D4(uint64_t a1, int *a2, int *a3)
{
  char v6 = (ctu::TextConverter *)(a1 + 240);
  *(_DWORD *)(a1 + 232) = sub_100A23A3C(*(unsigned int *)(a1 + 232), a1 + 240);
  int v7 = sub_100A23B70(a1);
  signed int v9 = sub_100795578((Registry **)(a1 + 16), *(unsigned int *)(a1 + 8));
  unsigned int v10 = *(_DWORD *)(a1 + 232);
  if (v10 <= 6)
  {
    if (((1 << v10) & 0x69) != 0)
    {
      getGsm7TableIndex();
      *a2 = ctu::TextConverter::countSeptetsInMessage();
      *a3 = 8 * (((18725 * (__int16)(140 - v7)) >> 17) + ((18725 * (__int16)(140 - v7)) >> 31));
      if (!v9)
      {
LABEL_25:
        BOOL v14 = 1;
        goto LABEL_26;
      }
      signed int v9 = ((double)(8 * (v9 - v7)) / 7.0);
    }
    else if (v10 == 1)
    {
      if (*(char *)(a1 + 263) < 0)
      {
        char v6 = *(ctu::TextConverter **)(a1 + 240);
        unint64_t v15 = *(const char **)(a1 + 248);
      }
      else
      {
        unint64_t v15 = (const char *)*(unsigned __int8 *)(a1 + 263);
      }
      *a2 = ctu::TextConverter::countCharactersInUtf8Message(v6, v15, v8);
      *a3 = (int)((140 - v7 + (((140 - v7) & 0x8000u) >> 15)) << 16) >> 17;
      if (!v9) {
        goto LABEL_25;
      }
      signed int v9 = (v9 - v7) >> 1;
    }
    else if (v10 == 2)
    {
      if (*(char *)(a1 + 263) < 0) {
        char v6 = *(ctu::TextConverter **)v6;
      }
      CFStringRef v11 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v6, 0x8000100u);
      *(void *)int buf = 0;
      if (v11)
      {
        CFStringRef v12 = v11;
        if (*(char *)(a1 + 263) < 0) {
          uint64_t v13 = *(void *)(a1 + 248);
        }
        else {
          uint64_t v13 = *(unsigned __int8 *)(a1 + 263);
        }
        uint64_t v20 = (UInt8 *)CFAllocatorAllocate(kCFAllocatorDefault, v13 + 1, 0);
        CFIndex Length = CFStringGetLength(v12);
        if (v20)
        {
          v22.length = Length;
          if (*(char *)(a1 + 263) < 0) {
            CFIndex v23 = *(void *)(a1 + 248);
          }
          else {
            CFIndex v23 = *(unsigned __int8 *)(a1 + 263);
          }
          v22.location = 0;
          CFStringGetBytes(v12, v22, 0x422u, 0x3Fu, 0, v20, v23, (CFIndex *)buf);
          uint64_t v24 = *(void *)buf;
          v20[*(void *)buf] = 0;
          if (v24 < 0)
          {
            LODWORD(v24) = 0;
            *(void *)int buf = 0;
          }
        }
        else
        {
          LODWORD(v24) = 0;
        }
        *a2 = v24;
        *a3 = 140 - v7;
        if (v9) {
          v9 -= v7;
        }
        else {
          signed int v9 = 0;
        }
        CFRelease(v12);
        if (v20) {
          CFAllocatorDeallocate(kCFAllocatorDefault, v20);
        }
      }
      else
      {
        *a2 = 0;
        *a3 = 140 - v7;
        if (v9) {
          v9 -= v7;
        }
        else {
          signed int v9 = 0;
        }
      }
    }
  }
  BOOL v14 = a3 != 0;
  if (a3 && v9)
  {
    if (*a3 > v9) {
      *a3 = v9;
    }
    goto LABEL_25;
  }
LABEL_26:
  int v16 = *a2;
  if (*a2 < 0)
  {
    int v16 = 0;
    *a2 = 0;
    if (!v14) {
      return;
    }
  }
  else if (!v14)
  {
    return;
  }
  unint64_t v17 = *(NSObject **)(a1 + 192);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = *a3;
    int v19 = *(_DWORD *)(a1 + 232);
    *(_DWORD *)int buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v16;
    __int16 v26 = 1024;
    int v27 = v18;
    __int16 v28 = 1024;
    int v29 = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Message size: %d split threshold: %d for encoding: %d", buf, 0x14u);
  }
}

BOOL sub_100A2671C(uint64_t a1, int a2)
{
  int v4 = sub_100A23B70(a1);
  char v5 = (ctu::TextConverter *)(a1 + 240);
  unsigned int v6 = sub_100A23A3C(*(unsigned int *)(a1 + 232), a1 + 240);
  BOOL v8 = 0;
  *(_DWORD *)(a1 + 232) = v6;
  if (v6 > 6) {
    return v8;
  }
  if (((1 << v6) & 0x69) == 0)
  {
    if (v6 == 1)
    {
      if (*(char *)(a1 + 263) < 0)
      {
        char v5 = *(ctu::TextConverter **)(a1 + 240);
        CFStringRef v11 = *(const char **)(a1 + 248);
      }
      else
      {
        CFStringRef v11 = (const char *)*(unsigned __int8 *)(a1 + 263);
      }
      return a2 - v4 < 2 * ctu::TextConverter::countCharactersInUtf8Message(v5, v11, v7);
    }
    else if (v6 == 2)
    {
      if (*(char *)(a1 + 263) < 0)
      {
        char v5 = *(ctu::TextConverter **)(a1 + 240);
        CFIndex v10 = *(void *)(a1 + 248);
      }
      else
      {
        CFIndex v10 = *(unsigned __int8 *)(a1 + 263);
      }
      CFStringRef v12 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)v5, v10, 0x8000100u, 0);
      CFIndex usedBufLen = 0;
      if (v12)
      {
        CFStringRef v13 = v12;
        if (*(char *)(a1 + 263) < 0) {
          uint64_t v14 = *(void *)(a1 + 248);
        }
        else {
          uint64_t v14 = *(unsigned __int8 *)(a1 + 263);
        }
        unint64_t v15 = (UInt8 *)CFAllocatorAllocate(kCFAllocatorDefault, v14 + 1, 0);
        CFIndex Length = CFStringGetLength(v13);
        if (v15)
        {
          v17.length = Length;
          if (*(char *)(a1 + 263) < 0) {
            CFIndex v18 = *(void *)(a1 + 248);
          }
          else {
            CFIndex v18 = *(unsigned __int8 *)(a1 + 263);
          }
          v17.location = 0;
          CFStringGetBytes(v13, v17, 0x422u, 0x3Fu, 0, v15, v18, &usedBufLen);
          CFIndex v19 = usedBufLen;
          v15[usedBufLen] = 0;
          if (v19 < 0)
          {
            LODWORD(v19) = 0;
            CFIndex usedBufLen = 0;
          }
          BOOL v8 = a2 - v4 < v19;
          CFRelease(v13);
          CFAllocatorDeallocate(kCFAllocatorDefault, v15);
          return v8;
        }
        CFRelease(v13);
      }
      return 0;
    }
    return v8;
  }
  if (*(char *)(a1 + 263) < 0) {
    char v5 = *(ctu::TextConverter **)v5;
  }

  return sub_100A25BDC(a1, (const char *)v5, a2 - v4);
}

uint64_t sub_100A26918(uint64_t a1)
{
  return *(unsigned int *)(a1 + 312);
}

BOOL sub_100A26920(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 232))(a1) == 0;
}

uint64_t sub_100A26960(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 316);
}

uint64_t sub_100A26968(uint64_t a1)
{
  return *(unsigned int *)(a1 + 344);
}

uint64_t sub_100A26970(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 512);
}

uint64_t sub_100A26978@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_10009DB3C(a2, a1 + 376);
}

__n128 sub_100A26984@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)(a1 + 544);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 528);
  *(_OWORD *)(a2 + 16) = v2;
  __n128 result = *(__n128 *)(a1 + 560);
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t sub_100A26998(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 576);
}

BOOL sub_100A269A0(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4 = *(unsigned __int8 *)(a1 + 576);
  if (*(unsigned char *)(a1 + 576))
  {
    *a2 = *(_DWORD *)(a1 + 580);
    *a3 = *(_DWORD *)(a1 + 584) - 1;
    *a4 = *(_DWORD *)(a1 + 588);
  }
  return v4 != 0;
}

uint64_t sub_100A269D0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 592);
}

uint64_t sub_100A269D8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36) == 2 && *(_DWORD *)(a1 + 40) == 2) {
    return *(unsigned __int16 *)(a1 + 52);
  }
  else {
    return 0;
  }
}

uint64_t sub_100A26A00(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 200)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 340)) {
    return 2;
  }
  return 1;
}

void *sub_100A26A24@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  if (*((unsigned char *)result + 200))
  {
    if ((*((char *)result + 183) & 0x80000000) == 0)
    {
      long long v2 = (char *)(result + 20);
LABEL_6:
      *(_OWORD *)a2 = *(_OWORD *)v2;
      *(void *)(a2 + 16) = *((void *)v2 + 2);
      return result;
    }
    uint64_t v3 = (void *)result[20];
    unint64_t v4 = result[21];
  }
  else
  {
    if ((*((char *)result + 311) & 0x80000000) == 0)
    {
      long long v2 = (char *)(result + 36);
      goto LABEL_6;
    }
    uint64_t v3 = (void *)result[36];
    unint64_t v4 = result[37];
  }
  return sub_10004FC84((unsigned char *)a2, v3, v4);
}

std::string *sub_100A26A70(std::string *result, char *a2)
{
  if (!result[8].__r_.__value_.__s.__data_[8]) {
    return sub_10003ED78(result + 12, a2);
  }
  return result;
}

uint64_t sub_100A26A84(uint64_t a1)
{
  return *(unsigned int *)(a1 + 320);
}

uint64_t sub_100A26A8C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 324);
}

uint64_t sub_100A26A94(uint64_t a1)
{
  return *(unsigned int *)(a1 + 328);
}

uint64_t sub_100A26A9C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 332);
}

uint64_t sub_100A26AA4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 333);
}

uint64_t sub_100A26AAC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 336);
}

uint64_t sub_100A26AB4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 656);
  *a2 = *(void *)(result + 648);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A26AD4()
{
  return 0;
}

uint64_t sub_100A26ADC(uint64_t a1)
{
  if (!*(void *)(a1 + 648)) {
    return 25;
  }
  char v10 = 15;
  if (ctu::TextConverter::decodeCbsDataCodingScheme())
  {
    if ((unint64_t)v10 <= 0x24) {
      return dword_101527AC8[v10];
    }
    return 25;
  }
  uint64_t v3 = *(void *)(a1 + 648);
  if (*(char *)(v3 + 135) < 0)
  {
    sub_10004FC84(__p, *(void **)(v3 + 112), *(void *)(v3 + 120));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(v3 + 112);
    uint64_t v9 = *(void *)(v3 + 128);
  }
  if (SHIBYTE(v9) < 0)
  {
    char v5 = __p[1];
    operator delete(__p[0]);
    if (!v5) {
      return 25;
    }
  }
  else if (!HIBYTE(v9))
  {
    return 25;
  }
  uint64_t v4 = *(void *)(a1 + 648);
  if (*(char *)(v4 + 135) < 0)
  {
    sub_10004FC84(__p, *(void **)(v4 + 112), *(void *)(v4 + 120));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(v4 + 112);
    uint64_t v9 = *(void *)(v4 + 128);
  }
  if (v9 >= 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = (void **)__p[0];
  }
  uint64_t BroadcastLanguageFromLocale = getBroadcastLanguageFromLocale((const char *)v7);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  return BroadcastLanguageFromLocale;
}

void sub_100A26BE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A26C04(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    unsigned int v6 = &v2[v5 >> 7];
    uint64_t v7 = (uint64_t)*v6;
    uint64_t v8 = (uint64_t)*v6 + 32 * (v5 & 0x7F);
    uint64_t v9 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 4) & 0xFFFFFFFFFFFFFF8))
       + 32 * ((*(void *)(a1 + 40) + v5) & 0x7F);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 31) < 0)
        {
          operator delete(*(void **)(v8 + 8));
          uint64_t v7 = (uint64_t)*v6;
        }
        v8 += 32;
        if (v8 - v7 == 4096)
        {
          uint64_t v10 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v10;
          uint64_t v8 = v10;
        }
      }
      while (v8 != v9);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 64;
    goto LABEL_16;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 128;
LABEL_16:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100A26D68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A2C050;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A26D88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A2C050;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A26DDC(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100A26E04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A2C0A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A26E24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A2C0A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A26E78(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100A26EA0()
{
}

void sub_100A26EB4(uint64_t a1, uint64_t a2)
{
  sub_100068A94(&v3);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)v3 + 144))(v3, a2, 0);
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100A26F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

id sub_100A26F38()
{
  id v0 = +[CTCellularPlanServer sharedServerInstance];

  return [v0 sendPlanInfoDidUpdateNotification];
}

id sub_100A26F68(uint64_t a1, uint64_t a2)
{
  id v3 = +[CTCellularPlanServer sharedServerInstance];

  return [v3 sendLocalPlanInfoDidUpdateNotification:a2];
}

id sub_100A26FA8()
{
  id v0 = +[CTCellularPlanServer sharedServerInstance];

  return [v0 sendPendingTransferPlanInfoDidUpdateNotification];
}

id sub_100A26FD8()
{
  id v0 = +[CTCellularPlanServer sharedServerInstance];

  return [v0 sendCarrierInfoDidUpdateNotification];
}

id sub_100A27008()
{
  id v0 = +[CTCellularPlanServer sharedServerInstance];

  return [v0 sendRemoteProvisioningDidBecomeAvailable];
}

void *sub_100A27038(void *a1)
{
  *a1 = off_101A2C140;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  id v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100A27094(void *a1)
{
  sub_100A27038(a1);

  operator delete();
}

void sub_100A270CC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 8));
  unint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v14);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  unint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 24))(v12, a2);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100A271E4(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

std::__shared_weak_count *sub_100A27200@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  __n128 result = *(std::__shared_weak_count **)(a1 + 32);
  if (result)
  {
    __n128 result = std::__shared_weak_count::lock(result);
    a2[1] = result;
    if (result) {
      *a2 = *(void *)(a1 + 24);
    }
  }
  return result;
}

void sub_100A27244()
{
}

void sub_100A272E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void *sub_100A2731C(void *a1, NSObject **a2)
{
  *a1 = off_1019DB040;
  id v3 = a1 + 1;
  uint64_t v4 = *a2;
  dispatch_object_t object = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "dese.bb");
  sub_100A27444(v3, "TelephonyBasebandController", QOS_CLASS_UTILITY, &object, &v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  if (object) {
    dispatch_release(object);
  }
  *a1 = off_101A2C1C0;
  a1[6] = TelephonyBasebandCreateController();
  return a1;
}

void sub_100A27400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v12 + 40));
  sub_100087E88(v13);
  _Unwind_Resume(a1);
}

void *sub_100A27444(void *a1, const char *a2, dispatch_qos_class_t qos_class, NSObject **a4, const OsLogContext *a5)
{
  unsigned int v9 = *a4;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  sub_100104718(a1, a2, qos_class, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v11, a5);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v11);
  return a1;
}

void sub_100A274D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a9);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_100A2750C(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A275EC(unint64_t a1, unsigned int a2, const void *a3)
{
  OsLogContext v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_100A2798C(&v6, a3, (uint64_t)a3 + 16 * a2, a2);
  v5[0] = a1;
  v5[1] = 0uLL;
  sub_100A2798C((void *)v5 + 1, v6, v7, (v7 - (uint64_t)v6) >> 4);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A27728(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A27744(unint64_t a1, unsigned int a2, const void *a3)
{
  OsLogContext v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_100A2798C(&v6, a3, (uint64_t)a3 + 16 * a2, a2);
  v5[0] = a1;
  v5[1] = 0uLL;
  sub_100A2798C((void *)v5 + 1, v6, v7, (v7 - (uint64_t)v6) >> 4);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A27880(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A2789C(uint64_t a1)
{
  *(void *)a1 = off_101A2C1C0;
  int v2 = (ctu::OsLogLogger *)(a1 + 40);
  sub_100A27A30((const void **)(a1 + 48));
  ctu::OsLogLogger::~OsLogLogger(v2);
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A27904(uint64_t a1)
{
  *(void *)a1 = off_101A2C1C0;
  int v2 = (ctu::OsLogLogger *)(a1 + 40);
  sub_100A27A30((const void **)(a1 + 48));
  ctu::OsLogLogger::~OsLogLogger(v2);
  sub_100087E88((void *)(a1 + 8));

  operator delete();
}

void *sub_100A2798C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v5 = result;
    if (a4 >> 60) {
      sub_10006A748();
    }
    __n128 result = operator new(16 * a4);
    uint64_t v8 = result;
    void *v5 = result;
    v5[1] = result;
    _OWORD v5[2] = &result[2 * a4];
    size_t v9 = a3 - (void)a2;
    if (v9) {
      __n128 result = memcpy(result, a2, v9);
    }
    v5[1] = (char *)v8 + v9;
  }
  return result;
}

void sub_100A27A14(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100A27A30(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_100A27A64(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A27AE4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A27B20(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A27B58(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A27B88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A27BCC(uint64_t **a1)
{
  id v3 = a1;
  uint64_t v1 = **a1;
  if ((TelephonyBasebandClearFreqList() & 1) == 0)
  {
    int v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#N Clear Frequency List Failed", buf, 2u);
    }
  }
  operator delete();
}

void sub_100A27C64()
{
}

uint64_t *sub_100A27C90(void **a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  OsLogContext v6 = v1;
  uint64_t v2 = *v1;
  if ((TelephonyBasebandAddFreqList() & 1) == 0)
  {
    id v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Add Frequency List Failed", buf, 2u);
    }
  }
  sub_100A27D40((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100A27D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100A27D40(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(void **)(v1 + 8);
    if (v2)
    {
      *(void *)(v1 + 16) = v2;
      operator delete(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100A27D98(void **a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  OsLogContext v6 = v1;
  uint64_t v2 = *v1;
  if ((TelephonyBasebandRemoveFreqList() & 1) == 0)
  {
    id v3 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#N Remove Frequency List Failed", buf, 2u);
    }
  }
  sub_100A27D40((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100A27E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_100A27E48(char *a1)
{
  uint64_t v11 = a1;
  if (!a1) {
    return &unk_101641437;
  }
  sub_100A27F94();
  uint64_t v2 = sub_100A28080((uint64_t)&qword_101B13E58, &v11);
  sub_100A27F94();
  if ((_UNKNOWN *)v2 != &unk_101B13E60) {
    return *(void **)(v2 + 40);
  }
  if (!strncmp("com.apple.", a1, 0xAuLL))
  {
    uint64_t v10 = a1 + 10;
    sub_100A27F94();
    uint64_t v2 = sub_100A28080((uint64_t)&qword_101B13E58, &v10);
    sub_100A27F94();
    if ((_UNKNOWN *)v2 != &unk_101B13E60) {
      return *(void **)(v2 + 40);
    }
  }
  sub_100A27F94();
  uint64_t v4 = qword_101B13E58;
  if ((_UNKNOWN *)qword_101B13E58 == &unk_101B13E60) {
    return &unk_101641437;
  }
  size_t v5 = strlen(a1);
  id v3 = &unk_101641437;
  while (strncmp(*(const char **)(v4 + 32), a1, v5))
  {
    OsLogContext v6 = *(void **)(v4 + 8);
    if (v6)
    {
      do
      {
        uint64_t v7 = v6;
        OsLogContext v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        uint64_t v7 = *(void **)(v4 + 16);
        BOOL v8 = *v7 == v4;
        uint64_t v4 = (uint64_t)v7;
      }
      while (!v8);
    }
    uint64_t v4 = (uint64_t)v7;
    if (v7 == (void *)&unk_101B13E60) {
      return v3;
    }
  }
  return *(void **)(v4 + 40);
}

uint64_t *sub_100A27F94()
{
  __chkstk_darwin();
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13E70, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13E70))
  {
    memcpy(__dst, off_101A2C310, sizeof(__dst));
    v1[0] = __dst;
    v1[1] = 396;
    sub_100A282E8((uint64_t **)&qword_101B13E58, (uint64_t)v1);
    __cxa_guard_release(&qword_101B13E70);
  }
  return &qword_101B13E58;
}

void sub_100A28068(_Unwind_Exception *a1)
{
}

uint64_t sub_100A28080(uint64_t a1, char **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    int v6 = sub_100A28504((char **)(v3 + 32), a2);
    uint64_t v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      uint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || sub_100A28470(a2, (char **)(v5 + 32))) {
    return v2;
  }
  return v5;
}

void sub_100A280FC(void **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (void *)*((unsigned __int8 *)a1 + 23);
  if ((char)v3 < 0) {
    uint64_t v3 = a1[1];
  }
  if (!v3
    || ((sub_100A281F8(), *((char *)a1 + 23) >= 0) ? (uint64_t v5 = a1) : (uint64_t v5 = *a1),
        __p[0] = v5,
        uint64_t v6 = sub_100A28080((uint64_t)&unk_101B13E78, (char **)__p),
        sub_100A281F8(),
        (_UNKNOWN *)v6 == &unk_101B13E80))
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v11 = 0;
    uint64_t v7 = (char *)sub_100A27E48(*(char **)(v6 + 40));
    sub_100058DB0(__p, v7);
    BOOL v8 = (void *)HIBYTE(v11);
    int v9 = SHIBYTE(v11);
    if (v11 < 0) {
      BOOL v8 = __p[1];
    }
    if (v8)
    {
      *(_OWORD *)a2 = *(_OWORD *)__p;
      *(void *)(a2 + 16) = v11;
      *(unsigned char *)(a2 + 24) = 1;
    }
    else
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      if (v9 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void *sub_100A281F8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B13E90, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B13E90))
  {
    v2[0] = "com.apple.iCloudDriveApp";
    v2[1] = "bird";
    void v2[2] = "com.apple.CTCarrierSpaceAuth";
    v2[3] = "CommCenter";
    v2[4] = "com.apple.datausage.telephony.ims";
    v2[5] = "CommCenter";
    v1[0] = v2;
    v1[1] = 3;
    sub_100A282E8((uint64_t **)&unk_101B13E78, (uint64_t)v1);
    __cxa_guard_release(&qword_101B13E90);
  }
  return &unk_101B13E78;
}

void sub_100A282D0(_Unwind_Exception *a1)
{
}

uint64_t **sub_100A282E8(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *(char ***)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  a1[1] = 0;
  uint64_t v5 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (v3)
  {
    uint64_t v6 = &v4[2 * v3];
    while (1)
    {
      uint64_t v7 = a1[1];
      if (*a1 == v5) {
        break;
      }
      BOOL v8 = v5;
      if (v7)
      {
        do
        {
          int v9 = v7;
          uint64_t v7 = (uint64_t *)v7[1];
        }
        while (v7);
      }
      else
      {
        do
        {
          int v9 = (uint64_t *)v8[2];
          BOOL v10 = *v9 == (void)v8;
          BOOL v8 = v9;
        }
        while (v10);
      }
      int v11 = sub_100A28504((char **)v9 + 4, v4);
      uint64_t v7 = (uint64_t *)*v5;
      if (v11) {
        goto LABEL_18;
      }
      uint64_t v12 = v5;
      char v13 = v5;
      if (!v7) {
        goto LABEL_21;
      }
      char v13 = v5;
      while (1)
      {
        while (1)
        {
          uint64_t v12 = v7;
          unint64_t v14 = (char **)(v7 + 4);
          if (!sub_100A28470(v4, (char **)v7 + 4)) {
            break;
          }
          uint64_t v7 = (uint64_t *)*v12;
          char v13 = v12;
          if (!*v12) {
            goto LABEL_21;
          }
        }
        if (!sub_100A28504(v14, v4)) {
          break;
        }
        char v13 = v12 + 1;
        uint64_t v7 = (uint64_t *)v12[1];
        if (!v7) {
          goto LABEL_21;
        }
      }
LABEL_20:
      if (!*v13)
      {
LABEL_21:
        uint64_t v15 = operator new(0x30uLL);
        v15[2] = *(_OWORD *)v4;
        *(void *)uint64_t v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = v12;
        *char v13 = (uint64_t)v15;
        uint64_t v16 = (uint64_t *)**a1;
        if (v16)
        {
          *a1 = v16;
          uint64_t v15 = (_OWORD *)*v13;
        }
        sub_100046C90(a1[1], (uint64_t *)v15);
        a1[2] = (uint64_t *)((char *)a1[2] + 1);
      }
      v4 += 2;
      if (v4 == v6) {
        return a1;
      }
    }
    int v9 = v5;
LABEL_18:
    uint64_t v12 = v5;
    char v13 = v5;
    if (!v7) {
      goto LABEL_21;
    }
    char v13 = v9 + 1;
    uint64_t v12 = v9;
    goto LABEL_20;
  }
  return a1;
}

void sub_100A28458(_Unwind_Exception *a1)
{
  sub_10005D144(*v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A28470(char **a1, char **a2)
{
  sub_100058DB0(v7, *a1);
  sub_100058DB0(__p, *a2);
  char v3 = sub_100046FE8(v7, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0) {
    operator delete(v7[0]);
  }
  return (v3 >> 7) & 1;
}

void sub_100A284E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A28504(char **a1, char **a2)
{
  sub_100058DB0(v7, *a1);
  sub_100058DB0(__p, *a2);
  char v3 = sub_100046FE8(v7, __p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  if (v8 < 0) {
    operator delete(v7[0]);
  }
  return (v3 >> 7) & 1;
}

void sub_100A2857C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A285A0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_100A285AC()
{
  return 0;
}

void sub_100A285B4(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  LazuliProvisioningServerWrapper::stopTimers((LazuliProvisioningServerWrapper *)a1);
  unint64_t v6 = sub_1008AE4F8(*(void *)(a1 + 360));
  if (v7)
  {
    LazuliProvisioningServerWrapper::startUnauthorizedXmlTimer((LazuliProvisioningServerWrapper *)a1, v6);
    return;
  }
  int v8 = a3;
  unint64_t v9 = sub_1008AD5A0(*(void *)(a1 + 360));
  if (v10)
  {
    unint64_t v11 = v9;
    if (v8)
    {
      unsigned int v12 = v9 - a2;
      if ((int)v9 - (int)a2 < 0) {
        unsigned int v12 = a2 - v9;
      }
      if (v12 <= 0x258)
      {
        char v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56));
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v19 = 134218240;
        unint64_t v20 = v11;
        __int16 v21 = 2048;
        uint64_t v22 = a2;
        unint64_t v14 = "#I Not starting FULL XML timer for %zu as its vicinity-banned : %zu";
LABEL_22:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v19, 0x16u);
        return;
      }
    }
    LazuliProvisioningServerWrapper::startFullXmlTimer((LazuliProvisioningServerWrapper *)a1, v9);
  }
  else
  {
    unint64_t v15 = sub_1008ADD90(*(void *)(a1 + 360));
    if (!v16) {
      return;
    }
    unint64_t v17 = v15;
    if (v8)
    {
      unsigned int v18 = v15 - a2;
      if ((int)v15 - (int)a2 < 0) {
        unsigned int v18 = a2 - v15;
      }
      if (v18 <= 0x258)
      {
        char v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56));
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v19 = 134218240;
        unint64_t v20 = v17;
        __int16 v21 = 2048;
        uint64_t v22 = a2;
        unint64_t v14 = "#I Not starting REFRESH XML timer for %zu as its vicinity-banned : %zu";
        goto LABEL_22;
      }
    }
    LazuliProvisioningServerWrapper::startRefreshXmlTimer((LazuliProvisioningServerWrapper *)a1, v15);
  }
}

void sub_100A28844(LazuliProvisioningServerWrapper *a1)
{
  LazuliProvisioningServerWrapper::~LazuliProvisioningServerWrapper(a1);

  operator delete();
}

void sub_100A2887C()
{
}

void sub_100A288C0()
{
}

void *sub_100A288E4(void *a1)
{
  *a1 = off_101A907D0;
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "cu.policy.ne");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *a1 = off_101A2DE10;
  a1[2] = objc_alloc_init((Class)NEPolicySession);
  return a1;
}

void sub_100A289A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  ctu::OsLogLogger::~OsLogLogger(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_100A289DC(uint64_t a1, uint64_t *a2)
{
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v33 = 0x4812000000;
  uint64_t v34 = sub_100A28E1C;
  uint64_t v35 = sub_100A28E40;
  unint64_t v36 = "";
  memset(v37, 0, 24);
  char v3 = (void *)NEHelperCacheCopyAppUUIDMapping();
  if (v3 || (char v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    char v3 = 0;
  }
  xpc_release(v3);
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 3221225472;
    applier[2] = sub_100A28E6C;
    applier[3] = &unk_101A2DE40;
    applier[4] = &buf;
    xpc_array_apply(v4, applier);
  }
  int v27 = 0;
  __int16 v28 = 0;
  __int16 v26 = 0;
  uint64_t v5 = *(void ***)(*((void *)&buf + 1) + 48);
  unint64_t v6 = *(void ***)(*((void *)&buf + 1) + 56);
  v30[0] = (void **)&v26;
  uint64_t v7 = (char *)v6 - (char *)v5;
  if (v6 != v5)
  {
    v30[1] = 0;
    if (v7 < 0) {
      sub_10006A748();
    }
    int v8 = (char *)sub_100048350(v7 >> 3);
    uint64_t v9 = 0;
    __int16 v26 = v8;
    int v27 = v8;
    __int16 v28 = &v8[8 * v10];
    unint64_t v11 = v8;
    do
    {
      unsigned int v12 = *v5++;
      *(void *)unint64_t v11 = v12;
      v11 += 8;
      v9 += 8;
    }
    while (v5 != v6);
    int v27 = &v8[v9];
  }
  xpc_release(v4);
  _Block_object_dispose(&buf, 8);
  v30[0] = (void **)v37;
  sub_100A29080(v30);
  char v13 = v26;
  unint64_t v14 = v27;
  if (v26 == v27)
  {
    char v15 = 0;
  }
  else
  {
    char v15 = 0;
    do
    {
      char v16 = *(void **)(a1 + 16);
      id v17 = objc_alloc((Class)NEPolicy);
      unsigned int v18 = +[NEPolicyResult drop];
      v31[0] = *(void *)v13;
      int v19 = +[NEPolicyCondition allInterfaces];
      v31[1] = v19;
      unint64_t v20 = +[NSArray arrayWithObjects:v31 count:2];
      id v21 = [v17 initWithOrder:300 result:v18 conditions:v20];
      LOBYTE(v16) = [v16 addPolicy:v21] == 0;

      if (v16)
      {
        uint64_t v22 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          if (*((char *)a2 + 23) >= 0) {
            CFIndex v23 = a2;
          }
          else {
            CFIndex v23 = (uint64_t *)*a2;
          }
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "A condition was not added for %{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        char v15 = 1;
      }
      v13 += 8;
    }
    while (v13 != v14);
  }
  *(void *)&long long buf = &v26;
  sub_100A29080((void ***)&buf);
  return v15 & 1;
}

void sub_100A28D5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id sub_100A28E0C(uint64_t a1)
{
  return [*(id *)(a1 + 16) removeAllPolicies];
}

id sub_100A28E14(uint64_t a1)
{
  return [*(id *)(a1 + 16) apply];
}

__n128 sub_100A28E1C(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void sub_100A28E40(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  sub_100A29080(&v1);
}

uint64_t sub_100A28E6C(uint64_t a1, int a2, xpc_object_t object)
{
  if (object && xpc_get_type(object) == (xpc_type_t)&_xpc_type_uuid)
  {
    uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8);
    id v6 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_uuid_get_bytes(object)];
    uint64_t v7 = +[NEPolicyCondition effectiveApplication:v6];
    uint64_t v8 = v7;
    uint64_t v10 = (uint64_t *)v5[7];
    unint64_t v9 = v5[8];
    if ((unint64_t)v10 >= v9)
    {
      uint64_t v12 = v5[6];
      uint64_t v13 = ((uint64_t)v10 - v12) >> 3;
      if ((unint64_t)(v13 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v14 = v9 - v12;
      uint64_t v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
        uint64_t v15 = v13 + 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16) {
        unint64_t v16 = (unint64_t)sub_100048350(v16);
      }
      else {
        uint64_t v17 = 0;
      }
      unsigned int v18 = (uint64_t *)(v16 + 8 * v13);
      unint64_t v19 = v16 + 8 * v17;
      *unsigned int v18 = v8;
      unint64_t v11 = v18 + 1;
      unint64_t v20 = (void *)v5[6];
      id v21 = (void *)v5[7];
      if (v21 == v20)
      {
        v5[6] = v18;
        uint8_t v5[7] = v11;
        unsigned char v5[8] = v19;
      }
      else
      {
        do
        {
          uint64_t v22 = *--v21;
          void *v21 = 0;
          *--unsigned int v18 = v22;
        }
        while (v21 != v20);
        id v21 = (void *)v5[6];
        CFIndex v23 = (void *)v5[7];
        v5[6] = v18;
        uint8_t v5[7] = v11;
        unsigned char v5[8] = v19;
        while (v23 != v21)
        {
          uint64_t v24 = (void *)*--v23;
        }
      }
      if (v21) {
        operator delete(v21);
      }
    }
    else
    {
      uint64_t *v10 = v7;
      unint64_t v11 = v10 + 1;
    }
    uint8_t v5[7] = v11;
  }
  return 1;
}

void sub_100A28FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100A28FF8(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100A2902C(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  operator delete();
}

void sub_100A29080(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    xpc_object_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        id v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100A29100(PB::Base *this)
{
  *(void *)this = &off_101A2DEB8;
  uint64_t v2 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 10);
  *((void *)this + 1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }

  PB::Base::~Base(this);
}

void sub_100A29424(PB::Base *a1)
{
  sub_100A29100(a1);

  operator delete();
}

uint64_t sub_100A2945C(uint64_t result, void *a2)
{
  *(void *)__n128 result = &off_101A2DEB8;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  *(_OWORD *)(result + 104) = 0u;
  *(void *)(result + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  if (a2[15]) {
    operator new();
  }
  if (a2[5]) {
    operator new();
  }
  if (a2[10]) {
    operator new();
  }
  if (a2[1]) {
    operator new();
  }
  if (a2[2]) {
    operator new();
  }
  if (a2[11]) {
    operator new();
  }
  if (a2[4]) {
    operator new();
  }
  if (a2[13]) {
    operator new();
  }
  if (a2[3]) {
    operator new();
  }
  if (a2[12]) {
    operator new();
  }
  if (a2[14]) {
    operator new();
  }
  if (a2[6]) {
    operator new();
  }
  if (a2[8]) {
    operator new();
  }
  if (a2[9]) {
    operator new();
  }
  if (a2[7]) {
    operator new();
  }
  return result;
}

uint64_t sub_100A29A4C(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)a1 = &off_101A2DEB8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  uint64_t v5 = a2[15];
  a2[15] = 0;
  uint64_t v6 = *(void *)(a1 + 120);
  *(void *)(a1 + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v5;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a2[5];
  a2[5] = 0;
  uint64_t v8 = *(void *)(a1 + 40);
  *(void *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v7;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a2[10];
  a2[10] = 0;
  uint64_t v10 = *(void *)(a1 + 80);
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v9;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = a2[1];
  a2[1] = 0;
  uint64_t v12 = *v4;
  uint64_t *v4 = v11;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = a2[2];
  a2[2] = 0;
  uint64_t v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = a2[11];
  a2[11] = 0;
  uint64_t v16 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v15;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = a2[4];
  a2[4] = 0;
  uint64_t v18 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v17;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = a2[13];
  a2[13] = 0;
  uint64_t v20 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = v19;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = a2[3];
  a2[3] = 0;
  uint64_t v22 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v21;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = a2[12];
  a2[12] = 0;
  uint64_t v24 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = v23;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = a2[14];
  a2[14] = 0;
  uint64_t v26 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = v25;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = a2[6];
  a2[6] = 0;
  uint64_t v28 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v27;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  uint64_t v29 = a2[8];
  a2[8] = 0;
  uint64_t v30 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v29;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  uint64_t v31 = a2[9];
  a2[9] = 0;
  uint64_t v32 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v31;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
  }
  uint64_t v33 = a2[7];
  a2[7] = 0;
  uint64_t v34 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v33;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
  }
  return a1;
}

uint64_t sub_100A29E08(void *a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = a1[1];
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, this, "activateProfile");
  }
  uint64_t v6 = a1[2];
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, this, "deleteProfile");
  }
  uint64_t v7 = a1[3];
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, this, "deviceInfo");
  }
  uint64_t v8 = a1[4];
  if (v8) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "endSession");
  }
  uint64_t v9 = a1[5];
  if (v9) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "fetchProfile");
  }
  uint64_t v10 = a1[6];
  if (v10) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, this, "fetchSubscriptionInfo");
  }
  uint64_t v11 = a1[7];
  if (v11) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, this, "genericTransferPayload");
  }
  uint64_t v12 = a1[8];
  if (v12) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, this, "pendingProfiles");
  }
  uint64_t v13 = a1[9];
  if (v13) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v13 + 32))(v13, this, "purchasePlan");
  }
  uint64_t v14 = a1[10];
  if (v14) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, this, "sendUserConsent");
  }
  uint64_t v15 = a1[11];
  if (v15) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v15 + 32))(v15, this, "startSession");
  }
  uint64_t v16 = a1[12];
  if (v16) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v16 + 32))(v16, this, "transferProfile");
  }
  uint64_t v17 = a1[13];
  if (v17) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v17 + 32))(v17, this, "updateProfile");
  }
  uint64_t v18 = a1[14];
  if (v18) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v18 + 32))(v18, this, "updateSubscriptionInfo");
  }
  uint64_t v19 = a1[15];
  if (v19) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v19 + 32))(v19, this, "vinylInfo");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100A2A194(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_22:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      switch((v10 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          operator new();
        case 3u:
          operator new();
        case 4u:
          operator new();
        case 5u:
          operator new();
        case 6u:
          operator new();
        case 7u:
          operator new();
        case 8u:
          operator new();
        case 9u:
          operator new();
        case 0xAu:
          operator new();
        case 0xBu:
          operator new();
        case 0xCu:
          operator new();
        case 0xDu:
          operator new();
        case 0xEu:
          operator new();
        case 0xFu:
          operator new();
        default:
          break;
      }
LABEL_20:
      uint64_t result = PB::Reader::skip(this, v19, v18, 0);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_22;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100A2AAE0(uint64_t result, PB::Writer *this)
{
  unint64_t v3 = (void *)result;
  int v4 = *(const PB::Base **)(result + 120);
  if (v4) {
    uint64_t result = PB::Writer::writeSubmessage(this, v4, 1u);
  }
  uint64_t v5 = (const PB::Base *)v3[5];
  if (v5) {
    uint64_t result = PB::Writer::writeSubmessage(this, v5, 2u);
  }
  uint64_t v6 = (const PB::Base *)v3[10];
  if (v6) {
    uint64_t result = PB::Writer::writeSubmessage(this, v6, 3u);
  }
  uint64_t v7 = (const PB::Base *)v3[1];
  if (v7) {
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 4u);
  }
  char v8 = (const PB::Base *)v3[2];
  if (v8) {
    uint64_t result = PB::Writer::writeSubmessage(this, v8, 5u);
  }
  unsigned int v9 = (const PB::Base *)v3[11];
  if (v9) {
    uint64_t result = PB::Writer::writeSubmessage(this, v9, 6u);
  }
  unint64_t v10 = (const PB::Base *)v3[4];
  if (v10) {
    uint64_t result = PB::Writer::writeSubmessage(this, v10, 7u);
  }
  unint64_t v11 = (const PB::Base *)v3[13];
  if (v11) {
    uint64_t result = PB::Writer::writeSubmessage(this, v11, 8u);
  }
  char v12 = (const PB::Base *)v3[3];
  if (v12) {
    uint64_t result = PB::Writer::writeSubmessage(this, v12, 9u);
  }
  BOOL v13 = (const PB::Base *)v3[12];
  if (v13) {
    uint64_t result = PB::Writer::writeSubmessage(this, v13, 0xAu);
  }
  char v14 = (const PB::Base *)v3[14];
  if (v14) {
    uint64_t result = PB::Writer::writeSubmessage(this, v14, 0xBu);
  }
  unsigned int v15 = (const PB::Base *)v3[6];
  if (v15) {
    uint64_t result = PB::Writer::writeSubmessage(this, v15, 0xCu);
  }
  unint64_t v16 = (const PB::Base *)v3[8];
  if (v16) {
    uint64_t result = PB::Writer::writeSubmessage(this, v16, 0xDu);
  }
  char v17 = (const PB::Base *)v3[9];
  if (v17) {
    uint64_t result = PB::Writer::writeSubmessage(this, v17, 0xEu);
  }
  unsigned __int8 v18 = (const PB::Base *)v3[7];
  if (v18)
  {
    return PB::Writer::writeSubmessage(this, v18, 0xFu);
  }
  return result;
}

uint64_t sub_100A2AC48(uint64_t result)
{
  if (!*(void *)(result + 120)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2ACF0(uint64_t result)
{
  if (!*(void *)(result + 40)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2ADB0(uint64_t result)
{
  if (!*(void *)(result + 80)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2AE5C(uint64_t result)
{
  if (!*(void *)(result + 8)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2AF08(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2AFB4(uint64_t result)
{
  if (!*(void *)(result + 88)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B060(uint64_t result)
{
  if (!*(void *)(result + 32)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B10C(uint64_t result)
{
  if (!*(void *)(result + 104)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B1C8(uint64_t result)
{
  if (!*(void *)(result + 24)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B270(uint64_t result)
{
  if (!*(void *)(result + 96)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B338(uint64_t result)
{
  if (!*(void *)(result + 112)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B3F0(uint64_t result)
{
  if (!*(void *)(result + 48)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B49C(uint64_t result)
{
  if (!*(void *)(result + 64)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B544(uint64_t result)
{
  if (!*(void *)(result + 72)) {
    operator new();
  }
  return result;
}

uint64_t sub_100A2B60C(uint64_t result)
{
  if (!*(void *)(result + 56)) {
    operator new();
  }
  return result;
}

void sub_100A2B6C8(ctu::OsLogLogger *this)
{
  unint64_t v2 = (const void *)*((void *)this + 9);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = *((void *)this + 5);
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    sub_10004D2C8(v6);
  }

  ctu::OsLogLogger::~OsLogLogger(this);
}

void sub_100A2B760(uint64_t a1, int a2)
{
  int v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "";
    int v7 = 136315650;
    char v8 = "PSThrottlingEntitlements";
    unint64_t v10 = ", ";
    __int16 v9 = 2080;
    if (a2) {
      uint64_t v5 = "permanent ";
    }
    __int16 v11 = 2080;
    char v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sgot %sfailure report", (uint8_t *)&v7, 0x20u);
  }
  if (a2) {
    int v6 = 2;
  }
  else {
    int v6 = 1;
  }
  *(_DWORD *)(a1 + 48) = v6;
  if ((a2 & 1) == 0) {
    sub_100A2B860(a1);
  }
}

void sub_100A2B860(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    os_log_t v2 = *(os_log_t *)a1;
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = "PSThrottlingEntitlements";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = ", ";
    uint64_t v3 = "#I %s%sAlready waiting on timer";
    goto LABEL_4;
  }
  int v6 = *(_DWORD *)(a1 + 52);
  if (v6)
  {
    *(_DWORD *)(a1 + 52) = v6 - 1;
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 8));
    uint64_t v7 = *(void *)buf;
    sub_100058DB0(__p, "PSThrottlingEntitlements retry");
    char v8 = *(NSObject **)(a1 + 40);
    dispatch_object_t object = v8;
    if (v8) {
      dispatch_retain(v8);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_100A2BCF0;
    aBlock[3] = &unk_101A2DF10;
    aBlock[4] = a1;
    unsigned int v15 = _Block_copy(aBlock);
    sub_100118A44(v7, (uint64_t)__p, 1, 60000000, &object, &v15);
    uint64_t v9 = v19;
    uint64_t v19 = 0;
    uint64_t v10 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v9;
    if (v10)
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      uint64_t v11 = v19;
      uint64_t v19 = 0;
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
      }
    }
    if (v15) {
      _Block_release(v15);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    os_log_t v12 = *(os_log_t *)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = "PSThrottlingEntitlements";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = ", ";
      __int16 v21 = 1024;
      int v22 = 60;
      __int16 v23 = 1024;
      int v24 = v13;
      uint64_t v3 = "#I %s%sTriggering retry in %d seconds. %d retries left";
      int v4 = v12;
      uint32_t v5 = 34;
      goto LABEL_21;
    }
  }
  else
  {
    os_log_t v2 = *(os_log_t *)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = "PSThrottlingEntitlements";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = ", ";
      uint64_t v3 = "#I %s%sNo more retries allowed";
LABEL_4:
      int v4 = v2;
      uint32_t v5 = 22;
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, buf, v5);
    }
  }
}

void sub_100A2BB48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A2BBB0(uint64_t a1)
{
  os_log_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315394;
    uint64_t v7 = "PSThrottlingEntitlements";
    __int16 v8 = 2080;
    uint64_t v9 = ", ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sreset", (uint8_t *)&v6, 0x16u);
  }
  *(void *)(a1 + 48) = 0x500000000;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    uint64_t v4 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  *(unsigned char *)(a1 + 64) = 0;
  uint32_t v5 = *(const void **)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v5) {
    _Block_release(v5);
  }
}

void sub_100A2BCE4(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A2BCF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  os_log_t v2 = *(std::__shared_weak_count **)(v1 + 32);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v1 + 24);
      if (!v5)
      {
LABEL_21:
        sub_10004D2C8(v4);
        return;
      }
      int v6 = *(NSObject **)v1;
      if (os_log_type_enabled(*(os_log_t *)v1, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 136315394;
        char v14 = "PSThrottlingEntitlements";
        __int16 v15 = 2080;
        unint64_t v16 = ", ";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%scallback", (uint8_t *)&v13, 0x16u);
      }
      uint64_t v7 = *(void *)(v1 + 56);
      *(void *)(v1 + 56) = 0;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      __int16 v8 = *(const void **)(v1 + 72);
      if (v8)
      {
        uint64_t v9 = (void (**)(void))_Block_copy(v8);
        uint64_t v10 = *(const void **)(v1 + 72);
        *(void *)(v1 + 72) = 0;
        if (v10) {
          _Block_release(v10);
        }
        int v11 = *(unsigned __int8 *)(v1 + 64);
        *(unsigned char *)(v1 + 64) = 0;
        if (*(_DWORD *)(v1 + 48) != 1) {
          goto LABEL_19;
        }
        if (v9) {
          v9[2](v9);
        }
        if (!v11) {
          goto LABEL_19;
        }
      }
      else
      {
        *(void *)(v1 + 72) = 0;
        int v12 = *(unsigned __int8 *)(v1 + 64);
        *(unsigned char *)(v1 + 64) = 0;
        if (!v12) {
          goto LABEL_21;
        }
        uint64_t v9 = 0;
        if (*(_DWORD *)(v1 + 48) != 1) {
          goto LABEL_21;
        }
      }
      (*(void (**)(uint64_t, void, void))(*(void *)v5 + 344))(v5, 0, 0);
LABEL_19:
      if (v9) {
        _Block_release(v9);
      }
      goto LABEL_21;
    }
  }
}

void sub_100A2BEC0(_Unwind_Exception *a1)
{
  _Block_release(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A2BF08(uint64_t a1, void *a2, void *a3, char *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, a4);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 24) = v7;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v29, (const OsLogContext *)buf);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v29);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v29);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  __int16 v8 = off_101A2DF40;
  *(void *)a1 = off_101A2DF40;
  *(void *)(a1 + 48) = *a2;
  uint64_t v9 = a2[1];
  *(void *)(a1 + 56) = v9;
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    __int16 v8 = *(void (***)())a1;
  }
  uint64_t v10 = (char *)((uint64_t (*)(uint64_t))v8[25])(a1);
  sub_100058DB0(&__p, v10);
  int v11 = *(NSObject **)(a1 + 24);
  uint64_t v26 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  ctu::RestModule::RestModule();
  if (v26) {
    dispatch_release(v26);
  }
  if (v28 < 0) {
    operator delete(__p);
  }
  int v12 = (PersonalityInfo ***)(a1 + 80);
  sub_1004054F4(a3, (void *)(a1 + 80));
  *(void *)(a1 + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(unsigned char *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 354) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 360), (const ctu::OsLogLogger *)(a1 + 40));
  *(void *)(a1 + 368) = *a2;
  uint64_t v13 = a2[1];
  *(void *)(a1 + 376) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  char v14 = *(NSObject **)(a1 + 24);
  *(void *)(a1 + 40ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  *(void *)(a1 + 408) = 0x500000000;
  *(void *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(void *)(a1 + 448) = 850045863;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 52ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0u;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = a1 + 520;
  *(_DWORD *)(a1 + 536) = 0;
  *(unsigned char *)(a1 + 54ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 1;
  *(unsigned char *)(a1 + 544) = 0;
  *(unsigned char *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 584) = 0u;
  *(void *)(a1 + 576) = a1 + 584;
  *(void *)(a1 + 60ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a1 + 608;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(void *)(a1 + 624) = a1 + 632;
  *(void *)(a1 + 648) = 850045863;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(void *)(a1 + 704) = 0;
  *(_OWORD *)(a1 + 72ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0u;
  *(void *)(a1 + 712) = a1 + 720;
  *(_DWORD *)(a1 + 736) = 0;
  *(void *)(a1 + 76ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(_OWORD *)(a1 + 744) = 0u;
  *(void *)(a1 + 768) = a2[3];
  uint64_t v15 = a2[4];
  *(void *)(a1 + 776) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 784) = a2[5];
  uint64_t v16 = a2[6];
  *(void *)(a1 + 792) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 816) = 0;
  *(void *)(a1 + 808) = 0;
  *(void *)(a1 + 80ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a1 + 808;
  *(_OWORD *)(a1 + 848) = 0uLL;
  *(_OWORD *)(a1 + 864) = 0uLL;
  *(_OWORD *)(a1 + 88ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0uLL;
  *(_OWORD *)(a1 + 896) = 0uLL;
  *(_OWORD *)(a1 + 912) = 0uLL;
  *(_OWORD *)(a1 + 928) = 0uLL;
  *(_OWORD *)(a1 + 944) = 0uLL;
  *(_OWORD *)(a1 + 96ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0uLL;
  *(_OWORD *)(a1 + 976) = 0uLL;
  *(_OWORD *)(a1 + 992) = 0uLL;
  *(_OWORD *)(a1 + 1002) = 0uLL;
  *(unsigned char *)(a1 + 84ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(_OWORD *)(a1 + 824) = 0uLL;
  char v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = PersonalityInfo::logPrefix(**v12);
    uint64_t v19 = **v12;
    int v22 = (const char *)*((void *)v19 + 3);
    uint64_t v20 = (char *)v19 + 24;
    __int16 v21 = v22;
    uint64_t v23 = *((unsigned __int8 *)v20 + 23);
    int v24 = (char)v23;
    if ((v23 & 0x80u) != 0) {
      uint64_t v23 = *((void *)v20 + 1);
    }
    if (v24 < 0) {
      uint64_t v20 = v21;
    }
    if (!v23) {
      uint64_t v20 = "<invalid>";
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v31 = v18;
    __int16 v32 = 2080;
    uint64_t v33 = " ";
    __int16 v34 = 2080;
    uint64_t v35 = v20;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sCreated for '%s'", buf, 0x20u);
  }
  return a1;
}

void sub_100A2C30C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, ctu::OsLogLogger *a11, void *a12, dispatch_object_t object, dispatch_object_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,int a22,__int16 a23,char a24,char a25)
{
  sub_1001509E4(v32);
  __int16 v34 = *(std::__shared_weak_count **)(v25 + 832);
  if (v34) {
    sub_10004D2C8(v34);
  }
  sub_10030AAD0(v26, *(void **)(v25 + 808));
  uint64_t v35 = *(std::__shared_weak_count **)(v25 + 792);
  if (v35) {
    sub_10004D2C8(v35);
  }
  unint64_t v36 = *(std::__shared_weak_count **)(v25 + 776);
  if (v36) {
    sub_10004D2C8(v36);
  }
  if (*(char *)(v25 + 767) < 0) {
    operator delete(*v27);
  }
  sub_10005D144(*(void **)(v25 + 720));
  std::mutex::~mutex(v29);
  sub_10005D144(*(void **)(v25 + 632));
  sub_10005D144(*(void **)(v25 + 608));
  sub_100119D90(*(void **)(v25 + 584));
  if (*(unsigned char *)(v25 + 568) && *(char *)(v25 + 567) < 0) {
    operator delete(*(void **)(v25 + 544));
  }
  sub_100A336C4(*(const void ***)(v25 + 520));
  std::mutex::~mutex(v30);
  uint64_t v37 = *(void *)(v25 + 440);
  *(void *)(v25 + 44ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
  }
  sub_100A2B6C8(a10);
  if (*(unsigned char *)(v25 + 344)) {
    sub_1001DFC34(v31);
  }
  if (*(char *)(v25 + 143) < 0) {
    operator delete(*v28);
  }
  sub_100119D90(*(void **)(v25 + 104));
  uint64_t v38 = *(std::__shared_weak_count **)(v25 + 88);
  if (v38) {
    sub_10004D2C8(v38);
  }
  unint64_t v39 = *(std::__shared_weak_count **)(v25 + 72);
  if (v39) {
    sub_10004D2C8(v39);
  }
  unint64_t v40 = *(std::__shared_weak_count **)(v25 + 56);
  if (v40) {
    sub_10004D2C8(v40);
  }
  PhoneServicesControl::~PhoneServicesControl((PhoneServicesControl *)v25);
  ctu::OsLogLogger::~OsLogLogger(a11);
  sub_100087E88(a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100A2C4CC(uint64_t a1)
{
  *(void *)a1 = off_101A2DF40;
  sub_1001509E4(a1 + 840);
  os_log_t v2 = *(std::__shared_weak_count **)(a1 + 832);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10030AAD0(a1 + 800, *(void **)(a1 + 808));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 792);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 776);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(char *)(a1 + 767) < 0) {
    operator delete(*(void **)(a1 + 744));
  }
  sub_10005D144(*(void **)(a1 + 720));
  std::mutex::~mutex((std::mutex *)(a1 + 648));
  sub_10005D144(*(void **)(a1 + 632));
  sub_10005D144(*(void **)(a1 + 608));
  sub_100119D90(*(void **)(a1 + 584));
  if (*(unsigned char *)(a1 + 568) && *(char *)(a1 + 567) < 0) {
    operator delete(*(void **)(a1 + 544));
  }
  sub_100A336C4(*(const void ***)(a1 + 520));
  std::mutex::~mutex((std::mutex *)(a1 + 448));
  uint64_t v5 = *(void *)(a1 + 440);
  *(void *)(a1 + 44ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_100A2B6C8((ctu::OsLogLogger *)(a1 + 360));
  if (*(unsigned char *)(a1 + 344)) {
    sub_1001DFC34(a1 + 144);
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  sub_100119D90(*(void **)(a1 + 104));
  int v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7) {
    sub_10004D2C8(v7);
  }
  __int16 v8 = *(std::__shared_weak_count **)(a1 + 56);
  if (v8) {
    sub_10004D2C8(v8);
  }
  PhoneServicesControl::~PhoneServicesControl((PhoneServicesControl *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A2C64C(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 80);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 47);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(v2 + 32);
  }
  if (v3)
  {
    if (*(unsigned char *)(v2 + 49) == 1) {
      CFStringRef v4 = @"onfile.status.icloud";
    }
    else {
      CFStringRef v4 = @"onfile.status.sim";
    }
    v87[0] = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v6 = ServiceMap;
    uint64_t v8 = v7;
    if (v7 < 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v8;
    int v12 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
    if (v12)
    {
      uint64_t v14 = v12[3];
      uint64_t v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v13 = 0;
    char v15 = 1;
LABEL_15:
    uint64_t v16 = kPhoneServicesWalletDomain;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v14 + 24))(&v89, v14, **(void **)(a1 + 80) + 24, @"onfile.status", kPhoneServicesWalletDomain, 0, 1);
    sub_10004EFE4(v87, (CFTypeRef *)&v89);
    sub_1000577C4((const void **)&v89);
    if ((v15 & 1) == 0) {
      sub_10004D2C8(v13);
    }
    char v17 = v87[0];
    if (v87[0]) {
      uint64_t v18 = sub_100080778;
    }
    else {
      uint64_t v18 = 0;
    }
    if (!v18)
    {
      sub_1003A9CA0(buf);
      CFTypeRef v86 = sub_1003A9B04(*(uint64_t *)buf, v4, 0);
      v89 = 0;
      uint64_t v19 = (const void **)sub_100084068(&v89, &v86);
      uint64_t v20 = (void *)v87[0];
      v87[0] = v89;
      v89 = v20;
      sub_100057D78(v19);
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      char v17 = v87[0];
      if (v87[0]) {
        __int16 v21 = sub_100080778;
      }
      else {
        __int16 v21 = 0;
      }
      if (!v21)
      {
        sub_1003A9CA0(buf);
        CFTypeRef v86 = sub_1003A9B04(*(uint64_t *)buf, @"onfile.status", 0);
        v89 = 0;
        int v22 = (const void **)sub_100084068(&v89, &v86);
        uint64_t v23 = (void *)v87[0];
        v87[0] = v89;
        v89 = v23;
        sub_100057D78(v22);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        char v17 = v87[0];
      }
    }
    if (v17) {
      int v24 = sub_100080778;
    }
    else {
      int v24 = 0;
    }
    if (!v24)
    {
LABEL_58:
      sub_100057D78(v87);
      Registry::createRestModuleOneTimeUseConnection(&v84, *(Registry **)(a1 + 48));
      ctu::RestModule::connect();
      if (v85) {
        sub_10004D2C8(v85);
      }
      sub_10003E168(buf, (void *)(a1 + 8));
      uint64_t v45 = *(void *)buf;
      uint64_t v46 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v46);
        atomic_fetch_add_explicit(&v46->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v47 = *(std::__shared_weak_count **)(a1 + 392);
      *(void *)(a1 + 384) = v45;
      *(void *)(a1 + 392) = v46;
      if (v47) {
        std::__shared_weak_count::__release_weak(v47);
      }
      if (v46) {
        std::__shared_weak_count::__release_weak(v46);
      }
      sub_10003E168(buf, (void *)(a1 + 8));
      uint64_t v48 = *(void *)buf;
      uint64_t v49 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v49);
      }
      sub_100058DB0(&v89, "/cc/props/carrier_entitlements_info");
      uint64_t v50 = operator new(0x28uLL);
      void *v50 = off_101A2E328;
      v50[1] = a1 + 800;
      void v50[2] = a1;
      v50[3] = v48;
      v50[4] = v49;
      *(void *)&unsigned char buf[24] = v50;
      ctu::RestModule::observeProperty();
      sub_10003F600(buf);
      if (v91 < 0) {
        operator delete(v89);
      }
      CFDictionaryRef v83 = 0;
      unint64_t v51 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
      long long v52 = v51;
      if (v7 < 0)
      {
        unint64_t v53 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v54 = 5381;
        do
        {
          uint64_t v7 = v54;
          unsigned int v55 = *v53++;
          uint64_t v54 = (33 * v54) ^ v55;
        }
        while (v55);
      }
      std::mutex::lock(v51);
      *(void *)long long buf = v7;
      uint64_t v56 = sub_10004D37C(&v52[1].__m_.__sig, (unint64_t *)buf);
      if (v56)
      {
        uint64_t v58 = v56[3];
        CFIndex v57 = (std::__shared_weak_count *)v56[4];
        if (v57)
        {
          atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v52);
          atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v57);
          char v59 = 0;
          goto LABEL_78;
        }
      }
      else
      {
        uint64_t v58 = 0;
      }
      std::mutex::unlock(v52);
      CFIndex v57 = 0;
      char v59 = 1;
LABEL_78:
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v58 + 24))(&v89, v58, **(void **)(a1 + 80) + 24, @"onfile.status", v16, 0, 4);
      sub_10004EFE4(&v83, (CFTypeRef *)&v89);
      sub_1000577C4((const void **)&v89);
      if ((v59 & 1) == 0) {
        sub_10004D2C8(v57);
      }
      if (v83) {
        uint64_t v60 = sub_100080778;
      }
      else {
        uint64_t v60 = 0;
      }
      if (v60) {
        sub_1003A8958(a1 + 144, v83);
      }
      sub_10003E168(buf, (void *)(a1 + 8));
      unint64_t v61 = *(const void **)buf;
      uint64_t v62 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(v62);
      }
      sub_10003E168(&v86, (void *)(a1 + 8));
      int v63 = *(NSObject **)(a1 + 24);
      v87[0] = v63;
      v87[1] = (const void *)a1;
      v87[2] = v61;
      v87[3] = v62;
      if (v62)
      {
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        memset(buf, 0, 32);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        dispatch_retain(v63);
        atomic_fetch_add_explicit(&v62->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        dispatch_retain(v63);
        memset(buf, 0, 32);
        dispatch_retain(v63);
        dispatch_retain(v63);
        dispatch_retain(v63);
        dispatch_retain(v63);
        dispatch_retain(v63);
        dispatch_retain(v63);
      }
      v89 = 0;
      dispatch_retain(v63);
      operator new();
    }
    uint64_t v25 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v26 = v25;
    uint64_t v27 = v7;
    if (v7 < 0)
    {
      char v28 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v25);
    *(void *)long long buf = v27;
    uint64_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
    if (v31)
    {
      uint64_t v33 = v31[3];
      uint64_t v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    uint64_t v32 = 0;
    char v34 = 1;
LABEL_42:
    (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, uint64_t, void, uint64_t, void))(*(void *)v33 + 16))(v33, **(void **)(a1 + 80) + 24, @"onfile.status", v87[0], v16, 0, 4, 0);
    if ((v34 & 1) == 0) {
      sub_10004D2C8(v32);
    }
    uint64_t v35 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    unint64_t v36 = v35;
    uint64_t v37 = v7;
    if (v7 < 0)
    {
      uint64_t v38 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v39 = 5381;
      do
      {
        uint64_t v37 = v39;
        unsigned int v40 = *v38++;
        uint64_t v39 = (33 * v39) ^ v40;
      }
      while (v40);
    }
    std::mutex::lock(v35);
    *(void *)long long buf = v37;
    int v41 = sub_10004D37C(&v36[1].__m_.__sig, (unint64_t *)buf);
    if (v41)
    {
      uint64_t v43 = v41[3];
      uint64_t v42 = (std::__shared_weak_count *)v41[4];
      if (v42)
      {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v36);
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v42);
        char v44 = 0;
LABEL_52:
        (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v43 + 32))(v43, **(void **)(a1 + 80) + 24, @"onfile.status", v16, 0, 1);
        if ((v44 & 1) == 0) {
          sub_10004D2C8(v42);
        }
        sub_1003A9CA0(buf);
        sub_1003A9C3C(*(uint64_t *)buf, v4, 0);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        sub_1003A9CA0(buf);
        sub_1003A9C3C(*(uint64_t *)buf, @"onfile.status", 0);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v43 = 0;
    }
    std::mutex::unlock(v36);
    uint64_t v42 = 0;
    char v44 = 1;
    goto LABEL_52;
  }
  uint64_t v82 = (std::mutex *)(a1 + 448);
  std::mutex::lock((std::mutex *)(a1 + 448));
  int v64 = 0;
  uint64_t v65 = (void *)(a1 + 104);
  LODWORD(v87[0]) = 0;
  uint64_t v66 = a1;
  uint64_t v67 = (uint64_t **)(a1 + 576);
  do
  {
    uint64_t v68 = *v65;
    if (!*v65) {
      goto LABEL_102;
    }
    uint64_t v69 = v65;
    do
    {
      int v70 = *(_DWORD *)(v68 + 32);
      BOOL v71 = v70 < v64;
      if (v70 >= v64) {
        uint64_t v72 = (uint64_t *)v68;
      }
      else {
        uint64_t v72 = (uint64_t *)(v68 + 8);
      }
      if (!v71) {
        uint64_t v69 = (void *)v68;
      }
      uint64_t v68 = *v72;
    }
    while (*v72);
    if (v69 == v65 || v64 < *((_DWORD *)v69 + 8))
    {
LABEL_102:
      v89 = 0;
      BOOL v90 = 0;
      sub_100A2DCB4(v64, (uint64_t)&v89);
      int64_t v74 = (uint64_t *)v89;
      uint64_t v73 = v90;
      if (v90)
      {
        atomic_fetch_add_explicit(&v90->__shared_owners_, 1uLL, memory_order_relaxed);
        *((_DWORD *)v74 + 4) = 1;
        sub_10004D2C8(v73);
      }
      else
      {
        *((_DWORD *)v89 + 4) = 1;
      }
      CFIndex v75 = sub_100256E84(v67, v64, v87);
      if (v73) {
        atomic_fetch_add_explicit(&v73->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v76 = (std::__shared_weak_count *)v75[6];
      v75[5] = v74;
      v75[6] = (uint64_t *)v73;
      if (v76) {
        sub_10004D2C8(v76);
      }
      unint64_t v77 = *(NSObject **)(v66 + 40);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        v78 = **(PersonalityInfo ***)(v66 + 80);
        if (v78) {
          uint64_t v79 = (const char *)PersonalityInfo::logPrefix(v78);
        }
        else {
          uint64_t v79 = "-1";
        }
        uint64_t v80 = asString();
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v79;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = v80;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I %s%s%s feature state defaulted to FALSE as unsupported for subscription type", buf, 0x20u);
      }
      if (v73) {
        sub_10004D2C8(v73);
      }
    }
    LODWORD(v87[0]) = v64 + 1;
  }
  while (v64++ < 5);
  std::mutex::unlock(v82);
}

void sub_100A2D7CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,const void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30)
{
}

void sub_100A2DCB4(int a1@<W1>, uint64_t a2@<X8>)
{
  if (a1 == 4)
  {
    uint64_t v5 = 0;
    long long v7 = 0u;
    long long v4 = 0u;
    int v6 = &v7;
    sub_100A377D0((uint64_t)&v4, &v8);
    *(_OWORD *)a2 = v8;
    long long v8 = 0uLL;
    sub_1000346F8((uint64_t)&v6, (void *)v7);
  }
  else
  {
    uint64_t v3 = operator new(0x30uLL);
    v3[1] = 0;
    v3[2] = 0;
    void *v3 = off_1019DD770;
    void v3[4] = 0;
    *((_DWORD *)v3 + 1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    *(void *)(a2 + 8) = v3;
    _OWORD v3[3] = 0;
    *(void *)a2 = v3 + 3;
  }
}

void sub_100A2DD68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  sub_1000346F8(v13, a13);
  _Unwind_Resume(a1);
}

void sub_100A2DD80(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 80);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 47);
  uint64_t v3 = *(void *)(v1 + 32);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = v2;
  }
  if (v3)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v6 = ServiceMap;
    if ((v7 & 0x8000000000000000) != 0)
    {
      long long v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        unint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v20 = v7;
    unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v20);
    if (v11)
    {
      uint64_t v13 = v11[3];
      int v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
LABEL_12:
        char v15 = (capabilities::ct *)(*(void *(**)(long long *__return_ptr, uint64_t))(*(void *)v13 + 200))(&v18, v13);
        uint64_t v16 = (void **)(a1 + 744);
        if (*(char *)(a1 + 767) < 0) {
          operator delete(*v16);
        }
        *(_OWORD *)uint64_t v16 = v18;
        *(void *)(a1 + 76ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v19;
        HIBYTE(v19) = 0;
        LOBYTE(v18) = 0;
        if ((v14 & 1) == 0) {
          sub_10004D2C8(v12);
        }
        if (capabilities::ct::supportsThumperSourcing(v15))
        {
          sub_10003E168(&v18, (void *)(a1 + 8));
          char v17 = (std::__shared_weak_count *)*((void *)&v18 + 1);
          if (*((void *)&v18 + 1))
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v18 + 1) + 16), 1uLL, memory_order_relaxed);
            sub_10004D2C8(v17);
          }
          if (v17) {
            atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          sub_10017B514();
          if (v17)
          {
            std::__shared_weak_count::__release_weak(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
        if (*(unsigned char *)(a1 + 344)) {
          sub_100A2E150(a1, a1 + 192);
        }
        sub_100A2E378(a1, 0);
        return;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    int v12 = 0;
    char v14 = 1;
    goto LABEL_12;
  }
}

void sub_100A2DFA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A2DFE4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        uint64_t v5 = a1[6];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        }
        v6[0] = 0;
        v6[1] = 0;
        sub_10003E168(v6, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100A2E124(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A2E140(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A2E150(uint64_t a1, uint64_t a2)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v17 = 0;
  if (*(unsigned char *)(a2 + 112))
  {
    if (*(char *)(a2 + 111) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a2 + 88), *(void *)(a2 + 96));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a2 + 88);
      uint64_t v17 = *(void *)(a2 + 104);
    }
  }
  else
  {
    sub_100058DB0(__dst, "");
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  if (*(unsigned char *)(a2 + 144))
  {
    if (*(char *)(a2 + 143) < 0)
    {
      sub_10004FC84(__p, *(void **)(a2 + 120), *(void *)(a2 + 128));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a2 + 120);
      uint64_t v15 = *(void *)(a2 + 136);
    }
  }
  else
  {
    sub_100058DB0(__p, "");
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    unint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    unsigned int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  unsigned int v11 = 0;
  char v13 = 1;
LABEL_19:
  (*(void (**)(uint64_t, uint64_t, void **, void **))(*(void *)v12 + 72))(v12, **(void **)(a1 + 80) + 24, __dst, __p);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_100A2E32C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A2E378(uint64_t a1, int a2)
{
  __s1[0] = 0;
  __s1[1] = 0;
  uint64_t v23 = 0;
  long long v4 = (void **)(a1 + 120);
  if (*(char *)(a1 + 143) < 0)
  {
    sub_10004FC84(__s1, *(void **)(a1 + 120), *(void *)(a1 + 128));
  }
  else
  {
    *(_OWORD *)__s1 = *(_OWORD *)v4;
    uint64_t v23 = *(void *)(a1 + 136);
  }
  __int16 v21 = 0;
  *(void *)long long buf = MGCopyAnswer();
  sub_100225AE0(&v21, (CFTypeRef *)buf);
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  uint64_t v5 = *(void *)buf;
  v26[0] = *(void *)&buf[8];
  *(void *)((char *)v26 + 7) = *(void *)&buf[15];
  uint8_t v6 = buf[23];
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*v4);
  }
  uint64_t v7 = v26[0];
  *(void *)(a1 + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v5;
  *(void *)(a1 + 128) = v7;
  *(void *)(a1 + 135) = *(void *)((char *)v26 + 7);
  *(unsigned char *)(a1 + 143) = v6;
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v9 = **(PersonalityInfo ***)(a1 + 80);
    if (v9)
    {
      unsigned int v10 = (const char *)PersonalityInfo::logPrefix(v9);
      uint8_t v6 = *(unsigned char *)(a1 + 143);
    }
    else
    {
      unsigned int v10 = "-1";
    }
    unsigned int v11 = v4;
    if ((v6 & 0x80) != 0) {
      unsigned int v11 = *v4;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sdisplayName: %s", buf, 0x20u);
  }
  if (a2)
  {
    uint64_t v12 = HIBYTE(v23);
    if (v23 >= 0) {
      char v13 = (void *)HIBYTE(v23);
    }
    else {
      char v13 = __s1[1];
    }
    char v14 = (void *)*(unsigned __int8 *)(a1 + 143);
    int v15 = (char)v14;
    if ((char)v14 < 0) {
      char v14 = *(void **)(a1 + 128);
    }
    if (v13 == v14)
    {
      if (v15 >= 0) {
        uint64_t v16 = (unsigned __int8 *)v4;
      }
      else {
        uint64_t v16 = (unsigned __int8 *)*v4;
      }
      if (v23 < 0)
      {
        if (!memcmp(__s1[0], v16, (size_t)__s1[1])) {
          goto LABEL_36;
        }
      }
      else
      {
        if (!HIBYTE(v23)) {
          goto LABEL_36;
        }
        uint64_t v17 = __s1;
        while (*(unsigned __int8 *)v17 == *v16)
        {
          uint64_t v17 = (void **)((char *)v17 + 1);
          ++v16;
          if (!--v12) {
            goto LABEL_36;
          }
        }
      }
    }
    unint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = **(PersonalityInfo ***)(a1 + 80);
      if (v19) {
        unint64_t v20 = (const char *)PersonalityInfo::logPrefix(v19);
      }
      else {
        unint64_t v20 = "-1";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sNeed to re-issue getPhoneServicesAccountStatus", buf, 0x16u);
    }
    (*(void (**)(uint64_t, void))(*(void *)a1 + 384))(a1, 0);
  }
LABEL_36:
  sub_1000558F4(&v21);
  if (SHIBYTE(v23) < 0) {
    operator delete(__s1[0]);
  }
}

void sub_100A2E654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A2E6A8(uint64_t a1)
{
  *(unsigned char *)(a1 + 354) = 1;
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

uint64_t sub_100A2E6B8(uint64_t a1)
{
  if (sub_100A2E718(a1)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 344))
  {
    if (*(unsigned char *)(a1 + 260))
    {
      uint64_t v3 = *(int *)(a1 + 256);
      if (v3 <= 2) {
        return dword_101528AA8[v3];
      }
    }
  }
  return 0;
}

BOOL sub_100A2E718(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 840) != 2) {
    goto LABEL_14;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v34 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v34);
  if (v8)
  {
    unsigned int v10 = (GestaltUtilityInterface *)v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v10 = 0;
  }
  std::mutex::unlock(v3);
  unsigned int v9 = 0;
LABEL_10:
  int isWatch = GestaltUtilityInterface::isWatch(v10);
  char v12 = isWatch;
  if (v9)
  {
    sub_10004D2C8(v9);
    if (v12)
    {
LABEL_12:
      CFStringRef v13 = @"EnableWiFiCallingWithoutEntitlementInStandaloneMode";
      goto LABEL_15;
    }
  }
  else if (isWatch)
  {
    goto LABEL_12;
  }
LABEL_14:
  CFStringRef v13 = @"EnableWiFiCallingWithoutEntitlement";
LABEL_15:
  char v14 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v15 = v14;
  if ((v16 & 0x8000000000000000) != 0)
  {
    uint64_t v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v18 = 5381;
    do
    {
      unint64_t v16 = v18;
      unsigned int v19 = *v17++;
      uint64_t v18 = (33 * v18) ^ v19;
    }
    while (v19);
  }
  std::mutex::lock(v14);
  unint64_t v34 = v16;
  unint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, &v34);
  if (v20)
  {
    int v22 = (GestaltUtilityInterface *)v20[3];
    __int16 v21 = (std::__shared_weak_count *)v20[4];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v15);
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v21);
      char v23 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    int v22 = 0;
  }
  std::mutex::unlock(v15);
  __int16 v21 = 0;
  char v23 = 1;
LABEL_23:
  int isIPhone = GestaltUtilityInterface::isIPhone(v22);
  uint64_t v25 = &kCFBooleanTrue;
  if (!isIPhone) {
    uint64_t v25 = &kCFBooleanFalse;
  }
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, const __CFString *, const CFBooleanRef))(*(void *)a1 + 472))(&cf, a1, v13, *v25);
  uint64_t v26 = (BOOL *)cf;
  LOBYTE(v34) = 0;
  if (cf && (CFTypeID v27 = CFGetTypeID(cf), v27 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)&v34, v26, v28);
    BOOL v29 = (_BYTE)v34 == 0;
  }
  else
  {
    BOOL v29 = 1;
  }
  sub_1000577C4(&cf);
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (v29) {
    return 0;
  }
  uint64_t v31 = sub_100046F68(a1 + 800, (void **)(**(void **)(a1 + 80) + 24));
  BOOL v32 = (void **)(a1 + 808) == v31 || ((_BYTE)v31[7] & 0x80) == 0;
  return (void **)(a1 + 808) != v31 && v32;
}

void sub_100A2E9BC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A2EA00(uint64_t a1)
{
  if (sub_100A2E718(a1)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 344))
  {
    if (*(unsigned char *)(a1 + 268))
    {
      uint64_t v3 = *(int *)(a1 + 264);
      if (v3 <= 2) {
        return dword_101528AA8[v3];
      }
    }
  }
  return 0;
}

uint64_t sub_100A2EA60(uint64_t a1)
{
  if (sub_100A2E718(a1)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 344))
  {
    if (*(unsigned char *)(a1 + 276))
    {
      uint64_t v3 = *(int *)(a1 + 272);
      if (v3 <= 4) {
        return dword_101528AB4[v3];
      }
    }
  }
  return 0;
}

BOOL sub_100A2EAC0(uint64_t a1, int a2)
{
  if (a2 == 5) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 344)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 276) && *(_DWORD *)(a1 + 272) == 3 || *(unsigned char *)(a1 + 268) && *(_DWORD *)(a1 + 264) == 3) {
    return 1;
  }
  return *(unsigned char *)(a1 + 260) && *(_DWORD *)(a1 + 256) == 3;
}

uint64_t sub_100A2EB20(uint64_t a1)
{
  int v2 = sub_100A2E6B8(a1);
  int v3 = sub_100A2EA00(a1);
  LODWORD(result) = sub_100A2EA60(a1);
  if (v3 >= v2) {
    int v5 = v2;
  }
  else {
    int v5 = v3;
  }
  if ((int)result >= v5) {
    return v5;
  }
  else {
    return result;
  }
}

uint64_t sub_100A2EB74(uint64_t a1, int a2, unsigned int a3)
{
  if (!*(unsigned char *)(**(void **)(a1 + 80) + 48)) {
    return 0;
  }
  if (a2 && sub_100A2EB20(a1) != 1
    || !*(unsigned char *)(a1 + 344)
    || !sub_100A2EE94(a1 + 144)
    || !*(unsigned char *)(a1 + 352))
  {
    if (*(unsigned char *)(a1 + 344) && sub_100A2EE94(a1 + 144))
    {
      int v6 = *(unsigned __int8 *)(a1 + 352);
      unsigned int v7 = *(NSObject **)(a1 + 40);
      BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      if (v6)
      {
        if (v8)
        {
          unsigned int v9 = **(PersonalityInfo ***)(a1 + 80);
          if (v9) {
            unsigned int v10 = (const char *)PersonalityInfo::logPrefix(v9);
          }
          else {
            unsigned int v10 = "-1";
          }
          int v19 = sub_100A2E6B8(a1);
          if (v19 == -1) {
            unint64_t v20 = "Incomplete";
          }
          else {
            unint64_t v20 = "Good";
          }
          if (v19) {
            __int16 v21 = v20;
          }
          else {
            __int16 v21 = "Pending";
          }
          int v22 = sub_100A2EA00(a1);
          if (v22 == -1) {
            char v23 = "Incomplete";
          }
          else {
            char v23 = "Good";
          }
          if (v22) {
            int v24 = v23;
          }
          else {
            int v24 = "Pending";
          }
          int v25 = sub_100A2EA60(a1);
          int v27 = 136316162;
          if (v25 == -1) {
            uint64_t v26 = "Incomplete";
          }
          else {
            uint64_t v26 = "Good";
          }
          CFBooleanRef v28 = v10;
          if (!v25) {
            uint64_t v26 = "Pending";
          }
          __int16 v29 = 2080;
          unsigned int v30 = " ";
          __int16 v31 = 2080;
          BOOL v32 = v21;
          __int16 v33 = 2080;
          unint64_t v34 = v24;
          __int16 v35 = 2080;
          unint64_t v36 = v26;
          char v14 = "#I %s%saccount status re-requested because: is911AddrStatusOK:%s, isTcStatusOK:%s, isAccountProvisioned:%s";
          int v15 = v7;
          uint32_t v16 = 52;
          goto LABEL_20;
        }
LABEL_21:
        (*(void (**)(uint64_t, void))(*(void *)a1 + 384))(a1, a2 | a3);
        goto LABEL_22;
      }
      if (!v8) {
        goto LABEL_21;
      }
      uint64_t v17 = **(PersonalityInfo ***)(a1 + 80);
      if (v17) {
        uint64_t v18 = (const char *)PersonalityInfo::logPrefix(v17);
      }
      else {
        uint64_t v18 = "-1";
      }
      int v27 = 136315394;
      CFBooleanRef v28 = v18;
      __int16 v29 = 2080;
      unsigned int v30 = " ";
      char v14 = "#I %s%saccount status need to be refreshed, it's time to";
    }
    else
    {
      unsigned int v7 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_21;
      }
      char v12 = **(PersonalityInfo ***)(a1 + 80);
      if (v12) {
        CFStringRef v13 = (const char *)PersonalityInfo::logPrefix(v12);
      }
      else {
        CFStringRef v13 = "-1";
      }
      int v27 = 136315394;
      CFBooleanRef v28 = v13;
      __int16 v29 = 2080;
      unsigned int v30 = " ";
      char v14 = "#I %s%saccount status is not present";
    }
    int v15 = v7;
    uint32_t v16 = 22;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v27, v16);
    goto LABEL_21;
  }
LABEL_22:
  (*(void (**)(uint64_t, void))(*(void *)a1 + 456))(a1, 0);
  return sub_100A2EB20(a1);
}

BOOL sub_100A2EE94(uint64_t a1)
{
  uint64_t v13 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  memset(v9, 0, sizeof(v9));
  long long v6 = 0u;
  *(_OWORD *)unsigned int v7 = 0u;
  *(_OWORD *)int v5 = 0u;
  sub_1000593FC((uint64_t)v5, (long long *)(a1 + 48));
  sub_1000593FC((uint64_t)v7, (long long *)(a1 + 80));
  v9[0] = *(_OWORD *)(a1 + 112);
  *(void *)((char *)v9 + 13) = *(void *)(a1 + 125);
  sub_1000593FC((uint64_t)&v9[1] + 8, (long long *)(a1 + 136));
  sub_1000593FC((uint64_t)&__p[1], (long long *)(a1 + 168));
  int v2 = BYTE4(v9[0]);
  int v3 = BYTE12(v9[0]);
  if ((_BYTE)v13 && SHIBYTE(v12) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && SHIBYTE(v10) < 0) {
    operator delete(*((void **)&v9[1] + 1));
  }
  if (BYTE8(v8) && SBYTE7(v8) < 0) {
    operator delete(v7[0]);
  }
  if (BYTE8(v6) && SBYTE7(v6) < 0) {
    operator delete(v5[0]);
  }
  return (v2 | v3) != 0;
}

void sub_100A2EFA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32)
{
  if (a32 && a31 < 0) {
    operator delete(__p);
  }
  if (a22 && a21 < 0) {
    operator delete(a16);
  }
  if (a15)
  {
    if (a14 < 0) {
      operator delete(a9);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100A2F004(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = **(PersonalityInfo ***)(a1 + 80);
    if (v3) {
      unint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
    }
    else {
      unint64_t v4 = "-1";
    }
    *(_DWORD *)uint32_t v16 = 136315394;
    *(void *)&v16[4] = v4;
    __int16 v17 = 2080;
    uint64_t v18 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%saccount status dropped", v16, 0x16u);
  }
  int v5 = (uint64_t *)*(unsigned __int8 *)(a1 + 344);
  if (*(unsigned char *)(a1 + 344))
  {
    sub_1001DFC34(a1 + 144);
    *(unsigned char *)(a1 + 344) = 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 48));
  unsigned int v7 = ServiceMap;
  if (v8 < 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint32_t v16 = v8;
  long long v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v16);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_16:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v14 + 32))(v14, **(void **)(a1 + 80) + 24, @"onfile.status", kPhoneServicesWalletDomain, 0, 4);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100A2F1E8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A2F218(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 344))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = **(PersonalityInfo ***)(a1 + 80);
      if (v3) {
        unint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
      }
      else {
        unint64_t v4 = "-1";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v4;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%saccount status result reset", buf, 0x16u);
    }
    char v15 = (_OWORD *)(a1 + 144);
    memset(v28, 0, sizeof(v28));
    *(_OWORD *)int v27 = 0u;
    if (*(char *)(a1 + 167) < 0)
    {
      sub_10004FC84(v27, *(void **)(a1 + 144), *(void *)(a1 + 152));
    }
    else
    {
      *(_OWORD *)int v27 = *v15;
      v28[0] = *(void **)(a1 + 160);
    }
    if (*(char *)(a1 + 191) < 0)
    {
      sub_10004FC84(&v28[1], *(void **)(a1 + 168), *(void *)(a1 + 176));
    }
    else
    {
      *(_OWORD *)&v28[1] = *(_OWORD *)(a1 + 168);
      v28[3] = *(void **)(a1 + 184);
    }
    uint64_t v40 = 0;
    *(_OWORD *)long long __p = 0u;
    long long v39 = 0u;
    *(_OWORD *)unint64_t v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    *(_OWORD *)__int16 v33 = 0u;
    long long v30 = 0u;
    *(_OWORD *)__int16 v31 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_1001DFA4C(a1 + 144, (long long *)buf);
    if ((_BYTE)v40 && SHIBYTE(v39) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && SHIBYTE(v37) < 0) {
      operator delete(v36[1]);
    }
    if (BYTE8(v34) && SBYTE7(v34) < 0) {
      operator delete(v33[0]);
    }
    if (BYTE8(v32) && SBYTE7(v32) < 0) {
      operator delete(v31[0]);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(*(void **)&buf[24]);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    std::string::operator=((std::string *)(a1 + 144), (const std::string *)v27);
    std::string::operator=((std::string *)(a1 + 168), (const std::string *)&v28[1]);
    if (SHIBYTE(v28[3]) < 0) {
      operator delete(v28[1]);
    }
    uint32_t v16 = (uint64_t *)SHIBYTE(v28[0]);
    if ((v16 & 0x80000000) != 0) {
      operator delete(v27[0]);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v16, *(Registry **)(a1 + 48));
    uint64_t v18 = ServiceMap;
    if (v19 < 0)
    {
      unint64_t v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        uint64_t v19 = v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v19;
    char v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
    if (v23)
    {
      uint64_t v24 = v23[3];
      long long v12 = (std::__shared_weak_count *)v23[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v25 = 0;
        goto LABEL_51;
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::mutex::unlock(v18);
    long long v12 = 0;
    char v25 = 1;
LABEL_51:
    uint64_t v26 = **(void **)(a1 + 80);
    sub_1003A8E80((uint64_t)v15, buf);
    (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, void, uint64_t, void))(*(void *)v24 + 16))(v24, v26 + 24, @"onfile.status", *(void *)buf, kPhoneServicesWalletDomain, 0, 4, 0);
    sub_100057D78((const void **)buf);
    if (v25) {
      return;
    }
    goto LABEL_52;
  }
  int v5 = (std::mutex *)Registry::getServiceMap((uint64_t *)*(unsigned __int8 *)(a1 + 344), *(Registry **)(a1 + 48));
  long long v6 = v5;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(v5);
  *(void *)long long buf = v7;
  unsigned int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  long long v12 = 0;
  char v14 = 1;
LABEL_13:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v13 + 32))(v13, **(void **)(a1 + 80) + 24, @"onfile.status", kPhoneServicesWalletDomain, 0, 4);
  if ((v14 & 1) == 0) {
LABEL_52:
  }
    sub_10004D2C8(v12);
}

void sub_100A2F654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A2F6CC(uint64_t a1, int a2, int **a3)
{
  switch(a2)
  {
    case 1:
      sub_100A2B760(a1 + 360, 0);
      break;
    case 2:
      int v9 = 0;
LABEL_26:
      int v8 = 0;
      return v9 | (v8 << 8);
    case 3:
      int v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        long long v6 = **(PersonalityInfo ***)(a1 + 80);
        if (v6) {
          uint64_t v7 = (const char *)PersonalityInfo::logPrefix(v6);
        }
        else {
          uint64_t v7 = "-1";
        }
        unsigned int v10 = sub_100FB56F4(**a3);
        int v17 = 136315650;
        uint64_t v18 = v7;
        __int16 v19 = 2080;
        unint64_t v20 = " ";
        __int16 v21 = 2080;
        unsigned int v22 = v10;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sentitlement response code %s", (uint8_t *)&v17, 0x20u);
      }
      int v11 = **a3;
      int v9 = 1;
      if ((v11 - 6000) <= 0x14)
      {
        if (((1 << (v11 - 112)) & 0x103F3E) != 0) {
          goto LABEL_21;
        }
        if (v11 == 6000)
        {
          sub_100A2BBB0(a1 + 360);
          int v8 = 1;
          return v9 | (v8 << 8);
        }
      }
      if ((v11 - 6300) >= 3 && v11 != 6201) {
        goto LABEL_26;
      }
LABEL_21:
      sub_100A2B760(a1 + 360, 0);
      *(unsigned char *)(a1 + 424) = 1;
      sub_100A2B860(a1 + 360);
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        char v14 = **(PersonalityInfo ***)(a1 + 80);
        if (v14) {
          char v15 = (const char *)PersonalityInfo::logPrefix(v14);
        }
        else {
          char v15 = "-1";
        }
        int v17 = 136315394;
        uint64_t v18 = v15;
        __int16 v19 = 2080;
        unint64_t v20 = " ";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sCarrier reported temporary failure, need to retry", (uint8_t *)&v17, 0x16u);
      }
      goto LABEL_26;
  }
  int v8 = 0;
  int v9 = 1;
  return v9 | (v8 << 8);
}

void sub_100A2F8EC(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(void *)(v3 + 440);
        *(void *)(v3 + 44ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        (*(void (**)(uint64_t, BOOL))(*(void *)v3 + 384))(v3, *(_DWORD *)(v3 + 736) != 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100A2F9C4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100A2F9D8(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(PersonalityInfo **)a1[10];
    if (v7) {
      int v8 = (const char *)PersonalityInfo::logPrefix(v7);
    }
    else {
      int v8 = "-1";
    }
    uint64_t v9 = asString();
    unsigned int v10 = "";
    int v13 = 136315906;
    char v14 = v8;
    uint32_t v16 = " ";
    __int16 v15 = 2080;
    if (a3) {
      unsigned int v10 = " with notify";
    }
    __int16 v17 = 2080;
    uint64_t v18 = v9;
    __int16 v19 = 2080;
    unint64_t v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sforceUpdateAccountStatus for %s%s", (uint8_t *)&v13, 0x2Au);
  }
  if (a3) {
    sub_100A37478(a1 + 78, a2, a2);
  }
  char v11 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 440))(a1, a2);
  char v12 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 384))(a1, 1);
  (*(void (**)(uint64_t *, uint64_t))(*a1 + 456))(a1, 1);
  if ((v11 & 1) == 0 && (v12 & 1) == 0)
  {
    if (a3)
    {
      sub_100A2FBE8(a1, a2);
      sub_100A2FD3C((uint64_t)a1, a2, 0);
    }
  }
}

uint64_t *sub_100A2FBE8(uint64_t *result, int a2)
{
  uint64_t v2 = result[79];
  if (v2)
  {
    unint64_t v4 = result;
    int v5 = (uint64_t **)(result + 78);
    uint64_t v6 = result + 79;
    do
    {
      int v7 = *(_DWORD *)(v2 + 28);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t *)v2;
      }
      else {
        uint64_t v9 = (uint64_t *)(v2 + 8);
      }
      if (!v8) {
        uint64_t v6 = (uint64_t *)v2;
      }
      uint64_t v2 = *v9;
    }
    while (*v9);
    if (v6 != result + 79 && *((_DWORD *)v6 + 7) <= a2)
    {
      unsigned int v10 = result[5];
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        char v11 = *(PersonalityInfo **)v4[10];
        if (v11) {
          char v12 = (const char *)PersonalityInfo::logPrefix(v11);
        }
        else {
          char v12 = "-1";
        }
        int v13 = 136315650;
        char v14 = v12;
        __int16 v15 = 2080;
        uint32_t v16 = " ";
        __int16 v17 = 2080;
        uint64_t v18 = asString();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%s%s, request found, notification forced", (uint8_t *)&v13, 0x20u);
      }
      sub_100A37530(v5, a2);
      return sub_100A37478(v4 + 75, a2, a2);
    }
  }
  return result;
}

void sub_100A2FD3C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = **(PersonalityInfo ***)(a1 + 80);
  if (*((unsigned char *)v6 + 48)) {
    goto LABEL_2;
  }
  __int16 v21 = *(NSObject **)(a1 + 40);
  BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (v22)
    {
      char v23 = (void **)PersonalityInfo::logPrefix(v6);
      uint64_t v24 = asString();
      uint64_t v25 = **(void **)(a1 + 80);
      CFBooleanRef v28 = *(const char **)(v25 + 24);
      uint64_t v26 = (const char *)(v25 + 24);
      int v27 = v28;
      uint64_t v29 = *((unsigned __int8 *)v26 + 23);
      int v30 = (char)v29;
      if ((v29 & 0x80u) != 0) {
        uint64_t v29 = *((void *)v26 + 1);
      }
      if (v30 < 0) {
        uint64_t v26 = v27;
      }
      if (!v29) {
        uint64_t v26 = "<invalid>";
      }
      LODWORD(keys[0]) = 136315906;
      *(void ***)((char *)keys + 4) = v23;
      WORD2(keys[1]) = 2080;
      *(void ***)((char *)&keys[1] + 6) = (void **)" ";
      HIWORD(keys[2]) = 2080;
      uint64_t v124 = v24;
      __int16 v125 = 2080;
      v126 = v26;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s%s capability notification and update forced for inactive personality %s", (uint8_t *)keys, 0x2Au);
    }
LABEL_2:
    uint64_t v120 = 0;
    CFDictionaryRef theDict = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 360))(&v120, a1, a2);
    uint64_t v118 = 0;
    CFDictionaryRef v119 = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 352))(&v118, a1, a2);
    CFMutableDictionaryRef v117 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      BOOL v8 = (void **)v117;
      CFMutableDictionaryRef v117 = Mutable;
      keys[0] = v8;
      sub_10005717C((const void **)keys);
    }
    if (theDict) {
      uint64_t v9 = sub_100080778;
    }
    else {
      uint64_t v9 = 0;
    }
    if (v9)
    {
      CFIndex Count = CFDictionaryGetCount(theDict);
      if (Count)
      {
        memset(keys, 0, sizeof(keys));
        sub_10019E8F0(keys, Count);
        values = 0;
        v115 = 0;
        uint64_t v116 = 0;
        sub_10004EE3C(&values, Count);
        CFDictionaryGetKeysAndValues(theDict, (const void **)keys[0], (const void **)values);
        if (Count >= 1)
        {
          for (uint64_t i = 0; i != Count; ++i)
            CFDictionaryAddValue(v117, keys[0][i], values[i]);
        }
        if (values)
        {
          v115 = values;
          operator delete(values);
        }
        if (keys[0])
        {
          keys[1] = keys[0];
          operator delete(keys[0]);
        }
      }
    }
    if (v119) {
      char v12 = sub_100080778;
    }
    else {
      char v12 = 0;
    }
    if (v12)
    {
      CFIndex v13 = CFDictionaryGetCount(v119);
      if (v13)
      {
        memset(keys, 0, sizeof(keys));
        sub_10019E8F0(keys, v13);
        values = 0;
        v115 = 0;
        uint64_t v116 = 0;
        sub_10004EE3C(&values, v13);
        CFDictionaryGetKeysAndValues(v119, (const void **)keys[0], (const void **)values);
        if (v13 >= 1)
        {
          for (uint64_t j = 0; j != v13; ++j)
            CFDictionaryAddValue(v117, keys[0][j], values[j]);
        }
        if (values)
        {
          v115 = values;
          operator delete(values);
        }
        if (keys[0])
        {
          keys[1] = keys[0];
          operator delete(keys[0]);
        }
      }
    }
    if ((_BYTE)v120) {
      CFBooleanRef v15 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v15 = kCFBooleanFalse;
    }
    CFDictionarySetValue(v117, kCTCapabilityCanSet, v15);
    if ((_BYTE)v118) {
      CFBooleanRef v16 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v16 = kCFBooleanFalse;
    }
    CFDictionarySetValue(v117, kCTCapabilityStatus, v16);
    xpc_object_t value = 0;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 432))(&value, a1, a2);
    if (value) {
      __int16 v17 = sub_100080778;
    }
    else {
      __int16 v17 = 0;
    }
    if (v17) {
      CFDictionaryAddValue(v117, kPSAccountDetails, value);
    }
    CFMutableDictionaryRef v112 = 0;
    uint64_t v18 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v18)
    {
      __int16 v19 = (void **)v112;
      CFMutableDictionaryRef v112 = v18;
      keys[0] = v19;
      sub_10005717C((const void **)keys);
    }
    switch((int)a2)
    {
      case 0:
        unint64_t v20 = (const void **)&kCTCapabilityAgent2;
        goto LABEL_66;
      case 1:
        unint64_t v20 = (const void **)&kCTCapabilityPhoneServices;
        goto LABEL_66;
      case 2:
        unint64_t v20 = (const void **)&kCTCapabilityAgent;
        goto LABEL_66;
      case 3:
        unint64_t v20 = (const void **)&kCTCapabilityAgent3;
        goto LABEL_66;
      case 4:
        unint64_t v20 = (const void **)&kCTCapabilityNetworkSlicing;
        goto LABEL_66;
      case 5:
        unint64_t v20 = (const void **)&kCTCapabilitySatellite;
LABEL_66:
        long long v39 = *v20;
        break;
      default:
        long long v39 = 0;
        break;
    }
    CFDictionarySetValue(v112, v39, v117);
    std::mutex::lock((std::mutex *)(a1 + 448));
    uint64_t v40 = (uint64_t **)(a1 + 520);
    uint64_t v41 = *(void *)(a1 + 520);
    if (!v41) {
      goto LABEL_77;
    }
    uint64_t v42 = a1 + 520;
    do
    {
      int v43 = *(_DWORD *)(v41 + 32);
      BOOL v44 = v43 < (int)a2;
      if (v43 >= (int)a2) {
        uint64_t v45 = (uint64_t *)v41;
      }
      else {
        uint64_t v45 = (uint64_t *)(v41 + 8);
      }
      if (!v44) {
        uint64_t v42 = v41;
      }
      uint64_t v41 = *v45;
    }
    while (*v45);
    if ((uint64_t **)v42 != v40 && *(_DWORD *)(v42 + 32) <= (int)a2)
    {
      if (CFEqual(*(CFTypeRef *)(v42 + 40), v112))
      {
        uint64_t v56 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v57 = **(PersonalityInfo ***)(a1 + 80);
          if (v57) {
            uint64_t v58 = (void **)PersonalityInfo::logPrefix(v57);
          }
          else {
            uint64_t v58 = (void **)"-1";
          }
          uint64_t v111 = asString();
          LODWORD(keys[0]) = 136315650;
          *(void ***)((char *)keys + 4) = v58;
          WORD2(keys[1]) = 2080;
          *(void ***)((char *)&keys[1] + 6) = (void **)" ";
          HIWORD(keys[2]) = 2080;
          uint64_t v124 = v111;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I %s%skCTEventCallCapabilitiesChanged.%s - no changes", (uint8_t *)keys, 0x20u);
        }
        std::mutex::unlock((std::mutex *)(a1 + 448));
        int v84 = 0;
LABEL_148:
        uint64_t v85 = *(void *)(a1 + 608);
        if (v85)
        {
          uint64_t v86 = a1 + 608;
          do
          {
            int v87 = *(_DWORD *)(v85 + 28);
            BOOL v88 = v87 < (int)a2;
            if (v87 >= (int)a2) {
              v89 = (uint64_t *)v85;
            }
            else {
              v89 = (uint64_t *)(v85 + 8);
            }
            if (!v88) {
              uint64_t v86 = v85;
            }
            uint64_t v85 = *v89;
          }
          while (*v89);
          if (v86 != a1 + 608 && *(_DWORD *)(v86 + 28) <= (int)a2) {
            goto LABEL_169;
          }
        }
        if ((v84 | a3) != 1) {
          goto LABEL_194;
        }
        uint64_t v90 = *(void *)(a1 + 632);
        if (!v90) {
          goto LABEL_169;
        }
        uint64_t v91 = a1 + 632;
        do
        {
          int v92 = *(_DWORD *)(v90 + 28);
          BOOL v93 = v92 < (int)a2;
          if (v92 >= (int)a2) {
            uint64_t v94 = (uint64_t *)v90;
          }
          else {
            uint64_t v94 = (uint64_t *)(v90 + 8);
          }
          if (!v93) {
            uint64_t v91 = v90;
          }
          uint64_t v90 = *v94;
        }
        while (*v94);
        if (v91 == a1 + 632 || *(_DWORD *)(v91 + 28) > (int)a2)
        {
LABEL_169:
          sub_100A37530((uint64_t **)(a1 + 600), a2);
          uint64_t v96 = **(PersonalityInfo ***)(a1 + 80);
          if (*((_DWORD *)v96 + 13) != 2)
          {
            ctu::cf_to_xpc((uint64_t *)keys, v112, v95);
            v97 = (void **)xpc_null_create();
            values = v97;
            sub_1000452AC(82, (xpc_object_t *)keys, (xpc_object_t *)&values);
            xpc_release(v97);
            xpc_release(keys[0]);
            uint64_t v96 = **(PersonalityInfo ***)(a1 + 80);
          }
          uint64_t v98 = *(void *)(a1 + 768);
          PersonalityInfo::uuid((uint64_t *)keys, v96);
          (*(void (**)(uint64_t, void **, CFMutableDictionaryRef))(*(void *)v98 + 16))(v98, keys[0], v112);
          sub_10012577C((const void **)keys);
          v99 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_187;
          }
          uint64_t v100 = **(PersonalityInfo ***)(a1 + 80);
          if (v100) {
            v101 = (void **)PersonalityInfo::logPrefix(v100);
          }
          else {
            v101 = (void **)"-1";
          }
          uint64_t v105 = asString();
          uint64_t v106 = "requested";
          LODWORD(keys[0]) = 136315906;
          *(void ***)((char *)keys + 4) = v101;
          if (a3) {
            uint64_t v106 = "forced";
          }
          WORD2(keys[1]) = 2080;
          *(void ***)((char *)&keys[1] + 6) = (void **)" ";
          HIWORD(keys[2]) = 2080;
          uint64_t v124 = v105;
          if (v84) {
            uint64_t v106 = "update";
          }
          __int16 v125 = 2080;
          v126 = v106;
          v107 = "#I %s%skCTEventCallCapabilitiesChanged.%s notification sent, reason: %s";
          v108 = v99;
          uint32_t v109 = 42;
        }
        else
        {
LABEL_194:
          if (!v84) {
            goto LABEL_187;
          }
          v102 = *(NSObject **)(a1 + 40);
          if (!os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_187;
          }
          uint64_t v103 = **(PersonalityInfo ***)(a1 + 80);
          if (v103) {
            uint64_t v104 = (void **)PersonalityInfo::logPrefix(v103);
          }
          else {
            uint64_t v104 = (void **)"-1";
          }
          uint64_t v110 = asString();
          LODWORD(keys[0]) = 136315650;
          *(void ***)((char *)keys + 4) = v104;
          WORD2(keys[1]) = 2080;
          *(void ***)((char *)&keys[1] + 6) = (void **)" ";
          HIWORD(keys[2]) = 2080;
          uint64_t v124 = v110;
          v107 = "#I %s%skCTEventCallCapabilitiesChanged.%s notification suppressed";
          v108 = v102;
          uint32_t v109 = 32;
        }
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, v107, (uint8_t *)keys, v109);
LABEL_187:
        sub_10005717C((const void **)&v112);
        sub_100057D78((const void **)&value);
        sub_10005717C((const void **)&v117);
        sub_100057D78((const void **)&v119);
        sub_100057D78((const void **)&theDict);
        return;
      }
      CFDictionaryRef v46 = *(const __CFDictionary **)(v42 + 40);
      if (a2) {
        goto LABEL_78;
      }
    }
    else
    {
LABEL_77:
      CFDictionaryRef v46 = 0;
      if (a2) {
        goto LABEL_78;
      }
    }
    if (v46)
    {
      CFDictionaryRef v59 = (const __CFDictionary *)CFDictionaryGetValue(v46, kCTCapabilityAgent2);
      CFDictionaryRef v60 = v59;
      if (!v59) {
        goto LABEL_105;
      }
      CFTypeID v61 = CFGetTypeID(v59);
      if (v61 == CFDictionaryGetTypeID())
      {
        CFDictionaryRef v62 = (const __CFDictionary *)CFDictionaryGetValue(v60, kCTProvisioningURL);
        CFDictionaryRef v60 = v62;
        if (v62)
        {
          CFTypeID v63 = CFGetTypeID(v62);
          if (v63 != CFDictionaryGetTypeID()) {
            CFDictionaryRef v60 = 0;
          }
        }
LABEL_105:
        if (v112
          && (CFDictionaryRef v64 = (const __CFDictionary *)CFDictionaryGetValue(v112, kCTCapabilityAgent2), (v65 = v64) != 0)
          && (CFTypeID v66 = CFGetTypeID(v64), v66 == CFDictionaryGetTypeID())
          && (uint64_t v67 = CFDictionaryGetValue(v65, kCTProvisioningURL), (v68 = (const __CFDictionary *)v67) != 0))
        {
          CFTypeID v69 = CFGetTypeID(v67);
          if (v69 == CFDictionaryGetTypeID()) {
            CFDictionaryRef v70 = v68;
          }
          else {
            CFDictionaryRef v70 = 0;
          }
        }
        else
        {
          CFDictionaryRef v70 = 0;
        }
        if (v60 != v70 && (!v60 || !v70 || !CFEqual(v60, v70)))
        {
          int v47 = 1;
LABEL_79:
          uint64_t v48 = *v40;
          if (*v40)
          {
            uint64_t v49 = (uint64_t *)(a1 + 520);
            uint64_t v50 = *v40;
            do
            {
              int v51 = *((_DWORD *)v50 + 8);
              BOOL v52 = v51 < (int)a2;
              if (v51 >= (int)a2) {
                unint64_t v53 = (uint64_t **)v50;
              }
              else {
                unint64_t v53 = (uint64_t **)(v50 + 1);
              }
              if (!v52) {
                uint64_t v49 = v50;
              }
              uint64_t v50 = *v53;
            }
            while (*v53);
            if (v49 != (uint64_t *)v40 && *((_DWORD *)v49 + 8) <= (int)a2)
            {
              uint64_t v54 = (uint64_t *)v49[1];
              if (v54)
              {
                do
                {
                  unsigned int v55 = v54;
                  uint64_t v54 = (uint64_t *)*v54;
                }
                while (v54);
              }
              else
              {
                BOOL v71 = v49;
                do
                {
                  unsigned int v55 = (uint64_t *)v71[2];
                  BOOL v72 = *v55 == (void)v71;
                  BOOL v71 = v55;
                }
                while (!v72);
              }
              if (*(uint64_t **)(a1 + 512) == v49) {
                *(void *)(a1 + 512) = v55;
              }
              --*(void *)(a1 + 528);
              sub_10005EE6C(v48, v49);
              sub_100057D78((const void **)v49 + 5);
              operator delete(v49);
            }
          }
          LODWORD(keys[0]) = a2;
          sub_10004EFE4(&keys[1], (CFTypeRef *)&v112);
          int v73 = (int)keys[0];
          int64_t v74 = *v40;
          CFIndex v75 = (uint64_t **)(a1 + 520);
          if (*v40)
          {
            while (1)
            {
              while (1)
              {
                CFIndex v75 = (uint64_t **)v74;
                int v76 = *((_DWORD *)v74 + 8);
                if (v76 <= SLODWORD(keys[0])) {
                  break;
                }
                int64_t v74 = *v75;
                uint64_t v40 = v75;
                if (!*v75) {
                  goto LABEL_131;
                }
              }
              if (v76 >= SLODWORD(keys[0])) {
                break;
              }
              int64_t v74 = v75[1];
              if (!v74)
              {
                uint64_t v40 = v75 + 1;
                goto LABEL_131;
              }
            }
          }
          else
          {
LABEL_131:
            unint64_t v77 = (void ***)operator new(0x30uLL);
            *((_DWORD *)v77 + 8) = v73;
            v77[5] = keys[1];
            keys[1] = 0;
            NSObject *v77 = 0;
            v77[1] = 0;
            v77[2] = (void **)v75;
            std::__shared_weak_count *v40 = (uint64_t *)v77;
            uint64_t v78 = **(void **)(a1 + 512);
            if (v78)
            {
              *(void *)(a1 + 512) = v78;
              unint64_t v77 = (void ***)*v40;
            }
            sub_100046C90(*(uint64_t **)(a1 + 520), (uint64_t *)v77);
            ++*(void *)(a1 + 528);
          }
          uint64_t v79 = sub_100057D78((const void **)&keys[1]);
          if (a2 == 1 && capabilities::ct::supportsThumperSourcing((capabilities::ct *)v79)) {
            sub_100A3112C();
          }
          uint64_t v80 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            v81 = **(PersonalityInfo ***)(a1 + 80);
            if (v81) {
              uint64_t v82 = (void **)PersonalityInfo::logPrefix(v81);
            }
            else {
              uint64_t v82 = (void **)"-1";
            }
            uint64_t v83 = asString();
            LODWORD(keys[0]) = 136315650;
            *(void ***)((char *)keys + 4) = v82;
            WORD2(keys[1]) = 2080;
            *(void ***)((char *)&keys[1] + 6) = (void **)" ";
            HIWORD(keys[2]) = 2080;
            uint64_t v124 = v83;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "#I %s%skCTEventCallCapabilitiesChanged.%s changed", (uint8_t *)keys, 0x20u);
            std::mutex::unlock((std::mutex *)(a1 + 448));
            if (v47) {
              goto LABEL_144;
            }
          }
          else
          {
            std::mutex::unlock((std::mutex *)(a1 + 448));
            if (v47)
            {
LABEL_144:
              values = 0;
              write_rest_value();
              sub_100058DB0(keys, "/cc/events/ps_account_provisioning_url_changed");
              xpc_object_t object = values;
              values = (void **)xpc_null_create();
              ctu::RestModule::sendEvent();
              xpc_release(object);
              xpc_object_t object = 0;
              if (SHIBYTE(keys[2]) < 0) {
                operator delete(keys[0]);
              }
              xpc_release(values);
            }
          }
          int v84 = 1;
          goto LABEL_148;
        }
LABEL_78:
        int v47 = 0;
        goto LABEL_79;
      }
    }
    CFDictionaryRef v60 = 0;
    goto LABEL_105;
  }
  if (v22)
  {
    __int16 v31 = (void **)PersonalityInfo::logPrefix(v6);
    uint64_t v32 = asString();
    uint64_t v33 = **(void **)(a1 + 80);
    unint64_t v36 = *(const char **)(v33 + 24);
    long long v34 = (const char *)(v33 + 24);
    long long v35 = v36;
    uint64_t v37 = *((unsigned __int8 *)v34 + 23);
    int v38 = (char)v37;
    if ((v37 & 0x80u) != 0) {
      uint64_t v37 = *((void *)v34 + 1);
    }
    if (v38 < 0) {
      long long v34 = v35;
    }
    if (!v37) {
      long long v34 = "<invalid>";
    }
    LODWORD(keys[0]) = 136315906;
    *(void ***)((char *)keys + 4) = v31;
    WORD2(keys[1]) = 2080;
    *(void ***)((char *)&keys[1] + 6) = (void **)" ";
    HIWORD(keys[2]) = 2080;
    uint64_t v124 = v32;
    __int16 v125 = 2080;
    v126 = v34;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%s%s capability notification and update are suppressed because personality %s is inactive", (uint8_t *)keys, 0x2Au);
  }
}

void sub_100A30A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, const void **a9, const void *a10, const void *a11, void *__p, uint64_t a13, uint64_t a14, const void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20,xpc_object_t object,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  std::mutex::unlock(v26);
  sub_10005717C(&a10);
  sub_100057D78(&a11);
  sub_10005717C(&a15);
  sub_100057D78(a9);
  sub_100057D78(v27);
  _Unwind_Resume(a1);
}

const void **sub_100A30BFC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  uint64_t result = (const void **)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v5 = (__CFDictionary *)result;
  if (result)
  {
    *a2 = result;
    *(void *)&long long v28 = 0;
    uint64_t result = sub_10005717C((const void **)&v28);
  }
  if (*(unsigned char *)(a1 + 344))
  {
    uint64_t result = (const void **)sub_100A2E718(a1);
    if ((result & 1) == 0)
    {
      if (sub_100A2EB20(a1) == 1)
      {
        (*(void (**)(long long *__return_ptr, uint64_t, const __CFString *, void))(*(void *)a1 + 472))(&v28, a1, @"AlwaysShowAddressUpdateButton", 0);
        uint64_t v6 = (BOOL *)v28;
        LOBYTE(__p[0]) = 0;
        if (!(void)v28 || (CFTypeID v7 = CFGetTypeID((CFTypeRef)v28), v7 != CFBooleanGetTypeID()))
        {
          sub_1000577C4((const void **)&v28);
LABEL_11:
          uint64_t result = (const void **)sub_100A2E718(a1);
          if ((result & 1) != 0
            || *(unsigned char *)(a1 + 344) && *(unsigned char *)(a1 + 260) && *(_DWORD *)(a1 + 256) == 2)
          {
            return result;
          }
          goto LABEL_15;
        }
        ctu::cf::assign((ctu::cf *)__p, v6, v8);
        int v9 = LOBYTE(__p[0]);
        sub_1000577C4((const void **)&v28);
        if (!v9) {
          goto LABEL_11;
        }
      }
LABEL_15:
      CFMutableDictionaryRef theDict = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFMutableDictionaryRef v11 = theDict;
        CFMutableDictionaryRef theDict = Mutable;
        *(void *)&long long v28 = v11;
        sub_10005717C((const void **)&v28);
      }
      if (*(unsigned char *)(a1 + 216))
      {
        char v12 = theDict;
        if (*(char *)(a1 + 215) < 0)
        {
          sub_10004FC84(__dst, *(void **)(a1 + 192), *(void *)(a1 + 200));
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 192);
          uint64_t v22 = *(void *)(a1 + 208);
        }
        if (SHIBYTE(v22) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v27 = v22;
        }
        uint64_t v25 = 0;
        if (SHIBYTE(v27) < 0)
        {
          sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          long long v28 = *(_OWORD *)__p;
          uint64_t v29 = v27;
        }
        int v30 = 0;
        if (ctu::cf::convert_copy())
        {
          CFIndex v13 = v25;
          uint64_t v25 = v30;
          __int16 v31 = v13;
          sub_1000558F4((const void **)&v31);
        }
        char v14 = (const void *)kCTWebSheetURL;
        if (SHIBYTE(v29) < 0) {
          operator delete((void *)v28);
        }
        xpc_object_t value = v25;
        uint64_t v25 = 0;
        sub_1000558F4((const void **)&v25);
        if (SHIBYTE(v27) < 0) {
          operator delete(__p[0]);
        }
        CFDictionarySetValue(v12, v14, value);
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(v22) < 0) {
          operator delete(__dst[0]);
        }
        if (*(unsigned char *)(a1 + 248))
        {
          if (*(char *)(a1 + 247) < 0)
          {
            sub_10004FC84(v18, *(void **)(a1 + 224), *(void *)(a1 + 232));
          }
          else
          {
            *(_OWORD *)uint64_t v18 = *(_OWORD *)(a1 + 224);
            uint64_t v19 = *(void *)(a1 + 240);
          }
          if (SHIBYTE(v19) < 0)
          {
            sub_10004FC84(__p, v18[0], (unint64_t)v18[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v18;
            uint64_t v27 = v19;
          }
          uint64_t v25 = 0;
          if (SHIBYTE(v27) < 0)
          {
            sub_10004FC84(&v28, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            long long v28 = *(_OWORD *)__p;
            uint64_t v29 = v27;
          }
          int v30 = 0;
          if (ctu::cf::convert_copy())
          {
            CFBooleanRef v15 = v25;
            uint64_t v25 = v30;
            __int16 v31 = v15;
            sub_1000558F4((const void **)&v31);
          }
          if (SHIBYTE(v29) < 0) {
            operator delete((void *)v28);
          }
          CFStringRef v16 = v25;
          unint64_t v20 = v25;
          uint64_t v25 = 0;
          sub_1000558F4((const void **)&v25);
          if (SHIBYTE(v27) < 0) {
            operator delete(__p[0]);
          }
          CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, v16, 0x600u, 0);
          xpc_object_t value = ExternalRepresentation;
          sub_1000558F4((const void **)&v20);
          if (SHIBYTE(v19) < 0) {
            operator delete(v18[0]);
          }
          CFDictionarySetValue(theDict, kCTWebSheetPostData, ExternalRepresentation);
          sub_100030068((const void **)&value);
        }
        CFDictionarySetValue(v5, kCTProvisioningURL, theDict);
      }
      return sub_10005717C((const void **)&theDict);
    }
  }
  return result;
}

void sub_100A31020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,const void *a24,const void *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_1000558F4(&a25);
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10005717C(&a24);
  sub_10005717C(v31);
  _Unwind_Resume(a1);
}

void sub_100A3112C()
{
}

void sub_100A3186C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char *a25)
{
  if (v27 < 0) {
    operator delete(v26);
  }
  a25 = &a13;
  sub_100047F64((void ***)&a25);
  sub_10004D2C8(v25);
  _Unwind_Resume(a1);
}

void sub_100A31974(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (std::mutex *)(a1 + 448);
  std::mutex::lock((std::mutex *)(a1 + 448));
  CFDictionaryRef v24 = 0;
  uint64_t v7 = *(void *)(a1 + 520);
  if (v7)
  {
    uint64_t v8 = a1 + 520;
    do
    {
      int v9 = *(_DWORD *)(v7 + 32);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        CFMutableDictionaryRef v11 = (uint64_t *)v7;
      }
      else {
        CFMutableDictionaryRef v11 = (uint64_t *)(v7 + 8);
      }
      if (!v10) {
        uint64_t v8 = v7;
      }
      uint64_t v7 = *v11;
    }
    while (*v11);
    if (v8 != a1 + 520 && *(_DWORD *)(v8 + 32) <= a2)
    {
      CFDictionaryRef theDict = 0;
      sub_100058198((const void **)&theDict, (const void **)(v8 + 40));
      if (theDict) {
        char v14 = sub_100080778;
      }
      else {
        char v14 = 0;
      }
      if (v14)
      {
        switch(a2)
        {
          case 0:
            CFBooleanRef v15 = (const void **)&kCTCapabilityAgent2;
            goto LABEL_25;
          case 1:
            CFBooleanRef v15 = (const void **)&kCTCapabilityPhoneServices;
            goto LABEL_25;
          case 2:
            CFBooleanRef v15 = (const void **)&kCTCapabilityAgent;
            goto LABEL_25;
          case 3:
            CFBooleanRef v15 = (const void **)&kCTCapabilityAgent3;
            goto LABEL_25;
          case 4:
            CFBooleanRef v15 = (const void **)&kCTCapabilityNetworkSlicing;
            goto LABEL_25;
          case 5:
            CFBooleanRef v15 = (const void **)&kCTCapabilitySatellite;
LABEL_25:
            CFStringRef v16 = *v15;
            break;
          default:
            CFStringRef v16 = 0;
            break;
        }
        CFTypeRef Value = CFDictionaryGetValue(theDict, v16);
        CFDictionaryRef v25 = 0;
        sub_10004EFE4(&v25, &Value);
        CFDictionaryRef v17 = v24;
        CFDictionaryRef v24 = v25;
        CFDictionaryRef v25 = v17;
        sub_100057D78((const void **)&v25);
        if (v24 ? sub_100080778 : 0)
        {
          uint64_t v19 = (BOOL *)CFDictionaryGetValue(v24, kCTCapabilityCanSet);
          CFIndex v13 = v19;
          LOBYTE(v25) = 0;
          if (!v19)
          {
LABEL_34:
            sub_100057D78((const void **)&theDict);
            char v12 = 1;
            goto LABEL_12;
          }
          CFTypeID v20 = CFGetTypeID(v19);
          if (v20 == CFBooleanGetTypeID())
          {
            ctu::cf::assign((ctu::cf *)&v25, v13, v21);
            LOBYTE(v13) = (_BYTE)v25;
            goto LABEL_34;
          }
        }
      }
      LOBYTE(v13) = 0;
      goto LABEL_34;
    }
  }
  char v12 = 0;
  LOBYTE(v13) = 0;
LABEL_12:
  *(unsigned char *)a3 = (_BYTE)v13;
  sub_100058198((const void **)(a3 + 8), (const void **)&v24);
  *(unsigned char *)(a3 + 16) = v12;
  sub_100057D78((const void **)&v24);
  std::mutex::unlock(v6);
}

void sub_100A31B78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  unint64_t v4 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void sub_100A31BB8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = **(PersonalityInfo ***)(a1 + 80);
    if (v3) {
      unint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
    }
    else {
      unint64_t v4 = "-1";
    }
    if (*(char *)(a1 + 767) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 744), *(void *)(a1 + 752));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 744);
      uint64_t v22 = *(void *)(a1 + 760);
    }
    int v5 = (void **)__p[0];
    if (v22 >= 0) {
      int v5 = __p;
    }
    uint64_t v6 = (void *)(a1 + 120);
    if (*(char *)(a1 + 143) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v24 = 2080;
    CFDictionaryRef v25 = v5;
    __int16 v26 = 2080;
    int v27 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fHardware: '%s', fDisplayName: '%s'", buf, 0x2Au);
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = **(PersonalityInfo ***)(a1 + 80);
    if (v7) {
      uint64_t v8 = (const char *)PersonalityInfo::logPrefix(v7);
    }
    else {
      uint64_t v8 = "-1";
    }
    sub_1003A8E80(a1 + 144, __p);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v24 = 2112;
    CFDictionaryRef v25 = __p[0];
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fAddr911Status: '%@'", buf, 0x20u);
    sub_100057D78((const void **)__p);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = **(PersonalityInfo ***)(a1 + 80);
    if (v9) {
      BOOL v10 = (const char *)PersonalityInfo::logPrefix(v9);
    }
    else {
      BOOL v10 = "-1";
    }
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 352));
    uint64_t v12 = asStringBool(*(unsigned char *)(a1 + 353));
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v10;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v24 = 2080;
    CFDictionaryRef v25 = (unsigned char *)v11;
    __int16 v26 = 2080;
    int v27 = (void *)v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fAddr911RefreshedOnBoot: %s, fAwaitingGetPSAS: %s", buf, 0x2Au);
  }
  std::mutex::lock((std::mutex *)(a1 + 448));
  CFIndex v13 = *(void **)(a1 + 512);
  if (v13 != (void *)(a1 + 520))
  {
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      LODWORD(__p[0]) = *((_DWORD *)v13 + 8);
      sub_100058198((const void **)&__p[1], (const void **)v13 + 5);
      char v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        CFBooleanRef v15 = **(PersonalityInfo ***)(a1 + 80);
        if (v15) {
          CFStringRef v16 = (const char *)PersonalityInfo::logPrefix(v15);
        }
        else {
          CFStringRef v16 = "-1";
        }
        uint64_t v17 = asString();
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v16;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        __int16 v24 = 2080;
        CFDictionaryRef v25 = (unsigned char *)v17;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%s| %s:", buf, 0x20u);
      }
      *(void *)long long buf = off_101A2E758;
      *(void *)&uint8_t buf[8] = a1;
      CFDictionaryRef v25 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      sub_100057D78((const void **)&__p[1]);
      uint64_t v18 = (void *)v13[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v13[2];
          BOOL v20 = *v19 == (void)v13;
          CFIndex v13 = v19;
        }
        while (!v20);
      }
      CFIndex v13 = v19;
    }
    while (v19 != (void *)(a1 + 520));
  }
  std::mutex::unlock((std::mutex *)(a1 + 448));
}

void sub_100A31FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t sub_100A31FE4(uint64_t a1, int a2)
{
  unint64_t v4 = (std::mutex *)(a1 + 648);
  std::mutex::lock((std::mutex *)(a1 + 648));
  uint64_t v5 = *(void *)(a1 + 720);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 720;
  do
  {
    int v7 = *(_DWORD *)(v5 + 28);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 720 && *(_DWORD *)(v6 + 28) <= a2) {
    uint64_t v10 = (*(_DWORD *)(v6 + 32) != 0) | ((*(_DWORD *)(v6 + 32) == 2) << 8) | (*(unsigned __int8 *)(v6 + 36) << 16);
  }
  else {
LABEL_11:
  }
    uint64_t v10 = 0;
  std::mutex::unlock(v4);
  return v10;
}

void sub_100A32090(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = (std::mutex *)(a1 + 448);
  std::mutex::lock((std::mutex *)(a1 + 448));
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 536);
  *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 540);
  sub_1000593FC(a2 + 8, (long long *)(a1 + 544));

  std::mutex::unlock(v4);
}

void sub_100A320F8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100A3210C(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v6 = (std::mutex *)(a1 + 448);
  std::mutex::lock((std::mutex *)(a1 + 448));
  uint64_t v7 = *(void *)(a1 + 584);
  if (!v7) {
    goto LABEL_11;
  }
  uint64_t v8 = a1 + 584;
  do
  {
    int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 < a2;
    if (v9 >= a2) {
      uint64_t v11 = (uint64_t *)v7;
    }
    else {
      uint64_t v11 = (uint64_t *)(v7 + 8);
    }
    if (!v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }
  while (*v11);
  if (v8 != a1 + 584 && *(_DWORD *)(v8 + 32) <= a2)
  {
    uint64_t v13 = *(void *)(v8 + 40);
    uint64_t v12 = *(void *)(v8 + 48);
    *a3 = v13;
    a3[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    sub_100A2DCB4(a2, (uint64_t)a3);
  }

  std::mutex::unlock(v6);
}

void sub_100A321C4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_100A321D8(uint64_t a1, int a2, uint64_t **a3)
{
  int v26 = a2;
  uint64_t v5 = *(void *)(a1 + 104);
  if (v5)
  {
    uint64_t v6 = a1 + 104;
    do
    {
      int v7 = *(_DWORD *)(v5 + 32);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        int v9 = (uint64_t *)v5;
      }
      else {
        int v9 = (uint64_t *)(v5 + 8);
      }
      if (!v8) {
        uint64_t v6 = v5;
      }
      uint64_t v5 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 104 && *(_DWORD *)(v6 + 32) <= a2)
    {
      uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(v6 + 40) + 88))(*(void *)(v6 + 40));
      std::mutex::lock((std::mutex *)(a1 + 648));
      int v27 = &v26;
      uint64_t v11 = sub_1001E2DA0((uint64_t **)(a1 + 712), &v26, (uint64_t)&unk_10144E20E, &v27);
      *((_DWORD *)v11 + 8) = v10;
      *((unsigned char *)v11 + 36) = BYTE4(v10);
      std::mutex::unlock((std::mutex *)(a1 + 648));
    }
  }
  std::mutex::lock((std::mutex *)(a1 + 448));
  uint64_t v12 = sub_100256E84((uint64_t **)(a1 + 576), v26, &v26);
  char v14 = *a3;
  uint64_t v13 = a3[1];
  if (v13) {
    atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
  }
  CFBooleanRef v15 = (std::__shared_weak_count *)v12[6];
  v12[5] = v14;
  v12[6] = v13;
  if (v15) {
    sub_10004D2C8(v15);
  }
  std::mutex::unlock((std::mutex *)(a1 + 448));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v17 = ServiceMap;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(ServiceMap);
  int v27 = (int *)v18;
  uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&v27);
  if (v22)
  {
    uint64_t v24 = v22[3];
    char v23 = (std::__shared_weak_count *)v22[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v17);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v25 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v24 = 0;
  }
  std::mutex::unlock(v17);
  char v23 = 0;
  char v25 = 1;
LABEL_24:
  (*(void (**)(uint64_t))(*(void *)v24 + 32))(v24);
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
}

void sub_100A323E0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A32410@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t result = a1 + 104;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = result;
  do
  {
    int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v4;
    }
    else {
      int v9 = (uint64_t *)(v4 + 8);
    }
    if (!v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 != result && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v11 = *(void *)(v6 + 40);
    uint64_t v10 = *(void *)(v6 + 48);
    *a3 = v11;
    a3[1] = v10;
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

BOOL sub_100A32470(uint64_t a1)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)a1 + 472))(&cf);
  CFArrayRef v2 = (const __CFArray *)cf;
  if (cf) {
    uint64_t v3 = sub_100080934;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    long long v22 = 0uLL;
    uint64_t v23 = 0;
    if (cf)
    {
      CFTypeID v4 = CFGetTypeID(cf);
      if (v4 == CFArrayGetTypeID())
      {
        memset(buf, 0, 24);
        context = buf;
        v34.length = CFArrayGetCount(v2);
        v34.location = 0;
        CFArrayApplyFunction(v2, v34, (CFArrayApplierFunction)sub_100449508, &context);
        long long v5 = v22;
        long long v22 = *(_OWORD *)buf;
        *(_OWORD *)long long buf = v5;
        uint64_t v6 = v23;
        uint64_t v23 = *(void *)&buf[16];
        *(void *)&uint8_t buf[16] = v6;
        context = buf;
        sub_100047F64((void ***)&context);
      }
    }
    uint64_t v7 = v22;
    CSIPhoneNumber::CSIPhoneNumber();
    if ((void)v22 != *((void *)&v22 + 1))
    {
      while (1)
      {
        uint64_t v33 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        memset(buf, 0, sizeof(buf));
        CSIPhoneNumber::CSIPhoneNumber();
        char v8 = CSIPhoneNumber::operator==();
        if (SHIBYTE(v31) < 0) {
          operator delete(*((void **)&v30 + 1));
        }
        if (SBYTE7(v30) < 0) {
          operator delete((void *)v29);
        }
        if (SBYTE7(v28) < 0) {
          operator delete((void *)v27);
        }
        if ((char)buf[31] < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (v8) {
          break;
        }
        v7 += 24;
        if (v7 == *((void *)&v22 + 1))
        {
          uint64_t v7 = *((void *)&v22 + 1);
          break;
        }
      }
    }
    BOOL v9 = v7 != *((void *)&v22 + 1);
    if (v21 < 0) {
      operator delete(v20);
    }
    if (v19 < 0) {
      operator delete(v18);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
    if (v15 < 0) {
      operator delete(v14);
    }
    if (v7 != *((void *)&v22 + 1))
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = **(PersonalityInfo ***)(a1 + 80);
        if (v11) {
          uint64_t v12 = (const char *)PersonalityInfo::logPrefix(v11);
        }
        else {
          uint64_t v12 = "-1";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sEmergency number over Wi-Fi-only found", buf, 0x16u);
      }
    }
    *(void *)long long buf = &v22;
    sub_100047F64((void ***)buf);
  }
  else
  {
    BOOL v9 = 0;
  }
  sub_1000577C4(&cf);
  return v9;
}

void sub_100A3275C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,const void *a31,char *a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  a32 = &a27;
  sub_100047F64((void ***)&a32);
  sub_1000577C4(&a31);
  _Unwind_Resume(a1);
}

BOOL sub_100A327FC(uint64_t a1)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)a1 + 472))(&cf);
  CFArrayRef v2 = (const __CFArray *)cf;
  if (cf) {
    uint64_t v3 = sub_100080934;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    long long v22 = 0uLL;
    uint64_t v23 = 0;
    if (cf)
    {
      CFTypeID v4 = CFGetTypeID(cf);
      if (v4 == CFArrayGetTypeID())
      {
        memset(buf, 0, 24);
        context = buf;
        v34.length = CFArrayGetCount(v2);
        v34.location = 0;
        CFArrayApplyFunction(v2, v34, (CFArrayApplierFunction)sub_100449508, &context);
        long long v5 = v22;
        long long v22 = *(_OWORD *)buf;
        *(_OWORD *)long long buf = v5;
        uint64_t v6 = v23;
        uint64_t v23 = *(void *)&buf[16];
        *(void *)&uint8_t buf[16] = v6;
        context = buf;
        sub_100047F64((void ***)&context);
      }
    }
    uint64_t v7 = v22;
    CSIPhoneNumber::CSIPhoneNumber();
    if ((void)v22 != *((void *)&v22 + 1))
    {
      while (1)
      {
        uint64_t v33 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        memset(buf, 0, sizeof(buf));
        CSIPhoneNumber::CSIPhoneNumber();
        char v8 = CSIPhoneNumber::operator==();
        if (SHIBYTE(v31) < 0) {
          operator delete(*((void **)&v30 + 1));
        }
        if (SBYTE7(v30) < 0) {
          operator delete((void *)v29);
        }
        if (SBYTE7(v28) < 0) {
          operator delete((void *)v27);
        }
        if ((char)buf[31] < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (v8) {
          break;
        }
        v7 += 24;
        if (v7 == *((void *)&v22 + 1))
        {
          uint64_t v7 = *((void *)&v22 + 1);
          break;
        }
      }
    }
    BOOL v9 = v7 != *((void *)&v22 + 1);
    if (v21 < 0) {
      operator delete(v20);
    }
    if (v19 < 0) {
      operator delete(v18);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
    if (v15 < 0) {
      operator delete(v14);
    }
    if (v7 != *((void *)&v22 + 1))
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = **(PersonalityInfo ***)(a1 + 80);
        if (v11) {
          uint64_t v12 = (const char *)PersonalityInfo::logPrefix(v11);
        }
        else {
          uint64_t v12 = "-1";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sShortcode number found", buf, 0x16u);
      }
    }
    *(void *)long long buf = &v22;
    sub_100047F64((void ***)buf);
  }
  else
  {
    BOOL v9 = 0;
  }
  sub_1000577C4(&cf);
  return v9;
}

void sub_100A32AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,const void *a31,char *a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  a32 = &a27;
  sub_100047F64((void ***)&a32);
  sub_1000577C4(&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_100A32B88(uint64_t a1, uint64_t a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  long long v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  char v14 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 48))(v12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if ((v14 & 1) == 0)
  {
    if (sub_100A32470(a1))
    {
      CFStringRef v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        char v17 = **(PersonalityInfo ***)(a1 + 80);
        if (v17) {
          uint64_t v18 = (const char *)PersonalityInfo::logPrefix(v17);
        }
        else {
          uint64_t v18 = "-1";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v18;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s%sDialed number matches Emergency number over Wi-Fi-only. LocationService off is ignored", buf, 0x16u);
      }
    }
    else if (sub_100A327FC(a1))
    {
      char v19 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = **(PersonalityInfo ***)(a1 + 80);
        if (v20) {
          char v21 = (const char *)PersonalityInfo::logPrefix(v20);
        }
        else {
          char v21 = "-1";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v21;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I %s%sDialed number matches Shortcode number. LocationService is disabled", buf, 0x16u);
      }
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)a2;
        uint64_t v24 = *(void *)(a2 + 16);
      }
      *(void *)long long buf = a1;
      if (SHIBYTE(v24) < 0)
      {
        sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
        uint64_t v28 = v24;
      }
      sub_10003E168(&v25, (void *)(a1 + 8));
      long long v22 = v26;
      v29[0] = v25;
      v29[1] = v26;
      if (v26)
      {
        atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
      }
      char v25 = 0;
      int v26 = 0;
      sub_10003E168(&v25, (void *)(a1 + 8));
      operator new();
    }
  }
  return 1;
}

void sub_100A32F70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A32FDC(uint64_t a1@<X0>, CFDataRef *a2@<X8>)
{
  __p[0] = 0;
  __p[1] = 0;
  int64_t v33 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  long long v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v34 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v34);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v12 + 160))(&v31, v12, *(unsigned int *)(**(void **)(a1 + 80) + 52));
  char v14 = std::string::append(&v31, "/", 1uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  CFStringRef v16 = std::string::append(&v35, "CarrierCA.crt", 0xDuLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  int64_t v33 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v13) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  operator delete(v31.__r_.__value_.__l.__data_);
  if ((v13 & 1) == 0) {
LABEL_13:
  }
    sub_10004D2C8(v11);
LABEL_14:
  v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101A0BD40;
  *a2 = 0;
  sub_1007EE138(kCFAllocatorDefault, (uint64_t)__p, a2);
  CFDataRef v18 = *a2;
  if (*a2) {
    char v19 = sub_10008324C;
  }
  else {
    char v19 = 0;
  }
  uint64_t v20 = *(NSObject **)(a1 + 40);
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (!v21) {
      goto LABEL_33;
    }
    long long v22 = **(PersonalityInfo ***)(a1 + 80);
    if (v22)
    {
      uint64_t v23 = (const char *)PersonalityInfo::logPrefix(v22);
      CFDataRef v18 = *a2;
    }
    else
    {
      uint64_t v23 = "-1";
    }
    int Length = CFDataGetLength(v18);
    LODWORD(v35.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v35.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(v35.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v35.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(v35.__r_.__value_.__r.__words[2]) = 1024;
    LODWORD(v36) = Length;
    long long v27 = "#I %s%sePDG CA certificate file of size %d loaded";
    uint64_t v28 = v20;
    uint32_t v29 = 28;
  }
  else
  {
    if (!v21) {
      goto LABEL_33;
    }
    uint64_t v24 = **(PersonalityInfo ***)(a1 + 80);
    if (v24) {
      char v25 = (const char *)PersonalityInfo::logPrefix(v24);
    }
    else {
      char v25 = "-1";
    }
    long long v30 = __p;
    if (v33 < 0) {
      long long v30 = (void **)__p[0];
    }
    LODWORD(v35.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v35.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
    WORD2(v35.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v35.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)" ";
    HIWORD(v35.__r_.__value_.__r.__words[2]) = 2080;
    unint64_t v36 = v30;
    long long v27 = "#I %s%sUnable to open '%s' for reading";
    uint64_t v28 = v20;
    uint32_t v29 = 32;
  }
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&v35, v29);
LABEL_33:
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&v31);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A33354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_100030068(v28);
  FileSystemInterface::~FileSystemInterface((FileSystemInterface *)&a10);
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A333E4(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 104);
  uint64_t result = a1 + 104;
  uint64_t v3 = v4;
  if (v4)
  {
    uint64_t v5 = result;
    do
    {
      int v6 = *(_DWORD *)(v3 + 32);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        uint64_t v8 = (uint64_t *)v3;
      }
      else {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (!v7) {
        uint64_t v5 = v3;
      }
      uint64_t v3 = *v8;
    }
    while (*v8);
    if (v5 != result && *(_DWORD *)(v5 + 32) <= a2) {
      return (*(uint64_t (**)(void))(**(void **)(v5 + 40) + 96))();
    }
  }
  return result;
}

void sub_100A3344C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 354))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    int v6 = ServiceMap;
    if (v7 < 0)
    {
      uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)CFDataRef v18 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v18);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        if (!v13) {
          goto LABEL_11;
        }
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13)
    {
LABEL_11:
      long long v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v16 = **(PersonalityInfo ***)(a1 + 80);
        if (v16) {
          long long v17 = (const char *)PersonalityInfo::logPrefix(v16);
        }
        else {
          long long v17 = "-1";
        }
        *(_DWORD *)CFDataRef v18 = 136315394;
        *(void *)&v18[4] = v17;
        __int16 v19 = 2080;
        uint64_t v20 = " ";
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "#E %s%sPhoneServices not found. Ignoring WiFiLocation evaluation", v18, 0x16u);
        if (v14) {
          return;
        }
LABEL_18:
        sub_10004D2C8(v12);
        return;
      }
LABEL_17:
      if (v14) {
        return;
      }
      goto LABEL_18;
    }
LABEL_16:
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
    goto LABEL_17;
  }
  CFArrayRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = **(PersonalityInfo ***)(a1 + 80);
    if (v3) {
      uint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
    }
    else {
      uint64_t v4 = "-1";
    }
    *(_DWORD *)CFDataRef v18 = 136315394;
    *(void *)&v18[4] = v4;
    __int16 v19 = 2080;
    uint64_t v20 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sPSControl is shutting down. Ignoring WiFiLocation evaluation", v18, 0x16u);
  }
}

void sub_100A33684(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A336BC()
{
  return 1;
}

void sub_100A336C4(const void **a1)
{
  if (a1)
  {
    sub_100A336C4(*a1);
    sub_100A336C4(a1[1]);
    sub_100057D78(a1 + 5);
    operator delete(a1);
  }
}

void *sub_100A33718(void *a1)
{
  *a1 = off_101A2E328;
  char v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A33764(void *a1)
{
  *a1 = off_101A2E328;
  char v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A337D0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)uint64_t result = off_101A2E328;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((void *)result + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A33834(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A2E328;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A33874(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A33884(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A338C4(uint64_t *a1, xpc_object_t *a2)
{
  sub_10031A644(a1[1], a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3)
  {
    uint64_t v4 = (void **)a1[2];
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      if (a1[3])
      {
        uint64_t v7 = sub_100046F68((uint64_t)(v4 + 100), (void **)(*v4[10] + 24));
        if (v4 + 101 != (void **)v7) {
          ((void (*)(void **, uint64_t, void **, void **, void **))(*v4)[37])(v4, *v4[10] + 24, v7 + 7, v7 + 8, v7 + 11);
        }
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A339A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A339B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A339F4()
{
}

void sub_100A33A00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100A33B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100163BC8((uint64_t)va);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 8))(a3);
  }
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A33BDC(uint64_t a1)
{
  sub_100A35098((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100A33C1C(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100A33D14(a1, v3);
}

void sub_100A33CE4(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A33D14(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100A33E0C(a1, a2);
}

void sub_100A33DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100A33E0C(uint64_t *a1, void *a2)
{
}

void sub_100A33E80()
{
}

uint64_t *sub_100A33EA4(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1001AA9E4(a1, a2, 1, 2);
}

void sub_100A33FA0()
{
}

void sub_100A33FC4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A2E3A8;
  operator new();
}

void sub_100A340D8(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100A34140(uint64_t a1)
{
  sub_100A344F4(a1);

  operator delete();
}

BOOL sub_100A34178(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100A34564((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100A34228(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A34258(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100A34284(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100A342B0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100A3430C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A34378(&v2);
}

void sub_100A34364(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A34378(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A343E8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100A34410(v1);
  __cxa_rethrow();
}

void sub_100A343FC(_Unwind_Exception *a1)
{
}

uint64_t sub_100A34410(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100A35098((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100A34470()
{
}

uint64_t sub_100A34484(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100A35098((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100A344DC()
{
  return 0;
}

uint64_t sub_100A344E4()
{
  return 0;
}

uint64_t sub_100A344EC()
{
  return 0;
}

uint64_t sub_100A344F4(uint64_t a1)
{
  *(void *)a1 = off_101A2E3A8;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100A34564(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1001AACC4((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1001AACC4(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100A34648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A34668(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A346D4(&v2);
}

void sub_100A346C0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A346D4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A34744(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100A3477C(_Unwind_Exception *a1)
{
}

void sub_100A34794()
{
}

uint64_t sub_100A347A8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A347D8()
{
  return 0;
}

uint64_t sub_100A347E0()
{
  return 0;
}

uint64_t sub_100A347E8()
{
  return 0;
}

uint64_t *sub_100A347F0(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100A34FD8((uint64_t)v4, result);
    sub_100A34FD8(v3, a2);
    sub_100A34FD8((uint64_t)a2, (uint64_t *)v4);
    return sub_100A35098((uint64_t *)v4);
  }
  return result;
}

void sub_100A34858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100A3486C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN13PSControlBase10initializeEvE3$_1EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN13PSControlBase10initializeEvE3$_1EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100A349A8(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v7 = *(void *)(a2 + 16);
  }
  uint64_t v3 = v2[1];
  uint64_t v4 = v2[2];
  long long v5 = (std::__shared_weak_count *)v2[3];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v10 = v4;
    uint64_t v11 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  else
  {
    uint64_t v10 = v4;
    uint64_t v11 = 0;
  }
  uint64_t v8 = off_101A2E4F0;
  uint64_t v9 = v3;
  sub_100A34AD8();
}

void sub_100A34AA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  sub_100A35098(&a16);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100A34AD8()
{
}

void sub_100A34C04()
{
}

uint64_t *sub_100A34C44(uint64_t a1)
{
  sub_1001AAED0(*(void **)(a1 + 32));
  uint64_t result = *(uint64_t **)(a1 + 32);
  if (result)
  {
    sub_100A35098(result);
    operator delete();
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }
  return result;
}

void sub_100A34CD8(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    int v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN13PSControlBase10initializeEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN13PSControlBase10initializeEvE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  int v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100A34DBC(uint64_t *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v5 = *a1;
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1] && sub_10001D294(a2, (unsigned __int8 *)(**(void **)(v5 + 80) + 24)))
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = **(PersonalityInfo ***)(v5 + 80);
          if (v9) {
            uint64_t v10 = (const char *)PersonalityInfo::logPrefix(v9);
          }
          else {
            uint64_t v10 = "-1";
          }
          int v16 = 136315394;
          long long v17 = v10;
          __int16 v18 = 2080;
          __int16 v19 = " ";
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%srefresh PhoneServices account status", (uint8_t *)&v16, 0x16u);
        }
        *(_DWORD *)(v5 + 736) = 0;
        sub_100A2BBB0(v5 + 360);
        *(unsigned char *)(v5 + 352) = 0;
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 456))(v5, 1);
        uint64_t v11 = *(void **)(v5 + 96);
        uint64_t v12 = (void *)(v5 + 104);
        if (v11 != v12)
        {
          do
          {
            (*(void (**)(void))(*(void *)v11[5] + 160))(v11[5]);
            uint64_t v13 = (void *)v11[1];
            if (v13)
            {
              do
              {
                char v14 = v13;
                uint64_t v13 = (void *)*v13;
              }
              while (v13);
            }
            else
            {
              do
              {
                char v14 = (void *)v11[2];
                BOOL v15 = *v14 == (void)v11;
                uint64_t v11 = v14;
              }
              while (!v15);
            }
            uint64_t v11 = v14;
          }
          while (v14 != v12);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100A34FC0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100A34FD8(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        int v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100A35074(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_100A35084(_Unwind_Exception *a1)
{
}

uint64_t *sub_100A35098(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_100A350EC(uint64_t a1)
{
  sub_100A36CB8((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

void sub_100A3512C(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100A35224(a1, v3);
}

void sub_100A351F4(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A35224(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100A3531C(a1, a2);
}

void sub_100A35304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100A3531C(uint64_t *a1, void *a2)
{
}

void sub_100A35390()
{
}

uint64_t *sub_100A353B4(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1001B329C(a1, a2, 1, 2);
}

void sub_100A354B0()
{
}

void sub_100A354D4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A2E520;
  operator new();
}

void sub_100A355E8(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100A35650(uint64_t a1)
{
  sub_100A35A04(a1);

  operator delete();
}

BOOL sub_100A35688(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100A35A74((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100A35738(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A35768(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100A35794(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100A357C0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100A3581C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A35888(&v2);
}

void sub_100A35874(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A35888(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A358F8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100A35920(v1);
  __cxa_rethrow();
}

void sub_100A3590C(_Unwind_Exception *a1)
{
}

uint64_t sub_100A35920(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100A36CB8((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100A35980()
{
}

uint64_t sub_100A35994(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100A36CB8((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100A359EC()
{
  return 0;
}

uint64_t sub_100A359F4()
{
  return 0;
}

uint64_t sub_100A359FC()
{
  return 0;
}

uint64_t sub_100A35A04(uint64_t a1)
{
  *(void *)a1 = off_101A2E520;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100A35A74(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1001B357C((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1001B357C(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100A35B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A35B78(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100A35BE4(&v2);
}

void sub_100A35BD0(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100A35BE4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100A35C54(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100A35C8C(_Unwind_Exception *a1)
{
}

void sub_100A35CA4()
{
}

uint64_t sub_100A35CB8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A35CE8()
{
  return 0;
}

uint64_t sub_100A35CF0()
{
  return 0;
}

uint64_t sub_100A35CF8()
{
  return 0;
}

uint64_t *sub_100A35D00(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100A36BF8((uint64_t)v4, result);
    sub_100A36BF8(v3, a2);
    sub_100A36BF8((uint64_t)a2, (uint64_t *)v4);
    return sub_100A36CB8((uint64_t *)v4);
  }
  return result;
}

void sub_100A35D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100A35D7C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN13PSControlBase10initializeEvE3$_2EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN13PSControlBase10initializeEvE3$_2EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100A35EB8(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  long long v5 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }
  uint64_t v7 = *a4;
  uint64_t v6 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v8 = v5[1];
  uint64_t v9 = v5[2];
  uint64_t v10 = (std::__shared_weak_count *)v5[3];
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v17 = v9;
    __int16 v18 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  else
  {
    uint64_t v17 = v5[2];
    __int16 v18 = 0;
  }
  BOOL v15 = off_101A2E668;
  uint64_t v16 = v8;
  uint64_t v13 = v7;
  uint64_t v14 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100A36054();
}

void sub_100A3600C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_100A36CB8(&a18);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100A36054()
{
}

void sub_100A361E8()
{
}

uint64_t sub_100A36228(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void **)(a1 + 56);
  uint64_t v5 = **(unsigned int **)(a1 + 48);
  uint64_t v6 = v4[1];
  *(void *)&long long v12 = *v4;
  *((void *)&v12 + 1) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_1001B3808(v2, v3, v5, &v12);
  if (*((void *)&v12 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
  }
  uint64_t v7 = *(uint64_t **)(a1 + 32);
  if (v7)
  {
    sub_100A36CB8(v7);
    operator delete();
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    if (*(char *)(v8 + 23) < 0) {
      operator delete(*(void **)v8);
    }
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    operator delete();
  }
  uint64_t v10 = *(void *)(a1 + 56);
  if (v10)
  {
    uint64_t v11 = *(std::__shared_weak_count **)(v10 + 8);
    if (v11) {
      sub_10004D2C8(v11);
    }
    operator delete();
  }
  return result;
}

void sub_100A36324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A3633C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN13PSControlBase10initializeEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN13PSControlBase10initializeEvE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100A36420(uint64_t *a1, unsigned __int8 *a2, int a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  uint64_t v5 = a4[1];
  *a4 = 0;
  a4[1] = 0;
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7)
  {
    uint64_t v10 = *a1;
    uint64_t v11 = std::__shared_weak_count::lock(v7);
    if (v11)
    {
      long long v12 = v11;
      if (!a1[1])
      {
LABEL_50:
        sub_10004D2C8(v12);
        goto LABEL_51;
      }
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      if (!sub_10001D294(a2, (unsigned __int8 *)(**(void **)(v10 + 80) + 24))) {
        goto LABEL_48;
      }
      uint64_t v13 = *(NSObject **)(v10 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = **(PersonalityInfo ***)(v10 + 80);
        if (v14) {
          BOOL v15 = (const char *)PersonalityInfo::logPrefix(v14);
        }
        else {
          BOOL v15 = "-1";
        }
        if ((a3 - 1) > 2) {
          uint64_t v16 = "RequestCanceled";
        }
        else {
          uint64_t v16 = off_101A2E848[a3 - 1];
        }
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v15;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        unsigned int v55 = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Evaluate Phone Services Account Status Update ==(cause:%s)==============================", buf, 0x20u);
      }
      v53[0] = (int *)v6;
      v53[1] = (int *)v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      unsigned __int16 v17 = sub_100A2F6CC(v10, a3, v53);
      if (v5) {
        sub_10004D2C8((std::__shared_weak_count *)v5);
      }
      if (!(_BYTE)v17)
      {
LABEL_48:
        if (v5) {
          sub_10004D2C8((std::__shared_weak_count *)v5);
        }
        goto LABEL_50;
      }
      *(unsigned char *)(v10 + 353) = 0;
      if (v17 < 0x100u || !*(unsigned char *)(v10 + 344))
      {
LABEL_38:
        if (sub_100A2EAC0(v10, 3))
        {
          if (!*(void *)(v10 + 440))
          {
            int v34 = *(_DWORD *)(v10 + 736);
            if (v34) {
              int v35 = v34 - 1;
            }
            else {
              int v35 = 3;
            }
            *(_DWORD *)(v10 + 736) = v35;
          }
        }
        else
        {
          *(_DWORD *)(v10 + 736) = 0;
          uint64_t v36 = *(void *)(v10 + 440);
          if (v36)
          {
            (*(void (**)(uint64_t))(*(void *)v36 + 16))(v36);
            uint64_t v37 = *(void *)(v10 + 440);
            *(void *)(v10 + 44ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
            if (v37) {
              (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
            }
          }
        }
        (*(void (**)(uint64_t, void, void))(*(void *)v10 + 344))(v10, 0, 0);
        if (!*(unsigned char *)(v10 + 353) && *(_DWORD *)(v10 + 736) && !*(void *)(v10 + 440))
        {
          sub_10003E168(buf, (void *)(v10 + 8));
          uint64_t v39 = *(void *)buf;
          int v38 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8])
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 16), 1uLL, memory_order_relaxed);
            sub_10004D2C8(v38);
          }
          int v40 = *(_DWORD *)(v10 + 736);
          Registry::getTimerService(&v50, *(Registry **)(v10 + 48));
          uint64_t v41 = v50;
          sub_100058DB0(__p, "RegisteredProvisioningStatus::kInProgress retry");
          uint64_t v42 = *(NSObject **)(v10 + 24);
          dispatch_object_t object = v42;
          if (v42) {
            dispatch_retain(v42);
          }
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 1174405120;
          *(void *)&uint8_t buf[16] = sub_100A2F8EC;
          unsigned int v55 = (const char *)&unk_101A2E158;
          uint64_t v56 = v10;
          uint64_t v57 = v39;
          uint64_t v58 = v38;
          if (v38) {
            atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          aBlock = _Block_copy(buf);
          sub_100118A44(v41, (uint64_t)__p, 1, 60000000 * (4 - v40), &object, &aBlock);
          uint64_t v43 = v52;
          uint64_t v52 = 0;
          uint64_t v44 = *(void *)(v10 + 440);
          *(void *)(v10 + 44ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v43;
          if (v44)
          {
            (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
            uint64_t v45 = v52;
            uint64_t v52 = 0;
            if (v45) {
              (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
            }
          }
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v49 < 0) {
            operator delete(__p[0]);
          }
          if (v51) {
            sub_10004D2C8(v51);
          }
          if (v58) {
            std::__shared_weak_count::__release_weak(v58);
          }
          if (v38) {
            std::__shared_weak_count::__release_weak(v38);
          }
        }
        goto LABEL_48;
      }
      *(unsigned char *)(v10 + 352) = 1;
      uint64_t v18 = *(void *)(v6 + 8);
      sub_100179AF8((std::string *)(v10 + 192), (const std::string *)v18);
      sub_100179AF8((std::string *)(v10 + 224), (const std::string *)(v18 + 32));
      long long v19 = *(_OWORD *)(v18 + 64);
      *(void *)(v10 + 269) = *(void *)(v18 + 77);
      *(_OWORD *)(v10 + 256) = v19;
      sub_100179AF8((std::string *)(v10 + 280), (const std::string *)(v18 + 88));
      sub_100179AF8((std::string *)(v10 + 312), (const std::string *)(v18 + 120));
      __p[0] = 0;
      sub_1003A8E80(v10 + 144, __p);
      uint64_t v20 = *(NSObject **)(v10 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v21 = **(PersonalityInfo ***)(v10 + 80);
        if (v21) {
          long long v22 = (const char *)PersonalityInfo::logPrefix(v21);
        }
        else {
          long long v22 = "-1";
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%sPSAS:", buf, 0x16u);
      }
      *(void *)long long buf = off_101A2E6D8;
      *(void *)&uint8_t buf[8] = v10;
      unsigned int v55 = buf;
      logger::CFTypeRefLogger();
      sub_10012C330(buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(v10 + 48));
      char v25 = ServiceMap;
      if (v26 < 0)
      {
        long long v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v28 = 5381;
        do
        {
          uint64_t v26 = v28;
          unsigned int v29 = *v27++;
          uint64_t v28 = (33 * v28) ^ v29;
        }
        while (v29);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v26;
      long long v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
      if (v30)
      {
        uint64_t v32 = v30[3];
        std::string v31 = (std::__shared_weak_count *)v30[4];
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v25);
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v31);
          char v33 = 0;
LABEL_35:
          (*(void (**)(uint64_t, uint64_t, const __CFString *, void *, void, void, uint64_t, void))(*(void *)v32 + 16))(v32, **(void **)(v10 + 80) + 24, @"onfile.status", __p[0], kPhoneServicesWalletDomain, 0, 4, 0);
          if ((v33 & 1) == 0) {
            sub_10004D2C8(v31);
          }
          sub_100A2E150(v10, *(void *)(v6 + 8));
          sub_100057D78((const void **)__p);
          goto LABEL_38;
        }
      }
      else
      {
        uint64_t v32 = 0;
      }
      std::mutex::unlock(v25);
      std::string v31 = 0;
      char v33 = 1;
      goto LABEL_35;
    }
  }
LABEL_51:
  if (v5)
  {
    sub_10004D2C8((std::__shared_weak_count *)v5);
  }
}

void sub_100A36AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *aBlock, dispatch_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A36BF8(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    *uint64_t v2 = 0;
  }
  return result;
}

void sub_100A36C94(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_100A36CA4(_Unwind_Exception *a1)
{
}

uint64_t *sub_100A36CB8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t sub_100A36D0C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t result = *(void *)a2;
      if (*(void *)a2)
      {
        sub_1001E1134(result);
        operator delete();
      }
      goto LABEL_9;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZN13PSControlBase10initializeEvE3$_3EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZN13PSControlBase10initializeEvE3$_3EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_9:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100A36E48(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v7 = *(void *)(a2 + 16);
  }
  uint64_t v3 = v2[1];
  uint64_t v4 = v2[2];
  uint64_t v5 = (std::__shared_weak_count *)v2[3];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v10 = v4;
    uint64_t v11 = v5;
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  else
  {
    uint64_t v10 = v4;
    uint64_t v11 = 0;
  }
  uint64_t v8 = off_101A2E6A8;
  uint64_t v9 = v3;
  sub_100A34AD8();
}

void sub_100A36F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16)
{
  sub_100A35098(&a16);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100A36F78(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    uint64_t v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZN13PSControlBase10initializeEvE3$_3" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZN13PSControlBase10initializeEvE3$_3" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100A3705C(uint64_t *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v5 = *a1;
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1] && sub_10001D294(a2, (unsigned __int8 *)(**(void **)(v5 + 80) + 24)))
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = **(PersonalityInfo ***)(v5 + 80);
          if (v9) {
            uint64_t v10 = (const char *)PersonalityInfo::logPrefix(v9);
          }
          else {
            uint64_t v10 = "-1";
          }
          int v11 = 136315394;
          long long v12 = v10;
          __int16 v13 = 2080;
          uint64_t v14 = " ";
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%shandlePSASChangedNotification", (uint8_t *)&v11, 0x16u);
        }
        (*(void (**)(uint64_t, void))(*(void *)v5 + 384))(v5, 0);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100A371E0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A371F4(std::mutex ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (v1[1])
      {
        std::mutex::lock(v3 + 7);
        sub_100A3112C();
      }
      sub_10004D2C8(v4);
    }
  }
  sub_100004A84((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100A3727C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::mutex::unlock(v11);
  sub_10004D2C8(v10);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100A372B4()
{
}

void *sub_100A372C8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2E6D8;
  result[1] = v3;
  return result;
}

uint64_t sub_100A37310(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2E6D8;
  a2[1] = v2;
  return result;
}

void sub_100A3733C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = **(PersonalityInfo ***)(v3 + 80);
    if (v5) {
      uint64_t v6 = (const char *)PersonalityInfo::logPrefix(v5);
    }
    else {
      uint64_t v6 = "-1";
    }
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    int v8 = 136315650;
    uint64_t v9 = v6;
    __int16 v10 = 2080;
    int v11 = " ";
    __int16 v12 = 2080;
    __int16 v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v8, 0x20u);
  }
}

uint64_t sub_100A3742C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A3746C()
{
}

uint64_t *sub_100A37478(uint64_t *result, int a2, int a3)
{
  uint64_t v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        int v8 = *(_DWORD *)(v5 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    uint64_t v9 = operator new(0x20uLL);
    v9[7] = a3;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    const char *v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      uint64_t *v4 = v10;
      int v11 = *v6;
    }
    else
    {
      int v11 = (uint64_t *)v9;
    }
    uint64_t result = sub_100046C90((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

void sub_100A37530(uint64_t **a1, int a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 1);
  uint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v5 = v4;
    uint64_t v6 = v3;
    do
    {
      int v7 = *((_DWORD *)v6 + 7);
      BOOL v8 = v7 < a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t **)v6;
      }
      else {
        uint64_t v9 = (uint64_t **)(v6 + 1);
      }
      if (!v8) {
        uint64_t v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && *((_DWORD *)v5 + 7) <= a2)
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        __int16 v12 = v5;
        do
        {
          int v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          __int16 v12 = v11;
        }
        while (!v13);
      }
      if (*a1 == v5) {
        *a1 = v11;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_10005EE6C(v3, v5);
      operator delete(v5);
    }
  }
}

void sub_100A3760C()
{
}

void *sub_100A37620(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A2E758;
  result[1] = v3;
  return result;
}

uint64_t sub_100A37668(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A2E758;
  a2[1] = v2;
  return result;
}

void sub_100A37694(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = **(PersonalityInfo ***)(v3 + 80);
    if (v5) {
      uint64_t v6 = (const char *)PersonalityInfo::logPrefix(v5);
    }
    else {
      uint64_t v6 = "-1";
    }
    if (*((char *)a2 + 23) >= 0) {
      int v7 = a2;
    }
    else {
      int v7 = (uint64_t *)*a2;
    }
    int v8 = 136315650;
    uint64_t v9 = v6;
    __int16 v10 = 2080;
    int v11 = " ";
    __int16 v12 = 2080;
    BOOL v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v8, 0x20u);
  }
}

uint64_t sub_100A37784(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A377C4()
{
}

char *sub_100A377D0@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t result = (char *)operator new(0x48uLL);
  *((void *)result + 1) = 0;
  *((void *)result + 2) = 0;
  *(void *)uint64_t result = off_1019BEB10;
  *(_OWORD *)(result + 24) = *(_OWORD *)a1;
  *((_DWORD *)result + 1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(_DWORD *)(a1 + 16);
  uint64_t v5 = (void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 32);
  *((void *)result + 6) = *(void *)(a1 + 24);
  *((void *)result + 7) = v6;
  int v7 = result + 56;
  uint64_t v8 = *(void *)(a1 + 40);
  *((void *)result + 8) = v8;
  if (v8)
  {
    *(void *)(v6 + 16) = v7;
    *(void *)(a1 + 24) = v5;
    void *v5 = 0;
    *(void *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  }
  else
  {
    *((void *)result + 6) = v7;
  }
  *a2 = result + 24;
  a2[1] = result;
  return result;
}

void sub_100A37870(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A378A8(uint64_t a1)
{
  return sub_100A378F4(*(void *)(a1 + 24));
}

uint64_t sub_100A378B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A378F4(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void **)(result + 24);
    sub_100047F64(&v2);
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100A3795C(uint64_t *a1)
{
  if (!*a1) {
    goto LABEL_17;
  }
  unsigned int v2 = *((_DWORD *)a1 + 2);
  uint64_t v3 = sub_10001C8F4(8);
  uint64_t v5 = (wis::WISServerConnection *)*v3;
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v5)
  {
    SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v3);
    int v7 = (wis *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v2);
    uint64_t v8 = v7;
    if (v7)
    {
      uint64_t v9 = *a1;
      *a1 = 0;
      if (v9)
      {
        if (*(unsigned char *)(v9 + 56))
        {
          unint64_t WISTimestamp = *(void *)(v9 + 8);
        }
        else
        {
          unint64_t WISTimestamp = wis::getWISTimestamp(v7);
          *(_DWORD *)(v9 + 56) |= 1u;
          *(void *)(v9 + 8) = WISTimestamp;
        }
        wis::MetricContainer::storeMetric(v8, WISTimestamp, *(_DWORD *)v8, (const wireless_diagnostics::google::protobuf::MessageLite *)v9);
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      wis::WISServerConnection::SubmitMetric(v5, v8);
    }
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v11 = *a1;
  *a1 = 0;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = *a1;
    *a1 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
LABEL_17:
    *a1 = 0;
  }
  return a1;
}

void sub_100A37ABC(void *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

uint64_t *sub_100A37B0C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int64_t v74 = a1;
  uint64_t v75 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!*(void *)(v1 + 32))
      {
LABEL_111:
        sub_10004D2C8(v5);
        goto LABEL_112;
      }
      uint64_t v6 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = **(PersonalityInfo ***)(v3 + 80);
        if (v7) {
          uint64_t v8 = (const char *)PersonalityInfo::logPrefix(v7);
        }
        else {
          uint64_t v8 = "-1";
        }
        uint64_t v9 = (const char *)(v1 + 8);
        if (*(char *)(v1 + 31) < 0)
        {
          if (*(void *)(v1 + 16)) {
            uint64_t v9 = *(const char **)v9;
          }
          else {
            uint64_t v9 = "<none>";
          }
        }
        else if (!*(unsigned char *)(v1 + 31))
        {
          uint64_t v9 = "<none>";
        }
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v8;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        *(_WORD *)&unsigned char buf[22] = 2080;
        v89 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sShow location service off alert. number: '%s'", buf, 0x20u);
      }
      CFStringRef v81 = 0;
      CFURLRef v82 = 0;
      CFStringRef format = 0;
      CFStringRef alertMessage = 0;
      CFStringRef v78 = 0;
      __int16 v10 = (void **)(v1 + 8);
      if (*(char *)(v1 + 31) < 0)
      {
        unint64_t v12 = *(void *)(v1 + 16);
        if (v12)
        {
          sub_10004FC84(__dst, *v10, v12);
          goto LABEL_21;
        }
      }
      else if (*(unsigned char *)(v1 + 31))
      {
        long long v11 = *(_OWORD *)v10;
        uint64_t v77 = *(void *)(v1 + 24);
        *(_OWORD *)std::string __dst = v11;
LABEL_21:
        if (SHIBYTE(v77) < 0)
        {
          sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)__dst;
          uint64_t v85 = v77;
        }
        CFStringRef v83 = 0;
        if (SHIBYTE(v85) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)long long buf = *(_OWORD *)__p;
          *(void *)&uint8_t buf[16] = v85;
        }
        CFStringRef v86 = 0;
        if (ctu::cf::convert_copy())
        {
          CFStringRef v13 = v83;
          CFStringRef v83 = v86;
          CFStringRef v87 = v13;
          sub_1000558F4((const void **)&v87);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        CFStringRef v78 = v83;
        CFStringRef v83 = 0;
        sub_1000558F4((const void **)&v83);
        if (SHIBYTE(v85) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v77) < 0) {
          operator delete(__dst[0]);
        }
LABEL_36:
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
        BOOL v15 = ServiceMap;
        if (v16 < 0)
        {
          unsigned __int16 v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v18 = 5381;
          do
          {
            uint64_t v16 = v18;
            unsigned int v19 = *v17++;
            uint64_t v18 = (33 * v18) ^ v19;
          }
          while (v19);
        }
        std::mutex::lock(ServiceMap);
        *(void *)long long buf = v16;
        uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
        if (v20)
        {
          uint64_t v22 = v20[3];
          BOOL v21 = (std::__shared_weak_count *)v20[4];
          if (v21)
          {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v15);
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v21);
            char v23 = 0;
            goto LABEL_44;
          }
        }
        else
        {
          uint64_t v22 = 0;
        }
        std::mutex::unlock(v15);
        BOOL v21 = 0;
        char v23 = 1;
LABEL_44:
        if (v78) {
          uint64_t v24 = sub_1000810B8;
        }
        else {
          uint64_t v24 = 0;
        }
        if (!v24)
        {
          int v35 = *(NSObject **)(v3 + 40);
          if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
            goto LABEL_108;
          }
          uint64_t v36 = **(PersonalityInfo ***)(v3 + 80);
          if (v36) {
            uint64_t v37 = (const char *)PersonalityInfo::logPrefix(v36);
          }
          else {
            uint64_t v37 = "-1";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v37;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = " ";
          BOOL v72 = "#E %s%sFailed to construct dialed number";
          goto LABEL_117;
        }
        char v25 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
        uint64_t v26 = v25;
        if (v27 < 0)
        {
          uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v29 = 5381;
          do
          {
            uint64_t v27 = v29;
            unsigned int v30 = *v28++;
            uint64_t v29 = (33 * v29) ^ v30;
          }
          while (v30);
        }
        std::mutex::lock(v25);
        *(void *)long long buf = v27;
        std::string v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
        char v73 = v23;
        if (v31)
        {
          uint64_t v33 = v31[3];
          uint64_t v32 = (std::__shared_weak_count *)v31[4];
          if (v32)
          {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v26);
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v32);
            char v34 = 0;
LABEL_59:
            int v38 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 64))(v33);
            if ((v34 & 1) == 0) {
              sub_10004D2C8(v32);
            }
            if (v38)
            {
              uint64_t v39 = kAlertDialogLocalizationTable;
              (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v22 + 40))(__p, v22, kAlertDialogLocalizationTable, @"SHORT_CODE_CALLING_WITHOUT_LOCATION_WLAN", 0);
            }
            else
            {
              uint64_t v39 = kAlertDialogLocalizationTable;
              (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, void))(*(void *)v22 + 40))(__p, v22, kAlertDialogLocalizationTable, @"SHORT_CODE_CALLING_WITHOUT_LOCATION", 0);
            }
            *(void *)long long buf = format;
            CFStringRef format = (CFStringRef)__p[0];
            __p[0] = 0;
            sub_1000558F4((const void **)buf);
            sub_1000558F4((const void **)__p);
            if (format) {
              int v40 = sub_1000810B8;
            }
            else {
              int v40 = 0;
            }
            if (v40)
            {
              CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, format, v78);
              CFStringRef v42 = format;
              CFStringRef format = v41;
              *(void *)long long buf = v42;
              sub_1000558F4((const void **)buf);
              uint64_t v43 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
              uint64_t v44 = v43;
              uint64_t v46 = v45;
              if (v45 < 0)
              {
                int v47 = (unsigned __int8 *)(v45 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v48 = 5381;
                do
                {
                  uint64_t v46 = v48;
                  unsigned int v49 = *v47++;
                  uint64_t v48 = (33 * v48) ^ v49;
                }
                while (v49);
              }
              std::mutex::lock(v43);
              *(void *)long long buf = v46;
              uint64_t v50 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)buf);
              if (v50)
              {
                uint64_t v52 = v50[3];
                int v51 = (std::__shared_weak_count *)v50[4];
                if (v51)
                {
                  atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v44);
                  atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v51);
                  char v53 = 0;
                  goto LABEL_79;
                }
              }
              else
              {
                uint64_t v52 = 0;
              }
              std::mutex::unlock(v44);
              int v51 = 0;
              char v53 = 1;
LABEL_79:
              int v56 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 56))(v52);
              if ((v53 & 1) == 0) {
                sub_10004D2C8(v51);
              }
              sub_100083EB8((const void **)&alertMessage, (const void **)&format);
              __p[0] = 0;
              (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v22 + 40))(__p, v22, v39, @"CANCEL", @"Cancel");
              CFStringRef v87 = 0;
              if (v56) {
                CFStringRef v57 = @"TURN_ON";
              }
              else {
                CFStringRef v57 = @"SETTINGS";
              }
              if (v56) {
                CFStringRef v58 = @"Turn On";
              }
              else {
                CFStringRef v58 = @"Settings";
              }
              char v23 = v73;
              (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, const __CFString *))(*(void *)v22 + 40))(&v87, v22, v39, v57, v58);
              CFStringRef v86 = 0;
              CFUserNotificationDisplayAlert(0.0, 0, v82, 0, 0, v81, alertMessage, (CFStringRef)__p[0], v87, 0, (CFOptionFlags *)&v86);
              if (v86 != (const __CFString *)1) {
                goto LABEL_107;
              }
              CFDictionaryRef v59 = *(NSObject **)(v3 + 40);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                CFDictionaryRef v60 = **(PersonalityInfo ***)(v3 + 80);
                if (v60) {
                  CFTypeID v61 = (const char *)PersonalityInfo::logPrefix(v60);
                }
                else {
                  CFTypeID v61 = "-1";
                }
                *(_DWORD *)long long buf = 136315394;
                *(void *)&uint8_t buf[4] = v61;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = " ";
                _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I %s%sLaunch Settings for Location", buf, 0x16u);
              }
              if (!v56)
              {
                *(void *)long long buf = 0;
                CFStringRef v83 = @"prefs:root=Privacy&path=LOCATION";
                sub_100013168((const void **)buf, (CFTypeRef *)&v83);
                CFStringRef v83 = *(const __CFString **)buf;
                if (*(void *)buf) {
                  CFRetain(*(CFTypeRef *)buf);
                }
                sub_10134D38C((const void **)&v83);
                sub_1000558F4((const void **)&v83);
                sub_1000558F4((const void **)buf);
                goto LABEL_107;
              }
              CFDictionaryRef v62 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
              CFTypeID v63 = v62;
              if (v45 < 0)
              {
                CFDictionaryRef v64 = (unsigned __int8 *)(v45 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v65 = 5381;
                do
                {
                  uint64_t v45 = v65;
                  unsigned int v66 = *v64++;
                  uint64_t v65 = (33 * v65) ^ v66;
                }
                while (v66);
              }
              std::mutex::lock(v62);
              *(void *)long long buf = v45;
              uint64_t v67 = sub_10004D37C(&v63[1].__m_.__sig, (unint64_t *)buf);
              if (v67)
              {
                uint64_t v69 = v67[3];
                CFDictionaryRef v68 = (std::__shared_weak_count *)v67[4];
                if (v68)
                {
                  atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v63);
                  atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v68);
                  char v70 = 0;
                  goto LABEL_105;
                }
              }
              else
              {
                uint64_t v69 = 0;
              }
              std::mutex::unlock(v63);
              CFDictionaryRef v68 = 0;
              char v70 = 1;
LABEL_105:
              (*(void (**)(uint64_t, uint64_t))(*(void *)v69 + 80))(v69, 1);
              if ((v70 & 1) == 0) {
                sub_10004D2C8(v68);
              }
LABEL_107:
              sub_1000558F4((const void **)&v87);
              sub_1000558F4((const void **)__p);
LABEL_108:
              if (v23)
              {
LABEL_110:
                sub_1000558F4((const void **)&v78);
                sub_1000558F4((const void **)&format);
                sub_1000558F4((const void **)&alertMessage);
                sub_1000558F4((const void **)&v81);
                sub_1000FE824((const void **)&v82);
                goto LABEL_111;
              }
LABEL_109:
              sub_10004D2C8(v21);
              goto LABEL_110;
            }
            int v35 = *(NSObject **)(v3 + 40);
            if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
              goto LABEL_108;
            }
            uint64_t v54 = **(PersonalityInfo ***)(v3 + 80);
            if (v54) {
              unsigned int v55 = (const char *)PersonalityInfo::logPrefix(v54);
            }
            else {
              unsigned int v55 = "-1";
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v55;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            BOOL v72 = "#E %s%sFailed to retrieve localized message text";
LABEL_117:
            _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v72, buf, 0x16u);
            if (v23) {
              goto LABEL_110;
            }
            goto LABEL_109;
          }
        }
        else
        {
          uint64_t v33 = 0;
        }
        std::mutex::unlock(v26);
        uint64_t v32 = 0;
        char v34 = 1;
        goto LABEL_59;
      }
      CFStringRef v78 = 0;
      goto LABEL_36;
    }
  }
LABEL_112:
  sub_100A3864C(&v75);
  return sub_100046B58((uint64_t *)&v74);
}

void sub_100A384B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, char a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,int a43,__int16 a44,char a45,char a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100A3864C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100A386B0(uint64_t a1, NSObject **a2, void *a3, uint64_t a4, uint64_t *a5, int a6)
{
  *(void *)a1 = &off_101A2E980;
  uint64_t v12 = a1 + 8;
  *(void *)(a1 + 8) = &off_101A2E9F0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v28, kCtLoggingSystemName, "oos.geo.ctrl");
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  CFStringRef v13 = *a2;
  *(void *)(a1 + 32) = *a2;
  if (v13) {
    dispatch_retain(v13);
  }
  *(void *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v29, &v28);
  uint64_t v14 = (os_log_t *)(a1 + 48);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 48), (const ctu::OsLogLogger *)v29);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v29);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v28);
  *(void *)a1 = off_101A2E870;
  *(void *)(a1 + 8) = off_101A2E918;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *a3;
  uint64_t v15 = a3[1];
  *(void *)(a1 + 72) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v16 = *v14;
  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v28.varResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I GeofenceController is initializing", (uint8_t *)&v28, 2u);
  }
  int v17 = *((char *)a5 + 23);
  uint64_t v18 = (uint64_t *)*a5;
  NSStringEncoding v19 = +[NSString defaultCStringEncoding];
  if (v17 >= 0) {
    uint64_t v20 = a5;
  }
  else {
    uint64_t v20 = v18;
  }
  BOOL v21 = +[NSString stringWithCString:v20 encoding:v19];
  uint64_t v22 = [OOSLocationController alloc];
  char v23 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v22;

  id v24 = *(id *)(a1 + 56);
  if (a6) {
    id v25 = [v24 initWithBundleIdentifier:v21 withQueue:a4];
  }
  else {
    id v25 = [v24 initWithBundlePath:v21 withQueue:a4];
  }
  uint64_t v26 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v25;

  [*(id *)(a1 + 56) setDelegate:v12];
  return a1;
}

void sub_100A388D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a12);
  sub_100087E88(v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100A38954(uint64_t a1)
{
  *(void *)a1 = off_101A2E870;
  *(void *)(a1 + 8) = off_101A2E918;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  return a1;
}

uint64_t sub_100A389E0(uint64_t a1)
{
  return sub_100A38954(a1 - 8);
}

void sub_100A389E8(uint64_t a1)
{
  sub_100A38954(a1);

  operator delete();
}

void sub_100A38A20(uint64_t a1)
{
  sub_100A38954(a1 - 8);

  operator delete();
}

id sub_100A38A5C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    return objc_msgSend(v2, "isLocationServiceEnabled_sync");
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

id sub_100A38AF0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    return objc_msgSend(v2, "isCircularGeofenceSupported_sync");
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

uint64_t sub_100A38B84()
{
  return 0;
}

void sub_100A38B8C(uint64_t a1@<X0>, double *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (!*(void *)(a1 + 56))
  {
    uint64_t v16 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    __int16 v24 = 0;
    int v17 = "Invalid Location module";
    uint64_t v18 = (uint8_t *)&v24;
LABEL_19:
    NSStringEncoding v19 = v16;
LABEL_20:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v17, v18, 2u);
    goto LABEL_22;
  }
  if (*a2 > 90.0 || *a2 < -90.0)
  {
    uint64_t v16 = *(NSObject **)(a1 + 48);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    __int16 v23 = 0;
    int v17 = "Invalid latitude for OOS Geofence";
    uint64_t v18 = (uint8_t *)&v23;
    goto LABEL_19;
  }
  double v7 = a2[1];
  if (v7 > 180.0 || v7 < -180.0)
  {
    uint64_t v16 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      int v17 = "Invalid longitude for OOS Geofence";
      uint64_t v18 = buf;
      goto LABEL_19;
    }
LABEL_22:
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  uint64_t v8 = *(NSObject **)(a1 + 48);
  if (a2[2] <= 0.0)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    __int16 v21 = 0;
    int v17 = "Invalid radius for OOS Geofence";
    uint64_t v18 = (uint8_t *)&v21;
    NSStringEncoding v19 = v8;
    goto LABEL_20;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v20 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I OOS circle info is valid.", v20, 2u);
  }
  id v10 = objc_alloc((Class)NSString);
  if (*((char *)a3 + 23) >= 0) {
    long long v11 = a3;
  }
  else {
    long long v11 = (uint64_t *)*a3;
  }
  id v12 = [v10 initWithUTF8String:v11];
  CFStringRef v13 = objc_msgSend(*(id *)(a1 + 56), "setupCircularGeoFence:withName:", v12, *a2, a2[1], a2[2]);
  uint64_t v14 = operator new(0x28uLL);
  v14[1] = 0;
  void v14[2] = 0;
  *uint64_t v14 = off_101A2EB20;
  id v15 = v13;
  *((_DWORD *)v14 + 6) = 0;
  void v14[4] = v15;
  *a4 = v14 + 3;
  a4[1] = v14;
}

void sub_100A38DC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A38DE4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(NSObject **)(a1 + 48);
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        uint64_t v8 = a3;
      }
      else {
        uint64_t v8 = (uint64_t *)*a3;
      }
      int v10 = 136315138;
      long long v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Attempting to stop OOS geofencing for[%s]", (uint8_t *)&v10, 0xCu);
      uint64_t v4 = *(void **)(a1 + 56);
    }
    id v9 = *(id *)(*(void *)a2 + 8);
    [v4 stopGeofence:v9];
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_ERROR))
  {
    LOWORD(v1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", (uint8_t *)&v10, 2u);
  }
}

void sub_100A38F10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A38F28(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Attempting to reset monitored OOS regions", v4, 2u);
      uint64_t v2 = *(void **)(a1 + 56);
    }
    [v2 resetMonitoredRegions];
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Invalid Location module", buf, 2u);
  }
}

void sub_100A38FE4(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting..", v2, 2u);
  }
}

void sub_100A39044(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Ending..", v2, 2u);
  }
}

void sub_100A390A4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A391FC(uint64_t a1, uint64_t a2)
{
}

void sub_100A39204(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A3935C(uint64_t a1, uint64_t a2)
{
}

void sub_100A39364(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A394BC(uint64_t a1, uint64_t a2)
{
}

void sub_100A394C4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A3961C(uint64_t a1, uint64_t a2)
{
}

void sub_100A39624(uint64_t a1, uint64_t a2, int *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v7 = *a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A39790(uint64_t a1, uint64_t a2, int *a3)
{
}

void sub_100A39798(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A39878(uint64_t a1)
{
}

void sub_100A39880(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A39960(uint64_t a1)
{
}

void sub_100A39968(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A39AC0(uint64_t a1, uint64_t a2)
{
}

void sub_100A39AC8(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A39C20(uint64_t a1, uint64_t a2)
{
}

void sub_100A39C28(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A2EB20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A39C48(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A2EB20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A39C9C(uint64_t a1)
{
}

uint64_t *sub_100A39CA8(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    id v9 = v1 + 8;
    if (v1[31] < 0) {
      id v9 = (void *)*v9;
    }
    *(_DWORD *)long long buf = 136446210;
    CFStringRef v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to set up geofence for OOS Region %{public}s", buf, 0xCu);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 72);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(v2 + 64);
      if (v7) {
        (*(void (**)(uint64_t, char *))(*(void *)v7 + 16))(v7, v1 + 8);
      }
      sub_10004D2C8(v6);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A39DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A39DE8(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1 + 8;
    if (v1[31] < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    CFStringRef v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Successfully set up geofence for OOS Region %{public}s", buf, 0xCu);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 24))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A39F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A39F24(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1 + 8;
    if (v1[31] < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    CFStringRef v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitoring started for OOS Region %{public}s", buf, 0xCu);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 24))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A3A03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A3A060(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1 + 8;
    if (v1[31] < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    CFStringRef v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitoring failed for OOS Region %{public}s", buf, 0xCu);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 32))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A3A178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A3A19C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (void *)(v1 + 8);
    if (*(char *)(v1 + 31) < 0) {
      uint64_t v4 = (void *)*v4;
    }
    int v5 = *(_DWORD *)(v1 + 32);
    *(_DWORD *)long long buf = 136446466;
    uint64_t v14 = v4;
    __int16 v15 = 1024;
    int v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Geofence didDetermineState for OOS Region %{public}s as state %d", buf, 0x12u);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v2 + 72);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(v2 + 64);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 40))(v9, v1 + 8, v1 + 32);
      }
      sub_10004D2C8(v8);
    }
  }
  sub_100A3A2EC(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100A3A2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100A3A2EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A3A2EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

void sub_100A3A344(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[6];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Monitoring failed with error...", buf, 2u);
  }
  uint64_t v3 = (std::__shared_weak_count *)v1[9];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = v1[8];
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_100A3A420()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100A3A454(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[6];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Location services disabled", buf, 2u);
  }
  uint64_t v3 = (std::__shared_weak_count *)v1[9];
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = v1[8];
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 56))(v6);
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_100A3A530()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t *sub_100A3A564(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1 + 8;
    if (v1[31] < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    CFStringRef v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Entered OOS Region %{public}s", buf, 0xCu);
  }
  int v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void (****)(void, char *))(v2 + 64);
      if (v8) {
        (**v8)(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A3A67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A3A6A0(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = v1 + 8;
    if (v1[31] < 0) {
      uint64_t v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    CFStringRef v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Exited OOS Region %{public}s", buf, 0xCu);
  }
  int v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 8))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A3A7B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100A3A7DC(uint64_t a1, os_log_t *a2)
{
  *(void *)a1 = off_101A2EB80;
  *(void *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  uint64_t v3 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEBUG))
  {
    int v5 = 136315394;
    uint64_t v6 = "AuthScheme";
    __int16 v7 = 2080;
    uint64_t v8 = ", ";
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "#D %s%screated AuthScheme", (uint8_t *)&v5, 0x16u);
  }
  return a1;
}

uint64_t sub_100A3A8C8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_101A2EB80;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = a1 + 16;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    for (uint64_t i = *(long long **)(a2 + 32); i; uint64_t i = *(long long **)i)
    {
      *(void *)&v11[16] = 0;
      uint64_t v6 = operator new(0x40uLL);
      *(void *)long long v11 = v6;
      *(void *)&v11[8] = a1 + 32;
      *(void *)uint64_t v6 = 0;
      *((void *)v6 + 1) = 0;
      sub_100236948((char *)v6 + 16, i + 1);
      v11[16] = 1;
      *((void *)v6 + 1) = sub_100206390(a1 + 40, (uint64_t)v6 + 16);
      sub_100A3BC70(v4, *(uint64_t *)v11);
      *(void *)long long v11 = 0;
      sub_100343D9C((uint64_t)v11, 0);
    }
  }
  __int16 v7 = *(os_log_t **)(a2 + 8);
  *(void *)(a1 + 8) = v7;
  uint64_t v8 = *v7;
  if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    *(_DWORD *)long long v11 = 136315394;
    *(void *)&void v11[4] = v10;
    *(_WORD *)&v11[12] = 2080;
    *(void *)&v11[14] = ", ";
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "#D %s%scloned AuthScheme", v11, 0x16u);
  }
  return a1;
}

void sub_100A3AA8C(_Unwind_Exception *a1)
{
  sub_100343DF4(v1);
  _Unwind_Resume(a1);
}

void *sub_100A3AABC(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  int v7 = *(char *)(v6 + 23);
  if (v7 >= 0) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = *(void *)v6;
  }
  if (v7 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    uint64_t v9 = *(void *)(v6 + 8);
  }
  uint64_t v10 = sub_10004B96C(a2, v8, v9);
  sub_10004B96C(v10, (uint64_t)" ", 1);
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v24 = 1065353216;
  (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)a1 + 8))(a1, &v22, a3);
  long long v11 = (uint64_t **)v23;
  if ((void)v23)
  {
    char v12 = 1;
    do
    {
      if ((v12 & 1) == 0)
      {
        char v25 = 44;
        sub_10004B96C(a2, (uint64_t)&v25, 1);
      }
      int v13 = *((char *)v11 + 39);
      if (v13 >= 0) {
        uint64_t v14 = (uint64_t)(v11 + 2);
      }
      else {
        uint64_t v14 = (uint64_t)v11[2];
      }
      if (v13 >= 0) {
        uint64_t v15 = *((unsigned __int8 *)v11 + 39);
      }
      else {
        uint64_t v15 = (uint64_t)v11[3];
      }
      int v16 = sub_10004B96C(a2, v14, v15);
      char v25 = 61;
      int v17 = sub_10004B96C(v16, (uint64_t)&v25, 1);
      int v18 = *((char *)v11 + 63);
      if (v18 >= 0) {
        uint64_t v19 = (uint64_t)(v11 + 5);
      }
      else {
        uint64_t v19 = (uint64_t)v11[5];
      }
      if (v18 >= 0) {
        uint64_t v20 = *((unsigned __int8 *)v11 + 63);
      }
      else {
        uint64_t v20 = (uint64_t)v11[6];
      }
      sub_10004B96C(v17, v19, v20);
      char v12 = 0;
      long long v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  sub_100343DF4((uint64_t)&v22);
  return a2;
}

void sub_100A3AC28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100A3AC40(uint64_t a1, void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  int v5 = *(char *)(v4 + 23);
  if (v5 >= 0) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = *(void *)v4;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(v4 + 23);
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8);
  }
  uint64_t v8 = sub_10004B96C(a2, v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
  uint64_t v9 = std::locale::use_facet((const std::locale *)&v23, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale((std::locale *)&v23);
  std::ostream::put();
  std::ostream::flush();
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v25 = 1065353216;
  (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)a1 + 8))(a1, &v23, 1);
  for (uint64_t i = (uint64_t **)v24; i; uint64_t i = (uint64_t **)*i)
  {
    long long v11 = sub_10004B96C(a2, (uint64_t)"  ", 2);
    int v12 = *((char *)i + 39);
    if (v12 >= 0) {
      uint64_t v13 = (uint64_t)(i + 2);
    }
    else {
      uint64_t v13 = (uint64_t)i[2];
    }
    if (v12 >= 0) {
      uint64_t v14 = *((unsigned __int8 *)i + 39);
    }
    else {
      uint64_t v14 = (uint64_t)i[3];
    }
    uint64_t v15 = sub_10004B96C(v11, v13, v14);
    LOBYTE(v26.__locale_) = 61;
    int v16 = sub_10004B96C(v15, (uint64_t)&v26, 1);
    int v17 = *((char *)i + 63);
    if (v17 >= 0) {
      uint64_t v18 = (uint64_t)(i + 5);
    }
    else {
      uint64_t v18 = (uint64_t)i[5];
    }
    if (v17 >= 0) {
      uint64_t v19 = *((unsigned __int8 *)i + 63);
    }
    else {
      uint64_t v19 = (uint64_t)i[6];
    }
    uint64_t v20 = sub_10004B96C(v16, v18, v19);
    std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
    __int16 v21 = std::locale::use_facet(&v26, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
    std::locale::~locale(&v26);
    std::ostream::put();
    std::ostream::flush();
  }
  sub_100343DF4((uint64_t)&v23);
  return a2;
}

void sub_100A3AE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::locale a14)
{
}

uint64_t sub_100A3AED0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(long long **)(a1 + 32);
  if (v2)
  {
    do
    {
      long long v30 = 0u;
      long long v31 = 0u;
      long long __dst = 0u;
      sub_100236948((char *)&__dst, v2 + 1);
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v19 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      *(_OWORD *)long long __p = 0u;
      memset(v15, 0, sizeof(v15));
      sub_10004DE24((uint64_t)v15);
      LOBYTE(v13) = 34;
      int v5 = sub_10004B96C(v15, (uint64_t)&v13, 1);
      if (v31 >= 0) {
        uint64_t v6 = (char *)&v30 + 8;
      }
      else {
        uint64_t v6 = (char *)*((void *)&v30 + 1);
      }
      if (v31 >= 0) {
        uint64_t v7 = HIBYTE(v31);
      }
      else {
        uint64_t v7 = v31;
      }
      uint64_t v8 = sub_10004B96C(v5, (uint64_t)v6, v7);
      LOBYTE(v13) = 34;
      sub_10004B96C(v8, (uint64_t)&v13, 1);
      sub_10004BC98((uint64_t)v15 + 8, &v13);
      p_dst = &__dst;
      uint64_t v9 = sub_100A3C118(a2, (unsigned __int8 *)&__dst, (uint64_t)&unk_10144E20E, &p_dst);
      uint64_t v10 = v9 + 40;
      if ((char)v9[63] < 0) {
        operator delete(*(void **)v10);
      }
      *(_OWORD *)uint64_t v10 = v13;
      *((void *)v10 + 2) = v14;
      *(void *)&v15[0] = v3;
      *(void *)((char *)v15 + *(void *)(v3 - 24)) = v4;
      if (SHIBYTE(v17) < 0) {
        operator delete(__p[1]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      std::ios::~ios();
      if (SHIBYTE(v31) < 0) {
        operator delete(*((void **)&v30 + 1));
      }
      if (SBYTE7(v30) < 0) {
        operator delete((void *)__dst);
      }
      uint64_t v2 = *(long long **)v2;
    }
    while (v2);
  }
  return 1;
}

void sub_100A3B12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_1000C937C((uint64_t)&a16);
  sub_1001085D8(v16 - 160);
  _Unwind_Resume(a1);
}

uint64_t sub_100A3B16C(void **a1, uint64_t a2)
{
  for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
  {
    uint64_t v4 = i + 2;
    int v5 = i + 5;
    if ((((uint64_t (*)(void **, uint64_t *, uint64_t *))**a1)(a1, i + 2, i + 5) & 1) == 0)
    {
      uint64_t v6 = *a1[1];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = ((uint64_t (*)(void **))(*a1)[4])(a1);
        if (*((char *)i + 39) < 0) {
          uint64_t v4 = (void *)*v4;
        }
        if (*((char *)i + 63) < 0) {
          int v5 = (void *)*v5;
        }
        *(_DWORD *)long long buf = 136315906;
        uint64_t v10 = v7;
        __int16 v11 = 2080;
        int v12 = ", ";
        __int16 v13 = 2080;
        uint64_t v14 = v4;
        __int16 v15 = 2080;
        uint64_t v16 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "#E %s%sUnable to parse auth directive: %s = %s", buf, 0x2Au);
      }
    }
  }
  return 1;
}

uint64_t sub_100A3B2F8(uint64_t a1, long long *a2, const std::string *a3)
{
  uint64_t v6 = a2;
  uint64_t v4 = sub_100A3C118(a1 + 16, (unsigned __int8 *)a2, (uint64_t)&unk_10144E20E, &v6);
  std::string::operator=((std::string *)(v4 + 40), a3);
  return 1;
}

unsigned __int8 *sub_100A3B34C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = sub_1003DF000((void *)(a1 + 16), a2);
  if (v2) {
    return v2 + 40;
  }
  uint64_t result = (unsigned __int8 *)&qword_101B0FCB8[1];
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_101B0FCB8, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(qword_101B0FCB8))
    {
      __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101B0FCB8[1], (void *)&_mh_execute_header);
      __cxa_guard_release(qword_101B0FCB8);
    }
    return (unsigned __int8 *)&qword_101B0FCB8[1];
  }
  return result;
}

BOOL sub_100A3B3E4(std::string *__str, std::string::size_type __pos, uint64_t a3)
{
  memset(&__stra, 0, sizeof(__stra));
  while (1)
  {
    char v6 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    if (v6 >= 0) {
      std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __str->__r_.__value_.__l.__size_;
    }
    if (size > __pos)
    {
      if (v6 >= 0) {
        uint64_t v8 = __str;
      }
      else {
        uint64_t v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      while (v8->__r_.__value_.__s.__data_[__pos] == 32)
      {
        if (size == ++__pos) {
          goto LABEL_64;
        }
      }
    }
    if (__pos == size) {
      break;
    }
    unint64_t v9 = __pos;
    if (__pos >= size) {
      goto LABEL_37;
    }
    char v10 = 0;
    if (v6 >= 0) {
      __int16 v11 = __str;
    }
    else {
      __int16 v11 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    unint64_t v9 = __pos;
    do
    {
      while (1)
      {
        if ((*((unsigned char *)&__str->__r_.__value_.__s + 23) & 0x80) != 0)
        {
          int v12 = *(unsigned __int8 *)(__str->__r_.__value_.__r.__words[0] + v9);
          std::string::size_type v13 = __str->__r_.__value_.__l.__size_;
          uint64_t v14 = (std::string *)__str->__r_.__value_.__r.__words[0];
        }
        else
        {
          int v12 = __str->__r_.__value_.__s.__data_[v9];
          std::string::size_type v13 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
          uint64_t v14 = __str;
        }
        if (v12 == 92) {
          break;
        }
        int v16 = v14->__r_.__value_.__s.__data_[v9];
        if (v16 == 34)
        {
          v10 ^= 1u;
          goto LABEL_28;
        }
        if (v10)
        {
          ++v9;
          char v10 = 1;
          if (v9 >= size) {
            goto LABEL_64;
          }
        }
        else
        {
          if (v16 == 44) {
            goto LABEL_37;
          }
          char v10 = 0;
          if (++v9 >= size) {
            goto LABEL_37;
          }
        }
      }
      if (v9 >= v13 - 1) {
        goto LABEL_64;
      }
      int v15 = v11->__r_.__value_.__s.__data_[++v9];
      if (v15 != 34 && v15 != 92) {
        goto LABEL_64;
      }
LABEL_28:
      ++v9;
    }
    while (v9 < size);
    if (v10) {
      break;
    }
LABEL_37:
    std::string::assign(&__stra, __str, __pos, v9 - __pos);
    std::string::size_type v17 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    int v18 = (char)v17;
    if ((v17 & 0x80u) != 0) {
      std::string::size_type v17 = __str->__r_.__value_.__l.__size_;
    }
    if (v18 >= 0) {
      long long v19 = __str;
    }
    else {
      long long v19 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    do
    {
      BOOL v20 = v19->__r_.__value_.__s.__data_[v9] != 44 || v9 >= v17;
      ++v9;
    }
    while (!v20);
    BOOL v21 = v9 == 0;
    char v22 = HIBYTE(__stra.__r_.__value_.__r.__words[2]);
    if (!v9) {
      goto LABEL_65;
    }
    size_t v23 = (__stra.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(__stra.__r_.__value_.__r.__words[2])
        : __stra.__r_.__value_.__l.__size_;
    if (!v23) {
      goto LABEL_65;
    }
    long long v24 = (__stra.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__stra
        : (std::string *)__stra.__r_.__value_.__r.__words[0];
    long long v25 = memchr(v24, 61, v23);
    std::string::size_type v26 = v25 - (unsigned char *)v24;
    if (!v25 || v26 == -1) {
      goto LABEL_65;
    }
    memset(&v31, 0, sizeof(v31));
    std::string::basic_string(&v31, &__stra, 0, v26, (std::allocator<char> *)&v30);
    memset(&v30, 0, sizeof(v30));
    std::string::basic_string(&v30, &__stra, v26 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v33);
    sub_100A3B6FC(&v30, "\r\n\t \"", 3);
    uint64_t v33 = &v31;
    uint64_t v28 = sub_100A3C118(a3, (unsigned __int8 *)&v31, (uint64_t)&unk_10144E20E, (long long **)&v33);
    std::string::operator=((std::string *)(v28 + 40), &v30);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    __pos = v9 - 1;
  }
LABEL_64:
  BOOL v21 = 1;
  char v22 = HIBYTE(__stra.__r_.__value_.__r.__words[2]);
LABEL_65:
  if (v22 < 0) {
    operator delete(__stra.__r_.__value_.__l.__data_);
  }
  return v21;
}

void sub_100A3B6AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A3B6FC(std::string *__str, char *__s, char a3)
{
  std::string::size_type v6 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  else {
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  }
  std::string::size_type v8 = 0;
  if (a3)
  {
    while (1)
    {
      std::string::size_type v9 = v6;
      if ((v6 & 0x80) != 0) {
        std::string::size_type v9 = __str->__r_.__value_.__l.__size_;
      }
      if (v8 >= v9) {
        break;
      }
      char v10 = __str;
      if ((v6 & 0x80) != 0) {
        char v10 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      if (!strchr(__s, v10->__r_.__value_.__s.__data_[v8])) {
        break;
      }
      ++v8;
    }
  }
  if (v8 == size)
  {
    if ((v6 & 0x80) != 0)
    {
      *__str->__r_.__value_.__l.__data_ = 0;
      __str->__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      __str->__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__str->__r_.__value_.__s + 23) = 0;
    }
  }
  else
  {
    if ((a3 & 2) != 0 && size >= 2)
    {
      while (1)
      {
        __int16 v11 = __str;
        if ((v6 & 0x80) != 0) {
          __int16 v11 = (std::string *)__str->__r_.__value_.__r.__words[0];
        }
        if (!strchr(__s, v11->__r_.__value_.__s.__data_[size - 1])) {
          break;
        }
        if (--size <= 1)
        {
          std::string::size_type size = 1;
          break;
        }
      }
    }
    std::string::basic_string(&v12, __str, v8, size - v8, (std::allocator<char> *)&v13);
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str->__r_.__value_.__l.__data_);
    }
    *std::string __str = v12;
  }
}

uint64_t sub_100A3B830(uint64_t a1)
{
  *(_OWORD *)&v10.__r_.__value_.__l.__data_ = *(_OWORD *)"Digest";
  v10.__r_.__value_.__r.__words[2] = 0x600000000000000;
  std::string::push_back(&v10, 32);
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v2 = (const char *)a1;
  }
  else {
    uint64_t v2 = *(const char **)a1;
  }
  char v3 = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = &v10;
  }
  else {
    uint64_t v4 = (std::string *)v10.__r_.__value_.__r.__words[0];
  }
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v10.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v10.__r_.__value_.__l.__size_;
  }
  if (!strncasecmp(v2, (const char *)v4, size))
  {
    memset(v8, 0, sizeof(v8));
    uint64_t v9 = 1065353216;
    if (sub_100A3B3E4((std::string *)a1, size, (uint64_t)v8))
    {
      uint64_t v7 = sub_1003DDE88(v8, "algorithm");
      if (!v7 || std::string::compare((const std::string *)(v7 + 40), 0, 3uLL, "AKA")) {
        operator new();
      }
      operator new();
    }
    sub_100343DF4((uint64_t)v8);
    if ((*((unsigned char *)&v10.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_12;
    }
  }
  else if (v3 < 0)
  {
LABEL_12:
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_100A3B9A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void sub_100A3BA08(uint64_t *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  if (a2)
  {
    uint64_t v3 = a2;
    do
    {
      int v6 = sub_100A3C56C(a1[1], *a1, (unsigned __int8 *)a1[1]);
      std::string::push_back(a3, aAbcdefghijklmn[v6]);
      --v3;
    }
    while (v3);
  }
}

void sub_100A3BA6C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string::size_type sub_100A3BA88(std::string *a1, std::string::size_type a2, std::string *a3, unsigned __int8 a4)
{
  char v7 = 1;
  LOWORD(__p) = a4;
  std::string::size_type v4 = sub_100A3BAF8(a1, a2, a3, (char *)&__p);
  if (v7 < 0) {
    operator delete(__p);
  }
  return v4;
}

void sub_100A3BADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string::size_type sub_100A3BAF8(std::string *__str, std::string::size_type __pos, std::string *this, char *a4)
{
  std::string::size_type v4 = a4;
  std::string::size_type v6 = __pos;
  char v7 = __str;
  int v8 = SHIBYTE(__str->__r_.__value_.__r.__words[2]);
  if (v8 >= 0) {
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  if (size > __pos)
  {
    if (a4[23] >= 0) {
      std::string v10 = a4;
    }
    else {
      std::string v10 = *(char **)a4;
    }
    if (v8 >= 0) {
      __int16 v11 = __str;
    }
    else {
      __int16 v11 = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    while (strchr(v10, v11->__r_.__value_.__s.__data_[v6]))
    {
      if (size == ++v6) {
        return -1;
      }
    }
  }
  if (v6 == size) {
    return -1;
  }
  std::string::size_type v12 = v6;
  if (v6 < size)
  {
    if (v4[23] >= 0) {
      char v13 = v4;
    }
    else {
      char v13 = *(char **)v4;
    }
    if (v8 >= 0) {
      uint64_t v14 = v7;
    }
    else {
      uint64_t v14 = (std::string *)v7->__r_.__value_.__r.__words[0];
    }
    std::string::size_type v12 = v6;
    while (!strchr(v13, v14->__r_.__value_.__s.__data_[v12]))
    {
      if (size == ++v12)
      {
        std::string::size_type v12 = size;
        break;
      }
    }
  }
  std::string::assign(this, v7, v6, v12 - v6);
  int v15 = SHIBYTE(v7->__r_.__value_.__r.__words[2]);
  if (v15 >= 0) {
    std::string::size_type v16 = HIBYTE(v7->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v16 = v7->__r_.__value_.__l.__size_;
  }
  if (v12 < v16)
  {
    if (v4[23] < 0) {
      std::string::size_type v4 = *(char **)v4;
    }
    if (v15 < 0) {
      char v7 = (std::string *)v7->__r_.__value_.__r.__words[0];
    }
    while (strchr(v4, v7->__r_.__value_.__s.__data_[v12]))
    {
      if (v16 == ++v12) {
        return v16;
      }
    }
  }
  return v12;
}

const char *sub_100A3BC64()
{
  return "AuthScheme";
}

void sub_100A3BC70(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  std::string::size_type v4 = (unint64_t *)(a1 + 24);
  uint64_t v45 = (unsigned __int8 *)(a2 + 16);
  unint64_t v5 = sub_100206390(a1 + 24, a2 + 16);
  float v6 = *(float *)(a1 + 32);
  unint64_t v46 = v5;
  v2[1] = v5;
  unint64_t v7 = *(void *)(a1 + 8);
  float v8 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  if (!v7 || (float)(v6 * (float)v7) < v8)
  {
    BOOL v9 = 1;
    if (v7 >= 3) {
      BOOL v9 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v10 = v9 | (2 * v7);
    unint64_t v11 = vcvtps_u32_f32(v8 / v6);
    if (v10 <= v11) {
      int8x8_t prime = (int8x8_t)v11;
    }
    else {
      int8x8_t prime = (int8x8_t)v10;
    }
    uint64_t v44 = v4;
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    uint64_t v43 = v2;
    if (*(void *)&prime > v7)
    {
LABEL_13:
      if (*(void *)&prime >> 61) {
        sub_10006A7CC();
      }
      char v13 = operator new(8 * *(void *)&prime);
      uint64_t v14 = *(void **)a1;
      *(void *)a1 = v13;
      if (v14) {
        operator delete(v14);
      }
      uint64_t v15 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v15++) = 0;
      while (*(void *)&prime != v15);
      std::string::size_type v16 = *(unsigned __int8 ***)(a1 + 16);
      if (v16)
      {
        unint64_t v17 = (unint64_t)v16[1];
        uint8x8_t v18 = (uint8x8_t)vcnt_s8(prime);
        v18.i16[0] = vaddlv_u8(v18);
        unint64_t v19 = v18.u32[0];
        if (v18.u32[0] > 1uLL)
        {
          if (v17 >= *(void *)&prime) {
            v17 %= *(void *)&prime;
          }
        }
        else
        {
          v17 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v17) = a1 + 16;
        size_t v23 = *v16;
        if (*v16)
        {
          unint64_t v42 = v18.u32[0];
          do
          {
            unint64_t v24 = *((void *)v23 + 1);
            if (v19 > 1)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            if (v24 == v17)
            {
              std::string::size_type v16 = (unsigned __int8 **)v23;
            }
            else if (*(void *)(*(void *)a1 + 8 * v24))
            {
              long long v25 = *(unsigned __int8 **)v23;
              if (*(void *)v23)
              {
                std::string::size_type v26 = v23;
                while (1)
                {
                  int v27 = sub_1000609C0(a1 + 32, v23 + 16, v25 + 16);
                  uint64_t v28 = *(unsigned __int8 **)v26;
                  if (!v27) {
                    break;
                  }
                  long long v25 = *(unsigned __int8 **)v28;
                  std::string::size_type v26 = *(unsigned __int8 **)v26;
                  if (!*(void *)v28) {
                    goto LABEL_46;
                  }
                }
                long long v25 = *(unsigned __int8 **)v26;
                uint64_t v28 = v26;
LABEL_46:
                unint64_t v19 = v42;
              }
              else
              {
                uint64_t v28 = v23;
              }
              *std::string::size_type v16 = v25;
              *(void *)uint64_t v28 = **(void **)(*(void *)a1 + 8 * v24);
              **(void **)(*(void *)a1 + 8 * v24) = v23;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v24) = v16;
              std::string::size_type v16 = (unsigned __int8 **)v23;
              unint64_t v17 = v24;
            }
            size_t v23 = *v16;
          }
          while (*v16);
        }
      }
      goto LABEL_58;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*v4 / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (*(void *)&prime <= v20) {
        int8x8_t prime = (int8x8_t)v20;
      }
      if (*(void *)&prime < v7)
      {
        if (prime) {
          goto LABEL_13;
        }
        uint64_t v29 = *(void **)a1;
        *(void *)a1 = 0;
        if (v29) {
          operator delete(v29);
        }
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_58:
    unint64_t v7 = *(void *)(a1 + 8);
    uint64_t v2 = v43;
    std::string::size_type v4 = v44;
  }
  uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
  v30.i16[0] = vaddlv_u8(v30);
  unint64_t v31 = v30.u32[0];
  if (v30.u32[0] > 1uLL)
  {
    unint64_t v32 = v46;
    if (v7 <= v46) {
      unint64_t v32 = v46 % v7;
    }
  }
  else
  {
    unint64_t v32 = (v7 - 1) & v46;
  }
  uint64_t v33 = *(unsigned __int8 **)(*(void *)a1 + 8 * v32);
  if (v33)
  {
    char v34 = *(unsigned __int8 **)v33;
    if (*(void *)v33)
    {
      int v35 = 0;
      do
      {
        unint64_t v36 = *((void *)v34 + 1);
        if (v31 > 1)
        {
          unint64_t v37 = *((void *)v34 + 1);
          if (v36 >= v7) {
            unint64_t v37 = v36 % v7;
          }
        }
        else
        {
          unint64_t v37 = v36 & (v7 - 1);
        }
        if (v37 != v32) {
          break;
        }
        int v38 = v36 == v46 ? sub_1000609C0(a1 + 32, v34 + 16, v45) : 0;
        if (v35 & (v38 ^ 1)) {
          break;
        }
        v35 |= v38;
        uint64_t v33 = *(unsigned __int8 **)v33;
        char v34 = *(unsigned __int8 **)v33;
      }
      while (*(void *)v33);
      unint64_t v7 = *(void *)(a1 + 8);
      uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
      v39.i16[0] = vaddlv_u8(v39);
      unint64_t v31 = v39.u32[0];
    }
  }
  unint64_t v40 = v2[1];
  if (v31 > 1)
  {
    if (v40 >= v7) {
      v40 %= v7;
    }
  }
  else
  {
    v40 &= v7 - 1;
  }
  if (!v33)
  {
    *uint64_t v2 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v2;
    *(void *)(*(void *)a1 + 8 * v4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a1 + 16;
    if (!*v2) {
      goto LABEL_95;
    }
    unint64_t v41 = *(void *)(*v2 + 8);
    if (v31 > 1)
    {
      if (v41 >= v7) {
        v41 %= v7;
      }
    }
    else
    {
      v41 &= v7 - 1;
    }
LABEL_94:
    *(void *)(*(void *)a1 + 8 * v41) = v2;
    goto LABEL_95;
  }
  *uint64_t v2 = *(void *)v33;
  *(void *)uint64_t v33 = v2;
  if (*v2)
  {
    unint64_t v41 = *(void *)(*v2 + 8);
    if (v31 > 1)
    {
      if (v41 >= v7) {
        v41 %= v7;
      }
    }
    else
    {
      v41 &= v7 - 1;
    }
    if (v41 != v40) {
      goto LABEL_94;
    }
  }
LABEL_95:
  ++*v4;
}

unsigned __int8 *sub_100A3C118(uint64_t a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  unint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_100206390(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v13 = v8;
      if (v8 >= v10) {
        unint64_t v13 = v8 % v10;
      }
    }
    else
    {
      unint64_t v13 = (v10 - 1) & v8;
    }
    uint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v13);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v9)
        {
          if (sub_1000609C0(a1 + 32, i + 16, a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v16 >= v10) {
              v16 %= v10;
            }
          }
          else
          {
            v16 &= v10 - 1;
          }
          if (v16 != v13) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v13 = 0;
  }
  memset(v26, 0, sizeof(v26));
  sub_100A3C3C0(a1, v9, a4, v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_1001369F0(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v13 = v9 % v10;
      }
      else {
        unint64_t v13 = v9;
      }
    }
    else
    {
      unint64_t v13 = (v10 - 1) & v9;
    }
  }
  size_t v23 = *(void **)(*(void *)a1 + 8 * v13);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    void *v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v13) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v24 >= v10) {
          v24 %= v10;
        }
      }
      else
      {
        v24 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t i = (unsigned __int8 *)v26[0];
  v26[0] = 0;
  ++*v7;
  sub_100343D9C((uint64_t)v26, 0);
  return i;
}

void sub_100A3C3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100343D9C((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

unsigned char *sub_100A3C3C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long **a3@<X3>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  unint64_t v8 = operator new(0x40uLL);
  *a4 = v8;
  a4[1] = v7;
  *((unsigned char *)a4 + 16) = 0;
  *unint64_t v8 = 0;
  v8[1] = a2;
  uint64_t result = v8 + 2;
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)v10, *((void *)v10 + 1));
  }
  else
  {
    long long v11 = *v10;
    v8[4] = *((void *)v10 + 2);
    *(_OWORD *)uint64_t result = v11;
  }
  v8[5] = 0;
  void v8[6] = 0;
  v8[7] = 0;
  *((unsigned char *)a4 + 16) = 1;
  return result;
}

void sub_100A3C454(_Unwind_Exception *a1)
{
  sub_100343D9C(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100A3C46C(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  v1.__padding_ = 0;
  sub_10016AA28(&v1);
  operator new();
}

void sub_100A3C538(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, std::random_device a11, std::random_device a12)
{
}

uint64_t sub_100A3C56C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  LODWORD(result) = a3[1];
  int v4 = result - *a3;
  if (v4)
  {
    unsigned int v5 = v4 + 1;
    if (v4 == -1)
    {
      *(void *)&v9[0] = a2;
      *(_OWORD *)((char *)v9 + 8) = xmmword_101528C60;
      *(int64x2_t *)((char *)&v9[1] + 8) = vdupq_n_s64(2uLL);
      *(_OWORD *)((char *)&v9[2] + 8) = xmmword_101528C70;
      LOBYTE(result) = sub_100A3C720((uint64_t)v9);
    }
    else
    {
      uint64_t v7 = __clz(v5);
      uint64_t v8 = 31;
      memset(&v9[1], 0, 40);
      if (((v5 << v7) & 0x7FFFFFFF) != 0) {
        uint64_t v8 = 32;
      }
      v9[0] = 0uLL;
      sub_100A3C62C((uint64_t)v9, a2, v8 - v7);
      do
        LODWORD(result) = sub_100A3C720((uint64_t)v9);
      while (result >= v5);
      LOBYTE(result) = *a3 + result;
    }
  }
  return result;
}

uint64_t sub_100A3C62C(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  if (a3 % 0x1E) {
    unint64_t v3 = a3 / 0x1E + 1;
  }
  else {
    unint64_t v3 = a3 / 0x1E;
  }
  unint64_t v4 = a3 / v3;
  *(void *)(result + 16) = a3 / v3;
  *(void *)(result + 24) = v3;
  LODWORD(v5) = (-1 << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x20) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = v5;
  }
  *(_DWORD *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v5;
  if (v5 / v3 < (v5 ^ 0x7FFFFFFE))
  {
    ++v3;
    unint64_t v4 = a3 / v3;
    *(void *)(result + 16) = a3 / v3;
    *(void *)(result + 24) = v3;
    if (a3 / v3 > 0x1F)
    {
      *(_DWORD *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
      *(void *)(result + 32) = v3 + v4 * v3 - a3;
      goto LABEL_13;
    }
    *(_DWORD *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = (-1 << v4) & 0x7FFFFFFE;
  }
  *(void *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 <= 0x1E)
  {
    *(_DWORD *)(result + 44) = (-2 << v4) & 0x7FFFFFFE;
    int v6 = 1;
    goto LABEL_14;
  }
LABEL_13:
  int v6 = 0;
  *(_DWORD *)(result + 44) = 0;
LABEL_14:
  unsigned int v7 = 0xFFFFFFFF >> -(char)v4;
  if (!v4) {
    unsigned int v7 = 0;
  }
  unsigned int v8 = 0xFFFFFFFF >> ~(_BYTE)v4;
  if (!v6) {
    unsigned int v8 = -1;
  }
  *(_DWORD *)(result + 48) = v7;
  *(_DWORD *)(result + 52) = v8;
  return result;
}

uint64_t sub_100A3C720(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = 0;
    LODWORD(result) = 0;
    unint64_t v5 = *(void *)(a1 + 16);
    unsigned int v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        unsigned int v7 = v6 / 0xADC8;
        unsigned int v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        BOOL v9 = v8 >= v7;
        unsigned int v10 = v8 - v7;
        if (v9) {
          int v11 = 0;
        }
        else {
          int v11 = 0x7FFFFFFF;
        }
        unsigned int v6 = v11 + v10;
      }
      while (v6 - 1 >= *(_DWORD *)(a1 + 40));
      int v12 = result << v5;
      if (v5 >= 0x20) {
        int v12 = 0;
      }
      uint64_t result = ((v6 - 1) & *(_DWORD *)(a1 + 48)) + v12;
      ++v3;
    }
    while (v3 != v2);
    **(_DWORD **)a1 = v6;
  }
  else
  {
    uint64_t result = 0;
  }
  unint64_t v13 = *(void *)(a1 + 24);
  if (v2 < v13)
  {
    uint64_t v14 = *(unsigned int **)a1;
    unsigned int v15 = *(_DWORD *)(a1 + 44);
    unint64_t v16 = *(void *)(a1 + 16);
    int v17 = *(_DWORD *)(a1 + 52);
    unsigned int v18 = *v14;
    while (1)
    {
      unsigned int v19 = v18 / 0xADC8;
      unsigned int v20 = 48271 * (v18 % 0xADC8);
      v19 *= 3399;
      BOOL v9 = v20 >= v19;
      unsigned int v21 = v20 - v19;
      if (v9) {
        int v22 = 0;
      }
      else {
        int v22 = 0x7FFFFFFF;
      }
      unsigned int v18 = v22 + v21;
      if (v18 - 1 < v15)
      {
        int v23 = result << (v16 + 1);
        if (v16 >= 0x1F) {
          int v23 = 0;
        }
        uint64_t result = ((v18 - 1) & v17) + v23;
        if (++v2 == v13) {
          break;
        }
      }
    }
    *uint64_t v14 = v18;
  }
  return result;
}

uint64_t sub_100A3C848@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  unint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    unsigned int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  BOOL v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    int v11 = (GestaltUtilityInterface *)v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    int v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
LABEL_9:
  char isWatch = GestaltUtilityInterface::isWatch(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (isWatch) {
    return 1;
  }
  BOOL v23 = 0;
  uint64_t v15 = sub_100365D74();
  sub_100058DB0(__p, "EnableWiFiCallingByDefault");
  BOOL v16 = sub_1002260B0(v15, __p, &v23);
  BOOL v17 = v16;
  if (v22 < 0)
  {
    operator delete(__p[0]);
    if (v17) {
      goto LABEL_15;
    }
LABEL_17:
    (*(void (**)(void **__return_ptr))(**(void **)(a1 + 80) + 472))(__p);
    unsigned int v18 = (BOOL *)__p[0];
    unsigned __int8 v24 = 0;
    if (__p[0])
    {
      CFTypeID v19 = CFGetTypeID(__p[0]);
      if (v19 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v24, v18, v20);
        LODWORD(v18) = v24;
      }
      else
      {
        LODWORD(v18) = 0;
      }
    }
    sub_1000577C4((const void **)__p);
    return v18 != 0;
  }
  if (!v16) {
    goto LABEL_17;
  }
LABEL_15:
  LODWORD(v18) = v23;
  return v18 != 0;
}

void sub_100A3CA18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

BOOL sub_100A3CA5C(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 64);
  if (*(unsigned char *)(v2 + 49)) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = *(unsigned int *)(v2 + 52);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, &v19);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  char v13 = 1;
LABEL_12:
  (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 32))(buf, v12, v3);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (*(void *)buf) {
    BOOL v14 = (*(unsigned int (**)(void, uint64_t))(**(void **)buf + 88))(*(void *)buf, 1) == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v17 = asStringBool(v14);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v21 = 2080;
    uint64_t v22 = v17;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %s%sGot WiFi Calling Preferred In Roaming value as %s", buf, 0x20u);
  }
  return v14;
}

void sub_100A3CC88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL *sub_100A3CCCC(uint64_t a1)
{
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)a1 + 472))(&cf);
  std::random_device v1 = (BOOL *)cf;
  char v6 = 0;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v6, v1, v3);
      std::random_device v1 = (BOOL *)(v6 != 0);
    }
    else
    {
      std::random_device v1 = 0;
    }
  }
  sub_1000577C4(&cf);
  return v1;
}

void sub_100A3CD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_100A3CD90()
{
}

void sub_100A3CE78(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A3CEAC(uint64_t a1, void *a2, NSObject **a3, void *a4, uint64_t a5)
{
  unsigned int v10 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v14, kCtLoggingSystemName, "ps.wfc");
  sub_100A3CFC0(v10, a3, &v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v14);
  *(void *)a1 = off_101A2EBE0;
  *(void *)(a1 + 48) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a5;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 3;
  *(_WORD *)(a1 + 10ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 256;
  *(_DWORD *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 108) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  return a1;
}

void sub_100A3CFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100A3CFC0(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100A3D028(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_100A3D04C(void *a1)
{
  *a1 = off_101A2EBE0;
  int v2 = (std::__shared_weak_count *)a1[15];
  if (v2) {
    sub_10004D2C8(v2);
  }
  CFBooleanRef v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    sub_10004D2C8(v3);
  }
  unint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100A3D0C8(void *a1)
{
  sub_100A3D04C(a1);

  operator delete();
}

void sub_100A3D100(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v4 = 136315394;
    uint64_t v5 = v3;
    __int16 v6 = 2080;
    uint64_t v7 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sinitializing", (uint8_t *)&v4, 0x16u);
  }
  sub_100A3D1C4(a1);
}

void sub_100A3D1C4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    unsigned int v10 = (GestaltUtilityInterface *)v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v10 = 0;
  }
  std::mutex::unlock(v3);
  unsigned int v9 = 0;
  char v11 = 1;
LABEL_9:
  char isWatch = GestaltUtilityInterface::isWatch(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (isWatch)
  {
    OsLogContext v14 = (std::mutex *)Registry::getServiceMap(v12, *(Registry **)(a1 + 48));
    uint64_t v15 = v14;
    uint64_t v17 = v16;
    if (v16 < 0)
    {
      unsigned int v18 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v19 = 5381;
      do
      {
        uint64_t v17 = v19;
        unsigned int v20 = *v18++;
        uint64_t v19 = (33 * v19) ^ v20;
      }
      while (v20);
    }
    std::mutex::lock(v14);
    *(void *)long long buf = v17;
    __int16 v21 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
    if (v21)
    {
      uint64_t v23 = v21[3];
      uint64_t v22 = (std::__shared_weak_count *)v21[4];
      if (v22)
      {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v22);
        char v24 = 0;
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    std::mutex::unlock(v15);
    uint64_t v22 = 0;
    char v24 = 1;
LABEL_32:
    uint64_t v36 = kPhoneServicesWalletDomain;
    (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v23 + 72))(v23, **(void **)(a1 + 64) + 24, @"vowifi.switch.status", kPhoneServicesWalletDomain, 0, 1);
    if ((v24 & 1) == 0) {
      sub_10004D2C8(v22);
    }
    int v38 = (std::mutex *)Registry::getServiceMap(v37, *(Registry **)(a1 + 48));
    uint8x8_t v39 = v38;
    if (v16 < 0)
    {
      unint64_t v40 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v41 = 5381;
      do
      {
        uint64_t v16 = v41;
        unsigned int v42 = *v40++;
        uint64_t v41 = (33 * v41) ^ v42;
      }
      while (v42);
    }
    std::mutex::lock(v38);
    *(void *)long long buf = v16;
    uint64_t v43 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)buf);
    if (v43)
    {
      uint64_t v45 = v43[3];
      uint64_t v44 = (std::__shared_weak_count *)v43[4];
      if (v44)
      {
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v39);
        atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v44);
        char v46 = 0;
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
    std::mutex::unlock(v39);
    uint64_t v44 = 0;
    char v46 = 1;
LABEL_42:
    (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v45 + 72))(v45, **(void **)(a1 + 64) + 24, @"vowifi.roaming_switch.status", v36, 0, 1);
    if ((v46 & 1) == 0) {
      sub_10004D2C8(v44);
    }
    return;
  }
  uint64_t v94 = 0;
  sub_1003A9CA0(buf);
  BOOL v93 = (unsigned int *)sub_1003A9B04(*(uint64_t *)buf, @"switch.status", 0);
  sub_10086FCF0(&v94, (CFTypeRef *)&v93);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v94) {
    long long v25 = (uint64_t *)sub_100081E58;
  }
  else {
    long long v25 = 0;
  }
  if (v25)
  {
    std::string::size_type v26 = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)(a1 + 48));
    int v27 = v26;
    if (v28 < 0)
    {
      uint64_t v29 = (unsigned __int8 *)(v28 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v30 = 5381;
      do
      {
        uint64_t v28 = v30;
        unsigned int v31 = *v29++;
        uint64_t v30 = (33 * v30) ^ v31;
      }
      while (v31);
    }
    std::mutex::lock(v26);
    *(void *)long long buf = v28;
    unint64_t v32 = sub_10004D37C(&v27[1].__m_.__sig, (unint64_t *)buf);
    if (v32)
    {
      uint64_t v34 = v32[3];
      uint64_t v33 = (std::__shared_weak_count *)v32[4];
      if (v33)
      {
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v27);
        atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v33);
        char v35 = 0;
LABEL_46:
        (*(void (**)(uint64_t, uint64_t, const __CFString *, unsigned int *, void, void, uint64_t, void))(*(void *)v34 + 48))(v34, **(void **)(a1 + 64) + 24, @"vowifi.switch.status", v94, kPhoneServicesWalletDomain, 0, 1, 0);
        if ((v35 & 1) == 0) {
          sub_10004D2C8(v33);
        }
        sub_1003A9CA0(buf);
        sub_1003A9C3C(*(uint64_t *)buf, @"switch.status", 0);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v34 = 0;
    }
    std::mutex::unlock(v27);
    uint64_t v33 = 0;
    char v35 = 1;
    goto LABEL_46;
  }
LABEL_50:
  BOOL v93 = 0;
  sub_1003A9CA0(buf);
  int v92 = sub_1003A9B04(*(uint64_t *)buf, @"roaming_switch.status", 0);
  sub_10086FCF0(&v93, &v92);
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v93) {
    int v47 = (uint64_t *)sub_100081E58;
  }
  else {
    int v47 = 0;
  }
  if (v47)
  {
    uint64_t v48 = (std::mutex *)Registry::getServiceMap(v47, *(Registry **)(a1 + 48));
    unsigned int v49 = v48;
    if (v50 < 0)
    {
      int v51 = (unsigned __int8 *)(v50 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v52 = 5381;
      do
      {
        uint64_t v50 = v52;
        unsigned int v53 = *v51++;
        uint64_t v52 = (33 * v52) ^ v53;
      }
      while (v53);
    }
    std::mutex::lock(v48);
    *(void *)long long buf = v50;
    uint64_t v54 = sub_10004D37C(&v49[1].__m_.__sig, (unint64_t *)buf);
    if (v54)
    {
      uint64_t v56 = v54[3];
      unsigned int v55 = (std::__shared_weak_count *)v54[4];
      if (v55)
      {
        atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v49);
        atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v55);
        char v57 = 0;
LABEL_64:
        (*(void (**)(uint64_t, uint64_t, const __CFString *, unsigned int *, void, void, uint64_t, void))(*(void *)v56 + 48))(v56, **(void **)(a1 + 64) + 24, @"vowifi.roaming_switch.status", v93, kPhoneServicesWalletDomain, 0, 1, 0);
        if ((v57 & 1) == 0) {
          sub_10004D2C8(v55);
        }
        sub_1003A9CA0(buf);
        sub_1003A9C3C(*(uint64_t *)buf, @"roaming_switch.status", 0);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_68;
      }
    }
    else
    {
      uint64_t v56 = 0;
    }
    std::mutex::unlock(v49);
    unsigned int v55 = 0;
    char v57 = 1;
    goto LABEL_64;
  }
LABEL_68:
  sub_1000570E8((const void **)&v93);
  sub_1000570E8((const void **)&v94);
  uint64_t v94 = 0;
  CFDictionaryRef v59 = (std::mutex *)Registry::getServiceMap(v58, *(Registry **)(a1 + 48));
  CFDictionaryRef v60 = v59;
  uint64_t v62 = v61;
  if (v61 < 0)
  {
    CFTypeID v63 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v64 = 5381;
    do
    {
      uint64_t v62 = v64;
      unsigned int v65 = *v63++;
      uint64_t v64 = (33 * v64) ^ v65;
    }
    while (v65);
  }
  std::mutex::lock(v59);
  *(void *)long long buf = v62;
  unsigned int v66 = sub_10004D37C(&v60[1].__m_.__sig, (unint64_t *)buf);
  if (v66)
  {
    uint64_t v68 = v66[3];
    uint64_t v67 = (std::__shared_weak_count *)v66[4];
    if (v67)
    {
      atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v60);
      atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v67);
      char v69 = 0;
      goto LABEL_76;
    }
  }
  else
  {
    uint64_t v68 = 0;
  }
  std::mutex::unlock(v60);
  uint64_t v67 = 0;
  char v69 = 1;
LABEL_76:
  uint64_t v70 = kPhoneServicesWalletDomain;
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v68 + 64))(&v93, v68, **(void **)(a1 + 64) + 24, @"vowifi.switch.status", kPhoneServicesWalletDomain, 0, 1);
  sub_1000842D0(&v94, (CFTypeRef *)&v93);
  sub_1000577C4((const void **)&v93);
  if ((v69 & 1) == 0) {
    sub_10004D2C8(v67);
  }
  if (v94) {
    BOOL v72 = (uint64_t *)sub_100081E58;
  }
  else {
    BOOL v72 = 0;
  }
  if (v72)
  {
    *(_DWORD *)long long buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v94, v71);
    uint64_t v73 = *(int *)buf;
    int64_t v74 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v75 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      if (v73 > 2) {
        int v76 = (char *)&unk_10161656E;
      }
      else {
        int v76 = off_101A2EE38[v73];
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v75;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v96 = 2080;
      v97 = v76;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "#I %s%sLast known VoWiFi switch state is: %s", buf, 0x20u);
    }
    sub_100A3DCB4(a1, v73);
  }
  BOOL v93 = 0;
  uint64_t v77 = (std::mutex *)Registry::getServiceMap(v72, *(Registry **)(a1 + 48));
  CFStringRef v78 = v77;
  if (v61 < 0)
  {
    uint64_t v79 = (unsigned __int8 *)(v61 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v80 = 5381;
    do
    {
      uint64_t v61 = v80;
      unsigned int v81 = *v79++;
      uint64_t v80 = (33 * v80) ^ v81;
    }
    while (v81);
  }
  std::mutex::lock(v77);
  *(void *)long long buf = v61;
  CFURLRef v82 = sub_10004D37C(&v78[1].__m_.__sig, (unint64_t *)buf);
  if (!v82)
  {
    uint64_t v84 = 0;
    goto LABEL_95;
  }
  uint64_t v84 = v82[3];
  CFStringRef v83 = (std::__shared_weak_count *)v82[4];
  if (!v83)
  {
LABEL_95:
    std::mutex::unlock(v78);
    CFStringRef v83 = 0;
    char v85 = 1;
    goto LABEL_96;
  }
  atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v78);
  atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v83);
  char v85 = 0;
LABEL_96:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v84 + 64))(&v92, v84, **(void **)(a1 + 64) + 24, @"vowifi.roaming_switch.status", v70, 0, 1);
  sub_1000842D0(&v93, &v92);
  sub_1000577C4(&v92);
  if ((v85 & 1) == 0) {
    sub_10004D2C8(v83);
  }
  if (v93) {
    CFStringRef v87 = sub_100081E58;
  }
  else {
    CFStringRef v87 = 0;
  }
  if (v87)
  {
    *(_DWORD *)long long buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v93, v86);
    *(_DWORD *)(a1 + 104) = *(_DWORD *)buf;
    BOOL v88 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v89 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v90 = *(int *)(a1 + 104);
      if (v90 > 2) {
        uint64_t v91 = (char *)&unk_10161656E;
      }
      else {
        uint64_t v91 = off_101A2EE38[v90];
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v89;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v96 = 2080;
      v97 = v91;
      _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I %s%sLast known VoWiFi Roaming switch state is: %s", buf, 0x20u);
    }
  }
  sub_1000570E8((const void **)&v93);
  sub_1000570E8((const void **)&v94);
}

void sub_100A3DB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  sub_1000570E8((const void **)va);
  sub_1000570E8((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_100A3DCB4(uint64_t a1, int a2)
{
  uint64_t v2 = *(int *)(a1 + 88);
  if (v2 != a2)
  {
    *(_DWORD *)(a1 + 88) = a2;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      if (v2 > 2) {
        uint64_t v6 = (char *)&unk_10161656E;
      }
      else {
        uint64_t v6 = off_101A2EE38[v2];
      }
      uint64_t v7 = *(int *)(a1 + 88);
      if (v7 > 2) {
        uint64_t v8 = (char *)&unk_10161656E;
      }
      else {
        uint64_t v8 = off_101A2EE38[v7];
      }
      int v9 = 136315906;
      uint64_t v10 = v5;
      __int16 v11 = 2080;
      uint64_t v12 = " ";
      __int16 v13 = 2080;
      OsLogContext v14 = v6;
      __int16 v15 = 2080;
      uint64_t v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%ssetSwitchState_sync: user switch state changed from %s -> %s", (uint8_t *)&v9, 0x2Au);
    }
  }
}

uint64_t sub_100A3DDD8(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    if ((a2 - 1) > 5) {
      uint64_t v6 = "???";
    }
    else {
      uint64_t v6 = off_101A2EE50[a2 - 1];
    }
    int v14 = 136315650;
    uint64_t v15 = v5;
    __int16 v16 = 2080;
    uint64_t v17 = " ";
    __int16 v18 = 2080;
    uint64_t v19 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi Entitlement:%s", (uint8_t *)&v14, 0x20u);
  }
  if (*(_DWORD *)(a1 + 96) == a2)
  {
    BOOL v7 = 0;
  }
  else
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      unsigned int v10 = *(_DWORD *)(a1 + 96) - 1;
      if (v10 > 5) {
        __int16 v11 = "???";
      }
      else {
        __int16 v11 = off_101A2EE50[v10];
      }
      if ((a2 - 1) > 5) {
        uint64_t v12 = "???";
      }
      else {
        uint64_t v12 = off_101A2EE50[a2 - 1];
      }
      int v14 = 136315906;
      uint64_t v15 = v9;
      __int16 v16 = 2080;
      uint64_t v17 = " ";
      __int16 v18 = 2080;
      uint64_t v19 = v11;
      __int16 v20 = 2080;
      __int16 v21 = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi entitlement is changing from %s to %s", (uint8_t *)&v14, 0x2Au);
    }
    *(_DWORD *)(a1 + 96) = a2;
    BOOL v7 = a2 == 2;
  }
  return (*(uint64_t (**)(uint64_t, void, BOOL))(*(void *)a1 + 104))(a1, 0, v7);
}

void sub_100A3DFD4(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    if ((a2 - 1) > 2) {
      uint64_t v6 = "RequestCanceled";
    }
    else {
      uint64_t v6 = off_101A2EE20[a2 - 1];
    }
    int v7 = 136315650;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    unsigned int v10 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEntitlement complete with cause: %s", (uint8_t *)&v7, 0x20u);
  }
  if (a2 != 2)
  {
    *(unsigned char *)(a1 + 10ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    if (a2 == 3) {
      *(unsigned char *)(a1 + 101) = 0;
    }
  }
}

uint64_t sub_100A3E0E0(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t sub_100A3E10C(uint64_t result, char a2)
{
  if ((a2 & 1) == 0) {
    *(unsigned char *)(result + 101) = 1;
  }
  return result;
}

uint64_t sub_100A3E11C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 128))();
}

void sub_100A3E140(uint64_t a1)
{
}

void sub_100A3E148(uint64_t a1, int a2)
{
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 80) + 472))(cf);
  uint64_t v4 = *(BOOL **)cf;
  LOBYTE(v106) = 0;
  if (!*(void *)cf)
  {
    sub_1000577C4((const void **)cf);
    return;
  }
  CFTypeID v5 = CFGetTypeID(*(CFTypeRef *)cf);
  if (v5 == CFBooleanGetTypeID()) {
    ctu::cf::assign((ctu::cf *)&v106, v4, v6);
  }
  int v7 = v106;
  sub_1000577C4((const void **)cf);
  if (v7)
  {
    uint64_t v8 = operator new(0x10uLL);
    uint64_t v9 = kPhoneServicesWalletDomain;
    uint64_t v106 = v8;
    v107[1] = (uint64_t)(v8 + 2);
    *uint64_t v8 = kPhoneServicesWalletDomain;
    v8[1] = @"vowifi.followup";
    v107[0] = (uint64_t)(v8 + 2);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v107, *(Registry **)(a1 + 48));
    __int16 v11 = ServiceMap;
    uint64_t v13 = v12;
    if (v12 < 0)
    {
      int v14 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v15 = 5381;
      do
      {
        uint64_t v13 = v15;
        unsigned int v16 = *v14++;
        uint64_t v15 = (33 * v15) ^ v16;
      }
      while (v16);
    }
    std::mutex::lock(ServiceMap);
    *(void *)CFTypeRef cf = v13;
    uint64_t v17 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)cf);
    if (v17)
    {
      uint64_t v19 = v17[3];
      __int16 v18 = (std::__shared_weak_count *)v17[4];
      if (v18)
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v18);
        char v20 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v19 = 0;
    }
    std::mutex::unlock(v11);
    __int16 v18 = 0;
    char v20 = 1;
LABEL_14:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void **, uint64_t))(*(void *)v19 + 24))(&v108, v19, **(void **)(a1 + 64) + 24, @"shown", 0, &v106, 1);
    __int16 v21 = (int *)v108;
    *(_DWORD *)CFTypeRef cf = 0;
    if (v108)
    {
      CFTypeID v22 = CFGetTypeID(v108);
      if (v22 == CFNumberGetTypeID()) {
        ctu::cf::assign((ctu::cf *)cf, v21, v23);
      }
      LODWORD(v21) = *(_DWORD *)cf;
    }
    sub_1000577C4(&v108);
    if ((v20 & 1) == 0) {
      sub_10004D2C8(v18);
    }
    char v24 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)CFTypeRef cf = 136315906;
      *(void *)&cf[4] = v26;
      *(_WORD *)&cf[12] = 2080;
      *(void *)&cf[14] = " ";
      __int16 v110 = 1024;
      LODWORD(v111[0]) = v21;
      WORD2(v111[0]) = 1024;
      *(_DWORD *)((char *)v111 + 6) = a2;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s%sfollowUp evaluation, shownFollowUp: %d, reason: %d", cf, 0x22u);
    }
    if (v21 == -1 || v21 == a2) {
      goto LABEL_117;
    }
    if (v21 == -2)
    {
      sub_100A40084(cf, (void *)a1);
      sub_100D211E4(*(uint64_t *)cf, 0);
      int v27 = *(std::__shared_weak_count **)&cf[8];
      if (!*(void *)&cf[8])
      {
LABEL_117:
        if (v106)
        {
          v107[0] = (uint64_t)v106;
          operator delete(v106);
        }
        return;
      }
LABEL_116:
      sub_10004D2C8(v27);
      goto LABEL_117;
    }
    uint64_t v28 = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)(a1 + 48));
    uint64_t v29 = v28;
    if (v30 < 0)
    {
      unsigned int v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v32 = 5381;
      do
      {
        uint64_t v30 = v32;
        unsigned int v33 = *v31++;
        uint64_t v32 = (33 * v32) ^ v33;
      }
      while (v33);
    }
    std::mutex::lock(v28);
    *(void *)CFTypeRef cf = v30;
    uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)cf);
    if (!v34)
    {
      std::mutex::unlock(v29);
      goto LABEL_117;
    }
    uint64_t v35 = v34[3];
    uint64_t v36 = (std::__shared_weak_count *)v34[4];
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v36);
      if (!v35)
      {
LABEL_115:
        int v27 = v36;
        goto LABEL_116;
      }
    }
    else
    {
      std::mutex::unlock(v29);
      if (!v35) {
        goto LABEL_117;
      }
    }
    uint64_t v105 = 0;
    int v38 = (std::mutex *)Registry::getServiceMap(v37, *(Registry **)(a1 + 48));
    uint8x8_t v39 = v38;
    uint64_t v40 = v12;
    if (v12 < 0)
    {
      uint64_t v41 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v42 = 5381;
      do
      {
        uint64_t v40 = v42;
        unsigned int v43 = *v41++;
        uint64_t v42 = (33 * v42) ^ v43;
      }
      while (v43);
    }
    std::mutex::lock(v38);
    *(void *)CFTypeRef cf = v40;
    uint64_t v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)cf);
    if (v44)
    {
      uint64_t v46 = v44[3];
      uint64_t v45 = (std::__shared_weak_count *)v44[4];
      if (v45)
      {
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v39);
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v45);
        char v47 = 0;
        goto LABEL_44;
      }
    }
    else
    {
      uint64_t v46 = 0;
    }
    std::mutex::unlock(v39);
    uint64_t v45 = 0;
    char v47 = 1;
LABEL_44:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void **, uint64_t))(*(void *)v46 + 24))(&v108, v46, **(void **)(a1 + 64) + 24, @"id", 0, &v106, 1);
    sub_100056248(&v105, &v108);
    sub_1000577C4(&v108);
    if ((v47 & 1) == 0) {
      sub_10004D2C8(v45);
    }
    if (v105) {
      uint64_t v48 = (uint64_t *)sub_1000810B8;
    }
    else {
      uint64_t v48 = 0;
    }
    if (v48) {
      (*(void (**)(uint64_t))(*(void *)v35 + 32))(v35);
    }
    if (a2 >= 1)
    {
      uint64_t v104 = 0;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v50 = v104;
        uint64_t v104 = Mutable;
        *(void *)CFTypeRef cf = v50;
        sub_10005717C((const void **)cf);
      }
      int v51 = *(_DWORD *)(**(void **)(a1 + 64) + 52);
      CFTypeRef v108 = 0;
      *(_DWORD *)CFTypeRef cf = v51;
      CFNumberRef v52 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, cf);
      if (v52)
      {
        CFTypeRef v53 = v108;
        CFTypeRef v108 = v52;
        *(void *)CFTypeRef cf = v53;
        sub_1000570E8((const void **)cf);
      }
      uint64_t v103 = (void *)v108;
      CFTypeRef v108 = 0;
      sub_1000570E8(&v108);
      sub_10069637C(v104, @"SlotID", (uint64_t)v103);
      sub_1000570E8((const void **)&v103);
      uint64_t v103 = 0;
      unsigned int v55 = (std::mutex *)Registry::getServiceMap(v54, *(Registry **)(a1 + 48));
      uint64_t v56 = v55;
      if (v57 < 0)
      {
        CFStringRef v58 = (unsigned __int8 *)(v57 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v59 = 5381;
        do
        {
          uint64_t v57 = v59;
          unsigned int v60 = *v58++;
          uint64_t v59 = (33 * v59) ^ v60;
        }
        while (v60);
      }
      std::mutex::lock(v55);
      CFTypeRef v108 = (CFTypeRef)v57;
      uint64_t v61 = sub_10004D37C(&v56[1].__m_.__sig, (unint64_t *)&v108);
      if (v61)
      {
        uint64_t v63 = v61[3];
        uint64_t v62 = (std::__shared_weak_count *)v61[4];
        if (v62)
        {
          atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v56);
          atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v62);
          char v64 = 0;
          goto LABEL_70;
        }
      }
      else
      {
        uint64_t v63 = 0;
      }
      std::mutex::unlock(v56);
      uint64_t v62 = 0;
      char v64 = 1;
LABEL_70:
      (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t))(*(void *)v63 + 168))(cf, v63, **(void **)(a1 + 64) + 24);
      if (v110 >= 0) {
        int64_t v74 = cf;
      }
      else {
        int64_t v74 = *(unsigned char **)cf;
      }
      uint64_t v103 = (void *)CFStringCreateWithFormat(0, 0, @"prefs:root=Phone&path=Wi-Fi%%20Calling/%s", v74);
      if (v116 < 0) {
        operator delete(__p);
      }
      if (v114 < 0) {
        operator delete(v113);
      }
      if (v112 < 0) {
        operator delete(v111[0]);
      }
      if (SHIBYTE(v110) < 0) {
        operator delete(*(void **)cf);
      }
      if ((v64 & 1) == 0) {
        sub_10004D2C8(v62);
      }
      sub_10010F3F0(v104, @"URL", (uint64_t)v103);
      v102 = 0;
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, void))(*(void *)v35 + 88))(&v102, v35, 1, *(void *)(a1 + 64));
      (*(void (**)(uint64_t, uint64_t, __CFDictionary *, const void *))(*(void *)v35 + 16))(v35, 1, v104, v102);
      int v76 = (std::mutex *)Registry::getServiceMap(v75, *(Registry **)(a1 + 48));
      uint64_t v77 = v76;
      uint64_t v78 = v12;
      if (v12 < 0)
      {
        uint64_t v79 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v80 = 5381;
        do
        {
          uint64_t v78 = v80;
          unsigned int v81 = *v79++;
          uint64_t v80 = (33 * v80) ^ v81;
        }
        while (v81);
      }
      std::mutex::lock(v76);
      *(void *)CFTypeRef cf = v78;
      CFURLRef v82 = sub_10004D37C(&v77[1].__m_.__sig, (unint64_t *)cf);
      if (v82)
      {
        uint64_t v84 = v82[3];
        CFStringRef v83 = (std::__shared_weak_count *)v82[4];
        if (v83)
        {
          atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v77);
          atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v83);
          char v85 = 0;
          goto LABEL_91;
        }
      }
      else
      {
        uint64_t v84 = 0;
      }
      std::mutex::unlock(v77);
      CFStringRef v83 = 0;
      char v85 = 1;
LABEL_91:
      uint64_t v86 = **(void **)(a1 + 64);
      CFTypeRef v108 = 0;
      *(_DWORD *)CFTypeRef cf = 1;
      CFNumberRef v87 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, cf);
      if (v87)
      {
        CFTypeRef v88 = v108;
        CFTypeRef v108 = v87;
        *(void *)CFTypeRef cf = v88;
        sub_1000570E8((const void **)cf);
      }
      CFTypeRef v101 = v108;
      CFTypeRef v108 = 0;
      sub_1000570E8(&v108);
      (*(void (**)(uint64_t, uint64_t, const __CFString *, CFTypeRef, void, void **, uint64_t, void))(*(void *)v84 + 16))(v84, v86 + 24, @"shown", v101, 0, &v106, 1, 0);
      sub_1000570E8(&v101);
      if ((v85 & 1) == 0) {
        sub_10004D2C8(v83);
      }
      uint64_t v90 = (std::mutex *)Registry::getServiceMap(v89, *(Registry **)(a1 + 48));
      uint64_t v91 = v90;
      if (v12 < 0)
      {
        int v92 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v93 = 5381;
        do
        {
          uint64_t v12 = v93;
          unsigned int v94 = *v92++;
          uint64_t v93 = (33 * v93) ^ v94;
        }
        while (v94);
      }
      std::mutex::lock(v90);
      *(void *)CFTypeRef cf = v12;
      uint64_t v95 = sub_10004D37C(&v91[1].__m_.__sig, (unint64_t *)cf);
      if (v95)
      {
        uint64_t v97 = v95[3];
        __int16 v96 = (std::__shared_weak_count *)v95[4];
        if (v96)
        {
          atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v91);
          atomic_fetch_add_explicit(&v96->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v96);
          char v98 = 0;
LABEL_103:
          (*(void (**)(uint64_t, uint64_t, const __CFString *, const void *, void, void **, uint64_t, void))(*(void *)v97 + 16))(v97, **(void **)(a1 + 64) + 24, @"id", v102, 0, &v106, 1, 0);
          if ((v98 & 1) == 0) {
            sub_10004D2C8(v96);
          }
          v99 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v100 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
            *(_DWORD *)CFTypeRef cf = 136315394;
            *(void *)&cf[4] = v100;
            *(_WORD *)&cf[12] = 2080;
            *(void *)&cf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "#I %s%sfollowUp posted", cf, 0x16u);
          }
          sub_1000558F4(&v102);
          sub_1000558F4((const void **)&v103);
          sub_10005717C((const void **)&v104);
          goto LABEL_114;
        }
      }
      else
      {
        uint64_t v97 = 0;
      }
      std::mutex::unlock(v91);
      __int16 v96 = 0;
      char v98 = 1;
      goto LABEL_103;
    }
    unsigned int v65 = (std::mutex *)Registry::getServiceMap(v48, *(Registry **)(a1 + 48));
    unsigned int v66 = v65;
    if (v12 < 0)
    {
      uint64_t v67 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v68 = 5381;
      do
      {
        uint64_t v12 = v68;
        unsigned int v69 = *v67++;
        uint64_t v68 = (33 * v68) ^ v69;
      }
      while (v69);
    }
    std::mutex::lock(v65);
    *(void *)CFTypeRef cf = v12;
    uint64_t v70 = sub_10004D37C(&v66[1].__m_.__sig, (unint64_t *)cf);
    if (v70)
    {
      uint64_t v72 = v70[3];
      CFNumberRef v71 = (std::__shared_weak_count *)v70[4];
      if (v71)
      {
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v66);
        atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v71);
        char v73 = 0;
LABEL_110:
        (*(void (**)(uint64_t, uint64_t, const __CFString *, uint64_t, void, uint64_t))(*(void *)v72 + 32))(v72, **(void **)(a1 + 64) + 24, @"vowifi.followup", v9, 0, 1);
        if ((v73 & 1) == 0) {
          sub_10004D2C8(v71);
        }
        sub_100A40084(cf, (void *)a1);
        sub_100D20DC0(*(uint64_t *)cf);
        if (*(void *)&cf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&cf[8]);
        }
LABEL_114:
        sub_1000558F4(&v105);
        if (!v36) {
          goto LABEL_117;
        }
        goto LABEL_115;
      }
    }
    else
    {
      uint64_t v72 = 0;
    }
    std::mutex::unlock(v66);
    CFNumberRef v71 = 0;
    char v73 = 1;
    goto LABEL_110;
  }
}

void sub_100A3ECAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12, const void *a13, const void *a14, const void *a15, void *__p, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24)
{
  sub_1000558F4(&a12);
  sub_1000558F4(&a13);
  sub_10005717C(&a14);
  sub_1000558F4(&a15);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (__p)
  {
    a17 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A3EEC4(_WORD *a1)
{
  a1[50] = 256;
  return (*(uint64_t (**)(_WORD *, void, uint64_t))(*(void *)a1 + 104))(a1, 0, 1);
}

uint64_t sub_100A3EEF8(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonal wallet changed", (uint8_t *)&v5, 0x16u);
  }
  sub_100A3D1C4(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

const void **sub_100A3EFEC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (uint64_t *)*(unsigned int *)(a1 + 88);
  if (v4)
  {
    if (v4 != 2)
    {
      int v5 = 0;
      BOOL v6 = 0;
      BOOL v8 = *(_DWORD *)(a1 + 92) != 0;
      goto LABEL_9;
    }
    int v5 = 1;
  }
  else
  {
    int v5 = sub_100A3C848(a1, v4);
  }
  BOOL v6 = 0;
  int v7 = *(_DWORD *)(a1 + 92);
  BOOL v8 = v7 != 0;
  if (v5 && !v7)
  {
    BOOL v6 = sub_100A2EAC0(*(void *)(a1 + 80), *(_DWORD *)(a1 + 96));
    BOOL v8 = 0;
  }
LABEL_9:
  CFMutableDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFMutableDictionaryRef v10 = theDict;
    CFMutableDictionaryRef theDict = Mutable;
    *(void *)long long buf = v10;
    sub_10005717C((const void **)buf);
  }
  int v11 = *(_DWORD *)(a1 + 104);
  if (v11)
  {
    if (v11 == 2)
    {
      uint64_t v12 = theDict;
      uint64_t v13 = (const void *)kPSWifiCallingRoamingEnabled;
LABEL_15:
      uint64_t v15 = (const void **)&kCFBooleanTrue;
      BOOL v16 = 1;
      goto LABEL_19;
    }
    BOOL v16 = 0;
    uint64_t v12 = theDict;
    uint64_t v13 = (const void *)kPSWifiCallingRoamingEnabled;
  }
  else
  {
    BOOL v14 = sub_100A3CA5C(a1);
    uint64_t v12 = theDict;
    uint64_t v13 = (const void *)kPSWifiCallingRoamingEnabled;
    if (v14) {
      goto LABEL_15;
    }
    BOOL v16 = 0;
  }
  uint64_t v15 = (const void **)&kCFBooleanFalse;
LABEL_19:
  CFDictionarySetValue(v12, v13, *v15);
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v18 = *(int *)(a1 + 88);
    uint64_t v19 = (char *)&unk_10161656E;
    if (v18 <= 2) {
      uint64_t v19 = off_101A2EE38[v18];
    }
    if (v5) {
      char v20 = "on";
    }
    else {
      char v20 = "off";
    }
    uint64_t v21 = asStringBool(v6);
    if (*(unsigned char *)(**(void **)(a1 + 64) + 48)) {
      CFTypeID v22 = "";
    }
    else {
      CFTypeID v22 = "NOT ";
    }
    int v23 = *(_DWORD *)(a1 + 92);
    char v24 = "Active";
    if (v23 != 1) {
      char v24 = (const char *)&unk_10161656E;
    }
    if (v23) {
      long long v25 = v24;
    }
    else {
      long long v25 = "Disabled";
    }
    uint64_t v26 = asStringBool(v8);
    uint64_t v27 = asStringBool(v16);
    *(_DWORD *)long long buf = 136317186;
    *(void *)&uint8_t buf[4] = v29;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v32 = 2080;
    unsigned int v33 = v19;
    __int16 v34 = 2080;
    uint64_t v35 = v20;
    __int16 v36 = 2080;
    uint64_t v37 = v21;
    __int16 v38 = 2080;
    uint8x8_t v39 = v22;
    __int16 v40 = 2080;
    uint64_t v41 = v25;
    __int16 v42 = 2080;
    uint64_t v43 = v26;
    __int16 v44 = 2080;
    uint64_t v45 = v27;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi, user preference status is %s ('%s'), activating: %s; SIM is %savailable; service status: %s; isEnab"
      "led return '%s', allowed in roaming '%s'",
      buf,
      0x5Cu);
  }
  buf[0] = v8;
  *(void *)&uint8_t buf[8] = theDict;
  if (theDict) {
    CFRetain(theDict);
  }
  *(unsigned char *)a2 = v8;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&buf[8]);
  sub_10005717C((const void **)&buf[8]);
  return sub_10005717C((const void **)&theDict);
}

void sub_100A3F310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100A3F34C@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  void (***v16)(CFMutableDictionaryRef *__return_ptr, void, uint64_t);
  char v17;
  unsigned __int8 v18;
  char v19;
  BOOL v20;
  int v21;
  unsigned int v22;
  CFMutableDictionaryRef v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  __CFDictionary *Mutable;
  CFMutableDictionaryRef v28;
  BOOL v29;
  int v30;
  int v31;
  const void **v32;
  unsigned int v33;
  const void **v34;
  __CFDictionary *v36;
  CFMutableDictionaryRef v37;
  std::__shared_weak_count *v38;
  CFMutableDictionaryRef theDict;

  BOOL v6 = sub_100A2E718(*(void *)(a1 + 80));
  uint64_t v37 = 0;
  __int16 v38 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)(a1 + 48));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  CFMutableDictionaryRef theDict = (CFMutableDictionaryRef)v10;
  BOOL v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&theDict);
  if (v14)
  {
    BOOL v16 = (void (***)(CFMutableDictionaryRef *__return_ptr, void, uint64_t))v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      uint64_t v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v16 = 0;
  }
  std::mutex::unlock(v9);
  uint64_t v15 = 0;
  uint64_t v17 = 1;
LABEL_9:
  (**v16)(&v37, v16, **(void **)(a1 + 64) + 24);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v37) {
    uint64_t v18 = (*(uint64_t (**)(CFMutableDictionaryRef, uint64_t))(*(void *)v37 + 488))(v37, 7);
  }
  else {
    uint64_t v18 = 0;
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  uint64_t v19 = v18 | v6;
  CFMutableDictionaryRef theDict = 0;
  if (((v18 | v6) & 1) == 0)
  {
    LOBYTE(v21) = 0;
    LOBYTE(v2ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    LOBYTE(v37) = v19;
    *(_WORD *)((char *)&v37 + 1) = 0;
    __int16 v38 = 0;
    goto LABEL_59;
  }
  if (*(_DWORD *)(a1 + 96) == 2)
  {
    char v20 = 1;
  }
  else
  {
    char v20 = sub_100A2E718(*(void *)(a1 + 80));
    CFTypeID v22 = *(_DWORD *)(a1 + 96);
    if ((v22 > 5 || ((1 << v22) & 0x26) == 0) && !sub_100A2E718(*(void *)(a1 + 80)))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v28 = theDict;
        CFMutableDictionaryRef theDict = Mutable;
        uint64_t v37 = v28;
        sub_10005717C((const void **)&v37);
      }
      uint64_t v21 = 0;
      goto LABEL_23;
    }
  }
  sub_100A30BFC(*(void *)(a1 + 80), &v36);
  int v23 = theDict;
  CFMutableDictionaryRef theDict = v36;
  __int16 v36 = 0;
  uint64_t v37 = v23;
  sub_10005717C((const void **)&v37);
  sub_10005717C((const void **)&v36);
  uint64_t v21 = 1;
LABEL_23:
  char v24 = *(void *)(a1 + 80);
  if (a2)
  {
    if (*(unsigned char *)(v24 + 344) && *(unsigned char *)(v24 + 216))
    {
      if (*(char *)(v24 + 215) < 0) {
        long long v25 = *(void *)(v24 + 200);
      }
      else {
        long long v25 = *(unsigned __int8 *)(v24 + 215);
      }
      uint64_t v26 = v25 == 0;
    }
    else
    {
      uint64_t v26 = 1;
    }
  }
  else
  {
    uint64_t v26 = 0;
  }
  uint64_t v29 = 0;
  uint64_t v30 = *(_DWORD *)(a1 + 88) == 2 || v26;
  if (*(_DWORD *)(a1 + 92) != 1 && v30) {
    uint64_t v29 = sub_100A2EAC0(*(void *)(a1 + 80), *(_DWORD *)(a1 + 96))
  }
       || *(unsigned char *)(v24 + 353)
       || *(unsigned char *)(a1 + 100) != 0;
  unsigned int v31 = sub_100A2EB20(v24);
  if (v20)
  {
    if (v29)
    {
      __int16 v32 = (const void **)&kCTProvisioningStatusInProcess;
    }
    else if (v31 == 1)
    {
      __int16 v32 = (const void **)&kCTProvisioningStatusSubscribed;
    }
    else
    {
      __int16 v32 = (const void **)&kCTProvisioningStatusNotSubscribed;
    }
  }
  else if (v21)
  {
    __int16 v32 = (const void **)&kCTProvisioningStatusInProcess;
    if (!v29) {
      __int16 v32 = (const void **)&kCTProvisioningStatusNotSubscribed;
    }
  }
  else
  {
    __int16 v32 = (const void **)&kCTProvisioningStatusNotAllowed;
  }
  CFDictionarySetValue(theDict, kCTProvisioningStatus, *v32);
  unsigned int v33 = sub_100A3CCCC(*(void *)(a1 + 80));
  __int16 v34 = (const void **)&kCFBooleanFalse;
  if (v33) {
    __int16 v34 = (const void **)&kCFBooleanTrue;
  }
  CFDictionarySetValue(theDict, kPSWifiCallingRoamingCanSet, *v34);
  LOBYTE(v37) = v19;
  BYTE1(v37) = v21;
  BYTE2(v37) = v20;
  __int16 v38 = (std::__shared_weak_count *)theDict;
  if (theDict) {
    CFRetain(theDict);
  }
LABEL_59:
  *(unsigned char *)a3 = v19;
  *(unsigned char *)(a3 + 1) = v21;
  *(unsigned char *)(a3 + 2) = v20;
  sub_10004EFE4((void *)(a3 + 8), (CFTypeRef *)&v38);
  sub_10005717C((const void **)&v38);
  return sub_10005717C((const void **)&theDict);
}

void sub_100A3F758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100A3F798()
{
  if ((v0 & 1) == 0) {
    JUMPOUT(0x100A3F7A0);
  }
  JUMPOUT(0x100A3F790);
}

void sub_100A3F7B0(uint64_t a1, int a2, CFDictionaryRef *a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 48));
  int v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    BOOL v14 = (GestaltUtilityInterface *)v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_9:
  char isWatch = GestaltUtilityInterface::isWatch(v14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (isWatch)
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "#E %s%ssetEnabled: SHOULDN'T BE CALLED on Watch!", buf, 0x16u);
    }
    return;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 96);
  if ((v19 > 5 || ((1 << v19) & 0x26) == 0) && (sub_100A2E718(*(void *)(a1 + 80)) | a2 ^ 1) != 1)
  {
    unsigned int v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v34;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi cannot be turned ON since feature is not allowed", buf, 0x16u);
    }
    sub_100A2FD3C(*(void *)(a1 + 80), 0, 1);
    return;
  }
  if (*a3) {
    char v20 = sub_100080778;
  }
  else {
    char v20 = 0;
  }
  if (v20)
  {
    if (sub_100A3CCCC(*(void *)(a1 + 80)))
    {
      CFTypeRef Value = CFDictionaryGetValue(*a3, kPSWifiCallingRoamingEnabled);
      if (Value)
      {
        if (CFEqual(Value, kCFBooleanTrue)) {
          uint64_t v22 = 2;
        }
        else {
          uint64_t v22 = 1;
        }
        *(_DWORD *)(a1 + 104) = v22;
        int v23 = (std::mutex *)Registry::getServiceMap((uint64_t *)v22, *(Registry **)(a1 + 48));
        char v24 = v23;
        if (v25 < 0)
        {
          uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v27 = 5381;
          do
          {
            uint64_t v25 = v27;
            unsigned int v28 = *v26++;
            uint64_t v27 = (33 * v27) ^ v28;
          }
          while (v28);
        }
        std::mutex::lock(v23);
        *(void *)long long buf = v25;
        uint64_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)buf);
        if (v29)
        {
          uint64_t v31 = v29[3];
          uint64_t v30 = (std::__shared_weak_count *)v29[4];
          if (v30)
          {
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v24);
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v30);
            char v32 = 0;
LABEL_37:
            uint64_t v35 = **(void **)(a1 + 64);
            uint64_t v36 = *(unsigned int *)(a1 + 104);
            CFNumberRef v76 = 0;
            *(void *)long long buf = v36;
            CFNumberRef v37 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
            if (v37)
            {
              CFNumberRef v38 = v76;
              CFNumberRef v76 = v37;
              *(void *)long long buf = v38;
              sub_1000570E8((const void **)buf);
            }
            CFNumberRef v75 = v76;
            CFNumberRef v76 = 0;
            sub_1000570E8((const void **)&v76);
            (*(void (**)(uint64_t, uint64_t, const __CFString *, CFNumberRef, void, void, uint64_t, void))(*(void *)v31 + 48))(v31, v35 + 24, @"vowifi.roaming_switch.status", v75, kPhoneServicesWalletDomain, 0, 1, 0);
            sub_1000570E8((const void **)&v75);
            if ((v32 & 1) == 0) {
              sub_10004D2C8(v30);
            }
            goto LABEL_41;
          }
        }
        else
        {
          uint64_t v31 = 0;
        }
        std::mutex::unlock(v24);
        uint64_t v30 = 0;
        char v32 = 1;
        goto LABEL_37;
      }
    }
  }
LABEL_41:
  if (a2) {
    int v39 = 2;
  }
  else {
    int v39 = 1;
  }
  __int16 v40 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v41 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    __int16 v42 = "Disabled";
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v41;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    if (a2) {
      __int16 v42 = "Enabled";
    }
    __int16 v78 = 2080;
    uint64_t v79 = (void *)v42;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi, switch state: %s", buf, 0x20u);
  }
  sub_100A3DCB4(a1, v39);
  if ((isReal() & 1) == 0)
  {
    unsigned int v49 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_67;
    }
    uint64_t v50 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v50;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    int v51 = "#I %s%sevaluateWiFiLocationRequirement: Skipping location evaluation for emergency personality";
    CFNumberRef v52 = v49;
    uint32_t v53 = 22;
    goto LABEL_66;
  }
  int v43 = *(_DWORD *)(a1 + 88);
  if (v43 == 2)
  {
    char v54 = 1;
  }
  else
  {
    if (!v43)
    {
      __int16 v44 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      uint64_t v46 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v47 = *(int *)(a1 + 88);
      if (v47 > 2) {
        uint64_t v48 = (char *)&unk_10161656E;
      }
      else {
        uint64_t v48 = off_101A2EE38[v47];
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v46;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v78 = 2080;
      uint64_t v79 = v48;
      int v51 = "#I %s%sevaluateWiFiLocationRequirement: Skipping location evaluation for switch state %s";
      CFNumberRef v52 = v44;
      uint32_t v53 = 32;
LABEL_66:
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v51, buf, v53);
      goto LABEL_67;
    }
    char v54 = 0;
  }
  *(unsigned char *)(a1 + 108) = v54;
  unsigned int v55 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v56 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v57 = *(int *)(a1 + 88);
    if (v57 > 2) {
      CFStringRef v58 = (char *)&unk_10161656E;
    }
    else {
      CFStringRef v58 = off_101A2EE38[v57];
    }
    uint64_t v59 = asStringBool(*(unsigned char *)(a1 + 108));
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v56;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    __int16 v78 = 2080;
    uint64_t v79 = v58;
    __int16 v80 = 2080;
    uint64_t v81 = v59;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I %s%sevaluateWiFiLocationRequirement: fSwitchState: %s, locationRequired: %s", buf, 0x2Au);
  }
  sub_100A3344C(*(void *)(a1 + 80));
LABEL_67:
  unsigned int v60 = (std::mutex *)Registry::getServiceMap(v45, *(Registry **)(a1 + 48));
  uint64_t v61 = v60;
  if (v62 < 0)
  {
    uint64_t v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v64 = 5381;
    do
    {
      uint64_t v62 = v64;
      unsigned int v65 = *v63++;
      uint64_t v64 = (33 * v64) ^ v65;
    }
    while (v65);
  }
  std::mutex::lock(v60);
  *(void *)long long buf = v62;
  unsigned int v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
  if (!v66)
  {
    uint64_t v68 = 0;
    goto LABEL_74;
  }
  uint64_t v68 = v66[3];
  uint64_t v67 = (std::__shared_weak_count *)v66[4];
  if (!v67)
  {
LABEL_74:
    std::mutex::unlock(v61);
    uint64_t v67 = 0;
    char v69 = 1;
    goto LABEL_75;
  }
  atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v61);
  atomic_fetch_add_explicit(&v67->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v67);
  char v69 = 0;
LABEL_75:
  uint64_t v70 = **(void **)(a1 + 64);
  uint64_t v71 = *(unsigned int *)(a1 + 88);
  CFNumberRef v76 = 0;
  *(void *)long long buf = v71;
  CFNumberRef v72 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
  if (v72)
  {
    CFNumberRef v73 = v76;
    CFNumberRef v76 = v72;
    *(void *)long long buf = v73;
    sub_1000570E8((const void **)buf);
  }
  CFNumberRef v74 = v76;
  CFNumberRef v75 = v76;
  CFNumberRef v76 = 0;
  sub_1000570E8((const void **)&v76);
  (*(void (**)(uint64_t, uint64_t, const __CFString *, CFNumberRef, void, void, uint64_t, void))(*(void *)v68 + 48))(v68, v70 + 24, @"vowifi.switch.status", v74, kPhoneServicesWalletDomain, 0, 1, 0);
  sub_1000570E8((const void **)&v75);
  if ((v69 & 1) == 0) {
    sub_10004D2C8(v67);
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, 1, 0);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_100A32410(*(void *)(a1 + 80), 2, buf);
  if (*(void *)buf) {
    (*(void (**)(void, void, void))(**(void **)buf + 104))(*(void *)buf, 0, 0);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
}

void sub_100A3FFE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000570E8(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A40074(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 108);
}

uint64_t sub_100A4007C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 92);
}

void sub_100A40084(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a2[2];
  if (!v3 || (int v5 = std::__shared_weak_count::lock(v3)) == 0) {
    sub_100088B9C();
  }
  BOOL v6 = v5;
  p_shared_weak_owners = &v5->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v5);
  if (!a2[14])
  {
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    sub_100D2031C();
  }
  uint64_t v8 = a2[15];
  *a1 = a2[14];
  a1[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  std::__shared_weak_count::__release_weak(v6);
}

void sub_100A401D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  std::__shared_weak_count::__release_weak(v17);
  _Unwind_Resume(a1);
}

void sub_100A401F0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (!v2) {
    return;
  }
  uint64_t v3 = a1[4];
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4) {
    return;
  }
  int v5 = v4;
  if (a1[5])
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v3 + 48));
    int v7 = ServiceMap;
    if (v8 < 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    long long __p = (void *)v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__p);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unsigned int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_13:
        uint64_t v16 = **(void **)(v3 + 64);
        uint64_t v17 = operator new(0x10uLL);
        unsigned int v19 = v17 + 2;
        char v20 = v17 + 2;
        void *v17 = kPhoneServicesWalletDomain;
        v17[1] = @"vowifi.followup";
        long long __p = v17;
        (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void **, uint64_t))(*(void *)v14 + 32))(v14, v16 + 24, @"shown", 0, &__p, 1);
        if (__p)
        {
          unsigned int v19 = __p;
          operator delete(__p);
        }
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        (*(void (**)(uint64_t, void, void))(*(void *)v3 + 104))(v3, 0, 0);
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    goto LABEL_13;
  }
LABEL_18:

  sub_10004D2C8(v5);
}

void sub_100A403D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_100A4041C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A40438(uint64_t a1)
{
  std::random_device v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A40448(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sfollowUp complete", buf, 0x16u);
  }
  BOOL v6 = operator new(0x10uLL);
  long long __p = v6;
  uint64_t v84 = v6 + 2;
  void *v6 = kPhoneServicesWalletDomain;
  v6[1] = @"vowifi.followup";
  CFStringRef v83 = v6 + 2;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v8 = ServiceMap;
  uint64_t v10 = v9;
  if (v9 < 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v8);
  char v15 = 0;
  char v17 = 1;
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void **, uint64_t))(*(void *)v16 + 32))(v16, **(void **)(a1 + 64) + 24, @"id", 0, &__p, 1);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"Action");
  CFStringRef v19 = Value;
  if (!Value
    || (CFTypeID v20 = CFGetTypeID(Value), v20 != CFStringGetTypeID())
    || CFStringCompare(v19, @"com.followup.dismiss", 0))
  {
    uint64_t v21 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v22 = v21;
    if (v9 < 0)
    {
      int v23 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v24 = 5381;
      do
      {
        uint64_t v9 = v24;
        unsigned int v25 = *v23++;
        uint64_t v24 = (33 * v24) ^ v25;
      }
      while (v25);
    }
    std::mutex::lock(v21);
    *(void *)long long buf = v9;
    uint64_t v26 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
    if (v26)
    {
      uint64_t v28 = v26[3];
      uint64_t v27 = (std::__shared_weak_count *)v26[4];
      if (v27)
      {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v27);
        char v29 = 0;
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    std::mutex::unlock(v22);
    uint64_t v27 = 0;
    char v29 = 1;
LABEL_24:
    uint64_t v30 = **(void **)(a1 + 64);
    CFTypeRef cf = 0;
    *(_DWORD *)long long buf = -1;
    CFNumberRef v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
    if (v31)
    {
      CFTypeRef v32 = cf;
      CFTypeRef cf = v31;
      *(void *)long long buf = v32;
      sub_1000570E8((const void **)buf);
    }
    CFTypeRef v33 = cf;
    CFTypeRef v81 = cf;
    CFTypeRef cf = 0;
    sub_1000570E8(&cf);
    (*(void (**)(uint64_t, uint64_t, const __CFString *, CFTypeRef, void, void **, uint64_t, void))(*(void *)v28 + 16))(v28, v30 + 24, @"shown", v33, 0, &__p, 1, 0);
    sub_1000570E8(&v81);
    if ((v29 & 1) == 0) {
      sub_10004D2C8(v27);
    }
    uint64_t v34 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v35;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      uint64_t v36 = "#I %s%sFollowUp WiFiCalling succeed";
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v36, buf, 0x16u);
      goto LABEL_31;
    }
    goto LABEL_31;
  }
  CFNumberRef v37 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  CFNumberRef v38 = v37;
  uint64_t v39 = v9;
  if (v9 < 0)
  {
    __int16 v40 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v41 = 5381;
    do
    {
      uint64_t v39 = v41;
      unsigned int v42 = *v40++;
      uint64_t v41 = (33 * v41) ^ v42;
    }
    while (v42);
  }
  std::mutex::lock(v37);
  *(void *)long long buf = v39;
  int v43 = sub_10004D37C(&v38[1].__m_.__sig, (unint64_t *)buf);
  if (v43)
  {
    uint64_t v45 = v43[3];
    __int16 v44 = (std::__shared_weak_count *)v43[4];
    if (v44)
    {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v38);
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v44);
      char v46 = 0;
      goto LABEL_42;
    }
  }
  else
  {
    uint64_t v45 = 0;
  }
  std::mutex::unlock(v38);
  __int16 v44 = 0;
  char v46 = 1;
LABEL_42:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, const __CFString *, void, void **, uint64_t))(*(void *)v45 + 24))(&cf, v45, **(void **)(a1 + 64) + 24, @"left.attempts", 0, &__p, 1);
  uint64_t v47 = (int *)cf;
  int v48 = 5;
  *(_DWORD *)long long buf = 5;
  if (cf)
  {
    CFTypeID v49 = CFGetTypeID(cf);
    if (v49 == CFNumberGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v47, v50);
    }
    int v48 = *(_DWORD *)buf;
  }
  sub_1000577C4(&cf);
  if ((v46 & 1) == 0) {
    sub_10004D2C8(v44);
  }
  if (v48)
  {
    int v51 = v48 - 1;
    CFNumberRef v52 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v53 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v53;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v87 = 1024;
      int v88 = 168;
      __int16 v89 = 1024;
      int v90 = v48 - 1;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I %s%sScheduling future followup attempt in %d hours. %d attempts left", buf, 0x22u);
    }
    char v54 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    unsigned int v55 = v54;
    uint64_t v56 = v9;
    if (v9 < 0)
    {
      uint64_t v57 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v58 = 5381;
      do
      {
        uint64_t v56 = v58;
        unsigned int v59 = *v57++;
        uint64_t v58 = (33 * v58) ^ v59;
      }
      while (v59);
    }
    std::mutex::lock(v54);
    *(void *)long long buf = v56;
    unsigned int v60 = sub_10004D37C(&v55[1].__m_.__sig, (unint64_t *)buf);
    if (v60)
    {
      uint64_t v62 = v60[3];
      uint64_t v61 = (std::__shared_weak_count *)v60[4];
      if (v61)
      {
        atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v55);
        atomic_fetch_add_explicit(&v61->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v61);
        char v63 = 0;
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v62 = 0;
    }
    std::mutex::unlock(v55);
    uint64_t v61 = 0;
    char v63 = 1;
LABEL_61:
    uint64_t v65 = **(void **)(a1 + 64);
    CFTypeRef cf = 0;
    *(_DWORD *)long long buf = v51;
    CFNumberRef v66 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
    if (v66)
    {
      CFTypeRef v67 = cf;
      CFTypeRef cf = v66;
      *(void *)long long buf = v67;
      sub_1000570E8((const void **)buf);
    }
    CFTypeRef v81 = cf;
    CFTypeRef cf = 0;
    sub_1000570E8(&cf);
    (*(void (**)(uint64_t, uint64_t, const __CFString *, CFTypeRef, void, void **, uint64_t, void))(*(void *)v62 + 16))(v62, v65 + 24, @"left.attempts", v81, 0, &__p, 1, 0);
    sub_1000570E8(&v81);
    if ((v63 & 1) == 0) {
      sub_10004D2C8(v61);
    }
    uint64_t v68 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    char v69 = v68;
    if (v9 < 0)
    {
      uint64_t v70 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v71 = 5381;
      do
      {
        uint64_t v9 = v71;
        unsigned int v72 = *v70++;
        uint64_t v71 = (33 * v71) ^ v72;
      }
      while (v72);
    }
    std::mutex::lock(v68);
    *(void *)long long buf = v9;
    CFNumberRef v73 = sub_10004D37C(&v69[1].__m_.__sig, (unint64_t *)buf);
    if (v73)
    {
      uint64_t v75 = v73[3];
      CFNumberRef v74 = (std::__shared_weak_count *)v73[4];
      if (v74)
      {
        atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v69);
        atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v74);
        char v76 = 0;
LABEL_73:
        uint64_t v77 = **(void **)(a1 + 64);
        CFTypeRef cf = 0;
        *(_DWORD *)long long buf = -2;
        CFNumberRef v78 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
        if (v78)
        {
          CFTypeRef v79 = cf;
          CFTypeRef cf = v78;
          *(void *)long long buf = v79;
          sub_1000570E8((const void **)buf);
        }
        CFTypeRef v80 = cf;
        CFTypeRef v81 = cf;
        CFTypeRef cf = 0;
        sub_1000570E8(&cf);
        (*(void (**)(uint64_t, uint64_t, const __CFString *, CFTypeRef, void, void **, uint64_t, void))(*(void *)v75 + 16))(v75, v77 + 24, @"shown", v80, 0, &__p, 1, 0);
        sub_1000570E8(&v81);
        if ((v76 & 1) == 0) {
          sub_10004D2C8(v74);
        }
        sub_100A40084(buf, (void *)a1);
        sub_100D211E4(*(uint64_t *)buf, 1);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v75 = 0;
    }
    std::mutex::unlock(v69);
    CFNumberRef v74 = 0;
    char v76 = 1;
    goto LABEL_73;
  }
  uint64_t v34 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v64 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v64;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = " ";
    uint64_t v36 = "#I %s%sIt was last attempt to FollowUp WiFiCalling";
    goto LABEL_30;
  }
LABEL_31:
  if (__p)
  {
    CFStringRef v83 = __p;
    operator delete(__p);
  }
}

void sub_100A40CE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A40DF8(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (*(unsigned char *)(v4 + 354)) {
    return;
  }
  if (*(_DWORD *)(a1 + 96) == 2)
  {
    BOOL v7 = 1;
    BOOL v8 = 1;
  }
  else
  {
    BOOL v7 = sub_100A2E718(v4);
    unsigned int v9 = *(_DWORD *)(a1 + 96);
    BOOL v8 = 1;
    BOOL v10 = v9 > 5;
    int v11 = (1 << v9) & 0x26;
    if (v10 || v11 == 0) {
      BOOL v8 = sub_100A2E718(*(void *)(a1 + 80));
    }
  }
  unsigned int v13 = (uint64_t *)*(unsigned int *)(a1 + 88);
  if (v13) {
    int v14 = v13 == 2;
  }
  else {
    int v14 = sub_100A3C848(a1, v13);
  }
  if (v7 || !v8 || !sub_100A3C848(a1, (uint64_t *)(v7 || !v8)))
  {
    unsigned int v16 = 0;
  }
  else
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 80) + 472))(cf);
    char v15 = *(BOOL **)cf;
    unsigned int v16 = 1;
    char v38 = 1;
    if (*(void *)cf)
    {
      CFTypeID v17 = CFGetTypeID(*(CFTypeRef *)cf);
      if (v17 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v38, v15, v18);
        unsigned int v16 = v38 != 0;
      }
      else
      {
        unsigned int v16 = 1;
      }
    }
    sub_1000577C4((const void **)cf);
  }
  if ((v7 | v16) != 1)
  {
    int v19 = -1;
    if (!v16) {
      goto LABEL_27;
    }
LABEL_25:
    if (*(unsigned char *)(a1 + 101)) {
      (*(void (**)(uint64_t))(*(void *)a1 + 168))(a1);
    }
    goto LABEL_27;
  }
  int v19 = sub_100A2EB74(*(void *)(a1 + 80), a2 | a3, v16);
  if (v16) {
    goto LABEL_25;
  }
LABEL_27:
  if ((v14 & v7) == 1 && v19 == 1 && (CFTypeID v20 = **(PersonalityInfo ***)(a1 + 64), *((unsigned char *)v20 + 48)))
  {
    if (*(_DWORD *)(a1 + 92) != 1)
    {
      uint64_t v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = PersonalityInfo::logPrefix(v20);
        *(_DWORD *)CFTypeRef cf = 136315394;
        *(void *)&cf[4] = v22;
        __int16 v40 = 2080;
        uint64_t v41 = " ";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I %s%sActivating VoWiFi phone service!", cf, 0x16u);
      }
      *(_DWORD *)(a1 + 92) = 1;
      sub_100A41314(a1);
    }
  }
  else
  {
    int v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      unsigned int v25 = "OFF";
      int v26 = *(unsigned __int8 *)(**(void **)(a1 + 64) + 48);
      if (v14) {
        unsigned int v25 = "ON";
      }
      if (v7) {
        uint64_t v27 = "";
      }
      else {
        uint64_t v27 = "NOT ";
      }
      uint64_t v28 = "Good";
      *(void *)&cf[4] = v24;
      if (v19 == -1) {
        uint64_t v28 = "Incomplete";
      }
      *(_DWORD *)CFTypeRef cf = 136316418;
      uint64_t v41 = " ";
      int v43 = v25;
      char v29 = "Pending";
      __int16 v40 = 2080;
      __int16 v42 = 2080;
      if (v19) {
        char v29 = v28;
      }
      __int16 v44 = 2080;
      uint64_t v45 = v27;
      __int16 v46 = 2080;
      if (v26) {
        uint64_t v30 = "";
      }
      else {
        uint64_t v30 = "NOT ";
      }
      uint64_t v47 = v29;
      __int16 v48 = 2080;
      CFTypeID v49 = v30;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi service disabled because: switch is %s, service is %sallowed, account status is %s, SIM is %savailable", cf, 0x3Eu);
    }
    if (*(_DWORD *)(a1 + 92))
    {
      CFNumberRef v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        *(_DWORD *)CFTypeRef cf = 136315394;
        *(void *)&cf[4] = v32;
        __int16 v40 = 2080;
        uint64_t v41 = " ";
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I %s%sDeactivating VoWiFi phone service!", cf, 0x16u);
      }
      *(_DWORD *)(a1 + 92) = 0;
      sub_100A41314(a1);
    }
    if ((v14 & v8) == 1 && v19 == -1 && *(unsigned char *)(**(void **)(a1 + 64) + 48) && !*(_DWORD *)(a1 + 88)) {
      sub_100A3E148(a1, 1);
    }
  }
  uint64_t v33 = *(void *)(a1 + 80);
  BOOL v34 = *(_DWORD *)(a1 + 92) == 1;
  sub_100058DB0(__p, "");
  (*(void (**)(uint64_t, void, BOOL, void **))(*(void *)v33 + 448))(v33, 0, v34, __p);
  if (v37 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v35 = *(void *)(a1 + 80);
  if (!*(unsigned char *)(v35 + 353) && !*(unsigned char *)(a1 + 100))
  {
    sub_100A2FBE8((uint64_t *)v35, 0);
    uint64_t v35 = *(void *)(a1 + 80);
  }
  sub_100A2FD3C(v35, 0, a2);
}

void sub_100A412E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, const void *a16)
{
}

void sub_100A41314(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 96) == 2 || (uint64_t v2 = (const void **)sub_100A2E718(*(void *)(a1 + 80)), v2))
  {
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)a1 + 48))(buf, a1);
    int v3 = buf[0];
    uint64_t v2 = sub_100057D78((const void **)&buf[8]);
  }
  else
  {
    int v3 = 2;
  }
  uint64_t v4 = *(PersonalityInfo ***)(a1 + 64);
  uint64_t v5 = *v4;
  switch(*((_DWORD *)*v4 + 13))
  {
    case 0:
    case 3:
      BOOL v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = PersonalityInfo::logPrefix(v5);
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v7;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = " ";
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "#E %s%sPhoneServices is broken!", buf, 0x16u);
      }
      break;
    case 1:
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_100A41F70;
      CFTypeID v17 = &unk_101A2EDE0;
      int v18 = v3;
      int v19 = 1;
      SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v2);
      unsigned int v9 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x800EFu);
      if (v9)
      {
        BOOL v10 = sub_10001C8F4(8);
        uint64_t v12 = *v10;
        int v11 = (std::__shared_weak_count *)v10[1];
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v12) {
          operator new();
        }
        goto LABEL_18;
      }
      return;
    case 2:
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_100A41FB8;
      CFTypeID v17 = &unk_101A2EE00;
      int v18 = v3;
      int v19 = 2;
      unsigned int v13 = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v2);
      unsigned int v9 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(v13, 0x80117u);
      if (v9)
      {
        int v14 = sub_10001C8F4(8);
        uint64_t v15 = *v14;
        int v11 = (std::__shared_weak_count *)v14[1];
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v15) {
          operator new();
        }
LABEL_18:
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (v9)
        {
          wis::MetricContainer::~MetricContainer(v9);
          operator delete();
        }
      }
      return;
    default:
      return;
  }
}

void sub_100A416FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100A417B0(uint64_t a1)
{
  void (***v19)(unsigned char *__return_ptr, void, uint64_t);
  char v20;
  uint64_t v21;
  unint64_t v22;
  unsigned char cf[22];

  if (*(_DWORD *)(a1 + 96) == 1)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 80) + 472))(cf);
    uint64_t v2 = *(BOOL **)cf;
    LOBYTE(v22) = 0;
    if (*(void *)cf && (CFTypeID v3 = CFGetTypeID(*(CFTypeRef *)cf), v3 == CFBooleanGetTypeID()))
    {
      ctu::cf::assign((ctu::cf *)&v22, v2, v4);
      int v5 = v22;
      sub_1000577C4((const void **)cf);
      if (v5)
      {
        if (*(unsigned char *)(a1 + 100))
        {
          BOOL v6 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v7 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
            *(_DWORD *)CFTypeRef cf = 136315394;
            *(void *)&cf[4] = v7;
            *(_WORD *)&unsigned char cf[12] = 2080;
            *(void *)&cf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEntitlement call in progress - skipped", cf, 0x16u);
          }
          return 1;
        }
        *(unsigned char *)(a1 + 10ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 1;
        unsigned int v9 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
          *(_DWORD *)CFTypeRef cf = 136315394;
          *(void *)&cf[4] = v10;
          *(_WORD *)&unsigned char cf[12] = 2080;
          *(void *)&cf[14] = " ";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Call Set Entitlement ================================", cf, 0x16u);
        }
        uint64_t v21 = 128;
        ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0x80, *(Registry **)(a1 + 48));
        uint64_t v12 = ServiceMap;
        if ((v13 & 0x8000000000000000) != 0)
        {
          int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v15 = 5381;
          do
          {
            unint64_t v13 = v15;
            unsigned int v16 = *v14++;
            uint64_t v15 = (33 * v15) ^ v16;
          }
          while (v16);
        }
        std::mutex::lock(ServiceMap);
        uint64_t v22 = v13;
        CFTypeID v17 = sub_10004D37C(&v12[1].__m_.__sig, &v22);
        if (v17)
        {
          int v19 = (void (***)(unsigned char *__return_ptr, void, uint64_t))v17[3];
          int v18 = (std::__shared_weak_count *)v17[4];
          if (v18)
          {
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v12);
            atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v18);
            CFTypeID v20 = 0;
LABEL_21:
            (**v19)(cf, v19, **(void **)(a1 + 64) + 24);
            (*(void (**)(void, void, uint64_t *))(**(void **)cf + 280))(*(void *)cf, 0, &v21);
            if (*(void *)&cf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&cf[8]);
            }
            if ((v20 & 1) == 0) {
              sub_10004D2C8(v18);
            }
            return 1;
          }
        }
        else
        {
          int v19 = 0;
        }
        std::mutex::unlock(v12);
        int v18 = 0;
        CFTypeID v20 = 1;
        goto LABEL_21;
      }
    }
    else
    {
      sub_1000577C4((const void **)cf);
    }
  }
  return 0;
}

void sub_100A41AC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_100A41B14@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *(unsigned int *)(a1 + 88);
  if (v2 == 2 || !v2 && sub_100A3C848(a1, a2)) {
    CFTypeID v3 = &_mh_execute_header;
  }
  else {
    CFTypeID v3 = 0;
  }
  return (unint64_t)v3 | v2;
}

void sub_100A41B58(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v4 = *(int *)(a1 + 88);
    int v5 = (const char *)&unk_10161656E;
    BOOL v6 = (char *)&unk_10161656E;
    if (v4 <= 2) {
      BOOL v6 = off_101A2EE38[v4];
    }
    int v7 = *(_DWORD *)(a1 + 92);
    int v8 = *(_DWORD *)(a1 + 96);
    if (v7 == 1) {
      int v5 = "Active";
    }
    if (v7) {
      unsigned int v9 = v5;
    }
    else {
      unsigned int v9 = "Disabled";
    }
    if ((v8 - 1) > 5) {
      uint64_t v10 = "???";
    }
    else {
      uint64_t v10 = off_101A2EE50[v8 - 1];
    }
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 100));
    uint64_t v12 = asStringBool(*(unsigned char *)(a1 + 108));
    int v13 = 136316674;
    uint64_t v14 = v3;
    __int16 v15 = 2080;
    unsigned int v16 = " ";
    __int16 v17 = 2080;
    int v18 = v6;
    __int16 v19 = 2080;
    CFTypeID v20 = v9;
    __int16 v21 = 2080;
    uint64_t v22 = v10;
    __int16 v23 = 2080;
    uint64_t v24 = v11;
    __int16 v25 = 2080;
    uint64_t v26 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s| fSwitchState: %s, fServiceStatus: %s, fEntitlementResultForWiFiCalling: %s, fAwaitingSetEntitlement: %s, fLocationRequired: %s", (uint8_t *)&v13, 0x48u);
  }
}

uint64_t sub_100A41CD8(uint64_t result)
{
  if (*(unsigned char *)(**(void **)(result + 64) + 48))
  {
    uint64_t v1 = result;
    if (*(_DWORD *)(result + 96) != 2) {
      sub_100A2E718(*(void *)(result + 80));
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v1 + 48))(&v2, v1);
    sub_100057D78(&v3);
    phoneservices::submitSwitchAnalytics();
  }
  return result;
}

void sub_100A41DA0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A41E6C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100A41F44);
  __cxa_rethrow();
}

void sub_100A41E94(_Unwind_Exception *a1)
{
}

void sub_100A41EAC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A41EE4(uint64_t a1)
{
}

uint64_t sub_100A41F00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A41F44(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A41F70(uint64_t a1, _DWORD *a2)
{
  a2[7] |= 2u;
  a2[4] = *(_DWORD *)(a1 + 32);
  uint64_t result = subscriber::simSlotAsInstance();
  a2[7] |= 4u;
  a2[5] = result;
  return result;
}

uint64_t sub_100A41FB8(uint64_t a1, _DWORD *a2)
{
  a2[7] |= 2u;
  a2[4] = *(_DWORD *)(a1 + 32);
  uint64_t result = subscriber::simSlotAsInstance();
  a2[7] |= 4u;
  a2[5] = result;
  return result;
}

void sub_100A42008(std::__shared_weak_count_vtbl **a1)
{
  v23[0] = off_101A2EEE8;
  void v23[3] = v23;
  inactive = dispatch_workloop_create_inactive("WeaGeofenceManager");
  sub_100136200((uint64_t)v23, (uint64_t)inactive);
  dispatch_activate(inactive);
  sub_1001362D0(v23);
  uint64_t v4 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  int v5 = (std::__shared_weak_count *)operator new(0x28uLL);
  BOOL v6 = v5;
  v5->__shared_owners_ = 0;
  p_shared_owners = &v5->__shared_owners_;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)off_101A2EF68;
  if (v3)
  {
    char v8 = 1;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    v5[1].__vftable = v4;
    v5[1].__shared_owners_ = (uint64_t)v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v3);
    uint64_t v4 = *a1;
    uint64_t v3 = (std::__shared_weak_count *)a1[1];
    if (v3)
    {
      char v8 = 0;
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    v5[1].__vftable = v4;
    v5[1].__shared_owners_ = 0;
    char v8 = 1;
  }
  atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
  if (capabilities::ct::supportsWEAGeofencing((capabilities::ct *)v5))
  {
    unsigned int v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
    dispatch_queue_t v10 = dispatch_queue_create("WeaGeofenceManager", v9);
    long long v20 = 0uLL;
    __int16 v21 = v4;
    uint64_t v22 = v3;
    if ((v8 & 1) == 0) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v20 = 0uLL;
    dispatch_object_t object = v10;
    sub_1004DF348(&v21, &v20);
    if (v22) {
      sub_10004D2C8(v22);
    }
    int v18 = 0;
    __int16 v19 = 0;
    __int16 v21 = v4;
    uint64_t v22 = v3;
    if ((v8 & 1) == 0) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v18 = 0;
    __int16 v19 = 0;
    sub_1004082F4(&v21, &v18);
    if (v22) {
      sub_10004D2C8(v22);
    }
    long long v17 = v20;
    if (*((void *)&v20 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v20 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    dispatch_object_t v16 = object;
    if (object) {
      dispatch_retain(object);
    }
    +[WeaLocationModule createModuleAndAddToDelegate:&v17 withQueue:&v16];
    if (v16) {
      dispatch_release(v16);
    }
    if (*((void *)&v17 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v17 + 1));
    }
    uint64_t v14 = v18;
    __int16 v15 = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_object_t v13 = object;
    if (object) {
      dispatch_retain(object);
    }
    +[WeaLocationModule createModuleAndAddToDelegate:&v14 withQueue:&v13];
    if (v13) {
      dispatch_release(v13);
    }
    if (v15) {
      sub_10004D2C8(v15);
    }
    operator new();
  }
  sub_10004D2C8(v6);
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  long long v17 = 0uLL;
  uint64_t v11 = (std::__shared_weak_count *)a1[1];
  uint64_t v14 = *a1;
  __int16 v15 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
  sub_1010CCBD8(&v20);
}

void sub_100A427F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, dispatch_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,dispatch_object_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,dispatch_object_t a26,uint64_t a27,uint64_t a28,dispatch_object_t a29,uint64_t a30,uint64_t a31)
{
  __cxa_free_exception(v34);
  if (a17) {
    sub_10004D2C8(a17);
  }
  if (a25) {
    sub_10004D2C8(a25);
  }
  char v38 = *(std::__shared_weak_count **)(v36 - 168);
  if (v38) {
    sub_10004D2C8(v38);
  }
  uint64_t v39 = *(std::__shared_weak_count **)(v36 - 152);
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (object) {
    dispatch_release(object);
  }
  sub_10004D2C8(v32);
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v33);
  }
  sub_10004D2C8(v32);
  if (v31) {
    dispatch_release(v31);
  }
  _Unwind_Resume(a1);
}

void sub_100A42A1C()
{
}

void *sub_100A42A30()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A2EEE8;
  return result;
}

void sub_100A42A68(uint64_t a1, void *a2)
{
  *a2 = off_101A2EEE8;
}

void sub_100A42A90(uint64_t a1, dispatch_workloop_t *a2)
{
}

uint64_t sub_100A42A9C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A42ADC()
{
}

void sub_100A42AE8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A2EF68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A42B08(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A2EF68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A42B5C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void CellularUsageReliableNetworkFallback::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A42BE4()
{
}

uint64_t CellularUsageReliableNetworkFallback::CellularUsageReliableNetworkFallback(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = off_101A5DDD8;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "cu.rnf");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &v8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(void *)a1 = off_101A2EFB8;
  *(void *)(a1 + 16) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 24) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100023950(a1 + 32, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 96) = 0;
  return a1;
}

void sub_100A42CFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A42D20(uint64_t a1)
{
  *(void *)a1 = off_101A2EFB8;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  sub_100060644((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100A42D90(uint64_t a1)
{
  sub_100A42D20(a1);

  operator delete();
}

void sub_100A42DC8(uint64_t a1, uint64_t a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v5 = 0;
  PersonalityIdFromSlotId();
  sub_100A42E6C(a1, (uint64_t)__p);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A42E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A42E6C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)*(unsigned __int8 *)(a2 + 23);
  if ((char)v3 < 0) {
    uint64_t v3 = *(uint64_t **)(a2 + 8);
  }
  if (v3)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 16));
    uint64_t v6 = ServiceMap;
    if (v7 < 0)
    {
      OsLogContext v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)uint64_t v22 = v7;
    uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v22);
    if (v11)
    {
      uint64_t v13 = v11[3];
      uint64_t v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        if (!v13)
        {
LABEL_10:
          __int16 v15 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v22 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not get the cellular usage store interface!", v22, 2u);
          }
          dispatch_object_t v16 = (void **)(a1 + 72);
          if (*(char *)(a1 + 95) < 0) {
            operator delete(*v16);
          }
          *dispatch_object_t v16 = 0;
          *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
          *(_WORD *)(a1 + 96) = 0;
          *(void *)(a1 + 88) = 0;
LABEL_28:
          if ((v14 & 1) == 0) {
            sub_10004D2C8(v12);
          }
          return;
        }
LABEL_20:
        int v18 = (void *)(a1 + 72);
        std::string::operator=((std::string *)(a1 + 72), (const std::string *)a2);
        __int16 v19 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 216))(v13, a1 + 72);
        *(_WORD *)(a1 + 96) = v19;
        long long v20 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v21 = "true";
          if (!(_BYTE)v19) {
            __int16 v21 = "false";
          }
          if ((v19 & 0xFF00) == 0) {
            __int16 v21 = "no-value";
          }
          if (*(char *)(a1 + 95) < 0) {
            int v18 = (void *)*v18;
          }
          *(_DWORD *)uint64_t v22 = 136315394;
          *(void *)&v22[4] = v21;
          __int16 v23 = 2080;
          uint64_t v24 = v18;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Initialized with user value of %s for %s", v22, 0x16u);
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    if (!v13) {
      goto LABEL_10;
    }
    goto LABEL_20;
  }
  long long v17 = (void **)(a1 + 72);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*v17);
  }
  void *v17 = 0;
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(_WORD *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
}

void sub_100A430F0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100A43120(uint64_t a1)
{
  CFBooleanRef v27 = 0;
  *(void *)long long buf = CFPreferencesCopyValue(@"ReliableNetworkFallbackToCellular", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1000BE34C(&v27, (CFTypeRef *)buf);
  if (v27) {
    char v2 = (uint64_t *)sub_100084B4C;
  }
  else {
    char v2 = 0;
  }
  if (!v2) {
    return sub_100062778((const void **)&v27);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 16));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_11;
      }
LABEL_15:
      subscriber::makeSimSlotRange();
      __int16 v15 = *(unsigned int **)buf;
      char v14 = v25;
      if (*(unsigned int **)buf != v25)
      {
        dispatch_object_t v16 = v26;
        while ((v16(*v15) & 1) == 0)
        {
          if (++v15 == v14)
          {
            __int16 v15 = v14;
            break;
          }
        }
        long long v17 = v25;
        while (v15 != v17)
        {
          __dst[0] = 0;
          __dst[1] = 0;
          uint64_t v23 = 0;
          PersonalityIdFromSlotId();
          if (SHIBYTE(v21) < 0)
          {
            sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
            operator delete(__p[0]);
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)__p;
            uint64_t v23 = v21;
          }
          (*(void (**)(uint64_t, void **, BOOL))(*(void *)v11 + 224))(v11, __dst, v27 == kCFBooleanTrue);
          if (SHIBYTE(v23) < 0) {
            operator delete(__dst[0]);
          }
          int v18 = v15 + 1;
          __int16 v15 = v14;
          if (v18 != v14)
          {
            __int16 v15 = v18;
            while ((v16(*v15) & 1) == 0)
            {
              if (++v15 == v14)
              {
                __int16 v15 = v14;
                break;
              }
            }
          }
        }
      }
      CFPreferencesSetValue(@"ReliableNetworkFallbackToCellular", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
  if (v11) {
    goto LABEL_15;
  }
LABEL_11:
  uint64_t v13 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not get the cellular usage store interface!", buf, 2u);
  }
LABEL_33:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  return sub_100062778((const void **)&v27);
}

void sub_100A43410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,const void *a27)
{
  if ((v28 & 1) == 0) {
    sub_10004D2C8(v27);
  }
  sub_100062778(&a27);
  _Unwind_Resume(a1);
}

uint64_t sub_100A43484(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v3 = (uint64_t *)&kCarrier1BundleId;
  }
  else
  {
    if (a2 != 2) {
      goto LABEL_12;
    }
    uint64_t v3 = (uint64_t *)&kCarrier2BundleId;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (uint64_t *)operator new(0x10uLL);
    uint64_t v6 = v5 + 2;
    __p[1] = v5 + 2;
    uint64_t v41 = (const char *)(v5 + 2);
    uint64_t *v5 = @"ReliableNetworkFallback";
    v5[1] = @"UserCanEdit";
    __p[0] = v5;
    unsigned int v8 = (Registry **)(a1 + 16);
    uint64_t v7 = *(Registry **)(a1 + 16);
    CFTypeRef cf = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v6, v7);
    unsigned int v10 = ServiceMap;
    if (v11 < 0)
    {
      char v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        uint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v11;
    __int16 v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
    if (v15)
    {
      uint64_t v17 = v15[3];
      dispatch_object_t v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    dispatch_object_t v16 = 0;
    char v18 = 1;
LABEL_17:
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, void **, void, void))(*(void *)v17 + 24))(&cf, v17, v4, __p, 0, 0);
    if ((v18 & 1) == 0) {
      sub_10004D2C8(v16);
    }
    uint64_t v21 = (BOOL *)cf;
    int v22 = 1;
    buf[0] = 1;
    if (cf)
    {
      CFTypeID v23 = CFGetTypeID(cf);
      if (v23 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v21, v24);
        int v22 = buf[0];
      }
      else
      {
        int v22 = 1;
      }
    }
    sub_1000577C4(&cf);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v41 = 0;
    PersonalityIdFromSlotId();
    if (SHIBYTE(v39) < 0)
    {
      sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
      if (SHIBYTE(v39) < 0)
      {
        operator delete(*(void **)buf);
        if (!v22) {
          goto LABEL_47;
        }
      }
      else if (!v22)
      {
        goto LABEL_47;
      }
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      uint64_t v41 = v39;
      if (!v22) {
        goto LABEL_47;
      }
    }
    uint64_t v25 = HIBYTE(v41);
    if (SHIBYTE(v41) >= 0) {
      uint64_t v26 = (void *)HIBYTE(v41);
    }
    else {
      uint64_t v26 = __p[1];
    }
    if (!v26)
    {
LABEL_47:
      BOOL v20 = sub_100A4393C(*v8, v4);
      CFNumberRef v31 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = __p[1];
        if (SHIBYTE(v41) >= 0) {
          uint64_t v32 = (void *)HIBYTE(v41);
        }
        BOOL v33 = v32 == 0;
        BOOL v34 = "false";
        *(_DWORD *)long long buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v22;
        if (v20) {
          BOOL v34 = "true";
        }
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v33;
        *(_WORD *)&buf[14] = 2080;
        uint64_t v39 = v34;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I User can't change the setting (%d) or subscriberId empty (%d), returning the carrier bundle value: %s", buf, 0x18u);
      }
      goto LABEL_58;
    }
    CFBooleanRef v27 = (void *)*(unsigned __int8 *)(a1 + 95);
    int v28 = (char)v27;
    if ((char)v27 < 0) {
      CFBooleanRef v27 = *(void **)(a1 + 80);
    }
    if (v26 == v27)
    {
      if (v28 >= 0) {
        char v29 = (unsigned __int8 *)(a1 + 72);
      }
      else {
        char v29 = *(unsigned __int8 **)(a1 + 72);
      }
      if ((HIBYTE(v41) & 0x80) != 0)
      {
        if (!memcmp(__p[0], v29, (size_t)__p[1])) {
          goto LABEL_55;
        }
      }
      else
      {
        if (!HIBYTE(v41)) {
          goto LABEL_55;
        }
        uint64_t v30 = __p;
        while (*(unsigned __int8 *)v30 == *v29)
        {
          uint64_t v30 = (void **)((char *)v30 + 1);
          ++v29;
          if (!--v25) {
            goto LABEL_55;
          }
        }
      }
    }
    sub_100A42E6C(a1, (uint64_t)__p);
LABEL_55:
    BOOL v35 = sub_100A4393C(*v8, v4);
    if (*(unsigned char *)(a1 + 97)) {
      BOOL v20 = *(unsigned char *)(a1 + 96) != 0;
    }
    else {
      BOOL v20 = v35;
    }
LABEL_58:
    if (SHIBYTE(v41) < 0) {
      operator delete(__p[0]);
    }
    return v20;
  }
LABEL_12:
  __int16 v19 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (void *)subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Invalid slot %s", (uint8_t *)__p, 0xCu);
  }
  return 1;
}

void sub_100A438B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100A4393C(Registry *a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)operator new(0x10uLL);
  int v22 = v4 + 2;
  CFTypeID v23 = v4 + 2;
  uint64_t *v4 = @"ReliableNetworkFallback";
  v4[1] = @"DefaultValue";
  CFTypeRef cf = 0;
  long long __p = v4;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4 + 2, a1);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v24 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v24);
  if (v11)
  {
    uint64_t v13 = v11[3];
    char v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  char v12 = 0;
  char v14 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, void **, void, void))(*(void *)v13 + 24))(&cf, v13, a2, &__p, 0, 0);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  __int16 v15 = (BOOL *)cf;
  int v16 = 1;
  LOBYTE(v24) = 1;
  if (cf)
  {
    CFTypeID v17 = CFGetTypeID(cf);
    if (v17 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v24, v15, v18);
      int v16 = v24;
    }
    else
    {
      int v16 = 1;
    }
  }
  sub_1000577C4(&cf);
  if (__p)
  {
    int v22 = __p;
    operator delete(__p);
  }
  return v16 != 0;
}

void sub_100A43AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A43B24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  PersonalityIdFromSlotId();
  if ((__p[23] & 0x80000000) != 0)
  {
    sub_10004FC84(v28, *(void **)__p, *(unint64_t *)&__p[8]);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  else
  {
    *(_OWORD *)int v28 = *(_OWORD *)__p;
    uint64_t v29 = *(void *)&__p[16];
  }
  uint64_t v6 = (void *)HIBYTE(v29);
  if (v29 < 0) {
    uint64_t v6 = v28[1];
  }
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2);
    int v7 = *(unsigned __int8 *)(a1 + 97);
    int v8 = *(unsigned __int8 *)(a1 + 96);
    if (*(unsigned char *)(a1 + 97) && v8 == a3) {
      goto LABEL_40;
    }
    uint64_t v9 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v10 = "true";
      uint64_t v11 = "no-value";
      if (v8) {
        char v12 = "true";
      }
      else {
        char v12 = "false";
      }
      if (v7) {
        uint64_t v11 = v12;
      }
      if (!a3) {
        unsigned int v10 = "false";
      }
      *(_DWORD *)long long __p = 136315394;
      *(void *)&__p[4] = v11;
      *(_WORD *)&unsigned char __p[12] = 2080;
      *(void *)&__p[14] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I User setting changing from %s to %s", __p, 0x16u);
    }
    *(_WORD *)(a1 + 96) = a3 | 0x100;
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)(a3 | 0x100), *(Registry **)(a1 + 16));
    char v14 = ServiceMap;
    if (v15 < 0)
    {
      int v16 = (unsigned __int8 *)(v15 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        uint64_t v15 = v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long __p = v15;
    __int16 v19 = sub_10004D37C(&v14[1].__m_.__sig, (unint64_t *)__p);
    if (v19)
    {
      uint64_t v21 = v19[3];
      BOOL v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        if (!v21)
        {
LABEL_25:
          CFTypeID v23 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long __p = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Could not get the cellular usage store interface!", __p, 2u);
          }
          unint64_t v24 = (void **)(a1 + 72);
          if (*(char *)(a1 + 95) < 0) {
            operator delete(*v24);
          }
          *unint64_t v24 = 0;
          *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
          *(_WORD *)(a1 + 96) = 0;
          *(void *)(a1 + 88) = 0;
          (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2);
          goto LABEL_38;
        }
LABEL_37:
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2);
        (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v21 + 224))(v21, v28, a3);
LABEL_38:
        if ((v22 & 1) == 0) {
          sub_10004D2C8(v20);
        }
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    BOOL v20 = 0;
    char v22 = 1;
    if (!v21) {
      goto LABEL_25;
    }
    goto LABEL_37;
  }
  uint64_t v25 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    uint64_t v27 = subscriber::asString();
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v27;
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "No Personality for slot %s", __p, 0xCu);
  }
  uint64_t v26 = (void **)(a1 + 72);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*v26);
  }
  *uint64_t v26 = 0;
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(_WORD *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2);
LABEL_40:
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
}

void sub_100A43F10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A43F74(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      uint64_t v4 = "true";
    }
    int v6 = 136315138;
    int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reevaluating the reliable network fallback setting value: %s", (uint8_t *)&v6, 0xCu);
  }
  if (*(unsigned char *)(a1 + 65)) {
    BOOL v5 = *(unsigned __int8 *)(a1 + 64) == v2;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    *(_WORD *)(a1 + 64) = v2 | 0x100;
    sub_1000607A8(a1 + 32, v2);
  }
}

void sub_100A44080(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "true";
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    if (*(unsigned char *)(a1 + 65)) {
      BOOL v5 = v4;
    }
    else {
      BOOL v5 = "no-value";
    }
    if (!*(unsigned char *)(a1 + 96)) {
      uint64_t v3 = "false";
    }
    if (*(unsigned char *)(a1 + 97)) {
      int v6 = v3;
    }
    else {
      int v6 = "no-value";
    }
    int v7 = 136315394;
    int v8 = v5;
    __int16 v9 = 2080;
    unsigned int v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I reported=%s, user=%s", (uint8_t *)&v7, 0x16u);
  }
}

void sub_100A44170(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100A441D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A44214(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A4424C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100A4427C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100A442C0(Registry **a1@<X0>, os_log_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  int v8 = ServiceMap;
  if (v9 < 0)
  {
    unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&v32[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v32);
  if (!v13)
  {
    uint64_t v15 = 0;
LABEL_11:
    std::mutex::unlock(v8);
    char v14 = 0;
    char v16 = 1;
    if (!v15) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
  uint64_t v15 = v13[3];
  char v14 = (std::__shared_weak_count *)v13[4];
  if (!v14) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
  if (!v15)
  {
LABEL_7:
    uint64_t v17 = *a2;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v32[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to parse message revoke XML - client factory not present", (uint8_t *)v32, 2u);
    }
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    goto LABEL_48;
  }
LABEL_12:
  int v18 = *((char *)a3 + 23);
  if (v18 >= 0) {
    __int16 v19 = a3;
  }
  else {
    __int16 v19 = (uint64_t *)*a3;
  }
  if (v18 >= 0) {
    uint64_t v20 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint64_t v20 = a3[1];
  }
  uint64_t v21 = +[NSData nonOwningDataWithBytes:v19 length:v20];
  char v22 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v32[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Decoding message revoke XML document using BlastDoor", (uint8_t *)v32, 2u);
  }
  char v37 = 0;
  char v38 = 0;
  uint64_t v36 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v15 + 16))(&v36, v15);
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  memset(v32, 0, sizeof(v32));
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = &v38;
  (*(void (**)(_OWORD *__return_ptr))(*(void *)v36 + 96))(v32);
  sub_100128064((const void **)buf);
  CFTypeID v23 = v38;
  if (v38) {
    unint64_t v24 = sub_10039195C;
  }
  else {
    unint64_t v24 = 0;
  }
  if (v24)
  {
    uint64_t v25 = *a2;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v23;
    uint64_t v27 = "Failed to unpack message revoke XML: %@";
    int v28 = v25;
    uint32_t v29 = 12;
LABEL_52:
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
    goto LABEL_25;
  }
  if ((_BYTE)v35)
  {
    if (SBYTE7(v32[1]) < 0)
    {
      sub_10004FC84(buf, *(void **)&v32[0], *((unint64_t *)&v32[0] + 1));
    }
    else
    {
      *(_OWORD *)long long buf = v32[0];
      uint64_t v40 = *(void *)&v32[1];
    }
    if (SHIBYTE(v32[2]) < 0)
    {
      sub_10004FC84(&v41, *((void **)&v32[1] + 1), *(unint64_t *)&v32[2]);
    }
    else
    {
      long long v41 = *(_OWORD *)((char *)&v32[1] + 8);
      uint64_t v42 = *((void *)&v32[2] + 1);
    }
    if (SBYTE7(v34) < 0)
    {
      sub_10004FC84(&v43, (void *)v33, *((unint64_t *)&v33 + 1));
    }
    else
    {
      long long v43 = v33;
      uint64_t v44 = v34;
    }
    if (DWORD2(v34)) {
      int v30 = -1;
    }
    else {
      int v30 = 0;
    }
    if (DWORD2(v34) == 1) {
      int v31 = 1;
    }
    else {
      int v31 = v30;
    }
    *(_OWORD *)a4 = *(_OWORD *)buf;
    *(void *)(a4 + 16) = v40;
    *(_OWORD *)(a4 + 24) = v41;
    *(void *)(a4 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v42;
    *(_OWORD *)(a4 + 48) = v43;
    *(void *)(a4 + 64) = v44;
    *(_DWORD *)(a4 + 72) = v31;
    *(unsigned char *)(a4 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 1;
    goto LABEL_45;
  }
  uint64_t v26 = *a2;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v27 = "Message revoke XML unpacking succeeded, but there was no payload";
    int v28 = v26;
    uint32_t v29 = 2;
    goto LABEL_52;
  }
LABEL_25:
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
LABEL_45:
  sub_100777CB4((uint64_t)v32);
  if (v37) {
    sub_10004D2C8(v37);
  }
  sub_100127D74(&v38);

LABEL_48:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_100A446E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,const void *a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  sub_100777CB4((uint64_t)&a9);
  if (a21) {
    sub_10004D2C8(a21);
  }
  sub_100127D74(&a22);

  if ((v36 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  _Unwind_Resume(a1);
}

void sub_100A4479C(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long v45 = 0uLL;
  int64_t v46 = 0;
  std::operator+<char>();
  uint64_t v4 = std::string::append(&v41, "</Message-ID>\n<From>", 0x14uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  int v6 = *(char *)(a1 + 71);
  if (v6 >= 0) {
    int v7 = (const std::string::value_type *)(a1 + 48);
  }
  else {
    int v7 = *(const std::string::value_type **)(a1 + 48);
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a1 + 71);
  }
  else {
    std::string::size_type v8 = *(void *)(a1 + 56);
  }
  uint64_t v9 = std::string::append(&v42, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  uint64_t v11 = std::string::append(&v43, "</From>\n<To>", 0xCuLL);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  uint64_t v15 = *(const std::string::value_type **)(a1 + 24);
  uint64_t v14 = a1 + 24;
  uint64_t v13 = v15;
  int v16 = *(char *)(v14 + 23);
  if (v16 >= 0) {
    uint64_t v17 = (const std::string::value_type *)v14;
  }
  else {
    uint64_t v17 = v13;
  }
  if (v16 >= 0) {
    std::string::size_type v18 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    std::string::size_type v18 = *(void *)(v14 + 8);
  }
  __int16 v19 = std::string::append(&v44, v17, v18);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  *(void *)&v27[0] = *((void *)&v19->__r_.__value_.__l + 2);
  *(_OWORD *)long long __p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  uint64_t v21 = std::string::append((std::string *)__p, "</To>\n</imRevoke>", 0x11uLL);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  int64_t v46 = v21->__r_.__value_.__r.__words[2];
  long long v45 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SBYTE7(v27[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  *(_OWORD *)int v28 = 0u;
  long long v29 = 0u;
  memset(v27, 0, sizeof(v27));
  *(_OWORD *)long long __p = 0u;
  sub_10004BD84((uint64_t)__p);
  if (v46 >= 0) {
    CFTypeID v23 = &v45;
  }
  else {
    CFTypeID v23 = (long long *)v45;
  }
  if (v46 >= 0) {
    uint64_t v24 = HIBYTE(v46);
  }
  else {
    uint64_t v24 = *((void *)&v45 + 1);
  }
  sub_10004B96C(v27, (uint64_t)v23, v24);
  sub_10004BC98((uint64_t)v27 + 8, &v44);
  sub_100CC8650(a2, (uint64_t)&v44);
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  *(void **)((char *)__p
  *(void *)&v27[0] = v25;
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if (SHIBYTE(v46) < 0) {
    operator delete((void *)v45);
  }
}

void sub_100A44AF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (*(char *)(v14 - 89) < 0) {
    operator delete(*(void **)(v14 - 112));
  }
  sub_10008248C((uint64_t)&__p);
  if (*(char *)(v14 - 57) < 0) {
    operator delete(*(void **)(v14 - 80));
  }
  _Unwind_Resume(a1);
}

void sub_100A44BAC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A44F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100A45168(uint64_t a1)
{
  *(void *)a1 = &off_101A2F0C8;
  sub_100057D78((const void **)(a1 + 328));
  int v2 = *(const void **)(a1 + 320);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 304);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100087F94(a1 + 248, *(void **)(a1 + 256));
  sub_1003C8134((unsigned char *)(a1 + 136));
  sub_10005717C((const void **)(a1 + 128));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 120);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 104);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *(NSObject **)(a1 + 48);
  if (v9) {
    dispatch_release(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100A4526C(uint64_t a1)
{
  sub_100A45168(a1);

  operator delete();
}

void sub_100A452A4(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4 && std::__shared_weak_count::lock(v4))
  {
    if (object)
    {
      dispatch_retain(object);
      dispatch_group_enter(object);
    }
    operator new();
  }
  sub_100088B9C();
}

void sub_100A453C0(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I handleCommandDriverStarted", buf, 2u);
  }
  *(unsigned char *)(a1 + 272) = 1;
  sub_100A454D4((const void **)a1, 1);
  *(void *)long long buf = 0;
  int v6 = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 120))(buf);
  if (*(void *)buf)
  {
    uint64_t v3 = *(void *)buf;
    uint64_t v4 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100A455AC(a1, &v3, 1);
    if (v4) {
      sub_10004D2C8(v4);
    }
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100A454B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100A454D4(const void **result, int a2)
{
  if (*((unsigned char *)result + 272))
  {
    uint64_t v2 = (uint64_t)result;
    if (!*((unsigned char *)result + 288))
    {
      uint64_t v4 = result[5];
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I sending collected P2P messages to BB", buf, 2u);
      }
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000;
      _OWORD v5[2] = sub_100A46764;
      v5[3] = &unk_101A2F180;
      uint64_t v5[4] = v2;
      return sub_100A45D64(v2, a2, (uint64_t)v5);
    }
  }
  return result;
}

void sub_100A455AC(uint64_t a1, uint64_t *a2, int a3)
{
  if (*(unsigned char *)(a1 + 272))
  {
    int v6 = (std::__shared_weak_count *)a2[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (capabilities::ct::supportsP2PAsGizmo((capabilities::ct *)a1))
    {
      unint64_t v7 = 0x100000001;
      if (!v6)
      {
LABEL_16:
        unint64_t v13 = HIDWORD(v7);
        uint64_t v14 = *a2;
        if (*a2 && !(_BYTE)v7)
        {
          uint64_t v15 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I paired device doesn't have active SIM", buf, 2u);
          }
          int v16 = (std::__shared_weak_count *)a2[1];
          *a2 = 0;
          a2[1] = 0;
          if (v16)
          {
            sub_10004D2C8(v16);
            uint64_t v14 = *a2;
          }
          else
          {
            uint64_t v14 = 0;
          }
        }
        if (v14 != *(void *)(a1 + 296) || *(_DWORD *)(a1 + 312) != v13 || a3)
        {
          __int16 v19 = *(NSObject **)(a1 + 40);
          BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
          if (v20)
          {
            if (v14) {
              uint64_t v21 = "is";
            }
            else {
              uint64_t v21 = "is not";
            }
            uint64_t v22 = subscriber::asString();
            CFTypeID v23 = "";
            *(_DWORD *)long long buf = 136315650;
            *(void *)&uint8_t buf[4] = v21;
            __int16 v37 = 2080;
            if (a3) {
              CFTypeID v23 = " (forced BB update)";
            }
            uint64_t v38 = v22;
            __int16 v39 = 2080;
            uint64_t v40 = v23;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I paired device %s in proximity. Associated slot:%s%s", buf, 0x20u);
          }
          if (capabilities::ct::supportsP2PAsPhone((capabilities::ct *)v20))
          {
            if (*(void *)(a1 + 296))
            {
              uint64_t v24 = *(unsigned int *)(a1 + 312);
              if (v24 != v13)
              {
                uint64_t v25 = *(void *)(a1 + 64);
                uint64_t v33 = 0;
                long long v34 = 0;
                (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v25 + 48))(v25, v24, &v33);
                if (v34) {
                  sub_10004D2C8(v34);
                }
              }
            }
            uint64_t v26 = *(void *)(a1 + 64);
            uint64_t v27 = (std::__shared_weak_count *)a2[1];
            uint64_t v31 = *a2;
            long long v32 = v27;
            if (v27) {
              atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(void *)v26 + 48))(v26, v13, &v31);
            if (v32) {
              sub_10004D2C8(v32);
            }
          }
          uint64_t v29 = *a2;
          uint64_t v28 = a2[1];
          if (v28) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
          }
          long long v30 = *(std::__shared_weak_count **)(a1 + 304);
          *(void *)(a1 + 296) = v29;
          *(void *)(a1 + 304) = v28;
          if (v30) {
            sub_10004D2C8(v30);
          }
          *(_DWORD *)(a1 + 312) = v13;
        }
        return;
      }
LABEL_15:
      sub_10004D2C8(v6);
      goto LABEL_16;
    }
    BOOL v35 = 0;
    uint64_t v10 = sub_100365D74();
    sub_100058DB0(buf, "vinyl.sim.active");
    BOOL v11 = sub_1002260B0(v10, (void **)buf, &v35);
    BOOL v12 = v11;
    if (SHIBYTE(v39) < 0)
    {
      operator delete(*(void **)buf);
      if (v12)
      {
LABEL_14:
        unint64_t v7 = v35 | (unint64_t)&_mh_execute_header;
        if (!v6) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
    }
    else if (v11)
    {
      goto LABEL_14;
    }
    if (*(unsigned char *)(a1 + 136)
      && cellplan::RemoteSimSubscriptionInfo::isSimReadyToUse((cellplan::RemoteSimSubscriptionInfo *)(a1 + 144)))
    {
      if (!*(unsigned char *)(a1 + 136)) {
        __assert_rtn("operator->", "optional.hpp", 1221, "this->is_initialized()");
      }
      unint64_t v17 = (unint64_t)*(unsigned int *)(a1 + 240) << 32;
      uint64_t v18 = 1;
    }
    else
    {
      uint64_t v18 = 0;
      unint64_t v17 = (unint64_t)&_mh_execute_header;
    }
    unint64_t v7 = v17 | v18;
    if (!v6) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*a2) {
      uint64_t v9 = "is";
    }
    else {
      uint64_t v9 = " is not";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#N BB client is not connected. Paired device indicated as %s in proximity", buf, 0xCu);
  }
}

void sub_100A45964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A459BC(uint64_t result)
{
  *(unsigned char *)(result + 272) = 0;
  *(unsigned char *)(result + 288) = 0;
  return result;
}

const void **sub_100A459C8(uint64_t a1, uint64_t a2, const void **a3, char a4)
{
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int64_t v9 = (unsigned char *)a3[1] - (unsigned char *)*a3;
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v34) = 2048;
    *(void *)((char *)&v34 + 2) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I passing to companion P2PMessage of type %d and length %zu", buf, 0x12u);
  }
  uint64_t v26 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    BOOL v11 = v26;
    uint64_t v26 = Mutable;
    *(void *)long long buf = v11;
    sub_10005717C((const void **)buf);
  }
  long long __p = 0;
  *(_DWORD *)long long buf = a2;
  CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
  if (v12)
  {
    unint64_t v13 = __p;
    long long __p = v12;
    *(void *)long long buf = v13;
    sub_1000570E8((const void **)buf);
  }
  long long v32 = __p;
  long long __p = 0;
  sub_1000570E8((const void **)&__p);
  CFDictionaryAddValue(v26, @"message.type", v32);
  sub_1000570E8((const void **)&v32);
  uint64_t v14 = *a3;
  uint64_t v15 = (uint64_t)a3[1];
  size_t v16 = v15 - (void)*a3;
  if ((const void *)v15 != *a3 && (a4 & 1) == 0)
  {
    unint64_t v17 = v26;
    CFTypeID v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    sub_10005C928(&v22, v14, v15, v16);
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    long long __p = 0;
    sub_10005C928(&__p, v22, (uint64_t)v23, v23 - (unsigned char *)v22);
    uint64_t v27 = 0;
    *(void *)long long buf = 0;
    long long v34 = 0uLL;
    sub_10005C928(buf, __p, (uint64_t)v29, v29 - (unsigned char *)__p);
    uint64_t v31 = 0;
    if (ctu::cf::convert_copy())
    {
      uint64_t v18 = v27;
      uint64_t v27 = v31;
      long long v32 = v18;
      sub_100030068((const void **)&v32);
    }
    if (*(void *)buf)
    {
      *(void *)&long long v34 = *(void *)buf;
      operator delete(*(void **)buf);
    }
    __int16 v19 = v27;
    uint64_t v25 = v27;
    uint64_t v27 = 0;
    sub_100030068((const void **)&v27);
    if (__p)
    {
      uint64_t v29 = __p;
      operator delete(__p);
    }
    CFDictionaryAddValue(v17, @"message.data", v19);
    sub_100030068(&v25);
    if (v22)
    {
      CFTypeID v23 = v22;
      operator delete(v22);
    }
  }
  *(void *)long long buf = CFStringCreateWithFormat(0, 0, @"%@%d", v16, @"p2p.network.info.", a2);
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 96) + 32))(&v21);
  sub_1000558F4(&v21);
  sub_1000558F4((const void **)buf);
  return sub_10005717C((const void **)&v26);
}

void sub_100A45CA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, const void *a15, const void *a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10005717C(&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100A45D4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 320);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

const void **sub_100A45D64(uint64_t a1, int a2, uint64_t a3)
{
  if (*(void *)(a1 + 328)) {
    int v6 = sub_100080778;
  }
  else {
    int v6 = 0;
  }
  if (v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = capabilities::ct::supportsP2PAsGizmo((capabilities::ct *)a1);
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(a1 + 128);
  if (v8) {
    int64_t v9 = sub_1000C06D0;
  }
  else {
    int64_t v9 = 0;
  }
  if (v9)
  {
    CFIndex Count = CFDictionaryGetCount(v8);
    if (Count)
    {
      if (*(unsigned char *)(a1 + 272))
      {
        unint64_t v11 = Count;
        CFTypeRef v50 = 0;
        CFTypeRef cf = 0;
        CFTypeID v49 = 0;
        CFNumberRef v12 = operator new(0x18uLL);
        uint64_t v13 = 0;
        void v12[2] = 0x300000002F00;
        *(_OWORD *)CFNumberRef v12 = xmmword_1015291EC;
        while (1)
        {
          int v14 = *(_DWORD *)((char *)v12 + v13);
          key = 0;
          CFNumberRef v52 = 0;
          LODWORD(valuePtr[0]) = v14;
          CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, valuePtr);
          if (v15)
          {
            size_t v16 = v52;
            CFNumberRef v52 = v15;
            valuePtr[0] = v16;
            sub_1000570E8(valuePtr);
          }
          key = v52;
          CFNumberRef v52 = 0;
          sub_1000570E8((const void **)&v52);
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 128), key);
          CFDictionaryRef v18 = Value;
          if (Value)
          {
            CFTypeID v19 = CFGetTypeID(Value);
            if (v19 == CFDictionaryGetTypeID()) {
              break;
            }
          }
          sub_1000570E8((const void **)&key);
          v13 += 4;
          if (v13 == 24) {
            goto LABEL_28;
          }
        }
        sub_1001AA2BC(&cf, (const void **)&key);
        CFNumberRef v52 = (void *)CFDictionaryGetValue(v18, @"id");
        valuePtr[0] = 0;
        CFTypeID v23 = (const void **)sub_1000842D0(valuePtr, (CFTypeRef *)&v52);
        CFTypeRef v24 = v50;
        CFTypeRef v50 = valuePtr[0];
        valuePtr[0] = v24;
        sub_1000570E8(v23);
        CFNumberRef v52 = (void *)CFDictionaryGetValue(v18, @"body");
        valuePtr[0] = 0;
        uint64_t v25 = (const void **)sub_1000C15D8(valuePtr, (CFTypeRef *)&v52);
        uint64_t v26 = v49;
        CFTypeID v49 = valuePtr[0];
        valuePtr[0] = v26;
        sub_100030068(v25);
        sub_1000570E8((const void **)&key);
LABEL_28:
        if (cf) {
          uint64_t v27 = sub_100081E58;
        }
        else {
          uint64_t v27 = 0;
        }
        if (!v27)
        {
          if (v11 >> 61) {
            sub_10006A748();
          }
          size_t v28 = 8 * v11;
          uint64_t v29 = (const void **)operator new(8 * v11);
          bzero(v29, v28);
          uint64_t v30 = (CFDictionaryRef *)operator new(v28);
          bzero(v30, v28);
          CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 128), v29, (const void **)v30);
          valuePtr[0] = *v29;
          sub_1006B9DE4(&cf, valuePtr);
          CFNumberRef v52 = (void *)CFDictionaryGetValue(*v30, @"id");
          valuePtr[0] = 0;
          uint64_t v31 = (const void **)sub_1000842D0(valuePtr, (CFTypeRef *)&v52);
          CFTypeRef v32 = v50;
          CFTypeRef v50 = valuePtr[0];
          valuePtr[0] = v32;
          sub_1000570E8(v31);
          CFNumberRef v52 = (void *)CFDictionaryGetValue(*v30, @"body");
          valuePtr[0] = 0;
          uint64_t v33 = (const void **)sub_1000C15D8(valuePtr, (CFTypeRef *)&v52);
          long long v34 = v49;
          CFTypeID v49 = valuePtr[0];
          valuePtr[0] = v34;
          sub_100030068(v33);
          operator delete(v30);
          operator delete(v29);
        }
        uint64_t v43 = a3;
        operator delete(v12);
        goto LABEL_35;
      }
      goto LABEL_24;
    }
  }
  if ((a2 & v7 & 1) == 0)
  {
    BOOL v20 = *(const void **)(a1 + 128);
    *(void *)(a1 + 128) = 0;
    valuePtr[0] = v20;
    sub_10005717C(valuePtr);
    return (const void **)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  if (!*(unsigned char *)(a1 + 272))
  {
LABEL_24:
    uint64_t v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(valuePtr[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#E bb update interrupted, client went offline", (uint8_t *)valuePtr, 2u);
    }
    return (const void **)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  uint64_t v43 = a3;
  CFTypeRef v50 = 0;
  CFTypeRef cf = 0;
  CFTypeID v49 = 0;
LABEL_35:
  *(unsigned char *)(a1 + 288) = 1;
  BOOL v35 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v35 || (uint64_t v36 = *(void *)(a1 + 8), (v37 = std::__shared_weak_count::lock(v35)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v38 = v37;
  p_shared_weak_owners = &v37->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v37);
  uint64_t v40 = *(void *)(a1 + 64);
  CFTypeRef v41 = cf;
  std::string v42 = v49;
  v44[0] = _NSConcreteStackBlock;
  v44[1] = 1174405120;
  v44[2] = sub_100A462E8;
  v44[3] = &unk_101A2F150;
  v44[5] = a1;
  v44[6] = v36;
  long long v45 = v38;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  int64_t v46 = v41;
  if (v41) {
    CFRetain(v41);
  }
  CFTypeRef v47 = v50;
  if (v50) {
    CFRetain(v50);
  }
  v44[4] = v43;
  (*(void (**)(uint64_t, CFTypeRef, const void *, uint64_t, uint64_t, void *))(*(void *)v40 + 40))(v40, v41, v42, v7, a1 + 296, v44);
  sub_1000570E8(&v47);
  sub_1000570E8(&v46);
  if (v45) {
    std::__shared_weak_count::__release_weak(v45);
  }
  std::__shared_weak_count::__release_weak(v38);
  sub_100030068(&v49);
  sub_1000570E8(&v50);
  return sub_1000570E8(&cf);
}

void sub_100A4622C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, char a20,int a21,const void *a22,const void *a23,const void *a24)
{
  operator delete(v26);
  operator delete(v25);
  operator delete(v24);
  sub_100030068(&a22);
  sub_1000570E8(&a23);
  sub_1000570E8(&a24);
  _Unwind_Resume(a1);
}

void sub_100A462E8(uint64_t a1, int a2, int a3, const void **a4)
{
  long long v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5)
  {
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      unint64_t v11 = v10;
      if (!*(void *)(a1 + 48))
      {
LABEL_34:
        sub_10004D2C8(v11);
        return;
      }
      *(unsigned char *)(v9 + 288) = 0;
      if (*a4) {
        CFNumberRef v12 = sub_100080778;
      }
      else {
        CFNumberRef v12 = 0;
      }
      if (v12)
      {
        sub_100058140((const void **)(v9 + 328), a4);
        (*(void (**)(void, void))(**(void **)(v9 + 96) + 136))(*(void *)(v9 + 96), *(void *)(v9 + 328));
      }
      CFDictionaryRef v13 = *(const __CFDictionary **)(v9 + 128);
      if (v13) {
        int v14 = sub_1000C06D0;
      }
      else {
        int v14 = 0;
      }
      if (v14 && ((CFNumberRef v15 = *(const void **)(a1 + 64)) != 0 ? (v16 = sub_100081E58) : (v16 = 0), v16 && (a3 & 1) == 0))
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v13, v15);
        if (Value)
        {
          CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(Value, @"id");
          if (CFNumberCompare(*(CFNumberRef *)(a1 + 72), v18, 0) == kCFCompareEqualTo)
          {
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v9 + 128), *(const void **)(a1 + 64));
            BOOL v35 = *(NSObject **)(v9 + 40);
            if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_33;
            }
            __int16 v37 = *(int **)(a1 + 72);
            int v39 = 0;
            ctu::cf::assign((ctu::cf *)&v39, v37, v36);
            uint64_t v38 = "failure";
            if (a2) {
              uint64_t v38 = "success";
            }
            *(_DWORD *)long long buf = 136315394;
            CFTypeRef v41 = v38;
            __int16 v42 = 1024;
            *(_DWORD *)uint64_t v43 = v39;
            uint64_t v26 = "#N send ack = %s, remove message %d from cache";
            uint64_t v27 = v35;
            uint32_t v28 = 18;
            goto LABEL_32;
          }
          CFTypeID v19 = *(NSObject **)(v9 + 40);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if (a2) {
              uint64_t v21 = "success";
            }
            else {
              uint64_t v21 = "failure";
            }
            uint64_t v22 = *(int **)(a1 + 72);
            int v39 = 0;
            ctu::cf::assign((ctu::cf *)&v39, v22, v20);
            int v23 = v39;
            int v39 = 0;
            ctu::cf::assign((ctu::cf *)&v39, (int *)v18, v24);
            uint64_t v25 = *(void *)(a1 + 64);
            *(_DWORD *)long long buf = 136315906;
            CFTypeRef v41 = v21;
            __int16 v42 = 1024;
            *(_DWORD *)uint64_t v43 = v23;
            *(_WORD *)&v43[4] = 1024;
            *(_DWORD *)&v43[6] = v39;
            __int16 v44 = 2112;
            uint64_t v45 = v25;
            uint64_t v26 = "#N send ack = %s, message found but ID is different %d vs %d (replaced?), name: %@";
            uint64_t v27 = v19;
            uint32_t v28 = 34;
            goto LABEL_32;
          }
LABEL_33:
          sub_100A45D64(v9, 0, *(void *)(a1 + 32));
          goto LABEL_34;
        }
        CFTypeRef v32 = *(NSObject **)(v9 + 40);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_33;
        }
        uint64_t v33 = "failure";
        uint64_t v34 = *(void *)(a1 + 64);
        if (a2) {
          uint64_t v33 = "success";
        }
        *(_DWORD *)long long buf = 136315394;
        CFTypeRef v41 = v33;
        __int16 v42 = 2112;
        *(void *)uint64_t v43 = v34;
        uint64_t v26 = "#N send ack = %s, message not found, name: %@";
        uint64_t v27 = v32;
      }
      else
      {
        uint64_t v29 = *(NSObject **)(v9 + 40);
        if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_33;
        }
        uint64_t v30 = "failure";
        if (a2) {
          uint64_t v30 = "success";
        }
        uint64_t v31 = "yes";
        if (!a3) {
          uint64_t v31 = "no";
        }
        *(_DWORD *)long long buf = 136315394;
        CFTypeRef v41 = v30;
        __int16 v42 = 2080;
        *(void *)uint64_t v43 = v31;
        uint64_t v26 = "#N send ack = %s, retry = %s";
        uint64_t v27 = v29;
      }
      uint32_t v28 = 22;
LABEL_32:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v26, buf, v28);
      goto LABEL_33;
    }
  }
}

void sub_100A46688(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

const void **sub_100A466AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1001AA314((const void **)(a1 + 64), (const void **)(a2 + 64));

  return sub_1001AA314((const void **)(a1 + 72), (const void **)(a2 + 72));
}

void sub_100A4670C(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 64);
  sub_1000570E8((const void **)(a1 + 72));
  sub_1000570E8(v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100A46764(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I bb update complete (no more messages)", v2, 2u);
  }
}

void sub_100A467C8(uint64_t a1)
{
  uint64_t v2 = *(const char **)(a1 + 128);
  if (v2) {
    uint64_t v3 = sub_1000C06D0;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(NSObject **)(a1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (!v5) {
      goto LABEL_10;
    }
    int v21 = 138412290;
    uint64_t v22 = v2;
    int v6 = "#I Cache: %@";
    uint64_t v7 = v4;
    uint32_t v8 = 12;
  }
  else
  {
    if (!v5) {
      goto LABEL_10;
    }
    LOWORD(v21) = 0;
    int v6 = "#I No cache";
    uint64_t v7 = v4;
    uint32_t v8 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v21, v8);
LABEL_10:
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 272)) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    int v21 = 136315138;
    uint64_t v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Client connected: %s", (uint8_t *)&v21, 0xCu);
    uint64_t v9 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v11 = *(const char **)(a1 + 280);
    int v21 = 134217984;
    uint64_t v22 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Message counter: %zu", (uint8_t *)&v21, 0xCu);
    uint64_t v9 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 288)) {
      CFNumberRef v12 = "true";
    }
    else {
      CFNumberRef v12 = "false";
    }
    int v21 = 136315138;
    uint64_t v22 = v12;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Busy: %s", (uint8_t *)&v21, 0xCu);
    uint64_t v9 = *(NSObject **)(a1 + 40);
  }
  uint64_t v13 = *(void *)(a1 + 296);
  BOOL v14 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (!v14) {
      return;
    }
    CFNumberRef v15 = (const char *)v13;
    if (*(char *)(v13 + 23) < 0) {
      CFNumberRef v15 = *(const char **)v13;
    }
    int v16 = *(_DWORD *)(v13 + 24);
    unint64_t v17 = (void *)(v13 + 32);
    if (*(char *)(v13 + 55) < 0) {
      unint64_t v17 = (void *)*v17;
    }
    int v21 = 136315650;
    uint64_t v22 = v15;
    __int16 v23 = 1024;
    int v24 = v16;
    __int16 v25 = 2080;
    uint64_t v26 = v17;
    CFNumberRef v18 = "#I Last reported device: hw=%s sw=%d uuid=%s";
    CFTypeID v19 = v9;
    uint32_t v20 = 28;
  }
  else
  {
    if (!v14) {
      return;
    }
    LOWORD(v21) = 0;
    CFNumberRef v18 = "#I No last reported device";
    CFTypeID v19 = v9;
    uint32_t v20 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v21, v20);
}

void sub_100A46A7C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A46AB4(uint64_t a1)
{
}

uint64_t sub_100A46AD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A46B14(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100A46B40(ServiceManager::Service *this)
{
  *(void *)this = off_101A2F2E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100A46B9C(ServiceManager::Service *this)
{
  *(void *)this = off_101A2F2E8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100A46C0C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "Peer2PeerController");
}

unsigned char *sub_100A46C1C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100A46C58(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100A452A4(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100A452A4(v4, 0);
}

uint64_t sub_100A46CDC()
{
  return 0;
}

uint64_t sub_100A46CE4()
{
  return 1;
}

uint64_t sub_100A46CEC()
{
  return 0;
}

void sub_100A46CF8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A46DD8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100A46EEC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I shutting down", buf, 2u);
  }
  uint64_t v4 = *(void *)(v2 + 64);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 112));
  sub_100088C88(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100A46F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100A46FB8(uint64_t a1)
{
  uint64_t v18 = a1;
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = *(NSObject **)(*(void *)a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I bootstrapping", buf, 2u);
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v1 + 56) + 16))(buf);
  long long v3 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 104);
  *(_OWORD *)(v1 + 96) = v3;
  if (v4)
  {
    sub_10004D2C8(v4);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  uint64_t v5 = *(void *)(v1 + 96);
  uint64_t v6 = *(void *)(v1 + 24);
  void v23[4] = v1;
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  __int16 v25 = sub_100A47410;
  uint64_t v26 = &unk_101A2F358;
  uint64_t v27 = v1;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = sub_100A4749C;
  void v23[3] = &unk_101A2F378;
  (*(void (**)(uint64_t, uint64_t, uint8_t *, void, void *, Block_layout *))(*(void *)v5 + 16))(v5, v6, buf, 0, v23, &stru_101A2F3B8);
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v7 || (uint64_t v8 = *(void *)(v1 + 64), v9 = *(void *)(v1 + 8), (v10 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v11 = v10;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  CFNumberRef v12 = std::__shared_weak_count::lock(v11);
  if (v12)
  {
    uint64_t v13 = v12;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v21 = v9;
    uint64_t v22 = v12;
    std::__shared_weak_count::__release_weak(v11);
    sub_10004D2C8(v13);
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    std::__shared_weak_count::__release_weak(v11);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 16))(v8, &v21);
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  Registry::createRestModuleOneTimeUseConnection(&v19, *(Registry **)(v1 + 80));
  ctu::RestModule::connect();
  if (v20) {
    sub_10004D2C8(v20);
  }
  sub_100058DB0(v28, "/cc/events/dump_state");
  BOOL v14 = (uint64_t (***)())operator new(0x20uLL);
  *BOOL v14 = off_101A2F3E8;
  v14[1] = (uint64_t (**)())v1;
  void v14[2] = (uint64_t (**)())sub_100A467C8;
  uint64_t v14[3] = 0;
  uint64_t v33 = v14;
  ctu::RestModule::observeEvent();
  CFNumberRef v15 = (capabilities::ct *)sub_10003F600(&v30);
  if (v29 < 0) {
    operator delete(v28[0]);
  }
  int v16 = (capabilities::ct *)capabilities::ct::supportsP2PAsPhone(v15);
  if (v16)
  {
    sub_100058DB0(v28, "/cc/props/cellular_plan_remotesubscription_info");
    uint64_t v30 = off_101A2F468;
    uint64_t v31 = v1 + 136;
    uint64_t v32 = v1;
    uint64_t v33 = &v30;
    ctu::RestModule::observeProperty();
    int v16 = (capabilities::ct *)sub_10003F600(&v30);
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }
  if (capabilities::ct::supportsP2PAsGizmo(v16))
  {
    sub_100058DB0(v28, "/cc/props/carrier_bundles");
    uint64_t v30 = off_101A2F4E8;
    uint64_t v31 = v1 + 248;
    uint64_t v32 = v1;
    uint64_t v33 = &v30;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v30);
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }
  return sub_1003C2130(&v18);
}

void sub_100A473A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  sub_10003F600((void *)(v13 - 88));
  if (*(char *)(v13 - 89) < 0) {
    operator delete(*(void **)(v13 - 112));
  }
  sub_1003C2130(&a9);
  _Unwind_Resume(a1);
}

void sub_100A47410(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = a2[1];
  uint64_t v5 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100A455AC(v2, &v5, 0);
  uint64_t v4 = v6;
  if (v6)
  {
    sub_10004D2C8(v4);
  }
}

void sub_100A47484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4749C(uint64_t a1, int a2, const __CFString *a3, CFTypeRef cf)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!cf)
  {
    uint64_t v10 = *(NSObject **)(v4 + 40);
    goto LABEL_18;
  }
  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (v7 == TypeID) {
    CFDictionaryRef v9 = (const __CFDictionary *)cf;
  }
  else {
    CFDictionaryRef v9 = 0;
  }
  uint64_t v10 = *(NSObject **)(v4 + 40);
  if (!a3 || v7 != TypeID)
  {
LABEL_18:
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "received malformed P2P message. discarding...", buf, 2u);
    }
    return;
  }
  if (os_log_type_enabled(*(os_log_t *)(v4 + 40), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a3;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I received P2P message '%@' from companion device: %@", buf, 0x16u);
  }
  if (!CFStringHasPrefix(a3, @"p2p.network.info."))
  {
    int v16 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    memset(buf, 0, sizeof(buf));
    ctu::cf::assign();
    *(_OWORD *)values = *(_OWORD *)buf;
    uint64_t v34 = *(void *)&buf[16];
    unint64_t v17 = values;
    if ((buf[23] & 0x80u) != 0) {
      unint64_t v17 = *(void ***)buf;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    uint64_t v18 = "#N received unknown P2P message '%s'' from companion device - bail out";
LABEL_45:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v18, buf, 0xCu);
    if (SHIBYTE(v34) < 0) {
      operator delete(values[0]);
    }
    return;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v9, @"message.type");
  CFNumberRef v12 = Value;
  if (Value)
  {
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 == CFNumberGetTypeID()) {
      BOOL v14 = v12;
    }
    else {
      BOOL v14 = 0;
    }
    CFNumberRef v15 = CFDictionaryGetValue(v9, @"message.data");
    if (!v15)
    {
      if (!v14) {
        goto LABEL_41;
      }
      goto LABEL_48;
    }
  }
  else
  {
    CFNumberRef v15 = CFDictionaryGetValue(v9, @"message.data");
    if (!v15)
    {
LABEL_41:
      int v16 = *(NSObject **)(v4 + 40);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)values = *(_OWORD *)buf;
      uint64_t v34 = *(void *)&buf[16];
      uint64_t v27 = values;
      if ((buf[23] & 0x80u) != 0) {
        uint64_t v27 = *(void ***)buf;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      uint64_t v18 = "#N Received empty P2P message '%s' means is was revoked by iPhone";
      goto LABEL_45;
    }
    BOOL v14 = 0;
  }
  CFTypeID v19 = CFGetTypeID(v15);
  if (v19 != CFDataGetTypeID()) {
    CFNumberRef v15 = 0;
  }
  if (!v14) {
    goto LABEL_41;
  }
  if (!v15)
  {
    CFNumberRef v12 = v14;
LABEL_48:
    uint32_t v28 = *(__CFDictionary **)(v4 + 128);
    if (v28) {
      char v29 = sub_1000C06D0;
    }
    else {
      char v29 = 0;
    }
    if (v29) {
      CFDictionaryRemoveValue(v28, v12);
    }
    return;
  }
  if (CFDataGetLength((CFDataRef)v15) > 2039)
  {
    uint64_t v30 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#E invalid data received. discarding...", buf, 2u);
    }
  }
  else
  {
    if (*(void *)(v4 + 128)) {
      uint32_t v20 = sub_1000C06D0;
    }
    else {
      uint32_t v20 = 0;
    }
    if (!v20)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        uint64_t v22 = *(void *)(v4 + 128);
        *(void *)(v4 + 128) = Mutable;
        *(void *)long long buf = v22;
        sub_10005717C((const void **)buf);
      }
    }
    uint64_t v23 = *(void *)(v4 + 280) + 1;
    *(void *)(v4 + 28ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v23;
    values[0] = 0;
    *(void *)long long buf = v23;
    CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, buf);
    if (v24)
    {
      __int16 v25 = values[0];
      values[0] = v24;
      *(void *)long long buf = v25;
      sub_1000570E8((const void **)buf);
    }
    uint64_t v26 = values[0];
    uint64_t v32 = values[0];
    values[0] = 0;
    sub_1000570E8((const void **)values);
    *(_OWORD *)long long buf = *(_OWORD *)off_101A2F138;
    values[0] = v26;
    values[1] = (void *)v15;
    CFDictionaryRef v31 = CFDictionaryCreate(0, (const void **)buf, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v4 + 128), v14, v31);
    sub_100A454D4((const void **)v4, 0);
    sub_100057D78((const void **)&v31);
    sub_1000570E8((const void **)&v32);
  }
}

void sub_100A47900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, __int16 a11, char a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
}

void sub_100A4795C()
{
}

__n128 sub_100A47970(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A2F3E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A479C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A2F3E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A479FC(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100A47A44(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A47A84()
{
}

void sub_100A47A94()
{
}

__n128 sub_100A47AA8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A2F468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100A47AF4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A2F468;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A47B24(uint64_t a1, cellplan::RemoteSimSubscriptionInfo *a2)
{
  sub_1003C8A7C(*(unsigned char **)(a1 + 8), a2);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v6 = 0;
  CFTypeID v7 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v3 + 96) + 120))(&v6);
  if (v6)
  {
    uint64_t v4 = v6;
    uint64_t v5 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100A455AC(v3, &v4, 0);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

void sub_100A47BD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A47BF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A47C34()
{
}

void sub_100A47C44()
{
}

__n128 sub_100A47C58(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A2F4E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100A47CA4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A2F4E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A47CD4(uint64_t a1, xpc_object_t *a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v22 = (void **)*v3;
  uint64_t v23 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v23;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v22 = &v23;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = *(void *)(a1 + 16);
  CFTypeID v7 = *(void **)(v6 + 248);
  if (v7 != (void *)(v6 + 256))
  {
    do
    {
      uint64_t v8 = v23;
      if (!v23) {
        goto LABEL_19;
      }
      int v9 = *((_DWORD *)v7 + 8);
      uint64_t v10 = &v23;
      do
      {
        unint64_t v11 = v8;
        CFNumberRef v12 = v10;
        int v13 = *((_DWORD *)v8 + 8);
        BOOL v14 = v8 + 1;
        if (v13 >= v9)
        {
          BOOL v14 = v11;
          uint64_t v10 = (void **)v11;
        }
        uint64_t v8 = (void *)*v14;
      }
      while (v8);
      if (v10 == &v23
        || (v13 >= v9 ? (CFNumberRef v15 = v11) : (CFNumberRef v15 = v12),
            v9 < *((_DWORD *)v15 + 8)
         || (v13 >= v9 ? (int v16 = v11) : (int v16 = v12), *((unsigned __int8 *)v16 + 40) != *((unsigned __int8 *)v7 + 40))))
      {
LABEL_19:
        if (*((unsigned __int8 *)v7 + 40) - 1 <= 2)
        {
          unint64_t v17 = *(NSObject **)(v6 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I CB changed, drop my BBInfo", buf, 2u);
          }
          uint64_t v18 = *(void *)(v6 + 328);
          *(void *)(v6 + 328) = 0;
          *(void *)long long buf = v18;
          sub_100057D78((const void **)buf);
          sub_100A454D4((const void **)v6, 1);
        }
      }
      CFTypeID v19 = (void *)v7[1];
      if (v19)
      {
        do
        {
          uint32_t v20 = v19;
          CFTypeID v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint32_t v20 = (void *)v7[2];
          BOOL v21 = *v20 == (void)v7;
          CFTypeID v7 = v20;
        }
        while (!v21);
      }
      CFTypeID v7 = v20;
    }
    while (v20 != (void *)(v6 + 256));
  }
  sub_100087F94((uint64_t)&v22, v23);
}

void sub_100A47E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100A47EA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A47EE4()
{
}

void sub_100A47EF0(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I starting", buf, 2u);
  }
  (*(void (**)(void))(**(void **)(v1 + 64) + 24))(*(void *)(v1 + 64));
  operator delete();
}

void sub_100A47FAC()
{
}

void *sub_100A47FD8(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  uint64_t v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint32_t v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  CFNumberRef v12 = "DATA.Connection.UT.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    CFNumberRef v12 = "DATA.Connection.UT.2";
  }
  BOOL v14 = "UT.X";
  if (v13 == 2) {
    BOOL v14 = "UT.2";
  }
  if (v13 == 1) {
    CFNumberRef v15 = "DATA.Connection.UT.1";
  }
  else {
    CFNumberRef v15 = v12;
  }
  if (v13 == 1) {
    int v16 = "UT.1";
  }
  else {
    int v16 = v14;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_101A2FFD8, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_101A2F5A0;
  a1[8] = off_101A2FAF0;
  a1[9] = off_101A2FD80;
  a1[10] = off_101A2FF70;
  return a1;
}

void sub_100A48164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100A48190(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_101A2FFD8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A481C0(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_101A2FFD8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A481F4(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_101A2FFD8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A48228(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_101A2FFD8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100A4825C(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_101A2FFD8);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100A482A0(uint64_t a1)
{
}

void sub_100A482A8(uint64_t a1)
{
}

void sub_100A482B0(uint64_t a1)
{
}

uint64_t sub_100A482B8@<X0>(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1[11]);
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      if (!v11)
      {
        CFNumberRef v12 = 0;
LABEL_27:
        sub_10004D2C8(v10);
        return ((void)v12 << 40) | (v11 << 32) | 0x1000000;
      }
    }
    else
    {
      std::mutex::unlock(v4);
      if (!v11)
      {
        CFNumberRef v12 = 0;
        return ((void)v12 << 40) | (v11 << 32) | 0x1000000;
      }
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    (*((void (**)(void **__return_ptr, Registry **))*a1 + 64))(__p, a1);
    uint64_t v20 = 0;
    BOOL v21 = 0;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **))(*(void *)v11 + 40))(&v20, v11, __p);
    if (v20)
    {
      (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v20 + 40))(&cf);
      int v13 = (BOOL *)cf;
      unsigned __int8 v24 = 0;
      if (cf && (CFTypeID v14 = CFGetTypeID(cf), v14 == CFBooleanGetTypeID()))
      {
        ctu::cf::assign((ctu::cf *)&v24, v13, v15);
        uint64_t v11 = v24;
      }
      else
      {
        uint64_t v11 = 0;
      }
      sub_1000577C4(&cf);
      (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v20 + 40))(&cf);
      CFNumberRef v12 = (BOOL *)cf;
      unsigned __int8 v24 = 0;
      if (cf)
      {
        CFTypeID v16 = CFGetTypeID(cf);
        if (v16 == CFBooleanGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)&v24, v12, v17);
          CFNumberRef v12 = (BOOL *)v24;
        }
        else
        {
          CFNumberRef v12 = 0;
        }
      }
      sub_1000577C4(&cf);
    }
    else
    {
      uint64_t v11 = 0;
      CFNumberRef v12 = 0;
    }
    if (v21) {
      sub_10004D2C8(v21);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
    if (v10) {
      goto LABEL_27;
    }
  }
  else
  {
    std::mutex::unlock(v4);
    CFNumberRef v12 = 0;
    uint64_t v11 = 0;
  }
  return ((void)v12 << 40) | (v11 << 32) | 0x1000000;
}

void sub_100A48580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A485E0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_100A482B8((Registry **)(a1 - 72), a2);
}

uint64_t sub_100A48600()
{
  return 0;
}

uint64_t sub_100A48608()
{
  return 0;
}

CFTimeZoneRef TimeHandler::getSystemTimeZone@<X0>(CFTimeZoneRef *a1@<X8>)
{
  CFTimeZoneRef result = CFTimeZoneCopySystem();
  *a1 = result;
  return result;
}

void *sub_100A4863C@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  if (*((unsigned char *)a1 + 4)) {
    uint64_t v2 = off_101A30D88[*a1 + 1];
  }
  else {
    uint64_t v2 = "Success";
  }
  return sub_100058DB0(a2, v2);
}

uint64_t sub_100A48670(void *a1)
{
  int v2 = (*(uint64_t (**)(void))(*(void *)*a1 + 16))(*a1);
  switch(v2)
  {
    case 4:
      if (*a1)
      {
        {
          uint64_t v4 = a1[1];
          if (v4) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
          }
        }
      }
      sub_100CC80B0();
    case 3:
      if (*a1)
      {
        {
          uint64_t v5 = a1[1];
          if (v5) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
          }
        }
      }
      sub_100CC80B0();
    case 1:
      if (*a1
      {
        uint64_t v3 = a1[1];
        if (v3) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
        }
      }
      sub_100CC80B0();
  }
  return 0;
}

void sub_100A48844(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A48864@<X0>(void *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = sub_100A48670(a1);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)*a1 + 16))();
    switch((int)result)
    {
      case 1:
        uint64_t v5 = (char *)*a1;
        if (*a1)
        {
          if (v5)
          {
            uint64_t v6 = a1[1];
            if (v6) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
            }
          }
        }
        if (v5[87] < 0)
        {
          sub_10004FC84(&__dst, *((void **)v5 + 8), *((void *)v5 + 9));
        }
        else
        {
          long long __dst = *((_OWORD *)v5 + 4);
          uint64_t v16 = *((void *)v5 + 10);
        }
        sub_100CC71C0();
      case 3:
        uint64_t v7 = (char *)*a1;
        if (*a1)
        {
          if (v7)
          {
            uint64_t v8 = a1[1];
            if (v8) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
            }
          }
        }
        if (v7[111] < 0)
        {
          sub_10004FC84(__p, *((void **)v7 + 11), *((void *)v7 + 12));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(v7 + 88);
          uint64_t v14 = *((void *)v7 + 13);
        }
        sub_100CC71C0();
      case 4:
        int v9 = (char *)*a1;
        if (*a1)
        {
          if (v9)
          {
            uint64_t v10 = a1[1];
            if (v10) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
            }
          }
        }
        if (v9[135] < 0)
        {
          sub_10004FC84(&v11, *((void **)v9 + 14), *((void *)v9 + 15));
        }
        else
        {
          long long v11 = *((_OWORD *)v9 + 7);
          uint64_t v12 = *((void *)v9 + 16);
        }
        sub_100CC71C0();
      default:
        break;
    }
  }
  *a2 = 0;
  a2[24] = 0;
  return result;
}

void sub_100A48B74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (v28) {
    sub_10004D2C8(v28);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100A48BEC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_100058DB0(a2, off_101A30DE0[*(int *)(*(void *)a1 + 56) + 1]);
}

void *sub_100A48C0C@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (sub_100B90DB8(a1))
  {
    uint64_t v6 = "text";
    uint64_t v7 = "group text";
    goto LABEL_3;
  }
  if (sub_100B90EA8(a1))
  {
    uint64_t v8 = "imdn";
    goto LABEL_21;
  }
  if (sub_100B90F20(a1))
  {
    uint64_t v8 = "composing";
    goto LABEL_21;
  }
  if (sub_100B90F98(a1))
  {
    uint64_t v6 = "file transfer push";
    uint64_t v7 = "group file transfer push";
LABEL_3:
    if (a2) {
      uint64_t v8 = (char *)v7;
    }
    else {
      uint64_t v8 = (char *)v6;
    }
    goto LABEL_21;
  }
  if (sub_100B91010(a1))
  {
    uint64_t v8 = "card";
  }
  else if (sub_100B91088(a1))
  {
    uint64_t v8 = "group chat";
  }
  else
  {
    BOOL v9 = sub_100B90E30(a1);
    uint64_t v10 = "group geo location push";
    if (a2) {
      uint64_t v10 = "geo location push";
    }
    if (v9) {
      uint64_t v8 = (char *)v10;
    }
    else {
      uint64_t v8 = "invalid";
    }
  }
LABEL_21:

  return sub_100058DB0(a3, v8);
}

BOOL sub_100A48D24(uint64_t a1)
{
  BOOL v2 = 0;
  uint64_t v3 = *(_DWORD **)a1;
  switch(v3[14])
  {
    case 0:
    case 1:
    case 0xD:
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
        if (v5)
        {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
          int v6 = v4[48];
          goto LABEL_16;
        }
      }
      int v9 = v4[48];
      return v9 != 0;
    case 2:
    case 3:
      if (!v7) {
        return 0;
      }
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        int v6 = v7[72];
        goto LABEL_16;
      }
      int v9 = v7[72];
      return v9 != 0;
    case 4:
    case 5:
      if (v8)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
        if (v5)
        {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
          int v6 = v8[272];
          goto LABEL_16;
        }
      }
      int v9 = v8[272];
      return v9 != 0;
    case 6:
      if (v10)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
        if (v5)
        {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
          int v6 = v10[464];
LABEL_16:
          BOOL v2 = v6 != 0;
          long long v11 = v5;
          goto LABEL_17;
        }
      }
      int v9 = v10[464];
      return v9 != 0;
    case 7:
      uint64_t v12 = v11;
      if (v11)
      {
        long long v11 = *(std::__shared_weak_count **)(a1 + 8);
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      if (!LOBYTE(v12[10].__shared_owners_))
      {
        BOOL v2 = LOBYTE(v12[9].__vftable) != 0;
        if (!v11) {
          return v2;
        }
LABEL_17:
        sub_10004D2C8(v11);
        return v2;
      }
      BOOL v2 = 1;
      if (v11) {
        goto LABEL_17;
      }
      return v2;
    default:
      return v2;
  }
}

uint64_t SaveDataModeController::create@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = capabilities::ct::getBasebandBootStrategy(a1);
  *a2 = 0;
  a2[1] = 0;
  if (result != 2) {
    operator new();
  }
  return result;
}

void sub_100A49608(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PersonalitiesTracker *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ctu::OsLogLogger *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,dispatch_object_t object,dispatch_object_t a25,uint64_t a26)
{
  sub_10008863C((void *)(v26 - 128));
  operator delete();
}

void sub_100A498C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v15 - 128));
  JUMPOUT(0x100A498A0);
}

void sub_100A498EC()
{
}

const char *sub_100A498F4(int a1)
{
  uint64_t v1 = "sdmc.?";
  if (a1 == 2) {
    uint64_t v1 = "sdmc.2";
  }
  if (a1 == 1) {
    return "sdmc.1";
  }
  else {
    return v1;
  }
}

void *sub_100A49920(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100A527F4((void *)a1);
}

void sub_100A49960(uint64_t a1, dispatch_object_t object)
{
  uint64_t v3 = (void *)(a1 + 8);
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_100A49A58(uint64_t a1, xpc_object_t object, NSObject **a3)
{
  if (object) {
    xpc_retain(object);
  }
  else {
    xpc_null_create();
  }
  uint64_t v5 = *a3;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, (void *)(a1 + 8));
  operator new();
}

uint64_t sub_100A49BC0(uint64_t result, int a2, uint64_t a3)
{
  if (*(void *)(a3 + 24))
  {
    uint64_t v3 = (void *)(result + 8);
    v4[4] = result;
    int v5 = a2;
    sub_100023950((uint64_t)&v6, a3);
    v4[0] = 0;
    v4[1] = 0;
    sub_10003E168(v4, v3);
    operator new();
  }
  return result;
}

void sub_100A49D10(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100A49D20(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL sub_100A49E10(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100A56D08;
  v7[3] = &unk_101A318A0;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  BOOL v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    uint64_t block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_10005B0A4;
    uint64_t v12 = &unk_101A318E0;
    int v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    uint64_t block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    long long v11 = sub_10005A340;
    uint64_t v12 = &unk_101A318C0;
    int v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_100A49F48(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

uint64_t sub_100A4A034(capabilities::ct *a1, int a2)
{
  uint64_t result = capabilities::ct::supports5G(a1);
  if (result)
  {
    int v6 = a1;
    int v7 = a2;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    _OWORD v8[2] = sub_100A56DBC;
    void v8[3] = &unk_101A31900;
    v8[4] = (char *)a1 + 8;
    v8[5] = &v6;
    int v9 = v8;
    uint64_t v5 = *((void *)a1 + 3);
    if (*((void *)a1 + 4))
    {
      char v16 = 0;
      uint64_t block = _NSConcreteStackBlock;
      uint64_t v11 = 0x40000000;
      uint64_t v12 = sub_10005B0A4;
      int v13 = &unk_101A318E0;
      uint64_t v14 = &v16;
      char v15 = &v9;
      dispatch_async_and_wait(v5, &block);
    }
    else
    {
      char v16 = 0;
      uint64_t block = _NSConcreteStackBlock;
      uint64_t v11 = 0x40000000;
      uint64_t v12 = sub_10005A340;
      int v13 = &unk_101A318C0;
      uint64_t v14 = &v16;
      char v15 = &v9;
      dispatch_sync(v5, &block);
    }
    return v16 != 0;
  }
  return result;
}

BOOL sub_100A4A184(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_100A56DCC;
  v7[3] = &unk_101A31920;
  void v7[4] = a1 + 8;
  void v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  BOOL v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    uint64_t block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005B0A4;
    uint64_t v12 = &unk_101A318E0;
    int v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    uint64_t block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A340;
    uint64_t v12 = &unk_101A318C0;
    int v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_100A4A2BC(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

BOOL sub_100A4A3A8(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _OWORD v5[2] = sub_100A56E6C;
  v5[3] = &unk_101A31940;
  uint64_t v5[4] = a1 + 8;
  void v5[5] = &v4;
  int v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    uint64_t block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    int v9 = sub_10005B0A4;
    uint64_t v10 = &unk_101A318E0;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    uint64_t block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    int v9 = sub_10005A340;
    uint64_t v10 = &unk_101A318C0;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_100A4A4D8(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100A4A5BC(uint64_t a1, CFDateRef *a2)
{
  if (*a2) {
    uint64_t v3 = sub_1001908E4;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(*a2);
    double Current = CFAbsoluteTimeGetCurrent();
    Registry::getTimerService(&v33, *(Registry **)(a1 + 56));
    uint64_t v7 = v33;
    sub_100058DB0(v31, "OverriddenInterfaceCost timer");
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v8 || (uint64_t v9 = *(void *)(a1 + 8), (v10 = std::__shared_weak_count::lock(v8)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v11 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
    *(_OWORD *)long long __p = *(_OWORD *)v31;
    uint64_t v37 = v32;
    v31[0] = 0;
    v31[1] = 0;
    uint64_t v32 = 0;
    int v39 = 0;
    uint64_t v12 = operator new(0x20uLL);
    *uint64_t v12 = off_101A31970;
    v12[1] = a1;
    void v12[2] = v9;
    v12[3] = v11;
    int v39 = v12;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, unsigned char *))(*(void *)v7 + 40))(&v35, v7, __p, 1, 1000000 * (uint64_t)(AbsoluteTime - Current), 0, buf);
    sub_10003B34C(buf);
    if (SHIBYTE(v37) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v13 = v35;
    uint64_t v35 = 0;
    uint64_t v14 = *(void *)(a1 + 616);
    *(void *)(a1 + 616) = v13;
    if (v14)
    {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      uint64_t v15 = v35;
      uint64_t v35 = 0;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
      }
    }
    if (SHIBYTE(v32) < 0) {
      operator delete(v31[0]);
    }
    if (v34) {
      sub_10004D2C8(v34);
    }
    char v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = (uint64_t)(AbsoluteTime - Current);
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Overridden interface cost will expire after %lld seconds", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v17, *(Registry **)(a1 + 56));
    uint64_t v19 = ServiceMap;
    if (v20 < 0)
    {
      BOOL v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v22 = 5381;
      do
      {
        uint64_t v20 = v22;
        unsigned int v23 = *v21++;
        uint64_t v22 = (33 * v22) ^ v23;
      }
      while (v23);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v20;
    unsigned __int8 v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)buf);
    if (v24)
    {
      uint64_t v26 = v24[3];
      __int16 v25 = (std::__shared_weak_count *)v24[4];
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v19);
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v25);
        char v27 = 0;
        if (!v26) {
          goto LABEL_24;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    std::mutex::unlock(v19);
    __int16 v25 = 0;
    char v27 = 1;
    if (!v26)
    {
LABEL_24:
      uint32_t v28 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Fail to retrieve CFPreferencesInterface. Overridden interface cost will not persist across reboots", buf, 2u);
      }
      goto LABEL_29;
    }
LABEL_28:
    CFDateRef v29 = *a2;
    uint64_t v30 = kCommCenterPreferencesNoBackupAppID;
    (*(void (**)(uint64_t, const __CFString *, CFDateRef, void, const CFStringRef, const CFStringRef))(*(void *)v26 + 16))(v26, @"OverriddenInexpensiveExpirationTime", v29, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    (*(void (**)(uint64_t, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v26 + 48))(v26, v30, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
LABEL_29:
    if ((v27 & 1) == 0) {
      sub_10004D2C8(v25);
    }
  }
}

void sub_100A4A9B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4AA38(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 616);
  if (v3)
  {
    *(void *)(a1 + 616) = 0;
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 56));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v15);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_11:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v13 = 0;
  if (v12)
  {
LABEL_12:
    uint64_t v14 = kCommCenterPreferencesNoBackupAppID;
    (*(void (**)(uint64_t, const __CFString *, void, void, const CFStringRef, const CFStringRef))(*(void *)v12 + 16))(v12, @"OverriddenInexpensiveExpirationTime", 0, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    (*(void (**)(uint64_t, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v12 + 48))(v12, v14, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  }
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100A4ABE8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4AC00(uint64_t a1, dispatch_object_t *a2)
{
  char v2 = (void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

uint64_t sub_100A4AD28(capabilities::ct *a1)
{
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v32 = &v33;
  subscriber::makeSimSlotRange();
  uint64_t v3 = *(unsigned int **)buf;
  char v2 = v30;
  if (*(unsigned int **)buf != v30)
  {
    uint64_t v4 = v31;
    while ((v31(*v3) & 1) == 0)
    {
      if (++v3 == v30)
      {
        uint64_t v3 = v30;
        break;
      }
    }
    uint64_t v5 = v30;
    while (v3 != v5)
    {
      uint64_t v6 = *v3;
      unsigned int PersistedLowDataMode_sync = (unsigned __int16)SaveDataModeController::getPersistedLowDataMode_sync((uint64_t)a1, v6);
      if (PersistedLowDataMode_sync <= 0x100) {
        char v8 = 0;
      }
      else {
        char v8 = PersistedLowDataMode_sync;
      }
      __int16 v9 = sub_100A4B22C((uint64_t)a1, v6);
      BOOL v10 = sub_100A4B494((uint64_t)a1, v6);
      if ((v9 & 0xFF00) != 0) {
        BOOL v11 = v9 != 0;
      }
      else {
        BOOL v11 = v10;
      }
      __int16 v12 = sub_100A4B69C((uint64_t)a1, v6);
      int v13 = HIBYTE(v12);
      if (HIBYTE(v12))
      {
        int v14 = v12;
      }
      else
      {
        __int16 v15 = sub_100A4B904(a1, v6);
        int v14 = v15;
        int v13 = HIBYTE(v15);
      }
      if (v13) {
        BOOL v16 = v14 == 0;
      }
      else {
        BOOL v16 = 0;
      }
      BOOL v17 = !v16;
      rest::SaveDataModePreference::SaveDataModePreference((rest::SaveDataModePreference *)&v27, v8 != 0, v11, v17);
      uint64_t v18 = v33;
      uint64_t v19 = &v33;
      uint64_t v20 = &v33;
      if (v33)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v20 = (uint64_t **)v18;
            int v21 = *((_DWORD *)v18 + 7);
            if (v21 <= (int)v6) {
              break;
            }
            uint64_t v18 = *v20;
            uint64_t v19 = v20;
            if (!*v20) {
              goto LABEL_29;
            }
          }
          if (v21 >= (int)v6) {
            break;
          }
          uint64_t v18 = v20[1];
          if (!v18)
          {
            uint64_t v19 = v20 + 1;
            goto LABEL_29;
          }
        }
      }
      else
      {
LABEL_29:
        uint64_t v22 = operator new(0x28uLL);
        v22[7] = v6;
        *((_WORD *)v22 + 16) = v27;
        *((unsigned char *)v22 + 34) = v28;
        *(void *)uint64_t v22 = 0;
        *((void *)v22 + 1) = 0;
        *((void *)v22 + 2) = v20;
        std::mutex *v19 = (uint64_t *)v22;
        if (*v32)
        {
          uint64_t v32 = (uint64_t **)*v32;
          uint64_t v22 = *v19;
        }
        sub_100046C90(v33, (uint64_t *)v22);
        ++v34;
      }
      unsigned int v23 = v3 + 1;
      uint64_t v3 = v2;
      if (v23 != v2)
      {
        uint64_t v3 = v23;
        while ((v4(*v3) & 1) == 0)
        {
          if (++v3 == v2)
          {
            uint64_t v3 = v2;
            break;
          }
        }
      }
    }
  }
  uint64_t v24 = sub_100A4BDA8((uint64_t)a1 + 200, &v32);
  sub_100A4C0C4((uint64_t)a1);
  if (v24)
  {
    __int16 v25 = *((void *)a1 + 5);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N Persisted save data modes restored", buf, 2u);
    }
    sub_100A4C524((uint64_t)a1);
  }
  sub_1000346F8((uint64_t)&v32, v33);
  return v24;
}

void sub_100A4AFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *a15)
{
}

uint64_t SaveDataModeController::getPersistedLowDataMode_sync(uint64_t a1, uint64_t a2)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v24 = 0;
  uint64_t v4 = (Registry **)(a1 + 56);
  PersonalityIdFromSlotId();
  if (SHIBYTE(v22) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    uint64_t v5 = (uint64_t *)SHIBYTE(v22);
    if ((v5 & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)__p;
    uint64_t v5 = v22;
    uint64_t v24 = v22;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *v4);
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    __int16 v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v8;
  __int16 v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (v12)
  {
    uint64_t v14 = v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_11;
      }
LABEL_17:
      __int16 v19 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v14 + 184))(v14, __dst);
      unsigned __int8 v18 = v19;
      int v17 = HIBYTE(v19);
      if (v15) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
  if (v14) {
    goto LABEL_17;
  }
LABEL_11:
  BOOL v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to get low data mode settings", (uint8_t *)__p, 2u);
  }
  int v17 = 0;
  unsigned __int8 v18 = 0;
  if ((v15 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v13);
LABEL_19:
  if (SHIBYTE(v24) < 0) {
    operator delete(__dst[0]);
  }
  return v18 | (v17 << 8);
}

void sub_100A4B1E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A4B22C(uint64_t a1, uint64_t a2)
{
  if (!capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    int v5 = 0;
    unsigned __int8 v6 = 0;
    return v6 | (v5 << 8);
  }
  __dst[0] = 0;
  __dst[1] = 0;
  unsigned int v23 = 0;
  PersonalityIdFromSlotId();
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    uint64_t v4 = (uint64_t *)SHIBYTE(v21);
    if ((v4 & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)__p;
    uint64_t v4 = v21;
    unsigned int v23 = v21;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 56));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_13;
      }
LABEL_19:
      __int16 v18 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v15 + 200))(v15, __dst);
      unsigned __int8 v6 = v18;
      int v5 = HIBYTE(v18);
      if (v16) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_19;
  }
LABEL_13:
  int v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to get smart data mode settings", (uint8_t *)__p, 2u);
  }
  int v5 = 0;
  unsigned __int8 v6 = 0;
  if (v16) {
    goto LABEL_21;
  }
LABEL_20:
  sub_10004D2C8(v14);
LABEL_21:
  if (SHIBYTE(v23) < 0) {
    operator delete(__dst[0]);
  }
  return v6 | (v5 << 8);
}

void sub_100A4B448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100A4B494(uint64_t a1, uint64_t a2)
{
  if (!capabilities::ct::supports5G((capabilities::ct *)a1)) {
    return 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 56));
  unsigned __int8 v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    unsigned int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_8;
      }
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  unsigned int v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_8:
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E Cannot find carrier settings interface", buf, 2u);
    }
    BOOL v16 = 0;
    if (v14) {
      return v16;
    }
LABEL_20:
    sub_10004D2C8(v12);
    return v16;
  }
LABEL_15:
  BOOL v16 = 1;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v13 + 96))(buf, v13, a2, 1, @"Enable5GAutoByDefault", 0, 0);
  int v17 = *(BOOL **)buf;
  char v21 = 1;
  if (*(void *)buf)
  {
    CFTypeID v18 = CFGetTypeID(*(CFTypeRef *)buf);
    if (v18 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v21, v17, v19);
      BOOL v16 = v21 != 0;
    }
    else
    {
      BOOL v16 = 1;
    }
  }
  sub_1000577C4((const void **)buf);
  if ((v14 & 1) == 0) {
    goto LABEL_20;
  }
  return v16;
}

void sub_100A4B670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A4B69C(uint64_t a1, uint64_t a2)
{
  if (!capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    int v5 = 0;
    unsigned __int8 v6 = 0;
    return v6 | (v5 << 8);
  }
  __dst[0] = 0;
  __dst[1] = 0;
  unsigned int v23 = 0;
  PersonalityIdFromSlotId();
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    uint64_t v4 = (uint64_t *)SHIBYTE(v21);
    if ((v4 & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)__p;
    uint64_t v4 = v21;
    unsigned int v23 = v21;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 56));
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    unsigned int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (v13)
  {
    uint64_t v15 = v13[3];
    char v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_13;
      }
LABEL_19:
      __int16 v18 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v15 + 232))(v15, __dst);
      unsigned __int8 v6 = v18;
      int v5 = HIBYTE(v18);
      if (v16) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  char v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_19;
  }
LABEL_13:
  int v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to get interface cost settings", (uint8_t *)__p, 2u);
  }
  int v5 = 0;
  unsigned __int8 v6 = 0;
  if (v16) {
    goto LABEL_21;
  }
LABEL_20:
  sub_10004D2C8(v14);
LABEL_21:
  if (SHIBYTE(v23) < 0) {
    operator delete(__dst[0]);
  }
  return v6 | (v5 << 8);
}

void sub_100A4B8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A4B904(capabilities::ct *a1, uint64_t a2)
{
  if (!capabilities::ct::supports5G(a1))
  {
    unsigned __int8 v13 = 0;
    int v14 = 0;
    return v13 | (v14 << 8);
  }
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(**((void **)a1 + 6) + 16))(*((void **)a1 + 6), a2);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v39 = 0;
  PersonalityIdFromSlotId();
  int v5 = sub_100046F68((uint64_t)a1 + 504, __p);
  if ((void **)((char *)a1 + 512) == v5) {
    goto LABEL_61;
  }
  unsigned __int8 v6 = (char *)v5[9];
  if (!v6) {
    goto LABEL_13;
  }
  uint64_t v7 = v5 + 9;
  do
  {
    int v8 = *((_DWORD *)v6 + 7);
    BOOL v9 = v8 < 15;
    if (v8 >= 15) {
      unsigned int v10 = (void **)v6;
    }
    else {
      unsigned int v10 = (void **)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = (void **)v6;
    }
    unsigned __int8 v6 = (char *)*v10;
  }
  while (*v10);
  if (v7 == v5 + 9 || *((int *)v7 + 7) >= 16)
  {
LABEL_13:
    uint64_t v11 = *v4;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
LABEL_16:
      unsigned __int8 v13 = 1;
      goto LABEL_17;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v12 = "#N 5G entitlement state not found";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
    goto LABEL_16;
  }
  int v15 = *((_DWORD *)v7 + 8);
  if (v15 != 2)
  {
    if (v15 == 1)
    {
      uint64_t v11 = *v4;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_16;
      }
      *(_WORD *)long long buf = 0;
      unsigned int v12 = "#N 5G entitlement state disabled";
      goto LABEL_15;
    }
    uint64_t v34 = *v4;
    unsigned __int8 v13 = 0;
    int v14 = 0;
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#N 5G entitlement state not allowed", buf, 2u);
LABEL_61:
    unsigned __int8 v13 = 0;
    int v14 = 0;
    goto LABEL_62;
  }
  __int16 v18 = (char *)v5[12];
  char v16 = v5 + 12;
  int v17 = v18;
  if (!v18) {
    goto LABEL_16;
  }
  CFBooleanRef v19 = v16;
  do
  {
    int v20 = *((_DWORD *)v17 + 8);
    BOOL v21 = v20 < 15;
    if (v20 >= 15) {
      char v22 = (void **)v17;
    }
    else {
      char v22 = (void **)(v17 + 8);
    }
    if (!v21) {
      CFBooleanRef v19 = (void **)v17;
    }
    int v17 = (char *)*v22;
  }
  while (*v22);
  if (v19 == v16 || *((int *)v19 + 8) > 15) {
    goto LABEL_16;
  }
  unsigned int v23 = v19[5];
  uint64_t v24 = v19[6];
  if (v23 == v24)
  {
LABEL_66:
    uint64_t v11 = *v4;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
    *(_WORD *)long long buf = 0;
    unsigned int v12 = "#N No 5G plan found";
    goto LABEL_15;
  }
  char v25 = 0;
  char v26 = 0;
  char v27 = 1;
  do
  {
    while (1)
    {
      if (*((unsigned char *)v23 + 4))
      {
        if (*v23 == 1)
        {
          char v28 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I 5G unmetered plan found", buf, 2u);
          }
          int v29 = 1;
        }
        else if (*((unsigned char *)v23 + 16))
        {
          uint64_t v32 = *v4;
          if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
          {
            int v33 = v23[3];
            *(_DWORD *)long long buf = 67109120;
            LODWORD(v41) = v33;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I 5G metered plan with volume cap of %d GB found", buf, 8u);
          }
          int v29 = v23[3] > 99;
        }
        else
        {
          int v29 = 0;
        }
        goto LABEL_54;
      }
      if (!*((unsigned char *)v23 + 9)) {
        break;
      }
      uint64_t v30 = *v4;
      if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v23 + 8)) {
          CFDictionaryRef v31 = "true";
        }
        else {
          CFDictionaryRef v31 = "false";
        }
        *(_DWORD *)long long buf = 136315138;
        CFTypeRef v41 = v31;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I 5G plan with 5G experience '%s' found", buf, 0xCu);
      }
      int v29 = *((unsigned __int8 *)v23 + 8);
LABEL_54:
      char v27 = 0;
      if (v29) {
        char v26 = 1;
      }
      else {
        char v26 = v25 & (v26 != 0);
      }
      v23 += 16;
      char v25 = 1;
      if (v23 == v24) {
        goto LABEL_68;
      }
    }
    v23 += 16;
  }
  while (v23 != v24);
  if (v27) {
    goto LABEL_66;
  }
LABEL_68:
  CFNumberRef v36 = *v4;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = "enabled";
    if (!v26) {
      uint64_t v37 = "disabled";
    }
    *(_DWORD *)long long buf = 136315138;
    CFTypeRef v41 = v37;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#N HDM is %s by 5G plan", buf, 0xCu);
  }
  unsigned __int8 v13 = v26 ^ 1;
LABEL_17:
  int v14 = 1;
LABEL_62:
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  return v13 | (v14 << 8);
}

void sub_100A4BD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A4BDA8(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 48) == a2[2])
  {
    uint64_t v4 = *(void **)(a1 + 32);
    int v5 = (void *)(a1 + 40);
    if (v4 == (void *)(a1 + 40)) {
      return 0;
    }
    unsigned __int8 v6 = (void *)*a2;
    while (*((_DWORD *)v4 + 7) == *((_DWORD *)v6 + 7) && rest::operator==())
    {
      uint64_t v7 = (void *)v4[1];
      int v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v9 = *v4 == (void)v8;
          int v8 = v4;
        }
        while (!v9);
      }
      unsigned int v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          unsigned __int8 v6 = v11;
        }
        while (!v9);
      }
      unsigned __int8 v6 = v11;
      if (v4 == v5) {
        return 0;
      }
    }
  }
  if ((void *)(a1 + 32) != a2)
  {
    int v15 = (void *)*a2;
    unsigned __int8 v13 = a2 + 1;
    int v14 = v15;
    if (!*(void *)(a1 + 48)) {
      goto LABEL_42;
    }
    int v17 = (uint64_t **)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v18 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = a1 + 40;
    *(void *)(v16 + 16) = 0;
    *(void *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    *(void *)(a1 + 48) = 0;
    uint64_t v19 = *(void *)(v18 + 8) ? *(void *)(v18 + 8) : v18;
    if (v19)
    {
      int v20 = sub_1000EA590(v19);
      if (v14 == v13)
      {
        BOOL v21 = (void *)v19;
        char v28 = v14;
      }
      else
      {
        do
        {
          BOOL v21 = v20;
          int v22 = *((_DWORD *)v14 + 7);
          *(_DWORD *)(v19 + 28) = v22;
          __int16 v23 = *((_WORD *)v14 + 16);
          *(unsigned char *)(v19 + 34) = *((unsigned char *)v14 + 34);
          *(_WORD *)(v19 + 32) = v23;
          uint64_t v24 = *v17;
          char v25 = (uint64_t **)(a1 + 40);
          char v26 = (uint64_t **)(a1 + 40);
          if (*v17)
          {
            do
            {
              while (1)
              {
                char v25 = (uint64_t **)v24;
                if (v22 >= *((_DWORD *)v24 + 7)) {
                  break;
                }
                uint64_t v24 = (uint64_t *)*v24;
                char v26 = v25;
                if (!*v25) {
                  goto LABEL_31;
                }
              }
              uint64_t v24 = (uint64_t *)v24[1];
            }
            while (v24);
            char v26 = v25 + 1;
          }
LABEL_31:
          sub_100046C38((uint64_t **)(a1 + 32), (uint64_t)v25, v26, (uint64_t *)v19);
          if (v20) {
            int v20 = sub_1000EA590((uint64_t)v20);
          }
          else {
            int v20 = 0;
          }
          char v27 = (void *)v14[1];
          if (v27)
          {
            do
            {
              char v28 = v27;
              char v27 = (void *)*v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              char v28 = (void *)v14[2];
              BOOL v9 = *v28 == (void)v14;
              int v14 = v28;
            }
            while (!v9);
          }
          if (!v21) {
            break;
          }
          uint64_t v19 = (uint64_t)v21;
          int v14 = v28;
        }
        while (v28 != v13);
      }
      sub_1000346F8(a1 + 32, v21);
      if (v20)
      {
        for (uint64_t i = (void *)v20[2]; i; uint64_t i = (void *)i[2])
          int v20 = i;
        sub_1000346F8(a1 + 32, v20);
      }
    }
    else
    {
LABEL_42:
      char v28 = v14;
    }
    if (v28 != v13)
    {
      uint64_t v30 = (uint64_t **)(a1 + 40);
      do
      {
        CFDictionaryRef v31 = (uint64_t *)operator new(0x28uLL);
        uint64_t v32 = *(void *)((char *)v28 + 28);
        *(uint64_t *)((char *)v31 + 28) = v32;
        int v33 = *v30;
        uint64_t v34 = (uint64_t **)(a1 + 40);
        uint64_t v35 = (uint64_t **)(a1 + 40);
        if (*v30)
        {
          do
          {
            while (1)
            {
              uint64_t v34 = (uint64_t **)v33;
              if (*((_DWORD *)v33 + 7) <= (int)v32) {
                break;
              }
              int v33 = (uint64_t *)*v33;
              uint64_t v35 = v34;
              if (!*v34) {
                goto LABEL_56;
              }
            }
            int v33 = (uint64_t *)v33[1];
          }
          while (v33);
          uint64_t v35 = v34 + 1;
        }
LABEL_56:
        sub_100046C38((uint64_t **)(a1 + 32), (uint64_t)v34, v35, v31);
        CFNumberRef v36 = (void *)v28[1];
        if (v36)
        {
          do
          {
            uint64_t v37 = v36;
            CFNumberRef v36 = (void *)*v36;
          }
          while (v36);
        }
        else
        {
          do
          {
            uint64_t v37 = (void *)v28[2];
            BOOL v9 = *v37 == (void)v28;
            char v28 = v37;
          }
          while (!v9);
        }
        char v28 = v37;
      }
      while (v37 != v13);
    }
  }
  uint64_t v38 = *(void *)(a1 + 24);
  if (v38) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v38 + 48))(v38, a1 + 32);
  }
  return 1;
}

void sub_100A4C0C4(uint64_t a1)
{
  if (capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    unsigned int v28 = *(_DWORD *)(a1 + 88);
    unsigned int v37 = v28;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    uint64_t v34 = &v35;
    subscriber::makeSimSlotRange();
    uint64_t v3 = v31;
    char v2 = v32;
    if (v31 != v32)
    {
      uint64_t v4 = v33;
      while ((v33(*v3) & 1) == 0)
      {
        if (++v3 == v32)
        {
          uint64_t v3 = v32;
          break;
        }
      }
      int v5 = v32;
LABEL_8:
      while (v3 != v5)
      {
        signed int v6 = *v3;
        if (*v3 == v28)
        {
          sub_100058DB0(v29, "");
          sub_100A4DFB8((uint64_t)buf, a1, (uint64_t)v29);
          char v7 = sub_100A4EF3C(a1, (uint64_t)buf, 0);
          if (v40 < 0) {
            operator delete(*(void **)&v39[4]);
          }
          if (v30 < 0) {
            operator delete(v29[0]);
          }
        }
        else
        {
          char v7 = 1;
        }
        int v8 = v35;
        BOOL v9 = &v35;
        unsigned int v10 = &v35;
        if (v35)
        {
          while (1)
          {
            while (1)
            {
              unsigned int v10 = (uint64_t **)v8;
              signed int v11 = *((_DWORD *)v8 + 7);
              if (v11 <= v6) {
                break;
              }
              int v8 = *v10;
              BOOL v9 = v10;
              if (!*v10) {
                goto LABEL_22;
              }
            }
            if (v11 >= v6) {
              break;
            }
            int v8 = v10[1];
            if (!v8)
            {
              BOOL v9 = v10 + 1;
              goto LABEL_22;
            }
          }
        }
        else
        {
LABEL_22:
          unsigned int v12 = operator new(0x28uLL);
          v12[7] = v6;
          *((unsigned char *)v12 + 32) = v7;
          *(void *)unsigned int v12 = 0;
          *((void *)v12 + 1) = 0;
          *((void *)v12 + 2) = v10;
          *BOOL v9 = (uint64_t *)v12;
          if (*v34)
          {
            uint64_t v34 = (uint64_t **)*v34;
            unsigned int v12 = *v9;
          }
          sub_100046C90(v35, (uint64_t *)v12);
          ++v36;
        }
        unsigned __int8 v13 = v3 + 1;
        uint64_t v3 = v2;
        if (v13 != v2)
        {
          uint64_t v3 = v13;
          while ((v4(*v3) & 1) == 0)
          {
            if (++v3 == v2)
            {
              uint64_t v3 = v2;
              goto LABEL_8;
            }
          }
        }
      }
    }
    if (*(void *)(a1 + 304) == v36)
    {
      int v14 = *(void **)(a1 + 288);
      if (v14 == (void *)(a1 + 296)) {
        goto LABEL_63;
      }
      int v15 = v34;
      while (1)
      {
        BOOL v16 = *((_DWORD *)v14 + 7) == *((_DWORD *)v15 + 7)
           && *((unsigned __int8 *)v14 + 32) == *((unsigned __int8 *)v15 + 32);
        if (!v16) {
          break;
        }
        int v17 = (void *)v14[1];
        uint64_t v18 = v14;
        if (v17)
        {
          do
          {
            int v14 = v17;
            int v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            int v14 = (void *)v18[2];
            BOOL v16 = *v14 == (void)v18;
            uint64_t v18 = v14;
          }
          while (!v16);
        }
        uint64_t v19 = v15[1];
        if (v19)
        {
          do
          {
            int v20 = (uint64_t **)v19;
            uint64_t v19 = (uint64_t *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            int v20 = (uint64_t **)v15[2];
            BOOL v16 = *v20 == (uint64_t *)v15;
            int v15 = v20;
          }
          while (!v16);
        }
        int v15 = v20;
        if (v14 == (void *)(a1 + 296)) {
          goto LABEL_63;
        }
      }
    }
    if ((uint64_t ***)(a1 + 288) != &v34) {
      sub_100912880((uint64_t **)(a1 + 288), v34, &v35);
    }
    uint64_t v21 = *(void *)(a1 + 280);
    if (v21) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 48))(v21, a1 + 288);
    }
    if (subscriber::isValidSimSlot())
    {
      int v22 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v28);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)sub_10012EF5C((uint64_t)&v34, (int *)&v37)) {
          __int16 v23 = "'expensive'";
        }
        else {
          __int16 v23 = "'cheap'";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)uint64_t v39 = v23;
        uint64_t v24 = "#I Potential interface cost expensive changed to %s";
        char v25 = v22;
        uint32_t v26 = 12;
        goto LABEL_62;
      }
    }
    else
    {
      char v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v24 = "#I Potential interface cost expensive changed";
        char v25 = v27;
        uint32_t v26 = 2;
LABEL_62:
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
      }
    }
LABEL_63:
    sub_1000346F8((uint64_t)&v34, v35);
  }
}

void sub_100A4C4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
}

void sub_100A4C524(uint64_t a1)
{
  char v2 = *(void **)(a1 + 232);
  uint64_t v3 = (void *)(a1 + 240);
  if (v2 != (void *)(a1 + 240))
  {
    uint64_t v4 = (mach_header_64 *)&_mh_execute_header;
    do
    {
      int v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 7));
      signed int v6 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = rest::asString((rest *)(v2 + 4), v7);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v28 = v8;
        _os_log_impl(v4, v6, OS_LOG_TYPE_DEFAULT, "#I Save data mode: %s", buf, 0xCu);
        signed int v6 = *v5;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        __int16 PersistedLowDataMode_sync = SaveDataModeController::getPersistedLowDataMode_sync(a1, *((unsigned int *)v2 + 7));
        if ((_BYTE)PersistedLowDataMode_sync) {
          unsigned int v10 = "enabled";
        }
        else {
          unsigned int v10 = "disabled";
        }
        if ((PersistedLowDataMode_sync & 0xFF00) != 0) {
          signed int v11 = v10;
        }
        else {
          signed int v11 = "undefined";
        }
        __int16 v12 = sub_100A4B22C(a1, *((unsigned int *)v2 + 7));
        if ((_BYTE)v12) {
          unsigned __int8 v13 = "enabled";
        }
        else {
          unsigned __int8 v13 = "disabled";
        }
        int v14 = v4;
        if ((v12 & 0xFF00) != 0) {
          int v15 = v13;
        }
        else {
          int v15 = "undefined";
        }
        __int16 v16 = sub_100A4B69C(a1, *((unsigned int *)v2 + 7));
        int v17 = "'expensive'";
        if (!(_BYTE)v16) {
          int v17 = "'cheap'";
        }
        *(_DWORD *)long long buf = 136315650;
        uint64_t v28 = (uint64_t)v11;
        if ((v16 & 0xFF00) == 0) {
          int v17 = "'undefined'";
        }
        __int16 v29 = 2080;
        char v30 = v15;
        uint64_t v4 = v14;
        __int16 v31 = 2080;
        uint64_t v32 = v17;
        _os_log_impl(v14, v6, OS_LOG_TYPE_DEFAULT, "#I Persisted values: LDM=%s, SDM=%s, IC=%s", buf, 0x20u);
      }
      uint64_t v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          char v2 = v19;
        }
        while (!v20);
      }
      char v2 = v19;
    }
    while (v19 != v3);
  }
  uint64_t v21 = *(void **)(a1 + 288);
  if (v21 != (void *)(a1 + 296))
  {
    do
    {
      int v22 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v21 + 7));
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)v21 + 32)) {
          __int16 v23 = "'expensive'";
        }
        else {
          __int16 v23 = "'cheap'";
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v28 = (uint64_t)v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Potential interface cost expensive: %s", buf, 0xCu);
      }
      uint64_t v24 = (void *)v21[1];
      if (v24)
      {
        do
        {
          char v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          char v25 = (void *)v21[2];
          BOOL v20 = *v25 == (void)v21;
          uint64_t v21 = v25;
        }
        while (!v20);
      }
      uint64_t v21 = v25;
    }
    while (v25 != (void *)(a1 + 296));
  }
  if (*(void *)(a1 + 616))
  {
    uint32_t v26 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Overridden interface cost timer was scheduled", buf, 2u);
    }
  }
}

uint64_t sub_100A4C884(uint64_t a1, uint64_t a2, __int16 a3)
{
  LOWORD(v3) = a3;
  uint64_t v4 = a2;
  unsigned int v37 = a2;
  signed int v6 = (Registry **)(a1 + 56);
  if (subscriber::isValidSimSlot())
  {
    char v7 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
    unsigned __int16 PersistedLowDataMode_sync = SaveDataModeController::getPersistedLowDataMode_sync(a1, v4);
    uint64_t v9 = (unsigned __int16)v3 & 0xFF00;
    if ((v3 & 0xFF00) != 0 && PersistedLowDataMode_sync >= 0x100u)
    {
      if (v3 != PersistedLowDataMode_sync) {
        goto LABEL_5;
      }
    }
    else if ((v9 != 0) != PersistedLowDataMode_sync > 0xFFu)
    {
LABEL_5:
      unsigned int v10 = *v7;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        signed int v11 = "enabled";
        if (!(_BYTE)v3) {
          signed int v11 = "disabled";
        }
        if ((v3 & 0xFF00) == 0) {
          signed int v11 = "undefined";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Low data mode settings changed to %s", buf, 0xCu);
      }
      __int16 v12 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v4);
      memset(buf, 0, sizeof(buf));
      PersonalityIdFromSlotId();
      if (SHIBYTE(v39) < 0)
      {
        sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        unsigned __int8 v13 = (uint64_t *)SHIBYTE(v39);
        if ((v13 & 0x80000000) != 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)__p;
        unsigned __int8 v13 = v39;
        *(void *)&uint8_t buf[16] = v39;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v13, *v6);
      uint64_t v19 = ServiceMap;
      if (v20 < 0)
      {
        uint64_t v21 = (unsigned __int8 *)(v20 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v22 = 5381;
        do
        {
          uint64_t v20 = v22;
          unsigned int v23 = *v21++;
          uint64_t v22 = (33 * v22) ^ v23;
        }
        while (v23);
      }
      std::mutex::lock(ServiceMap);
      __p[0] = (void *)v20;
      uint64_t v24 = sub_10004D37C(&v19[1].__m_.__sig, (unint64_t *)__p);
      if (v24)
      {
        uint64_t v26 = v24[3];
        char v25 = (std::__shared_weak_count *)v24[4];
        if (v25)
        {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v19);
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v25);
          char v27 = 0;
          if (!v26) {
            goto LABEL_30;
          }
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v26 = 0;
      }
      std::mutex::unlock(v19);
      char v25 = 0;
      char v27 = 1;
      if (!v26)
      {
LABEL_30:
        uint64_t v28 = *v12;
        if (os_log_type_enabled(*v12, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to set low data mode settings", (uint8_t *)__p, 2u);
        }
LABEL_48:
        if ((v27 & 1) == 0) {
          sub_10004D2C8(v25);
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v15 = 1;
        uint64_t v4 = v37;
        goto LABEL_53;
      }
LABEL_34:
      (*(void (**)(uint64_t, uint8_t *, void))(*(void *)v26 + 192))(v26, buf, (unsigned __int16)v3);
      __int16 v29 = *v12;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        char v30 = "enabled";
        uint64_t v3 = v3;
        if (!(_BYTE)v3) {
          char v30 = "disabled";
        }
        if (!v9) {
          char v30 = "undefined";
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = (void *)v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Low data mode settings persisted with value %s", (uint8_t *)__p, 0xCu);
      }
      else
      {
        uint64_t v3 = v3;
      }
      if (v3) {
        BOOL v31 = v9 == 0;
      }
      else {
        BOOL v31 = 1;
      }
      uint64_t v32 = !v31;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 600) + 24))(*(void *)(a1 + 600), v4, v32);
      goto LABEL_48;
    }
    uint64_t v15 = 0;
LABEL_53:
    memset(buf, 0, sizeof(buf));
    sub_100A57770((uint64_t)buf, (void *)(a1 + 232));
    int v33 = sub_100A578EC((uint64_t **)buf, v4, &v37);
    if (v9) {
      BOOL v34 = v3 == 0;
    }
    else {
      BOOL v34 = 1;
    }
    char v35 = !v34;
    *((unsigned char *)v33 + 32) = v35;
    if (sub_100A4BDA8(a1 + 200, buf)) {
      sub_100A4CDD4(a1, v4);
    }
    sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
    return v15;
  }
  int v14 = *(NSObject **)(a1 + 40);
  uint64_t v15 = 0;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v16 = "enabled";
    if (!(_BYTE)v3) {
      __int16 v16 = "disabled";
    }
    if ((v3 & 0xFF00) != 0) {
      int v17 = v16;
    }
    else {
      int v17 = "undefined";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#E Ignoring low data mode settings %s for %s", buf, 0x16u);
    return 0;
  }
  return v15;
}

void sub_100A4CD5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4CDD4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 152);
  if (v2)
  {
    int v3 = a2;
    uint64_t v5 = a1 + 152;
    do
    {
      int v6 = *(_DWORD *)(v2 + 32);
      BOOL v7 = v6 < (int)a2;
      if (v6 >= (int)a2) {
        uint64_t v8 = (uint64_t *)v2;
      }
      else {
        uint64_t v8 = (uint64_t *)(v2 + 8);
      }
      if (!v7) {
        uint64_t v5 = v2;
      }
      uint64_t v2 = *v8;
    }
    while (*v8);
    if (v5 != a1 + 152 && *(_DWORD *)(v5 + 32) <= (int)a2)
    {
      uint64_t v9 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (*(_DWORD *)(v5 + 64) != 2) {
        goto LABEL_22;
      }
      uint64_t v10 = *(void *)(a1 + 240);
      if (!v10) {
        goto LABEL_22;
      }
      uint64_t v11 = a1 + 240;
      do
      {
        int v12 = *(_DWORD *)(v10 + 28);
        BOOL v13 = v12 < v3;
        if (v12 >= v3) {
          int v14 = (uint64_t *)v10;
        }
        else {
          int v14 = (uint64_t *)(v10 + 8);
        }
        if (!v13) {
          uint64_t v11 = v10;
        }
        uint64_t v10 = *v14;
      }
      while (*v14);
      if (v11 != a1 + 240 && *(_DWORD *)(v11 + 28) <= v3) {
        BOOL v15 = *(unsigned __int8 *)(v11 + 32) != 0;
      }
      else {
LABEL_22:
      }
        BOOL v15 = 0;
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v41 = 0;
      if (*(char *)(v5 + 63) < 0)
      {
        sub_10004FC84(__dst, *(void **)(v5 + 40), *(void *)(v5 + 48));
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)(v5 + 40);
        uint64_t v41 = *(void *)(v5 + 56);
      }
      char v16 = HIBYTE(v41);
      if (v41 >= 0) {
        int v17 = (void *)HIBYTE(v41);
      }
      else {
        int v17 = __dst[1];
      }
      uint64_t v18 = *v9;
      BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
      if (!v17)
      {
        if (v19)
        {
          uint64_t v21 = "disabled";
          if (v15) {
            uint64_t v21 = "enabled";
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v21;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E No interface name. Failed to set network interface constraint %s", buf, 0xCu);
        }
        goto LABEL_62;
      }
      if (v19)
      {
        uint64_t v20 = "disabled";
        if (v15) {
          uint64_t v20 = "enabled";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Evaluated interface constraint: %s", buf, 0xCu);
        char v16 = HIBYTE(v41);
      }
      if (v16 < 0)
      {
        sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)__dst;
        uint64_t v39 = v41;
      }
      uint64_t v22 = (void *)HIBYTE(v39);
      int v23 = SHIBYTE(v39);
      if (v39 < 0) {
        uint64_t v22 = __p[1];
      }
      if (!v22)
      {
LABEL_60:
        if (SHIBYTE(v39) < 0) {
          operator delete(__p[0]);
        }
LABEL_62:
        if (SHIBYTE(v41) < 0) {
          operator delete(__dst[0]);
        }
        return;
      }
      uint64_t v24 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = "Disable";
        if (v15) {
          uint64_t v26 = "Enable";
        }
        char v27 = (void **)__p[0];
        if (v23 >= 0) {
          char v27 = __p;
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v26;
        __int16 v43 = 2080;
        __int16 v44 = v27;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I %s network interface constrained for '%s'", buf, 0x16u);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v25, *(Registry **)(a1 + 56));
      __int16 v29 = ServiceMap;
      if (v30 < 0)
      {
        BOOL v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          uint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v30;
      BOOL v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
      if (v34)
      {
        uint64_t v36 = v34[3];
        char v35 = (std::__shared_weak_count *)v34[4];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v29);
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v35);
          char v37 = 0;
          goto LABEL_58;
        }
      }
      else
      {
        uint64_t v36 = 0;
      }
      std::mutex::unlock(v29);
      char v35 = 0;
      char v37 = 1;
LABEL_58:
      (*(void (**)(uint64_t, void **, BOOL))(*(void *)v36 + 16))(v36, __p, v15);
      if ((v37 & 1) == 0) {
        sub_10004D2C8(v35);
      }
      goto LABEL_60;
    }
  }
}

void sub_100A4D1BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SaveDataModeController::getSmartDataMode_sync(capabilities::ct *a1, int a2)
{
  uint64_t result = capabilities::ct::supports5G(a1);
  if (result)
  {
    uint64_t v7 = *((void *)a1 + 30);
    int v6 = (void *)((char *)a1 + 240);
    uint64_t v5 = v7;
    if (!v7) {
      return 0;
    }
    uint64_t v8 = v6;
    do
    {
      int v9 = *(_DWORD *)(v5 + 28);
      BOOL v10 = v9 < a2;
      if (v9 >= a2) {
        uint64_t v11 = (uint64_t *)v5;
      }
      else {
        uint64_t v11 = (uint64_t *)(v5 + 8);
      }
      if (!v10) {
        uint64_t v8 = (void *)v5;
      }
      uint64_t v5 = *v11;
    }
    while (*v11);
    return v8 != v6 && *((_DWORD *)v8 + 7) <= a2 && *((unsigned __int8 *)v8 + 33) != 0;
  }
  return result;
}

uint64_t sub_100A4D298(uint64_t a1, uint64_t a2, unsigned __int16 a3)
{
  int v45 = a2;
  int v6 = (Registry **)(a1 + 56);
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    int v12 = *(NSObject **)(a1 + 40);
    uint64_t v11 = 0;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      return v11;
    }
    BOOL v13 = "enabled";
    if (!(_BYTE)a3) {
      BOOL v13 = "disabled";
    }
    if ((a3 & 0xFF00) != 0) {
      int v14 = v13;
    }
    else {
      int v14 = "undefined";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = subscriber::asString();
    BOOL v15 = "#E Ignoring smart data mode settings %s for %s";
    char v16 = v12;
    uint32_t v17 = 22;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
    return 0;
  }
  uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if ((capabilities::ct::supports5G((capabilities::ct *)v7) & 1) == 0)
  {
    os_log_t v18 = *v7;
    BOOL v19 = os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT);
    uint64_t v11 = 0;
    if (!v19) {
      return v11;
    }
    *(_WORD *)long long buf = 0;
    BOOL v15 = "#I Smart data mode not supported";
    char v16 = v18;
    uint32_t v17 = 2;
    goto LABEL_16;
  }
  int v8 = a3;
  int v9 = HIBYTE(a3);
  unsigned __int16 v10 = sub_100A4B22C(a1, a2);
  if (!HIBYTE(a3) || v10 < 0x100u)
  {
    if ((HIBYTE(a3) != 0) == v10 > 0xFFu) {
      goto LABEL_6;
    }
LABEL_18:
    uint64_t v20 = *v7;
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (v21)
    {
      uint64_t v22 = "enabled";
      if (!(_BYTE)a3) {
        uint64_t v22 = "disabled";
      }
      if ((a3 & 0xFF00) == 0) {
        uint64_t v22 = "undefined";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Smart data mode settings changed to %s", buf, 0xCu);
    }
    if (!capabilities::ct::supports5G((capabilities::ct *)v21)) {
      goto LABEL_53;
    }
    int v23 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    memset(buf, 0, sizeof(buf));
    PersonalityIdFromSlotId();
    if (SHIBYTE(v47) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
      uint64_t v24 = (uint64_t *)SHIBYTE(v47);
      if ((v24 & 0x80000000) != 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)__p;
      uint64_t v24 = v47;
      *(void *)&uint8_t buf[16] = v47;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v24, *v6);
    uint64_t v26 = ServiceMap;
    if (v27 < 0)
    {
      uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        uint64_t v27 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(ServiceMap);
    __p[0] = (void *)v27;
    BOOL v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)__p);
    if (v31)
    {
      uint64_t v33 = v31[3];
      uint64_t v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v26);
    uint64_t v32 = 0;
    char v34 = 1;
LABEL_37:
    if (v33)
    {
      (*(void (**)(uint64_t, uint8_t *, void))(*(void *)v33 + 208))(v33, buf, a3);
      char v35 = *v23;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = "enabled";
        if (!(_BYTE)a3) {
          uint64_t v36 = "disabled";
        }
        if ((a3 & 0xFF00) == 0) {
          uint64_t v36 = "undefined";
        }
        LODWORD(__p[0]) = 136315138;
        *(void **)((char *)__p + 4) = (void *)v36;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Smart data mode settings persisted with value %s", (uint8_t *)__p, 0xCu);
      }
      uint64_t v37 = *(void *)(a1 + 600);
      BOOL v38 = sub_100A4B494(a1, a2);
      if ((a3 & 0xFF00) != 0) {
        uint64_t v39 = a3 != 0;
      }
      else {
        uint64_t v39 = v38;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37 + 32))(v37, a2, v39);
    }
    else
    {
      char v40 = *v23;
      if (os_log_type_enabled(*v23, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to set smart data mode settings", (uint8_t *)__p, 2u);
        if (v34)
        {
LABEL_51:
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
LABEL_53:
          uint64_t v11 = 1;
          goto LABEL_54;
        }
LABEL_50:
        sub_10004D2C8(v32);
        goto LABEL_51;
      }
    }
    if (v34) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  if (a3 != v10) {
    goto LABEL_18;
  }
LABEL_6:
  uint64_t v11 = 0;
LABEL_54:
  memset(buf, 0, sizeof(buf));
  sub_100A57770((uint64_t)buf, (void *)(a1 + 232));
  BOOL v41 = sub_100A4B494(a1, a2);
  __int16 v42 = sub_100A578EC((uint64_t **)buf, v45, &v45);
  BOOL v43 = v8 != 0;
  if (!v9) {
    BOOL v43 = v41;
  }
  *((unsigned char *)v42 + 33) = v43;
  sub_100A4BDA8(a1 + 200, buf);
  sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
  return v11;
}

void sub_100A4D7D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SaveDataModeController::getInterfaceCostExpensive_sync(capabilities::ct *a1, int a2)
{
  if (capabilities::ct::supports5G(a1))
  {
    uint64_t v7 = *((void *)a1 + 30);
    int v6 = (void *)((char *)a1 + 240);
    uint64_t v5 = v7;
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v4 = v6;
    do
    {
      int v8 = *(_DWORD *)(v5 + 28);
      BOOL v9 = v8 < a2;
      if (v8 >= a2) {
        unsigned __int16 v10 = (uint64_t *)v5;
      }
      else {
        unsigned __int16 v10 = (uint64_t *)(v5 + 8);
      }
      if (!v9) {
        uint64_t v4 = (void *)v5;
      }
      uint64_t v5 = *v10;
    }
    while (*v10);
    if (v4 != v6 && *((_DWORD *)v4 + 7) <= a2)
    {
      char v11 = 0;
      LOBYTE(v4) = *((unsigned char *)v4 + 34) != 0;
    }
    else
    {
LABEL_12:
      char v11 = 1;
    }
    char v12 = v11 | v4;
  }
  else
  {
    char v12 = 1;
  }
  return v12 & 1;
}

void sub_100A4D8DC(uint64_t a1, uint64_t a2, unsigned __int16 a3, int a4)
{
  unsigned int v48 = a2;
  int v8 = (Registry **)(a1 + 56);
  if ((subscriber::isValidSimSlot() & 1) == 0)
  {
    BOOL v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v14 = "'expensive'";
    if (!(_BYTE)a3) {
      int v14 = "'cheap'";
    }
    if ((a3 & 0xFF00) != 0) {
      BOOL v15 = v14;
    }
    else {
      BOOL v15 = "'undefined'";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = subscriber::asString();
    char v16 = "#E Ignoring interface cost settings %s for %s";
    uint32_t v17 = v13;
    uint32_t v18 = 22;
    goto LABEL_18;
  }
  BOOL v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if ((capabilities::ct::supports5G((capabilities::ct *)v9) & 1) == 0)
  {
    os_log_t v19 = *v9;
    if (!os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    char v16 = "#I Setting interface cost not supported";
    uint32_t v17 = v19;
    uint32_t v18 = 2;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    return;
  }
  long long v54 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_100058DB0(__p, "");
  sub_100A4DFB8((uint64_t)buf, a1, (uint64_t)__p);
  if (SBYTE7(v46) < 0) {
    operator delete(__p[0]);
  }
  unsigned __int16 v10 = (capabilities::ct *)sub_100A4B69C(a1, a2);
  int v11 = HIBYTE(a3);
  int v12 = a3;
  if (HIBYTE(a3) && (unsigned __int16)v10 >= 0x100u)
  {
    if (a3 == v10) {
      goto LABEL_49;
    }
  }
  else if ((HIBYTE(a3) != 0) == (unsigned __int16)v10 > 0xFFu)
  {
    goto LABEL_49;
  }
  if (!a4)
  {
    uint64_t v22 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Interface expensive settings changed without persisting", (uint8_t *)__p, 2u);
    }
    goto LABEL_49;
  }
  if (capabilities::ct::supports5G(v10))
  {
    uint64_t v20 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v46 = 0;
    PersonalityIdFromSlotId();
    if (SHIBYTE(v56) < 0)
    {
      sub_10004FC84(__p, *(void **)v55, *(unint64_t *)&v55[8]);
      BOOL v21 = (uint64_t *)SHIBYTE(v56);
      if ((v21 & 0x80000000) != 0) {
        operator delete(*(void **)v55);
      }
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)v55;
      BOOL v21 = v56;
      *(void *)&long long v46 = v56;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v21, *v8);
    uint64_t v24 = ServiceMap;
    if (v25 < 0)
    {
      uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v27 = 5381;
      do
      {
        uint64_t v25 = v27;
        unsigned int v28 = *v26++;
        uint64_t v27 = (33 * v27) ^ v28;
      }
      while (v28);
    }
    std::mutex::lock(ServiceMap);
    *(void *)unsigned int v55 = v25;
    uint64_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)v55);
    if (v29)
    {
      uint64_t v31 = v29[3];
      unsigned int v30 = (std::__shared_weak_count *)v29[4];
      if (v30)
      {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v24);
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v30);
        char v32 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v31 = 0;
    }
    std::mutex::unlock(v24);
    unsigned int v30 = 0;
    char v32 = 1;
LABEL_36:
    if (v31)
    {
      (*(void (**)(uint64_t, void **, void))(*(void *)v31 + 240))(v31, __p, a3);
      uint64_t v33 = *v20;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        char v34 = "'expensive'";
        if (!(_BYTE)a3) {
          char v34 = "'cheap'";
        }
        if ((a3 & 0xFF00) == 0) {
          char v34 = "'undefined'";
        }
        *(_DWORD *)unsigned int v55 = 136315138;
        *(void *)&v55[4] = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Interface expensive settings persisted with value %s", v55, 0xCu);
        if (v32) {
          goto LABEL_47;
        }
        goto LABEL_46;
      }
    }
    else
    {
      char v35 = *v20;
      if (os_log_type_enabled(*v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned int v55 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to set interface cost settings", v55, 2u);
        if (v32)
        {
LABEL_47:
          if (SBYTE7(v46) < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_49;
        }
LABEL_46:
        sub_10004D2C8(v30);
        goto LABEL_47;
      }
    }
    if (v32) {
      goto LABEL_47;
    }
    goto LABEL_46;
  }
LABEL_49:
  memset(v55, 0, sizeof(v55));
  uint64_t v56 = 0;
  uint64_t v36 = (uint64_t **)sub_100A57770((uint64_t)v55, (void *)(a1 + 232));
  if (v11) {
    BOOL v37 = v12 == 0;
  }
  else {
    BOOL v37 = 0;
  }
  uint64_t v38 = !v37;
  uint64_t v39 = v48;
  *((unsigned char *)sub_100A578EC(v36, v48, &v48) + 34) = v38;
  if (sub_100A4BDA8(a1 + 200, v55))
  {
    long long v46 = 0u;
    long long v47 = 0u;
    *(_OWORD *)long long __p = 0u;
    sub_100058DB0(v49, "");
    sub_100A4DFB8((uint64_t)__p, a1, (uint64_t)v49);
    if (v52 < 0) {
      operator delete(*(void **)v49);
    }
    int v40 = buf[0];
    int v41 = LOBYTE(__p[0]);
    if (buf[0] != LOBYTE(__p[0]))
    {
      __int16 v42 = *v9;
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v43 = "true";
        if (v40) {
          __int16 v44 = "true";
        }
        else {
          __int16 v44 = "false";
        }
        if (!v41) {
          BOOL v43 = "false";
        }
        *(_DWORD *)CFTypeID v49 = 136315394;
        *(void *)&v49[4] = v44;
        __int16 v50 = 2080;
        int v51 = v43;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Interface expensive settings changed from %s -> %s", v49, 0x16u);
      }
    }
    sub_100A4E5E8(a1, (uint64_t)buf, (uint64_t)__p);
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 600) + 40))(*(void *)(a1 + 600), v39, v38);
    if (SHIBYTE(v46) < 0) {
      operator delete(__p[1]);
    }
  }
  sub_1000346F8((uint64_t)v55, *(void **)&v55[8]);
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_100A4DEDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (*(char *)(v36 - 105) < 0) {
    operator delete(*(void **)(v36 - 128));
  }
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4DFB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v61[0] = 0;
  v61[1] = 0;
  uint64_t v62 = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v61, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v61 = *(_OWORD *)a3;
    uint64_t v62 = *(void *)(a3 + 16);
  }
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(unsigned char *)a1 = 1;
  sub_100058DB0(&__p, "");
  NetworkInterfaceInfo::NetworkInterfaceInfo();
  if ((char)v65 < 0) {
    operator delete(__p);
  }
  *(_DWORD *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(_WORD *)(a1 + 44) = 0;
  int v5 = *(_DWORD *)(a2 + 88);
  *(unsigned char *)a1 = SaveDataModeController::getInterfaceCostExpensive_sync((capabilities::ct *)a2, v5);
  uint64_t v7 = a2 + 104;
  uint64_t v6 = *(void *)(a2 + 104);
  if (!v6) {
    goto LABEL_16;
  }
  uint64_t v8 = a2 + 104;
  do
  {
    int v9 = *(_DWORD *)(v6 + 28);
    BOOL v10 = v9 < v5;
    if (v9 >= v5) {
      int v11 = (uint64_t *)v6;
    }
    else {
      int v11 = (uint64_t *)(v6 + 8);
    }
    if (!v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == v7 || v5 < *(_DWORD *)(v8 + 28)) {
LABEL_16:
  }
    uint64_t v8 = a2 + 104;
  sub_100058DB0(&__p, "/cc/props/in_home_countries_definite");
  if ((v65 & 0x80u) == 0) {
    size_t v12 = v65;
  }
  else {
    size_t v12 = __n;
  }
  BOOL v13 = (void *)HIBYTE(v62);
  if (v62 < 0) {
    BOOL v13 = v61[1];
  }
  if ((void *)v12 == v13)
  {
    if (v62 >= 0) {
      int v14 = v61;
    }
    else {
      int v14 = (void **)v61[0];
    }
    if ((v65 & 0x80) != 0)
    {
      char v16 = __p;
      int v17 = memcmp(__p, v14, __n);
      operator delete(v16);
      if (!v17) {
        goto LABEL_37;
      }
      goto LABEL_35;
    }
    if (!v65) {
      goto LABEL_37;
    }
    uint64_t v15 = 0;
    while (*((unsigned __int8 *)&__p + v15) == *((unsigned __int8 *)v14 + v15))
    {
      if (v65 == ++v15) {
        goto LABEL_37;
      }
    }
  }
  if ((v65 & 0x80) != 0) {
    operator delete(__p);
  }
LABEL_35:
  if (v8 != v7) {
    *(unsigned char *)(a1 + 1) = *(unsigned char *)(v8 + 32);
  }
LABEL_37:
  uint64_t v19 = a2 + 128;
  uint64_t v18 = *(void *)(a2 + 128);
  if (!v18) {
    goto LABEL_47;
  }
  uint64_t v20 = a2 + 128;
  do
  {
    int v21 = *(_DWORD *)(v18 + 28);
    BOOL v22 = v21 < v5;
    if (v21 >= v5) {
      int v23 = (uint64_t *)v18;
    }
    else {
      int v23 = (uint64_t *)(v18 + 8);
    }
    if (!v22) {
      uint64_t v20 = v18;
    }
    uint64_t v18 = *v23;
  }
  while (*v23);
  if (v20 == v19 || v5 < *(_DWORD *)(v20 + 28)) {
LABEL_47:
  }
    uint64_t v20 = a2 + 128;
  sub_100058DB0(&__p, "/cc/props/data_ui_indicators");
  if ((v65 & 0x80u) == 0) {
    size_t v24 = v65;
  }
  else {
    size_t v24 = __n;
  }
  uint64_t v25 = (void *)HIBYTE(v62);
  if (v62 < 0) {
    uint64_t v25 = v61[1];
  }
  if ((void *)v24 == v25)
  {
    if (v62 >= 0) {
      uint64_t v26 = v61;
    }
    else {
      uint64_t v26 = (void **)v61[0];
    }
    if ((v65 & 0x80) != 0)
    {
      unsigned int v28 = __p;
      int v29 = memcmp(__p, v26, __n);
      operator delete(v28);
      if (!v29) {
        goto LABEL_68;
      }
      goto LABEL_66;
    }
    if (!v65) {
      goto LABEL_68;
    }
    uint64_t v27 = 0;
    while (*((unsigned __int8 *)&__p + v27) == *((unsigned __int8 *)v26 + v27))
    {
      if (v65 == ++v27) {
        goto LABEL_68;
      }
    }
  }
  if ((v65 & 0x80) != 0) {
    operator delete(__p);
  }
LABEL_66:
  if (v20 != v19) {
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v20 + 32);
  }
LABEL_68:
  uint64_t v31 = a2 + 152;
  uint64_t v30 = *(void *)(a2 + 152);
  if (!v30) {
    goto LABEL_78;
  }
  uint64_t v32 = a2 + 152;
  do
  {
    int v33 = *(_DWORD *)(v30 + 32);
    BOOL v34 = v33 < v5;
    if (v33 >= v5) {
      char v35 = (uint64_t *)v30;
    }
    else {
      char v35 = (uint64_t *)(v30 + 8);
    }
    if (!v34) {
      uint64_t v32 = v30;
    }
    uint64_t v30 = *v35;
  }
  while (*v35);
  if (v32 == v31 || v5 < *(_DWORD *)(v32 + 32)) {
LABEL_78:
  }
    uint64_t v32 = a2 + 152;
  sub_100058DB0(&__p, "/cc/props/internal_internet_connection_state");
  if ((v65 & 0x80u) == 0) {
    size_t v36 = v65;
  }
  else {
    size_t v36 = __n;
  }
  BOOL v37 = (void *)HIBYTE(v62);
  if (v62 < 0) {
    BOOL v37 = v61[1];
  }
  if ((void *)v36 == v37)
  {
    if (v62 >= 0) {
      uint64_t v38 = v61;
    }
    else {
      uint64_t v38 = (void **)v61[0];
    }
    if ((v65 & 0x80) != 0)
    {
      int v40 = __p;
      int v41 = memcmp(__p, v38, __n);
      operator delete(v40);
      if (!v41) {
        goto LABEL_99;
      }
      goto LABEL_97;
    }
    if (!v65) {
      goto LABEL_99;
    }
    uint64_t v39 = 0;
    while (*((unsigned __int8 *)&__p + v39) == *((unsigned __int8 *)v38 + v39))
    {
      if (v65 == ++v39) {
        goto LABEL_99;
      }
    }
  }
  if ((v65 & 0x80) != 0) {
    operator delete(__p);
  }
LABEL_97:
  if (v32 != v31)
  {
    std::string::operator=((std::string *)(a1 + 8), (const std::string *)(v32 + 40));
    int v42 = *(_DWORD *)(v32 + 64);
    *(_WORD *)(a1 + 36) = *(_WORD *)(v32 + 68);
    *(_DWORD *)(a1 + 32) = v42;
  }
LABEL_99:
  sub_100058DB0(&__p, "/cc/props/internet_interface_cost");
  if ((v65 & 0x80u) == 0) {
    size_t v43 = v65;
  }
  else {
    size_t v43 = __n;
  }
  __int16 v44 = (void *)HIBYTE(v62);
  if (v62 < 0) {
    __int16 v44 = v61[1];
  }
  if ((void *)v43 == v44)
  {
    if (v62 >= 0) {
      int v45 = v61;
    }
    else {
      int v45 = (void **)v61[0];
    }
    if ((v65 & 0x80) != 0)
    {
      long long v47 = __p;
      int v48 = memcmp(__p, v45, __n);
      operator delete(v47);
      if (!v48) {
        goto LABEL_119;
      }
      goto LABEL_117;
    }
    if (!v65) {
      goto LABEL_119;
    }
    uint64_t v46 = 0;
    while (*((unsigned __int8 *)&__p + v46) == *((unsigned __int8 *)v45 + v46))
    {
      if (v65 == ++v46) {
        goto LABEL_119;
      }
    }
  }
  if ((v65 & 0x80) != 0) {
    operator delete(__p);
  }
LABEL_117:
  if (*(_DWORD *)(a2 + 172) == *(_DWORD *)(a2 + 88)) {
    *(_DWORD *)(a1 + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(_DWORD *)(a2 + 168);
  }
LABEL_119:
  uint64_t v50 = a2 + 184;
  uint64_t v49 = *(void *)(a2 + 184);
  if (!v49) {
    goto LABEL_129;
  }
  uint64_t v51 = a2 + 184;
  do
  {
    int v52 = *(_DWORD *)(v49 + 28);
    BOOL v53 = v52 < v5;
    if (v52 >= v5) {
      long long v54 = (uint64_t *)v49;
    }
    else {
      long long v54 = (uint64_t *)(v49 + 8);
    }
    if (!v53) {
      uint64_t v51 = v49;
    }
    uint64_t v49 = *v54;
  }
  while (*v54);
  if (v51 == v50 || v5 < *(_DWORD *)(v51 + 28)) {
LABEL_129:
  }
    uint64_t v51 = a2 + 184;
  sub_100058DB0(&__p, "/cc/props/private_network_sims_active");
  if ((v65 & 0x80u) == 0) {
    size_t v55 = v65;
  }
  else {
    size_t v55 = __n;
  }
  uint64_t v56 = (void *)HIBYTE(v62);
  if (v62 < 0) {
    uint64_t v56 = v61[1];
  }
  if ((void *)v55 == v56)
  {
    if (v62 >= 0) {
      uint64_t v57 = v61;
    }
    else {
      uint64_t v57 = (void **)v61[0];
    }
    if ((v65 & 0x80) != 0)
    {
      unsigned int v59 = __p;
      int v60 = memcmp(__p, v57, __n);
      operator delete(v59);
      if (!v60) {
        goto LABEL_150;
      }
      goto LABEL_148;
    }
    if (!v65) {
      goto LABEL_150;
    }
    uint64_t v58 = 0;
    while (*((unsigned __int8 *)&__p + v58) == *((unsigned __int8 *)v57 + v58))
    {
      if (v65 == ++v58) {
        goto LABEL_150;
      }
    }
  }
  if ((v65 & 0x80) != 0) {
    operator delete(__p);
  }
LABEL_148:
  if (v51 != v50) {
    *(unsigned char *)(a1 + 44) = *(unsigned char *)(v51 + 32);
  }
LABEL_150:
  *(unsigned char *)(a1 + 45) = *(void *)(a2 + 616) != 0;
  if (SHIBYTE(v62) < 0) {
    operator delete(v61[0]);
  }
}

void sub_100A4E590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (*(char *)(v20 + 31) < 0) {
    operator delete(*v21);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4E5E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_100A4C0C4(a1);
  int v6 = sub_100A4EF3C(a1, a2, 1);
  uint64_t v7 = sub_100A4EF3C(a1, a3, 1);
  if (v6 != v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a1 + 152);
    memset(&v52, 0, sizeof(v52));
    if (!v9) {
      goto LABEL_24;
    }
    int v10 = *(_DWORD *)(a1 + 88);
    uint64_t v11 = a1 + 152;
    do
    {
      int v12 = *(_DWORD *)(v9 + 32);
      BOOL v13 = v12 < v10;
      if (v12 >= v10) {
        int v14 = (uint64_t *)v9;
      }
      else {
        int v14 = (uint64_t *)(v9 + 8);
      }
      if (!v13) {
        uint64_t v11 = v9;
      }
      uint64_t v9 = *v14;
    }
    while (*v14);
    if (v11 == a1 + 152 || v10 < *(_DWORD *)(v11 + 32)) {
      goto LABEL_24;
    }
    std::string::operator=(&v52, (const std::string *)(v11 + 40));
    std::string::size_type size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v52.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      char v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = subscriber::asString();
        uint64_t v18 = "'cheap'";
        if (v6) {
          uint64_t v19 = "'expensive'";
        }
        else {
          uint64_t v19 = "'cheap'";
        }
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v19;
        if (v8) {
          uint64_t v18 = "'expensive'";
        }
        *(_WORD *)&unsigned char buf[22] = 2080;
        long long v54 = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Evaluated interface cost for %s changed from %s -> %s", buf, 0x20u);
      }
      std::string __p = v52;
      memset(&v52, 0, sizeof(v52));
      sub_100A4EA80(a1, (uint64_t *)&__p, v8);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
LABEL_24:
      int v21 = *(NSObject **)(a1 + 40);
      BOOL v20 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        BOOL v22 = "'cheap'";
        if (v8) {
          BOOL v22 = "'expensive'";
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#E No interface name. Failed to set interface cost %s", buf, 0xCu);
      }
    }
    int v23 = (capabilities::ct *)capabilities::ct::supports5GSlicing((capabilities::ct *)v20);
    if (v23)
    {
      memset(buf, 0, sizeof(buf));
      if (!capabilities::ct::supports5GSlicing(v23)) {
        goto LABEL_70;
      }
      uint64_t v24 = *(void *)(a1 + 584);
      if (!v24) {
        goto LABEL_70;
      }
      int v25 = *(_DWORD *)(a1 + 88);
      uint64_t v26 = a1 + 584;
      do
      {
        int v27 = *(_DWORD *)(v24 + 32);
        BOOL v28 = v27 < v25;
        if (v27 >= v25) {
          int v29 = (uint64_t *)v24;
        }
        else {
          int v29 = (uint64_t *)(v24 + 8);
        }
        if (!v28) {
          uint64_t v26 = v24;
        }
        uint64_t v24 = *v29;
      }
      while (*v29);
      if (v26 == a1 + 584
        || v25 < *(_DWORD *)(v26 + 32)
        || (v30 = *(void **)(v26 + 40), uint64_t v31 = (void *)(v26 + 48), v30 == (void *)(v26 + 48)))
      {
LABEL_70:
        uint64_t v32 = 0;
      }
      else
      {
        uint64_t v32 = 0;
        unint64_t v33 = 0;
        BOOL v34 = 0;
        do
        {
          if (isSlice())
          {
            char v35 = (long long *)(v30 + 5);
            if ((unint64_t)v34 >= v33)
            {
              unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((v34 - v32) >> 4) + 1;
              if (v38 > 0x555555555555555)
              {
                *(void *)long long buf = v32;
                sub_10006A748();
              }
              if (0x5555555555555556 * ((uint64_t)(v33 - (void)v32) >> 4) > v38) {
                unint64_t v38 = 0x5555555555555556 * ((uint64_t)(v33 - (void)v32) >> 4);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v33 - (void)v32) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                unint64_t v39 = 0x555555555555555;
              }
              else {
                unint64_t v39 = v38;
              }
              if (v39) {
                unint64_t v39 = (unint64_t)sub_100A52878(v39);
              }
              else {
                uint64_t v40 = 0;
              }
              int v41 = (_OWORD *)(v39 + 16 * ((v34 - v32) >> 4));
              long long v42 = *v35;
              long long v43 = *(_OWORD *)(v30 + 9);
              v41[1] = *(_OWORD *)(v30 + 7);
              v41[2] = v43;
              _OWORD *v41 = v42;
              if (v34 == v32)
              {
                long long v47 = (char *)(v39 + 16 * ((v34 - v32) >> 4));
              }
              else
              {
                unint64_t v44 = v39 + 16 * ((v34 - v32) >> 4);
                do
                {
                  long long v45 = *((_OWORD *)v34 - 3);
                  long long v46 = *((_OWORD *)v34 - 1);
                  long long v47 = (char *)(v44 - 48);
                  *(_OWORD *)(v44 - 32) = *((_OWORD *)v34 - 2);
                  *(_OWORD *)(v44 - 16) = v46;
                  *(_OWORD *)(v44 - 48) = v45;
                  v34 -= 48;
                  v44 -= 48;
                }
                while (v34 != v32);
              }
              unint64_t v33 = v39 + 48 * v40;
              BOOL v34 = (char *)(v41 + 3);
              *(void *)&uint8_t buf[8] = v41 + 3;
              *(void *)&uint8_t buf[16] = v33;
              if (v32) {
                operator delete(v32);
              }
              uint64_t v32 = v47;
            }
            else
            {
              long long v36 = *v35;
              long long v37 = *(_OWORD *)(v30 + 9);
              *((_OWORD *)v34 + 1) = *(_OWORD *)(v30 + 7);
              *((_OWORD *)v34 + 2) = v37;
              *(_OWORD *)BOOL v34 = v36;
              v34 += 48;
            }
            *(void *)&uint8_t buf[8] = v34;
          }
          int v48 = (void *)v30[1];
          if (v48)
          {
            do
            {
              uint64_t v49 = v48;
              int v48 = (void *)*v48;
            }
            while (v48);
          }
          else
          {
            do
            {
              uint64_t v49 = (void *)v30[2];
              BOOL v50 = *v49 == (void)v30;
              uint64_t v30 = v49;
            }
            while (!v50);
          }
          uint64_t v30 = v49;
        }
        while (v49 != v31);
        *(void *)long long buf = v32;
      }
      sub_100A4F004(a1, a3, (int **)buf);
      if (v32)
      {
        *(void *)&uint8_t buf[8] = v32;
        operator delete(v32);
      }
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100A4EA24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4EA80(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  char v6 = *((unsigned char *)a2 + 23);
  if (v6 < 0)
  {
    if (!a2[1]) {
      return;
    }
  }
  else if (!*((unsigned char *)a2 + 23))
  {
    return;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a2;
    if (v6 < 0) {
      uint64_t v9 = (uint64_t *)*a2;
    }
    int v10 = "'cheap'";
    if (a3) {
      int v10 = "'expensive'";
    }
    *(_DWORD *)int v21 = 136315394;
    *(void *)&v21[4] = v9;
    __int16 v22 = 2080;
    int v23 = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Setting interface cost for %s to %s", v21, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)(a1 + 56));
  int v12 = ServiceMap;
  if (v13 < 0)
  {
    int v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v15 = 5381;
    do
    {
      uint64_t v13 = v15;
      unsigned int v16 = *v14++;
      uint64_t v15 = (33 * v15) ^ v16;
    }
    while (v16);
  }
  std::mutex::lock(ServiceMap);
  *(void *)int v21 = v13;
  uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v21);
  if (v17)
  {
    uint64_t v19 = v17[3];
    uint64_t v18 = (std::__shared_weak_count *)v17[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v12);
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      char v20 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  std::mutex::unlock(v12);
  uint64_t v18 = 0;
  char v20 = 1;
LABEL_19:
  (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v19 + 32))(v19, a2, a3);
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
}

void sub_100A4EC60(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL SaveDataModeController::isHighDataModeSupported_sync@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *(Registry **)(a1 + 56));
  char v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&cf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    int v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_19;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  int v12 = 0;
  char v14 = 1;
  if (!v13) {
    goto LABEL_19;
  }
LABEL_10:
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v13 + 16))(v13)) {
    goto LABEL_19;
  }
  unsigned int v16 = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(a1 + 56));
  uint64_t v17 = v16;
  if (v18 < 0)
  {
    uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v20 = 5381;
    do
    {
      uint64_t v18 = v20;
      unsigned int v21 = *v19++;
      uint64_t v20 = (33 * v20) ^ v21;
    }
    while (v21);
  }
  std::mutex::lock(v16);
  CFTypeRef cf = (CFTypeRef)v18;
  __int16 v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&cf);
  if (!v22)
  {
    std::mutex::unlock(v17);
    goto LABEL_19;
  }
  uint64_t v24 = v22[3];
  int v23 = (std::__shared_weak_count *)v22[4];
  if (!v23)
  {
    std::mutex::unlock(v17);
    if (v24) {
      goto LABEL_24;
    }
LABEL_19:
    BOOL v25 = 0;
    goto LABEL_20;
  }
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v17);
  atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v23);
  if (!v24)
  {
    BOOL v25 = 0;
LABEL_29:
    sub_10004D2C8(v23);
    goto LABEL_20;
  }
LABEL_24:
  BOOL v25 = 1;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v24 + 96))(&cf, v24, a2, 1, @"ShowHighDataModeSwitch", 0, 0);
  int v27 = (BOOL *)cf;
  char v30 = 1;
  if (cf)
  {
    CFTypeID v28 = CFGetTypeID(cf);
    if (v28 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v30, v27, v29);
      BOOL v25 = v30 != 0;
    }
    else
    {
      BOOL v25 = 1;
    }
  }
  sub_1000577C4(&cf);
  if (v23) {
    goto LABEL_29;
  }
LABEL_20:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  return v25;
}

void sub_100A4EEF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A4EF3C(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 && *(_DWORD *)(a2 + 32) != 2) {
    return 1;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 88);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
  if (*(_DWORD *)(a2 + 40) == 2 || *(unsigned char *)(a2 + 44) != 0 || *(unsigned char *)(a2 + 45) != 0) {
    return 0;
  }
  uint64_t result = 1;
  if (!*(unsigned char *)a2 && *(unsigned char *)(a2 + 1))
  {
    if (!SaveDataModeController::isHighDataModeSupported_sync(a1, v6, (uint64_t *)*(unsigned __int8 *)(a2 + 1))) {
      return 1;
    }
    return DataUtils::is5gOrBetterIndicator((DataUtils *)*(unsigned int *)(a2 + 4), v9) ^ 1;
  }
  return result;
}

void sub_100A4F004(uint64_t a1, uint64_t a2, int **a3)
{
  unsigned int v5 = sub_100A4EF3C(a1, a2, 0);
  uint64_t v6 = *a3;
  uint64_t v7 = a3[1];
  if (*a3 != v7)
  {
    unsigned int v8 = v5;
    do
    {
      if ((*v6 & 0x80000000) == 0)
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v19 = 0;
        CSIPDPManager::getInterfaceNameById();
        int v9 = (void *)HIBYTE(v19);
        int v10 = SHIBYTE(v19);
        if (v19 < 0) {
          int v9 = __p[1];
        }
        if (v9)
        {
          if ((v6[1] - 3) < 0xFFFFFFFE) {
            uint64_t v11 = 1;
          }
          else {
            uint64_t v11 = v8;
          }
          char v12 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = (void **)__p[0];
            uint64_t v14 = asStringBool(v11);
            *(_DWORD *)long long buf = 136315394;
            uint64_t v15 = __p;
            if (v10 < 0) {
              uint64_t v15 = v13;
            }
            *(void *)&uint8_t buf[4] = v15;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v14;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Slice interface name: %s (cs), expensive: %s", buf, 0x16u);
            LOBYTE(v1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = HIBYTE(v19);
          }
          if ((v10 & 0x80) != 0)
          {
            sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)__p;
            *(void *)&uint8_t buf[16] = v19;
          }
          sub_100A4EA80(a1, (uint64_t *)buf, v11);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }
        else
        {
          unsigned int v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            int v17 = *v6;
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#E No slice interface name for pdp %d (cs)", buf, 8u);
          }
        }
        if (SHIBYTE(v19) < 0) {
          operator delete(__p[0]);
        }
      }
      v6 += 12;
    }
    while (v6 != v7);
  }
}

void sub_100A4F208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4F240(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::supports5GSlicing((capabilities::ct *)a1))
  {
    CFNumberRef v73 = 0;
    CFNumberRef v74 = 0;
    unint64_t v75 = 0;
    uint64_t v4 = *(void *)(a1 + 584);
    if (v4)
    {
      int v5 = *(_DWORD *)(a1 + 88);
      uint64_t v6 = a1 + 584;
      do
      {
        int v7 = *(_DWORD *)(v4 + 32);
        BOOL v8 = v7 < v5;
        if (v7 >= v5) {
          int v9 = (uint64_t *)v4;
        }
        else {
          int v9 = (uint64_t *)(v4 + 8);
        }
        if (!v8) {
          uint64_t v6 = v4;
        }
        uint64_t v4 = *v9;
      }
      while (*v9);
      if (v6 != a1 + 584 && v5 >= *(_DWORD *)(v6 + 32))
      {
        uint64_t v12 = *(void *)(a2 + 8);
        uint64_t v11 = a2 + 8;
        uint64_t v10 = v12;
        if (!v12) {
          goto LABEL_22;
        }
        uint64_t v13 = v11;
        do
        {
          int v14 = *(_DWORD *)(v10 + 32);
          BOOL v15 = v14 < v5;
          if (v14 >= v5) {
            unsigned int v16 = (uint64_t *)v10;
          }
          else {
            unsigned int v16 = (uint64_t *)(v10 + 8);
          }
          if (!v15) {
            uint64_t v13 = v10;
          }
          uint64_t v10 = *v16;
        }
        while (*v16);
        if (v13 != v11 && v5 >= *(_DWORD *)(v13 + 32))
        {
          unint64_t v38 = *(void **)(v6 + 40);
          unint64_t v39 = (void *)(v6 + 48);
          if (v38 == (void *)(v6 + 48)) {
            return;
          }
          uint64_t v19 = 0;
          unint64_t v40 = 0;
          unsigned int v21 = 0;
          int v41 = (void *)(v13 + 48);
          do
          {
            if (isSlice())
            {
              long long v42 = v38 + 5;
              uint64_t v43 = *v41;
              if (!*v41) {
                goto LABEL_90;
              }
              int v44 = *((_DWORD *)v38 + 8);
              long long v45 = v41;
              do
              {
                int v46 = *(_DWORD *)(v43 + 32);
                BOOL v47 = v46 < v44;
                if (v46 >= v44) {
                  int v48 = (uint64_t *)v43;
                }
                else {
                  int v48 = (uint64_t *)(v43 + 8);
                }
                if (!v47) {
                  long long v45 = (void *)v43;
                }
                uint64_t v43 = *v48;
              }
              while (*v48);
              if (v45 == v41
                || v44 < *((_DWORD *)v45 + 8)
                || *((_DWORD *)v45 + 10) != *v42
                || *((_DWORD *)v45 + 11) != *((_DWORD *)v38 + 11))
              {
                goto LABEL_90;
              }
              uint64_t v49 = 0;
              BOOL v50 = v38 + 6;
              do
              {
                BOOL v51 = LODWORD(v45[v49 + 6]) == LODWORD(v50[v49]) && v45[v49 + 7] == v50[v49 + 1];
                int v52 = v51;
                BOOL v53 = v52 != 1 || v49 == 2;
                v49 += 2;
              }
              while (!v53);
              if (!v52
                || *((unsigned __int8 *)v45 + 80) != *((unsigned __int8 *)v38 + 80)
                || *((_DWORD *)v45 + 21) != *((_DWORD *)v38 + 21))
              {
LABEL_90:
                if ((unint64_t)v21 >= v40)
                {
                  unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v19) >> 4) + 1;
                  if (v56 > 0x555555555555555) {
                    sub_10006A748();
                  }
                  if (0x5555555555555556 * ((uint64_t)(v40 - (void)v19) >> 4) > v56) {
                    unint64_t v56 = 0x5555555555555556 * ((uint64_t)(v40 - (void)v19) >> 4);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v40 - (void)v19) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                    unint64_t v57 = 0x555555555555555;
                  }
                  else {
                    unint64_t v57 = v56;
                  }
                  if (v57) {
                    unint64_t v57 = (unint64_t)sub_100A52878(v57);
                  }
                  else {
                    uint64_t v58 = 0;
                  }
                  unsigned int v59 = (_OWORD *)(v57 + 16 * ((v21 - v19) >> 4));
                  long long v60 = *(_OWORD *)v42;
                  long long v61 = *(_OWORD *)(v38 + 9);
                  v59[1] = *(_OWORD *)(v38 + 7);
                  v59[2] = v61;
                  *unsigned int v59 = v60;
                  if (v21 == v19)
                  {
                    unsigned __int8 v65 = (int *)(v57 + 16 * ((v21 - v19) >> 4));
                  }
                  else
                  {
                    unint64_t v62 = v57 + 16 * ((v21 - v19) >> 4);
                    do
                    {
                      long long v63 = *((_OWORD *)v21 - 3);
                      long long v64 = *((_OWORD *)v21 - 1);
                      unsigned __int8 v65 = (int *)(v62 - 48);
                      *(_OWORD *)(v62 - 32) = *((_OWORD *)v21 - 2);
                      *(_OWORD *)(v62 - 16) = v64;
                      *(_OWORD *)(v62 - 48) = v63;
                      v21 -= 48;
                      v62 -= 48;
                    }
                    while (v21 != v19);
                  }
                  unint64_t v40 = v57 + 48 * v58;
                  unsigned int v21 = (char *)(v59 + 3);
                  CFNumberRef v73 = v65;
                  unint64_t v75 = v40;
                  if (v19) {
                    operator delete(v19);
                  }
                  uint64_t v19 = (char *)v65;
                }
                else
                {
                  long long v54 = *(_OWORD *)v42;
                  long long v55 = *(_OWORD *)(v38 + 9);
                  *((_OWORD *)v21 + 1) = *(_OWORD *)(v38 + 7);
                  *((_OWORD *)v21 + 2) = v55;
                  *(_OWORD *)unsigned int v21 = v54;
                  v21 += 48;
                }
                CFNumberRef v74 = v21;
              }
            }
            CFNumberRef v66 = (void *)v38[1];
            if (v66)
            {
              do
              {
                CFTypeRef v67 = v66;
                CFNumberRef v66 = (void *)*v66;
              }
              while (v66);
            }
            else
            {
              do
              {
                CFTypeRef v67 = (void *)v38[2];
                BOOL v51 = *v67 == (void)v38;
                unint64_t v38 = v67;
              }
              while (!v51);
            }
            unint64_t v38 = v67;
          }
          while (v67 != v39);
        }
        else
        {
LABEL_22:
          int v17 = *(void **)(v6 + 40);
          uint64_t v18 = (void *)(v6 + 48);
          if (v17 == (void *)(v6 + 48)) {
            return;
          }
          uint64_t v19 = 0;
          unint64_t v20 = 0;
          unsigned int v21 = 0;
          __int16 v22 = v74;
          do
          {
            if (isSlice())
            {
              int v23 = (long long *)(v17 + 5);
              if ((unint64_t)v21 >= v20)
              {
                unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v21 - v19) >> 4) + 1;
                if (v26 > 0x555555555555555)
                {
                  CFNumberRef v73 = (int *)v19;
                  CFNumberRef v74 = v22;
                  sub_10006A748();
                }
                if (0x5555555555555556 * ((uint64_t)(v20 - (void)v19) >> 4) > v26) {
                  unint64_t v26 = 0x5555555555555556 * ((uint64_t)(v20 - (void)v19) >> 4);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - (void)v19) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v27 = 0x555555555555555;
                }
                else {
                  unint64_t v27 = v26;
                }
                if (v27) {
                  unint64_t v27 = (unint64_t)sub_100A52878(v27);
                }
                else {
                  uint64_t v28 = 0;
                }
                CFBooleanRef v29 = (_OWORD *)(v27 + 16 * ((v21 - v19) >> 4));
                long long v30 = *v23;
                long long v31 = *(_OWORD *)(v17 + 9);
                v29[1] = *(_OWORD *)(v17 + 7);
                CFTypeRef v29[2] = v31;
                *CFBooleanRef v29 = v30;
                if (v21 == v19)
                {
                  char v35 = (char *)(v27 + 16 * ((v21 - v19) >> 4));
                }
                else
                {
                  unint64_t v32 = v27 + 16 * ((v21 - v19) >> 4);
                  do
                  {
                    long long v33 = *((_OWORD *)v21 - 3);
                    long long v34 = *((_OWORD *)v21 - 1);
                    char v35 = (char *)(v32 - 48);
                    *(_OWORD *)(v32 - 32) = *((_OWORD *)v21 - 2);
                    *(_OWORD *)(v32 - 16) = v34;
                    *(_OWORD *)(v32 - 48) = v33;
                    v21 -= 48;
                    v32 -= 48;
                  }
                  while (v21 != v19);
                }
                unint64_t v20 = v27 + 48 * v28;
                __int16 v22 = (char *)(v29 + 3);
                unint64_t v75 = v20;
                if (v19) {
                  operator delete(v19);
                }
                uint64_t v19 = v35;
              }
              else
              {
                long long v24 = *v23;
                long long v25 = *(_OWORD *)(v17 + 9);
                *((_OWORD *)v21 + 1) = *(_OWORD *)(v17 + 7);
                *((_OWORD *)v21 + 2) = v25;
                *(_OWORD *)unsigned int v21 = v24;
                __int16 v22 = v21 + 48;
              }
              unsigned int v21 = v22;
            }
            long long v36 = (void *)v17[1];
            if (v36)
            {
              do
              {
                long long v37 = v36;
                long long v36 = (void *)*v36;
              }
              while (v36);
            }
            else
            {
              do
              {
                long long v37 = (void *)v17[2];
                BOOL v51 = *v37 == (void)v17;
                int v17 = v37;
              }
              while (!v51);
            }
            int v17 = v37;
          }
          while (v37 != v18);
          CFNumberRef v73 = (int *)v19;
          CFNumberRef v74 = v22;
        }
        if (v19 != v21)
        {
          long long v71 = 0u;
          long long v72 = 0u;
          *(_OWORD *)uint64_t v70 = 0u;
          sub_100058DB0(__p, "");
          sub_100A4DFB8((uint64_t)v70, a1, (uint64_t)__p);
          if (v69 < 0) {
            operator delete(__p[0]);
          }
          sub_100A4F004(a1, (uint64_t)v70, &v73);
          if (SHIBYTE(v71) < 0) {
            operator delete(v70[1]);
          }
        }
        if (v19)
        {
          CFNumberRef v74 = v19;
          operator delete(v19);
        }
      }
    }
  }
}

void sub_100A4F724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (v27) {
    operator delete(v27);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A4F780(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 112))
  {
    uint64_t v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    int v5 = *(void **)(a1 + 96);
    while (1)
    {
      BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7) && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
      if (!v6) {
        break;
      }
      int v7 = (void *)v4[1];
      BOOL v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v6 = *v4 == (void)v8;
          BOOL v8 = v4;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          int v5 = v10;
        }
        while (!v6);
      }
      int v5 = v10;
      if (v4 == a2 + 1) {
        return;
      }
    }
  }
  int v32 = *(_DWORD *)(a1 + 88);
  sub_10005DF14(&v33, (uint64_t)a2);
  uint64_t v11 = *(void **)(a1 + 96);
  if (v11 != (void *)(a1 + 104))
  {
    uint64_t v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v11 + 7);
      if (!*v12) {
        goto LABEL_34;
      }
      BOOL v15 = a2 + 1;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          uint64_t v18 = (uint64_t *)v13;
        }
        else {
          uint64_t v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          BOOL v15 = (uint64_t *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12
        || (int)v14 < *((_DWORD *)v15 + 7)
        || *((unsigned __int8 *)v15 + 32) != *((unsigned __int8 *)v11 + 32))
      {
LABEL_34:
        if (v32 == v14)
        {
          long long v39 = 0u;
          long long v40 = 0u;
          *(_OWORD *)unint64_t v38 = 0u;
          sub_100058DB0(__p, "");
          sub_100A4DFB8((uint64_t)v38, a1, (uint64_t)__p);
          if (SBYTE7(v36) < 0) {
            operator delete(__p[0]);
          }
          long long v36 = 0u;
          long long v37 = 0u;
          *(_OWORD *)std::string __p = 0u;
          sub_100058DB0(buf, "/cc/props/in_home_countries_definite");
          sub_100A4DFB8((uint64_t)__p, a1, (uint64_t)buf);
          if (v44 < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v19 = v34[0];
          if (v34[0])
          {
            unint64_t v20 = v34;
            do
            {
              unsigned int v21 = v19;
              __int16 v22 = v20;
              int v23 = *((_DWORD *)v19 + 7);
              long long v24 = v19 + 1;
              if (v23 >= (int)v14)
              {
                long long v24 = v21;
                unint64_t v20 = (void **)v21;
              }
              uint64_t v19 = (void *)*v24;
            }
            while (v19);
            if (v20 != v34)
            {
              long long v25 = v23 >= (int)v14 ? v21 : v22;
              if (*((_DWORD *)v25 + 7) <= (int)v14)
              {
                if (v23 < (int)v14) {
                  unsigned int v21 = v22;
                }
                BYTE1(__p[0]) = *((unsigned char *)v21 + 32);
              }
            }
          }
          if (BYTE1(__p[0]) != BYTE1(v38[0]))
          {
            unint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              if (BYTE1(__p[0])) {
                unint64_t v27 = "true";
              }
              else {
                unint64_t v27 = "false";
              }
              if (BYTE1(v38[0])) {
                uint64_t v28 = "true";
              }
              else {
                uint64_t v28 = "false";
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v27;
              __int16 v42 = 2080;
              uint64_t v43 = v28;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I InHomeCountry changed from %s -> %s", buf, 0x16u);
            }
            sub_100A4E5E8(a1, (uint64_t)__p, (uint64_t)v38);
          }
          if (SHIBYTE(v36) < 0) {
            operator delete(__p[1]);
          }
          if (SHIBYTE(v39) < 0) {
            operator delete(v38[1]);
          }
        }
      }
      CFBooleanRef v29 = (void *)v11[1];
      if (v29)
      {
        do
        {
          long long v30 = v29;
          CFBooleanRef v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          long long v30 = (void *)v11[2];
          BOOL v6 = *v30 == (void)v11;
          uint64_t v11 = v30;
        }
        while (!v6);
      }
      uint64_t v11 = v30;
    }
    while (v30 != (void *)(a1 + 104));
  }
  sub_1000346F8((uint64_t)&v33, v34[0]);
}

void sub_100A4FB54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

void sub_100A4FBD0(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 136))
  {
    uint64_t v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    int v5 = *(void **)(a1 + 120);
    while (1)
    {
      BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7) && *((_DWORD *)v4 + 8) == *((_DWORD *)v5 + 8);
      if (!v6) {
        break;
      }
      int v7 = (void *)v4[1];
      BOOL v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v6 = *v4 == (void)v8;
          BOOL v8 = v4;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          int v5 = v10;
        }
        while (!v6);
      }
      int v5 = v10;
      if (v4 == a2 + 1) {
        return;
      }
    }
  }
  int v32 = *(_DWORD *)(a1 + 88);
  sub_100A579C0(&v33, (uint64_t)a2);
  uint64_t v11 = *(void **)(a1 + 120);
  if (v11 != (void *)(a1 + 128))
  {
    uint64_t v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v11 + 7);
      if (!*v12) {
        goto LABEL_34;
      }
      BOOL v15 = a2 + 1;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          uint64_t v18 = (uint64_t *)v13;
        }
        else {
          uint64_t v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          BOOL v15 = (uint64_t *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12 || (int)v14 < *((_DWORD *)v15 + 7) || *((_DWORD *)v15 + 8) != *((_DWORD *)v11 + 8))
      {
LABEL_34:
        if (v32 == v14)
        {
          long long v39 = 0u;
          long long v40 = 0u;
          *(_OWORD *)unint64_t v38 = 0u;
          sub_100058DB0(__p, "");
          sub_100A4DFB8((uint64_t)v38, a1, (uint64_t)__p);
          if (SBYTE7(v36) < 0) {
            operator delete(__p[0]);
          }
          long long v36 = 0u;
          long long v37 = 0u;
          *(_OWORD *)std::string __p = 0u;
          sub_100058DB0(buf, "/cc/props/data_ui_indicators");
          sub_100A4DFB8((uint64_t)__p, a1, (uint64_t)buf);
          if (v44 < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v19 = v34[0];
          if (v34[0])
          {
            unint64_t v20 = v34;
            do
            {
              unsigned int v21 = v19;
              __int16 v22 = v20;
              int v23 = *((_DWORD *)v19 + 7);
              long long v24 = v19 + 1;
              if (v23 >= (int)v14)
              {
                long long v24 = v21;
                unint64_t v20 = (void **)v21;
              }
              uint64_t v19 = (void *)*v24;
            }
            while (v19);
            if (v20 != v34)
            {
              long long v25 = v23 >= (int)v14 ? v21 : v22;
              if (*((_DWORD *)v25 + 7) <= (int)v14)
              {
                if (v23 < (int)v14) {
                  unsigned int v21 = v22;
                }
                HIDWORD(__p[0]) = *((_DWORD *)v21 + 8);
              }
            }
          }
          if (HIDWORD(__p[0]) != HIDWORD(v38[0]))
          {
            unint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v27 = asString();
              uint64_t v28 = asString();
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v27;
              __int16 v42 = 2080;
              uint64_t v43 = v28;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Indicator changed from %s -> %s", buf, 0x16u);
            }
            sub_100A4E5E8(a1, (uint64_t)__p, (uint64_t)v38);
          }
          if (SHIBYTE(v36) < 0) {
            operator delete(__p[1]);
          }
          if (SHIBYTE(v39) < 0) {
            operator delete(v38[1]);
          }
        }
      }
      CFBooleanRef v29 = (void *)v11[1];
      if (v29)
      {
        do
        {
          long long v30 = v29;
          CFBooleanRef v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          long long v30 = (void *)v11[2];
          BOOL v6 = *v30 == (void)v11;
          uint64_t v11 = v30;
        }
        while (!v6);
      }
      uint64_t v11 = v30;
    }
    while (v30 != (void *)(a1 + 128));
  }
  sub_1000346F8((uint64_t)&v33, v34[0]);
}

void sub_100A4FF88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

void sub_100A50008(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)*a2;
  if (a2[2] == *(void *)(a1 + 160))
  {
    int v5 = a2 + 1;
    if (v4 == a2 + 1) {
      return;
    }
    BOOL v6 = *(void **)(a1 + 144);
    while (*((_DWORD *)v4 + 8) == *((_DWORD *)v6 + 8) && operator==())
    {
      int v7 = (void *)v4[1];
      BOOL v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v9 = *v4 == (void)v8;
          BOOL v8 = v4;
        }
        while (!v9);
      }
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          BOOL v6 = v11;
        }
        while (!v9);
      }
      BOOL v6 = v11;
      if (v4 == v5) {
        return;
      }
    }
    uint64_t v4 = (void *)*a2;
  }
  int v48 = *(_DWORD *)(a1 + 88);
  BOOL v50 = 0;
  uint64_t v51 = 0;
  uint64_t v49 = &v50;
  uint64_t v12 = a2 + 1;
  if (v4 != a2 + 1)
  {
    while (1)
    {
      uint64_t v13 = &v50;
      if (v49 != &v50)
      {
        uint64_t v14 = v50;
        BOOL v15 = &v50;
        if (v50)
        {
          do
          {
            uint64_t v13 = (uint64_t **)v14;
            uint64_t v14 = (uint64_t *)v14[1];
          }
          while (v14);
        }
        else
        {
          do
          {
            uint64_t v13 = (uint64_t **)v15[2];
            BOOL v9 = *v13 == (uint64_t *)v15;
            BOOL v15 = v13;
          }
          while (v9);
        }
        int v16 = *((_DWORD *)v4 + 8);
        if (*((_DWORD *)v13 + 8) >= v16) {
          break;
        }
      }
      if (v50) {
        BOOL v17 = v13;
      }
      else {
        BOOL v17 = &v50;
      }
      if (v50) {
        uint64_t v18 = v13 + 1;
      }
      else {
        uint64_t v18 = &v50;
      }
      if (!*v18) {
        goto LABEL_42;
      }
LABEL_48:
      long long v25 = (void *)v4[1];
      if (v25)
      {
        do
        {
          unint64_t v26 = v25;
          long long v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          unint64_t v26 = (void *)v4[2];
          BOOL v9 = *v26 == (void)v4;
          uint64_t v4 = v26;
        }
        while (!v9);
      }
      uint64_t v4 = v26;
      if (v26 == v12) {
        goto LABEL_54;
      }
    }
    uint64_t v18 = &v50;
    BOOL v17 = &v50;
    if (v50)
    {
      uint64_t v19 = v50;
      while (1)
      {
        while (1)
        {
          BOOL v17 = (uint64_t **)v19;
          int v20 = *((_DWORD *)v19 + 8);
          if (v20 <= v16) {
            break;
          }
          uint64_t v19 = *v17;
          uint64_t v18 = v17;
          if (!*v17) {
            goto LABEL_42;
          }
        }
        if (v20 >= v16) {
          goto LABEL_48;
        }
        uint64_t v19 = v17[1];
        if (!v19)
        {
          uint64_t v18 = v17 + 1;
          break;
        }
      }
    }
LABEL_42:
    *(void *)&long long v56 = 0;
    unsigned int v21 = (char *)operator new(0x48uLL);
    v55[1] = &v50;
    *((_DWORD *)v21 + 8) = *((_DWORD *)v4 + 8);
    __int16 v22 = v21 + 40;
    if (*((char *)v4 + 63) < 0)
    {
      sub_10004FC84(v22, (void *)v4[5], v4[6]);
    }
    else
    {
      long long v23 = *(_OWORD *)(v4 + 5);
      *((void *)v21 + 7) = v4[7];
      *(_OWORD *)__int16 v22 = v23;
    }
    int v24 = *((_DWORD *)v4 + 16);
    *((_WORD *)v21 + 34) = *((_WORD *)v4 + 34);
    *((_DWORD *)v21 + 16) = v24;
    *(void *)unsigned int v21 = 0;
    *((void *)v21 + 1) = 0;
    *((void *)v21 + 2) = v17;
    *uint64_t v18 = (uint64_t *)v21;
    if (*v49)
    {
      uint64_t v49 = (uint64_t **)*v49;
      unsigned int v21 = (char *)*v18;
    }
    sub_100046C90(v50, (uint64_t *)v21);
    ++v51;
    goto LABEL_48;
  }
LABEL_54:
  uint64_t v27 = *(void **)(a1 + 144);
  if (v27 != (void *)(a1 + 152))
  {
    while (1)
    {
      uint64_t v28 = *v12;
      if (!*v12) {
        break;
      }
      uint64_t v29 = *((unsigned int *)v27 + 8);
      long long v30 = v12;
      do
      {
        int v31 = *(_DWORD *)(v28 + 32);
        BOOL v32 = v31 < (int)v29;
        if (v31 >= (int)v29) {
          uint64_t v33 = (uint64_t *)v28;
        }
        else {
          uint64_t v33 = (uint64_t *)(v28 + 8);
        }
        if (!v32) {
          long long v30 = (void *)v28;
        }
        uint64_t v28 = *v33;
      }
      while (*v33);
      if (v30 == v12 || (int)v29 < *((_DWORD *)v30 + 8)) {
        goto LABEL_67;
      }
      if ((operator==() & 1) == 0) {
        break;
      }
LABEL_99:
      int v46 = (void *)v27[1];
      if (v46)
      {
        do
        {
          BOOL v47 = v46;
          int v46 = (void *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          BOOL v47 = (void *)v27[2];
          BOOL v9 = *v47 == (void)v27;
          uint64_t v27 = v47;
        }
        while (!v9);
      }
      uint64_t v27 = v47;
      if (v47 == (void *)(a1 + 152)) {
        goto LABEL_105;
      }
    }
    uint64_t v29 = *((unsigned int *)v27 + 8);
LABEL_67:
    if (v48 == v29)
    {
      long long v56 = 0u;
      long long v57 = 0u;
      *(_OWORD *)long long v55 = 0u;
      sub_100058DB0(__p, "");
      sub_100A4DFB8((uint64_t)v55, a1, (uint64_t)__p);
      if (SBYTE7(v53) < 0) {
        operator delete(__p[0]);
      }
      long long v53 = 0u;
      long long v54 = 0u;
      *(_OWORD *)std::string __p = 0u;
      sub_100058DB0(buf, "/cc/props/internal_internet_connection_state");
      sub_100A4DFB8((uint64_t)__p, a1, (uint64_t)buf);
      if (v61 < 0) {
        operator delete(*(void **)buf);
      }
      long long v34 = v50;
      if (v50)
      {
        char v35 = &v50;
        do
        {
          long long v36 = v34;
          long long v37 = v35;
          int v38 = *((_DWORD *)v34 + 8);
          long long v39 = (uint64_t **)(v34 + 1);
          if (v38 >= (int)v29)
          {
            long long v39 = (uint64_t **)v36;
            char v35 = (uint64_t **)v36;
          }
          long long v34 = *v39;
        }
        while (v34);
        if (v35 != &v50)
        {
          long long v40 = v38 >= (int)v29 ? v36 : (uint64_t *)v37;
          if (*((_DWORD *)v40 + 8) <= (int)v29)
          {
            if (v38 >= (int)v29) {
              int v41 = (const std::string *)(v36 + 5);
            }
            else {
              int v41 = (const std::string *)(v37 + 5);
            }
            std::string::operator=((std::string *)&__p[1], v41);
            __int16 v42 = (uint64_t *)(v37 + 8);
            if (v38 >= (int)v29) {
              __int16 v42 = v36 + 8;
            }
            LODWORD(v54) = *(_DWORD *)v42;
            WORD2(v54) = *((_WORD *)v42 + 2);
          }
        }
      }
      if (operator!=())
      {
        uint64_t v43 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v29);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v44 = asString();
          long long v45 = "true";
          if (!BYTE5(v57)) {
            long long v45 = "false";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v44;
          __int16 v59 = 2080;
          long long v60 = v45;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Internet connection state changed to %s (default=%s)", buf, 0x16u);
        }
        sub_100A4E5E8(a1, (uint64_t)__p, (uint64_t)v55);
      }
      if (SHIBYTE(v53) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(v56) < 0) {
        operator delete(v55[1]);
      }
    }
    sub_100A4CDD4(a1, v29);
    sub_100A516B4(a1, v29);
    goto LABEL_99;
  }
LABEL_105:
  sub_1000886C0((uint64_t)&v49, (char *)v50);
}

void sub_100A505BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, uint64_t a19, void *__p,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  sub_1000886C0(a9, a17);
  _Unwind_Resume(a1);
}

void sub_100A50664(uint64_t a1, _DWORD *a2)
{
  if ((rest::operator==() & 1) == 0 && *(_DWORD *)(a1 + 172) == *(_DWORD *)(a1 + 88))
  {
    long long v12 = 0u;
    long long v13 = 0u;
    *(_OWORD *)uint64_t v11 = 0u;
    sub_100058DB0(__p, "");
    sub_100A4DFB8((uint64_t)v11, a1, (uint64_t)__p);
    if (SBYTE7(v9) < 0) {
      operator delete(__p[0]);
    }
    long long v9 = 0u;
    long long v10 = 0u;
    *(_OWORD *)std::string __p = 0u;
    sub_100058DB0(buf, "/cc/props/internet_interface_cost");
    sub_100A4DFB8((uint64_t)__p, a1, (uint64_t)buf);
    if (SHIBYTE(v17) < 0) {
      operator delete(*(void **)buf);
    }
    DWORD2(v1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *a2;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = rest::asString();
      uint64_t v6 = rest::asString();
      uint64_t v7 = subscriber::asString();
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v15 = 2080;
      uint64_t v16 = v6;
      __int16 v17 = 2080;
      uint64_t v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Network cost changed from %s -> %s for %s", buf, 0x20u);
    }
    sub_100A4E5E8(a1, (uint64_t)__p, (uint64_t)v11);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(v12) < 0) {
      operator delete(v11[1]);
    }
  }
}

void sub_100A50810(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A50878(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 192))
  {
    uint64_t v4 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return;
    }
    uint64_t v5 = *(void **)(a1 + 176);
    while (1)
    {
      BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7) && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v4[1];
      BOOL v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v6 = *v4 == (void)v8;
          BOOL v8 = v4;
        }
        while (!v6);
      }
      long long v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          long long v10 = v9;
          long long v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          long long v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v4 == a2 + 1) {
        return;
      }
    }
  }
  int v32 = *(_DWORD *)(a1 + 88);
  sub_10005DF14(&v33, (uint64_t)a2);
  uint64_t v11 = *(void **)(a1 + 176);
  if (v11 != (void *)(a1 + 184))
  {
    long long v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v11 + 7);
      if (!*v12) {
        goto LABEL_34;
      }
      __int16 v15 = a2 + 1;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          uint64_t v18 = (uint64_t *)v13;
        }
        else {
          uint64_t v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          __int16 v15 = (uint64_t *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 == v12
        || (int)v14 < *((_DWORD *)v15 + 7)
        || *((unsigned __int8 *)v15 + 32) != *((unsigned __int8 *)v11 + 32))
      {
LABEL_34:
        if (v32 == v14)
        {
          long long v39 = 0u;
          long long v40 = 0u;
          *(_OWORD *)int v38 = 0u;
          sub_100058DB0(__p, "");
          sub_100A4DFB8((uint64_t)v38, a1, (uint64_t)__p);
          if (SBYTE7(v36) < 0) {
            operator delete(__p[0]);
          }
          long long v36 = 0u;
          long long v37 = 0u;
          *(_OWORD *)std::string __p = 0u;
          sub_100058DB0(buf, "/cc/props/private_network_sims_active");
          sub_100A4DFB8((uint64_t)__p, a1, (uint64_t)buf);
          if (v44 < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v19 = v34[0];
          if (v34[0])
          {
            int v20 = v34;
            do
            {
              unsigned int v21 = v19;
              __int16 v22 = v20;
              int v23 = *((_DWORD *)v19 + 7);
              int v24 = v19 + 1;
              if (v23 >= (int)v14)
              {
                int v24 = v21;
                int v20 = (void **)v21;
              }
              uint64_t v19 = (void *)*v24;
            }
            while (v19);
            if (v20 != v34)
            {
              long long v25 = v23 >= (int)v14 ? v21 : v22;
              if (*((_DWORD *)v25 + 7) <= (int)v14)
              {
                if (v23 < (int)v14) {
                  unsigned int v21 = v22;
                }
                BYTE12(v37) = *((unsigned char *)v21 + 32);
              }
            }
          }
          if (BYTE12(v37) != BYTE12(v40))
          {
            unint64_t v26 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              if (BYTE12(v37)) {
                uint64_t v27 = "true";
              }
              else {
                uint64_t v27 = "false";
              }
              if (BYTE12(v40)) {
                uint64_t v28 = "true";
              }
              else {
                uint64_t v28 = "false";
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v27;
              __int16 v42 = 2080;
              uint64_t v43 = v28;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network sim inexpensive changed from %s -> %s", buf, 0x16u);
            }
            sub_100A4E5E8(a1, (uint64_t)__p, (uint64_t)v38);
          }
          if (SHIBYTE(v36) < 0) {
            operator delete(__p[1]);
          }
          if (SHIBYTE(v39) < 0) {
            operator delete(v38[1]);
          }
        }
      }
      uint64_t v29 = (void *)v11[1];
      if (v29)
      {
        do
        {
          long long v30 = v29;
          uint64_t v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          long long v30 = (void *)v11[2];
          BOOL v6 = *v30 == (void)v11;
          uint64_t v11 = v30;
        }
        while (!v6);
      }
      uint64_t v11 = v30;
    }
    while (v30 != (void *)(a1 + 184));
  }
  sub_1000346F8((uint64_t)&v33, v34[0]);
}

void sub_100A50C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
}

uint64_t sub_100A50CC8(capabilities::ct *a1, uint64_t a2)
{
  uint64_t result = rest::operator==();
  if (result) {
    return result;
  }
  uint64_t v5 = (void *)*((void *)a1 + 39);
  if (v5 == (void *)((char *)a1 + 320)) {
    return result;
  }
  int v6 = 0;
  uint64_t v7 = (uint64_t *)(a2 + 8);
  do
  {
    uint64_t v8 = *v7;
    if (!*v7) {
      goto LABEL_14;
    }
    int v9 = *((_DWORD *)v5 + 8);
    uint64_t v10 = a2 + 8;
    do
    {
      int v11 = *(_DWORD *)(v8 + 32);
      BOOL v12 = v11 < v9;
      if (v11 >= v9) {
        uint64_t v13 = (uint64_t *)v8;
      }
      else {
        uint64_t v13 = (uint64_t *)(v8 + 8);
      }
      if (!v12) {
        uint64_t v10 = v8;
      }
      uint64_t v8 = *v13;
    }
    while (*v13);
    if ((uint64_t *)v10 != v7 && v9 >= *(_DWORD *)(v10 + 32))
    {
      uint64_t result = rest::operator==();
      if ((result & 1) != 0 || *((unsigned __int8 *)v5 + 40) - 1 > 2) {
        goto LABEL_16;
      }
    }
    else
    {
LABEL_14:
      if (*((unsigned __int8 *)v5 + 40) - 1 >= 3) {
        goto LABEL_16;
      }
    }
    int v6 = 1;
LABEL_16:
    uint64_t v14 = (void *)v5[1];
    if (v14)
    {
      do
      {
        __int16 v15 = v14;
        uint64_t v14 = (void *)*v14;
      }
      while (v14);
    }
    else
    {
      do
      {
        __int16 v15 = (void *)v5[2];
        BOOL v16 = *v15 == (void)v5;
        uint64_t v5 = v15;
      }
      while (!v16);
    }
    uint64_t v5 = v15;
  }
  while (v15 != (void *)((char *)a1 + 320));
  if (v6)
  {
    BOOL v17 = *((void *)a1 + 5);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Carrier bundles changed. Reloading save data mode settings", v18, 2u);
    }
    return sub_100A4AD28(a1);
  }
  return result;
}

void sub_100A50E2C(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 56));
    int v6 = ServiceMap;
    if (v7 < 0)
    {
      uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v9 = 5381;
      do
      {
        uint64_t v7 = v9;
        unsigned int v10 = *v8++;
        uint64_t v9 = (33 * v9) ^ v10;
      }
      while (v10);
    }
    std::mutex::lock(ServiceMap);
    *(void *)int v31 = v7;
    int v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)v31);
    if (v11)
    {
      uint64_t v13 = v11[3];
      BOOL v12 = (std::__shared_weak_count *)v11[4];
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v6);
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v12);
        char v14 = 0;
        if (!v13) {
          goto LABEL_8;
        }
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::mutex::unlock(v6);
    BOOL v12 = 0;
    char v14 = 1;
    if (!v13)
    {
LABEL_8:
      __int16 v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)int v31 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "No PersonalityShop", v31, 2u);
      }
LABEL_35:
      if ((v14 & 1) == 0) {
        sub_10004D2C8(v12);
      }
      return;
    }
LABEL_12:
    uint64_t v16 = SlotIdFromPersonalityId();
    BOOL v17 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v16);
    uint64_t v18 = *v17;
    if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(unsigned __int8 *)(a2 + 23);
      unsigned int v21 = *(const char **)a2;
      uint64_t v20 = *(void *)(a2 + 8);
      uint64_t v22 = asString();
      if ((v19 & 0x80u) == 0) {
        uint64_t v23 = v19;
      }
      else {
        uint64_t v23 = v20;
      }
      if ((v19 & 0x80u) == 0) {
        int v24 = (const char *)a2;
      }
      else {
        int v24 = v21;
      }
      if (v23) {
        long long v25 = v24;
      }
      else {
        long long v25 = "<invalid>";
      }
      *(_DWORD *)int v31 = 136315394;
      *(void *)&v31[4] = v25;
      __int16 v32 = 2080;
      uint64_t v33 = v22;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Personality '%s' is %s", v31, 0x16u);
    }
    if (*(unsigned char *)(a2 + 24) == 1)
    {
      if (sub_100A4AD28((capabilities::ct *)a1))
      {
        unint64_t v26 = *v17;
        if (os_log_type_enabled(*v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = *(unsigned __int8 *)(a2 + 23);
          BOOL v28 = (v27 & 0x80u) != 0;
          if ((v27 & 0x80u) != 0) {
            uint64_t v27 = *(void *)(a2 + 8);
          }
          if (v28) {
            uint64_t v29 = *(const char **)a2;
          }
          else {
            uint64_t v29 = (const char *)a2;
          }
          if (v27) {
            long long v30 = v29;
          }
          else {
            long long v30 = "<invalid>";
          }
          *(_DWORD *)int v31 = 136315138;
          *(void *)&v31[4] = v30;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Personality '%s' enabled. Save data mode settings reloaded", v31, 0xCu);
        }
      }
    }
    goto LABEL_35;
  }
}

void sub_100A510E0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A51118(uint64_t a1, unsigned __int8 **a2)
{
  if (capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    if (a2[2] == *(unsigned __int8 **)(a1 + 520))
    {
      uint64_t v4 = *a2;
      if (*a2 == (unsigned __int8 *)(a2 + 1)) {
        return;
      }
      uint64_t v5 = *(unsigned __int8 **)(a1 + 504);
      while (sub_10001D294(v4 + 32, v5 + 32) && sub_1003B27B4((uint64_t)(v4 + 56), (uint64_t)(v5 + 56)))
      {
        int v6 = (unsigned __int8 *)*((void *)v4 + 1);
        uint64_t v7 = v4;
        if (v6)
        {
          do
          {
            uint64_t v4 = v6;
            int v6 = *(unsigned __int8 **)v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v4 = (unsigned __int8 *)*((void *)v7 + 2);
            BOOL v8 = *(void *)v4 == (void)v7;
            uint64_t v7 = v4;
          }
          while (!v8);
        }
        uint64_t v9 = (unsigned __int8 *)*((void *)v5 + 1);
        if (v9)
        {
          do
          {
            unsigned int v10 = v9;
            uint64_t v9 = *(unsigned __int8 **)v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            unsigned int v10 = (unsigned __int8 *)*((void *)v5 + 2);
            BOOL v8 = *(void *)v10 == (void)v5;
            uint64_t v5 = v10;
          }
          while (!v8);
        }
        uint64_t v5 = v10;
        if (v4 == (unsigned __int8 *)(a2 + 1)) {
          return;
        }
      }
    }
    int v11 = *(void ***)(a1 + 504);
    if (v11 != (void **)(a1 + 512))
    {
      do
      {
        BOOL v12 = sub_100046F68((uint64_t)a2, v11 + 4);
        if (a2 + 1 == (unsigned __int8 **)v12 || (sub_1003B27B4((uint64_t)(v12 + 7), (uint64_t)(v11 + 7)) & 1) == 0)
        {
          uint64_t v13 = SlotIdFromPersonalityId();
          char v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v13);
          if ((unsigned __int16)sub_100A4B69C(a1, v13) < 0x100u)
          {
            unsigned __int16 v16 = sub_100A4B904((capabilities::ct *)a1, v13);
            if (v16 >= 0x100u)
            {
              unsigned __int16 v17 = v16;
              if (!(_BYTE)v16) {
                sub_100A4C884(a1, v13, 256);
              }
              sub_100A4D8DC(a1, v13, v17, 0);
            }
          }
          else
          {
            __int16 v15 = *v14;
            if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
            {
              v20[0] = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N Ignoring entitlement info as user already configured interface cost", (uint8_t *)v20, 2u);
            }
          }
        }
        uint64_t v18 = (void **)v11[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            uint64_t v18 = (void **)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v19 = (void **)v11[2];
            BOOL v8 = *v19 == v11;
            int v11 = v19;
          }
          while (!v8);
        }
        int v11 = v19;
      }
      while (v19 != (void **)(a1 + 512));
    }
  }
}

void sub_100A5137C(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 544) == a2[2])
  {
    uint64_t v4 = *(void **)(a1 + 528);
    uint64_t v5 = (void *)(a1 + 536);
    if (v4 == (void *)(a1 + 536)) {
      return;
    }
    int v6 = (void *)*a2;
    while (*((_DWORD *)v4 + 7) == *((_DWORD *)v6 + 7) && rest::operator==())
    {
      uint64_t v7 = (void *)v4[1];
      BOOL v8 = v4;
      if (v7)
      {
        do
        {
          uint64_t v4 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v4 = (void *)v8[2];
          BOOL v9 = *v4 == (void)v8;
          BOOL v8 = v4;
        }
        while (!v9);
      }
      unsigned int v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          int v6 = v11;
        }
        while (!v9);
      }
      int v6 = v11;
      if (v4 == v5) {
        return;
      }
    }
  }
  int v27 = *(_DWORD *)(a1 + 88);
  sub_100A57A18((uint64_t)v28, (uint64_t)a2);
  BOOL v12 = *(void **)(a1 + 528);
  if (v12 != (void *)(a1 + 536))
  {
    uint64_t v13 = a2 + 1;
    do
    {
      uint64_t v14 = *v13;
      uint64_t v15 = *((unsigned int *)v12 + 7);
      if (!*v13) {
        goto LABEL_30;
      }
      unsigned __int16 v16 = v13;
      do
      {
        int v17 = *(_DWORD *)(v14 + 28);
        BOOL v18 = v17 < (int)v15;
        if (v17 >= (int)v15) {
          uint64_t v19 = (uint64_t *)v14;
        }
        else {
          uint64_t v19 = (uint64_t *)(v14 + 8);
        }
        if (!v18) {
          unsigned __int16 v16 = (void *)v14;
        }
        uint64_t v14 = *v19;
      }
      while (*v19);
      if (v16 != v13 && (int)v15 >= *((_DWORD *)v16 + 7))
      {
        if ((rest::operator==() & 1) == 0)
        {
          uint64_t v15 = *((unsigned int *)v12 + 7);
          if (v27 == v15)
          {
            uint64_t v20 = a1;
            unsigned int v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v12 + 7));
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
LABEL_32:
              int v22 = *((_DWORD *)v12 + 8);
              int v23 = *((_DWORD *)v12 + 9);
              uint64_t v24 = rest::asString();
              *(_DWORD *)long long buf = 67109634;
              int v30 = v22;
              __int16 v31 = 1024;
              int v32 = v23;
              __int16 v33 = 2080;
              uint64_t v34 = v24;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Bandwidth changed to (ul: %u Kbps, dl: %u Kbps, rat: %s)", buf, 0x18u);
            }
LABEL_33:
            sub_100A516B4(v20, v15);
          }
        }
      }
      else
      {
LABEL_30:
        if (v27 == v15)
        {
          uint64_t v20 = a1;
          unsigned int v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v12 + 7));
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_32;
          }
          goto LABEL_33;
        }
      }
      long long v25 = (void *)v12[1];
      if (v25)
      {
        do
        {
          unint64_t v26 = v25;
          long long v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          unint64_t v26 = (void *)v12[2];
          BOOL v9 = *v26 == (void)v12;
          BOOL v12 = v26;
        }
        while (!v9);
      }
      BOOL v12 = v26;
    }
    while (v26 != (void *)(a1 + 536));
  }
  sub_1000346F8((uint64_t)v28, v28[1]);
}

void sub_100A51694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
}

void sub_100A516B4(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::supports5G((capabilities::ct *)a1))
  {
    uint64_t v4 = *(void *)(a1 + 152);
    if (v4)
    {
      uint64_t v5 = a1 + 152;
      do
      {
        int v6 = *(_DWORD *)(v4 + 32);
        BOOL v7 = v6 < (int)a2;
        if (v6 >= (int)a2) {
          BOOL v8 = (uint64_t *)v4;
        }
        else {
          BOOL v8 = (uint64_t *)(v4 + 8);
        }
        if (!v7) {
          uint64_t v5 = v4;
        }
        uint64_t v4 = *v8;
      }
      while (*v8);
      if (v5 != a1 + 152 && *(_DWORD *)(v5 + 32) <= (int)a2)
      {
        uint64_t v9 = *(void *)(a1 + 536);
        if (v9)
        {
          uint64_t v10 = a1 + 536;
          do
          {
            int v11 = *(_DWORD *)(v9 + 28);
            BOOL v12 = v11 < (int)a2;
            if (v11 >= (int)a2) {
              uint64_t v13 = (uint64_t *)v9;
            }
            else {
              uint64_t v13 = (uint64_t *)(v9 + 8);
            }
            if (!v12) {
              uint64_t v10 = v9;
            }
            uint64_t v9 = *v13;
          }
          while (*v13);
          if (v10 != a1 + 536 && *(_DWORD *)(v10 + 28) <= (int)a2)
          {
            uint64_t v14 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
            ServiceMap = (std::mutex *)Registry::getServiceMap(v15, *(Registry **)(a1 + 56));
            int v17 = ServiceMap;
            if (v18 < 0)
            {
              uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v20 = 5381;
              do
              {
                uint64_t v18 = v20;
                unsigned int v21 = *v19++;
                uint64_t v20 = (33 * v20) ^ v21;
              }
              while (v21);
            }
            std::mutex::lock(ServiceMap);
            __p[0] = (void *)v18;
            int v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)__p);
            if (v22)
            {
              uint64_t v24 = v22[3];
              int v23 = (std::__shared_weak_count *)v22[4];
              if (v23)
              {
                atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v17);
                atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v23);
                char v25 = 0;
LABEL_30:
                if (v24)
                {
                  __p[0] = 0;
                  __p[1] = 0;
                  uint64_t v37 = 0;
                  if (*(char *)(v5 + 63) < 0)
                  {
                    sub_10004FC84(__p, *(void **)(v5 + 40), *(void *)(v5 + 48));
                  }
                  else
                  {
                    *(_OWORD *)std::string __p = *(_OWORD *)(v5 + 40);
                    uint64_t v37 = *(void *)(v5 + 56);
                  }
                  if (v37 >= 0) {
                    int v27 = (void *)HIBYTE(v37);
                  }
                  else {
                    int v27 = __p[1];
                  }
                  BOOL v28 = *v14;
                  BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
                  if (v27)
                  {
                    if (v29)
                    {
                      int v31 = *(_DWORD *)(v10 + 32);
                      int v30 = *(_DWORD *)(v10 + 36);
                      uint64_t v32 = rest::asString();
                      *(_DWORD *)long long buf = 67109634;
                      int v39 = v31;
                      __int16 v40 = 1024;
                      int v41 = v30;
                      __int16 v42 = 2080;
                      uint64_t v43 = v32;
                      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Evaluated interface bandwidth: (ul: %u Kbps, dl: %u Kbps, rat: %s)", buf, 0x18u);
                    }
                    if (*(_DWORD *)(v5 + 64) == 2)
                    {
                      uint64_t v33 = *(unsigned int *)(v10 + 32);
                      uint64_t v34 = *(unsigned int *)(v10 + 36);
                      uint64_t v35 = *(unsigned __int8 *)(v10 + 40);
                    }
                    else
                    {
                      uint64_t v33 = 0;
                      uint64_t v34 = 0;
                      uint64_t v35 = 0;
                    }
                    (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t))(*(void *)v24 + 48))(v24, __p, v33, v34, v35);
                  }
                  else if (v29)
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#N No interface name. Failed to set network interface bandwidth", buf, 2u);
                  }
                  if (SHIBYTE(v37) < 0) {
                    operator delete(__p[0]);
                  }
                }
                else
                {
                  unint64_t v26 = *v14;
                  if (os_log_type_enabled(*v14, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(__p[0]) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#E No network config interface. Failed to set network interface bandwidth", (uint8_t *)__p, 2u);
                  }
                }
                if ((v25 & 1) == 0) {
                  sub_10004D2C8(v23);
                }
                return;
              }
            }
            else
            {
              uint64_t v24 = 0;
            }
            std::mutex::unlock(v17);
            int v23 = 0;
            char v25 = 1;
            goto LABEL_30;
          }
        }
      }
    }
  }
}

void sub_100A51A0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A51A54(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  int v3 = (Registry **)(a1 + 56);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    BOOL v12 = 0;
    char v14 = 1;
    if (!v11) {
      goto LABEL_68;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v10[3];
  BOOL v12 = (std::__shared_weak_count *)v10[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
  if (!v11) {
    goto LABEL_68;
  }
LABEL_10:
  char v15 = (std::mutex *)Registry::getServiceMap(v13, *v3);
  unsigned __int16 v16 = v15;
  if (v17 < 0)
  {
    uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v15);
  *(void *)long long buf = v17;
  unsigned int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
  if (v21)
  {
    uint64_t v22 = v21[3];
    int v23 = (std::__shared_weak_count *)v21[4];
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v23);
      char v24 = 0;
      if (!v22) {
        goto LABEL_16;
      }
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  std::mutex::unlock(v16);
  int v23 = 0;
  char v24 = 1;
  if (!v22)
  {
LABEL_16:
    char v25 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#N PersonalityShop is not ready", buf, 2u);
    }
    if (v24) {
      goto LABEL_68;
    }
LABEL_67:
    sub_10004D2C8(v23);
    goto LABEL_68;
  }
LABEL_22:
  char v49 = v24;
  char v50 = v14;
  int v48 = v23;
  uint64_t v51 = (capabilities::ct *)a1;
  subscriber::makeSimSlotRange();
  int v27 = *(unsigned int **)buf;
  unint64_t v26 = v55;
  if (*(unsigned int **)buf != v55)
  {
    BOOL v28 = v56;
    while ((v28(*v27) & 1) == 0)
    {
      if (++v27 == v26)
      {
        int v27 = v26;
        break;
      }
    }
    BOOL v29 = v55;
    if (v27 != v55)
    {
      int v30 = (void *)(a1 + 560);
      BOOL v47 = (void *)(a1 + 240);
      int v46 = v12;
      do
      {
        uint64_t v31 = *v27;
        uint64_t v52 = 0;
        long long v53 = 0;
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v22 + 8))(&v52, v22, v31);
        if (v52)
        {
          if (*(unsigned char *)(v52 + 48))
          {
            uint64_t v32 = *v30;
            if (*v30)
            {
              uint64_t v33 = v30;
              do
              {
                int v34 = *(_DWORD *)(v32 + 32);
                BOOL v35 = v34 < (int)v31;
                if (v34 >= (int)v31) {
                  long long v36 = (uint64_t *)v32;
                }
                else {
                  long long v36 = (uint64_t *)(v32 + 8);
                }
                if (!v35) {
                  uint64_t v33 = (void *)v32;
                }
                uint64_t v32 = *v36;
              }
              while (*v36);
              if (v33 != v30 && (int)v31 >= *((_DWORD *)v33 + 8))
              {
                int v38 = v47;
                uint64_t v39 = *v47;
                if (!*v47) {
                  goto LABEL_59;
                }
                do
                {
                  int v40 = *(_DWORD *)(v39 + 28);
                  BOOL v41 = v40 < (int)v31;
                  if (v40 >= (int)v31) {
                    __int16 v42 = (uint64_t *)v39;
                  }
                  else {
                    __int16 v42 = (uint64_t *)(v39 + 8);
                  }
                  if (!v41) {
                    int v38 = (void *)v39;
                  }
                  uint64_t v39 = *v42;
                }
                while (*v42);
                if (v38 != v47 && *((_DWORD *)v38 + 7) <= (int)v31) {
                  BOOL v43 = *((unsigned char *)v38 + 32) != 0;
                }
                else {
LABEL_59:
                }
                  BOOL v43 = 0;
                InterfaceCostExpensive_sync = (capabilities::ct *)SaveDataModeController::getInterfaceCostExpensive_sync(v51, v31);
                int v45 = (int)InterfaceCostExpensive_sync;
                if ((capabilities::ct::supports5G(InterfaceCostExpensive_sync) & 1) == 0 || v45 || !v43) {
                  operator new();
                }
                BOOL v12 = v46;
              }
            }
          }
        }
        if (v53) {
          sub_10004D2C8(v53);
        }
        uint64_t v37 = v27 + 1;
        int v27 = v26;
        if (v37 != v26)
        {
          int v27 = v37;
          while ((v28(*v27) & 1) == 0)
          {
            if (++v27 == v26)
            {
              int v27 = v26;
              break;
            }
          }
        }
      }
      while (v27 != v29);
    }
  }
  char v14 = v50;
  int v23 = v48;
  if ((v49 & 1) == 0) {
    goto LABEL_67;
  }
LABEL_68:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100A51EE4()
{
}

void sub_100A51FA4(uint64_t a1, void **a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string __p = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_99;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_99;
  }
LABEL_10:
  if ((*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12))
  {
    sub_100058DB0(__p, "slot");
    char v15 = sub_100046F68((uint64_t)(a2 + 3), (void **)__p);
    if (v62 < 0) {
      operator delete(*(void **)__p);
    }
    unsigned __int16 v16 = (void **)(a2 + 4);
    if (a2 + 4 != (void **)v15)
    {
      uint64_t v17 = (subscriber *)(v15 + 7);
      if (*((char *)v15 + 79) < 0) {
        uint64_t v17 = *(subscriber **)v17;
      }
      subscriber::fromString(v17, v14);
      int v18 = *((char *)a2 + 23);
      if (v18 >= 0) {
        size_t v19 = *((unsigned __int8 *)a2 + 23);
      }
      else {
        size_t v19 = (size_t)a2[1];
      }
      switch(v19)
      {
        case 0xEuLL:
          if (v18 >= 0) {
            unsigned int v20 = a2;
          }
          else {
            unsigned int v20 = *a2;
          }
          if (!memcmp(v20, "submit-metrics", v19))
          {
            unsigned int v21 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string __p = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I [DEBUG] Submitting switch metrics", __p, 2u);
            }
            *(void *)std::string __p = 0;
            *(void *)&__p[8] = 0;
            sub_10003E168(__p, (void *)(a1 + 8));
            operator new();
          }
          return;
        case 0x11uLL:
          if (v18 >= 0) {
            uint64_t v22 = (uint64_t *)a2;
          }
          else {
            uint64_t v22 = *a2;
          }
          uint64_t v23 = *v22;
          uint64_t v24 = v22[1];
          int v25 = *((unsigned __int8 *)v22 + 16);
          if (v23 == 0x2D776F6C2D746573 && v24 == 0x646F6D2D61746164 && v25 == 101)
          {
            sub_100058DB0(__p, "enabled");
            BOOL v28 = sub_100046F68((uint64_t)(a2 + 3), (void **)__p);
            if (v62 < 0) {
              operator delete(*(void **)__p);
            }
            if (v16 != v28)
            {
              int v29 = std::stoi((const std::string *)(v28 + 7), 0, 10);
              int v30 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v31 = subscriber::asString();
                uint64_t v32 = "Disable";
                if (v29) {
                  uint64_t v32 = "Enable";
                }
                *(_DWORD *)std::string __p = 136315394;
                *(void *)&__p[4] = v32;
                *(_WORD *)&unsigned char __p[12] = 2080;
                *(void *)&__p[14] = v31;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I [DEBUG] %s low data mode for %s", __p, 0x16u);
              }
              sub_100A49D20(a1);
            }
          }
          return;
        case 0x13uLL:
          if (v18 >= 0) {
            uint64_t v33 = (uint64_t *)a2;
          }
          else {
            uint64_t v33 = *a2;
          }
          uint64_t v34 = *v33;
          uint64_t v35 = v33[1];
          uint64_t v36 = *(uint64_t *)((char *)v33 + 11);
          if (v34 == 0x72616D732D746573 && v35 == 0x6D2D617461642D74 && v36 == 0x65646F6D2D617461)
          {
            sub_100058DB0(__p, "enabled");
            uint64_t v39 = sub_100046F68((uint64_t)(a2 + 3), (void **)__p);
            if (v62 < 0) {
              operator delete(*(void **)__p);
            }
            if (v16 != v39)
            {
              int v40 = std::stoi((const std::string *)(v39 + 7), 0, 10);
              BOOL v41 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v42 = subscriber::asString();
                BOOL v43 = "Disable";
                if (v40) {
                  BOOL v43 = "Enable";
                }
                *(_DWORD *)std::string __p = 136315394;
                *(void *)&__p[4] = v43;
                *(_WORD *)&unsigned char __p[12] = 2080;
                *(void *)&__p[14] = v42;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I [DEBUG] %s smart data mode for %s", __p, 0x16u);
              }
              sub_100A49F48(a1);
            }
          }
          return;
        case 0x17uLL:
          if (v18 >= 0) {
            char v44 = (uint64_t *)a2;
          }
          else {
            char v44 = *a2;
          }
          if (*v44 == 0x65746E692D746573
            && v44[1] == 0x78652D6563616672
            && *(uint64_t *)((char *)v44 + 15) == 0x657669736E657078)
          {
            sub_100058DB0(__p, "expensive");
            long long v56 = sub_100046F68((uint64_t)(a2 + 3), (void **)__p);
            if (v62 < 0) {
              operator delete(*(void **)__p);
            }
            if (v16 != v56)
            {
              int v57 = std::stoi((const std::string *)(v56 + 7), 0, 10);
              uint64_t v58 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v59 = subscriber::asString();
                long long v60 = "false";
                if (v57) {
                  long long v60 = "true";
                }
                *(_DWORD *)std::string __p = 136315394;
                *(void *)&__p[4] = v60;
                *(_WORD *)&unsigned char __p[12] = 2080;
                *(void *)&__p[14] = v59;
                _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I [DEBUG] Setting interface expensive to %s for %s", __p, 0x16u);
              }
              sub_100A4A2BC(a1);
            }
          }
          else
          {
            uint64_t v47 = *v44;
            uint64_t v48 = v44[1];
            uint64_t v49 = *(uint64_t *)((char *)v44 + 15);
            if (v47 == 0x656469727265766FLL && v48 == 0x61667265746E692DLL && v49 == 0x74736F632D656361)
            {
              sub_100058DB0(__p, "inexpensive");
              uint64_t v52 = sub_100046F68((uint64_t)(a2 + 3), (void **)__p);
              if (v62 < 0) {
                operator delete(*(void **)__p);
              }
              if (v16 != v52)
              {
                int v53 = std::stoi((const std::string *)(v52 + 7), 0, 10);
                long long v54 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                {
                  long long v55 = "false";
                  if (v53) {
                    long long v55 = "true";
                  }
                  *(_DWORD *)std::string __p = 136315138;
                  *(void *)&__p[4] = v55;
                  _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I [DEBUG] Overriding interface in-expensive to %s", __p, 0xCu);
                }
                sub_100A4A4D8(a1);
              }
            }
          }
          return;
        default:
          break;
      }
    }
  }
LABEL_99:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100A52700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A527BC(uint64_t a1)
{
  sub_100A528C0(a1);

  operator delete();
}

void *sub_100A527F4(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100A52878(unint64_t a1)
{
  if (a1 >= 0x555555555555556) {
    sub_10006A7CC();
  }
  return operator new(48 * a1);
}

void sub_100A528C0(uint64_t a1)
{
  *(void *)a1 = off_101A30E70;
  uint64_t v2 = *(void *)(a1 + 616);
  *(void *)(a1 + 616) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 608);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10024D10C(a1 + 576, *(void **)(a1 + 584));
  sub_10019D5B8(a1 + 552, *(void **)(a1 + 560));
  sub_1000346F8(a1 + 528, *(void **)(a1 + 536));
  sub_10030AAD0(a1 + 504, *(void **)(a1 + 512));
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 336));
  sub_100087F94(a1 + 312, *(void **)(a1 + 320));
  sub_1000346F8(a1 + 288, *(void **)(a1 + 296));
  sub_10041A760((void *)(a1 + 256));
  sub_1000346F8(a1 + 232, *(void **)(a1 + 240));
  sub_100A527F4((void *)(a1 + 200));
  sub_1000346F8(a1 + 176, *(void **)(a1 + 184));
  sub_1000886C0(a1 + 144, *(char **)(a1 + 152));
  sub_1000346F8(a1 + 120, *(void **)(a1 + 128));
  sub_1000346F8(a1 + 96, *(void **)(a1 + 104));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SaveDataModeInterface::~SaveDataModeInterface((SaveDataModeInterface *)a1);
}

void sub_100A52A50(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A52A88(uint64_t a1)
{
}

uint64_t sub_100A52AA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100A52AE8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100A52B14(ServiceManager::Service *this)
{
  *(void *)this = off_101A310A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100A52B70(ServiceManager::Service *this)
{
  *(void *)this = off_101A310A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100A52BE0@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SaveDataModeController");
}

unsigned char *sub_100A52BF0@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  *uint64_t v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100A52C30(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100A49960(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100A49960(v4, 0);
}

uint64_t sub_100A52CB4()
{
  return 1;
}

uint64_t sub_100A52CBC()
{
  return 1;
}

uint64_t sub_100A52CC4()
{
  return 2;
}

void sub_100A52CCC(uint64_t a1, xpc_object_t *a2, NSObject **a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v5 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v5 = xpc_null_create();
  }
  uint64_t v6 = *a3;
  BOOL v7 = v6;
  if (v6)
  {
    dispatch_retain(v6);
    dispatch_group_enter(v6);
    sub_100A49A58(v4, v5, &v7);
  }
  sub_100A49A58(v4, v5, &v7);
}

void sub_100A52D7C(uint64_t a1)
{
  char v1 = (void *)(*(void *)(a1 + 8) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

void sub_100A52E58(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(v3 + 8));
  operator new();
}

void sub_100A52F6C(ServiceManager::Service *this)
{
  *(void *)this = off_101A310A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100A52FC8(ServiceManager::Service *this)
{
  *(void *)this = off_101A310A8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

uint64_t sub_100A53038()
{
  return 0;
}

uint64_t sub_100A53040()
{
  return 0;
}

void sub_100A53050()
{
}

uint64_t sub_100A53064(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_100A53070(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v43 = a1;
  uint64_t v44 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping...", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v45, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v46) {
    sub_10004D2C8(v46);
  }
  sub_10041BCB4(v2 + 88);
  if (capabilities::ct::supports5GSlicing(v4))
  {
    sub_100058DB0(&__p, "/cc/props/connection_state");
    xpc_object_t v5 = (uint8_t *)operator new(0x28uLL);
    *(void *)xpc_object_t v5 = off_101A31170;
    *((void *)v5 + 1) = v2 + 576;
    *((void *)v5 + 2) = v2;
    *((void *)v5 + 3) = sub_100A4F240;
    *((void *)v5 + 4) = 0;
    long long v56 = v5;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (SHIBYTE(v49) < 0) {
      operator delete(__p);
    }
  }
  sub_100058DB0(&__p, "/cc/props/in_home_countries_definite");
  uint64_t v6 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v6 = off_101A311F0;
  *((void *)v6 + 1) = v2 + 96;
  *((void *)v6 + 2) = v2;
  *((void *)v6 + 3) = sub_100A4F780;
  *((void *)v6 + 4) = 0;
  long long v56 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/data_ui_indicators");
  BOOL v7 = (uint8_t *)operator new(0x28uLL);
  *(void *)BOOL v7 = off_101A31270;
  *((void *)v7 + 1) = v2 + 120;
  *((void *)v7 + 2) = v2;
  *((void *)v7 + 3) = sub_100A4FBD0;
  *((void *)v7 + 4) = 0;
  long long v56 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/internal_internet_connection_state");
  uint64_t v8 = (uint8_t *)operator new(0x28uLL);
  *(void *)uint64_t v8 = off_101A312F0;
  *((void *)v8 + 1) = v2 + 144;
  *((void *)v8 + 2) = v2;
  *((void *)v8 + 3) = sub_100A50008;
  *((void *)v8 + 4) = 0;
  long long v56 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/internet_interface_cost");
  unsigned int v9 = (uint8_t *)operator new(0x28uLL);
  *(void *)unsigned int v9 = off_101A31370;
  *((void *)v9 + 1) = v2 + 168;
  *((void *)v9 + 2) = v2;
  *((void *)v9 + 3) = sub_100A50664;
  *((void *)v9 + 4) = 0;
  long long v56 = v9;
  ctu::RestModule::observeProperty();
  uint64_t v10 = (capabilities::ct *)sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  if (capabilities::ct::supportsCerberus(v10))
  {
    sub_100058DB0(&__p, "/cc/props/private_network_sims_active");
    uint64_t v11 = (uint8_t *)operator new(0x28uLL);
    *(void *)uint64_t v11 = off_101A313F0;
    *((void *)v11 + 1) = v2 + 176;
    *((void *)v11 + 2) = v2;
    *((void *)v11 + 3) = sub_100A50878;
    *((void *)v11 + 4) = 0;
    long long v56 = v11;
    ctu::RestModule::observeProperty();
    sub_10003F600(buf);
    if (SHIBYTE(v49) < 0) {
      operator delete(__p);
    }
  }
  uint64_t v12 = (uint8_t *)(v2 + 200);
  *(void *)long long buf = off_101A31470;
  uint64_t v54 = v2 + 72;
  long long v56 = buf;
  if (buf != (uint8_t *)(v2 + 200))
  {
    char v13 = *(uint8_t **)(v2 + 224);
    if (v13 == v12)
    {
      uint64_t v48 = v2 + 72;
      uint64_t v49 = 0;
      std::string __p = off_101A31470;
      long long v56 = 0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v12 + 24))(v2 + 200, buf);
      (*(void (**)(void))(**(void **)(v2 + 224) + 32))(*(void *)(v2 + 224));
      *(void *)(v2 + 224) = 0;
      long long v56 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, v2 + 200);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(v2 + 20ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = off_101A31470;
      *(void *)(v2 + 208) = v2 + 72;
      long long v56 = v13;
    }
    *(void *)(v2 + 224) = v12;
  }
  sub_100A527F4(buf);
  char v14 = *(capabilities::ct **)(v2 + 224);
  if (v14) {
    char v14 = (capabilities::ct *)(*(uint64_t (**)(capabilities::ct *, uint64_t))(*(void *)v14 + 48))(v14, v2 + 232);
  }
  if (capabilities::ct::supports5G(v14))
  {
    *(void *)long long buf = off_101A31500;
    uint64_t v54 = v2 + 72;
    long long v56 = buf;
    sub_10041CA0C(buf, (void *)(v2 + 256));
    sub_10041A760(buf);
    uint64_t v15 = *(void *)(v2 + 280);
    if (v15) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, v2 + 288);
    }
  }
  sub_100058DB0(&__p, "/cc/props/carrier_bundles");
  unsigned __int16 v16 = (uint8_t *)operator new(0x28uLL);
  *(void *)unsigned __int16 v16 = off_101A31580;
  *((void *)v16 + 1) = v2 + 312;
  *((void *)v16 + 2) = v2;
  *((void *)v16 + 3) = sub_100A50CC8;
  *((void *)v16 + 4) = 0;
  long long v56 = v16;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  char v17 = (uint8_t *)operator new(0x20uLL);
  int v18 = (dispatch_object_t *)(v2 + 24);
  *(void *)char v17 = off_101A31600;
  *((void *)v17 + 1) = v2;
  *((void *)v17 + 2) = sub_100A50E2C;
  *((void *)v17 + 3) = 0;
  long long v56 = v17;
  char v50 = 0;
  object[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(object);
  sub_10010040C(&__p);
  sub_100100388(buf);
  sub_100058DB0(&__p, "/cc/props/carrier_entitlements_info");
  size_t v19 = (uint8_t *)operator new(0x28uLL);
  *(void *)size_t v19 = off_101A31680;
  *((void *)v19 + 1) = v2 + 504;
  *((void *)v19 + 2) = v2;
  *((void *)v19 + 3) = sub_100A51118;
  *((void *)v19 + 4) = 0;
  long long v56 = v19;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/props/bandwidth_infos");
  unsigned int v20 = (uint8_t *)operator new(0x28uLL);
  *(void *)unsigned int v20 = off_101A31700;
  *((void *)v20 + 1) = v2 + 528;
  *((void *)v20 + 2) = v2;
  *((void *)v20 + 3) = sub_100A5137C;
  *((void *)v20 + 4) = 0;
  long long v56 = v20;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  sub_10071A3EC(v2 + 552);
  sub_100058DB0(&__p, "/cc/events/dump_state");
  unsigned int v21 = (uint8_t *)operator new(0x20uLL);
  *(void *)unsigned int v21 = off_101A31780;
  *((void *)v21 + 1) = v2;
  *((void *)v21 + 2) = sub_100A4C524;
  *((void *)v21 + 3) = 0;
  long long v56 = v21;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/debug_rest_command");
  uint64_t v22 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v22 = off_101A31800;
  *((void *)v22 + 1) = v2;
  *((void *)v22 + 2) = sub_100A51FA4;
  *((void *)v22 + 3) = 0;
  long long v56 = v22;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v49) < 0) {
    operator delete(__p);
  }
  SaveDataModeController::setupAwdMetricCallbacks_sync((SaveDataModeController *)v2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v23, *(Registry **)(v2 + 56));
  int v25 = ServiceMap;
  if (v26 < 0)
  {
    int v27 = (unsigned __int8 *)(v26 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v28 = 5381;
    do
    {
      uint64_t v26 = v28;
      unsigned int v29 = *v27++;
      uint64_t v28 = (33 * v28) ^ v29;
    }
    while (v29);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v26;
  int v30 = sub_10004D37C(&v25[1].__m_.__sig, (unint64_t *)buf);
  if (v30)
  {
    uint64_t v32 = v30[3];
    uint64_t v31 = (std::__shared_weak_count *)v30[4];
    if (v31)
    {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v25);
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v31);
      char v33 = 0;
      if (!v32) {
        goto LABEL_65;
      }
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v32 = 0;
  }
  std::mutex::unlock(v25);
  uint64_t v31 = 0;
  char v33 = 1;
  if (!v32) {
    goto LABEL_65;
  }
LABEL_48:
  uint64_t v34 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v34 || (uint64_t v35 = *(void *)(v2 + 8), (v36 = std::__shared_weak_count::lock(v34)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v37 = v36;
  atomic_fetch_add_explicit(&v36->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v36);
  int v38 = *v18;
  if (*v18) {
    dispatch_retain(*v18);
  }
  std::string __p = _NSConcreteStackBlock;
  uint64_t v48 = 0x40000000;
  uint64_t v49 = sub_100A53CAC;
  char v50 = &unk_101A31140;
  uint64_t v51 = v2;
  if (v38)
  {
    uint64_t v39 = _Block_copy(&__p);
    int v40 = v39;
    object[0] = v38;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v54 = 1174405120;
    long long v55 = sub_100A563C8;
    long long v56 = (uint8_t *)&unk_101A31870;
    uint64_t v57 = v35;
    uint64_t v58 = v37;
    atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (v39) {
      BOOL v41 = _Block_copy(v39);
    }
    else {
      BOOL v41 = 0;
    }
    aBlock = v41;
    (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, uint8_t *))(*(void *)v32 + 40))(v32, "commCenterSwitchState", 1, object, buf);
    if (object[0]) {
      dispatch_release(object[0]);
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (v58) {
      std::__shared_weak_count::__release_weak(v58);
    }
    if (v40) {
      _Block_release(v40);
    }
  }
  std::__shared_weak_count::__release_weak(v37);
LABEL_65:
  if ((v33 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  sub_100088C88(&v44);
  return sub_100046B58((uint64_t *)&v43);
}

void sub_100A53B68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,dispatch_object_t object,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34,void *aBlock)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A53CAC(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
}

void sub_100A53CB8()
{
}

__n128 sub_100A53CCC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A31170;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A53D20(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31170;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A53D58(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  unsigned int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    unsigned int v9 = &v10;
  }
  sub_100318E34((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10024D10C((uint64_t)&v9, v10);
}

void sub_100A53E18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100A53E30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A53E70()
{
}

void sub_100A53E80()
{
}

__n128 sub_100A53E94(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A311F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A53EE8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A311F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A53F20(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  unsigned int v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    unsigned int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100A53FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100A53FF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A54038()
{
}

void sub_100A54048()
{
}

__n128 sub_100A5405C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A31270;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A540B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A540E8(void *a1, xpc_object_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = a1[1];
  xpc_object_t v5 = (uint64_t **)(v3 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  uint64_t v26 = *(uint64_t **)v3;
  int v27 = v4;
  if (*(void *)(v3 + 16))
  {
    void v4[2] = &v27;
    *(void *)uint64_t v3 = v5;
    void *v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    uint64_t v26 = (uint64_t *)&v27;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_1000346F8(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v31, &object, 0);
    xpc_release(object);
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    int v25 = v2;
    sub_100048BF4(v30, &object, count);
    xpc_release(object);
    for (uint64_t i = v32; ; uint64_t i = ++v32)
    {
      if (i == v30[1] && v31 == v30[0])
      {
        xpc_release(v31);
        xpc_release(v31);
        uint64_t v2 = v25;
        goto LABEL_57;
      }
      xpc_object_t v29 = 0;
      xpc_object_t object = &v31;
      uint64_t v34 = i;
      sub_10003FBDC((uint64_t)&object, &v29);
      if (xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_55:
      xpc_release(v29);
    }
    xpc_object_t v9 = v29;
    if (v29)
    {
      xpc_retain(v29);
      xpc_object_t v36 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v36 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v36;
      goto LABEL_30;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v36 = v10;
LABEL_30:
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t object = &v36;
      uint64_t v34 = "first";
      sub_100048BAC((uint64_t)&object, &v35);
      xpc_type_t type = xpc_get_type(v35);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v37 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v37, (int *)&v35, v14);
        int v12 = v37;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        int v12 = xpc::dyn_cast_or_default((xpc *)&v35, 0, (uint64_t)v14);
      }
      else
      {
        int v12 = 0;
      }
      xpc_release(v35);
      xpc_object_t object = &v36;
      uint64_t v34 = "second";
      sub_100048BAC((uint64_t)&object, &v35);
      xpc_type_t v15 = xpc_get_type(v35);
      if (v15 == (xpc_type_t)&_xpc_type_string)
      {
        int v37 = 0;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v37, (unsigned int *)&v35, v16);
        int v11 = v37;
      }
      else if (v15 == (xpc_type_t)&_xpc_type_BOOL {
             || v15 == (xpc_type_t)&_xpc_type_int64
      }
             || v15 == (xpc_type_t)&_xpc_type_uint64)
      {
        int v11 = xpc::dyn_cast_or_default((xpc *)&v35, 0, (uint64_t)v16);
      }
      else
      {
        int v11 = 0;
      }
      xpc_release(v35);
    }
    else
    {
      int v11 = 0;
      int v12 = 0;
    }
    xpc_release(v36);
    xpc_release(v9);
    char v17 = *v5;
    int v18 = (uint64_t **)(v3 + 8);
    size_t v19 = (uint64_t **)(v3 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          size_t v19 = (uint64_t **)v17;
          int v20 = *((_DWORD *)v17 + 7);
          if (v20 <= v12) {
            break;
          }
          char v17 = *v19;
          int v18 = v19;
          if (!*v19) {
            goto LABEL_54;
          }
        }
        if (v20 >= v12) {
          break;
        }
        char v17 = v19[1];
        if (!v17)
        {
          int v18 = v19 + 1;
          goto LABEL_54;
        }
      }
    }
    else
    {
LABEL_54:
      unsigned int v21 = (uint64_t *)operator new(0x28uLL);
      *((_DWORD *)v21 + 7) = v12;
      *((_DWORD *)v21 + 8) = v11;
      sub_100046C38((uint64_t **)v3, (uint64_t)v19, v18, v21);
    }
    goto LABEL_55;
  }
LABEL_57:
  xpc_release(v6);
  uint64_t v22 = (void (*)(void *, uint64_t **))v2[3];
  uint64_t v23 = v2[4];
  uint64_t v24 = (void *)(v2[2] + (v23 >> 1));
  if (v23) {
    uint64_t v22 = *(void (**)(void *, uint64_t **))(*v24 + v22);
  }
  v22(v24, &v26);
  sub_1000346F8((uint64_t)&v26, v27);
}

void sub_100A5455C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, xpc_object_t a13, xpc_object_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20,xpc_object_t a21)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a16);
  xpc_release(v21);
  sub_1000346F8((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100A5464C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A5468C()
{
}

void sub_100A5469C()
{
}

__n128 sub_100A546B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A312F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A54704(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A312F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A5473C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  xpc_object_t v9 = (char **)*v3;
  xpc_object_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1004CED98((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000886C0((uint64_t)&v9, v10);
}

void sub_100A547FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_100A54814(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A54854()
{
}

void sub_100A54864()
{
}

__n128 sub_100A54878(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A31370;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A548CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A54904(uint64_t a1)
{
  uint64_t v6 = **(void **)(a1 + 8);
  rest::read_rest_value();
  uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (void *)(*(void *)(a1 + 16) + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, uint64_t *))(*v4 + v2);
  }
  return v2(v4, &v6);
}

uint64_t sub_100A54988(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A549C8()
{
}

void sub_100A549D8()
{
}

__n128 sub_100A549EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A313F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A54A40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A313F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A54A78(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = a1[1];
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v24 = v25;
  sub_100314EF8((uint64_t)&v24, a2);
  uint64_t v5 = (void *)(v3 + 8);
  uint64_t v4 = *(void **)(v3 + 8);
  unsigned int v21 = *(uint64_t **)v3;
  uint64_t v22 = v4;
  uint64_t v23 = *(void *)(v3 + 16);
  if (v23)
  {
    void v4[2] = &v22;
    uint64_t v4 = 0;
    *(void *)uint64_t v3 = v5;
    void *v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    unsigned int v21 = (uint64_t *)&v22;
  }
  sub_1000346F8(v3, v4);
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  uint64_t v6 = v24;
  if (v24 == v25)
  {
    uint64_t v10 = 0;
  }
  else
  {
    do
    {
      uint64_t v26 = *(void *)((char *)v6 + 28);
      char v7 = BYTE5(v26);
      int v27 = &v26;
      *((unsigned char *)sub_10005CE78((uint64_t **)v3, (int *)&v26, (uint64_t)&unk_10144E20E, (_DWORD **)&v27) + 32) = v7;
      uint64_t v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          xpc_object_t v9 = (void **)v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          xpc_object_t v9 = (void **)v6[2];
          BOOL v13 = *v9 == v6;
          uint64_t v6 = v9;
        }
        while (!v13);
      }
      uint64_t v6 = v9;
    }
    while (v9 != v25);
    uint64_t v10 = *(void *)(v3 + 16);
  }
  if (v23 == v10)
  {
    int v11 = v21;
    if (v21 == (uint64_t *)&v22) {
      goto LABEL_36;
    }
    int v12 = *(uint64_t **)v3;
    while (1)
    {
      BOOL v13 = *((_DWORD *)v11 + 7) == *((_DWORD *)v12 + 7)
         && *((unsigned __int8 *)v11 + 32) == *((unsigned __int8 *)v12 + 32);
      if (!v13) {
        break;
      }
      char v14 = (uint64_t *)v11[1];
      xpc_type_t v15 = v11;
      if (v14)
      {
        do
        {
          int v11 = v14;
          char v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          int v11 = (uint64_t *)v15[2];
          BOOL v13 = *v11 == (void)v15;
          xpc_type_t v15 = v11;
        }
        while (!v13);
      }
      unsigned __int16 v16 = (uint64_t *)v12[1];
      if (v16)
      {
        do
        {
          char v17 = v16;
          unsigned __int16 v16 = (uint64_t *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          char v17 = (uint64_t *)v12[2];
          BOOL v13 = *v17 == (void)v12;
          int v12 = v17;
        }
        while (!v13);
      }
      int v12 = v17;
      if (v11 == (uint64_t *)&v22) {
        goto LABEL_36;
      }
    }
  }
  int v18 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v19 = a1[4];
  int v20 = (void *)(a1[2] + (v19 >> 1));
  if (v19) {
    int v18 = *(void (**)(void *, uint64_t **))(*v20 + v18);
  }
  v18(v20, &v21);
LABEL_36:
  sub_1000346F8((uint64_t)&v21, v22);
  sub_1000346F8((uint64_t)&v24, v25[0]);
}

void sub_100A54CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, void *a14)
{
}

uint64_t sub_100A54CE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A54D20()
{
}

void sub_100A54D30()
{
}

void *sub_100A54D44(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A31470;
  result[1] = v3;
  return result;
}

uint64_t sub_100A54D8C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A31470;
  a2[1] = v2;
  return result;
}

void sub_100A54DB8(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  char v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v27 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v27 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v27 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 7);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v25, (ctu::rest::detail *)v11, v12, v13);
      std::string __p = &v27;
      unsigned int v21 = "first";
      sub_100035E70((uint64_t)&__p, &v25, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v25);
      xpc_object_t v25 = 0;
      rest::write_rest_value((rest *)(v6 + 4), v14);
      std::string __p = &v27;
      unsigned int v21 = "second";
      sub_100035E70((uint64_t)&__p, &v23, &v24);
      xpc_release(v24);
      xpc_object_t v24 = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_object_t v15 = v27;
      if (v27) {
        xpc_retain(v27);
      }
      else {
        xpc_object_t v15 = xpc_null_create();
      }
      xpc_release(v27);
      xpc_array_append_value(v4, v15);
      xpc_release(v15);
      unsigned __int16 v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          char v17 = v16;
          unsigned __int16 v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          char v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          uint64_t v6 = v17;
        }
        while (!v18);
      }
      uint64_t v6 = v17;
    }
    while (v17 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v19 = v4;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/save_data_mode_user_preference");
  xpc_object_t v27 = v19;
  if (v19) {
    xpc_retain(v19);
  }
  else {
    xpc_object_t v27 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (v22 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
}

void sub_100A55080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100A55138(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A55178()
{
}

void sub_100A55188()
{
}

void *sub_100A5519C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A31500;
  result[1] = v3;
  return result;
}

uint64_t sub_100A551E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A31500;
  a2[1] = v2;
  return result;
}

void sub_100A55210(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/potential_interface_cost");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100A552B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_100A552F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A55338()
{
}

void sub_100A55348()
{
}

__n128 sub_100A5535C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A31580;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A553B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31580;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A553E8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  xpc_object_t v15 = 0;
  uint64_t v16 = 0;
  char v14 = &v15;
  sub_10008AAD8((uint64_t)&v14, a2);
  char v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  int v11 = (void **)*v3;
  uint64_t v12 = v5;
  if (v3[2])
  {
    void v5[2] = &v12;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v11 = &v12;
  }
  xpc_object_t v9 = v14;
  v10[0] = v15;
  v10[1] = v16;
  if (v16)
  {
    v15[2] = v10;
    char v14 = &v15;
    xpc_object_t v15 = 0;
    uint64_t v16 = 0;
  }
  else
  {
    xpc_object_t v9 = v10;
  }
  sub_100A555B4((uint64_t)v3, &v9);
  sub_100087F94((uint64_t)&v9, v10[0]);
  if (rest::operator!=())
  {
    uint64_t v6 = (void (*)(void *, void ***))a1[3];
    uint64_t v7 = a1[4];
    xpc_object_t v8 = (void *)(a1[2] + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
    }
    v6(v8, &v11);
  }
  sub_100087F94((uint64_t)&v11, v12);
  sub_100087F94((uint64_t)&v14, v15);
}

void sub_100A55528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, void *a14, uint64_t a15, char a16, void *a17)
{
}

uint64_t sub_100A55568(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A555A8()
{
}

void sub_100A555B4(uint64_t a1, void *a2)
{
  char v4 = (void *)(a1 + 8);
  sub_100087F94(a1, *(void **)(a1 + 8));
  *(void *)a1 = v4;
  *(void *)(a1 + 16) = 0;
  void *v4 = 0;
  uint64_t v7 = (void *)*a2;
  xpc_object_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    while (1)
    {
      int v8 = *((unsigned __int8 *)v6 + 40);
      int v9 = *((unsigned __int8 *)v6 + 41);
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v19 = 0;
      if (*((char *)v6 + 71) < 0)
      {
        sub_10004FC84(__dst, (void *)v6[6], v6[7]);
      }
      else
      {
        *(_OWORD *)long long __dst = *((_OWORD *)v6 + 3);
        uint64_t v19 = v6[8];
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v17 = 0;
      if (*((char *)v6 + 95) < 0)
      {
        sub_10004FC84(__p, (void *)v6[9], v6[10]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(v6 + 9);
        uint64_t v17 = v6[11];
      }
      if (v8 == 255 && !v9) {
        break;
      }
      if (v8) {
        goto LABEL_18;
      }
LABEL_19:
      if (SHIBYTE(v17) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v19) < 0) {
        operator delete(__dst[0]);
      }
      BOOL v13 = (void *)v6[1];
      if (v13)
      {
        do
        {
          char v14 = v13;
          BOOL v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          char v14 = (void *)v6[2];
          BOOL v15 = *v14 == (void)v6;
          uint64_t v6 = v14;
        }
        while (!v15);
      }
      uint64_t v6 = v14;
      if (v14 == v5) {
        return;
      }
    }
    xpc_object_t v10 = (void *)HIBYTE(v19);
    if (v19 < 0) {
      xpc_object_t v10 = __dst[1];
    }
    if (!v10)
    {
      int v11 = (void *)HIBYTE(v17);
      if (v17 < 0) {
        int v11 = __p[1];
      }
      if (!v11) {
        goto LABEL_19;
      }
    }
LABEL_18:
    int v20 = v6 + 4;
    uint64_t v12 = sub_100699824((uint64_t **)a1, (int *)v6 + 8, (uint64_t)&unk_10144E20E, &v20);
    *((_WORD *)v12 + 2ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *((_WORD *)v6 + 20);
    std::string::operator=((std::string *)v12 + 2, (const std::string *)v6 + 2);
    std::string::operator=((std::string *)v12 + 3, (const std::string *)v6 + 3);
    goto LABEL_19;
  }
}

void sub_100A55770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A557A8()
{
}

__n128 sub_100A557BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A31600;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A55810(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31600;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A55848(void *a1, uint64_t a2, uint64_t a3)
{
  char v4 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    return (*(uint64_t (**)(void))(*v6 + v4))();
  }
  else {
    return v4(v6, a3);
  }
}

uint64_t sub_100A55894(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A558D4()
{
}

void sub_100A558E4()
{
}

__n128 sub_100A558F8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A31680;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A5594C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31680;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A55984(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10031A644((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10030AAD0((uint64_t)&v9, v10);
}

void sub_100A55A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100A55A5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A55A9C()
{
}

void sub_100A55AAC()
{
}

__n128 sub_100A55AC0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A31700;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100A55B14(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A55B4C(void *a1, xpc_object_t *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = (uint64_t **)(v3 + 8);
  char v4 = *(void **)(v3 + 8);
  xpc_object_t v23 = *(uint64_t **)v3;
  xpc_object_t v24 = v4;
  if (*(void *)(v3 + 16))
  {
    void v4[2] = &v24;
    *(void *)uint64_t v3 = v5;
    void *v5 = 0;
    *(void *)(v3 + 16) = 0;
  }
  else
  {
    xpc_object_t v23 = (uint64_t *)&v24;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_1000346F8(v3, *(void **)(v3 + 8));
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)uint64_t v3 = v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    sub_100048BF4(&v29, &object, 0);
    xpc_release(object);
    xpc_object_t object = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    char v22 = v2;
    sub_100048BF4(v28, &object, count);
    xpc_release(object);
    for (uint64_t i = v30; ; uint64_t i = ++v30)
    {
      if (i == v28[1] && v29 == v28[0])
      {
        xpc_release(v29);
        xpc_release(v29);
        uint64_t v2 = v22;
        goto LABEL_48;
      }
      xpc_object_t v27 = 0;
      xpc_object_t object = &v29;
      uint64_t v32 = i;
      sub_10003FBDC((uint64_t)&object, &v27);
      if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_46:
      xpc_release(v27);
    }
    long long v26 = 0uLL;
    rest::BandwidthInfo::BandwidthInfo();
    xpc_object_t v9 = v27;
    if (v27)
    {
      xpc_retain(v27);
      xpc_object_t v34 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v34 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
      goto LABEL_30;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v34 = v10;
LABEL_30:
    if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t object = &v34;
      uint64_t v32 = "first";
      sub_100048BAC((uint64_t)&object, &v33);
      xpc_type_t type = xpc_get_type(v33);
      if (type == (xpc_type_t)&_xpc_type_string)
      {
        int v35 = v26;
        ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v35, (int *)&v33, v12);
        LODWORD(v26) = v35;
      }
      else if (type == (xpc_type_t)&_xpc_type_BOOL {
             || type == (xpc_type_t)&_xpc_type_int64
      }
             || type == (xpc_type_t)&_xpc_type_uint64)
      {
        LODWORD(v26) = xpc::dyn_cast_or_default((xpc *)&v33, 0, (uint64_t)v12);
      }
      xpc_release(v33);
      xpc_object_t object = &v34;
      uint64_t v32 = "second";
      sub_100048BAC((uint64_t)&object, &v33);
      rest::read_rest_value();
      xpc_release(v33);
      xpc_object_t v10 = v34;
    }
    xpc_release(v10);
    xpc_release(v9);
    int v13 = v26;
    char v14 = *v5;
    BOOL v15 = (uint64_t **)(v3 + 8);
    uint64_t v16 = (uint64_t **)(v3 + 8);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v16 = (uint64_t **)v14;
          int v17 = *((_DWORD *)v14 + 7);
          if (v17 <= (int)v26) {
            break;
          }
          char v14 = *v16;
          BOOL v15 = v16;
          if (!*v16) {
            goto LABEL_45;
          }
        }
        if (v17 >= (int)v26) {
          break;
        }
        char v14 = v16[1];
        if (!v14)
        {
          BOOL v15 = v16 + 1;
          goto LABEL_45;
        }
      }
    }
    else
    {
LABEL_45:
      BOOL v18 = operator new(0x30uLL);
      v18[7] = v13;
      *((void *)v18 + 4) = *(void *)((char *)&v26 + 4);
      v18[10] = HIDWORD(v26);
      sub_100046C38((uint64_t **)v3, (uint64_t)v16, v15, (uint64_t *)v18);
    }
    goto LABEL_46;
  }
LABEL_48:
  xpc_release(v6);
  uint64_t v19 = (void (*)(void *, uint64_t **))v2[3];
  uint64_t v20 = v2[4];
  unsigned int v21 = (void *)(v2[2] + (v20 >> 1));
  if (v20) {
    uint64_t v19 = *(void (**)(void *, uint64_t **))(*v21 + v19);
  }
  v19(v21, &v23);
  sub_1000346F8((uint64_t)&v23, v24);
}

void sub_100A55F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t a18, uint64_t a19, xpc_object_t object,uint64_t a21,xpc_object_t a22)
{
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(a18);
  xpc_release(v22);
  sub_1000346F8((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100A56078(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A560B8()
{
}

void sub_100A560C8()
{
}

__n128 sub_100A560DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A31780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A56130(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100A56168(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_100A561B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A561F0()
{
}

void sub_100A56200()
{
}

__n128 sub_100A56214(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A31800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100A56268(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100A562A0(void *a1)
{
  uint64_t v6 = 0;
  long long v8 = 0u;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v7 = &v8;
  rest::read_rest_value();
  uint64_t v2 = (void (*)(void *, void **))a1[2];
  uint64_t v3 = a1[3];
  char v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(void (**)(void *, void **))(*v4 + v2);
  }
  v2(v4, __p);
  sub_10010C0E0((uint64_t)&v7, (void *)v8);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100A56354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16)
{
  sub_10010C0E0(v16, a16);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100A5637C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A563BC()
{
}

void sub_100A563C8(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100A56440(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100A56454(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = (void *)a2[6];
  if (result) {
    __n128 result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100A564A0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_100A564F4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting...", buf, 2u);
  }
  sub_100A4AD28((capabilities::ct *)v1);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v1 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v6;
  xpc_object_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    std::mutex::unlock(v5);
    goto LABEL_25;
  }
  uint64_t v12 = v10[3];
  int v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12) {
      goto LABEL_24;
    }
  }
  else
  {
    std::mutex::unlock(v5);
    if (!v12) {
      goto LABEL_25;
    }
  }
  *(void *)long long buf = 0;
  (*(void (**)(uint8_t *__return_ptr, uint64_t, const __CFString *, void, const CFStringRef, const CFStringRef))(*(void *)v12 + 40))(v17, v12, @"OverriddenInexpensiveExpirationTime", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100201EE4(buf, (CFTypeRef *)v17);
  sub_1000577C4((const void **)v17);
  if (*(void *)buf) {
    int v13 = sub_1001908E4;
  }
  else {
    int v13 = 0;
  }
  if (v13)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)buf);
    if (AbsoluteTime >= CFAbsoluteTimeGetCurrent())
    {
      uint64_t v16 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v17 = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Restoring overridden interface cost timer", v17, 2u);
      }
      *(void *)int v17 = *(void *)buf;
      if (*(void *)buf) {
        CFRetain(*(CFTypeRef *)buf);
      }
      sub_100A4A5BC(v1, (CFDateRef *)v17);
      sub_10007CA64((const void **)v17);
    }
    else
    {
      sub_100A4AA38(v1, v15);
    }
  }
  sub_10007CA64((const void **)buf);
  if (!v11) {
LABEL_25:
  }
    operator delete();
LABEL_24:
  sub_10004D2C8(v11);
  goto LABEL_25;
}

void sub_100A5676C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_10007CA64((const void **)va);
  sub_10007CA64((const void **)va1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  operator delete();
}

uint64_t *sub_100A567E0(uint64_t **a1)
{
  uint64_t v2 = *a1;
  uint64_t v19 = a1;
  uint64_t v20 = v2;
  uint64_t v4 = *v2++;
  uint64_t v3 = v4;
  unsigned int v21 = (const char *)v2;
  char v22 = "kIsUpgrade";
  sub_100048BAC((uint64_t)&v21, object);
  int v6 = xpc::dyn_cast_or_default((xpc *)object, 0, v5);
  xpc_release(*(xpc_object_t *)object);
  unsigned int v21 = (const char *)v2;
  char v22 = "kIsRestore";
  sub_100048BAC((uint64_t)&v21, object);
  LODWORD(v2) = xpc::dyn_cast_or_default((xpc *)object, 0, v7);
  xpc_release(*(xpc_object_t *)object);
  if ((v6 | v2))
  {
    subscriber::makeSimSlotRange();
    unsigned int v9 = v21;
    uint64_t v8 = (unsigned int *)v22;
    if (v21 != v22)
    {
      xpc_object_t v10 = v23;
      while ((v10(*(unsigned int *)v9) & 1) == 0)
      {
        v9 += 4;
        if (v9 == (const char *)v8)
        {
          unsigned int v9 = (const char *)v8;
          break;
        }
      }
      int v11 = (unsigned int *)v22;
      if (v9 != v22)
      {
        do
        {
          uint64_t v12 = *(unsigned int *)v9;
          unsigned int PersistedLowDataMode_sync = (unsigned __int16)SaveDataModeController::getPersistedLowDataMode_sync(v3, v12);
          if (PersistedLowDataMode_sync <= 0x100) {
            LOBYTE(PersistedLowDataMode_sync) = 0;
          }
          if ((_BYTE)PersistedLowDataMode_sync)
          {
            unsigned __int16 v14 = sub_100A4B69C(v3, v12);
            if (v14 >= 0x100u && v14 == 0)
            {
              uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), v12);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)xpc_object_t object = 136315138;
                *(void *)&dispatch_object_t object[4] = "'cheap'";
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Migrating with Interface cost %s. Adjusting Low data mode to Off", object, 0xCu);
              }
              unint64_t v1 = v1 & 0xFFFFFFFFFFFF0000 | 0x100;
              sub_100A4C884(v3, v12, v1);
            }
          }
          int v17 = (unsigned int *)(v9 + 4);
          unsigned int v9 = (const char *)v8;
          if (v17 != v8)
          {
            unsigned int v9 = (const char *)v17;
            while ((v10(*(unsigned int *)v9) & 1) == 0)
            {
              v9 += 4;
              if (v9 == (const char *)v8)
              {
                unsigned int v9 = (const char *)v8;
                break;
              }
            }
          }
        }
        while (v9 != (const char *)v11);
      }
    }
  }
  sub_100A56AA0((uint64_t *)&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_100A56A3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100A56AA0(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(v1 + 16);
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = *(NSObject **)(v1 + 16);
      if (v3) {
        dispatch_release(v3);
      }
    }
    xpc_release(*(xpc_object_t *)(v1 + 8));
    *(void *)(v1 + 8) = 0;
    operator delete();
  }
  return result;
}

uint64_t *sub_100A56B10(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down...", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100A56B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100A56BB0(_DWORD **a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v10 = a1;
  int v11 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 240);
  if (!v2) {
    goto LABEL_11;
  }
  int v3 = v1[2];
  uint64_t v4 = *(void *)v1 + 240;
  do
  {
    int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      BOOL v7 = (uint64_t *)v2;
    }
    else {
      BOOL v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 != *(void *)v1 + 240 && *(_DWORD *)(v4 + 28) <= v3) {
    char v8 = *(unsigned char *)(v4 + 32) != 0;
  }
  else {
LABEL_11:
  }
    char v8 = 0;
  sub_1000607A8((uint64_t)(v1 + 4), v8);
  sub_10041EF98((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A56C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100A56C68(uint64_t **a1)
{
  int v3 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (sub_100A4C884(v2, *((unsigned int *)*a1 + 2), *((unsigned __int8 *)*a1 + 12) | 0x100u)) {
    SaveDataModeController::submitLowDataModeMetrics_sync(v2, *((_DWORD *)v1 + 2));
  }
  operator delete();
}

void sub_100A56CDC()
{
}

uint64_t sub_100A56D08(uint64_t a1)
{
  return SaveDataModeController::getSmartDataMode_sync(**(capabilities::ct ***)(a1 + 40), *(_DWORD *)(*(void *)(a1 + 40) + 8));
}

void sub_100A56D18(capabilities::ct ***a1)
{
  int v3 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (sub_100A4D298((uint64_t)v2, *((unsigned int *)*a1 + 2), *((unsigned __int8 *)*a1 + 12) | 0x100u)) {
    SaveDataModeController::submitSmartDataModeMetrics_sync(v2, *((_DWORD *)v1 + 2));
  }
  operator delete();
}

void sub_100A56D90()
{
}

BOOL sub_100A56DBC(uint64_t a1)
{
  return SaveDataModeController::isHighDataModeSupported_sync(**(void **)(a1 + 40), *(unsigned int *)(*(void *)(a1 + 40) + 8), *(uint64_t **)(a1 + 40));
}

uint64_t sub_100A56DCC(uint64_t a1)
{
  return SaveDataModeController::getInterfaceCostExpensive_sync(**(capabilities::ct ***)(a1 + 40), *(_DWORD *)(*(void *)(a1 + 40) + 8));
}

void sub_100A56DDC(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_100A4D8DC(**a1, *((unsigned int *)*a1 + 2), *((unsigned __int8 *)*a1 + 12) | 0x100, 1);
  operator delete();
}

void sub_100A56E40()
{
}

BOOL sub_100A56E6C(uint64_t a1)
{
  return *(void *)(**(void **)(a1 + 40) + 616) != 0;
}

void sub_100A56E84(uint64_t **a1)
{
  BOOL v6 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  sub_100058DB0(__p, "");
  sub_100A4DFB8((uint64_t)&v13, v2, (uint64_t)__p);
  if (SBYTE7(v10) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v3 = *(void *)(v2 + 616);
  if (*((unsigned char *)v1 + 8))
  {
    if (v3) {
      goto LABEL_14;
    }
    __p[0] = CFCalendarCopyCurrent();
    at[0] = CFAbsoluteTimeGetCurrent();
    CFCalendarAddComponents((CFCalendarRef)__p[0], at, 0, "d", 1);
    uint64_t v17 = 0;
    unsigned int v16 = 0;
    CFCalendarDecomposeAbsoluteTime((CFCalendarRef)__p[0], at[0], "yMd", (char *)&v17 + 4, &v17, &v16);
    CFCalendarComposeAbsoluteTime((CFCalendarRef)__p[0], at, "yMdHms", HIDWORD(v17), v17, v16, 5, 0, 0, v6);
    CFDateRef v12 = CFDateCreate(kCFAllocatorDefault, at[0]);
    sub_1006020EC((const void **)__p);
    sub_100A4A5BC(v2, &v12);
    sub_10007CA64((const void **)&v12);
  }
  else
  {
    if (!v3) {
      goto LABEL_14;
    }
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Dropping overridden interface cost timer", (uint8_t *)__p, 2u);
    }
    sub_100A4AA38(v2, v5);
  }
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)std::string __p = 0u;
  sub_100058DB0(at, "");
  sub_100A4DFB8((uint64_t)__p, v2, (uint64_t)at);
  if (v8 < 0) {
    operator delete(*(void **)&at[0]);
  }
  sub_100A4E5E8(v2, (uint64_t)&v13, (uint64_t)__p);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
LABEL_14:
  if (SHIBYTE(v14) < 0) {
    operator delete(*((void **)&v13 + 1));
  }
  operator delete();
}

void sub_100A570A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,int a24,__int16 a25,char a26,char a27,int a28,__int16 a29,char a30,char a31)
{
  sub_10007CA64((const void **)(v31 - 104));
  if (*(char *)(v31 - 65) < 0) {
    operator delete(*(void **)(v31 - 88));
  }
  operator delete();
}

void *sub_100A57150(void *a1)
{
  *a1 = off_101A31970;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100A5719C(void *a1)
{
  *a1 = off_101A31970;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100A57208(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A31970;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A5726C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A31970;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A572AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100A572BC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100A572FC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        v5[0] = 0;
        v5[1] = 0;
        sub_10003E168(v5, (void *)(v4 + 8));
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_100A57408(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A57448()
{
}

void sub_100A57454(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Overridden interface cost timer fired", buf, 2u);
  }
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)long long buf = 0u;
  sub_100058DB0(__p, "");
  sub_100A4DFB8((uint64_t)buf, v1, (uint64_t)__p);
  uint64_t v3 = (uint64_t *)SBYTE7(v8);
  if ((v3 & 0x80000000) != 0) {
    operator delete(__p[0]);
  }
  sub_100A4AA38(v1, v3);
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)std::string __p = 0u;
  sub_100058DB0(v5, "");
  sub_100A4DFB8((uint64_t)__p, v1, (uint64_t)v5);
  if (v6 < 0) {
    operator delete(v5[0]);
  }
  sub_100A4E5E8(v1, (uint64_t)buf, (uint64_t)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(*(void **)&buf[8]);
  }
  operator delete();
}

void sub_100A57598(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, int a18, __int16 a19, char a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  operator delete();
}

uint64_t *sub_100A57620(capabilities::ct ***a1)
{
  uint64_t v1 = *a1;
  BOOL v7 = a1;
  long long v8 = v1;
  uint64_t v2 = *v1;
  subscriber::makeSimSlotRange();
  uint64_t v4 = v9;
  if (v9 != (uint64_t *)v10)
  {
    while ((v11(*(unsigned int *)v4) & 1) == 0)
    {
      uint64_t v4 = (uint64_t *)((char *)v4 + 4);
      if (v4 == (uint64_t *)v10)
      {
        uint64_t v4 = (uint64_t *)v10;
        break;
      }
    }
LABEL_5:
    while (v4 != (uint64_t *)v10)
    {
      uint64_t v5 = *(unsigned int *)v4;
      sub_100A4C884((uint64_t)v2, v5, 0);
      if (sub_100A4D298((uint64_t)v2, v5, 0)) {
        SaveDataModeController::submitSmartDataModeMetrics_sync(v2, v5);
      }
      sub_100A4D8DC((uint64_t)v2, v5, 0, 1);
      uint64_t v3 = (uint64_t *)((char *)v4 + 4);
      uint64_t v4 = (uint64_t *)v10;
      if (v3 != (uint64_t *)v10)
      {
        uint64_t v4 = v3;
        while ((v11(*(unsigned int *)v4) & 1) == 0)
        {
          uint64_t v4 = (uint64_t *)((char *)v4 + 4);
          if (v4 == (uint64_t *)v10)
          {
            uint64_t v4 = (uint64_t *)v10;
            goto LABEL_5;
          }
        }
      }
    }
  }
  sub_100A4AA38((uint64_t)v2, v3);
  sub_100A4AD28(v2);
  sub_100088C88((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100A57748(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_100088C88((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A57770(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (uint64_t **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = *(void *)(a1 + 8);
      BOOL v7 = v3;
      if (*(uint64_t ***)a1 == v3) {
        goto LABEL_8;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      long long v9 = v3;
      if (v6)
      {
        do
        {
          BOOL v7 = (uint64_t **)v8;
          uint64_t v8 = *(void *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          BOOL v7 = (uint64_t **)v9[2];
          BOOL v10 = *v7 == (uint64_t *)v9;
          long long v9 = v7;
        }
        while (v10);
      }
      int v11 = *((_DWORD *)v5 + 7);
      if (*((_DWORD *)v7 + 7) < v11)
      {
LABEL_8:
        if (v6) {
          long long v12 = v7;
        }
        else {
          long long v12 = v3;
        }
        if (v6) {
          long long v13 = v7 + 1;
        }
        else {
          long long v13 = v3;
        }
        if (*v13) {
          goto LABEL_25;
        }
      }
      else
      {
        long long v13 = v3;
        long long v12 = v3;
        if (v6)
        {
          long long v14 = *(uint64_t **)(a1 + 8);
          while (1)
          {
            while (1)
            {
              long long v12 = (uint64_t **)v14;
              int v15 = *((_DWORD *)v14 + 7);
              if (v15 <= v11) {
                break;
              }
              long long v14 = *v12;
              long long v13 = v12;
              if (!*v12) {
                goto LABEL_24;
              }
            }
            if (v15 >= v11) {
              goto LABEL_25;
            }
            long long v14 = v12[1];
            if (!v14)
            {
              long long v13 = v12 + 1;
              break;
            }
          }
        }
      }
LABEL_24:
      unsigned int v16 = (uint64_t *)operator new(0x28uLL);
      *(uint64_t *)((char *)v16 + 28) = *(void *)((char *)v5 + 28);
      sub_100046C38((uint64_t **)a1, (uint64_t)v12, v13, v16);
LABEL_25:
      uint64_t v17 = (void *)v5[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v5[2];
          BOOL v10 = *v18 == (void)v5;
          uint64_t v5 = v18;
        }
        while (!v10);
      }
      uint64_t v5 = v18;
    }
    while (v18 != v4);
  }
  return a1;
}

void sub_100A578D4(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t **sub_100A578EC(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= a2) {
        return v7;
      }
      uint64_t v5 = v7[1];
    }
    while (v5);
    uint64_t v6 = v7 + 1;
  }
  else
  {
    BOOL v7 = a1 + 1;
  }
LABEL_10:
  long long v9 = (uint64_t *)operator new(0x28uLL);
  *((_DWORD *)v9 + 7) = *a3;
  rest::SaveDataModePreference::SaveDataModePreference((rest::SaveDataModePreference *)(v9 + 4), 0, 0, 1);
  sub_100046C38(a1, (uint64_t)v7, v6, v9);
  return (uint64_t **)v9;
}

void sub_100A579AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A579C0(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10005DF6C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A57A00(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_100A57A18(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  sub_100A57A70((char *)a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100A57A58(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *sub_100A57A70(char *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t *)(result + 8);
    do
    {
      __n128 result = sub_100A57AFC(v5, v6, v4 + 7, v4 + 7);
      BOOL v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          BOOL v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *sub_100A57AFC(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v6 = sub_10005CF3C(a1, a2, &v11, &v10, a3);
  BOOL v7 = (char *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    BOOL v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 28) = *a4;
    sub_100046C38(a1, (uint64_t)v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void sub_100A57B88(capabilities::ct ***a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = a1;
  uint64_t v2 = **a1;
  sub_100A51A54((uint64_t)v2, a2);
  SaveDataModeController::submitSmartDataModeMetrics_sync(v2, 3);
  operator delete();
}

void sub_100A57BF0()
{
}

void read_rest_value(uint64_t a1, xpc_object_t *a2)
{
  *(_WORD *)a1 = 0;
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v6 = &v9;
    BOOL v7 = "fThumperCapable";
    sub_100048BAC((uint64_t)&v6, &object);
    *(unsigned char *)a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, v4);
    xpc_release(object);
    uint64_t v6 = &v9;
    BOOL v7 = "fThumperEnabled";
    sub_100048BAC((uint64_t)&v6, &object);
    *(unsigned char *)(a1 + 1) = xpc::dyn_cast_or_default((xpc *)&object, 0, v5);
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_100A57D1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

void write_rest_value(BOOL *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v14 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v14 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v14 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v12 = xpc_BOOL_create(*a1);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  int v11 = "fThumperCapable";
  sub_100035E70((uint64_t)&v10, &v12, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v8 = xpc_BOOL_create(a1[1]);
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  uint64_t v10 = &v14;
  int v11 = "fThumperEnabled";
  sub_100035E70((uint64_t)&v10, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_object_t v7 = v14;
  *a2 = v14;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v14);
}

void sub_100A57F10(uint64_t a1, xpc_object_t *a2, void *a3, void *a4)
{
  xpc_object_t v8 = (void *)(a1 + 8);
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = v8;
  *(void *)(a1 + 16) = 0;
  *xpc_object_t v8 = 0;
  xpc_object_t v9 = *a2;
  if (*a2 && xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v9);
    object[0] = v9;
    goto LABEL_6;
  }
  xpc_object_t v9 = xpc_null_create();
  object[0] = v9;
  if (v9)
  {
LABEL_6:
    xpc_retain(v9);
    int v10 = 0;
    goto LABEL_7;
  }
  xpc_object_t v9 = 0;
  object[0] = xpc_null_create();
  int v10 = 1;
LABEL_7:
  sub_100048BF4(&v37, object, 0);
  xpc_release(object[0]);
  object[0] = v9;
  if (v10) {
    object[0] = xpc_null_create();
  }
  else {
    xpc_retain(v9);
  }
  xpc_object_t v24 = v9;
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array) {
    count = (void *)xpc_array_get_count(v9);
  }
  else {
    count = 0;
  }
  sub_100048BF4(v36, object, count);
  xpc_release(object[0]);
  for (uint64_t i = v38; i != v36[1] || v37 != v36[0]; uint64_t i = ++v38)
  {
    v35[0] = &v37;
    v35[1] = i;
    xpc_object_t v34 = 0;
    sub_10003FBDC((uint64_t)v35, &v34);
    if (xpc_get_type(v34) == (xpc_type_t)&_xpc_type_dictionary)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v33 = 0;
      object[0] = &v34;
      object[1] = a3;
      sub_100048BAC((uint64_t)object, v30);
      read_rest_value();
      xpc_release(v30[0]);
      v30[0] = &v34;
      v30[1] = a4;
      sub_100048BAC((uint64_t)v30, &v31);
      xpc_object_t v13 = v31;
      xpc_object_t v40 = v31;
      if (v31 && xpc_get_type(v31) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v13);
        xpc_object_t v14 = v40;
      }
      else
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t v40 = v14;
      }
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
      {
        object[0] = &v40;
        object[1] = "VoWiFiConfigSrc";
        sub_100048BAC((uint64_t)object, v39);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v39);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          v41[0] = 0;
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v41, v39, v19);
          int v17 = v41[0];
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          int v17 = xpc::dyn_cast_or_default((xpc *)v39, 0, (uint64_t)v19);
        }
        else
        {
          int v17 = 0;
        }
        xpc_release(*(xpc_object_t *)v39);
        object[0] = &v40;
        object[1] = "VolteFeatureSupport";
        sub_100048BAC((uint64_t)object, v39);
        xpc_type_t v20 = xpc_get_type(*(xpc_object_t *)v39);
        if (v20 == (xpc_type_t)&_xpc_type_string)
        {
          v41[0] = 0;
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v41, v39, v21);
          int v15 = v41[0];
        }
        else if (v20 == (xpc_type_t)&_xpc_type_BOOL {
               || v20 == (xpc_type_t)&_xpc_type_int64
        }
               || v20 == (xpc_type_t)&_xpc_type_uint64)
        {
          int v15 = xpc::dyn_cast_or_default((xpc *)v39, 0, (uint64_t)v21);
        }
        else
        {
          int v15 = 0;
        }
        xpc_release(*(xpc_object_t *)v39);
        object[0] = &v40;
        object[1] = "VoNRFeatureSupport";
        sub_100048BAC((uint64_t)object, v39);
        xpc_type_t v22 = xpc_get_type(*(xpc_object_t *)v39);
        if (v22 == (xpc_type_t)&_xpc_type_string)
        {
          v41[0] = 0;
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v41, v39, v23);
          int v16 = v41[0];
        }
        else if (v22 == (xpc_type_t)&_xpc_type_BOOL {
               || v22 == (xpc_type_t)&_xpc_type_int64
        }
               || v22 == (xpc_type_t)&_xpc_type_uint64)
        {
          int v16 = xpc::dyn_cast_or_default((xpc *)v39, 0, (uint64_t)v23);
        }
        else
        {
          int v16 = 0;
        }
        xpc_release(*(xpc_object_t *)v39);
      }
      else
      {
        int v15 = 0;
        int v16 = 0;
        int v17 = 0;
      }
      xpc_release(v40);
      xpc_release(v31);
      if (SHIBYTE(v33) < 0)
      {
        sub_10004FC84(object, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)xpc_object_t object = *(_OWORD *)__p;
        uint64_t v26 = v33;
      }
      int v27 = v15;
      int v28 = v16;
      int v29 = v17;
      sub_100A5AC14((uint64_t **)a1, object, (uint64_t)object);
      if (SHIBYTE(v26) < 0) {
        operator delete(object[0]);
      }
      if (SHIBYTE(v33) < 0) {
        operator delete(__p[0]);
      }
    }
    xpc_release(v34);
  }
  xpc_release(v37);
  xpc_release(v37);
  xpc_release(v24);
}

void sub_100A583B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, xpc_object_t a19, uint64_t a20,xpc_object_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,xpc_object_t a28,uint64_t a29,uint64_t a30,xpc_object_t a31)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v31 - 128));
  xpc_release(a10);
  _Unwind_Resume(a1);
}

void sub_100A584EC(void *a1@<X0>, const char *a2@<X1>, const char *a3@<X2>, xpc_object_t *a4@<X8>)
{
  xpc_object_t v8 = xpc_array_create(0, 0);
  if (v8 || (xpc_object_t v8 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v8);
      xpc_object_t v9 = v8;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v8 = 0;
  }
  xpc_release(v8);
  xpc_object_t v12 = (void *)*a1;
  int v10 = a1 + 1;
  int v11 = v12;
  if (v12 != v10)
  {
    do
    {
      xpc_object_t value = 0;
      xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v14 = v13;
      if (v13)
      {
        xpc_object_t value = v13;
      }
      else
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t value = v14;
        if (!v14)
        {
          xpc_object_t v15 = xpc_null_create();
          xpc_object_t v14 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v14);
        goto LABEL_16;
      }
      xpc_object_t v15 = xpc_null_create();
LABEL_15:
      xpc_object_t value = v15;
LABEL_16:
      xpc_release(v14);
      write_rest_value();
      p_xpc_object_t value = &value;
      BOOL v41 = a2;
      sub_100035E70((uint64_t)&p_value, &v33, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v17 = v16;
      if (v16)
      {
        xpc_object_t v44 = v16;
      }
      else
      {
        xpc_object_t v17 = xpc_null_create();
        xpc_object_t v44 = v17;
        if (!v17)
        {
          xpc_object_t v18 = xpc_null_create();
          xpc_object_t v17 = 0;
          goto LABEL_23;
        }
      }
      if (xpc_get_type(v17) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v18 = xpc_null_create();
LABEL_23:
        xpc_object_t v44 = v18;
        goto LABEL_24;
      }
      xpc_retain(v17);
LABEL_24:
      xpc_release(v17);
      int v19 = *((_DWORD *)v11 + 16);
      uint64_t v20 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v42, (ctu::rest::detail *)v19, v20, v21);
      p_xpc_object_t value = &v44;
      BOOL v41 = "VoWiFiConfigSrc";
      sub_100035E70((uint64_t)&p_value, &v42, &v43);
      xpc_release(v43);
      xpc_object_t v43 = 0;
      xpc_release(v42);
      xpc_object_t v42 = 0;
      int v22 = *((_DWORD *)v11 + 14);
      uint64_t v23 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v38, (ctu::rest::detail *)v22, v23, v24);
      p_xpc_object_t value = &v44;
      BOOL v41 = "VolteFeatureSupport";
      sub_100035E70((uint64_t)&p_value, &v38, &v39);
      xpc_release(v39);
      xpc_object_t v39 = 0;
      xpc_release(v38);
      xpc_object_t v38 = 0;
      int v25 = *((_DWORD *)v11 + 15);
      uint64_t v26 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v36, (ctu::rest::detail *)v25, v26, v27);
      p_xpc_object_t value = &v44;
      BOOL v41 = "VoNRFeatureSupport";
      sub_100035E70((uint64_t)&p_value, &v36, &v37);
      xpc_release(v37);
      xpc_object_t v37 = 0;
      xpc_release(v36);
      xpc_object_t v36 = 0;
      xpc_object_t v31 = v44;
      if (v44) {
        xpc_retain(v44);
      }
      else {
        xpc_object_t v31 = xpc_null_create();
      }
      xpc_release(v44);
      p_xpc_object_t value = &value;
      BOOL v41 = a3;
      sub_100035E70((uint64_t)&p_value, &v31, &v32);
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_release(v31);
      xpc_object_t v31 = 0;
      xpc_array_append_value(v9, value);
      xpc_release(value);
      int v28 = (void *)v11[1];
      if (v28)
      {
        do
        {
          int v29 = v28;
          int v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v29 = (void *)v11[2];
          BOOL v30 = *v29 == (void)v11;
          int v11 = v29;
        }
        while (!v30);
      }
      int v11 = v29;
    }
    while (v29 != v10);
  }
  *a4 = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    *a4 = xpc_null_create();
  }
  xpc_release(v9);
}

void sub_100A588F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100A5892C(uint64_t a1, xpc_object_t *a2, void *a3, void *a4)
{
  xpc_object_t v6 = (void *)(a1 + 8);
  sub_1007035FC(a1, *(void **)(a1 + 8));
  *(void *)a1 = v6;
  *(void *)(a1 + 16) = 0;
  void *v6 = 0;
  xpc_object_t v7 = *a2;
  if (*a2 && xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v7);
    object[0] = v7;
    goto LABEL_6;
  }
  xpc_object_t v7 = xpc_null_create();
  object[0] = v7;
  if (v7)
  {
LABEL_6:
    xpc_retain(v7);
    int v8 = 0;
    goto LABEL_7;
  }
  xpc_object_t v7 = 0;
  object[0] = xpc_null_create();
  int v8 = 1;
LABEL_7:
  sub_100048BF4(&v36, object, 0);
  xpc_release(object[0]);
  object[0] = v7;
  if (v8) {
    object[0] = xpc_null_create();
  }
  else {
    xpc_retain(v7);
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array) {
    count = (void *)xpc_array_get_count(v7);
  }
  else {
    count = 0;
  }
  sub_100048BF4(v35, object, count);
  xpc_release(object[0]);
  for (uint64_t i = v37; i != v35[1] || v36 != v35[0]; uint64_t i = ++v37)
  {
    v34[0] = &v36;
    v34[1] = i;
    xpc_object_t v33 = 0;
    sub_10003FBDC((uint64_t)v34, &v33);
    if (xpc_get_type(v33) == (xpc_type_t)&_xpc_type_dictionary)
    {
      v31[0] = 0;
      v31[1] = 0;
      uint64_t v32 = 0;
      uint64_t v30 = 0;
      *(_OWORD *)int v28 = 0u;
      long long v29 = 0u;
      BYTE4(v28[0]) = 1;
      object[0] = &v33;
      object[1] = a3;
      sub_100048BAC((uint64_t)object, v26);
      read_rest_value();
      xpc_release(v26[0]);
      v26[0] = &v33;
      v26[1] = a4;
      sub_100048BAC((uint64_t)v26, &v27);
      LODWORD(object[0]) = 0;
      BYTE4(object[0]) = 1;
      LOBYTE(object[1]) = 0;
      LOBYTE(__p) = 0;
      LODWORD(v28[0]) = 0;
      BYTE4(v28[0]) = 1;
      sub_100179CB0((uint64_t)&v28[1], (__n128 *)&object[1]);
      if ((_BYTE)__p && v22 < 0) {
        operator delete(object[1]);
      }
      xpc_object_t v11 = v27;
      xpc_object_t v39 = v27;
      if (v27 && xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v11);
        xpc_object_t v12 = v39;
      }
      else
      {
        xpc_object_t v12 = xpc_null_create();
        xpc_object_t v39 = v12;
      }
      if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
      {
        object[0] = &v39;
        object[1] = "config";
        sub_100048BAC((uint64_t)object, v38);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v38);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          v40[0] = (int)v28[0];
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v40, v38, v14);
          LODWORD(v28[0]) = v40[0];
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(v28[0]) = xpc::dyn_cast_or_default((xpc *)v38, 0, (uint64_t)v14);
        }
        xpc_release(*(xpc_object_t *)v38);
        object[0] = &v39;
        object[1] = "preferInRoaming";
        sub_100048BAC((uint64_t)object, v38);
        BYTE4(v28[0]) = xpc::dyn_cast_or_default((xpc *)v38, 0, v15);
        xpc_release(*(xpc_object_t *)v38);
        object[0] = &v39;
        object[1] = "thumperId";
        if (xpc_dictionary_get_value(v39, "thumperId"))
        {
          sub_100048BAC((uint64_t)object, v38);
          sub_10008BD58((uint64_t)&v28[1], (xpc_object_t *)v38);
          xpc_release(*(xpc_object_t *)v38);
        }
      }
      xpc_release(v39);
      xpc_release(v27);
      if (SHIBYTE(v32) < 0)
      {
        sub_10004FC84(object, v31[0], (unint64_t)v31[1]);
      }
      else
      {
        *(_OWORD *)xpc_object_t object = *(_OWORD *)v31;
        uint64_t v19 = v32;
      }
      int v20 = (int)v28[0];
      char v21 = BYTE4(v28[0]);
      sub_1000593FC((uint64_t)&__p, (long long *)&v28[1]);
      sub_100A5ADA8((uint64_t **)a1, object, (long long *)object);
      if (v25 && v24 < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v19) < 0) {
        operator delete(object[0]);
      }
      if ((_BYTE)v30 && SHIBYTE(v29) < 0) {
        operator delete(v28[1]);
      }
      if (SHIBYTE(v32) < 0) {
        operator delete(v31[0]);
      }
    }
    xpc_release(v33);
  }
  xpc_release(v36);
  xpc_release(v36);
  xpc_release(v7);
}

void sub_100A58DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, xpc_object_t object, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,xpc_object_t a25,uint64_t a26,xpc_object_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v42 - 128));
  xpc_release(a10);
  _Unwind_Resume(a1);
}

void sub_100A58F1C(void *a1@<X0>, const char *a2@<X1>, const char *a3@<X2>, xpc_object_t *a4@<X8>)
{
  xpc_object_t v8 = xpc_array_create(0, 0);
  if (v8 || (xpc_object_t v8 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v8);
      xpc_object_t v9 = v8;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v8 = 0;
  }
  xpc_release(v8);
  xpc_object_t v12 = (void *)*a1;
  int v10 = a1 + 1;
  xpc_object_t v11 = v12;
  if (v12 != v10)
  {
    do
    {
      xpc_object_t value = 0;
      xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v14 = v13;
      if (v13)
      {
        xpc_object_t value = v13;
      }
      else
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t value = v14;
        if (!v14)
        {
          xpc_object_t v15 = xpc_null_create();
          xpc_object_t v14 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v14);
        goto LABEL_16;
      }
      xpc_object_t v15 = xpc_null_create();
LABEL_15:
      xpc_object_t value = v15;
LABEL_16:
      xpc_release(v14);
      write_rest_value();
      p_xpc_object_t value = &value;
      xpc_object_t v36 = a2;
      sub_100035E70((uint64_t)&p_value, &v28, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v28);
      xpc_object_t v28 = 0;
      xpc_object_t v39 = 0;
      xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v17 = v16;
      if (v16)
      {
        xpc_object_t v39 = v16;
      }
      else
      {
        xpc_object_t v17 = xpc_null_create();
        xpc_object_t v39 = v17;
        if (!v17)
        {
          xpc_object_t v18 = xpc_null_create();
          xpc_object_t v17 = 0;
          goto LABEL_23;
        }
      }
      if (xpc_get_type(v17) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v18 = xpc_null_create();
LABEL_23:
        xpc_object_t v39 = v18;
        goto LABEL_24;
      }
      xpc_retain(v17);
LABEL_24:
      xpc_release(v17);
      int v19 = *((_DWORD *)v11 + 14);
      uint64_t v20 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v37, (ctu::rest::detail *)v19, v20, v21);
      p_xpc_object_t value = &v39;
      xpc_object_t v36 = "config";
      sub_100035E70((uint64_t)&p_value, &v37, &v38);
      xpc_release(v38);
      xpc_object_t v38 = 0;
      xpc_release(v37);
      xpc_object_t v37 = 0;
      xpc_object_t v33 = xpc_BOOL_create(*((unsigned char *)v11 + 60));
      if (!v33) {
        xpc_object_t v33 = xpc_null_create();
      }
      p_xpc_object_t value = &v39;
      xpc_object_t v36 = "preferInRoaming";
      sub_100035E70((uint64_t)&p_value, &v33, &v34);
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_release(v33);
      xpc_object_t v33 = 0;
      if (*((unsigned char *)v11 + 88))
      {
        if (*((char *)v11 + 87) >= 0) {
          char v22 = (const char *)(v11 + 8);
        }
        else {
          char v22 = (const char *)v11[8];
        }
        xpc_object_t v31 = xpc_string_create(v22);
        if (!v31) {
          xpc_object_t v31 = xpc_null_create();
        }
        p_xpc_object_t value = &v39;
        xpc_object_t v36 = "thumperId";
        sub_100035E70((uint64_t)&p_value, &v31, &v32);
        xpc_release(v32);
        xpc_object_t v32 = 0;
        xpc_release(v31);
        xpc_object_t v31 = 0;
      }
      xpc_object_t v26 = v39;
      if (v39) {
        xpc_retain(v39);
      }
      else {
        xpc_object_t v26 = xpc_null_create();
      }
      xpc_release(v39);
      p_xpc_object_t value = &value;
      xpc_object_t v36 = a3;
      sub_100035E70((uint64_t)&p_value, &v26, &v27);
      xpc_release(v27);
      xpc_object_t v27 = 0;
      xpc_release(v26);
      xpc_object_t v26 = 0;
      xpc_array_append_value(v9, value);
      xpc_release(value);
      uint64_t v23 = (void *)v11[1];
      if (v23)
      {
        do
        {
          char v24 = v23;
          uint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          char v24 = (void *)v11[2];
          BOOL v25 = *v24 == (void)v11;
          xpc_object_t v11 = v24;
        }
        while (!v25);
      }
      xpc_object_t v11 = v24;
    }
    while (v24 != v10);
  }
  *a4 = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    *a4 = xpc_null_create();
  }
  xpc_release(v9);
}

void sub_100A59348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v15);
  _Unwind_Resume(a1);
}

void sub_100A59380(uint64_t a1, xpc_object_t *a2, void *a3, void *a4)
{
  xpc_object_t v8 = (void *)(a1 + 8);
  sub_10005CD2C(a1, *(char **)(a1 + 8));
  *(void *)a1 = v8;
  *(void *)(a1 + 16) = 0;
  *xpc_object_t v8 = 0;
  xpc_object_t v9 = *a2;
  if (v9 && xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v9);
    object[0] = v9;
    goto LABEL_6;
  }
  xpc_object_t v9 = xpc_null_create();
  object[0] = v9;
  if (v9)
  {
LABEL_6:
    xpc_retain(v9);
    int v10 = 0;
    goto LABEL_7;
  }
  xpc_object_t v9 = 0;
  object[0] = xpc_null_create();
  int v10 = 1;
LABEL_7:
  sub_100048BF4(&v24, object, 0);
  xpc_release(object[0]);
  object[0] = v9;
  if (v10) {
    object[0] = xpc_null_create();
  }
  else {
    xpc_retain(v9);
  }
  if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array) {
    count = (void *)xpc_array_get_count(v9);
  }
  else {
    count = 0;
  }
  sub_100048BF4(v23, object, count);
  xpc_release(object[0]);
  for (uint64_t i = v25; i != v23[1] || v24 != v23[0]; uint64_t i = ++v25)
  {
    v22[0] = &v24;
    v22[1] = i;
    xpc_object_t v21 = 0;
    sub_10003FBDC((uint64_t)v22, &v21);
    if (xpc_get_type(v21) == (xpc_type_t)&_xpc_type_dictionary)
    {
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v20 = 0;
      object[0] = &v21;
      object[1] = a3;
      sub_100048BAC((uint64_t)object, &v18);
      read_rest_value();
      xpc_release(v18);
      object[0] = &v21;
      object[1] = a4;
      sub_100048BAC((uint64_t)object, &v18);
      char v14 = xpc::dyn_cast_or_default((xpc *)&v18, 0, v13);
      xpc_release(v18);
      if (SHIBYTE(v20) < 0)
      {
        sub_10004FC84(object, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)xpc_object_t object = *(_OWORD *)__p;
        uint64_t v16 = v20;
      }
      char v17 = v14;
      sub_10025675C((uint64_t **)a1, object, (uint64_t)object);
      if (SHIBYTE(v16) < 0) {
        operator delete(object[0]);
      }
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
    }
    xpc_release(v21);
  }
  xpc_release(v24);
  xpc_release(v24);
  xpc_release(v9);
}

void sub_100A595F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, xpc_object_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,xpc_object_t a24,uint64_t a25,uint64_t a26,xpc_object_t a27)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v28 - 80));
  xpc_release(v27);
  _Unwind_Resume(a1);
}

void sub_100A596C4(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, xpc_object_t *a4@<X8>)
{
  xpc_object_t v8 = xpc_array_create(0, 0);
  if (v8 || (xpc_object_t v8 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v8);
      xpc_object_t v9 = v8;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v9 = xpc_null_create();
    xpc_object_t v8 = 0;
  }
  xpc_release(v8);
  xpc_object_t v12 = (void *)*a1;
  int v10 = a1 + 1;
  xpc_object_t v11 = v12;
  if (v12 != v10)
  {
    do
    {
      xpc_object_t value = 0;
      xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v14 = v13;
      if (v13)
      {
        xpc_object_t value = v13;
      }
      else
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t value = v14;
        if (!v14)
        {
          xpc_object_t v15 = xpc_null_create();
          xpc_object_t v14 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v15 = xpc_null_create();
LABEL_15:
        xpc_object_t value = v15;
        goto LABEL_16;
      }
      xpc_retain(v14);
LABEL_16:
      xpc_release(v14);
      write_rest_value();
      p_xpc_object_t value = &value;
      uint64_t v22 = a2;
      sub_100035E70((uint64_t)&p_value, &v23, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_object_t v19 = xpc_BOOL_create(*((unsigned char *)v11 + 56));
      if (!v19) {
        xpc_object_t v19 = xpc_null_create();
      }
      p_xpc_object_t value = &value;
      uint64_t v22 = a3;
      sub_100035E70((uint64_t)&p_value, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_array_append_value(v9, value);
      xpc_release(value);
      uint64_t v16 = (void *)v11[1];
      if (v16)
      {
        do
        {
          char v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          char v17 = (void *)v11[2];
          BOOL v18 = *v17 == (void)v11;
          xpc_object_t v11 = v17;
        }
        while (!v18);
      }
      xpc_object_t v11 = v17;
    }
    while (v17 != v10);
  }
  *a4 = v9;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    *a4 = xpc_null_create();
  }
  xpc_release(v9);
}

void sub_100A59934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v16);
  _Unwind_Resume(a1);
}

uint64_t asString@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  *(_OWORD *)xpc_object_t v33 = 0u;
  long long v34 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v31 = 0u;
  sub_10004BD84((uint64_t)&v31);
  sub_10004B96C(v32, (uint64_t)"[", 1);
  xpc_object_t v5 = (void *)*a1;
  xpc_object_t v3 = a1 + 1;
  xpc_object_t v4 = v5;
  if (v5 != v3)
  {
    do
    {
      sub_10004B96C(v32, (uint64_t)"(category ", 10);
      xpc_object_t v7 = (void *)std::ostream::operator<<();
      xpc_object_t v8 = sub_10004B96C(v7, (uint64_t)": ", 2);
      xpc_object_t v9 = v6;
      uint64_t v60 = 0;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      memset(v47, 0, sizeof(v47));
      long long v46 = 0u;
      sub_10004BD84((uint64_t)&v46);
      if (*((unsigned char *)v4 + 40)) {
        int v10 = "on";
      }
      else {
        int v10 = "off";
      }
      if (*((unsigned char *)v4 + 40)) {
        uint64_t v11 = 2;
      }
      else {
        uint64_t v11 = 3;
      }
      xpc_object_t v12 = sub_10004B96C(v47, (uint64_t)v10, v11);
      xpc_object_t v13 = sub_10004B96C(v12, (uint64_t)"[", 1);
      xpc_object_t v14 = (const char *)asString();
      size_t v15 = strlen(v14);
      uint64_t v16 = sub_10004B96C(v13, (uint64_t)v14, v15);
      sub_10004B96C(v16, (uint64_t)"]", 1);
      sub_10004BC98((uint64_t)&v47[1], v29);
      *(void *)&long long v46 = v28;
      *(void *)((char *)&v47[-2] + *(v28 - 3)) = v27;
      v47[0] = v26;
      if (SHIBYTE(v49) < 0) {
        operator delete(*((void **)&v48 + 1));
      }
      std::streambuf::~streambuf();
      xpc_object_t v6 = v9;
      std::iostream::~basic_iostream();
      std::ios::~ios();
      if ((v30 & 0x80u) == 0) {
        char v17 = v29;
      }
      else {
        char v17 = (void **)v29[0];
      }
      if ((v30 & 0x80u) == 0) {
        uint64_t v18 = v30;
      }
      else {
        uint64_t v18 = (uint64_t)v29[1];
      }
      xpc_object_t v19 = sub_10004B96C(v8, (uint64_t)v17, v18);
      sub_10004B96C(v19, (uint64_t)"),", 2);
      if ((char)v30 < 0) {
        operator delete(v29[0]);
      }
      xpc_object_t v20 = (void *)v4[1];
      if (v20)
      {
        do
        {
          xpc_object_t v21 = v20;
          xpc_object_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          xpc_object_t v21 = (void *)v4[2];
          BOOL v22 = *v21 == (void)v4;
          xpc_object_t v4 = v21;
        }
        while (!v22);
      }
      xpc_object_t v4 = v21;
    }
    while (v21 != v3);
  }
  sub_10004B96C(v32, (uint64_t)"]", 1);
  sub_10004BC98((uint64_t)v32 + 8, a2);
  *(void *)&long long v31 = *v6;
  xpc_object_t v23 = v6[9];
  *(void *)((char *)&v32[-1] + *(void *)(v31 - 24)) = v6[8];
  *(void *)&v32[0] = v23;
  if (SHIBYTE(v34) < 0) {
    operator delete(v33[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100A59DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
}

void sub_100A59E10(uint64_t a1, xpc_object_t *a2, void *a3, uint64_t a4)
{
  xpc_object_t v6 = (void *)(a1 + 8);
  sub_100313534(a1, *(void **)(a1 + 8));
  *(void *)a1 = v6;
  *(void *)(a1 + 16) = 0;
  void *v6 = 0;
  xpc_object_t v7 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_retain(v7);
    object[0] = v7;
    goto LABEL_6;
  }
  xpc_object_t v7 = xpc_null_create();
  object[0] = v7;
  if (v7)
  {
LABEL_6:
    xpc_retain(v7);
    int v8 = 0;
    goto LABEL_7;
  }
  xpc_object_t v7 = 0;
  object[0] = xpc_null_create();
  int v8 = 1;
LABEL_7:
  sub_100048BF4(&v39, object, 0);
  xpc_release(object[0]);
  object[0] = v7;
  if (v8) {
    object[0] = xpc_null_create();
  }
  else {
    xpc_retain(v7);
  }
  if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array) {
    count = (void *)xpc_array_get_count(v7);
  }
  else {
    count = 0;
  }
  sub_100048BF4(v38, object, count);
  xpc_release(object[0]);
  for (uint64_t i = v40; i != v38[1] || v39 != v38[0]; uint64_t i = ++v40)
  {
    v37[0] = &v39;
    v37[1] = i;
    xpc_object_t v36 = 0;
    sub_10003FBDC((uint64_t)v37, &v36);
    if (xpc_get_type(v36) != (xpc_type_t)&_xpc_type_dictionary) {
      goto LABEL_56;
    }
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v35 = 0;
    xpc_object_t v32 = 0;
    uint64_t v33 = 0;
    long long v31 = (uint64_t *)&v32;
    object[0] = &v36;
    object[1] = a3;
    sub_100048BAC((uint64_t)object, &v46);
    read_rest_value();
    xpc_release(v46);
    v29[0] = &v36;
    v29[1] = a4;
    sub_100048BAC((uint64_t)v29, &v30);
    sub_1000346F8((uint64_t)&v31, v32);
    xpc_object_t v32 = 0;
    uint64_t v33 = 0;
    long long v31 = (uint64_t *)&v32;
    xpc_object_t v11 = v30;
    if (v30 && xpc_get_type(v30) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v11);
      object[0] = v11;
    }
    else
    {
      xpc_object_t v11 = xpc_null_create();
      object[0] = v11;
      if (!v11)
      {
        xpc_object_t v11 = 0;
        object[0] = xpc_null_create();
        int v12 = 1;
        goto LABEL_23;
      }
    }
    xpc_retain(v11);
    int v12 = 0;
LABEL_23:
    sub_100048BF4(&v46, object, 0);
    xpc_release(object[0]);
    object[0] = v11;
    if (v12) {
      object[0] = xpc_null_create();
    }
    else {
      xpc_retain(v11);
    }
    if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array) {
      xpc_object_t v13 = (void *)xpc_array_get_count(v11);
    }
    else {
      xpc_object_t v13 = 0;
    }
    sub_100048BF4(v45, object, v13);
    xpc_release(object[0]);
    for (uint64_t j = v47; j != v45[1] || v46 != v45[0]; uint64_t j = ++v47)
    {
      v44[0] = &v46;
      v44[1] = j;
      xpc_object_t v43 = 0;
      sub_10003FBDC((uint64_t)v44, &v43);
      if (xpc_get_type(v43) == (xpc_type_t)&_xpc_type_dictionary)
      {
        object[0] = &v43;
        object[1] = "AppCategoryID";
        sub_100048BAC((uint64_t)object, v41);
        uint64_t v16 = (void *)xpc::dyn_cast_or_default((xpc *)v41, 0, v15);
        xpc_release(v41[0]);
        v41[0] = &v43;
        v41[1] = "State";
        sub_100048BAC((uint64_t)v41, &v42);
        xpc_object_t v17 = v42;
        xpc_object_t v49 = v42;
        if (v42 && xpc_get_type(v42) == (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_retain(v17);
        }
        else
        {
          xpc_object_t v17 = xpc_null_create();
          xpc_object_t v49 = v17;
        }
        if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_dictionary)
        {
          object[0] = &v49;
          object[1] = "state";
          sub_100048BAC((uint64_t)object, v48);
          unsigned int v21 = xpc::dyn_cast_or_default((xpc *)v48, 0, v20);
          xpc_release(*(xpc_object_t *)v48);
          object[0] = &v49;
          object[1] = "rawState";
          sub_100048BAC((uint64_t)object, v48);
          xpc_type_t type = xpc_get_type(*(xpc_object_t *)v48);
          if (type == (xpc_type_t)&_xpc_type_string)
          {
            v50[0] = 0;
            ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v50, v48, v23);
            uint64_t v18 = v50[0];
          }
          else if (type == (xpc_type_t)&_xpc_type_BOOL {
                 || type == (xpc_type_t)&_xpc_type_int64
          }
                 || type == (xpc_type_t)&_xpc_type_uint64)
          {
            uint64_t v18 = xpc::dyn_cast_or_default((xpc *)v48, 0, (uint64_t)v23);
          }
          else
          {
            uint64_t v18 = 0;
          }
          xpc_release(*(xpc_object_t *)v48);
          uint64_t v19 = v21;
          xpc_object_t v17 = v49;
        }
        else
        {
          uint64_t v18 = 0;
          uint64_t v19 = 0;
        }
        xpc_release(v17);
        xpc_release(v42);
        object[0] = v16;
        object[1] = (xpc_object_t)(v19 | (v18 << 32));
        sub_100A5AFA8(&v31, (unint64_t *)object, object);
      }
      xpc_release(v43);
    }
    xpc_release(v46);
    xpc_release(v46);
    xpc_release(v11);
    xpc_release(v30);
    if (SHIBYTE(v35) < 0)
    {
      sub_10004FC84(object, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)xpc_object_t object = *(_OWORD *)__p;
      uint64_t v27 = v35;
    }
    sub_100A5B240(v28, (uint64_t)&v31);
    sub_100A5B0A4((uint64_t **)a1, object, (long long *)object);
    sub_1000346F8((uint64_t)v28, (void *)v28[1]);
    if (SHIBYTE(v27) < 0) {
      operator delete(object[0]);
    }
    sub_1000346F8((uint64_t)&v31, v32);
    if (SHIBYTE(v35) < 0) {
      operator delete(__p[0]);
    }
LABEL_56:
    xpc_release(v36);
  }
  xpc_release(v39);
  xpc_release(v39);
  xpc_release(v7);
}

void sub_100A5A3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,char a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,xpc_object_t a36,uint64_t a37,uint64_t a38,xpc_object_t a39,uint64_t a40,xpc_object_t a41)
{
}

void sub_100A5A5CC(void *a1@<X0>, const char *a2@<X1>, const char *a3@<X2>, xpc_object_t *a4@<X8>)
{
  xpc_object_t v6 = xpc_array_create(0, 0);
  if (v6 || (xpc_object_t v6 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v6);
      xpc_object_t v7 = v6;
    }
    else
    {
      xpc_object_t v7 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v7 = xpc_null_create();
    xpc_object_t v6 = 0;
  }
  xpc_release(v6);
  int v8 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    xpc_object_t v29 = v7;
    do
    {
      xpc_object_t v36 = 0;
      xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v10 = v9;
      if (v9)
      {
        xpc_object_t v36 = v9;
      }
      else
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v36 = v10;
        if (!v10)
        {
          xpc_object_t v11 = xpc_null_create();
          xpc_object_t v10 = 0;
          goto LABEL_16;
        }
      }
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v11 = xpc_null_create();
LABEL_16:
        xpc_object_t v36 = v11;
        goto LABEL_17;
      }
      xpc_retain(v10);
LABEL_17:
      xpc_release(v10);
      write_rest_value();
      p_xpc_object_t value = &v36;
      uint64_t v45 = a2;
      sub_100035E70((uint64_t)&p_value, &v34, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v34);
      xpc_object_t v34 = 0;
      xpc_object_t v12 = xpc_array_create(0, 0);
      if (v12 || (xpc_object_t v12 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v12);
          xpc_object_t v13 = v12;
        }
        else
        {
          xpc_object_t v13 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v13 = xpc_null_create();
        xpc_object_t v12 = 0;
      }
      xpc_release(v12);
      xpc_object_t v14 = (void *)v8[7];
      if (v14 != v8 + 8)
      {
        do
        {
          xpc_object_t value = 0;
          xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v16 = v15;
          if (v15)
          {
            xpc_object_t value = v15;
          }
          else
          {
            xpc_object_t v16 = xpc_null_create();
            xpc_object_t value = v16;
            if (!v16)
            {
              xpc_object_t v17 = xpc_null_create();
              xpc_object_t v16 = 0;
              goto LABEL_31;
            }
          }
          if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v16);
            goto LABEL_32;
          }
          xpc_object_t v17 = xpc_null_create();
LABEL_31:
          xpc_object_t value = v17;
LABEL_32:
          xpc_release(v16);
          xpc_object_t v39 = xpc_uint64_create(v14[4]);
          if (!v39) {
            xpc_object_t v39 = xpc_null_create();
          }
          p_xpc_object_t value = &value;
          uint64_t v45 = "AppCategoryID";
          sub_100035E70((uint64_t)&p_value, &v39, &v40);
          xpc_release(v40);
          xpc_object_t v40 = 0;
          xpc_release(v39);
          xpc_object_t v39 = 0;
          xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v19 = v18;
          if (v18)
          {
            v48[0] = v18;
          }
          else
          {
            xpc_object_t v19 = xpc_null_create();
            v48[0] = v19;
            if (!v19)
            {
              xpc_object_t v20 = xpc_null_create();
              xpc_object_t v19 = 0;
              goto LABEL_41;
            }
          }
          if (xpc_get_type(v19) != (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_object_t v20 = xpc_null_create();
LABEL_41:
            v48[0] = v20;
            goto LABEL_42;
          }
          xpc_retain(v19);
LABEL_42:
          xpc_release(v19);
          xpc_object_t v46 = xpc_BOOL_create(*((unsigned char *)v14 + 40));
          if (!v46) {
            xpc_object_t v46 = xpc_null_create();
          }
          p_xpc_object_t value = v48;
          uint64_t v45 = "state";
          sub_100035E70((uint64_t)&p_value, &v46, &v47);
          xpc_release(v47);
          xpc_object_t v47 = 0;
          xpc_release(v46);
          xpc_object_t v46 = 0;
          int v21 = *((_DWORD *)v14 + 11);
          uint64_t v22 = asString();
          ctu::rest::detail::write_enum_string_value((uint64_t *)&v42, (ctu::rest::detail *)v21, v22, v23);
          p_xpc_object_t value = v48;
          uint64_t v45 = "rawState";
          sub_100035E70((uint64_t)&p_value, &v42, &v43);
          xpc_release(v43);
          xpc_object_t v43 = 0;
          xpc_release(v42);
          xpc_object_t v42 = 0;
          xpc_object_t v37 = v48[0];
          if (v48[0]) {
            xpc_retain(v48[0]);
          }
          else {
            xpc_object_t v37 = xpc_null_create();
          }
          xpc_release(v48[0]);
          p_xpc_object_t value = &value;
          uint64_t v45 = "State";
          sub_100035E70((uint64_t)&p_value, &v37, &v38);
          xpc_release(v38);
          xpc_object_t v38 = 0;
          xpc_release(v37);
          xpc_object_t v37 = 0;
          xpc_array_append_value(v13, value);
          xpc_release(value);
          char v24 = (void *)v14[1];
          if (v24)
          {
            do
            {
              BOOL v25 = v24;
              char v24 = (void *)*v24;
            }
            while (v24);
          }
          else
          {
            do
            {
              BOOL v25 = (void *)v14[2];
              BOOL v26 = *v25 == (void)v14;
              xpc_object_t v14 = v25;
            }
            while (!v26);
          }
          xpc_object_t v14 = v25;
        }
        while (v25 != v8 + 8);
      }
      xpc_object_t v32 = v13;
      if (v13)
      {
        xpc_retain(v13);
        xpc_object_t v7 = v29;
      }
      else
      {
        xpc_object_t v7 = v29;
        xpc_object_t v32 = xpc_null_create();
      }
      xpc_release(v13);
      p_xpc_object_t value = &v36;
      uint64_t v45 = a3;
      sub_100035E70((uint64_t)&p_value, &v32, &v33);
      xpc_release(v33);
      xpc_object_t v33 = 0;
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_array_append_value(v7, v36);
      xpc_release(v36);
      uint64_t v27 = (void *)v8[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          uint64_t v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = (void *)v8[2];
          BOOL v26 = *v28 == (void)v8;
          int v8 = v28;
        }
        while (!v26);
      }
      int v8 = v28;
    }
    while (v28 != a1 + 1);
  }
  *a4 = v7;
  if (v7) {
    xpc_retain(v7);
  }
  else {
    *a4 = xpc_null_create();
  }
  xpc_release(v7);
}

void sub_100A5AB60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t a24)
{
}

uint64_t *sub_100A5AC14(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t v8 = 0;
  xpc_object_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v8, a2);
  __n128 result = *v5;
  if (!*v5)
  {
    memset(v7, 0, sizeof(v7));
    sub_100A5ACA0((uint64_t)a1, a3, v7);
    sub_100046C38(a1, v8, v5, v7[0]);
    return v7[0];
  }
  return result;
}

unsigned char *sub_100A5ACA0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  xpc_object_t v6 = a3 + 1;
  xpc_object_t v7 = (char *)operator new(0x48uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  *((void *)v7 + 7) = *(void *)(a2 + 24);
  *((_DWORD *)v7 + 16) = *(_DWORD *)(a2 + 32);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A5AD40(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100A5AD5C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_100A5ADA8(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v10, a2);
  xpc_object_t v6 = *v5;
  if (!*v5)
  {
    xpc_object_t v7 = v5;
    memset(v9, 0, sizeof(v9));
    sub_100A5AE48((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, v9[0]);
    xpc_object_t v6 = v9[0];
    v9[0] = 0;
    sub_100A5AF50((uint64_t)v9, 0);
  }
  return v6;
}

void *sub_100A5AE48@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  xpc_object_t v6 = operator new(0x60uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_100A5AEBC(v6 + 4, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A5AEA4(_Unwind_Exception *a1)
{
  sub_100A5AF50(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_100A5AEBC(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  char v5 = *((unsigned char *)a2 + 28);
  int v6 = *((_DWORD *)a2 + 6);
  *((unsigned char *)__dst + 32) = 0;
  *((_DWORD *)__dst + 6) = v6;
  *((unsigned char *)__dst + 28) = v5;
  *((unsigned char *)__dst + 56) = 0;
  if (*((unsigned char *)a2 + 56))
  {
    long long v7 = a2[2];
    __dst[6] = *((void *)a2 + 6);
    *((_OWORD *)__dst + 2) = v7;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 4) = 0;
    *((unsigned char *)__dst + 56) = 1;
  }
  return __dst;
}

void sub_100A5AF50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100703658((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t **sub_100A5AFA8(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  int v6 = a1 + 1;
  char v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        char v5 = *v8;
        int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      char v5 = v8[1];
      if (!v5)
      {
        int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_100046C38(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t sub_100A5B064(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_100A5B0A4(uint64_t **a1, void **a2, long long *a3)
{
  uint64_t v10 = 0;
  char v5 = (char **)sub_100046ED4((uint64_t)a1, &v10, a2);
  int v6 = *v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    memset(v9, 0, sizeof(v9));
    sub_100A5B144((uint64_t)a1, a3, v9);
    sub_100046C38(a1, v10, v7, (uint64_t *)v9[0]);
    int v6 = v9[0];
    v9[0] = 0;
    sub_10031E5B4((uint64_t)v9, 0);
  }
  return v6;
}

char *sub_100A5B144@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, char **a3@<X8>)
{
  char v5 = (char *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  __n128 result = sub_100A5B1B8(v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100A5B1A0(_Unwind_Exception *a1)
{
  sub_10031E5B4(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_100A5B1B8(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  *((void *)__dst + 3) = *((void *)a2 + 3);
  char v5 = a2 + 2;
  uint64_t v6 = *((void *)a2 + 4);
  *((void *)__dst + 4) = v6;
  unint64_t v7 = __dst + 32;
  uint64_t v8 = *((void *)a2 + 5);
  *((void *)__dst + 5) = v8;
  if (v8)
  {
    *(void *)(v6 + 16) = v7;
    *((void *)a2 + 3) = v5;
    void *v5 = 0;
    *((void *)a2 + 5) = 0;
  }
  else
  {
    *((void *)__dst + 3) = v7;
  }
  return __dst;
}

uint64_t *sub_100A5B240(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10024EF04(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100A5B280(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100A5B298(uint64_t a1)
{
  sub_100C62700(a1, "kDeviceManagementUpdate", (unint64_t)sub_100A5B428, 0x17u);
  sub_100C62700(a1, "kLoadManagedCellularProfile", (unint64_t)sub_100A5B49C, 0x17u);
  sub_100C62700(a1, "kUnloadManagedCellularProfile", (unint64_t)sub_100A5BAF8, 0x17u);
  sub_100C62700(a1, "kGetManagedCellularProfile", (unint64_t)sub_100A5C030, 0x17u);
  sub_100C62700(a1, "kSetUIConfiguredApns", (unint64_t)sub_100A5C1D8, 3u);
  sub_100C62700(a1, "kGetUIConfiguredApns", (unint64_t)sub_100A5C65C, 3u);
  sub_100C62700(a1, "kResetUIConfiguredApns", (unint64_t)sub_100A5C840, 3u);
  sub_100C62700(a1, "kGetConfiguredApns", (unint64_t)sub_100A5CA9C, 3u);
  sub_100C62630(a1, "kSetDisallowTelephonyFeature", (unint64_t)sub_100A5CD08, 3u);

  return sub_100C62700(a1, "kGetDisallowTelephonyFeature", (unint64_t)sub_100A5CE44, 3u);
}

void sub_100A5B428()
{
  CSILogger::CSILogger();
  char v0 = v2;
  CSILogger::~CSILogger((CSILogger *)v1);
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "#I OMADM is not supported, ignore", v1, 2u);
  }
}

void sub_100A5B49C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  v55[0] = 0;
  *(void *)long long buf = a4;
  long long v52 = "kManagedCellularProfileDict";
  sub_100048BAC((uint64_t)buf, v55);
  if (xpc_get_type(v55[0]) != (xpc_type_t)&_xpc_type_null)
  {
    long long v48 = 0;
    *(void *)long long buf = _CFXPCCreateCFObjectFromXPCObject();
    sub_100084068(&v48, (CFTypeRef *)buf);
    if (v48) {
      unint64_t v7 = (uint64_t *)sub_100080778;
    }
    else {
      unint64_t v7 = 0;
    }
    if (!v7)
    {
      CSILogger::CSILogger();
      xpc_object_t v19 = v54;
      CSILogger::~CSILogger((CSILogger *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Invalid kManagedCellularProfileDict", buf, 2u);
      }
      xpc_object_t v46 = xpc_int64_create(4);
      if (!v46) {
        xpc_object_t v46 = xpc_null_create();
      }
      *(void *)long long buf = *a5;
      long long v52 = "kMachError";
      sub_100035E70((uint64_t)buf, &v46, &v47);
      xpc_release(v47);
      xpc_object_t v47 = 0;
      xpc_release(v46);
      xpc_object_t v46 = 0;
      goto LABEL_65;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *a1);
    unint64_t v9 = ServiceMap;
    uint64_t v10 = "16IPCU_CellProfile";
    if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
    {
      xpc_object_t v11 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = (const char *)v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v10;
    xpc_object_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      xpc_object_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        if (!v16)
        {
LABEL_63:
          if ((v17 & 1) == 0) {
            sub_10004D2C8(v15);
          }
LABEL_65:
          sub_100057D78(&v48);
          goto LABEL_66;
        }
LABEL_25:
        if (!(*(unsigned int (**)(uint64_t, const void *))(*(void *)v16 + 56))(v16, v48)) {
          goto LABEL_63;
        }
        int v21 = (std::mutex *)Registry::getServiceMap(v20, *a1);
        uint64_t v22 = v21;
        if (v23 < 0)
        {
          char v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v25 = 5381;
          do
          {
            uint64_t v23 = v25;
            unsigned int v26 = *v24++;
            uint64_t v25 = (33 * v25) ^ v26;
          }
          while (v26);
        }
        std::mutex::lock(v21);
        *(void *)long long buf = v23;
        uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
        if (v27)
        {
          uint64_t v29 = v27[3];
          uint64_t v28 = (std::__shared_weak_count *)v27[4];
          if (v28)
          {
            atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v22);
            atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v28);
            char v30 = 0;
            if (!v29) {
              goto LABEL_59;
            }
            goto LABEL_35;
          }
        }
        else
        {
          uint64_t v29 = 0;
        }
        std::mutex::unlock(v22);
        uint64_t v28 = 0;
        char v30 = 1;
        if (!v29)
        {
LABEL_59:
          if ((v30 & 1) == 0) {
            sub_10004D2C8(v28);
          }
          uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 80))(v16);
          if (v38) {
            ResetAllPacketHandlersAPNs(v38, 9, 0xFFFFFFFFLL, 0);
          }
          goto LABEL_63;
        }
LABEL_35:
        char v39 = v30;
        subscriber::makeSimSlotRange();
        xpc_object_t v32 = *(unsigned int **)buf;
        long long v31 = (unsigned int *)v52;
        if (*(const char **)buf != v52)
        {
          xpc_object_t v33 = v53;
          while ((v33(*v32) & 1) == 0)
          {
            if (++v32 == v31)
            {
              xpc_object_t v32 = v31;
              break;
            }
          }
          xpc_object_t v34 = (unsigned int *)v52;
LABEL_41:
          while (v32 != v34)
          {
            uint64_t v35 = *v32;
            uint64_t v44 = 0;
            uint64_t v45 = 0;
            (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v29 + 16))(&v44, v29, v35);
            if (v44 && (*(unsigned int (**)(uint64_t))(*(void *)v44 + 88))(v44))
            {
              v42[0] = 0;
              v42[1] = 0;
              uint64_t v43 = 0;
              (*(void (**)(void **__return_ptr))(*(void *)v44 + 104))(v42);
              uint64_t v36 = v44;
              if (SHIBYTE(v43) < 0)
              {
                sub_10004FC84(__p, v42[0], (unint64_t)v42[1]);
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)v42;
                uint64_t v41 = v43;
              }
              (*(void (**)(uint64_t, void **))(*(void *)v36 + 16))(v36, __p);
              if (SHIBYTE(v41) < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v43) < 0) {
                operator delete(v42[0]);
              }
            }
            if (v45) {
              sub_10004D2C8(v45);
            }
            xpc_object_t v37 = v32 + 1;
            xpc_object_t v32 = v31;
            if (v37 != v31)
            {
              xpc_object_t v32 = v37;
              while ((v33(*v32) & 1) == 0)
              {
                if (++v32 == v31)
                {
                  xpc_object_t v32 = v31;
                  goto LABEL_41;
                }
              }
            }
          }
        }
        char v30 = v39;
        goto LABEL_59;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    xpc_object_t v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_63;
    }
    goto LABEL_25;
  }
  CSILogger::CSILogger();
  xpc_object_t v18 = v54;
  CSILogger::~CSILogger((CSILogger *)buf);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I No kManagedCellularProfileDict", buf, 2u);
  }
  xpc_object_t v49 = xpc_int64_create(15);
  if (!v49) {
    xpc_object_t v49 = xpc_null_create();
  }
  *(void *)long long buf = *a5;
  long long v52 = "kMachError";
  sub_100035E70((uint64_t)buf, &v49, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v49);
  xpc_object_t v49 = 0;
LABEL_66:
  xpc_release(v55[0]);
}

void sub_100A5BA10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  if ((a11 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  sub_100057D78(&a29);
  xpc_release(*(xpc_object_t *)(v32 - 96));
  _Unwind_Resume(a1);
}

void sub_100A5BAF8(Registry **a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *a1);
  long long v4 = ServiceMap;
  char v5 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      char v5 = (const char *)v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  long long v51 = (unsigned int *)v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v51);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_59;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11) {
    goto LABEL_59;
  }
LABEL_10:
  uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 80))(v11);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v11 + 64))(v11)) {
    goto LABEL_59;
  }
  xpc_object_t v15 = (std::mutex *)Registry::getServiceMap(v14, *a1);
  uint64_t v16 = v15;
  if ((v17 & 0x8000000000000000) != 0)
  {
    xpc_object_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      unint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v15);
  long long v51 = (unsigned int *)v17;
  int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&v51);
  if (v21)
  {
    uint64_t v23 = v21[3];
    uint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      char v24 = 0;
      if (!v23) {
        goto LABEL_44;
      }
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v16);
  uint64_t v22 = 0;
  char v24 = 1;
  if (!v23) {
    goto LABEL_44;
  }
LABEL_20:
  unsigned int v43 = v13;
  char v44 = v24;
  subscriber::makeSimSlotRange();
  unsigned int v26 = v51;
  uint64_t v25 = v52;
  if (v51 != v52)
  {
    uint64_t v27 = v53;
    while ((v27(*v26) & 1) == 0)
    {
      if (++v26 == v25)
      {
        unsigned int v26 = v25;
        break;
      }
    }
    uint64_t v28 = v52;
LABEL_26:
    while (v26 != v28)
    {
      uint64_t v29 = *v26;
      uint64_t v49 = 0;
      long long v50 = 0;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v23 + 16))(&v49, v23, v29);
      if (v49 && (*(unsigned int (**)(uint64_t))(*(void *)v49 + 88))(v49))
      {
        v47[0] = 0;
        v47[1] = 0;
        uint64_t v48 = 0;
        (*(void (**)(void **__return_ptr))(*(void *)v49 + 104))(v47);
        uint64_t v30 = v49;
        if (SHIBYTE(v48) < 0)
        {
          sub_10004FC84(__p, v47[0], (unint64_t)v47[1]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)v47;
          uint64_t v46 = v48;
        }
        (*(void (**)(uint64_t, void **))(*(void *)v30 + 16))(v30, __p);
        if (SHIBYTE(v46) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete(v47[0]);
        }
      }
      if (v50) {
        sub_10004D2C8(v50);
      }
      char v31 = v26 + 1;
      unsigned int v26 = v25;
      if (v31 != v25)
      {
        unsigned int v26 = v31;
        while ((v27(*v26) & 1) == 0)
        {
          if (++v26 == v25)
          {
            unsigned int v26 = v25;
            goto LABEL_26;
          }
        }
      }
    }
  }
  uint64_t v13 = v43;
  char v24 = v44;
LABEL_44:
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  if (v13)
  {
    ResetAllPacketHandlersAPNs(v13, 9, 0xFFFFFFFFLL, 0);
    xpc_object_t v33 = (std::mutex *)Registry::getServiceMap(v32, *a1);
    xpc_object_t v34 = v33;
    if ((v35 & 0x8000000000000000) != 0)
    {
      uint64_t v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v37 = 5381;
      do
      {
        unint64_t v35 = v37;
        unsigned int v38 = *v36++;
        uint64_t v37 = (33 * v37) ^ v38;
      }
      while (v38);
    }
    std::mutex::lock(v33);
    long long v51 = (unsigned int *)v35;
    char v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)&v51);
    if (v39)
    {
      uint64_t v41 = v39[3];
      xpc_object_t v40 = (std::__shared_weak_count *)v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v40);
        char v42 = 0;
        if (!v41)
        {
LABEL_57:
          if ((v42 & 1) == 0) {
            sub_10004D2C8(v40);
          }
          goto LABEL_59;
        }
LABEL_56:
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v41 + 312))(v41, v13, 10, 0);
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    std::mutex::unlock(v34);
    xpc_object_t v40 = 0;
    char v42 = 1;
    if (!v41) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
LABEL_59:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100A5BF8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26)
{
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A5C030(Registry **a1@<X0>, unint64_t *a2@<X4>, uint64_t *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a3, *a1);
  char v5 = ServiceMap;
  uint64_t v6 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = (const char *)v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = (unint64_t)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v15);
  if (!v10)
  {
    std::mutex::unlock(v5);
    return;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v5);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
    if (!v12)
    {
LABEL_16:
      sub_10004D2C8(v11);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v5);
    if (!v12) {
      return;
    }
  }
  xpc_object_t v18 = 0;
  (*(void (**)(ctu **__return_ptr, uint64_t))(*(void *)v12 + 72))(&v18, v12);
  if (v18) {
    xpc_object_t v14 = sub_100080778;
  }
  else {
    xpc_object_t v14 = 0;
  }
  if (v14)
  {
    ctu::cf_to_xpc((uint64_t *)&v16, v18, v13);
    v15[0] = *a2;
    v15[1] = (unint64_t)"kManagedCellularProfileDict";
    sub_100035E70((uint64_t)v15, &v16, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v16);
    xpc_object_t v16 = 0;
  }
  sub_100057D78((const void **)&v18);
  if (v11) {
    goto LABEL_16;
  }
}

void sub_100A5C1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100057D78((const void **)va);
  if (v6) {
    sub_10004D2C8(v6);
  }
  _Unwind_Resume(a1);
}

void sub_100A5C1D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  xpc_object_t v34 = 0;
  *(void *)long long buf = a4;
  uint64_t v32 = (std::__shared_weak_count *)"kUIApnsDict";
  sub_100048BAC((uint64_t)buf, &v34);
  if (xpc_get_type(v34) != (xpc_type_t)&_xpc_type_null)
  {
    uint64_t v28 = 0;
    *(void *)long long buf = _CFXPCCreateCFObjectFromXPCObject();
    sub_100084068(&v28, (CFTypeRef *)buf);
    if (v28) {
      uint64_t v7 = (uint64_t *)sub_100080778;
    }
    else {
      uint64_t v7 = 0;
    }
    if (!v7)
    {
      CSILogger::CSILogger();
      xpc_object_t v18 = v33;
      CSILogger::~CSILogger((CSILogger *)buf);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Invalid kUIApnsDict", buf, 2u);
      }
      xpc_object_t v26 = xpc_int64_create(4);
      if (!v26) {
        xpc_object_t v26 = xpc_null_create();
      }
      *(void *)long long buf = *a5;
      uint64_t v32 = (std::__shared_weak_count *)"kMachError";
      sub_100035E70((uint64_t)buf, &v26, &v27);
      xpc_release(v27);
      xpc_object_t v27 = 0;
      xpc_release(v26);
      xpc_object_t v26 = 0;
      goto LABEL_38;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, *(Registry **)a1);
    unsigned int v9 = ServiceMap;
    if (v10 < 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long buf = v10;
    xpc_object_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
    if (v14)
    {
      uint64_t v16 = v14[3];
      xpc_object_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        if (!v16)
        {
LABEL_37:
          sub_10004D2C8(v15);
          goto LABEL_38;
        }
LABEL_25:
        *(void *)long long buf = 0;
        uint64_t v32 = 0;
        sub_10022EDC4(v16, buf);
        uint64_t v19 = *(void *)buf;
        if (*(void *)buf)
        {
          unsigned int v20 = v28;
          uint64_t v22 = *(Registry **)a1;
          int v21 = *(std::__shared_weak_count **)(a1 + 8);
          if (v21) {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v24 = *a5;
          uint64_t v23 = a5[1];
          if (v23) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v36 = 0;
          uint64_t v25 = operator new(0x28uLL);
          *uint64_t v25 = off_101A319F0;
          v25[1] = v22;
          int v25[2] = v21;
          if (v21) {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v25[3] = v24;
          v25[4] = v23;
          uint64_t v36 = v25;
          (*(void (**)(uint64_t, const void *, void *))(*(void *)v19 + 104))(v19, v20, v35);
          sub_100060644(v35);
          if (v21) {
            sub_10004D2C8(v21);
          }
        }
        if (v32) {
          sub_10004D2C8(v32);
        }
        if (!v15) {
          goto LABEL_38;
        }
        goto LABEL_37;
      }
      std::mutex::unlock(v9);
      if (v16) {
        goto LABEL_25;
      }
    }
    else
    {
      std::mutex::unlock(v9);
    }
LABEL_38:
    sub_100057D78(&v28);
    goto LABEL_39;
  }
  CSILogger::CSILogger();
  unint64_t v17 = v33;
  CSILogger::~CSILogger((CSILogger *)buf);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I No kUIApnsDict", buf, 2u);
  }
  xpc_object_t v29 = xpc_int64_create(15);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)long long buf = *a5;
  uint64_t v32 = (std::__shared_weak_count *)"kMachError";
  sub_100035E70((uint64_t)buf, &v29, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
LABEL_39:
  xpc_release(v34);
}

void sub_100A5C5A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_100A5C65C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *a1);
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, &v18);
  if (!v12)
  {
    std::mutex::unlock(v7);
    return;
  }
  uint64_t v14 = v12[3];
  unsigned int v13 = (std::__shared_weak_count *)v12[4];
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v7);
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v13);
    if (!v14)
    {
LABEL_17:
      sub_10004D2C8(v13);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v7);
    if (!v14) {
      return;
    }
  }
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_10022EDC4(v14, &v18);
  unint64_t v15 = v18;
  if (v18)
  {
    uint64_t v17 = *a5;
    uint64_t v16 = a5[1];
    if (v16) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
    }
    v20[0] = off_101A31A70;
    v20[1] = v17;
    int v20[2] = v16;
    v20[3] = v20;
    (*(void (**)(unint64_t, void *))(*(void *)v15 + 120))(v15, v20);
    sub_10010E020(v20);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  if (v13) {
    goto LABEL_17;
  }
}

void sub_100A5C7F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  sub_10010E020((uint64_t *)va);
  if (a4) {
    sub_10004D2C8(a4);
  }
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100A5C840(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)a1);
  unint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      unint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v9;
  unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, &v22);
  if (!v13)
  {
    std::mutex::unlock(v8);
    return;
  }
  uint64_t v15 = v13[3];
  uint64_t v14 = (std::__shared_weak_count *)v13[4];
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v8);
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v14);
    if (!v15)
    {
LABEL_22:
      sub_10004D2C8(v14);
      return;
    }
  }
  else
  {
    std::mutex::unlock(v8);
    if (!v15) {
      return;
    }
  }
  unint64_t v22 = 0;
  uint64_t v23 = 0;
  sub_10022EDC4(v15, &v22);
  unint64_t v16 = v22;
  if (v22)
  {
    unint64_t v18 = *(Registry **)a1;
    uint64_t v17 = *(std::__shared_weak_count **)(a1 + 8);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = *a5;
    uint64_t v19 = a5[1];
    if (v19) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = 0;
    int v21 = operator new(0x28uLL);
    void *v21 = off_101A31AF0;
    v21[1] = v18;
    int v21[2] = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    void v21[3] = v20;
    v21[4] = v19;
    uint64_t v25 = v21;
    (*(void (**)(unint64_t, void, void *))(*(void *)v16 + 96))(v16, 0, v24);
    sub_10003B34C(v24);
    if (v17) {
      sub_10004D2C8(v17);
    }
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v14) {
    goto LABEL_22;
  }
}

void sub_100A5CA44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, std::__shared_weak_count *);
  sub_10003B34C((uint64_t *)va1);
  sub_10025B9C0((uint64_t)va);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

const void **sub_100A5CA9C(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4, const void **a5)
{
  xpc_object_t v33 = 0;
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    uint64_t v9 = v33;
    xpc_object_t v33 = Mutable;
    uint64_t v30 = (const char *)v9;
    sub_1000440D4((const void **)&v30);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *a1);
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v30 = (const char *)v12;
  unint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v30);
  if (v16)
  {
    uint64_t v18 = v16[3];
    uint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v20 = 0;
      if (!v18) {
        goto LABEL_18;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  uint64_t v17 = 0;
  char v20 = 1;
  if (!v18) {
    goto LABEL_18;
  }
LABEL_12:
  uint64_t v30 = 0;
  char v31 = 0;
  uint64_t v32 = 0;
  (*(void (**)(const char **__return_ptr, uint64_t, uint64_t))(*(void *)v18 + 96))(&v30, v18, 1);
  unint64_t v22 = v30;
  int v21 = v31;
  if (v31 != v30)
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    do
    {
      uint64_t v25 = *(void *)&v22[v23];
      if (v25)
      {
        xpc_object_t v26 = v33;
        sub_100C940DC(v25, 0, &value);
        CFArrayAppendValue(v26, value);
        sub_100057D78((const void **)&value);
        unint64_t v22 = v30;
        int v21 = v31;
      }
      ++v24;
      v23 += 16;
    }
    while (v24 < (v21 - v22) >> 4);
  }
  xpc_object_t value = &v30;
  sub_10005CBF0((void ***)&value);
LABEL_18:
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  ctu::cf_to_xpc((uint64_t *)&v28, v33, v19);
  uint64_t v30 = (const char *)*a5;
  char v31 = "kApns";
  sub_100035E70((uint64_t)&v30, &v28, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  return sub_1000440D4((const void **)&v33);
}

void sub_100A5CCA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if ((v8 & 1) == 0) {
    sub_10004D2C8(v7);
  }
  sub_1000440D4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100A5CD08(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4)
{
  CFStringRef v14 = 0;
  uint64_t v10 = a4;
  uint64_t v11 = "kTelephonyFeature";
  sub_100048BAC((uint64_t)&v10, &object);
  xpc::bridge((uint64_t *)&v13, (xpc *)&object, v5);
  sub_100056248(&v14, (CFTypeRef *)&v13);
  sub_1000577C4((const void **)&v13);
  xpc_release(object);
  if (xpc_dictionary_get_value(*a4, "kDisallow"))
  {
    if (v14) {
      uint64_t v6 = sub_1000810B8;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6)
    {
      uint64_t v10 = a4;
      uint64_t v11 = "kDisallow";
      sub_100048BAC((uint64_t)&v10, &v13);
      int v8 = xpc::dyn_cast_or_default((xpc *)&v13, 0, v7);
      xpc_release(v13);
      sub_1000BE2C8(v14, v8);
    }
  }
  return sub_1000558F4((const void **)&v14);
}

void sub_100A5CDE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
  sub_1000558F4((const void **)(v13 - 24));
  _Unwind_Resume(a1);
}

const void **sub_100A5CE44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  CFStringRef v16 = 0;
  uint64_t v12 = a4;
  uint64_t v13 = "kTelephonyFeature";
  sub_100048BAC((uint64_t)&v12, &object);
  xpc::bridge((uint64_t *)&v15, (xpc *)&object, v6);
  sub_100056248(&v16, &v15);
  sub_1000577C4(&v15);
  xpc_release(object);
  if (v16) {
    BOOL v7 = sub_1000810B8;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    unsigned __int8 v8 = sub_1000BE198(v16);
    xpc_object_t v10 = xpc_BOOL_create(v8);
    if (!v10) {
      xpc_object_t v10 = xpc_null_create();
    }
    uint64_t v12 = *a5;
    uint64_t v13 = "kDisallow";
    sub_100035E70((uint64_t)&v12, &v10, &v11);
    xpc_release(v11);
    xpc_object_t v11 = 0;
    xpc_release(v10);
    xpc_object_t v10 = 0;
  }
  return sub_1000558F4((const void **)&v16);
}

void sub_100A5CF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  sub_1000558F4((const void **)(v14 - 24));
  _Unwind_Resume(a1);
}

void *sub_100A5CF74(void *a1)
{
  *a1 = off_101A319F0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100A5CFCC(void *a1)
{
  *a1 = off_101A319F0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_100A5D044(void *a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *__n128 result = off_101A319F0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_100A5D0B8(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A319F0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A5D108(uint64_t a1)
{
}

void sub_100A5D110(void *a1)
{
  sub_10000ACD0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A5D14C(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)*a2, *(Registry **)(a1 + 8));
    uint64_t v3 = ServiceMap;
    if ((v4 & 0x8000000000000000) != 0)
    {
      uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v6 = 5381;
      do
      {
        unint64_t v4 = v6;
        unsigned int v7 = *v5++;
        uint64_t v6 = (33 * v6) ^ v7;
      }
      while (v7);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v12 = v4;
    unsigned __int8 v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
    if (v8)
    {
      uint64_t v10 = v8[3];
      uint64_t v9 = (std::__shared_weak_count *)v8[4];
      if (v9)
      {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v3);
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        char v11 = 0;
        if (!v10)
        {
LABEL_12:
          if ((v11 & 1) == 0) {
            sub_10004D2C8(v9);
          }
          return;
        }
LABEL_11:
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 640))(v10, 1, 10, 0xFFFFFFFFLL, 0);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 312))(v10, 1, 9, 0);
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v10 = 0;
    }
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
}

void sub_100A5D2B4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A5D2CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A5D30C()
{
}

void *sub_100A5D318(void *a1)
{
  *a1 = off_101A31A70;
  char v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100A5D364(void *a1)
{
  *a1 = off_101A31A70;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void *sub_100A5D3D0(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = off_101A31A70;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100A5D42C(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A31A70;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A5D464(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_100A5D474(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

const void **sub_100A5D4B4(uint64_t a1, const void **a2)
{
  uint64_t v5 = (ctu *)*a2;
  uint64_t v3 = v5;
  *a2 = 0;
  ctu::cf_to_xpc((uint64_t *)&object, v3, a2);
  v6[0] = *(void *)(a1 + 8);
  v6[1] = "kUIApnsDict";
  sub_100035E70((uint64_t)v6, &object, &v8);
  xpc_release(v8);
  xpc_object_t v8 = 0;
  xpc_release(object);
  return sub_100057D78((const void **)&v5);
}

void sub_100A5D534(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A5D548(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A5D588()
{
}

void *sub_100A5D594(void *a1)
{
  *a1 = off_101A31AF0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100A5D5EC(void *a1)
{
  *a1 = off_101A31AF0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_100A5D664(void *a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *__n128 result = off_101A31AF0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_100A5D6D8(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A31AF0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100A5D728(uint64_t a1)
{
}

void sub_100A5D730(void *a1)
{
  sub_10000ACD0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A5D76C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 8));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  xpc_object_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10)
  {
LABEL_10:
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 640))(v10, 1, 11, 0xFFFFFFFFLL, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 312))(v10, 1, 8, 0);
  }
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100A5D8CC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A5D8E4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A5D924()
{
}

uint64_t sub_100A5D930()
{
  return sub_100C624B8((uint64_t)&unk_101B0FCDA, (uint64_t)sub_100A5B298);
}

void sub_100A5DC40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, dispatch_object_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  _Unwind_Resume(a1);
}

void sub_100A5DDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
}

uint64_t sub_100A5DE10(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 8);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (v3) {
      dispatch_release(v3);
    }
  }

  return a1;
}

void sub_100A5DEDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100A5DFB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
}

void sub_100A5E144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

uint64_t sub_100A5E170(uint64_t a1)
{
  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void sub_100A5E2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

void sub_100A5E430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, id a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  objc_destroyWeak(&location);
  objc_destroyWeak(&a11);
  _Unwind_Resume(a1);
}

void sub_100A5E634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  sub_1001F23E0(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(a1);
}

void sub_100A5E748(xpc_object_t *a1, void *a2)
{
  long long v64 = 0;
  uint64_t v65 = 0;
  long long v63 = &v64;
  char v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      unint64_t v4 = (uint64_t **)operator new(0x38uLL);
      uint64_t v5 = v4;
      uint64_t v6 = (uint64_t *)v3[5];
      unsigned int v7 = (std::__shared_weak_count *)v3[6];
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        v4[4] = v6;
        void v4[5] = (uint64_t *)v7;
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        v4[4] = v6;
        void v4[5] = 0;
      }
      xpc_object_t v8 = (uint64_t *)xpc_array_create(0, 0);
      uint64_t v9 = v8;
      if (v8)
      {
        void v5[6] = v8;
      }
      else
      {
        uint64_t v9 = (uint64_t *)xpc_null_create();
        void v5[6] = v9;
        if (!v9)
        {
          uint64_t v10 = (uint64_t *)xpc_null_create();
          uint64_t v9 = 0;
          goto LABEL_12;
        }
      }
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v9);
        goto LABEL_13;
      }
      uint64_t v10 = (uint64_t *)xpc_null_create();
LABEL_12:
      void v5[6] = v10;
LABEL_13:
      xpc_release(v9);
      if (v7) {
        sub_10004D2C8(v7);
      }
      char v11 = v64;
      unint64_t v12 = &v64;
      uint64_t v13 = &v64;
      if (v64)
      {
        int v14 = *(_DWORD *)v5[4];
        while (1)
        {
          while (1)
          {
            uint64_t v13 = (uint64_t **)v11;
            int v15 = *(_DWORD *)v11[4];
            if (v14 >= v15) {
              break;
            }
            char v11 = (uint64_t *)*v11;
            unint64_t v12 = v13;
            if (!*v13) {
              goto LABEL_23;
            }
          }
          if (v15 >= v14) {
            break;
          }
          char v11 = (uint64_t *)v11[1];
          if (!v11)
          {
            unint64_t v12 = v13 + 1;
            goto LABEL_23;
          }
        }
        sub_100A61ACC((uint64_t)(v5 + 4));
        operator delete(v5);
        uint64_t v5 = v13;
      }
      else
      {
LABEL_23:
        unsigned __int8 *v5 = 0;
        v5[1] = 0;
        void v5[2] = (uint64_t *)v13;
        *unint64_t v12 = (uint64_t *)v5;
        CFStringRef v16 = (uint64_t *)v5;
        if (*v63)
        {
          long long v63 = (uint64_t **)*v63;
          CFStringRef v16 = *v12;
        }
        sub_100046C90(v64, v16);
        ++v65;
      }
      xpc_object_t v56 = 0;
      xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v18 = v17;
      if (v17)
      {
        xpc_object_t v56 = v17;
      }
      else
      {
        xpc_object_t v18 = xpc_null_create();
        xpc_object_t v56 = v18;
        if (!v18)
        {
          xpc_object_t v19 = xpc_null_create();
          xpc_object_t v18 = 0;
          goto LABEL_34;
        }
      }
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v18);
        goto LABEL_35;
      }
      xpc_object_t v19 = xpc_null_create();
LABEL_34:
      xpc_object_t v56 = v19;
LABEL_35:
      xpc_release(v18);
      xpc_object_t v20 = xpc_array_create(0, 0);
      if (v20 || (xpc_object_t v20 = xpc_null_create()) != 0)
      {
        if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_array)
        {
          xpc_retain(v20);
          xpc_object_t v21 = v20;
        }
        else
        {
          xpc_object_t v21 = xpc_null_create();
        }
      }
      else
      {
        xpc_object_t v21 = xpc_null_create();
        xpc_object_t v20 = 0;
      }
      xpc_release(v20);
      unint64_t v22 = (SEL *)v3[7];
      uint64_t v23 = (SEL *)v3[8];
      while (v22 != v23)
      {
        NSStringFromSelector(*v22);
        id v24 = objc_claimAutoreleasedReturnValue();
        xpc_object_t v25 = xpc_string_create((const char *)[v24 UTF8String]);
        if (!v25) {
          xpc_object_t v25 = xpc_null_create();
        }

        xpc_array_append_value(v21, v25);
        xpc_release(v25);
        ++v22;
      }
      xpc_object_t v72 = v21;
      if (v21) {
        xpc_retain(v21);
      }
      else {
        xpc_object_t v72 = xpc_null_create();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v56;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"notifications";
      sub_10017AC14((uint64_t)&__p, &v72, v73);
      xpc_release(v73[0]);
      v73[0] = 0;
      xpc_release(v72);
      xpc_object_t v72 = 0;
      xpc_object_t v70 = xpc_int64_create(v3[14]);
      if (!v70) {
        xpc_object_t v70 = xpc_null_create();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v56;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"notification count";
      sub_100035E70((uint64_t)&__p, &v70, &v71);
      xpc_release(v71);
      xpc_object_t v71 = 0;
      xpc_release(v70);
      xpc_object_t v70 = 0;
      xpc_object_t v68 = xpc_BOOL_create(*((unsigned char *)v3 + 104));
      if (!v68) {
        xpc_object_t v68 = xpc_null_create();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v56;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"has outstanding notifications";
      sub_100035E70((uint64_t)&__p, &v68, &v69);
      xpc_release(v69);
      xpc_object_t v69 = 0;
      xpc_release(v68);
      xpc_object_t v68 = 0;
      int v26 = *(_DWORD *)(v3[5] + 48);
      uint64_t v27 = asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&object, (ctu::rest::detail *)v26, v27, v28);
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v56;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"application state";
      sub_100035E70((uint64_t)&__p, &object, &v67);
      xpc_release(v67);
      xpc_object_t v67 = 0;
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_object_t v29 = v56;
      if (v56) {
        xpc_retain(v56);
      }
      else {
        xpc_object_t v29 = xpc_null_create();
      }
      xpc_release(v21);
      xpc_release(v56);
      xpc_array_append_value(v5[6], v29);
      xpc_release(v29);
      uint64_t v30 = (void *)v3[1];
      if (v30)
      {
        do
        {
          char v31 = v30;
          uint64_t v30 = (void *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          char v31 = (void *)v3[2];
          BOOL v32 = *v31 == (void)v3;
          uint64_t v3 = v31;
        }
        while (!v32);
      }
      uint64_t v3 = v31;
    }
    while (v31 != v2);
  }
  v73[0] = 0;
  xpc_object_t v33 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v34 = v33;
  if (v33)
  {
    v73[0] = v33;
  }
  else
  {
    xpc_object_t v34 = xpc_null_create();
    v73[0] = v34;
    if (!v34)
    {
      xpc_object_t v35 = xpc_null_create();
      xpc_object_t v34 = 0;
      goto LABEL_69;
    }
  }
  if (xpc_get_type(v34) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v34);
    goto LABEL_70;
  }
  xpc_object_t v35 = xpc_null_create();
LABEL_69:
  v73[0] = v35;
LABEL_70:
  xpc_release(v34);
  uint64_t v36 = v63;
  if (v63 != &v64)
  {
    do
    {
      xpc_object_t v72 = 0;
      xpc_object_t v37 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v38 = v37;
      if (v37)
      {
        xpc_object_t v72 = v37;
      }
      else
      {
        xpc_object_t v38 = xpc_null_create();
        xpc_object_t v72 = v38;
        if (!v38)
        {
          xpc_object_t v39 = xpc_null_create();
          xpc_object_t v38 = 0;
          goto LABEL_78;
        }
      }
      if (xpc_get_type(v38) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v39 = xpc_null_create();
LABEL_78:
        xpc_object_t v72 = v39;
        goto LABEL_79;
      }
      xpc_retain(v38);
LABEL_79:
      xpc_release(v38);
      xpc_object_t v40 = v36[4];
      uint64_t v41 = (const char *)(v40 + 1);
      if (*((char *)v40 + 31) < 0) {
        uint64_t v41 = *(const char **)v41;
      }
      xpc_object_t v61 = xpc_string_create(v41);
      if (!v61) {
        xpc_object_t v61 = xpc_null_create();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v72;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"name";
      sub_100035E70((uint64_t)&__p, &v61, &v62);
      xpc_release(v62);
      xpc_object_t v62 = 0;
      xpc_release(v61);
      xpc_object_t v61 = 0;
      (*(void (**)(std::string *__return_ptr))(*(void *)v36[4][4] + 40))(&__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      xpc_object_t v59 = xpc_string_create((const char *)p_p);
      if (!v59) {
        xpc_object_t v59 = xpc_null_create();
      }
      xpc_object_t v56 = &v72;
      long long v57 = "entitlements";
      sub_100035E70((uint64_t)&v56, &v59, &v60);
      xpc_release(v60);
      xpc_object_t v60 = 0;
      xpc_release(v59);
      xpc_object_t v59 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (xpc_get_type(v36[6]) == (xpc_type_t)&_xpc_type_array) {
        int64_t count = xpc_array_get_count(v36[6]);
      }
      else {
        int64_t count = 0;
      }
      xpc_object_t v54 = xpc_int64_create(count);
      if (!v54) {
        xpc_object_t v54 = xpc_null_create();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v72;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"num_clients";
      sub_100035E70((uint64_t)&__p, &v54, &v55);
      xpc_release(v55);
      xpc_object_t v55 = 0;
      xpc_release(v54);
      xpc_object_t v54 = 0;
      char v44 = v36[6];
      xpc_object_t v52 = v44;
      if (v44) {
        xpc_retain(v44);
      }
      else {
        xpc_object_t v52 = xpc_null_create();
      }
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v72;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)"clients";
      sub_10017AC14((uint64_t)&__p, &v52, &v53);
      xpc_release(v53);
      xpc_object_t v53 = 0;
      xpc_release(v52);
      xpc_object_t v52 = 0;
      xpc_object_t v50 = v72;
      if (v72) {
        xpc_retain(v72);
      }
      else {
        xpc_object_t v50 = xpc_null_create();
      }
      std::to_string(&__p, *(_DWORD *)v36[4]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v45 = &__p;
      }
      else {
        uint64_t v45 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      xpc_object_t v56 = v73;
      long long v57 = (const char *)v45;
      sub_10014E03C((uint64_t)&v56, &v50, &v51);
      xpc_release(v51);
      xpc_object_t v51 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      xpc_release(v50);
      xpc_object_t v50 = 0;
      xpc_release(v72);
      uint64_t v46 = v36[1];
      if (v46)
      {
        do
        {
          xpc_object_t v47 = (uint64_t **)v46;
          uint64_t v46 = (uint64_t *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          xpc_object_t v47 = (uint64_t **)v36[2];
          BOOL v32 = *v47 == (uint64_t *)v36;
          uint64_t v36 = v47;
        }
        while (!v32);
      }
      uint64_t v36 = v47;
    }
    while (v47 != &v64);
  }
  xpc_object_t v48 = v73[0];
  *a1 = v73[0];
  if (v48) {
    xpc_retain(v48);
  }
  else {
    *a1 = xpc_null_create();
  }
  xpc_release(v73[0]);
  sub_100A61B20(v64);
}

void sub_100A5EFC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  xpc_release(v26);
  sub_100A61B20(a26);
  _Unwind_Resume(a1);
}

void sub_100A5F384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A5F720(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;

  _Unwind_Resume(a1);
}

uint64_t sub_100A5F7B4(uint64_t a1)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(a1 + 24));
  char v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  objc_destroyWeak((id *)a1);
  return a1;
}

void sub_100A5F964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A5FD9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A5FDD4(uint64_t a1)
{
  char v2 = *(void **)(a1 + 32);
  if (v2)
  {
    [v2 getLogContext];
    uint64_t v3 = v15;
  }
  else
  {
    uint64_t v3 = 0;
    std::string __p = 0;
    int v15 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    sub_10004B74C(&__p, *(void *)(*(void *)(a1 + 64) + 40));
    unint64_t v12 = v16 >= 0 ? &__p : (void **)__p;
    uint64_t v13 = *(void **)(a1 + 40);
    *(_DWORD *)long long buf = 136446466;
    xpc_object_t v18 = v12;
    __int16 v19 = 2050;
    xpc_object_t v20 = v13;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Send barrier complete for client [%{public}s] (conn=%{public}p)", buf, 0x16u);
    if (v16 < 0) {
      operator delete(__p);
    }
  }
  *(unsigned char *)(*(void *)(a1 + 64) + 104) = 0;
  unint64_t v4 = [*(id *)(a1 + 48) invocationDescriptionWithClassifier:*(void *)(a1 + 56)];
  if ([*(id *)(a1 + 56) foundSensitiveObject])
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5)
    {
      [v5 getLogContext];
      uint64_t v6 = v15;
    }
    else
    {
      uint64_t v6 = 0;
      std::string __p = 0;
      int v15 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004B74C(&__p, *(void *)(*(void *)(a1 + 64) + 40));
      if (v16 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)long long buf = 138740227;
      xpc_object_t v18 = v4;
      __int16 v19 = 2082;
      xpc_object_t v20 = p_p;
      uint64_t v9 = "Sent notification %{sensitive}@ after barrier to client [%{public}s]";
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v9, buf, 0x16u);
      if (v16 < 0) {
        operator delete(__p);
      }
    }
  }
  else
  {
    unsigned int v7 = *(void **)(a1 + 32);
    if (v7)
    {
      [v7 getLogContext];
      uint64_t v6 = v15;
    }
    else
    {
      uint64_t v6 = 0;
      std::string __p = 0;
      int v15 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004B74C(&__p, *(void *)(*(void *)(a1 + 64) + 40));
      if (v16 >= 0) {
        uint64_t v10 = &__p;
      }
      else {
        uint64_t v10 = __p;
      }
      *(_DWORD *)long long buf = 138412546;
      xpc_object_t v18 = v4;
      __int16 v19 = 2082;
      xpc_object_t v20 = v10;
      uint64_t v9 = "Sent notification %@ after barrier to client [%{public}s]";
      goto LABEL_22;
    }
  }
  ++*(void *)(*(void *)(a1 + 64) + 112);
  char v11 = [*(id *)(a1 + 40) remoteObjectProxy];
  [*(id *)(a1 + 48) invokeWithTarget:v11];
}

void sub_100A6007C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A60244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }

  _Unwind_Resume(a1);
}

void sub_100A604D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A605F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A606EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  objc_destroyWeak(v15);
  objc_destroyWeak((id *)(v17 - 40));
  _Unwind_Resume(a1);
}

void sub_100A60714(uint64_t a1)
{
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    id v4 = [WeakRetained[14] requiredEntitlementForNotification:*(void *)(a1 + 56)];
    uint64_t v5 = (id *)v3[20];
    if (v5 != v3 + 21)
    {
      id v6 = v4;
      while (1)
      {
        unsigned int v7 = (void **)v5[5];
        if (!v7 || (*(unsigned int (**)(void *, id))(*v7[4] + 16))(v7[4], v6) != 1) {
          break;
        }
        id v8 = [v3[14] accessControlListForRequest:*(void *)(a1 + 56)];
        if (v8)
        {
          id v9 = v5[4];
          uint64_t v10 = (int *)v5[5];
          uint64_t v11 = *((void *)v10 + 4);
          if (v9)
          {
            [v9 auditToken];
            uint64_t v10 = (int *)v5[5];
          }
          else
          {
            memset(v34, 0, sizeof(v34));
          }
          int v17 = *v10;
          if (*((char *)v10 + 31) < 0)
          {
            sub_10004FC84(__p, *((void **)v10 + 1), *((void *)v10 + 2));
          }
          else
          {
            long long v18 = *(_OWORD *)(v10 + 2);
            xpc_object_t v33 = (void *)*((void *)v10 + 3);
            *(_OWORD *)std::string __p = v18;
          }
          *(_DWORD *)xpc_object_t v39 = v17;
          if (SHIBYTE(v33) < 0)
          {
            sub_10004FC84(&v39[8], __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)&v39[8] = *(_OWORD *)__p;
            xpc_object_t v40 = v33;
          }
          char v19 = (*(uint64_t (**)(uint64_t, _OWORD *, unsigned char *, id))(*(void *)v11 + 32))(v11, v34, v39, v8);
          if (SHIBYTE(v40) < 0) {
            operator delete(*(void **)&v39[8]);
          }
          if (SHIBYTE(v33) < 0)
          {
            operator delete(__p[0]);
            if ((v19 & 1) == 0)
            {
LABEL_37:
              unint64_t v22 = *(void **)(a1 + 32);
              if (v22)
              {
                [v22 getLogContext];
                uint64_t v23 = *(NSObject **)&v39[8];
              }
              else
              {
                uint64_t v23 = 0;
                *(void *)xpc_object_t v39 = 0;
                *(void *)&v39[8] = 0;
              }
              ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v39);
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
                goto LABEL_50;
              }
              sub_10004B74C(v39, (uint64_t)v5[5]);
              int v24 = v39[23];
              xpc_object_t v25 = *(unsigned char **)v39;
              uint64_t v26 = NSStringFromSelector(*(SEL *)(a1 + 56));
              uint64_t v27 = (void *)v26;
              *(_DWORD *)long long buf = 136315394;
              xpc_object_t v28 = v39;
              if (v24 < 0) {
                xpc_object_t v28 = v25;
              }
              *(void *)&uint8_t buf[4] = v28;
              __int16 v36 = 2112;
              uint64_t v37 = v26;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Client [%s] is not allowed for notification \"%@\"", buf, 0x16u);
              if ((v39[23] & 0x80000000) != 0) {
                operator delete(*(void **)v39);
              }
              goto LABEL_49;
            }
          }
          else if ((v19 & 1) == 0)
          {
            goto LABEL_37;
          }
        }
        xpc_object_t v21 = v5[7];
        xpc_object_t v20 = v5[8];
        if (v21 != v20)
        {
          while (*v21 != *(void *)(a1 + 56))
          {
            if (++v21 == v20)
            {
              xpc_object_t v21 = v5[8];
              break;
            }
          }
        }
        if (v21 != v20) {
          goto LABEL_35;
        }
LABEL_50:
        xpc_object_t v29 = (id *)v5[1];
        if (v29)
        {
          do
          {
            uint64_t v30 = v29;
            xpc_object_t v29 = (id *)*v29;
          }
          while (v29);
        }
        else
        {
          do
          {
            uint64_t v30 = (id *)v5[2];
            BOOL v31 = *v30 == v5;
            uint64_t v5 = v30;
          }
          while (!v31);
        }
        uint64_t v5 = v30;
        if (v30 == v3 + 21) {
          goto LABEL_35;
        }
      }
      unint64_t v12 = *(void **)(a1 + 32);
      if (v12)
      {
        [v12 getLogContext];
        uint64_t v13 = *(NSObject **)&v39[8];
      }
      else
      {
        uint64_t v13 = 0;
        *(void *)xpc_object_t v39 = 0;
        *(void *)&v39[8] = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v39);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_50;
      }
      sub_10004B74C(buf, (uint64_t)v5[5]);
      uint64_t v14 = 0;
      if (v38 >= 0) {
        int v15 = buf;
      }
      else {
        int v15 = *(unsigned char **)buf;
      }
      while (dword_101AAF500[v14] != v6)
      {
        v14 += 4;
        if (v14 == 124)
        {
          char v16 = "???";
          goto LABEL_47;
        }
      }
      char v16 = *(const char **)&dword_101AAF500[v14 + 2];
LABEL_47:
      uint64_t v27 = NSStringFromSelector(*(SEL *)(a1 + 56));
      *(_DWORD *)xpc_object_t v39 = 136315650;
      *(void *)&v39[4] = v15;
      *(_WORD *)&unsigned char v39[12] = 2080;
      *(void *)&v39[14] = v16;
      *(_WORD *)&v39[22] = 2112;
      xpc_object_t v40 = v27;
      _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Client [%s] entitlement failed: '%s', required for notification \"%@\"", v39, 0x20u);
      if (v38 < 0) {
        operator delete(*(void **)buf);
      }
LABEL_49:

      goto LABEL_50;
    }
LABEL_35:
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_100A60BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  _Unwind_Resume(a1);
}

void sub_100A60EFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  id v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  id v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  id v8 = va_arg(va3, const void *);
  sub_1000558F4((const void **)va);
  sub_100030068((const void **)va1);
  sub_100127D74((const void **)va2);
  sub_100057D78((const void **)va3);
  xpc_release(v2);
  _Unwind_Resume(a1);
}

void sub_100A61168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A613DC(_Unwind_Exception *a1)
{
  sub_100A61D88(*v1);
  _Unwind_Resume(a1);
}

void sub_100A6187C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100A61E3C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100A61ACC(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 16));
  *(void *)(a1 + 16) = 0;
  char v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

void sub_100A61B20(void *a1)
{
  if (a1)
  {
    sub_100A61B20(*a1);
    sub_100A61B20(a1[1]);
    sub_100A61ACC((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

__n128 sub_100A61B74(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  id v6 = (char *)operator new(0x78uLL);
  *a1 = v6;
  a1[1] = v5;
  *((unsigned char *)a1 + 16) = 0;
  id v7 = *(id *)a3;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a3 + 16);
  *((void *)v6 + 4) = v7;
  *((void *)v6 + 5) = v9;
  *((void *)v6 + 6) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v6 + 7) = 0;
  *((void *)v6 + 8) = 0;
  *((void *)v6 + 9) = 0;
  uint64_t v11 = *(unsigned char **)(a3 + 24);
  uint64_t v10 = *(unsigned char **)(a3 + 32);
  int64_t v12 = v10 - v11;
  if (v10 != v11)
  {
    sub_100A61D08((void *)v6 + 7, v12 >> 3);
    uint64_t v13 = (char *)*((void *)v6 + 8);
    memmove(v13, v11, v12);
    *((void *)v6 + 8) = &v13[8 * (v12 >> 3)];
  }
  *((void *)v6 + 1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *((void *)v6 + 11) = 0;
  *((void *)v6 + 12) = 0;
  uint64_t v14 = *(void *)(a3 + 48);
  uint64_t v15 = *(void *)(a3 + 56);
  if (v15 != v14)
  {
    sub_100A61D48((void *)v6 + 10, (v15 - v14) >> 4);
    uint64_t v16 = 0;
    uint64_t v17 = *((void *)v6 + 11);
    do
    {
      long long v18 = (void *)(v17 + v16);
      uint64_t v19 = v14 + v16;
      *long long v18 = *(void *)(v14 + v16);
      uint64_t v20 = *(void *)(v14 + v16 + 8);
      v18[1] = v20;
      if (v20) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
      }
      v16 += 16;
    }
    while (v19 + 16 != v15);
    *((void *)v6 + 11) = v17 + v16;
  }
  __n128 result = *(__n128 *)(a3 + 72);
  *(__n128 *)(v6 + 104) = result;
  *((unsigned char *)a1 + 16) = 1;
  return result;
}

void sub_100A61CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_10005CBF0(&a9);
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 64) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(v10 + 48);
  if (v14) {
    sub_10004D2C8(v14);
  }

  sub_10003C22C(v9);
  _Unwind_Resume(a1);
}

char *sub_100A61D08(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_10006A748();
  }
  __n128 result = (char *)sub_100048350(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

char *sub_100A61D48(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_10006A748();
  }
  __n128 result = (char *)sub_1009C886C(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void sub_100A61D88(void *a1)
{
  if (a1)
  {
    sub_100A61D88(*a1);
    sub_100A61D88(a1[1]);
    sub_10005ED58((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t sub_100A61DDC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  *(void *)(result + 16) = v1;
  if (v1)
  {
    char v2 = *(void **)(v1 + 16);
    if (v2)
    {
      uint64_t v3 = (void *)*v2;
      if (*v2 == v1)
      {
        *char v2 = 0;
        while (1)
        {
          uint64_t v4 = (void *)v2[1];
          if (!v4) {
            break;
          }
          do
          {
            char v2 = v4;
            uint64_t v4 = (void *)*v4;
          }
          while (v4);
        }
      }
      else
      {
        for (v2[1] = 0; v3; uint64_t v3 = (void *)v2[1])
        {
          do
          {
            char v2 = v3;
            uint64_t v3 = (void *)*v3;
          }
          while (v3);
        }
      }
    }
    *(void *)(result + 8) = v2;
  }
  return result;
}

uint64_t sub_100A61E3C(uint64_t a1)
{
  sub_100A61D88(*(void **)(a1 + 16));
  char v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        char v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_100A61D88(v2);
  }
  return a1;
}

uint64_t sub_100A61E8C(uint64_t a1)
{
  *(void *)a1 = off_101A31C48;
  char v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }

  return a1;
}

void sub_100A61EEC(uint64_t a1)
{
  *(void *)a1 = off_101A31C48;
  char v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100A61F6C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x18uLL);
  *char v2 = off_101A31C48;
  sub_100A623D4(v2 + 1, v1);
  return v2;
}

void *sub_100A61FC0(uint64_t a1, void *a2)
{
  *a2 = off_101A31C48;
  return sub_100A623D4(a2 + 1, a1 + 8);
}

void sub_100A61FEC(uint64_t a1)
{
}

void sub_100A61FF4(void *a1)
{
  sub_100A62424((uint64_t)a1 + 8);

  operator delete(a1);
}

id sub_100A62030(uint64_t a1)
{
  char v2 = *(void **)(a1 + 8);
  if (v2)
  {
    [v2 getLogContext];
    uint64_t v3 = v18;
  }
  else
  {
    uint64_t v3 = 0;
    *(void *)long long buf = 0;
    uint64_t v18 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Bootstrapping", buf, 2u);
  }
  objc_msgSend(*(id *)(*(void *)(a1 + 8) + 104), "bootstrapWithDelegate:");
  [*(id *)(*(void *)(a1 + 8) + 64) bootstrap];
  Registry::createRestModuleOneTimeUseConnection(&v13, *(Registry **)(*(void *)(a1 + 8) + 144));
  ctu::RestModule::connect();
  if (v14) {
    sub_10004D2C8(v14);
  }
  id v4 = *(id *)(a1 + 8);
  sub_100058DB0(__p, "/cc/props/subscription_info");
  uint64_t v5 = (id (*)(uint64_t, uint64_t))v4;
  *(void *)long long buf = off_101A31CE0;
  uint64_t v18 = (uint64_t)v4 + 16;
  uint64_t v19 = v5;
  uint64_t v20 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }

  id v6 = *(id *)(a1 + 8);
  sub_100058DB0(__p, "/cc/props/active_subscriptions");
  id v7 = (id (*)(uint64_t, uint64_t))v6;
  *(void *)long long buf = off_101A31D60;
  uint64_t v18 = (uint64_t)v6 + 40;
  uint64_t v19 = v7;
  uint64_t v20 = buf;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }

  uint64_t v8 = *(void **)(a1 + 8);
  if (v8)
  {
    [v8 getQueue];
    uint64_t v9 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v9 = 0;
    __p[0] = 0;
  }
  *(void *)long long buf = _NSConcreteStackBlock;
  uint64_t v18 = 3221225472;
  uint64_t v19 = sub_100A62470;
  uint64_t v20 = (uint8_t *)&unk_101A31CB0;
  uint64_t v21 = v9;
  uint64_t v10 = os_state_add_handler();
  uint64_t v11 = *(void **)(a1 + 8);
  v11[9] = v10;
  if (__p[0])
  {
    dispatch_release((dispatch_object_t)__p[0]);
    uint64_t v11 = *(void **)(a1 + 8);
  }
  objc_msgSend(v11, "_registerRestProviders_sync");
  return objc_msgSend(*(id *)(a1 + 8), "_registerRestObservers_sync");
}

void sub_100A6230C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18)
{
  sub_10003F600(&a18);
  if (a17 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100A62388(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31DD0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A623C8()
{
  return &off_101A31DD0;
}

void *sub_100A623D4(void *a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  uint64_t v5 = *(NSObject **)(a2 + 8);
  *a1 = v4;
  a1[1] = v5;
  if (v5)
  {
    dispatch_retain(v5);
    id v6 = a1[1];
    if (v6) {
      dispatch_group_enter(v6);
    }
  }
  return a1;
}

void sub_100A62424(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 8);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (v3) {
      dispatch_release(v3);
    }
  }
  id v4 = *(void **)a1;
}

id sub_100A62470(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "_dumpState_sync:", a2);
}

uint64_t sub_100A6247C(uint64_t a1)
{
  return a1;
}

void sub_100A624A8(uint64_t a1)
{
  operator delete();
}

void *sub_100A624F4(uint64_t a1)
{
  char v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  *char v2 = off_101A31CE0;
  v2[1] = v3;
  void v2[2] = v4;
  return v2;
}

id sub_100A6254C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  *a2 = off_101A31CE0;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100A62594(uint64_t a1)
{
}

void sub_100A6259C(id *a1)
{
  operator delete(a1);
}

void sub_100A625D8(uint64_t a1, SubscriptionInfo *a2, const object *a3)
{
  id v4 = *(void **)(a1 + 8);
  uint64_t v5 = v4 + 1;
  id v6 = (void *)v4[1];
  id v7 = (void **)*v4;
  uint64_t v8 = v6;
  if (v4[2])
  {
    void v6[2] = &v8;
    void *v4 = v5;
    void *v5 = 0;
    void v4[2] = 0;
  }
  else
  {
    id v7 = &v8;
  }
  rest::read_rest_value((rest *)v4, a2, a3);
  objc_msgSend(*(id *)(a1 + 16), "_handleSubscriptionInfoChanged_sync:", &v7);
  sub_10030A9DC((uint64_t)&v7, v8);
}

void sub_100A62658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100A62670(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31D40)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A626B0()
{
  return &off_101A31D40;
}

uint64_t sub_100A626BC(uint64_t a1)
{
  return a1;
}

void sub_100A626E8(uint64_t a1)
{
  operator delete();
}

void *sub_100A62734(uint64_t a1)
{
  char v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  *char v2 = off_101A31D60;
  v2[1] = v3;
  void v2[2] = v4;
  return v2;
}

id sub_100A6278C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  *a2 = off_101A31D60;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void sub_100A627D4(uint64_t a1)
{
}

void sub_100A627DC(id *a1)
{
  operator delete(a1);
}

void sub_100A62818(uint64_t a1, ActiveSubscriptions *a2, const object *a3)
{
  id v4 = *(rest **)(a1 + 8);
  long long v5 = *(_OWORD *)v4;
  uint64_t v6 = *((void *)v4 + 2);
  *(void *)id v4 = 0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  rest::read_rest_value(v4, a2, a3);
  objc_msgSend(*(id *)(a1 + 16), "_handleActiveSubscriptionsChanged_sync:", &v5);
  id v7 = (void **)&v5;
  sub_1007034E0(&v7);
}

void sub_100A6287C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1007034E0(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100A62898(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31DC0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A628D8()
{
  return &off_101A31DC0;
}

uint64_t sub_100A628E4(uint64_t a1)
{
  return a1;
}

void sub_100A62910(uint64_t a1)
{
  operator delete();
}

void *sub_100A6295C(uint64_t a1)
{
  char v2 = operator new(0x10uLL);
  *char v2 = off_101A31DF0;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_100A629B4(uint64_t a1, void *a2)
{
  *a2 = off_101A31DF0;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_100A629FC(uint64_t a1)
{
}

void sub_100A62A04(id *a1)
{
  operator delete(a1);
}

void sub_100A62A40(uint64_t a1)
{
  char v2 = *(void **)(a1 + 8);
  if (v2)
  {
    [v2 getLogContext];
    uint64_t v3 = v16;
  }
  else
  {
    uint64_t v3 = 0;
    std::string __p = 0;
    char v16 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Starting", (uint8_t *)&__p, 2u);
  }
  objc_msgSend(*(id *)(*(void *)(a1 + 8) + 104), "start", __p, v16);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(uint64_t **)(a1 + 8), *(Registry **)(*(void *)(a1 + 8) + 144));
  long long v5 = ServiceMap;
  if (v6 < 0)
  {
    id v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  std::string __p = (void *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_22;
      }
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_22;
  }
LABEL_15:
  uint64_t v14 = *(void **)(a1 + 8);
  if (v14) {
    [v14 getQueue];
  }
  else {
    dispatch_object_t object = 0;
  }
  sub_100058DB0(&__p, "CTXPCServer");
  (*(void (**)(uint64_t, dispatch_object_t *, void **))(*(void *)v12 + 16))(v12, &object, &__p);
  if (v17 < 0) {
    operator delete(__p);
  }
  if (object) {
    dispatch_release(object);
  }
LABEL_22:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100A62C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object)
{
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A62C60(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31E50)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A62CA0()
{
  return &off_101A31E50;
}

uint64_t sub_100A62CAC(uint64_t a1)
{
  *(void *)a1 = off_101A31E70;
  char v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }

  return a1;
}

void sub_100A62D0C(uint64_t a1)
{
  *(void *)a1 = off_101A31E70;
  char v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = *(NSObject **)(a1 + 16);
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

void *sub_100A62D8C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x18uLL);
  *char v2 = off_101A31E70;
  sub_100A623D4(v2 + 1, v1);
  return v2;
}

void *sub_100A62DE0(uint64_t a1, void *a2)
{
  *a2 = off_101A31E70;
  return sub_100A623D4(a2 + 1, a1 + 8);
}

void sub_100A62E0C(uint64_t a1)
{
}

void sub_100A62E14(void *a1)
{
  sub_100A62424((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100A62E50(uint64_t a1)
{
  char v2 = *(void **)(a1 + 8);
  if (v2)
  {
    [v2 getLogContext];
    uint64_t v3 = v6;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Shutting down", (uint8_t *)&v5, 2u);
  }
  ctu::RestModule::disconnect(*(ctu::RestModule **)(*(void *)(a1 + 8) + 8));
  uint64_t result = *(void *)(*(void *)(a1 + 8) + 72);
  if (result)
  {
    uint64_t result = os_state_remove_handler();
    *(void *)(*(void *)(a1 + 8) + 72) = 0;
  }
  return result;
}

uint64_t sub_100A62F0C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31ED0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A62F4C()
{
  return &off_101A31ED0;
}

uint64_t sub_100A62F58(uint64_t a1)
{
  *(void *)a1 = off_101A31EF0;
  char v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void sub_100A62FAC(uint64_t a1)
{
  *(void *)a1 = off_101A31EF0;
  char v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100A63020(uint64_t a1)
{
  char v2 = operator new(0x28uLL);
  *char v2 = off_101A31EF0;
  id v3 = *(id *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  v2[1] = v3;
  void v2[2] = v5;
  v2[3] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
  *((unsigned char *)v2 + 36) = *(unsigned char *)(a1 + 36);
  return v2;
}

id sub_100A630A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31EF0;
  id result = *(id *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a2 + 8) = result;
  *(void *)(a2 + 16) = v6;
  *(void *)(a2 + 24) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  int v7 = *(_DWORD *)(a1 + 32);
  *(unsigned char *)(a2 + 36) = *(unsigned char *)(a1 + 36);
  *(_DWORD *)(a2 + 32) = v7;
  return result;
}

void sub_100A63114(uint64_t a1)
{
}

void sub_100A6311C(void *a1)
{
  sub_100A6375C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A63158(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8) + 160;
  id v3 = **(id **)(a1 + 16);
  uint64_t v6 = *(void **)(v2 + 8);
  uint64_t v5 = (char *)(v2 + 8);
  uint64_t v4 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  int v7 = v5;
  do
  {
    unint64_t v8 = v4[4];
    BOOL v9 = v8 >= (unint64_t)v3;
    if (v8 >= (unint64_t)v3) {
      uint64_t v10 = v4;
    }
    else {
      uint64_t v10 = v4 + 1;
    }
    if (v9) {
      int v7 = (char *)v4;
    }
    uint64_t v4 = (void *)*v10;
  }
  while (*v10);
  if (v7 == v5 || (unint64_t)v3 < *((void *)v7 + 4)) {
LABEL_12:
  }
    int v7 = v5;

  uint64_t v11 = *(char **)(a1 + 8);
  if (v7 == v11 + 168)
  {
    if (v11)
    {
      [v11 getLogContext];
      char v13 = *(NSObject **)&buf[8];
    }
    else
    {
      char v13 = 0;
      memset(buf, 0, sizeof(buf));
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v18 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v18;
    uint64_t v19 = "setAssertionForConnection: xpc connection for connectionType %d not found";
LABEL_37:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v19, buf, 8u);
    return;
  }
  if (*(unsigned char *)(a1 + 36))
  {
    if (v11)
    {
      [v11 getLogContext];
      uint64_t v12 = *(NSObject **)&buf[8];
    }
    else
    {
      uint64_t v12 = 0;
      memset(buf, 0, sizeof(buf));
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "setAssertionForConnection: added dataConnection Assertion for connectionType %d", buf, 8u);
    }
    memset(buf, 0, sizeof(buf));
    sub_1011DEFFC(buf);
  }
  uint64_t v14 = *((void *)v7 + 10);
  uint64_t v15 = *((void *)v7 + 11);
  if (v14 == v15)
  {
LABEL_23:
    if (v11)
    {
      [v11 getLogContext];
      char v13 = *(NSObject **)&buf[8];
    }
    else
    {
      char v13 = 0;
      memset(buf, 0, sizeof(buf));
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v21 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    uint64_t v19 = "setAssertionForConnection: failed removing dataConnection Assertion. ConnectionType %d not found";
    goto LABEL_37;
  }
  uint64_t v16 = -v14;
  while (*(_DWORD *)(*(void *)v14 + 16) != *(_DWORD *)(a1 + 32))
  {
    v14 += 16;
    v16 -= 16;
    if (v14 == v15) {
      goto LABEL_23;
    }
  }
  if (v11)
  {
    [v11 getLogContext];
    uint64_t v20 = *(NSObject **)&buf[8];
  }
  else
  {
    uint64_t v20 = 0;
    memset(buf, 0, sizeof(buf));
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "setAssertionForConnection: removed dataConnection Assertion for connectionType %d", buf, 8u);
  }
  uint64_t v23 = (long long *)(16 - v16);
  int v24 = (long long *)*((void *)v7 + 11);
  if ((long long *)(16 - v16) == v24)
  {
    uint64_t v27 = -v16;
  }
  else
  {
    do
    {
      long long v25 = *v23;
      *(void *)uint64_t v23 = 0;
      *((void *)v23 + 1) = 0;
      uint64_t v26 = (std::__shared_weak_count *)*((void *)v23 - 1);
      *(v23 - 1) = v25;
      if (v26) {
        sub_10004D2C8(v26);
      }
      ++v23;
    }
    while (v23 != v24);
    uint64_t v27 = (uint64_t)(v23 - 1);
    uint64_t v23 = (long long *)*((void *)v7 + 11);
  }
  while (v23 != (long long *)v27)
  {
    xpc_object_t v28 = (std::__shared_weak_count *)*((void *)v23 - 1);
    if (v28) {
      sub_10004D2C8(v28);
    }
    --v23;
  }
  *((void *)v7 + 11) = v27;
}

void sub_100A636C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A63710(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31F50)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A63750()
{
  return &off_101A31F50;
}

void sub_100A6375C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(void **)a1;
}

uint64_t sub_100A6379C(uint64_t a1)
{
  *(void *)a1 = off_101A31F70;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void sub_100A637F0(uint64_t a1)
{
  *(void *)a1 = off_101A31F70;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100A63864(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = off_101A31F70;
  sub_100A63DB4(v2 + 1, v1);
  return v2;
}

void *sub_100A638B8(uint64_t a1, void *a2)
{
  *a2 = off_101A31F70;
  return sub_100A63DB4(a2 + 1, a1 + 8);
}

void sub_100A638E4(uint64_t a1)
{
}

void sub_100A638EC(void *a1)
{
  sub_100A6375C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A63928(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8) + 160;
  id v3 = (Registry *)**(id **)(a1 + 16);
  uint64_t v6 = *(void **)(v2 + 8);
  uint64_t v5 = v2 + 8;
  uint64_t v4 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  int v7 = (Registry **)v5;
  do
  {
    unint64_t v8 = v4[4];
    BOOL v9 = v8 >= (unint64_t)v3;
    if (v8 >= (unint64_t)v3) {
      uint64_t v10 = v4;
    }
    else {
      uint64_t v10 = v4 + 1;
    }
    if (v9) {
      int v7 = (Registry **)v4;
    }
    uint64_t v4 = (void *)*v10;
  }
  while (*v10);
  if (v7 == (Registry **)v5 || v3 < v7[4]) {
LABEL_12:
  }
    int v7 = (Registry **)v5;

  uint64_t v11 = *(Registry ***)(a1 + 8);
  if (v7 == v11 + 21)
  {
    if (v11)
    {
      [v11 getLogContext];
      uint64_t v26 = *(NSObject **)&v36[8];
    }
    else
    {
      uint64_t v26 = 0;
      *(void *)__int16 v36 = 0;
      *(void *)&v36[8] = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = *(void *)(a1 + 32);
      *(_DWORD *)__int16 v36 = 134217984;
      *(void *)&v36[4] = v30;
      BOOL v31 = "setApplicationCategory: xpc connection for category %llu not found";
LABEL_40:
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v31, v36, 0xCu);
    }
  }
  else
  {
    uint64_t v12 = v7[5];
    if (v12)
    {
      uint64_t v13 = *(_DWORD *)v12;
      ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0x90, v11[18]);
      uint64_t v15 = ServiceMap;
      if (v16 < 0)
      {
        int v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v18 = 5381;
        do
        {
          uint64_t v16 = v18;
          unsigned int v19 = *v17++;
          uint64_t v18 = (33 * v18) ^ v19;
        }
        while (v19);
      }
      std::mutex::lock(ServiceMap);
      *(void *)__int16 v36 = v16;
      uint64_t v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)v36);
      if (v20)
      {
        uint64_t v22 = v20[3];
        int v21 = (std::__shared_weak_count *)v20[4];
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v15);
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v21);
          char v23 = 0;
          if (!v22) {
            goto LABEL_21;
          }
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v15);
      int v21 = 0;
      char v23 = 1;
      if (!v22)
      {
LABEL_21:
        int v24 = *(void **)(a1 + 8);
        if (v24)
        {
          [v24 getLogContext];
          long long v25 = *(NSObject **)&v36[8];
        }
        else
        {
          long long v25 = 0;
          *(void *)__int16 v36 = 0;
          *(void *)&v36[8] = 0;
        }
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int16 v36 = 0;
          xpc_object_t v35 = "DataService empty";
          goto LABEL_54;
        }
        goto LABEL_50;
      }
LABEL_29:
      uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 872))(v22);
      if (v27)
      {
        xpc_object_t v28 = *(void **)(a1 + 8);
        if (v28)
        {
          [v28 getLogContext];
          xpc_object_t v29 = *(NSObject **)&v36[8];
        }
        else
        {
          xpc_object_t v29 = 0;
          *(void *)__int16 v36 = 0;
          *(void *)&v36[8] = 0;
        }
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = *(void *)(a1 + 32);
          *(_DWORD *)__int16 v36 = 134218240;
          *(void *)&v36[4] = v34;
          *(_WORD *)&v36[12] = 1024;
          *(_DWORD *)&v36[14] = v13;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "setApplicationCategory: %llu for pid %d", v36, 0x12u);
        }
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v27 + 120))(v27, v13, *(void *)(a1 + 32));
      }
      else
      {
        BOOL v32 = *(void **)(a1 + 8);
        if (v32)
        {
          [v32 getLogContext];
          long long v25 = *(NSObject **)&v36[8];
        }
        else
        {
          long long v25 = 0;
          *(void *)__int16 v36 = 0;
          *(void *)&v36[8] = 0;
        }
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int16 v36 = 0;
          xpc_object_t v35 = "SliceManager empty";
LABEL_54:
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v35, v36, 2u);
          if (v23) {
            return;
          }
LABEL_51:
          sub_10004D2C8(v21);
          return;
        }
      }
LABEL_50:
      if (v23) {
        return;
      }
      goto LABEL_51;
    }
    if (v11)
    {
      [v11 getLogContext];
      uint64_t v26 = *(NSObject **)&v36[8];
    }
    else
    {
      uint64_t v26 = 0;
      *(void *)__int16 v36 = 0;
      *(void *)&v36[8] = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = *(void *)(a1 + 32);
      *(_DWORD *)__int16 v36 = 134217984;
      *(void *)&v36[4] = v33;
      BOOL v31 = "setApplicationCategory: process info for category %llu not found";
      goto LABEL_40;
    }
  }
}

void sub_100A63D2C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A63D68(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A31FD0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A63DA8()
{
  return &off_101A31FD0;
}

void *sub_100A63DB4(void *a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  *a1 = v4;
  a1[1] = v6;
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[3] = *(void *)(a2 + 24);
  return a1;
}

uint64_t sub_100A63E08(uint64_t a1)
{
  return a1;
}

void sub_100A63E34(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));

  operator delete();
}

id *sub_100A63E80(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 8);
  char v2 = (id *)operator new(0x10uLL);
  *char v2 = off_101A31FF0;
  objc_copyWeak(v2 + 1, v1);
  return v2;
}

void sub_100A63ED4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A31FF0;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
}

void sub_100A63F00(uint64_t a1)
{
}

void sub_100A63F08(id *a1)
{
  objc_destroyWeak(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100A63F44(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32050)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A63F84()
{
  return &off_101A32050;
}

uint64_t sub_100A63F90(uint64_t a1)
{
  return a1;
}

void sub_100A63FBC(uint64_t a1)
{
  operator delete();
}

void *sub_100A64008(uint64_t a1)
{
  char v2 = operator new(0x10uLL);
  *char v2 = off_101A32070;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_100A64060(uint64_t a1, void *a2)
{
  *a2 = off_101A32070;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_100A640A8(uint64_t a1)
{
}

void sub_100A640B0(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A640EC(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v7 = *a3;
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  xpc_object_t v4 = xpc_null_create();
  uint64_t v5 = *(void **)(a1 + 8);
  xpc_object_t v9 = v4;
  long long v10 = v7;
  v8[1] = 0;
  _OWORD v8[2] = 0;
  v8[0] = xpc_null_create();
  objc_msgSend(v5, "_handleGetClientsQuery_sync:", &v9);
  sub_100A641CC((uint64_t)&v9);
  return sub_100A641CC((uint64_t)v8);
}

void sub_100A6415C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_100A641CC((uint64_t)va1);
  sub_100A641CC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A64180(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A320D0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A641C0()
{
  return &off_101A320D0;
}

uint64_t sub_100A641CC(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    xpc_object_t v2 = *(xpc_object_t *)a1;
    if (*(void *)a1) {
      xpc_retain(*(xpc_object_t *)a1);
    }
    else {
      xpc_object_t v2 = xpc_null_create();
    }
    id v3 = *(void ***)(a1 + 8);
    uint64_t v4 = *v3;
    Registry *v3 = v2;
    xpc_release(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }
  xpc_release(*(xpc_object_t *)a1);
  *(void *)a1 = 0;
  return a1;
}

void sub_100A64248(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A320F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A64268(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A320F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A642BC(uint64_t a1)
{
  *(void *)a1 = off_101A32140;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(a1 + 32));
  xpc_object_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  objc_destroyWeak((id *)(a1 + 8));
  return a1;
}

void sub_100A64314(uint64_t a1)
{
  *(void *)a1 = off_101A32140;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(a1 + 32));
  xpc_object_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  objc_destroyWeak((id *)(a1 + 8));

  operator delete();
}

uint64_t sub_100A6438C(uint64_t a1, void *a2)
{
  *a2 = off_101A32140;
  return sub_100026E70((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100A643B8(uint64_t a1)
{
}

uint64_t sub_100A643C0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A321A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A64400()
{
  return &off_101A321A0;
}

uint64_t sub_100A6440C(uint64_t a1)
{
  return a1;
}

void sub_100A64440(uint64_t a1)
{
  operator delete();
}

void *sub_100A64494(uint64_t a1)
{
  xpc_object_t v2 = operator new(0x18uLL);
  *xpc_object_t v2 = off_101A321C0;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = *(id *)(a1 + 16);
  return v2;
}

void sub_100A644F8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6453C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32220)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6457C()
{
  return &off_101A32220;
}

void sub_100A64588()
{
}

uint64_t sub_100A645B0(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (TelephonyRadiosGetRadioVendor() != 1) {
    return a1;
  }
  xpc_object_t v2 = (std::__shared_weak_count *)operator new(0x90uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_101A32290;
  id v3 = v2 + 1;
  QMIServerConnection::QMIServerConnection((QMIServerConnection *)&v2[1]);
  shared_weak_owners = (std::__shared_weak_count *)v2[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      goto LABEL_7;
    }
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v2[1].__shared_owners_ = (uint64_t)v3;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v2[1].__shared_owners_ = (uint64_t)v3;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
  }
  sub_10004D2C8(v2);
LABEL_7:
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = v2;
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_100A64690(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v4);
  uint64_t v5 = (std::__shared_weak_count *)v1[5];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)v1[3];
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)v1[1];
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  _Unwind_Resume(a1);
}

void sub_100A646D8(void *a1@<X8>)
{
  xpc_object_t v2 = operator new(0x48uLL);
  sub_100A6473C(v2);
  *a1 = v2 + 3;
  a1[1] = v2;

  sub_1000B3BC8((uint64_t)a1, v2 + 3, (uint64_t)(v2 + 3));
}

void sub_100A64728(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100A6473C(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A32240;
  sub_100A645B0((uint64_t)(a1 + 3));
  return a1;
}

void sub_100A64784(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100A64798(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A647B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32240;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A6480C(void *a1)
{
  xpc_object_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = (std::__shared_weak_count *)a1[6];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_100A6486C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32290;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6488C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32290;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A648E0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

CFIndex sub_100A64908()
{
  qword_101B13E98 = CFStringGetLength(@"GID1-");
  qword_101B13EA0 = CFStringGetLength(@"GID2-");
  qword_101B13EA8 = CFStringGetLength(@"ID-");
  CFIndex result = CFStringGetLength(@"bs-");
  qword_101B13EB0 = result;
  qword_101B13EB8 = kCTPostponementInfoICCID;
  qword_101B13EC0 = kCTPostponementInfoIMSI;
  qword_101B13EC8 = kCTPostponementInfoMEID;
  qword_101B13ED0 = kCTPostponementInfoCarrierID;
  return result;
}

void sub_100A64B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100060644((uint64_t *)va);
  if (a5) {
    sub_10004D2C8(a5);
  }

  _Unwind_Resume(a1);
}

void sub_100A64D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  sub_10065C870(&a16);
  sub_100A64DE0((uint64_t)&a9);
  if (a14) {
    sub_10004D2C8(a14);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100A64DE0(uint64_t a1)
{
  xpc_object_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_100A65054(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100A65310(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100A65378(uint64_t a1)
{
  return a1;
}

void sub_100A653A4(uint64_t a1)
{
  operator delete();
}

void *sub_100A653F0(uint64_t a1)
{
  xpc_object_t v2 = operator new(0x10uLL);
  *xpc_object_t v2 = off_101A32400;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A65448(uint64_t a1, void *a2)
{
  *a2 = off_101A32400;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A65490(uint64_t a1)
{
}

void sub_100A65498(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A654D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A654EC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32460)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6552C()
{
  return &off_101A32460;
}

uint64_t sub_100A65538(uint64_t a1)
{
  *(void *)a1 = off_101A32480;
  xpc_object_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  return a1;
}

void sub_100A6558C(uint64_t a1)
{
  *(void *)a1 = off_101A32480;
  xpc_object_t v2 = *(NSObject **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }

  operator delete();
}

void *sub_100A65600(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  xpc_object_t v2 = operator new(0x18uLL);
  *xpc_object_t v2 = off_101A32480;
  sub_100A65854(v2 + 1, v1);
  return v2;
}

void *sub_100A65654(uint64_t a1, void *a2)
{
  *a2 = off_101A32480;
  return sub_100A65854(a2 + 1, a1 + 8);
}

void sub_100A65680(uint64_t a1)
{
}

void sub_100A65688(void *a1)
{
  sub_100A65898((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100A656C4(uint64_t a1, uint64_t a2, long long *a3)
{
  objc_retainBlock(*(id *)(a1 + 8));
  sub_100A65D7C((uint64_t)&v4, a3);
  operator new();
}

void sub_100A657D8(void *a1)
{
  sub_10006A6AC(a1);
}

void sub_100A657F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100A65808(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A324F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A65848()
{
  return &off_101A324F0;
}

void *sub_100A65854(void *a1, uint64_t a2)
{
  id v4 = objc_retainBlock(*(id *)a2);
  uint64_t v5 = *(NSObject **)(a2 + 8);
  *a1 = v4;
  a1[1] = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  return a1;
}

void sub_100A65898(uint64_t a1)
{
  xpc_object_t v2 = *(NSObject **)(a1 + 8);
  if (v2) {
    dispatch_release(v2);
  }
  char v3 = *(void **)a1;
}

uint64_t *sub_100A658D8(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    xpc_object_t v2 = *(void **)(v1 + 152);
    if (v2)
    {
      *(void *)(v1 + 16ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v2;
      operator delete(v2);
    }
    char v3 = *(void **)(v1 + 128);
    if (v3)
    {
      *(void *)(v1 + 136) = v3;
      operator delete(v3);
    }
    id v4 = *(void **)(v1 + 104);
    if (v4)
    {
      *(void *)(v1 + 112) = v4;
      operator delete(v4);
    }
    uint64_t v5 = *(void **)(v1 + 80);
    if (v5)
    {
      *(void *)(v1 + 88) = v5;
      operator delete(v5);
    }

    operator delete();
  }
  return result;
}

uint64_t *sub_100A65968(uint64_t a1)
{
  uint64_t v38 = a1;
  if (*(unsigned char *)(a1 + 8))
  {
    id v2 = objc_alloc_init((Class)CTRadioFrequencyFrontEndScanData);
    [v2 setVersion:*(unsigned int *)(a1 + 16)];
    [v2 setHwPrdId:*(unsigned int *)(a1 + 20)];
    [v2 setHwSku:*(unsigned int *)(a1 + 24)];
    [v2 setHwRev:*(unsigned int *)(a1 + 28)];
    [v2 setHwHousing:*(unsigned int *)(a1 + 32)];
    [v2 setRfcInitPass:*(unsigned __int8 *)(a1 + 36)];
    [v2 setRfcHwid:*(unsigned int *)(a1 + 40)];
    [v2 setRfcRev:*(unsigned int *)(a1 + 44)];
    [v2 setRfcMmwHwid:*(unsigned int *)(a1 + 48)];
    [v2 setRfcMmwRev:*(unsigned int *)(a1 + 52)];
    [v2 setFr2TrxRev:*(unsigned int *)(a1 + 56)];
    [v2 setRffeScanPass:*(unsigned __int8 *)(a1 + 60)];
    [v2 setNumExpectedDevices:*(unsigned int *)(a1 + 64)];
    [v2 setNumDetectedDevices:*(unsigned int *)(a1 + 68)];
    [v2 setNumMissingDevices:*(unsigned int *)(a1 + 72)];
    uint64_t v4 = *(void *)(a1 + 80);
    uint64_t v3 = *(void *)(a1 + 88);
    unint64_t v5 = v3 - v4;
    if (v3 != v4)
    {
      id v6 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v5];
      [v2 setRffeScanInfo:v6];

      uint64_t v7 = 0;
      unsigned int v8 = 1;
      do
      {
        xpc_object_t v9 = [v2 rffeScanInfo];
        long long v10 = +[NSNumber numberWithInteger:*(unsigned __int8 *)(*(void *)(a1 + 80) + v7)];
        [v9 addObject:v10];

        uint64_t v7 = v8;
        BOOL v11 = v5 > v8++;
      }
      while (v11);
    }
    uint64_t v13 = *(void *)(a1 + 104);
    uint64_t v12 = *(void *)(a1 + 112);
    unint64_t v14 = v12 - v13;
    if (v12 != v13)
    {
      id v15 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v14];
      [v2 setMissingRffeDevices:v15];

      uint64_t v16 = 0;
      unsigned int v17 = 1;
      do
      {
        uint64_t v18 = [v2 missingRffeDevices];
        unsigned int v19 = +[NSNumber numberWithInteger:*(unsigned __int8 *)(*(void *)(a1 + 104) + v16)];
        [v18 addObject:v19];

        uint64_t v16 = v17;
        BOOL v11 = v14 > v17++;
      }
      while (v11);
    }
    uint64_t v21 = *(void *)(a1 + 128);
    uint64_t v20 = *(void *)(a1 + 136);
    unint64_t v22 = v20 - v21;
    if (v20 != v21)
    {
      id v23 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v22];
      [v2 setMissingAtDevices:v23];

      uint64_t v24 = 0;
      unsigned int v25 = 1;
      do
      {
        uint64_t v26 = [v2 missingAtDevices];
        uint64_t v27 = +[NSNumber numberWithInteger:*(unsigned __int8 *)(*(void *)(a1 + 128) + v24)];
        [v26 addObject:v27];

        uint64_t v24 = v25;
        BOOL v11 = v22 > v25++;
      }
      while (v11);
    }
    uint64_t v29 = *(void *)(a1 + 152);
    uint64_t v28 = *(void *)(a1 + 160);
    unint64_t v30 = v28 - v29;
    if (v28 != v29)
    {
      id v31 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v30];
      [v2 setMissingMmwDevices:v31];

      uint64_t v32 = 0;
      unsigned int v33 = 1;
      do
      {
        uint64_t v34 = [v2 missingMmwDevices];
        xpc_object_t v35 = +[NSNumber numberWithInteger:*(unsigned __int8 *)(*(void *)(a1 + 152) + v32)];
        [v34 addObject:v35];

        uint64_t v32 = v33;
        BOOL v11 = v30 > v33++;
      }
      while (v11);
    }
    (*(void (**)(void))(*(void *)a1 + 16))();
  }
  else
  {
    uint64_t v36 = *(void *)a1;
    id v2 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*(void (**)(uint64_t, void, id))(v36 + 16))(v36, 0, v2);
  }

  return sub_100A658D8(&v38);
}

void sub_100A65CF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100A658D8((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100A65D7C(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  long long v6 = a2[2];
  *(_OWORD *)(a1 + 44) = *(long long *)((char *)a2 + 44);
  *(_OWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  sub_10005C928((void *)(a1 + 64), *((const void **)a2 + 8), *((void *)a2 + 9), *((void *)a2 + 9) - *((void *)a2 + 8));
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  sub_10005C928((void *)(a1 + 88), *((const void **)a2 + 11), *((void *)a2 + 12), *((void *)a2 + 12) - *((void *)a2 + 11));
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 12ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(void *)(a1 + 128) = 0;
  sub_10005C928((void *)(a1 + 112), *((const void **)a2 + 14), *((void *)a2 + 15), *((void *)a2 + 15) - *((void *)a2 + 14));
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  sub_10005C928((void *)(a1 + 136), *((const void **)a2 + 17), *((void *)a2 + 18), *((void *)a2 + 18) - *((void *)a2 + 17));
  return a1;
}

void sub_100A65E3C(_Unwind_Exception *exception_object)
{
  long long v6 = *v4;
  if (*v4)
  {
    v1[15] = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v3;
  if (*v3)
  {
    v1[12] = v7;
    operator delete(v7);
  }
  unsigned int v8 = *v2;
  if (*v2)
  {
    v1[9] = v8;
    operator delete(v8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A65E88(uint64_t a1)
{
  return a1;
}

void sub_100A65EB4(uint64_t a1)
{
  operator delete();
}

void *sub_100A65F00(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_101A32510;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A65F58(uint64_t a1, void *a2)
{
  *a2 = off_101A32510;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A65FA0(uint64_t a1)
{
}

void sub_100A65FA8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A65FE4(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *a2);
  }
  return result;
}

uint64_t sub_100A66000(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32570)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A66040()
{
  return &off_101A32570;
}

void sub_100A6604C(uint64_t *a1, os_log_t *a2, xpc_object_t *a3)
{
  uint64_t v5 = *a1;
  long long v6 = *a2;
  BOOL v7 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      sub_100A66D28((uint64_t)v11, *a3);
      sub_100A66208((uint64_t)v11, __p);
      if (v13 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136380675;
      id v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [CT] ==>> laz ==>> [IPT] terminateChat: %{private}s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      sub_100179294((uint64_t)v11);
      uint64_t v5 = *a1;
    }
    xpc_object_t v9 = *a3;
    xpc_object_t object = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 16))(v5, &object);
    xpc_release(object);
  }
  else if (v7)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid chat during terminateChat", (uint8_t *)__p, 2u);
  }
}

void sub_100A661C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

uint64_t sub_100A66208@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)char v13 = 0u;
  long long v14 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v11 = 0u;
  sub_10004BD84((uint64_t)&v11);
  *(_DWORD *)((char *)v12 + *(void *)(*(void *)&v12[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v12
                                                                                    + *(void *)(*(void *)&v12[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFFB5 | 8;
  sub_10004B96C(v12, (uint64_t)"[Chat: ", 7);
  long long v4 = (void *)std::ostream::operator<<();
  sub_10004B96C(v4, (uint64_t)"] ", 2);
  if (*(unsigned char *)(a1 + 8))
  {
    sub_100120074((xpc_object_t *)a1, __p);
    uint64_t v5 = v10 >= 0 ? (const char *)__p : (const char *)__p[0];
    size_t v6 = strlen(v5);
    sub_10004B96C(v12, (uint64_t)v5, v6);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_10004BC98((uint64_t)v12 + 8, a2);
  *(void *)((char *)&v12[-1]
  *(void *)&v12[0] = v7;
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100A6644C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100A6647C(uint64_t *a1, os_log_t *a2, xpc_object_t *a3)
{
  uint64_t v5 = *a1;
  size_t v6 = *a2;
  BOOL v7 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      sub_100A66D28((uint64_t)v11, *a3);
      sub_100A66208((uint64_t)v11, __p);
      if (v13 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136315138;
      long long v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [CT] ==>> laz ==>> [IPT] changeGroupChatInfo: %{senstive}s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      sub_100179294((uint64_t)v11);
      uint64_t v5 = *a1;
    }
    xpc_object_t v9 = *a3;
    xpc_object_t object = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 24))(v5, &object);
    xpc_release(object);
  }
  else if (v7)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid chat during changeGroupChatInfo", (uint8_t *)__p, 2u);
  }
}

void sub_100A665F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_100A66638(uint64_t *a1, os_log_t *a2, xpc_object_t *a3)
{
  uint64_t v5 = *a1;
  size_t v6 = *a2;
  BOOL v7 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      sub_100A66D28((uint64_t)v11, *a3);
      sub_100A66208((uint64_t)v11, __p);
      if (v13 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136380675;
      long long v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [CT] ==>> laz ==>> [IPT] sendMessage: %{private}s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      sub_100179294((uint64_t)v11);
      uint64_t v5 = *a1;
    }
    xpc_object_t v9 = *a3;
    xpc_object_t object = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 32))(v5, &object);
    xpc_release(object);
  }
  else if (v7)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid chat during sendMessage", (uint8_t *)__p, 2u);
  }
}

void sub_100A667B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_100A667F4(uint64_t *a1, os_log_t *a2, xpc_object_t *a3)
{
  uint64_t v5 = *a1;
  size_t v6 = *a2;
  BOOL v7 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      sub_100A66D28((uint64_t)v11, *a3);
      sub_100A66208((uint64_t)v11, __p);
      if (v13 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136380675;
      long long v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [CT] ==>> laz ==>> [IPT] addParticipant: %{private}s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      sub_100179294((uint64_t)v11);
      uint64_t v5 = *a1;
    }
    xpc_object_t v9 = *a3;
    xpc_object_t object = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 40))(v5, &object);
    xpc_release(object);
  }
  else if (v7)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid chat during addParticipant", (uint8_t *)__p, 2u);
  }
}

void sub_100A66970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_100A669B0(uint64_t *a1, os_log_t *a2, xpc_object_t *a3)
{
  uint64_t v5 = *a1;
  size_t v6 = *a2;
  BOOL v7 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      sub_100A66D28((uint64_t)v11, *a3);
      sub_100A66208((uint64_t)v11, __p);
      if (v13 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136380675;
      long long v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [CT] ==>> laz ==>> [IPT] removeParticipant: %{private}s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      sub_100179294((uint64_t)v11);
      uint64_t v5 = *a1;
    }
    xpc_object_t v9 = *a3;
    xpc_object_t object = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 48))(v5, &object);
    xpc_release(object);
  }
  else if (v7)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid chat during removeParticipant", (uint8_t *)__p, 2u);
  }
}

void sub_100A66B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_100A66B6C(uint64_t *a1, os_log_t *a2, xpc_object_t *a3)
{
  uint64_t v5 = *a1;
  size_t v6 = *a2;
  BOOL v7 = os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      sub_100A66D28((uint64_t)v11, *a3);
      sub_100A66208((uint64_t)v11, __p);
      if (v13 >= 0) {
        unsigned int v8 = __p;
      }
      else {
        unsigned int v8 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136380675;
      long long v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [CT] ==>> laz ==>> [IPT] leaveGroupChat: %{private}s", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      sub_100179294((uint64_t)v11);
      uint64_t v5 = *a1;
    }
    xpc_object_t v9 = *a3;
    xpc_object_t object = v9;
    if (v9) {
      xpc_retain(v9);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    (*(void (**)(uint64_t, xpc_object_t *))(*(void *)v5 + 112))(v5, &object);
    xpc_release(object);
  }
  else if (v7)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Invalid chat during leaveGroupChat", (uint8_t *)__p, 2u);
  }
}

void sub_100A66CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

uint64_t sub_100A66D28(uint64_t a1, xpc_object_t object)
{
  *(void *)a1 = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    *(void *)a1 = xpc_null_create();
  }
  *(unsigned char *)(a1 + 8) = 1;
  return a1;
}

void sub_100A6701C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100A6776C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, char a13, void *a14, uint64_t a15, void *a16, uint64_t a17, void **a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  a18 = (void **)&a29;
  sub_100A6AABC(&a18);
  if ((a13 & 1) == 0) {
    sub_10004D2C8(a11);
  }

  _Unwind_Resume(a1);
}

void sub_100A67B18(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100A67E14(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100A681B0(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100A6850C(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100A68880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

void sub_100A68FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__shared_weak_count *a9, int a10, char a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a27) {
    sub_10004D2C8(a27);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a9);
  }

  _Unwind_Resume(a1);
}

void sub_100A69550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }

  _Unwind_Resume(a1);
}

void sub_100A69964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

void sub_100A69E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }

  _Unwind_Resume(a1);
}

void sub_100A6A1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

void sub_100A6A5C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

void sub_100A6A9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100A6AA58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_100030068((const void **)(i - 8));
    sub_100030068((const void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100A6AABC(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100A6AB10((const void **)v2, (const void **)*v2);
    char v3 = **a1;
    operator delete(v3);
  }
}

const void **sub_100A6AB10(const void **result, const void **a2)
{
  char v3 = result;
  for (uint64_t i = (const void **)result[1]; i != a2; i -= 3)
  {
    sub_100030068(i - 1);
    uint64_t result = sub_100030068(i - 2);
  }
  v3[1] = a2;
  return result;
}

uint64_t sub_100A6AB6C(uint64_t a1)
{
  return a1;
}

void sub_100A6ABA0(uint64_t a1)
{
  operator delete();
}

void *sub_100A6ABF4(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  *uint64_t v2 = off_101A32590;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100A6AC58(uint64_t a1, void *a2)
{
  *a2 = off_101A32590;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100A6ACB0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100A6ACEC(id *a1)
{
  operator delete(a1);
}

void sub_100A6AD30(uint64_t a1, unsigned int **a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  if (a2[1] == *a2)
  {
    char v10 = 0;
  }
  else
  {
    size_t v6 = objc_opt_new();
    unsigned int v8 = *a2;
    for (uint64_t i = a2[1]; v8 != i; v8 += 10)
    {
      id v9 = [objc_alloc((Class)CTTransportKey) initWithKey:*((void *)v8 + 2) epki:*((void *)v8 + 1) forIdx:*v8 toReplaceEpki:*((void *)v8 + 3) isLastResort:*((unsigned __int8 *)v8 + 32)];
      [v6 addObject:v9];
    }
    char v10 = v6;
  }
  long long v11 = *(void **)(a1 + 8);
  if (v11)
  {
    [v11 getLogContext];
    char v12 = v16;
  }
  else
  {
    char v12 = 0;
    uint64_t v15 = 0;
    long long v16 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "processed getTransportKeysToUpdate", (uint8_t *)&v15, 2u);
  }
  uint64_t v13 = *(void *)(a1 + 16);
  id v14 = [objc_alloc((Class)CTTransportKeysUpdate) initWith:v10 sps:v4];
  (*(void (**)(uint64_t, id, void))(v13 + 16))(v13, v14, 0);
}

void sub_100A6AE90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100A6AEC8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32600)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6AF08()
{
  return &off_101A32600;
}

void *sub_100A6AF14(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100A6AF98(uint64_t a1)
{
  return a1;
}

void sub_100A6AFCC(uint64_t a1)
{
  operator delete();
}

void *sub_100A6B020(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  *uint64_t v2 = off_101A32620;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100A6B084(uint64_t a1, void *a2)
{
  *a2 = off_101A32620;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100A6B0DC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100A6B118(id *a1)
{
  operator delete(a1);
}

void sub_100A6B15C(uint64_t a1, const __CFUUID **a2, uint64_t *a3, uint64_t *a4)
{
  CFUUIDRef v5 = *a2;
  uint64_t v6 = *a3;
  uint64_t v7 = *a4;
  id v8 = objc_alloc((Class)CTSatelliteMessagingProvisioning);
  id v9 = sub_1005B0A4C(v5);
  id v10 = [v8 initWithID:v9 data:v6 sps:v7];

  long long v11 = *(void **)(a1 + 8);
  if (v11)
  {
    [v11 getLogContext];
    char v12 = v14;
  }
  else
  {
    char v12 = 0;
    uint64_t v13 = 0;
    id v14 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v13) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "processed getSatelliteMsgCfgToUpdate", (uint8_t *)&v13, 2u);
  }
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
}

void sub_100A6B258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100A6B278(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32690)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6B2B8()
{
  return &off_101A32690;
}

void *sub_100A6B2C4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100A6B348(uint64_t a1)
{
  return a1;
}

void sub_100A6B374(uint64_t a1)
{
  operator delete();
}

void *sub_100A6B3C0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A326B0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6B418(uint64_t a1, void *a2)
{
  *a2 = off_101A326B0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6B460(uint64_t a1)
{
}

void sub_100A6B468(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6B4A4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6B4B8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32710)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6B4F8()
{
  return &off_101A32710;
}

void sub_100A6B504(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32730;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6B524(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32730;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

const void **sub_100A6B578(const void **a1)
{
  uint64_t v2 = a1 + 3;
  sub_1000558F4(a1 + 8);
  sub_100044D00(a1 + 6);
  sub_1000558F4(a1 + 5);
  sub_100044D00(a1 + 4);

  return sub_1000558F4(v2);
}

uint64_t sub_100A6B5D4(uint64_t a1)
{
  return a1;
}

void sub_100A6B600(uint64_t a1)
{
  operator delete();
}

void *sub_100A6B64C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A32780;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6B6A4(uint64_t a1, void *a2)
{
  *a2 = off_101A32780;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6B6EC(uint64_t a1)
{
}

void sub_100A6B6F4(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6B730(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6B748(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A327F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6B788()
{
  return &off_101A327F0;
}

uint64_t sub_100A6B794(uint64_t a1)
{
  return a1;
}

void sub_100A6B7C0(uint64_t a1)
{
  operator delete();
}

void *sub_100A6B80C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A32810;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6B864(uint64_t a1, void *a2)
{
  *a2 = off_101A32810;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6B8AC(uint64_t a1)
{
}

void sub_100A6B8B4(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6B8F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6B904(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32870)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6B944()
{
  return &off_101A32870;
}

uint64_t sub_100A6B950(uint64_t a1)
{
  return a1;
}

void sub_100A6B97C(uint64_t a1)
{
  operator delete();
}

void *sub_100A6B9C8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A32890;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6BA20(uint64_t a1, void *a2)
{
  *a2 = off_101A32890;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6BA68(uint64_t a1)
{
}

void sub_100A6BA70(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6BAAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6BAC0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A328F0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6BB00()
{
  return &off_101A328F0;
}

uint64_t sub_100A6BB0C(uint64_t a1)
{
  return a1;
}

void sub_100A6BB38(uint64_t a1)
{
  operator delete();
}

void *sub_100A6BB84(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A32910;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6BBDC(uint64_t a1, void *a2)
{
  *a2 = off_101A32910;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6BC24(uint64_t a1)
{
}

void sub_100A6BC2C(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6BC68(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6BC80(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32980)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6BCC0()
{
  return &off_101A32980;
}

uint64_t sub_100A6BCCC(uint64_t a1)
{
  return a1;
}

void sub_100A6BCF8(uint64_t a1)
{
  operator delete();
}

void *sub_100A6BD44(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A329A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6BD9C(uint64_t a1, void *a2)
{
  *a2 = off_101A329A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6BDE4(uint64_t a1)
{
}

void sub_100A6BDEC(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6BE28(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6BE3C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32A10)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6BE7C()
{
  return &off_101A32A10;
}

uint64_t sub_100A6BE88(uint64_t a1)
{
  return a1;
}

void sub_100A6BEB4(uint64_t a1)
{
  operator delete();
}

void *sub_100A6BF00(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A32A30;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6BF58(uint64_t a1, void *a2)
{
  *a2 = off_101A32A30;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6BFA0(uint64_t a1)
{
}

void sub_100A6BFA8(id *a1)
{
  operator delete(a1);
}

void sub_100A6BFE4(uint64_t a1, void **a2)
{
  if (*a2)
  {
    uint64_t v4 = objc_opt_new();
    [v4 setBitRateMaxUL:**a2];
    [v4 setBitRateMaxDL:(*a2)[1]];
    [v4 setBitRateGuaranteedUL:(*a2)[2]];
    id v5 = v4;
    [v4 setBitRateGuaranteedDL:(*a2)[3]];
  }
  else
  {
    id v5 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100A6C0B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100A6C0CC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32AA0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6C10C()
{
  return &off_101A32AA0;
}

uint64_t sub_100A6C118(uint64_t a1)
{
  return a1;
}

void sub_100A6C144(uint64_t a1)
{
  operator delete();
}

void *sub_100A6C190(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = off_101A32AC0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100A6C1E8(uint64_t a1, void *a2)
{
  *a2 = off_101A32AC0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100A6C230(uint64_t a1)
{
}

void sub_100A6C238(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100A6C274(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100A6C288(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A32B20)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100A6C2C8()
{
  return &off_101A32B20;
}

void sub_100A6C2D4(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = 0;
  uint64_t v1 = (capabilities::ct *)(*(void *(**)(void *__return_ptr))(*(void *)a1 + 40))(v3);
  if (capabilities::ct::supportsGemini(v1)) {
    sub_1013F5018(&v2);
  }
  sub_1013F5018(&v2);
}

void sub_100A6C454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A6C4F4(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  BasebandSettingsDeviceStateModel::create(&v2);
}

void sub_100A6C564(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100A6C57C()
{
}

double sub_100A6C584@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_100A6C5BC(int a1@<W1>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0:
      long long v2 = operator new(0x80uLL);
      v2[1] = 0;
      void v2[2] = 0;
      *long long v2 = off_101A32C40;
      sub_100944F38(v2 + 3);
    case 2:
      char v3 = operator new(0x98uLL);
      v3[1] = 0;
      void v3[2] = 0;
      void *v3 = off_101A32BF0;
      sub_100944F38(v3 + 3);
    case 5:
      long long v4 = operator new(0x80uLL);
      v4[1] = 0;
      void v4[2] = 0;
      void *v4 = off_101A32BA0;
      sub_100945004(v4 + 3);
    case 6:
      id v5 = operator new(0x80uLL);
      v5[1] = 0;
      void v5[2] = 0;
      void *v5 = off_101A32CE0;
      sub_100945004(v5 + 3);
    case 7:
      id v9 = operator new(0x80uLL);
      v9[1] = 0;
      _OWORD v9[2] = 0;
      *id v9 = off_101A32C90;
      sub_100944F38(v9 + 3);
    case 8:
      uint64_t v6 = operator new(0x80uLL);
      v6[1] = 0;
      void v6[2] = 0;
      void *v6 = off_101A32DD0;
      sub_100945004(v6 + 3);
    case 9:
      uint64_t v7 = operator new(0x80uLL);
      v7[1] = 0;
      void v7[2] = 0;
      void *v7 = off_101A32D30;
      sub_100945004(v7 + 3);
    case 10:
      id v8 = operator new(0x80uLL);
      v8[1] = 0;
      _OWORD v8[2] = 0;
      *id v8 = off_101A32D80;
      sub_100945004(v8 + 3);
    default:
      *a2 = 0;
      a2[1] = 0;
      return;
  }
}

void sub_100A6C8C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_100A6C924(BasebandSettingsFactoryInterface *this)
{
  *(void *)this = off_101A32B40;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  BasebandSettingsFactoryInterface::~BasebandSettingsFactoryInterface(this);
}

void sub_100A6C980(BasebandSettingsFactoryInterface *this)
{
  *(void *)this = off_101A32B40;
  long long v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  BasebandSettingsFactoryInterface::~BasebandSettingsFactoryInterface(this);

  operator delete();
}

uint64_t **sub_100A6C9F0(uint64_t **a1, int *a2, uint64_t a3)
{
  a1[1] = 0;
  long long v4 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    id v5 = a2;
    uint64_t v6 = 0;
    uint64_t v7 = &a2[6 * a3];
    id v8 = a1 + 1;
    while (1)
    {
      int v9 = *v5;
      id v10 = v4;
      if (v8 == v4) {
        break;
      }
      long long v11 = v6;
      char v12 = v4;
      if (v6)
      {
        do
        {
          id v10 = (uint64_t **)v11;
          long long v11 = (uint64_t *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          id v10 = (uint64_t **)v12[2];
          BOOL v13 = *v10 == (uint64_t *)v12;
          char v12 = v10;
        }
        while (v13);
      }
      if (*((_DWORD *)v10 + 8) < v9) {
        break;
      }
      uint64_t v15 = v4;
      id v14 = v4;
      if (!v6) {
        goto LABEL_25;
      }
      long long v16 = v6;
      while (1)
      {
        while (1)
        {
          id v14 = (uint64_t **)v16;
          int v17 = *((_DWORD *)v16 + 8);
          if (v17 <= v9) {
            break;
          }
          long long v16 = *v14;
          uint64_t v15 = v14;
          if (!*v14) {
            goto LABEL_25;
          }
        }
        if (v17 >= v9) {
          break;
        }
        long long v16 = v14[1];
        if (!v16)
        {
          uint64_t v15 = v14 + 1;
          goto LABEL_25;
        }
      }
LABEL_30:
      v5 += 6;
      if (v5 == v7) {
        return a1;
      }
      id v8 = (uint64_t **)*a1;
      uint64_t v6 = a1[1];
    }
    if (v6) {
      id v14 = v10;
    }
    else {
      id v14 = v4;
    }
    if (v6) {
      uint64_t v15 = v10 + 1;
    }
    else {
      uint64_t v15 = v4;
    }
    if (*v15) {
      goto LABEL_30;
    }
LABEL_25:
    long long v18 = (uint64_t *)operator new(0x38uLL);
    long long v19 = v18;
    *((_DWORD *)v18 + 8) = v9;
    uint64_t v20 = *((void *)v5 + 2);
    v18[5] = *((void *)v5 + 1);
    v18[6] = v20;
    if (v20) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
    }
    *long long v18 = 0;
    v18[1] = 0;
    void v18[2] = (uint64_t)v14;
    *uint64_t v15 = v18;
    long long v21 = (uint64_t *)**a1;
    if (v21)
    {
      *a1 = v21;
      long long v19 = *v15;
    }
    sub_100046C90(a1[1], v19);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_30;
  }
  return a1;
}

void sub_100A6CB74(_Unwind_Exception *a1)
{
  sub_10005D0E4(v1, v2);
  _Unwind_Resume(a1);
}

void sub_100A6CB8C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32BA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CBAC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32BA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CC00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CC28(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32BF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CC48(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32BF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CC9C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CCC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32C40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CCE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32C40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CD38(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CD60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32C90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CD80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32C90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CDD4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CDFC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32CE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CE1C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32CE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CE70(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CE98(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32D30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CEB8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32D30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CF0C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CF34(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32D80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CF54(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32D80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6CFA8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6CFD0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A32DD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6CFF0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A32DD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100A6D044(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

void sub_100A6D06C(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v8 = 0;
  int v9 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 24))(&v8);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = a2 + 1;
  subscriber::makeSimSlotRange();
  char v3 = v5;
  if (v5 != v6)
  {
    while ((v7(*v3) & 1) == 0)
    {
      if (++v3 == v6)
      {
        char v3 = v6;
        break;
      }
    }
    if (v3 != v6)
    {
      v4[0] = 0;
      v4[1] = 0;
      sub_100BD0640(v4);
    }
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_100A6D2C8(_Unwind_Exception *a1)
{
  sub_10005D0E4(v1, *(void **)(v1 + 8));
  long long v4 = *(std::__shared_weak_count **)(v2 - 88);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

double sub_100A6D350@<D0>(CCPreferences *a1@<X0>, _OWORD *a2@<X8>)
{
  CCPreferences::create((uint64_t *)&v4, a1);
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_100A6D388(RoamingHandlerFactoryInterface *this)
{
  *(void *)this = off_101A32E20;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  RoamingHandlerFactoryInterface::~RoamingHandlerFactoryInterface(this);
}

void sub_100A6D3E4(RoamingHandlerFactoryInterface *this)
{
  *(void *)this = off_101A32E20;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  RoamingHandlerFactoryInterface::~RoamingHandlerFactoryInterface(this);

  operator delete();
}

void sub_100A6D454()
{
}

void sub_100A6D5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, std::__shared_weak_count *a6, ...)
{
  va_start(va, a6);
  sub_100060644((uint64_t *)va);
  if (v6) {
    dispatch_release(v6);
  }
  if (a6) {
    sub_10004D2C8(a6);
  }
  _Unwind_Resume(a1);
}

void sub_100A6D61C(Registry **a1, uint64_t a2)
{
  long long v4 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, v4, LogGroupName);
  uint64_t v6 = v46;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Device supports SIM OTA provisioning over BIP", buf, 2u);
  }
  *(void *)long long buf = 0;
  uint64_t v46 = 0;
  sGetSubscriberSimInterface();
  if (*(void *)buf)
  {
    *(void *)unsigned int v43 = 0;
    char v44 = 0;
    sub_1002C1DC8((uint64_t)&qword_101B0FCE8, v43);
    uint64_t v7 = (std::__shared_weak_count_vtbl *)operator new(1uLL);
    LOBYTE(v7->~__shared_weak_count) = 1;
    uint64_t v8 = (std::__shared_weak_count *)operator new(0x30uLL);
    int v9 = v8;
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_1019B47B8;
    v8[1].__vftable = v7;
    v8[1].__shared_owners_ = (uint64_t)&v7->~__shared_weak_count + 1;
    v8[1].__shared_weak_owners_ = (uint64_t)&v7->~__shared_weak_count + 1;
    uint64_t v10 = *(void *)buf;
    uint64_t v41 = *(void *)v43;
    char v42 = v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v39 = v8 + 1;
    xpc_object_t v40 = v8;
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    xpc_object_t v48 = 0;
    v47[0] = off_1019CC928;
    v47[1] = _Block_copy(&stru_101A32E78);
    xpc_object_t v48 = v47;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, std::__shared_weak_count **, void *))(*(void *)v10 + 272))(v10, a2, &v41, 162, &v39, v47);
    sub_100060644(v47);
    if (v40) {
      sub_10004D2C8(v40);
    }
    if (v42) {
      sub_10004D2C8(v42);
    }
    CFStringRef v38 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    char v12 = ServiceMap;
    unint64_t v14 = v13;
    if ((v13 & 0x8000000000000000) != 0)
    {
      uint64_t v15 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v16 = 5381;
      do
      {
        unint64_t v14 = v16;
        unsigned int v17 = *v15++;
        uint64_t v16 = (33 * v16) ^ v17;
      }
      while (v17);
    }
    std::mutex::lock(ServiceMap);
    v36[0] = v14;
    long long v18 = sub_10004D37C(&v12[1].__m_.__sig, v36);
    if (v18)
    {
      uint64_t v20 = v18[3];
      long long v19 = (std::__shared_weak_count *)v18[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v12);
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v19);
        char v21 = 0;
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    std::mutex::unlock(v12);
    long long v19 = 0;
    char v21 = 1;
LABEL_20:
    uint64_t v24 = kOtaspLocalizationTable;
    (*(void (**)(const __CFString **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v20 + 16))(&v38, v20, kOtaspLocalizationTable, @"Starting Service Update", 1);
    if ((v21 & 1) == 0) {
      sub_10004D2C8(v19);
    }
    CFStringRef v37 = 0;
    uint64_t v25 = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v26 = v25;
    if ((v13 & 0x8000000000000000) != 0)
    {
      uint64_t v27 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        unint64_t v13 = v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(v25);
    v36[0] = v13;
    unint64_t v30 = sub_10004D37C(&v26[1].__m_.__sig, v36);
    if (v30)
    {
      uint64_t v32 = v30[3];
      id v31 = (std::__shared_weak_count *)v30[4];
      if (v31)
      {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v26);
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v31);
        char v33 = 0;
LABEL_30:
        (*(void (**)(const __CFString **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v32 + 16))(&v37, v32, v24, @"OK", 1);
        if ((v33 & 1) == 0) {
          sub_10004D2C8(v31);
        }
        _CreateSimpleUserNotificationWithButton(0x78u, v38, &stru_101AC1B28, v37);
        uint64_t v34 = (const char *)sGetLogGroupName();
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v36, v4, v34);
        xpc_object_t v35 = v36[1];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v36);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          LOWORD(v36[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_INFO, "SHOW STARTED DIALOG FOR ##UPDATE#", (uint8_t *)v36, 2u);
        }
        sub_1000558F4((const void **)&v37);
        sub_1000558F4((const void **)&v38);
        sub_10004D2C8(v9);
        if (v44) {
          sub_10004D2C8(v44);
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    std::mutex::unlock(v26);
    id v31 = 0;
    char v33 = 1;
    goto LABEL_30;
  }
  long long v22 = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v43, v4, v22);
  long long v23 = v44;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v43);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)unsigned int v43 = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "No subscriber interface to send SIM reprovision", v43, 2u);
  }
LABEL_36:
  if (v46) {
    sub_10004D2C8((std::__shared_weak_count *)v46);
  }
}

void sub_100A6DB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  sub_1000558F4(&a11);
  sub_1000558F4(&a12);
  sub_10004D2C8(v20);
  if (a18) {
    sub_10004D2C8(a18);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  _Unwind_Resume(a1);
}

void sub_100A6DBF4(id a1, BOOL a2)
{
  BOOL v2 = a2;
  char v3 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v6, v3, LogGroupName);
  id v5 = v7;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v6);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6[0] = 67109120;
    v6[1] = v2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Sent SIM reprovision: %d", (uint8_t *)v6, 8u);
  }
}

uint64_t sub_100A6DCC0(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  BOOL v2 = ServiceMap;
  if (v3 < 0)
  {
    long long v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      uint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v15 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, (unint64_t *)&v15);
  if (!v7)
  {
    std::mutex::unlock(v2);
    goto LABEL_9;
  }
  uint64_t v9 = v7[3];
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (!v8)
  {
    std::mutex::unlock(v2);
    if (v9) {
      goto LABEL_11;
    }
LABEL_9:
    uint64_t v10 = 0;
    goto LABEL_18;
  }
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v2);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  if (!v9)
  {
    uint64_t v10 = 0;
LABEL_17:
    sub_10004D2C8(v8);
    goto LABEL_18;
  }
LABEL_11:
  long long v15 = 0uLL;
  sub_1006E3F34(v9, &v15);
  if ((void)v15) {
    uint64_t v10 = (*(uint64_t (**)(void))(*(void *)v15 + 96))(v15);
  }
  else {
    uint64_t v10 = 0;
  }
  if (*((void *)&v15 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
  }
  if (v8) {
    goto LABEL_17;
  }
LABEL_18:
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v15, kCtLoggingSystemName, LogGroupName);
  char v12 = *((void *)&v15 + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v15);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
  {
    unint64_t v13 = "false";
    if (v10) {
      unint64_t v13 = "true";
    }
    LODWORD(v15) = 136315138;
    *(void *)((char *)&v15 + 4) = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Supports OTA %s", (uint8_t *)&v15, 0xCu);
  }
  return v10;
}

void sub_100A6DEB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100A6DEFC(void *a1)
{
  *a1 = off_101A32EA8;
  BOOL v2 = a1[1];
  if (v2) {
    dispatch_release(v2);
  }
  return a1;
}

void sub_100A6DF48(void *a1)
{
  *a1 = off_101A32EA8;
  uint64_t v1 = a1[1];
  if (v1) {
    dispatch_release(v1);
  }

  operator delete();
}

void *sub_100A6DFB4(uint64_t a1)
{
  BOOL v2 = operator new(0x10uLL);
  uint64_t v3 = *(NSObject **)(a1 + 8);
  *BOOL v2 = off_101A32EA8;
  v2[1] = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  return v2;
}

void sub_100A6E00C(uint64_t a1, void *a2)
{
  BOOL v2 = *(NSObject **)(a1 + 8);
  *a2 = off_101A32EA8;
  a2[1] = v2;
  if (v2) {
    dispatch_retain(v2);
  }
}

void sub_100A6E038(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (v1) {
    dispatch_release(v1);
  }
}

void sub_100A6E048(void *__p)
{
  BOOL v2 = __p[1];
  if (v2) {
    dispatch_release(v2);
  }

  operator delete(__p);
}

intptr_t sub_100A6E088(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  long long v4 = (const char *)kCtLoggingSystemName;
  LogGroupName = (const char *)sGetLogGroupName();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, v4, LogGroupName);
  unsigned int v6 = *(NSObject **)&v10[4];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = "complete";
    if (!v3) {
      uint64_t v7 = "failed";
    }
    int v9 = 136315138;
    *(void *)uint64_t v10 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "CSIM reset %s", (uint8_t *)&v9, 0xCu);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 8));
}

uint64_t sub_100A6E180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100A6E1C0()
{
}

uint64_t sub_100A6E1CC()
{
  qword_101B0FCE8 = 0;
  qword_101B0FCF0 = 0;
  qword_101B0FCF8 = 0;
  char v0 = operator new(0xFuLL);
  qword_101B0FCF0 = (uint64_t)v0 + 15;
  qword_101B0FCF8 = (uint64_t)v0 + 15;
  *(void *)char v0 = 0x15F14430000000A0;
  v0[2] = 16868198;
  *((_WORD *)v0 + 6) = 18755;
  *((unsigned char *)v0 + 14) = 49;
  qword_101B0FCE8 = (uint64_t)v0;

  return __cxa_atexit((void (*)(void *))sub_1007D9B0C, &qword_101B0FCE8, (void *)&_mh_execute_header);
}

void *sub_100A6E6E4(void *a1, NSObject **a2, void *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "gf.loc.ctrl");
  sub_100A6E818(a1 + 2, a2, &v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *a1 = off_101A32F28;
  a1[1] = off_101A32FE8;
  a1[7] = 0;
  a1[8] = *a3;
  uint64_t v6 = a3[1];
  a1[9] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100A6E7EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CTLocationControllerDelegateInterface::~CTLocationControllerDelegateInterface(v10);
  GeofenceControllerInterface::~GeofenceControllerInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_100A6E818(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_100A6E880(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void sub_100A6E8A4(uint64_t a1)
{
  *(void *)a1 = off_101A32F28;
  BOOL v2 = (CTLocationControllerDelegateInterface *)(a1 + 8);
  *(void *)(a1 + 8) = off_101A32FE8;
  int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 48));
  sub_100087E88((void *)(a1 + 16));
  CTLocationControllerDelegateInterface::~CTLocationControllerDelegateInterface(v2);

  GeofenceControllerInterface::~GeofenceControllerInterface((GeofenceControllerInterface *)a1);
}

void sub_100A6E950(uint64_t a1)
{
}

void sub_100A6E958(uint64_t a1)
{
  sub_100A6E8A4(a1);

  operator delete();
}

void sub_100A6E990(uint64_t a1)
{
  sub_100A6E8A4(a1 - 8);

  operator delete();
}

id sub_100A6E9CC(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 56);
  if (v2)
  {
    return objc_msgSend(v2, "isLocationServiceEnabled_sync");
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

id sub_100A6EA60(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 56);
  if (v2)
  {
    return objc_msgSend(v2, "isCircularGeofenceSupported_sync");
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

id sub_100A6EAF4(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 56);
  if (v2)
  {
    return objc_msgSend(v2, "isPolygonalGeofenceSupported_sync");
  }
  else
  {
    int v3 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

void sub_100A6EB88(uint64_t a1, double *a2, uint64_t *a3)
{
  if (*(void *)(a1 + 56))
  {
    id v6 = objc_alloc((Class)NSString);
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v7 = a3;
    }
    else {
      uint64_t v7 = (uint64_t *)*a3;
    }
    id v9 = [v6 initWithUTF8String:v7];
    objc_msgSend(*(id *)(a1 + 56), "setupCircularGeoFence:withName:", *a2, a2[1], a2[2]);
  }
  else
  {
    OsLogContext v8 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invalid Location module", buf, 2u);
    }
  }
}

void sub_100A6EC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100A6EC7C(uint64_t a1@<X0>, long long **a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (*(void *)(a1 + 56))
  {
    id v8 = objc_alloc((Class)NSString);
    if (*((char *)a3 + 23) >= 0) {
      id v9 = a3;
    }
    else {
      id v9 = (uint64_t *)*a3;
    }
    id v10 = [v8 initWithUTF8String:v9];
    long long v11 = *(void **)(a1 + 56);
    unsigned int v17 = 0;
    uint64_t v18 = 0;
    std::string __p = 0;
    sub_100952E7C((char *)&__p, *a2, a2[1], a2[1] - *a2);
    char v12 = [v11 setupPolygonalGeoFence:&__p withName:v10];
    unint64_t v13 = operator new(0x28uLL);
    v13[1] = 0;
    v13[2] = 0;
    *unint64_t v13 = off_101A33110;
    id v14 = v12;
    *((_DWORD *)v13 + 6) = 0;
    v13[4] = v14;
    *a4 = v13 + 3;
    a4[1] = v13;

    if (__p)
    {
      unsigned int v17 = __p;
      operator delete(__p);
    }
  }
  else
  {
    long long v15 = *(NSObject **)(a1 + 48);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Invalid Location module", buf, 2u);
    }
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_100A6EDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100A6EDF0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v3 = *(NSObject **)(a1 + 48);
  long long v4 = *(void **)(a1 + 56);
  if (v4)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) >= 0) {
        id v8 = a3;
      }
      else {
        id v8 = (uint64_t *)*a3;
      }
      int v10 = 136315138;
      long long v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Attempting to stop geofencing for[%s]", (uint8_t *)&v10, 0xCu);
      long long v4 = *(void **)(a1 + 56);
    }
    id v9 = *(id *)(*(void *)a2 + 8);
    [v4 stopGeofence:v9];
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_ERROR))
  {
    LOWORD(v1ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", (uint8_t *)&v10, 2u);
  }
}

void sub_100A6EF1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A6EF34(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  BOOL v2 = *(void **)(a1 + 56);
  if (v2)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Attempting to reset monitored regions", v4, 2u);
      BOOL v2 = *(void **)(a1 + 56);
    }
    [v2 resetMonitoredRegions];
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 48), OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Invalid Location module", buf, 2u);
  }
}

void sub_100A6EFF0(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  int v10 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Starting CTLocationController..", v16, 2u);
  }
  if (*((char *)a3 + 23) < 0) {
    a3 = (uint64_t *)*a3;
  }
  long long v11 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a3, +[NSString defaultCStringEncoding]);
  char v12 = [CTLocationController alloc];
  unint64_t v13 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v12;

  id v14 = [*(id *)(a1 + 56) initWithBundleIdentifier:v11 withDistanceFilter:*a4 withDesiredAccuracy:*a5 withQueue:a2 withDelegate:a1 + 8];
  long long v15 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v14;
}

void sub_100A6F0F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100A6F104(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Ending..", v2, 2u);
  }
}

id sub_100A6F164(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 48);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Requesting for location", v4, 2u);
  }
  return [*(id *)(a1 + 56) requestLocation];
}

void sub_100A6F1D0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6F328(uint64_t a1, uint64_t a2)
{
}

void sub_100A6F330(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6F488(uint64_t a1, uint64_t a2)
{
}

void sub_100A6F490(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6F5E8(uint64_t a1, uint64_t a2)
{
}

void sub_100A6F5F0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6F748(uint64_t a1, uint64_t a2)
{
}

void sub_100A6F750(uint64_t a1, uint64_t a2, int *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v7 = *a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6F8BC(uint64_t a1, uint64_t a2, int *a3)
{
}

void sub_100A6F8C4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6F9A4(uint64_t a1)
{
}

void sub_100A6F9AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6FA9C(uint64_t a1)
{
}

void sub_100A6FAA4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6FBFC(uint64_t a1, uint64_t a2)
{
}

void sub_100A6FC04(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6FD5C(uint64_t a1, uint64_t a2)
{
}

void sub_100A6FD64(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100A6FE58(uint64_t a1)
{
}

void sub_100A6FE60(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A33110;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100A6FE80(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A33110;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100A6FED4(uint64_t a1)
{
}

uint64_t *sub_100A6FEE0(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    id v9 = v1 + 8;
    if (v1[31] < 0) {
      id v9 = (void *)*v9;
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v13 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Geofence setup error %{public}s", buf, 0xCu);
  }
  long long v4 = *(std::__shared_weak_count **)(v2 + 72);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)(v2 + 64);
      if (v7) {
        (*(void (**)(uint64_t, char *))(*(void *)v7 + 16))(v7, v1 + 8);
      }
      sub_10004D2C8(v6);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A6FFFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A70020(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = v1 + 8;
    if (v1[31] < 0) {
      long long v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Geofence setup success%{public}s", buf, 0xCu);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    id v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 24))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A70138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A7015C(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = v1 + 8;
    if (v1[31] < 0) {
      long long v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitoring started for %{public}s", buf, 0xCu);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    id v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 24))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A70274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A70298(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = v1 + 8;
    if (v1[31] < 0) {
      long long v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Monitoring failed for %{public}s", buf, 0xCu);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    id v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 32))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A703B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A703D4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    long long v4 = (void *)(v1 + 8);
    if (*(char *)(v1 + 31) < 0) {
      long long v4 = (void *)*v4;
    }
    int v5 = *(_DWORD *)(v1 + 32);
    *(_DWORD *)long long buf = 136446466;
    id v14 = v4;
    __int16 v15 = 1024;
    int v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Geofence didDetermineState for %{public}s as state %d", buf, 0x12u);
  }
  id v6 = *(std::__shared_weak_count **)(v2 + 72);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(v2 + 64);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 40))(v9, v1 + 8, v1 + 32);
      }
      sub_10004D2C8(v8);
    }
  }
  sub_100A3A2EC(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_100A70500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100A3A2EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100A70524(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[6];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Monitoring failed with error...", buf, 2u);
  }
  int v3 = (std::__shared_weak_count *)v1[9];
  if (v3)
  {
    long long v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = v1[8];
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_100A70600()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100A70634(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)**a1;
  int v3 = v2[6];
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *((unsigned __int8 *)v1 + 8);
    *(_DWORD *)long long buf = 67109120;
    int v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Location services status changed to %d", buf, 8u);
  }
  int v5 = (std::__shared_weak_count *)v2[9];
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = v2[8];
      if (v8) {
        (*(void (**)(uint64_t, void))(*(void *)v8 + 56))(v8, *((unsigned __int8 *)v1 + 8));
      }
      sub_10004D2C8(v7);
    }
  }
  operator delete();
}

void sub_100A70750()
{
  sub_10004D2C8(v0);
  operator delete();
}

uint64_t *sub_100A70784(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = v1 + 8;
    if (v1[31] < 0) {
      int v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Geofence Entry %{public}s", buf, 0xCu);
  }
  int v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void (****)(void, char *))(v2 + 64);
      if (v8) {
        (**v8)(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A7089C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100A708C0(char **a1)
{
  uint64_t v1 = *a1;
  int v10 = a1;
  long long v11 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = *(NSObject **)(*(void *)v1 + 48);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = v1 + 8;
    if (v1[31] < 0) {
      int v4 = (void *)*v4;
    }
    *(_DWORD *)long long buf = 136446210;
    unint64_t v13 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Geofence Exit %{public}s", buf, 0xCu);
  }
  int v5 = *(std::__shared_weak_count **)(v2 + 72);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(v2 + 64);
      if (v8) {
        (*(void (**)(uint64_t, char *))(*(void *)v8 + 8))(v8, v1 + 8);
      }
      sub_10004D2C8(v7);
    }
  }
  sub_10008E880((uint64_t *)&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_100A709D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_10008E880(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100A709FC(double **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)*a1;
  int v3 = *(std::__shared_weak_count **)(v2 + 72);
  if (v3)
  {
    int v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = *(void *)(v2 + 64);
      if (v6) {
        (*(void (**)(uint64_t, double, double))(*(void *)v6 + 64))(v6, v1[1], v1[2]);
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_100A70AA0()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100A70AD4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100A70B40()
{
}

uint64_t sub_100A70B64(uint64_t a1, int a2)
{
  int v4 = (ctu::OsLogLogger *)(a1 + 8);
  int v5 = "pb.mdl.?";
  if (a2 == 2) {
    int v5 = "pb.mdl.2";
  }
  if (a2 == 1) {
    uint64_t v6 = "pb.mdl.1";
  }
  else {
    uint64_t v6 = v5;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, v6);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &v8);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A33160;
  *(_DWORD *)(a1 + 32) = a2;
  *(void *)(a1 + 36) = 0x600000006;
  PBCapabilities::PrimaryNumber::PrimaryNumber((PBCapabilities::PrimaryNumber *)(a1 + 44));
  PBCapabilities::Groups::Groups((PBCapabilities::Groups *)(a1 + 56));
  PBCapabilities::AdditionaNumber::AdditionaNumber((PBCapabilities::AdditionaNumber *)(a1 + 58));
  PBCapabilities::Email::Email((PBCapabilities::Email *)(a1 + 61));
  PBCapabilities::SecondName::SecondName((PBCapabilities::SecondName *)(a1 + 63));
  PBCapabilities::HiddenRecords::HiddenRecords((PBCapabilities::HiddenRecords *)(a1 + 64));
  *(void *)(a1 + 8ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = a1 + 80;
  sub_1002AE1CC(a1 + 96);
  *(_WORD *)(a1 + 48ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = 0;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 488));
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 624));
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 760));
  *(unsigned char *)(a1 + 896) = 1;
  CSIPhoneNumber::CSIPhoneNumber((CSIPhoneNumber *)(a1 + 904));
  *(void *)(a1 + 1056) = 0;
  *(void *)(a1 + 1048) = 0;
  *(void *)(a1 + 104ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a1 + 1048;
  return a1;
}

void sub_100A70CEC(_Unwind_Exception *a1)
{
  uint64_t v8 = v3;
  sub_100087E24(v8);
  sub_100087E24(v6);
  sub_100087E24(v5);
  sub_100039D40(v4);
  sub_100A72A70(*v7);
  int v10 = (std::__shared_weak_count *)*((void *)v1 + 3);
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  ctu::OsLogLogger::~OsLogLogger(v2);
  PhonebookModelInterface::~PhonebookModelInterface(v1);
  _Unwind_Resume(a1);
}

void sub_100A70D90(uint64_t a1)
{
  *(void *)a1 = off_101A33160;
  sub_10005D144(*(void **)(a1 + 1048));
  if (*(char *)(a1 + 1015) < 0) {
    operator delete(*(void **)(a1 + 992));
  }
  if (*(char *)(a1 + 991) < 0) {
    operator delete(*(void **)(a1 + 968));
  }
  if (*(char *)(a1 + 959) < 0) {
    operator delete(*(void **)(a1 + 936));
  }
  if (*(char *)(a1 + 935) < 0) {
    operator delete(*(void **)(a1 + 912));
  }
  if (*(char *)(a1 + 871) < 0) {
    operator delete(*(void **)(a1 + 848));
  }
  if (*(char *)(a1 + 847) < 0) {
    operator delete(*(void **)(a1 + 824));
  }
  if (*(char *)(a1 + 815) < 0) {
    operator delete(*(void **)(a1 + 792));
  }
  if (*(char *)(a1 + 791) < 0) {
    operator delete(*(void **)(a1 + 768));
  }
  if (*(char *)(a1 + 735) < 0) {
    operator delete(*(void **)(a1 + 712));
  }
  if (*(char *)(a1 + 711) < 0) {
    operator delete(*(void **)(a1 + 688));
  }
  if (*(char *)(a1 + 679) < 0) {
    operator delete(*(void **)(a1 + 656));
  }
  if (*(char *)(a1 + 655) < 0) {
    operator delete(*(void **)(a1 + 632));
  }
  if (*(char *)(a1 + 599) < 0) {
    operator delete(*(void **)(a1 + 576));
  }
  if (*(char *)(a1 + 575) < 0) {
    operator delete(*(void **)(a1 + 552));
  }
  if (*(char *)(a1 + 543) < 0) {
    operator delete(*(void **)(a1 + 520));
  }
  if (*(char *)(a1 + 519) < 0) {
    operator delete(*(void **)(a1 + 496));
  }
  sub_100039D40(a1 + 96);
  sub_100A72A70(*(void **)(a1 + 80));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  PhonebookModelInterface::~PhonebookModelInterface((PhonebookModelInterface *)a1);
}

void sub_100A70F10(uint64_t a1)
{
  sub_100A70D90(a1);

  operator delete();
}

void sub_100A70F48(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 80);
  sub_100A72A70(*(void **)(a1 + 80));
  *(v1 - 1) = v1;
  void *v1 = 0;
  v1[1] = 0;
}

uint64_t sub_100A70F78(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

uint64_t sub_100A70F80(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_100A70F88(uint64_t result, int a2)
{
  *(_DWORD *)(result + 4ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a2;
  return result;
}

BOOL sub_100A70F90(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = a2;
  unint64_t v4 = *(void *)(a1 + 88);
  if (v4 > a2)
  {
    uint64_t v5 = *(void **)(a1 + 72);
    if (a2)
    {
      for (int i = 0; i != a2; ++i)
      {
        uint64_t v7 = (void *)v5[1];
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v5[2];
            BOOL v9 = *v8 == (void)v5;
            uint64_t v5 = v8;
          }
          while (!v9);
        }
        uint64_t v5 = v8;
      }
    }
    else
    {
      uint64_t v8 = *(void **)(a1 + 72);
    }
    sub_100A71020(a3, (uint64_t)(v8 + 5));
  }
  return v4 > v3;
}

uint64_t sub_100A71020(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v3 = a2;
    *(void *)a1 = *(void *)a2;
    std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
    *(void *)(a1 + 32) = *(void *)(v3 + 32);
    std::string::operator=((std::string *)(a1 + 40), (const std::string *)(v3 + 40));
    std::string::operator=((std::string *)(a1 + 64), (const std::string *)(v3 + 64));
    char v4 = *(unsigned char *)(v3 + 92);
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(v3 + 88);
    *(unsigned char *)(a1 + 92) = v4;
    std::string::operator=((std::string *)(a1 + 96), (const std::string *)(v3 + 96));
    std::string::operator=((std::string *)(a1 + 120), (const std::string *)(v3 + 120));
    long long v5 = *(_OWORD *)(v3 + 144);
    *(unsigned char *)(a1 + 16ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(unsigned char *)(v3 + 160);
    *(_OWORD *)(a1 + 144) = v5;
    uint64_t v6 = *(void *)(v3 + 168);
    v3 += 168;
    *(void *)(a1 + 168) = v6;
    std::string::operator=((std::string *)(a1 + 176), (const std::string *)(v3 + 8));
    std::string::operator=((std::string *)(a1 + 200), (const std::string *)(v3 + 32));
    char v7 = *(unsigned char *)(v3 + 60);
    *(_DWORD *)(a1 + 224) = *(_DWORD *)(v3 + 56);
    *(unsigned char *)(a1 + 228) = v7;
    std::string::operator=((std::string *)(a1 + 232), (const std::string *)(v3 + 64));
    std::string::operator=((std::string *)(a1 + 256), (const std::string *)(v3 + 88));
    char v8 = *(unsigned char *)(v3 + 128);
    *(_OWORD *)(a1 + 28ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(_OWORD *)(v3 + 112);
    *(unsigned char *)(a1 + 296) = v8;
    std::string::operator=((std::string *)(a1 + 304), (const std::string *)(v3 + 136));
    std::string::operator=((std::string *)(a1 + 328), (const std::string *)(v3 + 160));
    std::string::operator=((std::string *)(a1 + 352), (const std::string *)(v3 + 184));
    *(unsigned char *)(a1 + 376) = *(unsigned char *)(v3 + 208);
  }
  return a1;
}

void sub_100A71148(void *a1, unsigned int a2)
{
  char v4 = a1 + 10;
  uint64_t v3 = (uint64_t *)a1[10];
  if (v3)
  {
    long long v5 = v4;
    uint64_t v6 = v3;
    do
    {
      unsigned int v7 = *((_DWORD *)v6 + 8);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        BOOL v9 = (uint64_t **)v6;
      }
      else {
        BOOL v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        long long v5 = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && *((_DWORD *)v5 + 8) <= a2)
    {
      int v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          int v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          long long v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if ((uint64_t *)a1[9] == v5) {
        a1[9] = v11;
      }
      --a1[11];
      sub_10005EE6C(v3, v5);
      sub_100039D40((uint64_t)(v5 + 5));
      operator delete(v5);
    }
  }
}

uint64_t sub_100A71228(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t sub_100A71230(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 57) = *(void *)((char *)a2 + 13);
  *(_OWORD *)(a1 + 44) = v2;
  return (*(uint64_t (**)(void))(*(void *)a1 + 264))();
}

uint64_t sub_100A7126C(uint64_t a1)
{
  return a1 + 44;
}

void sub_100A71274(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  char v4 = *(void **)(a2 + 8);
  if (*(void **)a2 != v4)
  {
    long long v5 = (uint64_t *)(a1 + 80);
    do
    {
      *(_DWORD *)long long buf = *v3;
      sub_100039E24((uint64_t)&buf[8], (uint64_t)v3);
      uint64_t v6 = *v5;
      unsigned int v7 = (void *)(a1 + 80);
      BOOL v8 = (void *)(a1 + 80);
      if (*v5)
      {
        while (1)
        {
          while (1)
          {
            BOOL v8 = (void *)v6;
            unsigned int v9 = *(_DWORD *)(v6 + 32);
            if (v9 <= *(_DWORD *)buf) {
              break;
            }
            uint64_t v6 = *v8;
            unsigned int v7 = v8;
            if (!*v8) {
              goto LABEL_10;
            }
          }
          if (v9 >= *(_DWORD *)buf) {
            break;
          }
          uint64_t v6 = v8[1];
          if (!v6)
          {
            unsigned int v7 = v8 + 1;
            goto LABEL_10;
          }
        }
      }
      else
      {
LABEL_10:
        uint64_t v36 = 0;
        int v10 = operator new(0x1A8uLL);
        *(void *)&long long v35 = v10;
        *((void *)&v35 + 1) = v5;
        v10[8] = *(_DWORD *)buf;
        sub_100039E24((uint64_t)(v10 + 10), (uint64_t)&buf[8]);
        LOBYTE(v36) = 1;
        *(void *)int v10 = 0;
        *((void *)v10 + 1) = 0;
        *((void *)v10 + 2) = v8;
        void *v7 = v10;
        uint64_t v11 = **(void **)(a1 + 72);
        if (v11)
        {
          *(void *)(a1 + 72) = v11;
          int v10 = (_DWORD *)*v7;
        }
        sub_100046C90(*(uint64_t **)(a1 + 80), (uint64_t *)v10);
        ++*(void *)(a1 + 88);
        *(void *)&long long v35 = 0;
        sub_100A72AC4((uint64_t)&v35);
      }
      sub_100039D40((uint64_t)&buf[8]);
      v3 += 48;
    }
    while (v3 != v4);
  }
  uint64_t v12 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 88);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Phone Book Size: %ld", buf, 0xCu);
  }
  id v14 = *(void **)(a1 + 72);
  if (v14 != (void *)(a1 + 80))
  {
    do
    {
      __int16 v15 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = v14[5];
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Record ID: %ld", buf, 0xCu);
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v17 = v14 + 6;
        if (*((char *)v14 + 71) >= 0)
        {
          uint64_t v18 = *((unsigned __int8 *)v14 + 71);
        }
        else
        {
          unsigned int v17 = (void *)v14[6];
          uint64_t v18 = v14[7];
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v17;
        __int16 v32 = 2048;
        uint64_t v33 = v18;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Name: %s, Length:%ld", buf, 0x16u);
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)(v14 + 9));
        int v19 = v34;
        uint64_t v20 = *(unsigned char **)buf;
        CSIPhoneNumber::getFullNumber((uint64_t *)&v35, (CSIPhoneNumber *)(v14 + 9));
        char v21 = buf;
        if (v19 < 0) {
          char v21 = v20;
        }
        uint64_t v22 = HIBYTE(v36);
        if (v36 < 0) {
          uint64_t v22 = *((void *)&v35 + 1);
        }
        *(_DWORD *)CFStringRef v37 = 136315394;
        CFStringRef v38 = v21;
        __int16 v39 = 2048;
        uint64_t v40 = v22;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Number: %s, Length: %ld", v37, 0x16u);
        if (SHIBYTE(v36) < 0) {
          operator delete((void *)v35);
        }
        if (v34 < 0) {
          operator delete(*(void **)buf);
        }
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        CSIPhoneNumber::getFullNumber((uint64_t *)buf, (CSIPhoneNumber *)(v14 + 26));
        if (v34 >= 0) {
          long long v23 = buf;
        }
        else {
          long long v23 = *(unsigned char **)buf;
        }
        LODWORD(v35) = 136315138;
        *(void *)((char *)&v35 + 4) = v23;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Additional Number: %s", (uint8_t *)&v35, 0xCu);
        if (v34 < 0) {
          operator delete(*(void **)buf);
        }
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = v14 + 43;
        if (*((char *)v14 + 367) < 0) {
          uint64_t v24 = (void *)v14[43];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Group: %s", buf, 0xCu);
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = v14 + 46;
        if (*((char *)v14 + 391) < 0) {
          uint64_t v25 = (void *)v14[46];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v25;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Second Name: %s", buf, 0xCu);
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v26 = v14 + 49;
        if (*((char *)v14 + 415) < 0) {
          uint64_t v26 = (void *)v14[49];
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v26;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Email: %s", buf, 0xCu);
        __int16 v15 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = *((unsigned __int8 *)v14 + 416);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v27;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Hidden: %d", buf, 8u);
      }
      uint64_t v28 = (void *)v14[1];
      if (v28)
      {
        do
        {
          unsigned int v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          unsigned int v29 = (void *)v14[2];
          BOOL v30 = *v29 == (void)v14;
          id v14 = v29;
        }
        while (!v30);
      }
      id v14 = v29;
    }
    while (v29 != (void *)(a1 + 80));
  }
}

void sub_100A717B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100A717FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_100A71804(uint64_t a1, uint64_t a2)
{
  return sub_100A71020(a1 + 96, a2);
}

uint64_t sub_100A7180C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 48ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = a2;
  return result;
}

uint64_t sub_100A71814(uint64_t result, char a2)
{
  *(unsigned char *)(result + 481) = a2;
  return result;
}

__n128 sub_100A7181C(uint64_t a1, uint64_t a2)
{
  char v4 = (__n128 *)(a1 + 488);
  *(void *)(a1 + 488) = *(void *)a2;
  std::string::operator=((std::string *)(a1 + 496), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 520), (const std::string *)(a2 + 32));
  char v5 = *(unsigned char *)(a2 + 60);
  *(_DWORD *)(a1 + 544) = *(_DWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 548) = v5;
  std::string::operator=((std::string *)(a1 + 552), (const std::string *)(a2 + 64));
  std::string::operator=((std::string *)(a1 + 576), (const std::string *)(a2 + 88));
  char v6 = *(unsigned char *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 112);
  v4[7] = result;
  *(unsigned char *)(a1 + 616) = v6;
  return result;
}

__n128 sub_100A718A0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 624) = *(void *)a2;
  std::string::operator=((std::string *)(a1 + 632), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 656), (const std::string *)(a2 + 32));
  char v4 = *(unsigned char *)(a2 + 60);
  *(_DWORD *)(a1 + 68ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(_DWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 684) = v4;
  std::string::operator=((std::string *)(a1 + 688), (const std::string *)(a2 + 64));
  std::string::operator=((std::string *)(a1 + 712), (const std::string *)(a2 + 88));
  char v5 = *(unsigned char *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 112);
  *(__n128 *)(a1 + 736) = result;
  *(unsigned char *)(a1 + 752) = v5;
  return result;
}

__n128 sub_100A71918(uint64_t a1, uint64_t a2)
{
  char v4 = (__n128 *)(a1 + 760);
  *(void *)(a1 + 76ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(void *)a2;
  std::string::operator=((std::string *)(a1 + 768), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 792), (const std::string *)(a2 + 32));
  char v5 = *(unsigned char *)(a2 + 60);
  *(_DWORD *)(a1 + 816) = *(_DWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 82ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = v5;
  std::string::operator=((std::string *)(a1 + 824), (const std::string *)(a2 + 64));
  std::string::operator=((std::string *)(a1 + 848), (const std::string *)(a2 + 88));
  char v6 = *(unsigned char *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 112);
  v4[7] = result;
  *(unsigned char *)(a1 + 888) = v6;
  return result;
}

uint64_t sub_100A7199C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 896) = a2;
  return result;
}

BOOL sub_100A719A4(unsigned char *a1)
{
  return a1[896] && !a1[480] && a1[481] != 0;
}

__n128 sub_100A719CC(uint64_t a1, uint64_t a2)
{
  char v4 = (__n128 *)(a1 + 904);
  *(void *)(a1 + 904) = *(void *)a2;
  std::string::operator=((std::string *)(a1 + 912), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 936), (const std::string *)(a2 + 32));
  char v5 = *(unsigned char *)(a2 + 60);
  *(_DWORD *)(a1 + 96ResetAllPacketHandlersAPNs(1, 16, 0xFFFFFFFFLL, 0) = *(_DWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 964) = v5;
  std::string::operator=((std::string *)(a1 + 968), (const std::string *)(a2 + 64));
  std::string::operator=((std::string *)(a1 + 992), (const std::string *)(a2 + 88));
  char v6 = *(unsigned char *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 112);
  v4[7] = result;
  *(unsigned char *)(a1 + 1032) = v6;
  return result;
}

uint64_t sub_100A71A50(uint64_t a1)
{
  return a1 + 904;
}

void sub_100A71A58(void *a1, void *a2)
{
  long long v2 = (uint64_t **)(a1 + 130);
  if (a1 + 130 == a2) {
    return;
  }
  char v4 = a2 + 1;
  char v5 = (void *)*a2;
  if (a1[132])
  {
    uint64_t v6 = a1[130];
    unsigned int v7 = (uint64_t **)(a1 + 131);
    a1[130] = a1 + 131;
    *(void *)(a1[131] + 16) = 0;
    a1[132] = 0;
    a1[131] = 0;
    if (*(void *)(v6 + 8)) {
      uint64_t v8 = *(void *)(v6 + 8);
    }
    else {
      uint64_t v8 = v6;
    }
    if (v8)
    {
      unsigned int v9 = sub_1000EA590(v8);
      if (v5 == v4)
      {
        uint64_t v11 = (void *)v8;
      }
      else
      {
        int v10 = v5;
        do
        {
          uint64_t v11 = v9;
          int v12 = *((_DWORD *)v10 + 7);
          *(_DWORD *)(v8 + 28) = v12;
          uint64_t v13 = *v7;
          id v14 = (uint64_t **)(a1 + 131);
          __int16 v15 = (uint64_t **)(a1 + 131);
          if (*v7)
          {
            do
            {
              while (1)
              {
                id v14 = (uint64_t **)v13;
                if (v12 >= *((_DWORD *)v13 + 7)) {
                  break;
                }
                uint64_t v13 = (uint64_t *)*v13;
                __int16 v15 = v14;
                if (!*v14) {
                  goto LABEL_15;
                }
              }
              uint64_t v13 = (uint64_t *)v13[1];
            }
            while (v13);
            __int16 v15 = v14 + 1;
          }
LABEL_15:
          sub_100046C38(v2, (uint64_t)v14, v15, (uint64_t *)v8);
          if (v9) {
            unsigned int v9 = sub_1000EA590((uint64_t)v9);
          }
          else {
            unsigned int v9 = 0;
          }
          uint64_t v16 = (void *)v10[1];
          if (v16)
          {
            do
            {
              char v5 = v16;
              uint64_t v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              char v5 = (void *)v10[2];
              BOOL v17 = *v5 == (void)v10;
              int v10 = v5;
            }
            while (!v17);
          }
          if (!v11) {
            break;
          }
          uint64_t v8 = (uint64_t)v11;
          int v10 = v5;
        }
        while (v5 != v4);
      }
      sub_10005D144(v11);
      if (!v9) {
        goto LABEL_33;
      }
      for (int i = (void *)v9[2]; i; int i = (void *)i[2])
        unsigned int v9 = i;
      uint64_t v18 = v9;
    }
    else
    {
      uint64_t v18 = 0;
    }
    sub_10005D144(v18);
  }
LABEL_33:
  if (v5 != v4)
  {
    uint64_t v20 = (uint64_t **)(a1 + 131);
    do
    {
      int v21 = *((_DWORD *)v5 + 7);
      uint64_t v22 = (uint64_t *)operator new(0x20uLL);
      *((_DWORD *)v22 + 7) = v21;
      long long v23 = *v20;
      uint64_t v24 = v20;
      uint64_t v25 = v20;
      if (*v20)
      {
        do
        {
          while (1)
          {
            uint64_t v24 = (uint64_t **)v23;
            if (*((_DWORD *)v23 + 7) <= v21) {
              break;
            }
            long long v23 = (uint64_t *)*v23;
            uint64_t v25 = v24;
            if (!*v24) {
              goto LABEL_41;
            }
          }
          long long v23 = (uint64_t *)v23[1];
        }
        while (v23);
        uint64_t v25 = v24 + 1;
      }
LABEL_41:
      sub_100046C38(v2, (uint64_t)v24, v25, v22);
      uint64_t v26 = (void *)v5[1];
      if (v26)
      {
        do
        {
          int v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          int v27 = (void *)v5[2];
          BOOL v17 = *v27 == (void)v5;
          char v5 = v27;
        }
        while (!v17);
      }
      char v5 = v27;
    }
    while (v27 != v4);
  }
}

BOOL sub_100A71C78(uint64_t a1, int a2)
{
  long long v2 = *(void **)(a1 + 1040);
  uint64_t v3 = (void *)(a1 + 1048);
  if (v2 != (void *)(a1 + 1048))
  {
    while (*((_DWORD *)v2 + 7) != a2)
    {
      char v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          char v5 = v4;
          char v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          char v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          long long v2 = v5;
        }
        while (!v6);
      }
      long long v2 = v5;
      if (v5 == v3)
      {
        long long v2 = (void *)(a1 + 1048);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}